diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/Documentation/fb/00-INDEX linux-2.6.23.1-stm/Documentation/fb/00-INDEX
--- linux-2.6.23.1/Documentation/fb/00-INDEX	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/Documentation/fb/00-INDEX	2007-11-01 12:00:41.000000000 +0000
@@ -19,6 +19,8 @@
 	- info on the Matrox frame buffer driver
 pvr2fb.txt
 	- info on the PowerVR 2 frame buffer driver
+splash.txt
+	- info on the Framebuffer Splash
 tgafb.txt
 	- info on the TGA (DECChip 21030) frame buffer driver
 vesafb.txt
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/Documentation/fb/splash.txt linux-2.6.23.1-stm/Documentation/fb/splash.txt
--- linux-2.6.23.1/Documentation/fb/splash.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/Documentation/fb/splash.txt	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,207 @@
+What is it?
+-----------
+
+The framebuffer splash is a kernel feature that allows displaying a background
+picture on selected consoles.
+
+What do I need to get it to work?
+---------------------------------
+
+To get fb splash up-and-running you will have to:
+ 1) get a copy of splashutils [1] or a similar program
+ 2) get some splash themes
+ 3) build the kernel helper program
+ 4) build your kernel with the FB_SPLASH option enabled.
+
+To get fbsplash operational right after fbcon initialization is finished, you
+will have to include a theme and the kernel helper into your initramfs image.
+Please refer to splashutils documentation for instructions on how to do that.
+
+[1] The splashutils package can be downloaded from:
+    http://dev.gentoo.org/~spock/projects/splashutils/
+
+The userspace helper
+--------------------
+
+The userspace splash helper (by default: /sbin/splash_helper) is called by the
+kernel whenever an important event occurs and the kernel needs some kind of
+job to be carried out. Important events include console switches and video
+mode switches (the kernel requests background images and configuration
+parameters for the current console). The splash helper must be accessible at
+all times. If it's not, fbsplash will be switched off automatically.
+
+It's possible to set path to the splash helper by writing it to
+/proc/sys/kernel/fbsplash.
+
+*****************************************************************************
+
+The information below is mostly technical stuff. There's probably no need to
+read it unless you plan to develop a userspace helper.
+
+The splash protocol
+-------------------
+
+The splash protocol defines a communication interface between the kernel and
+the userspace splash helper.
+
+The kernel side is responsible for:
+
+ * rendering console text, using an image as a background (instead of a
+   standard solid color fbcon uses),
+ * accepting commands from the user via ioctls on the fbsplash device,
+ * calling the userspace helper to set things up as soon as the fb subsystem 
+   is initialized.
+
+The userspace helper is responsible for everything else, including parsing
+configuration files, decompressing the image files whenever the kernel needs
+it, and communicating with the kernel if necessary.
+
+The splash protocol specifies how communication is done in both ways:
+kernel->userspace and userspace->helper.
+  
+Kernel -> Userspace
+-------------------
+
+The kernel communicates with the userspace helper by calling it and specifying
+the task to be done in a series of arguments.
+
+The arguments follow the pattern:
+<splash protocol version> <command> <parameters>
+
+All commands defined in splash protocol v2 have the following parameters:
+ virtual console
+ framebuffer number
+ theme
+
+Splash protocol v1 specified an additional 'fbsplash mode' after the
+framebuffer number. Splash protocol v1 is deprecated and should not be used.
+
+Splash protocol v2 specifies the following commands:
+
+getpic
+------
+ The kernel issues this command to request image data. It's up to the 
+ userspace  helper to find a background image appropriate for the specified 
+ theme and the current resolution. The userspace helper should respond by 
+ issuing the FBIOSPLASH_SETPIC ioctl.
+
+init
+----
+ The kernel issues this command after the fbsplash device is created and
+ the fbsplash interface is initialized. Upon receiving 'init', the userspace
+ helper should parse the kernel command line (/proc/cmdline) or otherwise
+ decide whether fbsplash is to be activated.
+
+ To activate fbsplash on the first console the helper should issue the
+ FBIOSPLASH_SETCFG, FBIOSPLASH_SETPIC and FBIOSPLASH_SETSTATE commands,
+ in the above-mentioned order.
+
+ When the userspace helper is called in an early phase of the boot process
+ (right after the initialization of fbcon), no filesystems will be mounted.
+ The helper program should mount sysfs and then create the appropriate
+ framebuffer, fbsplash and tty0 devices (if they don't already exist) to get
+ current display settings and to be able to communicate with the kernel side.
+ It should probably also mount the procfs to be able to parse the kernel
+ command line parameters.
+
+ Note that the console sem is not held when the kernel calls splash_helper
+ with the 'init' command. The splash helper should perform all ioctls with
+ origin set to FB_SPLASH_IO_ORIG_USER.
+
+modechange
+----------
+ The kernel issues this command on a mode change. The helper's response should
+ be similar to the response to the 'init' command. Note that this time the
+ console sem is held and all ioctls must be performed with origin set to
+ FB_SPLASH_IO_ORIG_KERNEL.
+
+
+Userspace -> Kernel
+-------------------
+
+Userspace programs can communicate with fbsplash via ioctls on the fbsplash
+device. These ioctls are to be used by both the userspace helper (called
+only by the kernel) and userspace configuration tools (run by the users).
+
+The splash helper should set the origin field to FB_SPLASH_IO_ORIG_KERNEL
+when doing the appropriate ioctls. All userspace configuration tools should
+use FB_SPLASH_IO_ORIG_USER. Failure to set the appropriate value in the origin
+field when performing ioctls from the kernel helper will most likely result
+in a console deadlock.
+
+FB_SPLASH_IO_ORIG_KERNEL instructs fbsplash not to try to acquire the console
+semaphore. Not surprisingly, FB_SPLASH_IO_ORIG_USER instructs it to acquire
+the console sem.
+
+The framebuffer splash provides the following ioctls (all defined in 
+linux/fb.h):
+
+FBIOSPLASH_SETPIC
+description: loads a background picture for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct fb_image*
+notes: 
+If called for consoles other than the current foreground one, the picture data
+will be ignored.
+
+If the current virtual console is running in a 8-bpp mode, the cmap substruct
+of fb_image has to be filled appropriately: start should be set to 16 (first
+16 colors are reserved for fbcon), len to a value <= 240 and red, green and
+blue should point to valid cmap data. The transp field is ingored. The fields
+dx, dy, bg_color, fg_color in fb_image are ignored as well.
+
+FBIOSPLASH_SETCFG
+description: sets the fbsplash config for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct vc_splash*
+notes: The structure has to be filled with valid data.
+
+FBIOSPLASH_GETCFG
+description: gets the fbsplash config for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct vc_splash*
+
+FBIOSPLASH_SETSTATE
+description: sets the fbsplash state for a virtual console
+argument: struct fb_splash_iowrapper*; data: unsigned int*
+          values: 0 = disabled, 1 = enabled.
+
+FBIOSPLASH_GETSTATE
+description: gets the fbsplash state for a virtual console
+argument: struct fb_splash_iowrapper*; data: unsigned int*
+          values: as in FBIOSPLASH_SETSTATE
+
+Info on used structures:
+
+Definition of struct vc_splash can be found in linux/console_splash.h. It's
+heavily commented. Note that the 'theme' field should point to a string
+no longer than FB_SPLASH_THEME_LEN. When FBIOSPLASH_GETCFG call is
+performed, the theme field should point to a char buffer of length
+FB_SPLASH_THEME_LEN.
+
+Definition of struct fb_splash_iowrapper can be found in linux/fb.h.
+The fields in this struct have the following meaning:
+
+vc: 
+Virtual console number.
+
+origin: 
+Specifies if the ioctl is performed as a response to a kernel request. The
+splash helper should set this field to FB_SPLASH_IO_ORIG_KERNEL, userspace
+programs should set it to FB_SPLASH_IO_ORIG_USER. This field is necessary to
+avoid console semaphore deadlocks.
+
+data: 
+Pointer to a data structure appropriate for the performed ioctl. Type of
+the data struct is specified in the ioctls description.
+
+*****************************************************************************
+
+Credit
+------
+
+Original 'bootsplash' project & implementation by:
+  Volker Poplawski <volker@poplawski.de>, Stefan Reinauer <stepan@suse.de>,
+  Steffen Winterfeldt <snwint@suse.de>, Michael Schroeder <mls@suse.de>,
+  Ken Wimer <wimer@suse.de>.
+
+Fbsplash, splash protocol design, current implementation & docs by:
+  Michal Januszewski <spock@gentoo.org>
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/Kconfig linux-2.6.23.1-stm/arch/sh/Kconfig
--- linux-2.6.23.1/arch/sh/Kconfig	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -202,6 +202,16 @@
 config CPU_HAS_FPU
 	bool
 
+config SH_GRB
+	bool "Implement atomic operations by roll-back (gRB) (EXPERIMENTAL)"
+	default n
+	---help---
+	  Enabling this option will allow the kernel to implement some
+	  atomic operations using a software implemention of load-locked/
+	  store-conditional (LLSC). On machines which do not have hardware
+	  LLSC, this should be more efficient than the other alternative of
+	  disabling insterrupts around the atomic sequence.
+
 endmenu
 
 menu "Board support"
@@ -275,6 +285,77 @@
 	  Select SystemH if you are configuring for a Renesas SystemH
 	  7751R evaluation board.
 
+config SH_ST_MB360
+	bool "mb360: ST40RA Eval"
+	depends on CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40RA-Eval if configuring for an
+	  STMicroelectronics ST40RA Eval Board (product code: ST40RA-Eval,
+	  ST board ID: mb360). More information at:
+	  <http://www.stlinux.com/boards/mb360/>
+
+config SH_ST_MB374
+	bool "mb374: ST40RA Starter"
+	select SYS_SUPPORTS_PCI
+       depends on CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40RA-Starter if configuring for an
+	  STMicroelectronics ST40RA Starter Board (also known as the
+	  ST40RA DDR Eval board) (product code: ST40RA-Starter,
+	  ST board ID: mb374). More information at:
+	  <http://www.stlinux.com/boards/mb374/>
+
+config SH_ST_MB411
+	bool "mb411: STB7100 Validation board"
+	depends on CPU_SUBTYPE_STB7100
+	help
+	  Select STB7100 Validation if configuring for an
+	  STMicroelectronics STB7100 Validation Board (product code: STB7100-MBOARD,
+	  ST board ID: mb411). More information at:
+	  <http://www.stlinux.com/boards/mb411/>
+
+config SH_ST_MB442
+	bool "mb442: STB7100 Reference board"
+	depends on CPU_SUBTYPE_STB7100
+	help
+	  Select STB7100 Reference if configuring for an
+	  STMicroelectronics STB7100 Reference Board (product code: STB7100-REF).
+	  This is sometimes referred to as the CoCo board.
+	  More information at:
+	  <http://www.stlinux.com/boards/mb442/>
+
+config SH_ST_MB448
+	bool "mb448: STB7109E Reference board"
+	depends on CPU_SUBTYPE_STB7100
+	help
+	  Select STB7109E Reference if configuring for an
+	  STMicroelectronics STB7109E Reference Board (product code: STB7109E-REF,
+	  ST board ID: mb448). More information at:
+	  <http://www.stlinux.com/boards/mb448/>
+
+config SH_ST_CB101
+	bool "cb101: ST Customer board 101"
+	depends on CPU_SUBTYPE_STX7200
+	help
+	  Select SH_ST_CB101 if configuring for this board.
+
+config SH_HMS1
+	bool "HMS1"
+	depends on CPU_SUBTYPE_STB7100
+	help
+	  Select HMS1 if configuring for a HMS1 board.
+	  More information at:
+	  <http://www.linuxsh.st.com/boards/hms1/>
+
+config SH_ST_MB519
+	bool "mb519: STx7200 Mboard"
+	depends on CPU_SUBTYPE_STX7200
+	help
+	  Select SH_ST_MB519 if configuring for an
+	  STMicroelectronics STx7200 Mboard (product code: STB7200-MBOARD,
+	  ST board ID: mb519). More information at:
+	  <http://www.stlinux.com/boards/mb519/>
+
 config SH_HP6XX
 	bool "HP6XX"
 	select SYS_SUPPORTS_APM_EMULATION
@@ -469,6 +550,30 @@
 
 endmenu
 
+config SH_EXTERNAL_CLOCK
+	int "External clock"
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200
+	default "30000000" if SH_ST_MB442
+	default "27000000"
+	help
+	  The kernel needs to know what the frequency of chip's external
+	  clock is, so that it can calculate what frequency the internal
+	  clocks are running at.
+
+	  The usual symptoms of getting this wrong are the serial port
+	  output being corrupted.
+
+config SH_FAST_HZ
+	bool "Fast kernel tick"
+	default n
+	help
+	  Enabling this option will increase the rate at which the kernel's
+	  internal timer ticks from 100Hz to 1000Hz. This will increase the
+	  accuracy of the kernel's internal time, at the expense of a higher
+	  interrupt load.
+
+	  This option needs to be set to use the SH watchdog.
+
 menu "CPU Frequency scaling"
 
 source "drivers/cpufreq/Kconfig"
@@ -618,6 +723,10 @@
 
 config CMDLINE_BOOL
 	bool "Default bootloader kernel arguments"
+	help
+	  Setting this option allows the kernel command line arguments to
+	  be set. These will overwrite any arguments passed in by a
+	  bootloader.
 
 config CMDLINE
 	string "Initial kernel command string"
@@ -752,6 +893,11 @@
 
 endmenu
 
+config PM_SH3_FRQCR
+	bool
+	default y if PM && CPU_SH3
+	default n
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/Makefile linux-2.6.23.1-stm/arch/sh/Makefile
--- linux-2.6.23.1/arch/sh/Makefile	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -107,6 +107,14 @@
 machdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	+= se/7751
 machdir-$(CONFIG_SH_7780_SOLUTION_ENGINE)	+= se/7780
 machdir-$(CONFIG_SH_7343_SOLUTION_ENGINE)	+= se/7343
+machdir-$(CONFIG_SH_ST_MB360)		+= st/mb360    st/harp-common
+machdir-$(CONFIG_SH_ST_MB374)		+= st/mb374 st/harp-common
+machdir-$(CONFIG_SH_ST_MB411)		+= st/mb411 st/harp-common
+machdir-$(CONFIG_SH_ST_MB442)		+= st/mb442
+machdir-$(CONFIG_SH_ST_MB448)		+= st/mb448
+machdir-$(CONFIG_SH_HMS1)			+= st/hms1
+machdir-$(CONFIG_SH_ST_MB519)			+= st/mb519
+machdir-$(CONFIG_SH_ST_CB101)			+= st/cb101
 machdir-$(CONFIG_SH_HP6XX)			+= hp6xx
 machdir-$(CONFIG_SH_DREAMCAST)			+= dreamcast
 machdir-$(CONFIG_SH_MPC1211)			+= mpc1211
@@ -128,11 +136,11 @@
 machdir-$(CONFIG_SH_LBOX_RE2)			+= lboxre2
 machdir-$(CONFIG_SH_MAGIC_PANEL_R2)		+= magicpanelr2
 
-incdir-y	:= $(notdir $(machdir-y))
+incdir-y	:= $(notdir $(firstword $(machdir-y)))
 
 ifneq ($(machdir-y),)
 core-y	+= $(addprefix arch/sh/boards/, \
-	     $(filter-out ., $(patsubst %,%/,$(machdir-y))))
+	     $(filter-out ., $(addsuffix /,$(machdir-y))))
 endif
 
 # Companion chips
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/cb101/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/cb101/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/cb101/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/cb101/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for cb101 board
+#
+
+obj-y := setup.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/cb101/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/cb101/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/cb101/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/cb101/setup.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,154 @@
+/*
+ * arch/sh/boards/st/cb101/setup.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * cb101 board support.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/io.h>
+
+#define SYSCONF_BASE 0xfd704000
+#define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
+#define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
+#define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
+
+/*
+ * Initialize the board
+ */
+void __init cb101_setup(char** cmdline_p)
+{
+	unsigned long sysconf;
+	unsigned long chip_revision;
+
+	printk("cb101 board initialisation\n");
+
+	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+	chip_revision = (sysconf >> 28) +1;
+
+	printk("STx7200 version %ld.x\n", chip_revision);
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(40));
+	sysconf &= ~(1<<16);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(40));
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<25);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<24);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<2);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<28);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<3);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf |= (1<<14);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(33));
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(33));
+
+	/* ClockgenB powers up with all the frequency synths bypassed.
+	 * Enable them all here.  Without this, USB 1.1 doesn't work,
+	 * as it needs a 48MHz clock which is separate from the USB 2
+	 * clock which is derived from the SATA clock. */
+	ctrl_outl(0, 0xFD701048);
+
+	stx7200eth_hw_setup(0, 0, 0);
+}
+
+static void phy_reset(void* bus)
+{
+	static struct stpio_pin *ethreset = NULL;
+
+	if (ethreset == NULL) {
+		ethreset = stpio_request_pin(4, 7, "STE101P_RST", STPIO_OUT);
+	}
+
+	stpio_set_pin(ethreset, 1);
+	udelay(1);
+	stpio_set_pin(ethreset, 0);
+	udelay(1000);
+	stpio_set_pin(ethreset, 1);
+}
+
+static struct plat_stmmacenet_data stmmaceth_private_data = {
+	.bus_id = 0,
+	.phy_addr = 14,
+	.phy_mask = 0,
+	.phy_name = "ste101p",
+	.pbl = 32,
+	.fix_mac_speed = fix_mac_speed,
+	.phy_reset = phy_reset,
+};
+
+static int __init device_init(void)
+{
+	// return platform_add_devices(cb101_devices, ARRAY_SIZE(cb101_devices));
+}
+device_initcall(device_init);
+
+static void __iomem *cb101_ioport_map(unsigned long port, unsigned int size)
+{
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init cb101_init_irq(void)
+{
+}
+
+struct sh_machine_vector mv_cb101 __initmv = {
+	.mv_name		= "cb101";
+	.mv_setup		= cb101_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_ioport_map		= cb101_ioport_map,
+};
+ALIAS_MV(cb101)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/harp-common/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/harp-common/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/Makefile	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics boards which look like the ST40STB1 HARP.
+#
+
+obj-y := irq.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/harp-common/epld.c linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/epld.c
--- linux-2.6.23.1/arch/sh/boards/st/harp-common/epld.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/epld.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include "epld.h"
+
+#define DRIVER_NAME "harp-epld"
+
+static void __iomem *epld_base;
+static int epld_opsize;
+
+void epld_write(unsigned long value, unsigned long offset)
+{
+	if (epld_opsize == 16)
+		writew(value, epld_base + offset);
+	else
+		writeb(value, epld_base + offset);
+}
+
+unsigned long epld_read(unsigned long offset)
+{
+	if (epld_opsize == 16)
+		return readw(epld_base + offset);
+	else
+		return readb(epld_base + offset);
+}
+
+static int __init epld_probe(struct platform_device *pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+		return -EBUSY;
+
+	epld_base = ioremap(pdev->resource[0].start, size);
+	if (!epld_base)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct platform_driver epld_driver = {
+	.probe		= epld_probe,
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+int harp_configure_epld(struct platform_device *epld_device)
+{
+	int error;
+	struct plat_epld_data *data = epld_device->dev.platform_data;
+
+	error = platform_driver_register(&epld_driver);
+	if (error)
+		return error;
+
+	error = platform_device_register(epld_device);
+	if (error) {
+		platform_driver_unregister(&epld_driver);
+		return error;
+	}
+
+	if (data) {
+		epld_opsize = data->opsize;
+	}
+
+	return 0;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/harp-common/epld.h linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/epld.h
--- linux-2.6.23.1/arch/sh/boards/st/harp-common/epld.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/epld.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,7 @@
+void epld_write(unsigned long value, unsigned long offset);
+unsigned long epld_read(unsigned long offset);
+int harp_configure_epld(struct platform_device *device);
+
+struct plat_epld_data {
+	int opsize;
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/harp-common/irq.c linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/irq.c
--- linux-2.6.23.1/arch/sh/boards/st/harp-common/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/harp-common/irq.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2000 STMicroelectronics Limited
+ * Author: David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Looks after interrupts on the HARP board.
+ *
+ * Bases on the IPR irq system
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/mach/harp.h>
+
+#ifndef epld_out
+#define epld_out(val,addr) ctrl_outl(val,addr)
+#define epld_in(addr)      ctrl_inl(addr)
+#endif
+
+#define NUM_EXTERNAL_IRQS 16
+
+static void disable_harp_irq(unsigned int irq)
+{
+	unsigned maskReg;
+	unsigned mask;
+	int pri;
+
+	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
+		return;
+
+	pri = 15 - irq;
+
+	if (pri < 8) {
+		maskReg = EPLD_INTMASK0CLR;
+	} else {
+		maskReg = EPLD_INTMASK1CLR;
+		pri -= 8;
+	}
+	mask=1<<pri;
+
+	epld_out(mask, maskReg);
+
+	/* Read back the value we just wrote to flush any write posting */
+	epld_in(maskReg);
+}
+
+static void enable_harp_irq(unsigned int irq)
+{
+	unsigned maskReg;
+	unsigned mask;
+	int pri;
+
+	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
+		return;
+
+	pri = 15 - irq;
+
+	if (pri < 8) {
+		maskReg = EPLD_INTMASK0SET;
+	} else {
+		maskReg = EPLD_INTMASK1SET;
+		pri -= 8;
+	}
+	mask=1<<pri;
+
+	epld_out(mask, maskReg);
+}
+
+static void __init disable_all_interrupts(void)
+{
+	epld_out(0x00, EPLD_INTMASK0);
+	epld_out(0x00, EPLD_INTMASK1);
+}
+
+static struct irq_chip harp_chips[NUM_EXTERNAL_IRQS] = {
+	[0 ... NUM_EXTERNAL_IRQS-1 ] = {
+		.mask = disable_harp_irq,
+		.unmask = enable_harp_irq,
+		.mask_ack = disable_harp_irq,
+		.name = "harp",
+	}
+};
+
+void __init harp_init_irq(void)
+{
+	int irq;
+
+	disable_all_interrupts();
+
+	for (irq = 0; irq < NUM_EXTERNAL_IRQS; irq++) {
+		disable_irq_nosync(irq);
+		set_irq_chip_and_handler_name(irq, &harp_chips[irq],
+			handle_level_irq, "level");
+		disable_harp_irq(irq);
+	}
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/hms1/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/hms1/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/hms1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/hms1/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for HMS1 board
+#
+
+obj-y := setup.o mach.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/hms1/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/hms1/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/hms1/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/hms1/mach.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,60 @@
+/*
+ * arch/sh/boards/st/hms1/mach.c
+ *
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the HMS1 board.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/irq-stb7100.h>
+
+static void __iomem *hms1_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init hms1_init_irq(void)
+{
+	void ilc_early_init(void);
+
+	/* enable individual interrupt mode for externals */
+	plat_irq_setup_pins(IRQ_MODE_IRQ);
+
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+	ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+}
+
+void __init hms1_setup(char**);
+
+static struct sh_machine_vector mv_hms1 __initmv = {
+	.mv_name		= "HMS1 board",
+	.mv_setup		= hms1_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= hms1_init_irq,
+	.mv_ioport_map		= hms1_ioport_map,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/hms1/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/hms1/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/hms1/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/hms1/setup.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,108 @@
+/*
+ * arch/sh/boards/st/hms1/setup.c
+ *
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * HMS1 board support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <asm/irl.h>
+
+static struct stpio_pin *vpp_pio;
+
+static int ascs[2] __initdata = { 2, 3 };
+
+void __init hms1_setup(char** cmdline_p)
+{
+	printk("HMS1 board initialisation\n");
+
+	stx7100_early_device_init();
+	stb7100_configure_asc(ascs, 2, 0);
+}
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT1,
+};
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		(SSC_I2C_CAPABILITY << (0*2)) |
+		((SSC_SPI_CAPABILITY | SSC_I2C_CAPABILITY) << (1*2)) |
+		(SSC_I2C_CAPABILITY << (2*2)),
+};
+
+static void set_vpp(struct map_info * info, int enable)
+{
+	stpio_set_pin(vpp_pio, enable);
+}
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct platform_device *hms1_devices[] __initdata = {
+	&physmap_flash,
+};
+
+static int __init hms1_device_init(void)
+{
+	stx7100_configure_sata();
+	stx7100_configure_pwm(&pwm_private_info);
+	stx7100_configure_ssc(&ssc_private_info);
+	stx7100_configure_usb();
+	stx7100_configure_alsa();
+	stx7100_configure_pata(3, IRL1_IRQ);
+
+	vpp_pio = stpio_request_pin(2,5, "VPP", STPIO_OUT);
+
+	return platform_add_devices(hms1_devices, ARRAY_SIZE(hms1_devices));
+}
+
+arch_initcall(hms1_device_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb360/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb360/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb360/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb360/Makefile	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40RA Eval board
+#
+
+obj-y := setup.o mach.o led.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb360/led.c linux-2.6.23.1-stm/arch/sh/boards/st/mb360/led.c
--- linux-2.6.23.1/arch/sh/boards/st/mb360/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb360/led.c	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,27 @@
+/*
+ * linux/arch/sh/boards/mb360/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the ST40RA/ST40STB1 Eval board.
+ */
+
+#include <linux/stm/pio.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/mb360/harp.h>
+
+/* ST40 Eval: Flash LD9 (PIO LED) connected to PIO1 bit 3 */
+void mach_led(int position, int value)
+{
+	static struct stpio_pin *led = NULL;
+
+	if (led == NULL) {
+		led = stpio_request_pin(1, 3, "LED", STPIO_OUT);
+	}
+
+	stpio_set_pin(led, value);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb360/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/mb360/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/mb360/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb360/mach.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+ * linux/arch/sh/boards/mb360/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB1 HARP and compatible boards
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/io_generic.h>
+#include <asm/mb360/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+unsigned long stb1eval_isa_port2addr(unsigned long offset)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((offset >= PCIBIOS_MIN_IO) &&
+            (offset < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return offset + ST40PCI_IO_ADDRESS;
+        }
+#endif
+
+        /* However picking somewhere safe isn't as easy as you might think.
+         * I used to use external ROM, but that can cause problems if you are
+         * in the middle of updating Flash. So I'm now using the processor core
+         * version register, which is guaranted to be available, and non-writable.
+         */
+        return CCN_PVR;
+}
+
+static struct sh_machine_vector mv_stb1eval __initmv = {
+        .mv_nr_irqs             = NR_IRQS,
+        .mv_isa_port2addr       = stb1eval_isa_port2addr,
+
+#ifdef CONFIG_PCI
+        .mv_init_irq            = harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+        .mv_heartbeat           = heartbeat_heart,
+#endif
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb360/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb360/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb360/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb360/setup.c	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,65 @@
+/*
+ * arch/sh/boards/mb360/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40RA/ST40STB1 Eval support.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/mb360/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+        unsigned board=ctrl_inl(EPLD_REVID_PLD);
+        unsigned pld=ctrl_inl(EPLD_REVID_BOARD);
+
+        printk("STMicroelectronics ST40RA/ST40STB1 Eval initialisaton\n");
+        printk("Board version %c EPLD version: %d.%02d\n",
+               'A'+(board&0xf), (pld >> 4) & 0xf, pld & 0xf);
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+}
+
+#ifdef CONFIG_PCI
+
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+        int irq=-1;
+
+
+        switch (slot) {
+        case 2:
+                irq=0;
+                break;
+        case 9 ... 12:
+                irq = 12-slot+1;
+                break;
+        }
+
+        /* Are we asking for a known slot ? */
+        if(irq==-1) return -1;
+
+	pr_debug("Asking for slot %d pin %d - given %d\n",slot,pin,irq);
+
+        if(pin==1) return irq;
+        /* An INTB,INTC,INTD - these are commoned up */
+        return pin+3;
+}
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb374/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb374/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb374/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb374/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40RA/ST40STB1 Starter board
+#
+
+obj-y := setup.o mach.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb374/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/mb374/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/mb374/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb374/mach.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+ * linux/arch/sh/boards/mb374/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB40RA Starter board.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/io.h>
+#include <asm/mb374/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *mb374_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((port >= PCIBIOS_MIN_IO) &&
+            (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return port + ST40PCI_IO_ADDRESS;
+        }
+#endif
+
+        /* However picking somewhere safe isn't as easy as you might think.
+         * I used to use external ROM, but that can cause problems if you are
+         * in the middle of updating Flash. So I'm now using the processor core
+         * version register, which is guaranted to be available, and non-writable.
+         */
+        return (void __iomem *)CCN_PVR;
+}
+
+void __init mb374_setup(char **cmdline_p);
+
+static struct sh_machine_vector mv_mb374 __initmv = {
+	.mv_name		= "ST40RA/ST40STB1 Starter",
+	.mv_setup		= mb374_setup,
+        .mv_nr_irqs             = NR_IRQS,
+        .mv_ioport_map		= mb374_ioport_map,
+
+#ifdef CONFIG_PCI
+        .mv_init_irq            = harp_init_irq,
+#endif
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb374/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb374/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb374/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb374/setup.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+ * arch/sh/boards/mb374/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40RA/ST40STB1 Starter support.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/mb374/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+/*
+ * Initialize the board
+ */
+void __init mb374_setup(char **cmdline_p)
+{
+	unsigned char version;
+
+	version = ctrl_inl(EPLD_REVID) & 0xff;
+
+	printk("STMicroelectronics ST40 Starter initialisation\n");
+	printk("EPLD version: %d.%02d\n",(version >> 4) & 0xf, version & 0xf);
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+}
+
+#ifdef CONFIG_PCI
+int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	pr_debug("%s: slot %d, pin %d\n", __FUNCTION__, slot, pin);
+
+	switch(slot) {
+	case 1:
+		irq=0;
+		break;
+	case 2:
+		irq=3;
+		break;
+	case 3:
+		irq=1;
+		break;
+	case 4:
+		irq=2;
+		break;
+	}
+
+	/* Are we asking for a known slot ? */
+	if(irq==-1) return -1;
+
+	if(pin==1) return irq;
+
+	/* if INTB/C/D h then this can only come from the PCI add in slot */
+	if(slot!=1) return -1;
+
+	/* An INTB,INTC,INTD - these are commoned up */
+	switch(pin) {
+	case 2:
+		irq=4;
+		break;
+	case 3:
+		irq=5;
+		break;
+	case 4:
+		irq=7;
+		break;
+	default:
+		irq=-1;
+		break;
+	}
+
+	return irq;
+}
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb411/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb411/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb411/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb411/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7100 Validation board
+#
+
+obj-y := setup.o mach.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb411/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/mb411/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/mb411/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb411/mach.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,60 @@
+/*
+ * arch/sh/boards/st/mb411/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7100 Validation board.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/irq-stb7100.h>
+#include <asm/mb411/harp.h>
+
+static void __iomem *mb411_ioport_map(unsigned long port, unsigned int size)
+{
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+        return (void __iomem *)CCN_PVR;
+}
+
+static void __init mb411_init_irq(void)
+{
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+
+        /* Route e/net PHY interrupt to SH4 - only for STb7109 */
+#ifdef CONFIG_STMMAC_ETH
+        /* Note that we invert the signal - the ste101p is connected
+           to the mb411 as active low. The sh4 INTC expects active high */
+        ilc_route_external(ILC_EXT_MDINT, 7, 1);
+#else
+        ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+#endif
+
+	/* ...where they are hadled as normal HARP style (encoded) interrpts */
+	harp_init_irq();
+}
+
+void __init mb411_setup(char**);
+
+static struct sh_machine_vector mv_mediaref __initmv = {
+	.mv_name		= "mb411",
+	.mv_setup		= mb411_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= mb411_init_irq,
+	.mv_ioport_map		= mb411_ioport_map,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb411/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb411/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb411/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb411/setup.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,171 @@
+/*
+ * arch/sh/boards/st/mb411/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7100 MBoard board support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/phy.h>
+#include <asm/io.h>
+#include <asm/mb411/harp.h>
+
+static int ascs[2] __initdata = { 2, 3 };
+
+void __init mb411_setup(char** cmdline_p)
+{
+	unsigned char epldver;
+	unsigned char pod_devid;
+
+	printk("STMicroelectronics STb7100 MBoard board initialisation\n");
+
+	epldver = ctrl_inb(EPLD_EPLDVER),
+	printk("EPLD v%dr%d, PCB ver %X\n",
+	       epldver >> 4, epldver & 0xf,
+	       ctrl_inb(EPLD_PCBVER));
+
+	pod_devid = ctrl_inb(EPLD_POD_DEVID);
+	printk("POD EPLD version: %d, DevID: MB411(%d) Rev.%c\n",
+	       ctrl_inb(EPLD_POD_REVID),
+	       pod_devid >> 4, 'A'-1+(pod_devid & 0xf));
+
+        stx7100_early_device_init();
+        stb7100_configure_asc(ascs, 2, 0);
+}
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT0 | PLAT_STM_PWM_OUT1,
+};
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		(SSC_I2C_CAPABILITY << (0*2)) |
+		((SSC_SPI_CAPABILITY | SSC_I2C_CAPABILITY) << (1*2)) |
+		(SSC_I2C_CAPABILITY << (2*2)),
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa3e00300,
+		.end	= 0xa3e00300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 7,
+		.end	= 7,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static void stb7100_mtd_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp) {
+		harp_set_vpp_on();
+	} else {
+		harp_set_vpp_off();
+	}
+}
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= stb7100_mtd_set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct plat_stmmacphy_data phy_private_data = {
+        .bus_id = 0,
+        .phy_addr = 0,
+        .phy_mask = 0,
+        .interface = PHY_INTERFACE_MODE_MII,
+};
+
+static struct platform_device mb411_phy_device = {
+        .name           = "stmmacphy",
+        .id             = 0,
+        .num_resources  = 1,
+        .resource       = (struct resource[]) {
+                {
+                        .name   = "phyirq",
+                        .start  = 0,
+                        .end    = 0,
+                        .flags  = IORESOURCE_IRQ,
+                },
+        },
+        .dev = {
+                .platform_data = &phy_private_data,
+         }
+};
+
+static struct platform_device *mb411_devices[] __initdata = {
+	&smc91x_device,
+	&physmap_flash,
+	&mb411_phy_device,
+};
+
+static int __init device_init(void)
+{
+	stx7100_configure_sata();
+	stx7100_configure_pwm(&pwm_private_info);
+	stx7100_configure_ssc(&ssc_private_info);
+	stx7100_configure_usb();
+	stx7100_configure_alsa();
+	stx7100_configure_lirc();
+	stx7100_configure_ethernet(0, 0, 0);
+
+	return platform_add_devices(mb411_devices,
+                                    ARRAY_SIZE(mb411_devices));
+}
+
+device_initcall(device_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb442/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb442/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb442/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb442/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7100 Reference board
+#
+
+obj-y := setup.o mach.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb442/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/mb442/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/mb442/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb442/mach.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,60 @@
+/*
+ * arch/sh/boards/st/mb442/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7100 Reference board.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/irq-stb7100.h>
+
+static void __iomem *mb442_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init mb442_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	plat_irq_setup_pins(IRQ_MODE_IRQ);
+
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	/* Inputs sys-irq2 and 3 are unused (pulled high) */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);		/* SMC Ethernet */
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);		/* ATA */
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);		/* Unused */
+	ilc_route_external(ILC_EXT_MDINT, 7, 0);	/* STe100 PHY */
+}
+
+void __init mb442_setup(char**);
+
+static struct sh_machine_vector mv_mb442 __initmv = {
+	.mv_name		= "STb7100 Reference board",
+	.mv_setup		= mb442_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= mb442_init_irq,
+	.mv_ioport_map		= mb442_ioport_map,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb442/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb442/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb442/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb442/setup.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,176 @@
+/*
+ * arch/sh/boards/st/mb442/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7100 Reference board support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/phy.h>
+#include <asm/irl.h>
+
+static int ascs[2] __initdata = { 2, 3 };
+
+void __init mb442_setup(char** cmdline_p)
+{
+	printk("STMicroelectronics STb7100 Reference board initialisation\n");
+
+	stx7100_early_device_init();
+	stb7100_configure_asc(ascs, 2, 0);
+}
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT1,
+};
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		(SSC_I2C_CAPABILITY << (0*2)) |
+		(SSC_SPI_CAPABILITY << (1*2)) |
+		(SSC_I2C_CAPABILITY << (2*2)),
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0x02000300,
+		.end	= 0x02000300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL0_IRQ,
+		.end	= IRL0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= NULL,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct stpio_pin *phy_reset_pin;
+
+static int mb442_phy_reset(void* bus)
+{
+	stpio_set_pin(phy_reset_pin, 1);
+	udelay(1);
+	stpio_set_pin(phy_reset_pin, 0);
+	udelay(1);
+	stpio_set_pin(phy_reset_pin, 1);
+
+	return 1;
+}
+
+static struct plat_stmmacphy_data phy_private_data = {
+	.bus_id = 0,
+	.phy_addr = 14,
+	.phy_mask = 1,
+	.interface = PHY_INTERFACE_MODE_MII,
+	.phy_reset = &mb442_phy_reset,
+};
+
+static struct platform_device mb442_phy_device = {
+	.name		= "stmmacphy",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+                {
+			.name	= "phyirq",
+			.start	= IRL3_IRQ,
+			.end	= IRL3_IRQ,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &phy_private_data,
+	 }
+};
+
+static struct platform_device *mb442_devices[] __initdata = {
+	&smc91x_device,
+	&physmap_flash,
+	&mb442_phy_device,
+};
+
+static int __init device_init(void)
+{
+	struct stpio_pin *smc91x_reset;
+
+	stx7100_configure_sata();
+	stx7100_configure_pwm(&pwm_private_info);
+	stx7100_configure_ssc(&ssc_private_info);
+	stx7100_configure_usb();
+	stx7100_configure_alsa();
+	stx7100_configure_lirc();
+	stx7100_configure_pata(3, IRL1_IRQ);
+
+	phy_reset_pin = stpio_request_set_pin(2, 4, "ste100p_reset",
+					      STPIO_OUT, 1);
+	stx7100_configure_ethernet(0, 0, 0);
+
+	/* Reset the SMSC 91C111 Ethernet chip */
+	smc91x_reset = stpio_request_set_pin(2, 6, "smc91x_reset",
+					     STPIO_OUT, 0);
+	udelay(1);
+	stpio_set_pin(smc91x_reset, 1);
+	udelay(1);
+	stpio_set_pin(smc91x_reset, 0);
+
+	return platform_add_devices(mb442_devices,
+				    ARRAY_SIZE(mb442_devices));
+}
+
+device_initcall(device_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb448/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb448/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb448/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb448/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7109E Reference board
+#
+
+obj-y := setup.o mach.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb448/mach.c linux-2.6.23.1-stm/arch/sh/boards/st/mb448/mach.c
--- linux-2.6.23.1/arch/sh/boards/st/mb448/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb448/mach.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+ * arch/sh/boards/st/mb448/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7109E Reference board.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/irq-stb7100.h>
+
+static void __iomem *mb448_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init mb448_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	plat_irq_setup_pins(IRQ_MODE_IRQ);
+
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(ILC_EXT_MDINT, 4, 1);	/* STe100 PHY */
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);		/* VoIP */
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);		/* ATA */
+	ilc_route_external(ILC_EXT_IRQ3, 7, 0);		/* SMC Ethernet */
+}
+
+void __init mb448_setup(char**);
+
+static struct sh_machine_vector mv_mb448 __initmv = {
+	.mv_name		= "mb448",
+	.mv_setup		= mb448_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= mb448_init_irq,
+	.mv_ioport_map		= mb448_ioport_map,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb448/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb448/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb448/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb448/setup.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,162 @@
+/*
+ * arch/sh/boards/st/mb448/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7109E Reference board support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/phy.h>
+#include <asm/irl.h>
+
+static struct stpio_pin *vpp_pio;
+
+static int ascs[2] __initdata = { 2, 3 };
+
+void __init mb448_setup(char** cmdline_p)
+{
+	printk("STMicroelectronics STb7109E Reference board initialisation\n");
+
+	stx7100_early_device_init();
+	stb7100_configure_asc(ascs, 2, 0);
+}
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		(SSC_I2C_CAPABILITY << (0*2)) |
+		((SSC_SPI_CAPABILITY | SSC_I2C_CAPABILITY) << (1*2)) |
+		(SSC_I2C_CAPABILITY << (2*2)),
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa2000300,
+		.end	= 0xa2000300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL3_IRQ,
+		.end	= IRL3_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static void set_vpp(struct map_info * info, int enable)
+{
+	stpio_set_pin(vpp_pio, enable);
+}
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct plat_stmmacphy_data phy_private_data = {
+	.bus_id = 0,
+	.phy_addr = 14,
+	.phy_mask = 1,
+	.interface = PHY_INTERFACE_MODE_MII,
+	.phy_reset = NULL,
+};
+
+static struct platform_device mb448_phy_device = {
+	.name		= "stmmacphy",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+                {
+			.name	= "phyirq",
+			.start	= IRL0_IRQ,
+			.end	= IRL0_IRQ,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &phy_private_data,
+	 }
+};
+
+static struct platform_device *mb448_devices[] __initdata = {
+	&smc91x_device,
+	&physmap_flash,
+	&mb448_phy_device,
+};
+
+static int __init device_init(void)
+{
+	struct stpio_pin *smc91x_reset;
+
+	stx7100_configure_sata();
+	stx7100_configure_ssc(&ssc_private_info);
+	stx7100_configure_usb();
+	stx7100_configure_alsa();
+	stx7100_configure_ethernet(0, 0, 0);
+
+	vpp_pio = stpio_request_pin(2,7, "VPP", STPIO_OUT);
+
+	/* Reset the SMSC 91C111 Ethernet chip */
+	smc91x_reset = stpio_request_set_pin(2, 6, "smc91x_reset",
+					     STPIO_OUT, 0);
+	udelay(1);
+	stpio_set_pin(smc91x_reset, 1);
+	udelay(1);
+	stpio_set_pin(smc91x_reset, 0);
+
+	return platform_add_devices(mb448_devices,
+				    ARRAY_SIZE(mb448_devices));
+}
+
+device_initcall(device_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb519/Makefile linux-2.6.23.1-stm/arch/sh/boards/st/mb519/Makefile
--- linux-2.6.23.1/arch/sh/boards/st/mb519/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb519/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,6 @@
+#
+# Makefile for STMicroelectronics STx7200 Mboard (mb519) board
+#
+
+obj-y := setup.o epld.o
+epld-y := ../harp-common/epld.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb519/epld.h linux-2.6.23.1-stm/arch/sh/boards/st/mb519/epld.h
--- linux-2.6.23.1/arch/sh/boards/st/mb519/epld.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb519/epld.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,24 @@
+#define EPLD_BASE 0x05000000
+#define EPLD_SIZE 0x01000000
+
+#define EPLD_ver		0x000000
+#define EPLD_cpcbver		0x020000
+#define EPLD_stem		0x040000
+#define EPLD_driver		0x060000
+#define EPLD_reset		0x080000
+#define EPLD_IntStat0		0x0A0000
+#define EPLD_IntStat1		0x0C0000
+#define EPLD_IntMask0		0x0E0000
+#define EPLD_IntMask0Set	0x100000
+#define EPLD_IntMask0Clear	0x120000
+#define EPLD_IntMask1		0x140000
+#define EPLD_IntMask1Set	0x160000
+#define EPLD_IntMask1Clear	0x180000
+#define EPLD_LedStdAddr		0x1A0000
+
+#define EPLD_Flash		0x400000
+#define EPLD_Stem		0x500000
+#define EPLD_StemSet		0x600000
+#define EPLD_StemClr		0x700000
+#define EPLD_DACSPMux		0xD00000
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boards/st/mb519/setup.c linux-2.6.23.1-stm/arch/sh/boards/st/mb519/setup.c
--- linux-2.6.23.1/arch/sh/boards/st/mb519/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boards/st/mb519/setup.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,237 @@
+/*
+ * arch/sh/boards/st/mb519/setup.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STx7200 Mboard support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/phy.h>
+#include <asm/irq-ilc.h>
+#include <asm/io.h>
+#include "../harp-common/epld.h"
+#include "epld.h"
+
+static int ascs[2] __initdata = { 2, 3 };
+
+void __init mb519_setup(char** cmdline_p)
+{
+	printk("STMicroelectronics STx7200 Mboard initialisation\n");
+
+	stx7200_early_device_init();
+	stx7200_configure_asc(ascs, 2, 0);
+}
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT1,
+};
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		((SSC_I2C_CAPABILITY                     ) << (0*2)) |
+		((SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY) << (1*2)) |
+		((SSC_I2C_CAPABILITY                     ) << (2*2)) |
+		((SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY) << (3*2)) |
+		((SSC_I2C_CAPABILITY                     ) << (4*2)),
+};
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static void mtd_set_vpp(struct map_info *map, int vpp)
+{
+	/* Bit 0: VPP enable
+	 * Bit 1: Reset (not used in later EPLD versions)
+	 */
+
+	if (vpp) {
+		epld_write(3, EPLD_Flash);
+	} else {
+		epld_write(2, EPLD_Flash);
+	}
+}
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= mtd_set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start		= 0x00000000,
+			.end		= 32*1024*1024 - 1,
+			.flags		= IORESOURCE_MEM,
+		}
+	},
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+};
+
+static struct plat_stmmacphy_data phy_private_data[2] = {
+{
+	/* MAC0: STE101P */
+	.bus_id = 0,
+	.phy_addr = 0,
+	.phy_mask = 0,
+	.interface = PHY_INTERFACE_MODE_MII,
+}, {
+	/* MAC1: SMSC LAN 8700 */
+	.bus_id = 1,
+	.phy_addr = 1,
+	.phy_mask = 0,
+	.interface = PHY_INTERFACE_MODE_MII,
+} };
+
+static struct platform_device mb519_phy_devices[2] = {
+{
+	.name		= "stmmacphy",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.name	= "phyirq",
+			/* This should be:
+			 * .start = ILC_IRQ(93),
+			 * .end = ILC_IRQ(93),
+			 * but because the mb519 uses the MII0_MDINT line
+			 * as MODE4, and the STE101P MDINT pin is O/C,
+			 * there may or maynot be a pull-up resistor
+			 * depending on switch SW1-4. Most of the time there
+			 * isn't, so disable the interrupt.
+			 */
+			.start	= -1,
+			.end	= -1,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &phy_private_data[0],
+	 }
+}, {
+	.name		= "stmmacphy",
+	.id		= 1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.name	= "phyirq",
+			.start	= ILC_IRQ(95),
+			.end	= ILC_IRQ(95),
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &phy_private_data[1],
+	 }
+} };
+
+static struct platform_device epld_device = {
+	.name		= "harp-epld",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= EPLD_BASE,
+			.end	= EPLD_BASE + EPLD_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		}
+	},
+	.dev.platform_data = &(struct plat_epld_data) {
+		 .opsize = 16,
+	},
+};
+
+static struct platform_device *mb519_devices[] __initdata = {
+	&physmap_flash,
+	&mb519_phy_devices[0],
+	&mb519_phy_devices[1],
+};
+
+static int __init device_init(void)
+{
+	unsigned int epld_rev;
+	unsigned int pcb_rev;
+
+	harp_configure_epld(&epld_device);
+
+	epld_rev = epld_read(EPLD_ver);
+	pcb_rev = epld_read(EPLD_cpcbver);
+	printk("mb519 PCB rev %X EPLD rev %dr%d\n",
+	       pcb_rev,
+	       epld_rev >> 4, epld_rev & 0xf);
+
+	stx7200_configure_pwm(&pwm_private_info);
+	stx7200_configure_ssc(&ssc_private_info);
+	stx7200_configure_usb();
+	stx7200_configure_ethernet(0, 0, 1, 0);
+	// stx7200_configure_ethernet(1, 0, 1, 1);
+        stx7200_configure_lirc();
+        
+	return platform_add_devices(mb519_devices, ARRAY_SIZE(mb519_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *stx7200mboard_ioport_map(unsigned long port, unsigned int size)
+{
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init stx7200mboard_init_irq(void)
+{
+#if 0
+	/* The off chip interrupts on the mb519 are a mess. The external
+	 * EPLD priority encodes them, but because they pass through the ILC3
+	 * there is no way to decode them.
+	 *
+	 * So here we bodge it as well. Only enable the STEM INTR0 signal,
+	 * and hope nothing else goes active.
+	 *
+	 * Note that this changed between EPLD rev 1r2 and 1r3. This is correct
+	 * for 1r3 which should be the most common now.
+	 */
+	ctrl_outw(1<<4, EPLD_IntMask0Set); /* IntPriority(4) <= not STEM_notINTR0 */
+#endif
+}
+
+struct sh_machine_vector mv_stx7200mboard __initmv = {
+	.mv_name		= "mb519",
+	.mv_setup		= mb519_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= stx7200mboard_init_irq,
+	.mv_ioport_map		= stx7200mboard_ioport_map,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boot/Makefile linux-2.6.23.1-stm/arch/sh/boot/Makefile
--- linux-2.6.23.1/arch/sh/boot/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boot/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -8,6 +8,10 @@
 # Copyright (C) 1999 Stuart Menefy
 #
 
+# Set these to dummy values if not defined to avoid error messages.
+CONFIG_MEMORY_START     ?= 0
+CONFIG_ZERO_PAGE_OFFSET ?= 0
+
 MKIMAGE := $(srctree)/scripts/mkuboot.sh
 
 #
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/boot/compressed/misc.c linux-2.6.23.1-stm/arch/sh/boot/compressed/misc.c
--- linux-2.6.23.1/arch/sh/boot/compressed/misc.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/boot/compressed/misc.c	2007-11-01 12:00:43.000000000 +0000
@@ -230,7 +230,12 @@
 void decompress_kernel(void)
 {
 	output_data = 0;
+#ifdef CONFIG_32BIT
+	/* Assume we are already running uncached */
+	output_ptr = (unsigned long)&_text+PAGE_SIZE;
+#else
 	output_ptr = P2SEGADDR((unsigned long)&_text+PAGE_SIZE);
+#endif
 	free_mem_ptr = (unsigned long)&_end;
 	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/dma/Kconfig linux-2.6.23.1-stm/arch/sh/drivers/dma/Kconfig
--- linux-2.6.23.1/arch/sh/drivers/dma/Kconfig	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/drivers/dma/Kconfig	2007-11-01 12:00:40.000000000 +0000
@@ -5,9 +5,14 @@
 
 config SH_DMA
 	bool "SuperH on-chip DMA controller (DMAC) support"
-	depends on CPU_SH3 || CPU_SH4
+	depends on CPU_SH3 || CPU_SH4 && !CPU_SUBTYPE_ST40
 	select SH_DMA_API
 	default n
+	help
+	  Selecting this option will allow the use of the Hitachi/Renesas
+	  DMA controller (DMAC). The DMAC is programmed using the generic
+	  SH DMA API, although a wrapper providing compatibility with the
+	  ISA DMA API used on PC's is also available.
 
 config NR_ONCHIP_DMA_CHANNELS
 	int
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/dma/dma-api.c linux-2.6.23.1-stm/arch/sh/drivers/dma/dma-api.c
--- linux-2.6.23.1/arch/sh/drivers/dma/dma-api.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/drivers/dma/dma-api.c	2007-11-01 12:00:42.000000000 +0000
@@ -192,9 +192,18 @@
 int request_dma(unsigned int chan, const char *dev_id)
 {
 	struct dma_channel *channel = { 0 };
-	struct dma_info *info = get_dma_info(chan);
+	struct dma_info *info;
 	int result;
 
+#if defined(CONFIG_STM_DMA)
+	if(DMA_REQ_ANY_CHANNEL == chan)
+		return dmac_search_free_channel(dev_id);
+#endif
+
+	info = get_dma_info(chan);
+	if (!info)
+		return -EINVAL;
+
 	channel = get_dma_channel(chan);
 	if (atomic_xchg(&channel->busy, 1))
 		return -EBUSY;
@@ -284,14 +293,9 @@
 	     unsigned long to, size_t size, unsigned int mode)
 {
 	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	channel->sar	= from;
-	channel->dar	= to;
-	channel->count	= size;
-	channel->mode	= mode;
+	struct dma_channel *channel =  get_dma_channel(chan);
 
-	return info->ops->xfer(channel);
+	return info->ops->xfer(channel, from, to, size, mode);
 }
 EXPORT_SYMBOL(dma_xfer);
 
@@ -328,7 +332,7 @@
 		for (i = 0; i < info->nr_channels; i++) {
 			struct dma_channel *channel = info->channels + i;
 
-			if (!(channel->flags & DMA_CONFIGURED))
+		        if(atomic_read(&channel->busy) == 0)
 				continue;
 
 			p += sprintf(p, "%2d: %14s    %s\n", i,
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/dma/dma-sysfs.c linux-2.6.23.1-stm/arch/sh/drivers/dma/dma-sysfs.c
--- linux-2.6.23.1/arch/sh/drivers/dma/dma-sysfs.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/drivers/dma/dma-sysfs.c	2007-11-01 12:00:40.000000000 +0000
@@ -28,7 +28,7 @@
 	ssize_t len = 0;
 	int i;
 
-	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+	for (i = 0; get_dma_info(i) != NULL; i++) {
 		struct dma_info *info = get_dma_info(i);
 		struct dma_channel *channel = get_dma_channel(i);
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/pci/Makefile linux-2.6.23.1-stm/arch/sh/drivers/pci/Makefile
--- linux-2.6.23.1/arch/sh/drivers/pci/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/drivers/pci/Makefile	2007-11-01 12:00:39.000000000 +0000
@@ -5,7 +5,7 @@
 obj-y					+= pci.o
 obj-$(CONFIG_PCI_AUTO)			+= pci-auto.o
 
-obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= pci-st40.o
+obj-$(CONFIG_CPU_SUBTYPE_ST40)		+= pci-st40.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o ops-sh4.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7751R)	+= pci-sh7751.o ops-sh4.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7780)	+= pci-sh7780.o ops-sh4.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/pci/pci-st40.c linux-2.6.23.1-stm/arch/sh/drivers/pci/pci-st40.c
--- linux-2.6.23.1/arch/sh/drivers/pci/pci-st40.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/drivers/pci/pci-st40.c	2007-11-01 12:00:42.000000000 +0000
@@ -2,7 +2,7 @@
  * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
  *
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
+ * License.  See linux/COPYING for more information.
  *
  * Support functions for the ST40 PCI hardware.
  */
@@ -20,12 +20,6 @@
 
 #include "pci-st40.h"
 
-/* This is in P2 of course */
-#define ST40PCI_BASE_ADDRESS     (0xb0000000)
-#define ST40PCI_MEM_ADDRESS      (ST40PCI_BASE_ADDRESS+0x0)
-#define ST40PCI_IO_ADDRESS       (ST40PCI_BASE_ADDRESS+0x06000000)
-#define ST40PCI_REG_ADDRESS      (ST40PCI_BASE_ADDRESS+0x07000000)
-
 #define ST40PCI_REG(x) (ST40PCI_REG_ADDRESS+(ST40PCI_##x))
 #define ST40PCI_REG_INDEXED(reg, index) 				\
 	(ST40PCI_REG(reg##0) +					\
@@ -41,60 +35,6 @@
 #define ST40PCI_READ_SHORT(reg) readw(ST40PCI_REG(reg))
 #define ST40PCI_READ_BYTE(reg) readb(ST40PCI_REG(reg))
 
-#define ST40PCI_SERR_IRQ	64
-#define ST40PCI_ERR_IRQ        	65
-
-
-/* Macros to extract PLL params */
-#define PLL_MDIV(reg)  ( ((unsigned)reg) & 0xff )
-#define PLL_NDIV(reg) ( (((unsigned)reg)>>8) & 0xff )
-#define PLL_PDIV(reg) ( (((unsigned)reg)>>16) & 0x3 )
-#define PLL_SETUP(reg) ( (((unsigned)reg)>>19) & 0x1ff )
-
-/* Build up the appropriate settings */
-#define PLL_SET(mdiv,ndiv,pdiv,setup) \
-( ((mdiv)&0xff) | (((ndiv)&0xff)<<8) | (((pdiv)&3)<<16)| (((setup)&0x1ff)<<19))
-
-#define PLLPCICR (0xbb040000+0x10)
-
-#define PLLPCICR_POWERON (1<<28)
-#define PLLPCICR_OUT_EN (1<<29)
-#define PLLPCICR_LOCKSELECT (1<<30)
-#define PLLPCICR_LOCK (1<<31)
-
-
-#define PLL_25MHZ 0x793c8512
-#define PLL_33MHZ PLL_SET(18,88,3,295)
-
-static void pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
-			 unsigned long pciOffset, unsigned long regionSize);
-
-static __init void SetPCIPLL(void)
-{
-	{
-		/* Lets play with the PLL values */
-		unsigned long pll1cr1;
-		unsigned long mdiv, ndiv, pdiv;
-		unsigned long muxcr;
-		unsigned int muxcr_ratios[4] = { 8, 16, 21, 1 };
-		unsigned int freq;
-
-#define CLKGENA            0xbb040000
-#define CLKGENA_PLL2_MUXCR CLKGENA + 0x48
-		pll1cr1 = ctrl_inl(PLLPCICR);
-		printk("PLL1CR1 %08lx\n", pll1cr1);
-		mdiv = PLL_MDIV(pll1cr1);
-		ndiv = PLL_NDIV(pll1cr1);
-		pdiv = PLL_PDIV(pll1cr1);
-		printk("mdiv %02lx ndiv %02lx pdiv %02lx\n", mdiv, ndiv, pdiv);
-		freq = ((2*27*ndiv)/mdiv) / (1 << pdiv);
-		printk("PLL freq %dMHz\n", freq);
-		muxcr = ctrl_inl(CLKGENA_PLL2_MUXCR);
-		printk("PCI freq %dMhz\n", freq / muxcr_ratios[muxcr & 3]);
-	}
-}
-
-
 struct pci_err {
   unsigned mask;
   const char *error_string;
@@ -249,18 +189,31 @@
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
-int __init st40pci_init(unsigned memStart, unsigned memSize)
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1) || \
+    defined (CONFIG_CPU_SUBTYPE_ST40GX1)
+static void __init pci_fixup_cache_line(struct pci_dev *d)
 {
-	u32 lsr0;
+	/*
+	 * STB1 and GX1 have bugs which prevent them being the target
+	 * of memory-read-multiple (MRM) PCI commands. This prevents some
+	 * cards using this command, but it is not infallible.
+	 */
+	pci_write_config_byte(d,PCI_CACHE_LINE_SIZE,0);
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_cache_line);
+#endif
 
-	SetPCIPLL();
+static int __init st40pci_host_init(unsigned memStart, unsigned memSize)
+{
 
 	/* Initialises the ST40 pci subsystem, performing a reset, then programming
 	 * up the address space decoders appropriately
 	 */
 
-	/* Should reset core here as well methink */
+	request_mem_region(ST40PCI_REG_ADDRESS, 0x17c, "PCI local");
+	request_mem_region(ST40PCI_REG_ADDRESS+ST40PCI_CSR, 0x100, "PCI CSR");
 
+	/* Should reset core here as well methink */
 	ST40PCI_WRITE(CR, CR_LOCK_MASK | CR_SOFT_RESET);
 
 	/* Loop while core resets */
@@ -282,10 +235,6 @@
 	 */
 	mdelay(1000);
 
-	/* Switch off interrupts */
-	ST40PCI_WRITE(INTM, 0);
-	ST40PCI_WRITE(AINT, 0);
-
 	/* Allow it to be a master */
 
 	ST40PCI_WRITE_SHORT(CSR_CMD,
@@ -316,7 +265,7 @@
 	ST40PCI_WRITE(LSR0, 0x0fff0001);
 
 	/* ... and set up the initial incoming window to expose all of RAM */
-	pci_set_rbar_region(7, memStart, memStart, memSize);
+	st40pci_set_rbar_region(7, memStart, memStart, memSize);
 
 	/* Maximise timeout values */
 	ST40PCI_WRITE_BYTE(CSR_TRDY, 0xff);
@@ -325,6 +274,25 @@
 
 	ST40PCI_WRITE_BYTE(PERF,PERF_MASTER_WRITE_POSTING);
 
+	if (request_irq(ST40PCI_SERR_IRQ, st40_pci_irq,
+                        IRQF_DISABLED, "st40pci", NULL)) {
+		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
+		return 0;
+	}
+
+	if (request_irq(ST40PCI_ERR_IRQ, st40_pci_irq,
+                        IRQF_DISABLED, "st40pci", NULL)) {
+		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
+		return 0;
+	}
+
+	/* Reset state just in case any outstanding (usually SERR) */
+	ST40PCI_WRITE(INT, ~0); ST40PCI_WRITE(AINT, ~0);
+
+	/* Enable the PCI interrupts on the device */
+	ST40PCI_WRITE(INTM, ~0);
+	ST40PCI_WRITE(AINT, ~0);
+
 	return 1;
 }
 
@@ -339,6 +307,8 @@
 
 #define CONFIG_CMD(bus, devfn, where) SET_CONFIG_BITS(bus->number,devfn,where)
 
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1) || \
+    defined (CONFIG_CPU_SUBTYPE_ST40GX1)
 
 static int CheckForMasterAbort(void)
 {
@@ -352,19 +322,33 @@
 	return 0;
 }
 
-/* Write to config register */
-static int st40pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+static int st40pci_read_as_bytes(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 * val)
 {
+	volatile u8 part0,part1,part2,part3;
+
+	CheckForMasterAbort();
+
 	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 	switch (size) {
 		case 1:
 			*val = (u8)ST40PCI_READ_BYTE(PDR + (where & 3));
 			break;
 		case 2:
-			*val = (u16)ST40PCI_READ_SHORT(PDR + (where & 2));
+			part0 = ST40PCI_READ_BYTE(PDR + (where & 2));
+			udelay(2);
+			part1 = ST40PCI_READ_BYTE(PDR + (where & 2) + 1);
+			*val= (part0)| (part1<<8);
 			break;
 		case 4:
-			*val = ST40PCI_READ(PDR);
+			part0 = ST40PCI_READ_BYTE(PDR);
+			udelay(2);
+			part1 = ST40PCI_READ_BYTE(PDR+1);
+			udelay(2);
+			part2 = ST40PCI_READ_BYTE(PDR+2);
+			udelay(2);
+			part3 = ST40PCI_READ_BYTE(PDR+3);
+			*val = part0|(part1<<8)|(part2<<16)|(part3<<24);
 			break;
 	}
 
@@ -385,19 +369,32 @@
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int st40pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+static int st40pci_write_as_bytes(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 val)
 {
-	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 
+	CheckForMasterAbort();
+
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 	switch (size) {
 		case 1:
 			ST40PCI_WRITE_BYTE(PDR + (where & 3), (u8)val);
 			break;
 		case 2:
-			ST40PCI_WRITE_SHORT(PDR + (where & 2), (u16)val);
+			ST40PCI_WRITE_BYTE(PDR + (where & 2), (val & 0xff));
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR + (where & 2) + 1 , (val>>8) & 0xff);
+			udelay(2);
 			break;
 		case 4:
-			ST40PCI_WRITE(PDR, val);
+			ST40PCI_WRITE_BYTE(PDR, val & 0xff);
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+1, (val>>8) & 0xff );
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+2, (val>>16) & 0xff);
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+3, (val>>24) & 0xff);
+			udelay(2);
 			break;
 	}
 
@@ -407,61 +404,93 @@
 }
 
 struct pci_ops st40pci_config_ops = {
-	.read = 	st40pci_read,
-	.write = 	st40pci_write,
+	.read = 	st40pci_read_as_bytes,
+	.write = 	st40pci_write_as_bytes,
 };
 
+#else /* CONFIG_CPU_SUBTYPE_ST40STB1 || CONFIG_CPU_SUBTYPE_ST40GX1 */
 
-/* Everything hangs off this */
-static struct pci_bus *pci_root_bus;
-
-static int __init pcibios_init(void)
+static int st40pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
 {
-	extern unsigned long memory_start, memory_end;
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
+	switch (size) {
+		case 1:
+			*val = (u8)ST40PCI_READ_BYTE(PDR + (where & 3));
+			break;
+		case 2:
+			*val = (u16)ST40PCI_READ_SHORT(PDR + (where & 2));
+			break;
+		case 4:
+			*val = ST40PCI_READ(PDR);
+			break;
+	}
 
-	printk(KERN_ALERT "pci-st40.c: pcibios_init\n");
+	return PCIBIOS_SUCCESSFUL;
+}
 
-	if (sh_mv.mv_init_pci != NULL) {
-		sh_mv.mv_init_pci();
+static int st40pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
+
+	switch (size) {
+		case 1:
+			ST40PCI_WRITE_BYTE(PDR + (where & 3), (u8)val);
+			break;
+		case 2:
+			ST40PCI_WRITE_SHORT(PDR + (where & 2), (u16)val);
+			break;
+		case 4:
+			ST40PCI_WRITE(PDR, val);
+			break;
 	}
 
-	/* The pci subsytem needs to know where memory is and how much 
-	 * of it there is. I've simply made these globals. A better mechanism
-	 * is probably needed.
-	 */
-	st40pci_init(PHYSADDR(memory_start),
-		     PHYSADDR(memory_end) - PHYSADDR(memory_start));
+	return PCIBIOS_SUCCESSFUL;
+}
 
-	if (request_irq(ST40PCI_ERR_IRQ, st40_pci_irq, 
-                        IRQF_DISABLED, "st40pci", NULL)) {
-		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
-		return -EIO;
-	}
+struct pci_ops st40pci_config_ops = {
+	.read = 	st40pci_read,
+	.write = 	st40pci_write,
+};
 
-	/* Enable the PCI interrupts on the device */
-	ST40PCI_WRITE(INTM, ~0);
-	ST40PCI_WRITE(AINT, ~0);
+#endif /* CONFIG_CPU_SUBTYPE_ST40STB1 || CONFIG_CPU_SUBTYPE_ST40GX1 */
 
-	/* Map the io address apprioately */
-#ifdef CONFIG_HD64465
-	hd64465_port_map(PCIBIOS_MIN_IO, (64 * 1024) - PCIBIOS_MIN_IO + 1,
-			 ST40_IO_ADDR + PCIBIOS_MIN_IO, 0);
-#endif
+static struct resource st40pci_io_resource = {
+	.name		= "ST40 PCI IO",
+	.start		= ST40_PCI_IO,
+	.end		= (64*1024) - 1,
+	.flags		= IORESOURCE_IO,
+};
 
-	/* ok, do the scan man */
-	pci_root_bus = pci_scan_bus(0, &st40pci_config_ops, NULL);
-	pci_assign_unassigned_resources();
+static struct resource st40pci_mem_resource = {
+	.name		= "ST40 PCI Mem",
+	.start		= ST40_PCI_MEM,
+	.end		= ST40_PCI_MEM + (96*1024*1024) - 1,
+	.flags		= IORESOURCE_MEM,
+};
 
-	return 0;
+struct pci_channel board_pci_channels[]={
+	{&st40pci_config_ops,&st40pci_io_resource,&st40pci_mem_resource,0,0},
+	{NULL,NULL,NULL,0,0}
+};
+
+static int __init st40pci_init(void)
+{
+	extern unsigned long memory_start, memory_end;
+
+	/* We could potentially do some checks here to make sure we can
+	 * access the host, eg checking for the host PAR and device ID */
+
+	return st40pci_host_init(memory_start, memory_end - memory_start);
 }
-subsys_initcall(pcibios_init);
+
+arch_initcall(st40pci_init);
 
 /*
  * Publish a region of local address space over the PCI bus
  * to other devices.
  */
-static void pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
-			 unsigned long pciOffset, unsigned long regionSize)
+void st40pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
+			     unsigned long pciOffset, unsigned long regionSize)
 {
 	unsigned long mask;
 
@@ -486,3 +515,16 @@
 	ST40PCI_WRITE_INDEXED(RSR, region, mask | 1);
 }
 
+/*
+ * Make a previously published region of local address space
+ * inaccessible to other PCI devices.
+ */
+void st40pci_clear_rbar_region(unsigned int region)
+{
+	if (region > 7)
+		return;
+
+	ST40PCI_WRITE_INDEXED(RSR, region, 0);
+	ST40PCI_WRITE_INDEXED(RBAR, region, 0);
+	ST40PCI_WRITE_INDEXED(RLAR, region, 0);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/drivers/pci/pci-st40.h linux-2.6.23.1-stm/arch/sh/drivers/pci/pci-st40.h
--- linux-2.6.23.1/arch/sh/drivers/pci/pci-st40.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/drivers/pci/pci-st40.h	2007-11-01 12:00:39.000000000 +0000
@@ -2,7 +2,7 @@
  * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
  *
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
+ * License.  See linux/COPYING for more information.
  *
  * Definitions for the ST40 PCI hardware.
  */
@@ -10,6 +10,19 @@
 #ifndef __PCI_ST40_H__
 #define __PCI_ST40_H__
 
+#define ST40PCI_BASE_ADDRESS     (0xb0000000)
+#define ST40PCI_MEM_ADDRESS      (ST40PCI_BASE_ADDRESS+0x0)
+#define ST40PCI_IO_ADDRESS       (ST40PCI_BASE_ADDRESS+0x06000000)
+#define ST40PCI_REG_ADDRESS      (ST40PCI_BASE_ADDRESS+0x07000000)
+
+#define ST40_PCI_IO     0x2000
+#define ST40_PCI_MEM    0x10000000
+
+#define ST40PCI_SERR_IRQ	64
+#define ST40PCI_ERR_IRQ        	65
+#define ST40PCI_AD_IRQ		66
+#define ST40PCI_PWR_DWN_IRQ	67
+
 #define ST40PCI_VCR_STATUS    0x00
 
 #define ST40PCI_VCR_VERSION   0x08
@@ -121,16 +134,67 @@
 /* H8 specific registers end here */
 
 
+/* H8 specific registers start here */
+#define ST40PCI_WCBAR         0x7c
+#define ST40PCI_LOCCFG_UNLOCK 0x34
+
+#define ST40PCI_RBAR0         0x100
+#define ST40PCI_RSR0          0x104
+#define ST40PCI_RLAR0         0x108
+
+#define ST40PCI_RBAR1         0x110
+#define ST40PCI_RSR1          0x114
+#define ST40PCI_RLAR1         0x118
+
+
+#define ST40PCI_RBAR2         0x120
+#define ST40PCI_RSR2          0x124
+#define ST40PCI_RLAR2         0x128
+
+#define ST40PCI_RBAR3         0x130
+#define ST40PCI_RSR3          0x134
+#define ST40PCI_RLAR3         0x138
+
+#define ST40PCI_RBAR4         0x140
+#define ST40PCI_RSR4          0x144
+#define ST40PCI_RLAR4         0x148
+
+#define ST40PCI_RBAR5         0x150
+#define ST40PCI_RSR5          0x154
+#define ST40PCI_RLAR5         0x158
+
+#define ST40PCI_RBAR6         0x160
+#define ST40PCI_RSR6          0x164
+#define ST40PCI_RLAR6         0x168
+
+#define ST40PCI_RBAR7         0x170
+#define ST40PCI_RSR7          0x174
+#define ST40PCI_RLAR7         0x178
+
+
+#define ST40PCI_RBAR(n)      (0x100+(0x10*(n)))
+#define ST40PCI_RSR(n)       (0x104+(0x10*(n)))
+#define ST40PCI_RLAR(n)      (0x108+(0x10*(n)))
+
+#define ST40PCI_PERF               0x80
+#define PERF_MASTER_WRITE_POSTING  (1<<4)
+/* H8 specific registers end here */
+
 /* These are configs space registers */
-#define ST40PCI_CSR_VID               0x10000
-#define ST40PCI_CSR_DID               0x10002
-#define ST40PCI_CSR_CMD               0x10004
-#define ST40PCI_CSR_STATUS            0x10006
-#define ST40PCI_CSR_MBAR0             0x10010
-#define ST40PCI_CSR_TRDY              0x10040
-#define ST40PCI_CSR_RETRY             0x10041
-#define ST40PCI_CSR_MIT               0x1000d
+#define ST40PCI_CSR			0x10000
+#define ST40PCI_CSR_VID			(ST40PCI_CSR + 0x000)
+#define ST40PCI_CSR_DID			(ST40PCI_CSR + 0x002)
+#define ST40PCI_CSR_CMD			(ST40PCI_CSR + 0x004)
+#define ST40PCI_CSR_STATUS		(ST40PCI_CSR + 0x006)
+#define ST40PCI_CSR_MBAR0		(ST40PCI_CSR + 0x010)
+#define ST40PCI_CSR_TRDY		(ST40PCI_CSR + 0x040)
+#define ST40PCI_CSR_RETRY		(ST40PCI_CSR + 0x041)
+#define ST40PCI_CSR_MIT			(ST40PCI_CSR + 0x00d)
+
+/* Functions and data exported by pci-st40.c */
+void st40pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
+			     unsigned long pciOffset, unsigned long regionSize);
+void st40pci_clear_rbar_region(unsigned int region);
 
-#define ST40_IO_ADDR 0xb6000000       
 
 #endif /* __PCI_ST40_H__ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/Makefile linux-2.6.23.1-stm/arch/sh/kernel/Makefile
--- linux-2.6.23.1/arch/sh/kernel/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -20,5 +20,5 @@
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
 obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
-obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_PM_SH3_FRQCR)	+= pm.o
 obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/Makefile linux-2.6.23.1-stm/arch/sh/kernel/cpu/Makefile
--- linux-2.6.23.1/arch/sh/kernel/cpu/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -12,3 +12,11 @@
 obj-$(CONFIG_SH_ADC)		+= adc.o
 
 obj-y	+= irq/ init.o clock.o
+
+# Most chips still use the Hitachi standard CPG which has a few standard
+# clocks. Those which do not can remove it here, and define a complete
+# new clock architecture in their own processor specific code.
+archclock-y					:= clock-cpg.o
+archclock-$(CONFIG_CPU_SUBTYPE_STB7100)	:=
+archclock-$(CONFIG_CPU_SUBTYPE_STX7200)	:=
+obj-y	+= $(archclock-y)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/clock-cpg.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/clock-cpg.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/clock-cpg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/clock-cpg.c	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,98 @@
+/*
+ * arch/sh/kernel/cpu/clock-cpg.c - SuperH clock framework for CPG style clocks
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This clock framework is derived from the OMAP version by:
+ *
+ *	Copyright (C) 2004 Nokia Corporation
+ *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/kref.h>
+#include <linux/seq_file.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/timer.h>
+
+/*
+ * Each subtype is expected to define the init routines for these clocks,
+ * as each subtype (or processor family) will have these clocks at the
+ * very least. These are all provided through the CPG, which even some of
+ * the more quirky parts (such as ST40, SH4-202, etc.) still have.
+ *
+ * The processor-specific code is expected to register any additional
+ * clock sources that are of interest.
+ */
+static struct clk master_clk = {
+	.name		= "master_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.rate		= CONFIG_SH_PCLK_FREQ,
+};
+
+static struct clk module_clk = {
+	.name		= "module_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk bus_clk = {
+	.name		= "bus_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk cpu_clk = {
+	.name		= "cpu_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED,
+};
+
+/*
+ * The ordering of these clocks matters, do not change it.
+ */
+static struct clk *onchip_clocks[] = {
+	&master_clk,
+	&module_clk,
+	&bus_clk,
+	&cpu_clk,
+};
+
+void __init __attribute__ ((weak))
+arch_init_clk_ops(struct clk_ops **ops, int type)
+{
+}
+
+void __init __attribute__ ((weak))
+arch_clk_init(void)
+{
+}
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	BUG_ON(!master_clk.rate);
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		arch_init_clk_ops(&clk->ops, i);
+		ret |= clk_register(clk);
+	}
+
+	arch_clk_init();
+
+	/* Kick the child clocks.. */
+	clk_set_rate(&master_clk, clk_get_rate(&master_clk));
+	clk_put(&master_clk);
+
+	return ret;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/clock.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/clock.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/clock.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/clock.c	2007-11-01 12:00:39.000000000 +0000
@@ -31,49 +31,6 @@
 static DEFINE_SPINLOCK(clock_lock);
 static DEFINE_MUTEX(clock_list_sem);
 
-/*
- * Each subtype is expected to define the init routines for these clocks,
- * as each subtype (or processor family) will have these clocks at the
- * very least. These are all provided through the CPG, which even some of
- * the more quirky parts (such as ST40, SH4-202, etc.) still have.
- *
- * The processor-specific code is expected to register any additional
- * clock sources that are of interest.
- */
-static struct clk master_clk = {
-	.name		= "master_clk",
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-	.rate		= CONFIG_SH_PCLK_FREQ,
-};
-
-static struct clk module_clk = {
-	.name		= "module_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-};
-
-static struct clk bus_clk = {
-	.name		= "bus_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-};
-
-static struct clk cpu_clk = {
-	.name		= "cpu_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED,
-};
-
-/*
- * The ordering of these clocks matters, do not change it.
- */
-static struct clk *onchip_clocks[] = {
-	&master_clk,
-	&module_clk,
-	&bus_clk,
-	&cpu_clk,
-};
-
 static void propagate_rate(struct clk *clk)
 {
 	struct clk *clkp;
@@ -291,16 +248,6 @@
 }
 EXPORT_SYMBOL_GPL(clk_put);
 
-void __init __attribute__ ((weak))
-arch_init_clk_ops(struct clk_ops **ops, int type)
-{
-}
-
-void __init __attribute__ ((weak))
-arch_clk_init(void)
-{
-}
-
 static int show_clocks(char *buf, char **start, off_t off,
 		       int len, int *eof, void *data)
 {
@@ -324,28 +271,6 @@
 	return p - buf;
 }
 
-int __init clk_init(void)
-{
-	int i, ret = 0;
-
-	BUG_ON(!master_clk.rate);
-
-	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
-		struct clk *clk = onchip_clocks[i];
-
-		arch_init_clk_ops(&clk->ops, i);
-		ret |= clk_register(clk);
-	}
-
-	arch_clk_init();
-
-	/* Kick the child clocks.. */
-	propagate_rate(&master_clk);
-	propagate_rate(&bus_clk);
-
-	return ret;
-}
-
 static int __init clk_proc_init(void)
 {
 	struct proc_dir_entry *p;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/init.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/init.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/init.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/init.c	2007-11-01 12:00:43.000000000 +0000
@@ -61,7 +61,7 @@
 /*
  * Generic first-level cache init
  */
-static void __init cache_init(void)
+static void __uses_jump_to_uncached  cache_init(void)
 {
 	unsigned long ccr, flags;
 
@@ -79,7 +79,7 @@
 	current_cpu_data.dcache.way_size = current_cpu_data.dcache.sets *
 				    current_cpu_data.dcache.linesz;
 
-	jump_to_P2();
+	jump_to_uncached();
 	ccr = ctrl_inl(CCR);
 
 	/*
@@ -156,7 +156,7 @@
 #endif
 
 	ctrl_outl(flags, CCR);
-	back_to_P1();
+	back_to_cached();
 }
 
 #ifdef CONFIG_SH_DSP
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/Makefile linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/Makefile
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/Makefile	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -5,3 +5,5 @@
 
 obj-$(CONFIG_CPU_HAS_IPR_IRQ)		+= ipr.o
 obj-$(CONFIG_CPU_HAS_MASKREG_IRQ)	+= maskreg.o
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= st40_ilc_sti5528.o ilc3_common.o
+obj-$(CONFIG_CPU_SUBTYPE_STX7200)	+= st40_ilc_stx7200.o ilc3_common.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/ilc3_common.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/ilc3_common.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/ilc3_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/ilc3_common.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+
+#define DRIVER_NAME "ilc3"
+
+void __iomem *ilc_base;
+
+void __init ilc_early_init(struct platform_device* pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	ilc_base = ioremap(pdev->resource[0].start, size);
+}
+
+static int __init ilc_probe(struct platform_device *pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+		return -EBUSY;
+
+	/* Have we already been set up through ilc_early_init? */
+	if (ilc_base)
+		return 0;
+
+	ilc_early_init(pdev);
+
+	return 0;
+}
+
+static struct platform_driver ilc_driver = {
+	.probe		= ilc_probe,
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ilc_init(void)
+{
+	return platform_driver_register(&ilc_driver);
+}
+
+arch_initcall(ilc_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/intc.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/intc.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/intc.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/intc.c	2007-11-01 12:00:40.000000000 +0000
@@ -66,7 +66,7 @@
 static inline struct intc_desc_int *get_intc_desc(unsigned int irq)
 {
 	struct irq_chip *chip = get_irq_chip(irq);
-	return (void *)((char *)chip - offsetof(struct intc_desc_int, chip));
+	return container_of(chip, struct intc_desc_int, chip);
 }
 
 static inline unsigned int set_field(unsigned int value,
@@ -84,31 +84,37 @@
 static void write_8(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outb(set_field(0, data, h), addr);
+	(void)ctrl_inb(addr);	/* Defeat write posting */
 }
 
 static void write_16(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outw(set_field(0, data, h), addr);
+	(void)ctrl_inw(addr);	/* Defeat write posting */
 }
 
 static void write_32(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outl(set_field(0, data, h), addr);
+	(void)ctrl_inl(addr);	/* Defeat write posting */
 }
 
 static void modify_8(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outb(set_field(ctrl_inb(addr), data, h), addr);
+	(void)ctrl_inb(addr);	/* Defeat write posting */
 }
 
 static void modify_16(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outw(set_field(ctrl_inw(addr), data, h), addr);
+	(void)ctrl_inw(addr);	/* Defeat write posting */
 }
 
 static void modify_32(unsigned long addr, unsigned long h, unsigned long data)
 {
 	ctrl_outl(set_field(ctrl_inl(addr), data, h), addr);
+	(void)ctrl_inl(addr);	/* Defeat write posting */
 }
 
 enum {	REG_FN_ERR = 0, REG_FN_WRITE_BASE = 1, REG_FN_MODIFY_BASE = 5 };
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/ipr.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/ipr.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/ipr.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/ipr.c	2007-11-01 12:00:40.000000000 +0000
@@ -34,6 +34,7 @@
 	unsigned long addr = get_ipr_desc(irq)->ipr_offsets[p->ipr_idx];
 	/* Set the priority in IPR to 0 */
 	ctrl_outw(ctrl_inw(addr) & (0xffff ^ (0xf << p->shift)), addr);
+	ctrl_inw(addr);	/* Read back to flush write posting */
 }
 
 static void enable_ipr_irq(unsigned int irq)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc.h linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc.h
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,42 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ * Author: Henry Bell <henry.bell@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for ST40 Interrupt Level Controler (ILC).
+ */
+
+extern void __iomem *ilc_base;
+
+#define _BIT(_int)		     (1 << (_int % 32))
+#define _REG_OFF(_int)		     (sizeof(int) * (_int / 32))
+
+#define ILC_INTERRUPT_REG(_int)      (ilc_base + 0x080 + _REG_OFF(_int))
+#define ILC_STATUS_REG(_int)         (ilc_base + 0x200 + _REG_OFF(_int))
+#define ILC_CLR_STATUS_REG(_int)     (ilc_base + 0x280 + _REG_OFF(_int))
+#define ILC_ENABLE_REG(_int)         (ilc_base + 0x400 + _REG_OFF(_int))
+#define ILC_CLR_ENABLE_REG(_int)     (ilc_base + 0x480 + _REG_OFF(_int))
+#define ILC_SET_ENABLE_REG(_int)     (ilc_base + 0x500 + _REG_OFF(_int))
+#define ILC_EXT_WAKEUP_EN_REG        (ilc_base + 0x600)
+#define ILC_EXT_WAKPOL_EN_REG        (ilc_base + 0x680)
+#define ILC_PRIORITY_REG(_int)       (ilc_base + 0x800 + (8 * _int))
+#define ILC_TRIGMODE_REG(_int)       (ilc_base + 0x804 + (8 * _int))
+
+/*
+ * Macros to get/set/clear ILC registers
+ */
+#define ILC_SET_ENABLE(_int)     ctrl_outl(_BIT(_int), ILC_SET_ENABLE_REG(_int))
+#define ILC_CLR_ENABLE(_int)     ctrl_outl(_BIT(_int), ILC_CLR_ENABLE_REG(_int))
+#define ILC_GET_ENABLE(_int)     (ctrl_inl(ILC_ENABLE_REG(_int)) & _BIT(_int))
+#define ILC_CLR_STATUS(_int)     ctrl_outl(_BIT(_int), ILC_CLR_STATUS_REG(_int))
+#define ILC_GET_STATUS(_int)     (ctrl_inl(ILC_STATUS_REG(_int)) & _BIT(_int))
+#define ILC_SET_PRI(_int, _pri)  ctrl_outl((_pri), ILC_PRIORITY_REG(_int))
+
+#define ILC_SET_TRIGMODE(_int, _mod) ctrl_outl((_mod), ILC_TRIGMODE_REG(_int))
+
+#define ILC_TRIGGERMODE_HIGH	1
+#define ILC_TRIGGERMODE_LOW	2
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,62 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for Interrupt Level Controler (ILC) on the STi5528.
+ *
+ * This is simply used to route external interrupt pins to the ST40's
+ * interrupt controller, optionally inverting them.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "st40_ilc.h"
+
+/*
+ * STi5528 initialisation function to set up the ILC
+ * The ST40 external interrupt management has a dependency on the
+ * ST20 ILC interrupt controller.
+ * Briefly on STi5528 interrupts:
+ * - interrupts rising from on chip devices are delivered to both CPUs,
+ *   ST40 via INTC2, and ST20 via ILC.  It's matter of software coherency
+ *   to guarantee that a specific device is "owned" by a single CPU
+ * - external interrupts (from PCI, STEMs, STi4629,...) come cross three
+ *   stages before reaching the ST40 INTC (IRL pins):
+ *   1) an EPLD, which provides:
+ *       -  Eval board (MB376): masking/unmasking control registers (like
+ *      		        other harp architectures) and multiplexes
+ *      		        the independent IRQs signals into 4 encoded
+ *      		        lines (input pins of STi5528).
+ *       -  Espresso board    : does nothing (currently EPLD is a pass through)
+ *
+ *   2) the 4 external lines go first to the ILC device because their polarity
+ *      could require to be inverted before reaching the ST40 INTC (it triggers
+ *      the interrupts on High level).
+ *      Currently this doesn't happen ... and all seems to work!! at least the
+ *      Ethernet)
+ *   3) finally the INTC manages the external interrupt (IRLs) as:
+ *      - on Eval board (MB376): 16 different encoded level
+ *      - on Espresso          : 4 independent signals
+ *
+ * An issue: it's likely that in the future linux will be in charge of
+ *           dealing with PCI devices while the STi4629 will probably be
+ *           managed by ST20 code.... concerning the interrupts this will
+ *           generate conflict between differnt CPUs when accessing the
+ *           ILC
+ */
+
+void __init ilc_route_external(int ilc_irq, int ext_out, int invert)
+{
+	ILC_SET_PRI(ilc_irq, 0x8000 | ext_out);
+	ILC_SET_TRIGMODE(ilc_irq, invert ? ILC_TRIGGERMODE_LOW : ILC_TRIGGERMODE_HIGH);
+	ILC_SET_ENABLE(ilc_irq);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,198 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupts routed through the Interrupt Level Controller (ILC3) on the STx7200
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq-ilc.h>
+
+#include "st40_ilc.h"
+
+struct ilc_data {
+	unsigned int priority;
+	struct list_head list;
+};
+
+static struct ilc_data ilc_data[ILC_NR_IRQS] =
+{
+	[0 ... ILC_NR_IRQS-1 ] = { .priority = 7 }
+};
+
+static struct list_head intc_data[16];
+
+static spinlock_t ilc_data_lock;
+
+/*
+ * Debug printk macro
+ */
+
+/* #define ILC_DEBUG */
+/* #define ILC_DEBUG_DEMUX */
+
+#ifdef ILC_DEBUG
+#define DPRINTK(args...)   printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+
+/*
+ * Beware this one; the ASC has ILC ints too...
+ */
+
+#ifdef ILC_DEBUG_DEMUX
+#define DPRINTK2(args...)   printk(args)
+#else
+#define DPRINTK2(args...)
+#endif
+
+/*
+ * The interrupt demux function. Check if this was an ILC interrupt, and
+ * of so which device generated the interrupt.
+ */
+
+void ilc_irq_demux(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int priority = 14 - irq;
+	unsigned int irq_offset;
+	struct ilc_data *this;
+	int handled = 0;
+
+	DPRINTK2("ilc demux got irq %d\n", irq);
+
+	list_for_each_entry(this, &intc_data[priority], list) {
+
+		irq_offset = this - ilc_data;
+
+		if (ILC_GET_STATUS(irq_offset) && ILC_GET_ENABLE(irq_offset)) {
+			struct irq_desc *desc = irq_desc + ILC_IRQ(irq_offset);
+
+			DPRINTK2("ilc found ilc %d active\n", irq_offset);
+			ILC_CLR_STATUS(irq_offset);
+			desc->handle_irq(ILC_IRQ(irq_offset), desc);
+			handled = 1;
+		}
+	}
+
+	if (!handled)
+		printk(KERN_INFO "ILC: spurious interrupt demux %d\n", irq);
+}
+
+static unsigned int startup_ilc_irq(unsigned int irq)
+{
+	struct ilc_data *this;
+	unsigned int priority;
+	int irq_offset = irq - ILC_FIRST_IRQ;
+	unsigned long flags;
+
+	DPRINTK("ilc startup irq %d\n", irq);
+
+	if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+		return -ENODEV;
+
+	this = &ilc_data[irq_offset];
+	priority = this->priority;
+
+	spin_lock_irqsave(&ilc_data_lock, flags);
+	list_add(&this->list, &intc_data[priority]);
+	spin_unlock_irqrestore(&ilc_data_lock, flags);
+
+	ILC_SET_PRI(irq_offset, priority);
+	ILC_SET_TRIGMODE(irq_offset, ILC_TRIGGERMODE_HIGH);
+
+	/* Gross hack for external Ethernet PHYs which are active low */
+	/* FIXME: Move this into the BSP code */
+	if ((irq_offset == 93)  ||  (irq_offset == 95)) {
+		ILC_SET_TRIGMODE(irq_offset, ILC_TRIGGERMODE_LOW);
+	}
+
+	ILC_SET_ENABLE(irq_offset);
+
+	return 0;
+}
+
+static void shutdown_ilc_irq(unsigned int irq)
+{
+	struct ilc_data *this;
+	unsigned int priority;
+	int irq_offset = irq - ILC_FIRST_IRQ;
+	unsigned long flags;
+
+	DPRINTK("ilc shutdown irq %d\n", irq);
+
+	if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+		return;
+
+	this = &ilc_data[irq_offset];
+	priority = this->priority;
+
+	ILC_CLR_ENABLE(irq_offset);
+	ILC_SET_PRI(irq_offset, 0);
+
+	spin_lock_irqsave(&ilc_data_lock, flags);
+	list_del(&this->list);
+	spin_unlock_irqrestore(&ilc_data_lock, flags);
+}
+
+static void enable_ilc_irq(unsigned int irq)
+{
+	int irq_offset = irq - ILC_FIRST_IRQ;
+DPRINTK2("%s: irq %d\n", __FUNCTION__, irq);
+	ILC_SET_ENABLE(irq_offset);
+}
+
+static void disable_ilc_irq(unsigned int irq)
+{
+	int irq_offset = irq - ILC_FIRST_IRQ;
+DPRINTK2("%s: irq %d\n", __FUNCTION__, irq);
+	ILC_CLR_ENABLE(irq_offset);
+}
+
+static void mask_and_ack_ilc(unsigned int irq)
+{
+	int irq_offset = irq - ILC_FIRST_IRQ;
+DPRINTK2("%s: irq %d\n", __FUNCTION__, irq);
+	ILC_CLR_ENABLE(irq_offset);
+	(void)ILC_GET_ENABLE(irq_offset); /* Defeat write posting */
+}
+
+static struct irq_chip ilc_chip = {
+	.name		= "ILC3-IRQ",
+	.startup	= startup_ilc_irq,
+	.shutdown	= shutdown_ilc_irq,
+	.mask		= disable_ilc_irq,
+	.mask_ack	= mask_and_ack_ilc,
+	.unmask		= enable_ilc_irq,
+};
+
+void __init ilc_stx7200_init(void)
+{
+	int irq;
+
+	DPRINTK("STx7200: Initialising ILC\n");
+
+	for (irq = ILC_FIRST_IRQ; irq < (ILC_FIRST_IRQ+ILC_NR_IRQS); irq++)
+		/* SIM: Should we do the masking etc in ilc_irq_demux and
+		 * then change this to handle_simple_irq? */
+		set_irq_chip_and_handler_name(irq, &ilc_chip, handle_level_irq,
+					      "ILC");
+
+	for (irq = 0; irq < 16; irq++) {
+		INIT_LIST_HEAD(&intc_data[irq]);
+	}
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh3/entry.S linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh3/entry.S
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh3/entry.S	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh3/entry.S	2007-11-01 12:00:43.000000000 +0000
@@ -13,8 +13,10 @@
 #include <linux/linkage.h>
 #include <asm/asm-offsets.h>
 #include <asm/thread_info.h>
-#include <asm/cpu/mmu_context.h>
 #include <asm/unistd.h>
+#include <asm/cpu/mmu_context.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
 
 ! NOTE:
 ! GNU as (as of 2.9.1) changes bf/s into bt/s and bra, when the address
@@ -66,6 +68,7 @@
 OFF_R7  =  28     	/* New ABI: arg3 */
 OFF_SP	=  (15*4)
 OFF_PC  =  (16*4)
+OFF_PR  =  (17*4)
 OFF_SR	=  (16*4+8)
 OFF_TRA	=  (16*4+6*4)
 
@@ -136,28 +139,13 @@
 
 call_dpf:
 	mov.l	1f, r0
-	mov	r5, r8
-	mov.l	@r0, r6
-	mov	r6, r9
-	mov.l	2f, r0
-	sts	pr, r10
-	jsr	@r0
-	 mov	r15, r4
-	!
-	tst	r0, r0
-	bf/s	0f
-	 lds	r10, pr
-	rts
-	 nop
-0:	mov.l	3f, r0
-	mov	r9, r6
-	mov	r8, r5
+ 	mov.l	@r0, r6		! address
+	mov.l	3f, r0
 	jmp	@r0
-	 mov	r15, r4
+ 	 mov	r15, r4		! regs
 
 	.align 2
 1:	.long	MMU_TEA
-2:	.long	__do_page_fault
 3:	.long	do_page_fault
 
 	.align	2
@@ -366,9 +354,171 @@
 !
 !
 
+/* gas doesn't flag impossible values for mov #immediate as an error */
+#if (_PAGE_PRESENT >> 2) > 0x7f
+#error cannot load PAGE_PRESENT as an immediate
+#endif
+#if _PAGE_DIRTY > 0x7f
+#error cannot load PAGE_DIRTY as an immediate
+#endif
+#if (_PAGE_PRESENT << 2) != _PAGE_ACCESSED
+#error cannot derive PAGE_ACCESSED from PAGE_PRESENT
+#endif
+
+#if defined(CONFIG_CPU_SH4)
+#define ldmmupteh(r)	mov.l	8f, r
+#else
+#define ldmmupteh(r)	mov	#MMU_PTEH, r
+#endif
+
 	.balign 	1024,0,1024
 tlb_miss:
-	mov.l	1f, k2
+#ifdef COUNT_EXCEPTIONS
+	! Increment the counts
+	mov.l	9f, k1
+	mov.l	@k1, k2
+	add	#1, k2
+	mov.l	k2, @k1
+#endif
+
+	! k0 scratch
+	! k1 pgd and pte pointers
+	! k2 faulting address
+	! k3 pgd and pte index masks
+	! k4 shift
+
+	! Load up the pgd entry (k1)
+
+	ldmmupteh(k0)			!  9 LS (latency=2)	MMU_PTEH
+
+	mov.w	4f, k3			!  8 LS (latency=2)	(PTRS_PER_PGD-1) << 2
+	mov	#-(PGDIR_SHIFT-2), k4	!  6 EX
+
+	mov.l	@(MMU_TEA-MMU_PTEH,k0), k2	! 18 LS (latency=2)
+
+	mov.l	@(MMU_TTB-MMU_PTEH,k0), k1	! 18 LS (latency=2)
+
+	mov	k2, k0			!   5 MT (latency=0)
+	shld	k4, k0			!  99 EX
+
+	and	k3, k0			!  78 EX
+
+	mov.l	@(k0, k1), k1		!  21 LS (latency=2)
+	mov	#-(PAGE_SHIFT-2), k4	!   6 EX
+
+	! Load up the pte entry (k2)
+
+	mov	k2, k0			!   5 MT (latency=0)
+	shld	k4, k0			!  99 EX
+
+	tst	k1, k1			!  86 MT
+
+	bt	20f			! 110 BR
+
+	mov.w	3f, k3			!  8 LS (latency=2)	(PTRS_PER_PTE-1) << 2
+	and	k3, k0			!  78 EX
+	mov.w	5f, k4			!   8 LS (latency=2)	_PAGE_PRESENT
+
+	mov.l	@(k0, k1), k2		!  21 LS (latency=2)
+	add	k0, k1			!  49 EX
+
+#ifdef CONFIG_CPU_HAS_PTEA
+	! Test the entry for present and _PAGE_ACCESSED
+
+	mov	#-28, k3		!   6 EX
+	mov	k2, k0			!   5 MT (latency=0)
+
+	tst	k4, k2			!  68 MT
+	shld	k3, k0			!  99 EX
+
+	bt	20f			! 110 BR
+
+	! Set PTEA register
+	! MMU_PTEA = ((pteval >> 28) & 0xe) | (pteval & 0x1)
+	!
+	! k0=pte>>28, k1=pte*, k2=pte, k3=<unused>, k4=_PAGE_PRESENT
+
+	and	#0xe, k0		!  79 EX
+
+	mov	k0, k3			!   5 MT (latency=0)
+	mov	k2, k0			!   5 MT (latency=0)
+
+	and	#1, k0			!  79 EX
+
+	or	k0, k3			!  82 EX
+
+	ldmmupteh(k0)			!   9 LS (latency=2)
+	shll2	k4			! 101 EX		_PAGE_ACCESSED
+
+	tst	k4, k2			!  68 MT
+
+	mov.l	k3, @(MMU_PTEA-MMU_PTEH,k0)	! 27 LS
+
+	mov.l	7f, k3			!   9 LS (latency=2)	_PAGE_FLAGS_HARDWARE_MASK
+
+	! k0=MMU_PTEH, k1=pte*, k2=pte, k3=_PAGE_FLAGS_HARDWARE, k4=_PAGE_ACCESSED
+#else
+
+	! Test the entry for present and _PAGE_ACCESSED
+
+	mov.l	7f, k3			!   9 LS (latency=2)	_PAGE_FLAGS_HARDWARE_MASK
+	tst	k4, k2			!  68 MT
+
+	shll2	k4			! 101 EX		_PAGE_ACCESSED
+	ldmmupteh(k0)			!   9 LS (latency=2)
+
+	bt	20f			! 110 BR
+	tst	k4, k2			!  68 MT
+
+	! k0=MMU_PTEH, k1=pte*, k2=pte, k3=_PAGE_FLAGS_HARDWARE, k4=_PAGE_ACCESSED
+
+#endif
+
+	! Set up the entry
+
+	and	k2, k3			!  78 EX
+	bt/s	10f			! 108 BR
+
+	 mov.l	k3, @(MMU_PTEL-MMU_PTEH,k0)	! 27 LS
+
+	ldtlb				! 128 CO
+
+	! At least one instruction between ldtlb and rte
+	nop				! 119 NOP
+
+	rte				! 126 CO
+
+	 nop				! 119 NOP
+
+
+10:	or	k4, k2			!  82 EX
+
+	ldtlb				! 128 CO
+
+	! At least one instruction between ldtlb and rte
+	mov.l	k2, @k1			!  27 LS
+
+	rte				! 126 CO
+
+	! Note we cannot execute mov here, because it is executed after
+	! restoring SSR, so would be executed in user space.
+	 nop				! 119 NOP
+
+
+	.align 5
+	! Once cache line if possible...
+1:	.long	swapper_pg_dir
+3:	.short	(PTRS_PER_PTE-1) << 2
+4:	.short	(PTRS_PER_PGD-1) << 2
+5:	.long	_PAGE_PRESENT
+7:	.long	_PAGE_FLAGS_HARDWARE_MASK
+8:	.long	MMU_PTEH
+#ifdef COUNT_EXCEPTIONS
+9:	.long	exception_count_miss
+#endif
+
+	! Either pgd or pte not present
+20:	mov.l	1f, k2
 	mov.l	4f, k3
 	bra	handle_exception
 	 mov.l	@k2, k2
@@ -409,6 +559,27 @@
 	! Using k0, k1 for scratch registers (r0_bank1, r1_bank),
 	! save all registers onto stack.
 	!
+
+#ifdef CONFIG_GUSA
+	! Check for roll back gRB (User and Kernel)
+	mov	r15, k0
+	shll	k0
+	bf/s	1f
+	 shll	k0
+	bf/s	1f
+	 stc	spc, k1
+	stc	r0_bank, k0
+	cmp/hs	k0, k1		! test k1 (saved PC) >= k0 (saved r0)
+	bt/s	2f
+	 stc	r1_bank, k1
+
+	add	#-2, k0
+	add	r15, k0
+	ldc	k0, spc		! PC = saved r0 + r15 - 2
+2:	mov	k1, r15		! SP = r1
+1:
+#endif
+
 	stc	ssr, k0		! Is it from kernel space?
 	shll	k0		! Check MD bit (bit30) by shifting it into...
 	shll	k0		!       ...the T bit
@@ -519,6 +690,15 @@
 	bf	interrupt_exception
 	shlr2	r8
 	shlr	r8
+
+#ifdef COUNT_EXCEPTIONS
+	mov.l	5f, r9
+	add	r8, r9
+	mov.l	@r9, r10
+	add	#1, r10
+	mov.l	r10, @r9
+#endif
+
 	mov.l	4f, r9
 	add	r8, r9
 	mov.l	@r9, r9
@@ -532,6 +712,9 @@
 2:	.long	0x000080f0	! FD=1, IMASK=15
 3:	.long	0xcfffffff	! RB=0, BL=0
 4:	.long	exception_handling_table
+#ifdef COUNT_EXCEPTIONS
+5:	.long	exception_count_table
+#endif
 
 interrupt_exception:
 	mov.l	1f, r9
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh3/probe.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh3/probe.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh3/probe.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh3/probe.c	2007-11-01 12:00:43.000000000 +0000
@@ -16,11 +16,11 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 
-int __init detect_cpu_and_cache_system(void)
+int __init __uses_jump_to_uncached detect_cpu_and_cache_system(void)
 {
 	unsigned long addr0, addr1, data0, data1, data2, data3;
 
-	jump_to_P2();
+	jump_to_uncached();
 	/*
 	 * Check if the entry shadows or not.
 	 * When shadowed, it's 128-entry system.
@@ -48,7 +48,7 @@
 	ctrl_outl(data0&~SH_CACHE_VALID, addr0);
 	ctrl_outl(data2&~SH_CACHE_VALID, addr1);
 
-	back_to_P1();
+	back_to_cached();
 
 	boot_cpu_data.dcache.ways		= 4;
 	boot_cpu_data.dcache.entry_shift	= 4;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/Makefile linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/Makefile
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -6,6 +6,7 @@
 common-y	+= $(addprefix ../sh3/, entry.o ex.o)
 
 obj-$(CONFIG_SH_FPU)			+= fpu.o
+obj-$(CONFIG_SH_FPU)			+= softfloat.o
 obj-$(CONFIG_SH_STORE_QUEUES)		+= sq.o
 
 # CPU subtype setup
@@ -17,10 +18,15 @@
 obj-$(CONFIG_CPU_SUBTYPE_SH7751R)	+= setup-sh7750.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7760)	+= setup-sh7760.o
 obj-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= setup-sh4-202.o
+obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= setup-st40ra.o
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= setup-stb7100.o
+obj-$(CONFIG_CPU_SUBTYPE_STX7200)	+= setup-stx7200.o
 
 # Primary on-chip clocks (common)
 ifndef CONFIG_CPU_SH4A
 clock-$(CONFIG_CPU_SH4)			:= clock-sh4.o
+clock-$(CONFIG_CPU_SUBTYPE_STB7100)	:= clock-stb7100.o
+clock-$(CONFIG_CPU_SUBTYPE_STX7200)	:= clock-stx7200.o
 endif
 
 # Additional clocks by subtype
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/clock-stb7100.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/clock-stb7100.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/clock-stb7100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/clock-stb7100.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2005 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Code to handle the clockgen hardware on the STb7100.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CLOCKGEN_BASE_ADDR	0x19213000	/* Clockgen A */
+
+static void __iomem *clkgen_base;
+
+#define CLOCKGEN_PLL0_CFG	0x08
+#define CLOCKGEN_PLL0_CLK1_CTRL	0x14
+#define CLOCKGEN_PLL0_CLK2_CTRL	0x18
+#define CLOCKGEN_PLL0_CLK3_CTRL	0x1c
+#define CLOCKGEN_PLL0_CLK4_CTRL	0x20
+#define CLOCKGEN_PLL1_CFG	0x24
+
+                               /* 0  1  2  3  4  5  6  7  */
+static unsigned char ratio1[] = { 1, 2, 3, 4, 6, 8 };
+static unsigned char ratio2[] = { 1, 2, 3, 4, 6, 8 };
+static unsigned char ratio3[] = { 4, 2, 4, 4, 6, 8 };
+static unsigned char ratio4[] = { 1, 2, 3, 4, 6, 8 };
+
+static int pll_freq(unsigned long addr)
+{
+	unsigned long freq, data, ndiv, pdiv, mdiv;
+
+	data = readl(clkgen_base+addr);
+	mdiv = (data >>  0) & 0xff;
+	ndiv = (data >>  8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+	freq = (((2 * (CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) /
+		(1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+static void pll0_clk_init(struct clk *clk)
+{
+	clk->rate = pll_freq(CLOCKGEN_PLL0_CFG);
+}
+
+static struct clk_ops pll0_clk_ops = {
+	.init		= pll0_clk_init,
+};
+
+static struct clk pll0_clk = {
+	.name		= "pll0_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &pll0_clk_ops,
+};
+
+static void pll1_clk_init(struct clk *clk)
+{
+	clk->rate = pll_freq(CLOCKGEN_PLL1_CFG);
+}
+
+static struct clk_ops pll1_clk_ops = {
+	.init		= pll1_clk_init,
+};
+
+static struct clk pll1_clk = {
+	.name		= "pll1_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &pll1_clk_ops,
+};
+
+#define DEFINE_CLKGEN_CLK(clock, pll, div_first, div)		\
+static void clock##_clk_recalc(struct clk *clk)			\
+{								\
+	div_first;						\
+	clk->rate = clk->parent->rate / (div);			\
+}								\
+								\
+static struct clk_ops clock##_clk_ops = {			\
+	.recalc		= clock##_clk_recalc,			\
+};								\
+								\
+static struct clk clock##_clk = {				\
+	.name		= #clock "_clk",				\
+	.parent		= &pll,					\
+	.flags		= CLK_ALWAYS_ENABLED,			\
+	.ops		= &clock##_clk_ops,			\
+};
+
+#define DEFINE_CLKGEN_RATIO_CLK(clock, pll, register, ratio)	\
+DEFINE_CLKGEN_CLK(clock, pll,					\
+		  unsigned long data = readl(clkgen_base+register) & 0x7, 2*ratio[data])
+
+DEFINE_CLKGEN_RATIO_CLK(sh4,    pll0_clk, CLOCKGEN_PLL0_CLK1_CTRL, ratio1)
+DEFINE_CLKGEN_RATIO_CLK(sh4_ic, pll0_clk, CLOCKGEN_PLL0_CLK2_CTRL, ratio2)
+DEFINE_CLKGEN_RATIO_CLK(module, pll0_clk, CLOCKGEN_PLL0_CLK3_CTRL, ratio3)
+DEFINE_CLKGEN_RATIO_CLK(slim,   pll0_clk, CLOCKGEN_PLL0_CLK4_CTRL, ratio4)
+
+DEFINE_CLKGEN_CLK(comms, pll1_clk, , 4)
+
+static struct clk *onchip_clocks[] = {
+	&pll0_clk,
+	&pll1_clk,
+	&sh4_clk,
+	&sh4_ic_clk,
+	&module_clk,
+	&slim_clk,
+	&comms_clk,
+};
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	clkgen_base = ioremap(CLOCKGEN_BASE_ADDR, 0x100);
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Propogate the PLL values down */
+	clk_set_rate(&pll0_clk, clk_get_rate(&pll0_clk));
+	clk_put(&pll0_clk);
+	clk_set_rate(&pll1_clk, clk_get_rate(&pll1_clk));
+	clk_put(&pll1_clk);
+
+	return ret;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/clock-stx7200.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/clock-stx7200.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/clock-stx7200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/clock-stx7200.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,655 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Code to handle the clockgen hardware on the STx7200.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+/* Values for mb519 */
+#define SYSACLKIN	27000000
+#define SYSBCLKIN	30000000
+
+/* Alternate clock for clockgen A, B and C respectivly */
+/* B & C come from SYSCLKINALT pin, SYSCLKINALT2 from PIO2[2] */
+unsigned long sysclkinalt[3] = { 0,0,0};
+
+#define CLOCKGEN_BASE_ADDR	0xfd700000	/* Clockgen A */
+#define CLOCKGENB_BASE_ADDR	0xfd701000	/* Clockgen B */
+
+#define CLOCKGEN_PLL_CFG(pll)	(CLOCKGEN_BASE_ADDR + ((pll)*0x4))
+#define   CLOCKGEN_PLL_CFG_BYPASS		(1<<20)
+#define CLOCKGEN_MUX_CFG	(CLOCKGEN_BASE_ADDR + 0x0c)
+#define   CLOCKGEN_MUX_CFG_SYSCLK_SRC		(1<<0)
+#define   CLOCKGEN_MUX_CFG_PLL_SRC(pll)		(1<<((pll)+1))
+#define   CLOCKGEN_MUX_CFG_DIV_SRC(pll)		(1<<((pll)+4))
+#define   CLOCKGEN_MUX_CFG_FDMA_SRC(fdma)	(1<<((fdma)+7))
+#define   CLOCKGEN_MUX_CFG_IC_REG_SRC		(1<<9)
+#define CLOCKGEN_DIV_CFG	(CLOCKGEN_BASE_ADDR + 0x10)
+#define CLOCKGEN_DIV2_CFG	(CLOCKGEN_BASE_ADDR + 0x14)
+#define CLOCKGEN_CLKOBS_MUX_CFG	(CLOCKGEN_BASE_ADDR + 0x18)
+#define CLOCKGEN_POWER_CFG	(CLOCKGEN_BASE_ADDR + 0x1c)
+
+#define CLOCKGENB_PLL0_CFG	(CLOCKGENB_BASE_ADDR + 0x3c)
+#define CLOCKGENB_IN_MUX_CFG	(CLOCKGENB_BASE_ADDR + 0x44)
+#define   CLOCKGENB_IN_MUX_CFG_PLL_SRC		(1<<0)
+#define CLOCKGENB_OUT_MUX_CFG	(CLOCKGENB_BASE_ADDR + 0x48)
+#define   CLOCKGENB_OUT_MUX_CFG_DIV_SRC		(1<<0)
+#define CLOCKGENB_DIV2_CFG	(CLOCKGENB_BASE_ADDR + 0x50)
+
+                                    /* 0  1  2  3  4  5  6     7  */
+static const unsigned int ratio1[] = { 1, 2, 3, 4, 6, 8, 1024, 1 };
+
+static unsigned long final_divider(unsigned long input, int div_ratio, int div)
+{
+	switch (div_ratio) {
+	case 1:
+		return input / 1024;
+	case 2:
+	case 3:
+		return input / div;
+	}
+
+	return 0;
+}
+
+static unsigned long pll02_freq(unsigned long input, unsigned long cfg)
+{
+	unsigned long freq, ndiv, pdiv, mdiv;
+
+	mdiv = (cfg >>  0) & 0xff;
+	ndiv = (cfg >>  8) & 0xff;
+	pdiv = (cfg >> 16) & 0x7;
+	freq = (((2 * (input / 1000) * ndiv) / mdiv) /
+		(1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+static unsigned long pll1_freq(unsigned long input, unsigned long cfg)
+{
+	unsigned long freq, ndiv, mdiv;
+
+	mdiv = (cfg >>  0) & 0x7;
+	ndiv = (cfg >>  8) & 0xff;
+	freq = (((input / 1000) * ndiv) / mdiv) * 1000;
+
+	return freq;
+}
+
+/* Note this returns the PLL frequency _after_ the bypass logic. */
+static unsigned long pll_freq(int pll_num)
+{
+	unsigned long sysabclkin, input, output;
+	unsigned long mux_cfg, pll_cfg;
+
+	mux_cfg = ctrl_inl(CLOCKGEN_MUX_CFG);
+	if ((mux_cfg & CLOCKGEN_MUX_CFG_SYSCLK_SRC) == 0) {
+		sysabclkin = SYSACLKIN;
+	} else {
+		sysabclkin = SYSBCLKIN;
+	}
+
+	if (mux_cfg & CLOCKGEN_MUX_CFG_PLL_SRC(pll_num)) {
+		input = sysclkinalt[0];
+	} else {
+		input = sysabclkin;
+	}
+
+	pll_cfg = ctrl_inl(CLOCKGEN_PLL_CFG(pll_num));
+	if (pll_num == 1) {
+		output = pll1_freq(input, pll_cfg);
+	} else {
+		output = pll02_freq(input, pll_cfg);
+	}
+
+	if ((pll_cfg & CLOCKGEN_PLL_CFG_BYPASS) == 0) {
+		return output;
+	} else if ((mux_cfg & CLOCKGEN_MUX_CFG_DIV_SRC(pll_num)) == 0) {
+		return input;
+	} else {
+		return sysabclkin;
+	}
+}
+
+struct pllclk
+{
+	struct clk clk;
+	unsigned long pll_num;
+};
+
+static void pll_clk_init(struct clk *clk)
+{
+	struct pllclk *pllclk = container_of(clk, struct pllclk, clk);
+
+	clk->rate = pll_freq(pllclk->pll_num);
+}
+
+static struct clk_ops pll_clk_ops = {
+	.init		= pll_clk_init,
+};
+
+static struct pllclk pllclks[3] = {
+	{
+		.clk = {
+			.name		= "pll0_clk",
+			.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops		= &pll_clk_ops,
+		},
+		.pll_num = 0
+	}, {
+		.clk = {
+			.name		= "pll1_clk",
+			.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops		= &pll_clk_ops,
+		},
+		.pll_num = 1
+	}, {
+		.clk = {
+			.name		= "pll2_clk",
+			.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops		= &pll_clk_ops,
+		},
+		.pll_num = 2
+	}
+};
+
+struct sh4clk
+{
+	struct clk clk;
+	unsigned long shift;
+};
+
+/* Note we ignore the possibility that we are in SH4 mode.
+ * Should check DIV_CFG.sh4_clk_ctl and switch to FRQCR mode. */
+static void sh4_clk_recalc(struct clk *clk)
+{
+	struct sh4clk *sh4clk = container_of(clk, struct sh4clk, clk);
+	unsigned long div_cfg = ctrl_inl(CLOCKGEN_DIV_CFG);
+	unsigned long div1, div2;
+
+	switch ((div_cfg >> 20) & 3) {
+	case 0:
+		clk->rate = 0;
+		return;
+	case 1:
+		div1 = 1;
+		break;
+	case 2:
+	case 3:
+		div1 = 2;
+		break;
+	}
+
+	div2 = ratio1[(div_cfg >> sh4clk->shift) & 7];
+	clk->rate = (clk->parent->rate / div1) / div2;
+
+	/* Note clk_sh4 and clk_sh4_ic have an extra clock gating
+	 * stage here based on DIV2_CFG bits 0 and 1. clk_sh4_per (aka
+	 * module_clock) doesn't.
+	 *
+	 * However if we ever implement this, remember that fdma0/1
+	 * may use clk_sh4 prior to the clock gating.
+	 */
+}
+
+static struct clk_ops sh4_clk_ops = {
+	.recalc		= sh4_clk_recalc,
+};
+
+static struct sh4clk sh4clks[3] = {
+	{
+		.clk = {
+			.name		= "sh4_clk",
+			.parent		= &pllclks[0].clk,
+			/* May propagate to FDMA */
+			.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops		= &sh4_clk_ops,
+		},
+		.shift = 1
+	}, {
+		.clk = {
+			.name		= "sh4_ic_clk",
+			.parent		= &pllclks[0].clk,
+			.flags		= CLK_ALWAYS_ENABLED,
+			.ops		= &sh4_clk_ops,
+		},
+		.shift = 4
+	}, {
+		.clk = {
+			.name		= "module_clk",
+			.parent		= &pllclks[0].clk,
+			.flags		= CLK_ALWAYS_ENABLED,
+			.ops		= &sh4_clk_ops,
+		},
+		.shift = 7
+	}
+};
+
+struct fdmalxclk {
+	struct clk clk;
+	char fdma_num;
+	char div_cfg_reg;
+	char div_cfg_shift;
+	char normal_div;
+};
+
+static void fdma_clk_init(struct clk *clk)
+{
+	struct fdmalxclk *fdmaclk = container_of(clk, struct fdmalxclk, clk);
+	unsigned long mux_cfg = ctrl_inl(CLOCKGEN_MUX_CFG);
+
+	if ((mux_cfg & CLOCKGEN_MUX_CFG_FDMA_SRC(fdmaclk->fdma_num)) == 0)
+		clk->parent = &sh4clks[0].clk;
+	else
+		clk->parent = &pllclks[1].clk;
+}
+
+static void fdmalx_clk_recalc(struct clk *clk)
+{
+	struct fdmalxclk *fdmalxclk = container_of(clk, struct fdmalxclk, clk);
+	unsigned long div_cfg;
+	unsigned long div_ratio;
+	unsigned long normal_div;
+
+	div_cfg = ctrl_inl(CLOCKGEN_DIV_CFG + fdmalxclk->div_cfg_reg);
+	div_ratio = (div_cfg >> fdmalxclk->div_cfg_shift) & 3;
+	normal_div = fdmalxclk->normal_div;
+	clk->rate = final_divider(clk->parent->rate, div_ratio, normal_div);
+}
+
+static struct clk_ops fdma_clk_ops = {
+	.init		= fdma_clk_init,
+	.recalc		= fdmalx_clk_recalc,
+};
+
+static struct clk_ops lx_clk_ops = {
+	.recalc		= fdmalx_clk_recalc,
+};
+
+static void ic266_clk_recalc(struct clk *clk)
+{
+	unsigned long div_cfg;
+	unsigned long div_ratio;
+
+	div_cfg = ctrl_inl(CLOCKGEN_DIV2_CFG);
+	div_ratio = ((div_cfg & (1<<5)) == 0) ? 1024 : 3;
+	clk->rate = clk->parent->rate / div_ratio;
+}
+
+static struct clk_ops ic266_clk_ops = {
+	.recalc		= ic266_clk_recalc,
+};
+
+#define CLKGENA(_name, _parent, _ops, _flags)			\
+	{							\
+		.name		= #_name,			\
+		.parent		= _parent,			\
+		.flags		= CLK_ALWAYS_ENABLED | _flags,	\
+		.ops		= &_ops,			\
+	}
+
+static struct clk miscclks[1] = {
+	CLKGENA(ic_266, &pllclks[2].clk, ic266_clk_ops, 0),
+};
+
+#define CLKGENA_FDMALX(_name, _parent, _ops, _fdma_num, _div_cfg_reg, _div_cfg_shift, _normal_div) \
+	{							\
+		.clk = {					\
+			.name		= #_name,		\
+			.parent		= _parent,		\
+			.flags		= CLK_ALWAYS_ENABLED,	\
+			.ops		= &_ops,		\
+		},						\
+		.fdma_num = _fdma_num,				\
+		.div_cfg_reg = _div_cfg_reg - CLOCKGEN_DIV_CFG,	\
+		.div_cfg_shift = _div_cfg_shift,		\
+		.normal_div = _normal_div,			\
+	}
+
+#define CLKGENA_FDMA(name, num)					\
+	CLKGENA_FDMALX(name, NULL, fdma_clk_ops, num,		\
+			CLOCKGEN_DIV_CFG, 10, 1)
+
+#define CLKGENA_LX(name, shift)				\
+	CLKGENA_FDMALX(name, &pllclks[1].clk, lx_clk_ops, 0,	\
+			CLOCKGEN_DIV_CFG, shift, 1)
+
+#define CLKGENA_MISCDIV(name, shift, ratio)		\
+	CLKGENA_FDMALX(name, &pllclks[2].clk, lx_clk_ops, 0,	\
+			CLOCKGEN_DIV2_CFG, shift, ratio)
+
+static struct fdmalxclk fdmaclks[2] = {
+	CLKGENA_FDMA(fdma_clk0, 0),
+	CLKGENA_FDMA(fdma_clk1, 1)
+};
+
+static struct fdmalxclk lxclks[4] = {
+	CLKGENA_LX(lx_aud0_cpu_clk, 12),
+	CLKGENA_LX(lx_aud1_cpu_clk, 14),
+	CLKGENA_LX(lx_dmu0_cpu_clk, 16),
+	CLKGENA_LX(lx_dmu1_cpu_clk, 18)
+};
+
+static struct fdmalxclk miscdivclks[4] = {
+	CLKGENA_MISCDIV(dmu0_266, 18, 3),
+	CLKGENA_MISCDIV(disp_266, 22, 3),
+	CLKGENA_MISCDIV(bdisp_200, 6, 4),
+	CLKGENA_MISCDIV(fdma_200, 14, 4)
+};
+
+static struct clk *clockgena_clocks[] = {
+	&pllclks[0].clk,
+	&pllclks[1].clk,
+	&pllclks[2].clk,
+	&sh4clks[0].clk,
+	&sh4clks[1].clk,
+	&sh4clks[2].clk,
+	&fdmaclks[0].clk,
+	&fdmaclks[1].clk,
+	&lxclks[0].clk,
+	&lxclks[1].clk,
+	&lxclks[2].clk,
+	&lxclks[3].clk,
+	&miscclks[0],
+	&miscdivclks[0].clk,
+	&miscdivclks[1].clk,
+	&miscdivclks[2].clk,
+	&miscdivclks[3].clk,
+};
+
+#define CLKGENB_BASE		0xfd701000
+#define CLKGENB_FS0_SETUP	(CLKGENB_BASE + 0x00)
+#define CLKGENB_FS1_SETUP	(CLKGENB_BASE + 0x04)
+#define CLKGENB_FS2_SETUP	(CLKGENB_BASE + 0x08)
+#define CLKGENB_FSx_CLKy_CFG(x,y)	\
+	(CLKGENB_BASE + ((x)*0x10) + (((y)-1)*4) + 0x00c)
+
+static unsigned long fsynth(unsigned long refclk, signed long md,
+			    unsigned long pe, unsigned long sdiv)
+{
+	  /*
+	   * The values in the registers need some 'interpretation'.
+	   * Note this is not documented in the 7100 datasheet, only the
+	   * 8000 architecture manual (vol 2):
+	   *   md: integer value of MD<4:0> range [-16, -1]
+	   *   pe: integer value of PE>15:0> range [0, 2^15-1]
+	   *   sdiv: value of the output divider as follows:
+	   *     SDIV<2:0> = '000' -> sidv = 2
+	   *     SDIV<2:0> = '001' -> sidv = 4
+	   *     ...
+	   *     SDIV<2:0> = '111' -> sidv = 256
+	   *
+	   *                                2^15 * Fpll
+	   * Fout = ------------------------------------------------------
+           *                           md                          md+1
+	   *        sdiv * [(pe * (1 + -- )) - ((pe - 2^15) * (1 + ---- ))]
+           *                           32                           32
+	   */
+
+	unsigned long f_pll = refclk * 8;
+	signed long part1;
+	signed long part2;
+	unsigned long long freq;
+
+	md = md - 32;
+	sdiv = 2 << sdiv;
+
+	part1 = (pe * (32+md)) / 32;
+	part2 = (((signed)pe - (1<<15)) * (32 + (md+1))) / 32;
+
+	freq = ((1ULL << 15) * f_pll) / (sdiv * (part1 - part2));
+	return freq;
+}
+
+struct fsclk
+{
+	struct clk clk;
+	unsigned long cfg_addr;
+	char name[8];
+};
+
+static void fs_clk_init(struct clk *clk)
+{
+	struct fsclk *fsclk = container_of(clk, struct fsclk, clk);
+	unsigned long data = ctrl_inl(fsclk->cfg_addr);
+	unsigned long pe, sdiv;
+	signed long md;
+
+	pe = (data >> 0) & 0xffff;
+	md = (data >> 16) & 0x1f;
+	sdiv = (data >> 22) & 7;
+	clk->rate = fsynth(CONFIG_SH_EXTERNAL_CLOCK, md, pe, sdiv);
+}
+
+static struct clk_ops fs_clk_ops = {
+	.init		= fs_clk_init,
+};
+
+static struct fsclk fsclks[12];
+
+
+static void pll_clkB_init(struct clk *clk)
+{
+	unsigned long input, output;
+	unsigned long mux_cfg, pll_cfg;
+
+	/* FIXME: probably needs more work! */
+
+	mux_cfg = ctrl_inl(CLOCKGENB_IN_MUX_CFG);
+	if (mux_cfg & CLOCKGENB_IN_MUX_CFG_PLL_SRC) {
+		input = sysclkinalt[1];
+	} else {
+		input = SYSBCLKIN;
+	}
+
+	pll_cfg = ctrl_inl(CLOCKGENB_PLL0_CFG);
+	output = pll02_freq(input, pll_cfg);
+
+	if (!(pll_cfg & CLOCKGEN_PLL_CFG_BYPASS)) {
+		clk->rate = output;
+	} else if (!(mux_cfg & CLOCKGENB_OUT_MUX_CFG_DIV_SRC)) {
+		clk->rate = input;
+	} else {
+		clk->rate = SYSBCLKIN;
+	}
+}
+
+static struct clk_ops pll_clkB_ops = {
+	.init		= pll_clkB_init,
+};
+
+static struct pllclk clkB_pllclks[1] = {
+	{
+		.clk = {
+			.name		= "b_pll0_clk",
+			.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops		= &pll_clkB_ops,
+		},
+		.pll_num = 0
+	}
+};
+
+#define CLKGENB(_name, _ops, _flags)				\
+	{							\
+		.name		= #_name,			\
+		.parent		= &clkB_pllclks[0].clk,		\
+		.flags		= CLK_ALWAYS_ENABLED | _flags,	\
+		.ops		= &_ops				\
+	}
+
+#define CLKGENB_DIV2(_name, _div_cfg_shift, _normal_div)	\
+	{							\
+		.clk = {					\
+			.name		= #_name,		\
+			.parent		= &clkB_pllclks[0].clk,	\
+			.flags		= CLK_ALWAYS_ENABLED,	\
+			.ops		= &clkgenb_div2_ops,	\
+		},						\
+		.div_cfg_shift = _div_cfg_shift,		\
+		.normal_div = _normal_div,			\
+	}
+
+
+struct clkgenBdiv2 {
+	struct clk clk;
+	char   div_cfg_shift;
+	char   normal_div;
+};
+
+static void clkgenb_div2_recalc(struct clk *clk)
+{
+	struct clkgenBdiv2 *clkgenBdiv2 = container_of(clk, struct clkgenBdiv2, clk);
+	unsigned long div_cfg;
+	unsigned long div_ratio;
+
+	div_cfg = ctrl_inl(CLOCKGENB_DIV2_CFG);
+	div_ratio = (div_cfg >> clkgenBdiv2->div_cfg_shift) & 3;
+	clk->rate = final_divider(clk->parent->rate, div_ratio,
+				  clkgenBdiv2->normal_div);
+}
+
+static struct clk_ops clkgenb_div2_ops = {
+	.recalc		= clkgenb_div2_recalc,
+};
+
+static struct clkgenBdiv2 clkB_div2clks[5] = {
+#define DIV2_B_BDISP266_CLOCK 0
+	CLKGENB_DIV2(bdisp_266, 16, 3),
+#define DIV2_B_COMPO200_CLOCK 1
+	CLKGENB_DIV2(compo_200,  8, 4),
+#define DIV2_B_DISP200_CLOCK 2
+	CLKGENB_DIV2(disp_200,  10, 4),
+#define DIV2_B_VDP200_CLOCK 3
+	CLKGENB_DIV2(vdp_200,   12, 4),
+#define DIV2_B_DMU1266_CLOCK 4
+	CLKGENB_DIV2(dmu1_266,  20, 3)
+};
+
+static void icreg_emi_eth_clk_recalc(struct clk *clk)
+{
+	unsigned long mux_cfg;
+	unsigned long div_ratio;
+
+	mux_cfg = ctrl_inl(CLOCKGEN_MUX_CFG);
+	div_ratio = ((mux_cfg & (CLOCKGEN_MUX_CFG_IC_REG_SRC)) == 0) ? 8 : 6;
+	clk->rate = clk->parent->rate / div_ratio;
+}
+
+static struct clk_ops icreg_emi_eth_clk_ops = {
+	.recalc		= icreg_emi_eth_clk_recalc,
+};
+
+static struct clk clkB_miscclks[3] = {
+	/* Propages to comms_clk */
+#define MISC_B_ICREG_CLOCK 0
+	CLKGENB(ic_reg,     icreg_emi_eth_clk_ops, CLK_RATE_PROPAGATES),
+#define MISC_B_ETHERNET_CLOCK 1
+	CLKGENB(ethernet,   icreg_emi_eth_clk_ops, 0),
+#define MISC_B_EMIMASTER_CLOCK 2
+	CLKGENB(emi_master, icreg_emi_eth_clk_ops, 0),
+};
+
+static struct clk *clockgenb_clocks[] = {
+	&clkB_pllclks[0].clk,
+
+	&clkB_div2clks[DIV2_B_BDISP266_CLOCK].clk,
+	&clkB_div2clks[DIV2_B_COMPO200_CLOCK].clk,
+	&clkB_div2clks[DIV2_B_DISP200_CLOCK].clk,
+	&clkB_div2clks[DIV2_B_VDP200_CLOCK].clk,
+	&clkB_div2clks[DIV2_B_DMU1266_CLOCK].clk,
+
+	&clkB_miscclks[MISC_B_ICREG_CLOCK],
+	&clkB_miscclks[MISC_B_ETHERNET_CLOCK],
+	&clkB_miscclks[MISC_B_EMIMASTER_CLOCK]
+};
+
+
+static void comms_clk_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate;
+}
+
+static struct clk_ops comms_clk_ops = {
+	.recalc		= comms_clk_recalc,
+};
+
+static struct clk comms_clk = {
+	.name		= "comms_clk",
+	.parent		= &clkB_miscclks[MISC_B_ICREG_CLOCK],
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &comms_clk_ops
+};
+
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+	int fs, clk;
+
+	/* Clockgen A */
+
+	for (i = 0; i < ARRAY_SIZE(clockgena_clocks); i++) {
+		struct clk *clk = clockgena_clocks[i];
+
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Propagate the PLL values down */
+	for (i=0; i<3; i++) {
+		clk_set_rate(&pllclks[i].clk, clk_get_rate(&pllclks[i].clk));
+		clk_put(&pllclks[i].clk);
+	}
+
+	/* Clockgen B */
+
+	for (fs=0; fs<3; fs++) {
+		for (clk=1; clk<5; clk++) {
+			struct fsclk *fsclk = &fsclks[(fs*4)+(clk-1)];
+
+			sprintf(fsclk->name, "fs%dclk%d", fs, clk);
+			fsclk->cfg_addr = CLKGENB_FSx_CLKy_CFG(fs, clk);
+			fsclk->clk.name = fsclk->name;
+			fsclk->clk.flags = CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES;
+			fsclk->clk.ops = &fs_clk_ops;
+
+			ret |= clk_register(&fsclk->clk);
+			clk_enable(&fsclk->clk);
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(clockgenb_clocks); i++) {
+		struct clk *clk = clockgenb_clocks[i];
+
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	ret |= clk_register(&comms_clk);
+	clk_enable(&comms_clk);
+
+	/* Propagate the PLL values down */
+	for (fs=0; fs<3; fs++) {
+		for (clk=1; clk<5; clk++) {
+			struct fsclk *fsclk = &fsclks[(fs*4)+(clk-1)];
+			struct clk *clk = &fsclk->clk;
+
+			clk_set_rate(clk, clk_get_rate(clk));
+			clk_put(clk);
+		}
+	}
+	for (i = 0; i < ARRAY_SIZE(clkB_pllclks); ++i) {
+		clk_set_rate(&clkB_pllclks[i].clk, clk_get_rate(&clkB_pllclks[i].clk));
+		clk_put(&clkB_pllclks[i].clk);
+	}
+
+	return ret;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/fpu.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/fpu.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/fpu.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/fpu.c	2007-11-01 12:00:40.000000000 +0000
@@ -9,8 +9,9 @@
  * for more details.
  *
  * Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
+ * Copyright (C) 2006  ST Microelectronics Ltd. (denorm support)
  *
- * FIXME! These routines can be optimized in big endian case.
+ * FIXME! These routines have not been tested for big endian case.
  */
 
 #include <linux/sched.h>
@@ -18,6 +19,7 @@
 #include <asm/processor.h>
 #include <asm/system.h>
 #include <asm/io.h>
+#include "sh4_fpu.h"
 
 /* The PR (precision) bit in the FP Status Register must be clear when
  * an frchg instruction is executed, otherwise the instruction is undefined.
@@ -25,113 +27,122 @@
  */
 
 #define FPSCR_RCHG 0x00000000
+extern unsigned long long float64_div(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_div(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_mul(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_mul(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_add(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_add(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_sub(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_sub(unsigned long int a, unsigned long int b);
 
+static unsigned int fpu_exception_flags;
 
 /*
  * Save FPU registers onto task structure.
  * Assume called with FPU enabled (SR.FD=0).
  */
-void
-save_fpu(struct task_struct *tsk, struct pt_regs *regs)
+void save_fpu(struct task_struct *tsk, struct pt_regs *regs)
 {
 	unsigned long dummy;
 
 	clear_tsk_thread_flag(tsk, TIF_USEDFPU);
 	enable_fpu();
-	asm volatile("sts.l	fpul, @-%0\n\t"
-		     "sts.l	fpscr, @-%0\n\t"
-		     "lds	%2, fpscr\n\t"
-		     "frchg\n\t"
-		     "fmov.s	fr15, @-%0\n\t"
-		     "fmov.s	fr14, @-%0\n\t"
-		     "fmov.s	fr13, @-%0\n\t"
-		     "fmov.s	fr12, @-%0\n\t"
-		     "fmov.s	fr11, @-%0\n\t"
-		     "fmov.s	fr10, @-%0\n\t"
-		     "fmov.s	fr9, @-%0\n\t"
-		     "fmov.s	fr8, @-%0\n\t"
-		     "fmov.s	fr7, @-%0\n\t"
-		     "fmov.s	fr6, @-%0\n\t"
-		     "fmov.s	fr5, @-%0\n\t"
-		     "fmov.s	fr4, @-%0\n\t"
-		     "fmov.s	fr3, @-%0\n\t"
-		     "fmov.s	fr2, @-%0\n\t"
-		     "fmov.s	fr1, @-%0\n\t"
-		     "fmov.s	fr0, @-%0\n\t"
-		     "frchg\n\t"
-		     "fmov.s	fr15, @-%0\n\t"
-		     "fmov.s	fr14, @-%0\n\t"
-		     "fmov.s	fr13, @-%0\n\t"
-		     "fmov.s	fr12, @-%0\n\t"
-		     "fmov.s	fr11, @-%0\n\t"
-		     "fmov.s	fr10, @-%0\n\t"
-		     "fmov.s	fr9, @-%0\n\t"
-		     "fmov.s	fr8, @-%0\n\t"
-		     "fmov.s	fr7, @-%0\n\t"
-		     "fmov.s	fr6, @-%0\n\t"
-		     "fmov.s	fr5, @-%0\n\t"
-		     "fmov.s	fr4, @-%0\n\t"
-		     "fmov.s	fr3, @-%0\n\t"
-		     "fmov.s	fr2, @-%0\n\t"
-		     "fmov.s	fr1, @-%0\n\t"
-		     "fmov.s	fr0, @-%0\n\t"
-		     "lds	%3, fpscr\n\t"
-		     : "=r" (dummy)
-		     : "0" ((char *)(&tsk->thread.fpu.hard.status)),
-		       "r" (FPSCR_RCHG),
-		       "r" (FPSCR_INIT)
-		     : "memory");
+	asm volatile ("sts.l	fpul, @-%0\n\t"
+		      "sts.l	fpscr, @-%0\n\t"
+		      "lds	%2, fpscr\n\t"
+		      "frchg\n\t"
+		      "fmov.s	fr15, @-%0\n\t"
+		      "fmov.s	fr14, @-%0\n\t"
+		      "fmov.s	fr13, @-%0\n\t"
+		      "fmov.s	fr12, @-%0\n\t"
+		      "fmov.s	fr11, @-%0\n\t"
+		      "fmov.s	fr10, @-%0\n\t"
+		      "fmov.s	fr9, @-%0\n\t"
+		      "fmov.s	fr8, @-%0\n\t"
+		      "fmov.s	fr7, @-%0\n\t"
+		      "fmov.s	fr6, @-%0\n\t"
+		      "fmov.s	fr5, @-%0\n\t"
+		      "fmov.s	fr4, @-%0\n\t"
+		      "fmov.s	fr3, @-%0\n\t"
+		      "fmov.s	fr2, @-%0\n\t"
+		      "fmov.s	fr1, @-%0\n\t"
+		      "fmov.s	fr0, @-%0\n\t"
+		      "frchg\n\t"
+		      "fmov.s	fr15, @-%0\n\t"
+		      "fmov.s	fr14, @-%0\n\t"
+		      "fmov.s	fr13, @-%0\n\t"
+		      "fmov.s	fr12, @-%0\n\t"
+		      "fmov.s	fr11, @-%0\n\t"
+		      "fmov.s	fr10, @-%0\n\t"
+		      "fmov.s	fr9, @-%0\n\t"
+		      "fmov.s	fr8, @-%0\n\t"
+		      "fmov.s	fr7, @-%0\n\t"
+		      "fmov.s	fr6, @-%0\n\t"
+		      "fmov.s	fr5, @-%0\n\t"
+		      "fmov.s	fr4, @-%0\n\t"
+		      "fmov.s	fr3, @-%0\n\t"
+		      "fmov.s	fr2, @-%0\n\t"
+		      "fmov.s	fr1, @-%0\n\t"
+		      "fmov.s	fr0, @-%0\n\t"
+		      "lds	%3, fpscr\n\t":"=r" (dummy)
+		      :"0"((char *)(&tsk->thread.fpu.hard.status)),
+		      "r"(FPSCR_RCHG), "r"(FPSCR_INIT)
+		      :"memory");
 
- 	disable_fpu();
- 	release_fpu(regs);
+	disable_fpu();
+	release_fpu(regs);
 }
 
-static void
-restore_fpu(struct task_struct *tsk)
+static void restore_fpu(struct task_struct *tsk)
 {
 	unsigned long dummy;
 
- 	enable_fpu();
-	asm volatile("lds	%2, fpscr\n\t"
-		     "fmov.s	@%0+, fr0\n\t"
-		     "fmov.s	@%0+, fr1\n\t"
-		     "fmov.s	@%0+, fr2\n\t"
-		     "fmov.s	@%0+, fr3\n\t"
-		     "fmov.s	@%0+, fr4\n\t"
-		     "fmov.s	@%0+, fr5\n\t"
-		     "fmov.s	@%0+, fr6\n\t"
-		     "fmov.s	@%0+, fr7\n\t"
-		     "fmov.s	@%0+, fr8\n\t"
-		     "fmov.s	@%0+, fr9\n\t"
-		     "fmov.s	@%0+, fr10\n\t"
-		     "fmov.s	@%0+, fr11\n\t"
-		     "fmov.s	@%0+, fr12\n\t"
-		     "fmov.s	@%0+, fr13\n\t"
-		     "fmov.s	@%0+, fr14\n\t"
-		     "fmov.s	@%0+, fr15\n\t"
-		     "frchg\n\t"
-		     "fmov.s	@%0+, fr0\n\t"
-		     "fmov.s	@%0+, fr1\n\t"
-		     "fmov.s	@%0+, fr2\n\t"
-		     "fmov.s	@%0+, fr3\n\t"
-		     "fmov.s	@%0+, fr4\n\t"
-		     "fmov.s	@%0+, fr5\n\t"
-		     "fmov.s	@%0+, fr6\n\t"
-		     "fmov.s	@%0+, fr7\n\t"
-		     "fmov.s	@%0+, fr8\n\t"
-		     "fmov.s	@%0+, fr9\n\t"
-		     "fmov.s	@%0+, fr10\n\t"
-		     "fmov.s	@%0+, fr11\n\t"
-		     "fmov.s	@%0+, fr12\n\t"
-		     "fmov.s	@%0+, fr13\n\t"
-		     "fmov.s	@%0+, fr14\n\t"
-		     "fmov.s	@%0+, fr15\n\t"
-		     "frchg\n\t"
-		     "lds.l	@%0+, fpscr\n\t"
-		     "lds.l	@%0+, fpul\n\t"
-		     : "=r" (dummy)
-		     : "0" (&tsk->thread.fpu), "r" (FPSCR_RCHG)
-		     : "memory");
+	enable_fpu();
+	asm volatile ("lds	%2, fpscr\n\t"
+		      "fmov.s	@%0+, fr0\n\t"
+		      "fmov.s	@%0+, fr1\n\t"
+		      "fmov.s	@%0+, fr2\n\t"
+		      "fmov.s	@%0+, fr3\n\t"
+		      "fmov.s	@%0+, fr4\n\t"
+		      "fmov.s	@%0+, fr5\n\t"
+		      "fmov.s	@%0+, fr6\n\t"
+		      "fmov.s	@%0+, fr7\n\t"
+		      "fmov.s	@%0+, fr8\n\t"
+		      "fmov.s	@%0+, fr9\n\t"
+		      "fmov.s	@%0+, fr10\n\t"
+		      "fmov.s	@%0+, fr11\n\t"
+		      "fmov.s	@%0+, fr12\n\t"
+		      "fmov.s	@%0+, fr13\n\t"
+		      "fmov.s	@%0+, fr14\n\t"
+		      "fmov.s	@%0+, fr15\n\t"
+		      "frchg\n\t"
+		      "fmov.s	@%0+, fr0\n\t"
+		      "fmov.s	@%0+, fr1\n\t"
+		      "fmov.s	@%0+, fr2\n\t"
+		      "fmov.s	@%0+, fr3\n\t"
+		      "fmov.s	@%0+, fr4\n\t"
+		      "fmov.s	@%0+, fr5\n\t"
+		      "fmov.s	@%0+, fr6\n\t"
+		      "fmov.s	@%0+, fr7\n\t"
+		      "fmov.s	@%0+, fr8\n\t"
+		      "fmov.s	@%0+, fr9\n\t"
+		      "fmov.s	@%0+, fr10\n\t"
+		      "fmov.s	@%0+, fr11\n\t"
+		      "fmov.s	@%0+, fr12\n\t"
+		      "fmov.s	@%0+, fr13\n\t"
+		      "fmov.s	@%0+, fr14\n\t"
+		      "fmov.s	@%0+, fr15\n\t"
+		      "frchg\n\t"
+		      "lds.l	@%0+, fpscr\n\t"
+		      "lds.l	@%0+, fpul\n\t"
+		      :"=r" (dummy)
+		      :"0"(&tsk->thread.fpu), "r"(FPSCR_RCHG)
+		      :"memory");
 	disable_fpu();
 }
 
@@ -141,61 +152,59 @@
  * double precision represents signaling NANS.  
  */
 
-static void
-fpu_init(void)
+static void fpu_init(void)
 {
 	enable_fpu();
-	asm volatile("lds	%0, fpul\n\t"
-		     "lds	%1, fpscr\n\t"
-		     "fsts	fpul, fr0\n\t"
-		     "fsts	fpul, fr1\n\t"
-		     "fsts	fpul, fr2\n\t"
-		     "fsts	fpul, fr3\n\t"
-		     "fsts	fpul, fr4\n\t"
-		     "fsts	fpul, fr5\n\t"
-		     "fsts	fpul, fr6\n\t"
-		     "fsts	fpul, fr7\n\t"
-		     "fsts	fpul, fr8\n\t"
-		     "fsts	fpul, fr9\n\t"
-		     "fsts	fpul, fr10\n\t"
-		     "fsts	fpul, fr11\n\t"
-		     "fsts	fpul, fr12\n\t"
-		     "fsts	fpul, fr13\n\t"
-		     "fsts	fpul, fr14\n\t"
-		     "fsts	fpul, fr15\n\t"
-		     "frchg\n\t"
-		     "fsts	fpul, fr0\n\t"
-		     "fsts	fpul, fr1\n\t"
-		     "fsts	fpul, fr2\n\t"
-		     "fsts	fpul, fr3\n\t"
-		     "fsts	fpul, fr4\n\t"
-		     "fsts	fpul, fr5\n\t"
-		     "fsts	fpul, fr6\n\t"
-		     "fsts	fpul, fr7\n\t"
-		     "fsts	fpul, fr8\n\t"
-		     "fsts	fpul, fr9\n\t"
-		     "fsts	fpul, fr10\n\t"
-		     "fsts	fpul, fr11\n\t"
-		     "fsts	fpul, fr12\n\t"
-		     "fsts	fpul, fr13\n\t"
-		     "fsts	fpul, fr14\n\t"
-		     "fsts	fpul, fr15\n\t"
-		     "frchg\n\t"
-		     "lds	%2, fpscr\n\t"
-		     : /* no output */
-		     : "r" (0), "r" (FPSCR_RCHG), "r" (FPSCR_INIT));
- 	disable_fpu();
+	asm volatile (	"lds	%0, fpul\n\t"
+			"lds	%1, fpscr\n\t"
+			"fsts	fpul, fr0\n\t"
+			"fsts	fpul, fr1\n\t"
+			"fsts	fpul, fr2\n\t"
+			"fsts	fpul, fr3\n\t"
+			"fsts	fpul, fr4\n\t"
+			"fsts	fpul, fr5\n\t"
+			"fsts	fpul, fr6\n\t"
+			"fsts	fpul, fr7\n\t"
+			"fsts	fpul, fr8\n\t"
+			"fsts	fpul, fr9\n\t"
+			"fsts	fpul, fr10\n\t"
+			"fsts	fpul, fr11\n\t"
+			"fsts	fpul, fr12\n\t"
+			"fsts	fpul, fr13\n\t"
+			"fsts	fpul, fr14\n\t"
+			"fsts	fpul, fr15\n\t"
+			"frchg\n\t"
+			"fsts	fpul, fr0\n\t"
+			"fsts	fpul, fr1\n\t"
+			"fsts	fpul, fr2\n\t"
+			"fsts	fpul, fr3\n\t"
+			"fsts	fpul, fr4\n\t"
+			"fsts	fpul, fr5\n\t"
+			"fsts	fpul, fr6\n\t"
+			"fsts	fpul, fr7\n\t"
+			"fsts	fpul, fr8\n\t"
+			"fsts	fpul, fr9\n\t"
+			"fsts	fpul, fr10\n\t"
+			"fsts	fpul, fr11\n\t"
+			"fsts	fpul, fr12\n\t"
+			"fsts	fpul, fr13\n\t"
+			"fsts	fpul, fr14\n\t"
+			"fsts	fpul, fr15\n\t"
+			"frchg\n\t"
+			"lds	%2, fpscr\n\t"
+			:	/* no output */
+		      	:"r" (0), "r"(FPSCR_RCHG), "r"(FPSCR_INIT));
+	disable_fpu();
 }
 
 /**
- *	denormal_to_double - Given denormalized float number,
- *	                     store double float
+ *      denormal_to_double - Given denormalized float number,
+ *                           store double float
  *
- *	@fpu: Pointer to sh_fpu_hard structure
- *	@n: Index to FP register
+ *      @fpu: Pointer to sh_fpu_hard structure
+ *      @n: Index to FP register
  */
-static void
-denormal_to_double (struct sh_fpu_hard_struct *fpu, int n)
+static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
 {
 	unsigned long du, dl;
 	unsigned long x = fpu->fpul;
@@ -212,7 +221,7 @@
 		dl = x << 29;
 
 		fpu->fp_regs[n] = du;
-		fpu->fp_regs[n+1] = dl;
+		fpu->fp_regs[n + 1] = dl;
 	}
 }
 
@@ -223,74 +232,208 @@
  *
  *	Returns 1 when it's handled (should not cause exception).
  */
-static int
-ieee_fpe_handler (struct pt_regs *regs)
+static int ieee_fpe_handler(struct pt_regs *regs)
 {
-	unsigned short insn = *(unsigned short *) regs->pc;
+	unsigned short insn = *(unsigned short *)regs->pc;
 	unsigned short finsn;
 	unsigned long nextpc;
 	int nib[4] = {
 		(insn >> 12) & 0xf,
 		(insn >> 8) & 0xf,
 		(insn >> 4) & 0xf,
-		insn & 0xf};
+		insn & 0xf
+	};
 
-	if (nib[0] == 0xb ||
-	    (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb)) /* bsr & jsr */
-		regs->pr = regs->pc + 4;
-  
-	if (nib[0] == 0xa || nib[0] == 0xb) { /* bra & bsr */
-		nextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xd) { /* bt/s */
+	if (nib[0] == 0xb || (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb))
+		regs->pr = regs->pc + 4;  /* bsr & jsr */
+
+	if (nib[0] == 0xa || nib[0] == 0xb) {
+		/* bra & bsr */
+		nextpc = regs->pc + 4 + ((short)((insn & 0xfff) << 4) >> 3);
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xd) {
+		/* bt/s */
 		if (regs->sr & 1)
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
 		else
 			nextpc = regs->pc + 4;
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xf) { /* bf/s */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xf) {
+		/* bf/s */
 		if (regs->sr & 1)
 			nextpc = regs->pc + 4;
 		else
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* jmp & jsr */
+			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x4 && nib[3] == 0xb && (nib[2] == 0x0 || nib[2] == 0x2)) {
+		/* jmp & jsr */
 		nextpc = regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* braf & bsrf */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x0 && nib[3] == 0x3 && (nib[2] == 0x0 || nib[2] == 0x2)) {
+		/* braf & bsrf */
 		nextpc = regs->pc + 4 + regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (insn == 0x000b) { /* rts */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (insn == 0x000b) {
+		/* rts */
 		nextpc = regs->pr;
-		finsn = *(unsigned short *) (regs->pc + 2);
+		finsn = *(unsigned short *)(regs->pc + 2);
 	} else {
 		nextpc = regs->pc + instruction_size(insn);
 		finsn = insn;
 	}
 
-	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
+	if ((finsn & 0xf1ff) == 0xf0ad) {
+		/* fcnvsd */
 		struct task_struct *tsk = current;
 
-		save_fpu(tsk, regs);
-		if ((tsk->thread.fpu.hard.fpscr & (1 << 17))) {
+		if ((tsk->thread.fpu.hard.fpscr & FPSCR_CAUSE_ERROR)) {
 			/* FPU error */
-			denormal_to_double (&tsk->thread.fpu.hard,
-					    (finsn >> 8) & 0xf);
-			tsk->thread.fpu.hard.fpscr &=
-				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
-			grab_fpu(regs);
-			restore_fpu(tsk);
-			set_tsk_thread_flag(tsk, TIF_USEDFPU);
+			denormal_to_double(&tsk->thread.fpu.hard,
+					   (finsn >> 8) & 0xf);
 		} else
-			force_sig(SIGFPE, tsk);
+			return 0;
 
 		regs->pc = nextpc;
 		return 1;
-	}
+	} else if ((finsn & 0xf00f) == 0xf002) {
+		/* fmul */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+			llx = float64_mul(llx, lly);
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			hx = float32_mul(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
+
+		regs->pc = nextpc;
+		return 1;
+	} else if ((finsn & 0xf00e) == 0xf000) {
+		/* fadd, fsub */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+			if ((finsn & 0xf00f) == 0xf000)
+				llx = float64_add(llx, lly);
+			else
+				llx = float64_sub(llx, lly);
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			if ((finsn & 0xf00f) == 0xf000)
+				hx = float32_add(hx, hy);
+			else
+				hx = float32_sub(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
+
+		regs->pc = nextpc;
+		return 1;
+
+	} else if ((finsn & 0xf003) == 0xf003) {
+		/* fdiv */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+
+			llx = float64_div(llx, lly);
+
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			hx = float32_div(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
 
-	return 0;
+		regs->pc = nextpc;
+		return 1;
+
+	} else
+
+		return 0;
+}
+
+void float_raise(unsigned int flags)
+{
+	fpu_exception_flags |= flags;
+}
+
+int float_rounding_mode(void)
+{
+	struct task_struct *tsk = current;
+	int roundingMode = FPSCR_ROUNDING_MODE(tsk->thread.fpu.hard.fpscr);
+	return roundingMode;
 }
 
 asmlinkage void
@@ -300,11 +443,23 @@
 	struct pt_regs *regs = RELOC_HIDE(&__regs, 0);
 	struct task_struct *tsk = current;
 
-	if (ieee_fpe_handler(regs))
-		return;
-
-	regs->pc += 2;
 	save_fpu(tsk, regs);
+	fpu_exception_flags = 0;
+	if (ieee_fpe_handler(regs)) {
+		tsk->thread.fpu.hard.fpscr &=
+		    ~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
+		tsk->thread.fpu.hard.fpscr |= fpu_exception_flags;
+		/* Set the FPSCR flag as well as cause bits - simply replicate the cause */
+		tsk->thread.fpu.hard.fpscr |= (fpu_exception_flags >> 10);
+		grab_fpu(&regs);
+		restore_fpu(tsk);
+		set_tsk_thread_flag(tsk, TIF_USEDFPU);
+		if ((((tsk->thread.fpu.hard.fpscr & FPSCR_ENABLE_MASK) >> 7) &
+		     (fpu_exception_flags >> 2)) == 0) {
+			return;
+		}
+	}
+
 	force_sig(SIGFPE, tsk);
 }
 
@@ -324,7 +479,7 @@
 	if (used_math()) {
 		/* Using the FPU again.  */
 		restore_fpu(tsk);
-	} else	{
+	} else {
 		/* First time FPU user.  */
 		fpu_init();
 		set_used_math();
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/probe.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/probe.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/probe.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/probe.c	2007-11-01 12:00:43.000000000 +0000
@@ -143,7 +143,12 @@
 		boot_cpu_data.type = CPU_ST40RA;
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
+	case 0x8002:
+		boot_cpu_data.type = CPU_STM8000;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
+		break;
 	case 0x8100:
+		/* Some bright spark used this same ID for the STi5528 */
 		boot_cpu_data.type = CPU_ST40GX1;
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
@@ -158,6 +163,20 @@
 		boot_cpu_data.dcache.ways = 2;
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
+	case 0x610 ... 0x611:
+		/* 0x0610 cut 1.x */
+		/* 0x0611 cut 2.x */
+		cpu_data->type = CPU_STB7100;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+		cpu_data->flags |= CPU_HAS_FPU;
+		break;
+	case 0x690:
+		cpu_data->type = CPU_STX7200;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+		cpu_data->flags |= CPU_HAS_FPU;
+		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
 		case 0x10:
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-st40ra.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-st40ra.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-st40ra.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-st40ra.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,187 @@
+/*
+ * ST40STB1/ST40RA Setup
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/io.h>
+#include <asm/sci.h>
+
+static struct resource rtc_resources[] = {
+	[0] = {
+		.start	= 0xffc80000,
+		.end	= 0xffc80000 + 0x58 - 1,
+		.flags	= IORESOURCE_IO,
+	},
+	[1] = {
+		/* Period IRQ */
+		.start	= 21,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* Carry IRQ */
+		.start	= 22,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		/* Alarm IRQ */
+		.start	= 20,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rtc_device = {
+	.name		= "sh-rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resources),
+	.resource	= rtc_resources,
+};
+
+static struct plat_sci_port sci_platform_data[] = {
+	{
+		.mapbase	= 0xffe00000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 23, 24, 26, 25 },
+	}, {
+		.mapbase	= 0xffe80000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 40, 41, 43, 42 },
+	}, {
+		.flags = 0,
+	}
+};
+
+static struct platform_device sci_device = {
+	.name		= "sh-sci",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= sci_platform_data,
+	},
+};
+
+static struct platform_device *st40ra_devices[] __initdata = {
+	&rtc_device,
+	&sci_device,
+};
+
+static int __init st40ra_devices_setup(void)
+{
+	return platform_add_devices(st40ra_devices,
+				    ARRAY_SIZE(st40ra_devices));
+}
+__initcall(st40ra_devices_setup);
+
+enum {
+	UNUSED = 0,
+
+	/* interrupt sources */
+	IRL0, IRL1, IRL2, IRL3, /* only IRLM mode described here */
+	HUDI,
+	TMU0, TMU1, TMU2_TUNI, TMU2_TICPI,
+	RTC_ATI, RTC_PRI, RTC_CUI,
+	SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI,
+	SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI,
+	WDT,
+	PCI_SERR, PCI_ERR, PCI_AD, PCI_PWR_DWN,
+	DMA0, DMA1, DMA2, DMA3, DMA4, DMA_ERR,
+	PIO0, PIO1, PIO2,
+
+	/* interrupt groups */
+	TMU2, RTC, SCIF1, SCIF2, PCI, DMAC, PIO,
+};
+
+static struct intc_vect vectors[] = {
+	INTC_VECT(HUDI, 0x600),
+	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
+	INTC_VECT(TMU2_TUNI, 0x440), INTC_VECT(TMU2_TICPI, 0x460),
+	INTC_VECT(RTC_ATI, 0x480), INTC_VECT(RTC_PRI, 0x4a0),
+	INTC_VECT(RTC_CUI, 0x4c0),
+	INTC_VECT(SCIF1_ERI, 0x4e0), INTC_VECT(SCIF1_RXI, 0x500),
+	INTC_VECT(SCIF1_BRI, 0x520), INTC_VECT(SCIF1_TXI, 0x540),
+	INTC_VECT(SCIF2_ERI, 0x700), INTC_VECT(SCIF2_RXI, 0x720),
+	INTC_VECT(SCIF2_BRI, 0x740), INTC_VECT(SCIF2_TXI, 0x760),
+	INTC_VECT(WDT, 0x560),
+	INTC_VECT(PCI_SERR, 0xa00), INTC_VECT(PCI_ERR, 0xa20),
+	INTC_VECT(PCI_AD, 0xa40), INTC_VECT(PCI_PWR_DWN, 0xa60),
+	INTC_VECT(DMA0, 0xb00), INTC_VECT(DMA1, 0xb20),
+	INTC_VECT(DMA1, 0xb40), INTC_VECT(DMA2, 0xb60),
+	INTC_VECT(DMA4, 0xb80), INTC_VECT(DMA_ERR, 0xbc0),
+	INTC_VECT(PIO0, 0xc00), INTC_VECT(PIO1, 0xc80),
+	INTC_VECT(PIO2, 0xd00),
+
+};
+
+static struct intc_group groups[] = {
+	INTC_GROUP(TMU2, TMU2_TUNI, TMU2_TICPI),
+	INTC_GROUP(RTC, RTC_ATI, RTC_PRI, RTC_CUI),
+	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
+	INTC_GROUP(SCIF2, SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI),
+	INTC_GROUP(PCI, PCI_ERR, PCI_AD, PCI_PWR_DWN),
+	INTC_GROUP(DMAC, DMA0, DMA1, DMA1, DMA2, DMA4, DMA_ERR),
+	INTC_GROUP(PIO, PIO0, PIO1, PIO2),
+};
+
+static struct intc_prio priorities[] = {
+	INTC_PRIO(SCIF1, 3),
+	INTC_PRIO(SCIF2, 3),
+	INTC_PRIO(DMAC, 7),
+};
+
+static struct intc_prio_reg prio_registers[] = {
+	{ 0xffd00004, 0, 16, 4, /* IPRA */     { TMU0, TMU1, TMU2,   RTC } },
+	{ 0xffd00008, 0, 16, 4, /* IPRB */     {  WDT,    0, SCIF1,    0 } },
+	{ 0xffd0000c, 0, 16, 4, /* IPRC */     {    0,    0, SCIF2, HUDI } },
+	{ 0xffd00010, 0, 16, 4, /* IPRD */     { IRL0, IRL1,  IRL2, IRL3 } },
+	{ 0xfe080000, 0, 32, 4, /* INTPRI00 */ {    0,    0,  PIO2, PIO1,
+						 PIO0, DMAC,   PCI, PCI_SERR } },
+};
+
+static struct intc_mask_reg mask_registers[] = {
+	{ 0xfe080040, 0xfe080060, 32, /* INTMSK00 / INTMSKCLR00 */
+	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 31..16 */
+	    0, PIO2, PIO1, PIO0,			/* 15..12 */
+	    DMA_ERR, 0, DMA4, DMA3,			/* 11...8 */
+	    DMA2, DMA1, DMA0, 0,			/*  7...4 */
+	    PCI_PWR_DWN, PCI_AD, PCI_ERR, PCI_SERR } }	/*  3...0 */
+};
+
+static DECLARE_INTC_DESC(intc_desc, "st40ra", vectors, groups,
+			 priorities, mask_registers, prio_registers, NULL);
+
+static struct intc_vect vectors_irlm[] = {
+	INTC_VECT(IRL0, 0x240), INTC_VECT(IRL1, 0x2a0),
+	INTC_VECT(IRL2, 0x300), INTC_VECT(IRL3, 0x360),
+};
+
+static DECLARE_INTC_DESC(intc_desc_irlm, "st40ra_irlm", vectors_irlm, NULL,
+			 priorities, NULL, prio_registers, NULL);
+
+void __init plat_irq_setup(void)
+{
+	register_intc_controller(&intc_desc);
+}
+
+#define INTC_ICR	0xffd00000UL
+#define INTC_ICR_IRLM   (1<<7)
+
+/* enable individual interrupt mode for external interupts */
+void __init plat_irq_setup_pins(int mode)
+{
+	switch (mode) {
+	case IRQ_MODE_IRQ: /* individual interrupt mode for IRL3-0 */
+		register_intc_controller(&intc_desc_irlm);
+		ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+		break;
+	default:
+		BUG();
+	}
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-stb7100.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-stb7100.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-stb7100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-stb7100.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1348 @@
+/*
+ * STx710x Setup
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/soc_init.h>
+#include <linux/stm/pio.h>
+#include <linux/phy.h>
+#include <linux/stm/sysconf.h>
+#include <linux/stm/emi.h>
+#include <linux/pata_platform.h>
+#include <asm/sci.h>
+#include <asm/irq-ilc.h>
+#include <linux/stm/fdma-plat.h>
+#include <linux/stm/fdma-reqs.h>
+
+static unsigned long chip_revision, chip_7109;
+static struct sysconf_field *sys_cfg7_0;
+
+static struct plat_sci_port sci_platform_data[] = {
+	{
+		.mapbase	= 0xffe00000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 26, 27, 28, 29 },
+	}, {
+		.mapbase	= 0xffe80000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 43, 44, 45, 46 },
+	}, {
+		.flags = 0,
+	}
+};
+
+static struct platform_device sci_device = {
+	.name		= "sh-sci",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= sci_platform_data,
+	},
+};
+
+static struct resource wdt_resource[] = {
+	/* Watchdog timer only needs a register address */
+	[0] = {
+		.start = 0xFFC00008,
+		.end = 0xFFC00010,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+struct platform_device wdt_device = {
+	.name = "wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(wdt_resource),
+	.resource = wdt_resource,
+};
+
+static struct resource rtc_resource[]= {
+	[0] = {
+		.start = 0xffc80000,
+		.end   = 0xffc80000 + 0x40,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 20,/* Alarm IRQ   */
+		.flags = IORESOURCE_IRQ
+	},
+	[2] = {
+		.start = 21,/* Periodic IRQ*/
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct platform_device rtc_device = {
+	.name		= "rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resource),
+	.resource	= rtc_resource,
+};
+
+/* USB resources ----------------------------------------------------------- */
+
+static struct resource st40_ohci_resources[] = {
+	[0] = {
+		.start	= 0x19100000 + 0xffc00,
+		.end	= 0x19100000 + 0xffcff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 168,
+		.end	= 168,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+static struct resource st40_ehci_resources[] = {
+	[0] =  {
+		.start	= 0x19100000 + 0xffe00,
+		.end	= 0x19100000 + 0xffeff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 169,
+		.end	= 169,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*
+ * Defines for the controller register offsets
+ */
+#define UHOST2C_BASE			0x19100000
+#define AHB2STBUS_WRAPPER_GLUE_BASE	(UHOST2C_BASE)
+#define AHB2STBUS_RESERVED1_BASE	(UHOST2C_BASE + 0x000e0000)
+#define AHB2STBUS_RESERVED2_BASE	(UHOST2C_BASE + 0x000f0000)
+#define AHB2STBUS_OHCI_BASE		(UHOST2C_BASE + 0x000ffc00)
+#define AHB2STBUS_EHCI_BASE		(UHOST2C_BASE + 0x000ffe00)
+#define AHB2STBUS_PROTOCOL_BASE		(UHOST2C_BASE + 0x000fff00)
+
+static struct sysconf_field *usb_power_sc;
+
+static void usb_power_up(void* dev)
+{
+	unsigned long reg;
+
+	/* Make sure PLL is on */
+	reg = sysconf_read(usb_power_sc);
+	if (reg) {
+		sysconf_write(usb_power_sc, 0);
+		mdelay(100);
+	}
+}
+
+static struct plat_usb_data usb_wrapper = {
+	.ahb2stbus_wrapper_glue_base = AHB2STBUS_WRAPPER_GLUE_BASE,
+	.ahb2stbus_protocol_base = AHB2STBUS_PROTOCOL_BASE,
+	.power_up = usb_power_up,
+	.initialised = 0,
+	.port_number = 0,
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device  st40_ohci_device = {
+	.name = "ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+		.platform_data = &usb_wrapper,
+	},
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+};
+
+static struct platform_device  st40_ehci_device = {
+	.name = "ST40-ehci",
+	.id=2,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+		.platform_data = &usb_wrapper,
+	},
+	.num_resources = ARRAY_SIZE(st40_ehci_resources),
+	.resource = st40_ehci_resources,
+};
+
+void __init stx7100_configure_usb(void)
+{
+	static struct stpio_pin *pin;
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 710x being active high.
+	 *
+	 * This test is wrong for 7100 cut 3.0 (which needs the work
+	 * around), but as we can't reliably determine the minor
+	 * revision number, hard luck, this works for most people.
+	 */
+	if ( ( chip_7109 && (chip_revision < 2)) ||
+	     (!chip_7109 && (chip_revision < 3)) ) {
+		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
+		stpio_set_pin(pin, 0);
+	}
+
+	/*
+	 * There have been two changes to the USB power enable signal:
+	 *
+	 * - 7100 upto and including cut 3.0 and 7109 1.0 generated an
+	 *   active high enables signal. From 7100 cut 3.1 and 7109 cut 2.0
+	 *   the signal changed to active low.
+	 *
+	 * - The 710x ref board (mb442) has always used power distribution
+	 *   chips which have active high enables signals (on rev A and B
+	 *   this was a TI TPS2052, rev C used the ST equivalent a ST2052).
+	 *   However rev A and B had a pull up on the enables signal, while
+	 *   rev C changed this to a pull down.
+	 *
+	 * The net effect of all this is that the easiest way to drive
+	 * this signal is ignore the USB hardware and drive it as a PIO
+	 * pin.
+	 *
+	 * (Note the USB over current input on the 710x changed from active
+	 * high to low at the same cuts, but board revs A and B had a resistor
+	 * option to select an inverted output from the TPS2052, so no
+	 * software work around is required.)
+	 */
+	pin = stpio_request_pin(5,7, "USBPWR", STPIO_OUT);
+	stpio_set_pin(pin, 1);
+
+	usb_power_sc = sysconf_claim(SYS_CFG, 2, 1, 1, "usb");
+
+	platform_device_register(&st40_ohci_device);
+	platform_device_register(&st40_ehci_device);
+}
+
+/* FDMA resources ---------------------------------------------------------- */
+
+#ifdef CONFIG_STM_DMA
+
+#include <linux/stm/7100_fdma2_firmware.h>
+#include <linux/stm/7109_cut2_fdma2_firmware.h>
+#include <linux/stm/7109_cut3_fdma2_firmware.h>
+
+static struct fdma_regs stb7100_fdma_regs = {
+	.fdma_id		= FDMA2_ID,
+	.fdma_ver		= FDAM2_VER,
+	.fdma_en		= FDMA2_ENABLE_REG,
+	.fdma_clk_gate		= FDMA2_CLOCKGATE,
+	.fdma_rev_id		= FDMA2_REV_ID,
+	.fdma_cmd_statn		= STB7100_FDMA_CMD_STATn_REG,
+	.fdma_ptrn		= STB7100_FDMA_PTR_REG,
+	.fdma_cntn		= STB7100_FDMA_COUNT_REG,
+	.fdma_saddrn		= STB7100_FDMA_SADDR_REG,
+	.fdma_daddrn		= STB7100_FDMA_DADDR_REG,
+	.fdma_req_ctln		= STB7100_FDMA_REQ_CTLn_REG,
+	.fdma_cmd_sta		= FDMA2_CMD_MBOX_STAT_REG,
+	.fdma_cmd_set		= FDMA2_CMD_MBOX_SET_REG,
+	.fdma_cmd_clr		= FDMA2_CMD_MBOX_CLR_REG,
+	.fdma_cmd_mask		= FDMA2_CMD_MBOX_MASK_REG,
+	.fdma_int_sta		= FDMA2_INT_STAT_REG,
+	.fdma_int_set		= FDMA2_INT_SET_REG,
+	.fdma_int_clr		= FDMA2_INT_CLR_REG,
+	.fdma_int_mask		= FDMA2_INT_MASK_REG,
+	.fdma_sync_reg		= FDMA2_SYNCREG,
+	.fdma_dmem_region	= STB7100_DMEM_OFFSET,
+	.fdma_imem_region	= STB7100_IMEM_OFFSET,
+};
+
+static struct fdma_regs stb7109_fdma_regs = {
+	.fdma_id		= FDMA2_ID,
+	.fdma_ver		= FDAM2_VER,
+	.fdma_en		= FDMA2_ENABLE_REG,
+	.fdma_clk_gate		= FDMA2_CLOCKGATE,
+	.fdma_rev_id		= FDMA2_REV_ID,
+	.fdma_cmd_statn		= STB7109_FDMA_CMD_STATn_REG,
+	.fdma_ptrn		= STB7109_FDMA_PTR_REG,
+	.fdma_cntn		= STB7109_FDMA_COUNT_REG,
+	.fdma_saddrn		= STB7109_FDMA_SADDR_REG,
+	.fdma_daddrn		= STB7109_FDMA_DADDR_REG,
+	.fdma_req_ctln		= STB7109_FDMA_REQ_CTLn_REG,
+	.fdma_cmd_sta		= FDMA2_CMD_MBOX_STAT_REG,
+	.fdma_cmd_set		= FDMA2_CMD_MBOX_SET_REG,
+	.fdma_cmd_clr		= FDMA2_CMD_MBOX_CLR_REG,
+	.fdma_cmd_mask		= FDMA2_CMD_MBOX_MASK_REG,
+	.fdma_int_sta		= FDMA2_INT_STAT_REG,
+	.fdma_int_set		= FDMA2_INT_SET_REG,
+	.fdma_int_clr		= FDMA2_INT_CLR_REG,
+	.fdma_int_mask		= FDMA2_INT_MASK_REG,
+	.fdma_sync_reg		= FDMA2_SYNCREG,
+	.fdma_dmem_region	= STB7109_DMEM_OFFSET,
+	.fdma_imem_region	= STB7109_IMEM_OFFSET,
+};
+
+static struct fdma_platform_device_data stb7109_C2_fdma_plat_data = {
+	.registers_ptr = &stb7109_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7109_fdmav2.8.bin",
+	.fw.data_reg = (unsigned long*)&STB7109_C2_DMEM_REGION,
+	.fw.imem_reg = (unsigned long*)&STB7109_C2_IMEM_REGION,
+	.fw.imem_fw_sz = STB7109_C2_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7109_C2_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7109_C2_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7109_C2_IMEM_REGION_LENGTH
+};
+
+static struct fdma_platform_device_data stb7109_C3_fdma_plat_data = {
+	.registers_ptr =(void*) &stb7109_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7109_fdmav3.0.bin",
+	.fw.data_reg = (unsigned long*)&STB7109_C3_DMEM_REGION,
+	.fw.imem_reg = (unsigned long*)&STB7109_C3_IMEM_REGION,
+	.fw.imem_fw_sz = STB7109_C3_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7109_C3_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7109_C3_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7109_C3_IMEM_REGION_LENGTH
+
+};
+
+static struct fdma_platform_device_data stb7100_Cx_fdma_plat_data = {
+	.registers_ptr =(void*) &stb7100_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num  =CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7100_fdmav2.8.bin",
+	.fw.data_reg = (unsigned long*)&STB7100_DMEM_REGION,
+	.fw.imem_reg = (unsigned long*)&STB7100_IMEM_REGION,
+	.fw.imem_fw_sz = STB7100_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7100_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7100_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7100_IMEM_REGION_LENGTH
+};
+
+#endif /* CONFIG_STM_DMA */
+
+static struct platform_device fdma_710x_device = {
+	.name		= "stmfdma",
+	.id		= -1,
+	.num_resources	= 2,
+	.resource = (struct resource[2]) {
+		[0] = {
+			.start = STB7100_FDMA_BASE,
+			.end   = STB7100_FDMA_BASE + 0x10000,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = LINUX_FDMA_STB7100_IRQ_VECT,
+			.end   = LINUX_FDMA_STB7100_IRQ_VECT,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+};
+
+static void fdma_setup(int chip_7109, int chip_revision)
+{
+#ifdef CONFIG_STM_DMA
+	if(chip_7109){
+		switch (chip_revision) {
+		case 1:
+			BUG();
+			break;
+		case 2:
+			fdma_710x_device.dev.platform_data =(void*) &stb7109_C2_fdma_plat_data;
+			break;
+		default:
+			fdma_710x_device.dev.platform_data =(void*) &stb7109_C3_fdma_plat_data;
+			break;
+		}
+	} else {
+		/* 7100 */
+		fdma_710x_device.dev.platform_data =(void*) &stb7100_Cx_fdma_plat_data;
+	}
+#endif
+}
+
+/* ALSA resources ---------------------------------------------------------- */
+
+static struct resource alsa_710x_resource_pcm0[3] = {
+
+	[0] = {/* allocatable channels*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags 	= IORESOURCE_IRQ
+	},
+	[1]= {/*fdma reqline*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ
+	},
+	[2] = {/*rising or falling edge I2s clocking
+		 1 == FALLING_EDGE
+		 0 == RISING EDGE */
+		 /*.start = runtime dependant*/
+		 /*.end = runtime dependant*/
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct resource alsa_710x_resource_pcm1[3] = {
+
+	[0] = {/* allocatable channels*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags 	= IORESOURCE_IRQ,
+	},
+	[1]= {/*fdma reqline*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {/*rising or falling edge I2s clocking
+		 1 == FALLING_EDGE
+		 0 == RISING EDGE */
+		 /*.start = runtime dependant*/
+		 /*.end = runtime dependant*/
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct resource alsa_710x_resource_spdif[2] = {
+
+	[0] = {/*min allocatable channels*/
+		.start = 2,
+		.end   =2,
+		.flags = IORESOURCE_IRQ
+	},
+	[1] = {/*fdma reqline*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct resource alsa_710x_resource_cnv[2] = {
+
+	[0] = {/*min allocatable channels*/
+		.start = 10,
+		.end   =10,
+		.flags = IORESOURCE_IRQ,
+	},
+	[1] = {/*fdma reqline*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource alsa_710x_resource_pcmin[3] = {
+
+	[0] = {/*min allocatable channels*/
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ,
+	},
+	[1] = {/*fdma reqline*/
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {/*rising or falling edge I2s clocking
+		 1 == FALLING_EDGE
+		 0 == RISING EDGE */
+		/*.start = runtime dependant*/
+		/*.end   = runtime dependant*/
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device alsa_710x_device_pcm0 = {
+	.name			= "710x_ALSA_PCM0",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcm0),
+	.resource		= alsa_710x_resource_pcm0,
+};
+
+static struct platform_device alsa_710x_device_pcm1 = {
+	.name			= "710x_ALSA_PCM1",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcm1),
+	.resource		= alsa_710x_resource_pcm1,
+};
+
+static struct platform_device alsa_710x_device_spdif = {
+	.name			= "710x_ALSA_SPD",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(alsa_710x_resource_spdif),
+	.resource		= alsa_710x_resource_spdif,
+};
+
+static struct platform_device alsa_710x_device_cnv = {
+	.name			= "710x_ALSA_CNV",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(alsa_710x_resource_cnv),
+	.resource		= alsa_710x_resource_cnv,
+};
+
+static struct platform_device alsa_710x_device_pcmin = {
+	.name			= "710x_ALSA_PCMIN",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(alsa_710x_resource_pcmin),
+	.resource		= alsa_710x_resource_pcmin,
+};
+
+static struct platform_device *alsa_devices[] __initdata = {
+	&alsa_710x_device_pcm0,
+	&alsa_710x_device_pcm1,
+ 	&alsa_710x_device_spdif,
+	&alsa_710x_device_cnv,
+	&alsa_710x_device_pcmin,
+};
+
+void __init stx7100_configure_alsa(void)
+{
+	if (chip_7109) {
+		switch (chip_revision) {
+		case 1:
+			alsa_710x_resource_pcm0[2].start =0;
+			alsa_710x_resource_pcm0[2].end = 0;
+
+			alsa_710x_resource_pcm1[2].start =0;
+			alsa_710x_resource_pcm1[2].end = 0;
+
+			alsa_710x_resource_pcmin[2].start = 1;
+			alsa_710x_resource_pcmin[2].end =   1;
+			break;
+		case 2:
+			alsa_710x_resource_pcm0[2].start =0;
+			alsa_710x_resource_pcm0[2].end = 0;
+
+			alsa_710x_resource_pcm1[2].start =0;
+			alsa_710x_resource_pcm1[2].end = 0;
+
+			alsa_710x_resource_pcmin[2].start = 0;
+			alsa_710x_resource_pcmin[2].end =   0;
+			break;
+		default:
+			/* 7109 cut >= 3.0 */
+			alsa_710x_resource_pcm0[2].start =1;
+			alsa_710x_resource_pcm0[2].end = 1;
+
+			alsa_710x_resource_pcm1[2].start =1;
+			alsa_710x_resource_pcm1[2].end = 1;
+
+			alsa_710x_resource_pcmin[2].start = 0;
+			alsa_710x_resource_pcmin[2].end =   0;
+			break;
+		}
+
+		alsa_710x_resource_pcm0[0].start = 2;
+		alsa_710x_resource_pcm0[0].end = 10;
+
+		alsa_710x_resource_pcm1[0].start = 2;
+		alsa_710x_resource_pcm1[0].end 	= 2;
+
+		alsa_710x_resource_pcm0[1].start = STB7109_FDMA_REQ_PCM_0;
+		alsa_710x_resource_pcm0[1].end = STB7109_FDMA_REQ_PCM_0;
+
+		alsa_710x_resource_pcm1[1].start = STB7109_FDMA_REQ_PCM_1;
+		alsa_710x_resource_pcm1[1].end = STB7109_FDMA_REQ_PCM_1;
+
+		alsa_710x_resource_spdif[1].start = STB7109_FDMA_REQ_SPDIF;
+		alsa_710x_resource_spdif[1].end =   STB7109_FDMA_REQ_SPDIF;
+
+		alsa_710x_resource_cnv[0].start =2;
+		alsa_710x_resource_cnv[0].end = 10;
+		alsa_710x_resource_cnv[1].start = STB7109_FDMA_REQ_PCM_0;
+		alsa_710x_resource_cnv[1].end = STB7109_FDMA_REQ_PCM_0;
+
+		alsa_710x_resource_pcmin[1].start = STB7109_FDMA_REQ_PCM_READ;
+		alsa_710x_resource_pcmin[1].end =   STB7109_FDMA_REQ_PCM_READ;
+	} else {
+		/* 7100 */
+		if(chip_revision >=3){
+			alsa_710x_resource_pcm0[0].start = 2;
+			alsa_710x_resource_pcm0[0].end = 10;
+			alsa_710x_resource_pcm1[0].start =2;
+			alsa_710x_resource_pcm1[0].end 	= 2;
+			alsa_710x_resource_cnv[0].start =2;
+			alsa_710x_resource_cnv[0].end = 10;
+		}
+		else {
+			alsa_710x_resource_pcm0[0].start = 10;
+			alsa_710x_resource_pcm0[0].end = 10;
+			alsa_710x_resource_pcm1[0].start = 10;
+			alsa_710x_resource_pcm1[0].end 	= 10;
+			alsa_710x_resource_cnv[0].start =10;
+			alsa_710x_resource_cnv[0].end = 10;
+		}
+		alsa_710x_resource_pcm0[1].start = STB7100_FDMA_REQ_PCM_0;
+		alsa_710x_resource_pcm0[1].end = STB7100_FDMA_REQ_PCM_0;
+
+		alsa_710x_resource_pcm1[1].start = STB7100_FDMA_REQ_PCM_1;
+		alsa_710x_resource_pcm1[1].end = STB7100_FDMA_REQ_PCM_1;
+
+		alsa_710x_resource_spdif[1].start =  STB7100_FDMA_REQ_SPDIF;
+		alsa_710x_resource_spdif[1].end =  STB7100_FDMA_REQ_SPDIF;
+
+		alsa_710x_resource_cnv[1].start = STB7100_FDMA_REQ_PCM_0;
+		alsa_710x_resource_cnv[1].end = STB7100_FDMA_REQ_PCM_0;
+
+		alsa_710x_resource_pcmin[1].start = STB7100_FDMA_REQ_PCM_READ;
+		alsa_710x_resource_pcmin[1].end =   STB7100_FDMA_REQ_PCM_READ;
+
+		alsa_710x_resource_pcm0[2].start =0;
+		alsa_710x_resource_pcm0[2].end = 0;
+
+		alsa_710x_resource_pcm1[2].start =0;
+		alsa_710x_resource_pcm1[2].end = 0;
+
+		alsa_710x_resource_pcmin[2].start = 0;
+		alsa_710x_resource_pcmin[2].end =   0;
+	}
+
+	platform_add_devices(alsa_devices, ARRAY_SIZE(alsa_devices));
+}
+
+/* SSC resources ----------------------------------------------------------- */
+
+static struct resource ssc_resource[] = {
+        [0] = {
+		.start	= 0x18040000,
+		.end	= 0x18040000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+        [1] = {
+		.start	= 0x18041000,
+		.end	= 0x18041000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+        [2] = {
+		.start	= 0x18042000,
+		.end	= 0x18042000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+        [3] = {
+		.start	= 119,
+		.end	= 119,
+		.flags	= IORESOURCE_IRQ,
+	},
+        [4] = {
+		.start	= 118,
+		.end	= 118,
+		.flags	= IORESOURCE_IRQ,
+	},
+        [5] = {
+		.start	= 117,
+		.end	= 117,
+               .flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+	{2, 0, 2, 1, 2, 2},
+	{3, 0, 3, 1, 3, 2},
+	{4, 0, 4, 1, 0xff, 0xff},
+};
+
+struct platform_device ssc_device = {
+        .name = "ssc",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(ssc_resource),
+        .resource = ssc_resource,
+};
+
+void __init stx7100_configure_ssc(struct plat_ssc_data *data)
+{
+	int i;
+	int capability;
+	struct sysconf_field* ssc_sc;
+
+	data->pio = ssc_pio;
+	ssc_device.dev.platform_data = data;
+
+	for (i=0, capability = data->capability;
+	     i<3;
+	     i++, capability >>= 2) {
+		if (! (capability & ((SSC_SPI_CAPABILITY|SSC_I2C_CAPABILITY) << (i*2))))
+			continue;
+
+		if (i== 0) {
+			ssc_sc = sysconf_claim(SYS_CFG, 7, 10, 10, "ssc");
+			sysconf_write(ssc_sc, 0);
+		}
+
+		ssc_sc = sysconf_claim(SYS_CFG, 7, i+1, i+1, "ssc");
+		sysconf_write(ssc_sc,
+			      capability & SSC_I2C_CAPABILITY ? 0 : 1);
+	}
+
+	platform_device_register(&ssc_device);
+}
+
+/* SATA resources ---------------------------------------------------------- */
+
+static struct resource sata_resource[]= {
+	[0] = {
+		.start = 0x18000000 + 0x01209000,
+		.end   = 0x18000000 + 0x01209000 + 0xfff,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 0xaa,
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct plat_sata_data sata_private_info;
+
+static struct platform_device sata_device = {
+	.name		= "sata_stm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(sata_resource),
+	.resource	= sata_resource,
+	.dev = {
+		.platform_data = &sata_private_info,
+	}
+};
+
+void __init stx7100_configure_sata(void)
+{
+	if ((! chip_7109) && (chip_revision == 1)) {
+		/* 7100 cut 1.x */
+		sata_private_info.phy_init = 0x0013704A;
+	} else {
+		/* 7100 cut 2.x and cut 3.x and 7109 */
+		sata_private_info.phy_init = 0x388fc;
+	}
+
+	if ((! chip_7109) || (chip_7109 && (chip_revision == 1))) {
+		sata_private_info.only_32bit = 1;
+		sata_private_info.pc_glue_logic_init = 0x1ff;
+	} else {
+		sata_private_info.only_32bit = 0;
+		sata_private_info.pc_glue_logic_init = 0x100ff;
+	}
+
+	platform_device_register(&sata_device);
+}
+
+/* PATA resources ---------------------------------------------------------- */
+
+/*
+ * EMI A21 = CS1 (active low)
+ * EMI A20 = CS0 (active low)
+ * EMI A19 = DA2
+ * EMI A18 = DA1
+ * EMI A17 = DA0
+ */
+
+static struct resource pata_resources[] = {
+	[0] = {	/* I/O base: CS1=N, CS0=A */
+		.start	= (1<<21),
+		.end	= (1<<21) + (8<<17)-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {	/* CTL base: CS1=A, CS0=N, DA2=A, DA1=A, DA0=N */
+		.start	= (1<<20) + (6<<17),
+		.end	= (1<<20) + (6<<17) + 3,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {	/* IRQ */
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct pata_platform_info pata_info = {
+	.ioport_shift	= 17,
+};
+
+static struct platform_device pata_device = {
+	.name		= "pata_platform",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pata_resources),
+	.resource	= pata_resources,
+	.dev = {
+		.platform_data = &pata_info,
+	}
+};
+
+void __init stx7100_configure_pata(int bank, int irq)
+{
+	unsigned long bank_base;
+
+	emi_init(0, 0x1a100000);
+	bank_base = emi_bank_base(bank);
+	pata_resources[0].start += bank_base;
+	pata_resources[0].end   += bank_base;
+	pata_resources[1].start += bank_base;
+	pata_resources[1].end   += bank_base;
+	pata_resources[2].start = irq;
+	pata_resources[2].end   = irq;
+
+	emi_config_pata(bank);
+
+	platform_device_register(&pata_device);
+}
+
+/* Ethernet MAC resources -------------------------------------------------- */
+
+static struct sysconf_field *mac_speed_sc;
+
+static void fix_mac_speed(void* priv, unsigned int speed)
+{
+	sysconf_write(mac_speed_sc, (speed == SPEED_100) ? 0 : 1);
+}
+
+/* Hopefully I can remove this now */
+static void stb7109eth_hw_setup_null(void)
+{
+}
+
+static struct plat_stmmacenet_data eth7109_private_data = {
+	.bus_id = 0,
+	.pbl = 1,
+	.fix_mac_speed = fix_mac_speed,
+	.hw_setup = stb7109eth_hw_setup_null,
+};
+
+static struct platform_device stb7109eth_device = {
+        .name           = "stmmaceth",
+        .id             = 0,
+        .num_resources  = 2,
+        .resource       = (struct resource[]) {
+        	{
+	                .start = 0x18110000,
+        	        .end   = 0x1811ffff,
+                	.flags  = IORESOURCE_MEM,
+        	},
+        	{
+			.name   = "macirq",
+                	.start  = 133,
+                	.end    = 133,
+                	.flags  = IORESOURCE_IRQ,
+        	},
+	},
+	.dev = {
+		.platform_data = &eth7109_private_data,
+	}
+};
+
+void stx7100_configure_ethernet(int rmii_mode, int ext_clk, int phy_bus)
+{
+	struct sysconf_field *sc;
+
+	if (!chip_7109)
+		return;
+
+	eth7109_private_data.bus_id = phy_bus;
+
+	/* DVO_ETH_PAD_DISABLE and ETH_IF_ON */
+	sc = sysconf_claim(SYS_CFG, 7, 16, 17, "stmmac");
+	sysconf_write(sc, 3);
+
+	/* RMII_MODE */
+	sc = sysconf_claim(SYS_CFG, 7, 18, 18, "stmmac");
+	sysconf_write(sc, rmii_mode ? 1 : 0);
+
+	/* PHY_CLK_EXT */
+	sc = sysconf_claim(SYS_CFG, 7, 19, 19, "stmmac");
+	sysconf_write(sc, ext_clk ? 1 : 0);
+
+	/* MAC_SPEED_SEL */
+	mac_speed_sc = sysconf_claim(SYS_CFG, 7, 20, 20, "stmmac");
+
+	/* Remove the PHY clk */
+	stpio_request_pin(3, 7, "stmmac EXTCLK", STPIO_ALT_OUT);
+
+	/* Configure the ethernet MAC PBL depending on the cut of the chip */
+	if (chip_revision == 1){
+		eth7109_private_data.pbl = 1;
+	} else {
+		eth7109_private_data.pbl = 32;
+	}
+
+	platform_device_register(&stb7109eth_device);
+}
+
+/* PWM resources ----------------------------------------------------------- */
+
+static struct resource stm_pwm_resource[]= {
+	[0] = {
+		.start	= 0x18010000,
+		.end	= 0x18010000 + 0x67,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start	= 126,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device stm_pwm_device = {
+	.name		= "stm-pwm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
+	.resource	= stm_pwm_resource,
+};
+
+void stx7100_configure_pwm(struct plat_stm_pwm_data *data)
+{
+	stm_pwm_device.dev.platform_data = data;
+
+	if (data->flags & PLAT_STM_PWM_OUT0) {
+		if (sys_cfg7_0 == NULL)
+			sys_cfg7_0 = sysconf_claim(SYS_CFG, 7, 0, 0, "pwm");
+		sysconf_write(sys_cfg7_0, 0);
+		stpio_request_pin(4, 6, "PWM", STPIO_ALT_OUT);
+	}
+
+	if (data->flags & PLAT_STM_PWM_OUT1) {
+		stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
+	}
+
+	platform_device_register(&stm_pwm_device);
+}
+
+/* LiRC resources ---------------------------------------------------------- */
+static struct lirc_pio lirc_pios[] = {
+	[0] = {
+		.bank = 3,
+		.pin  = 3,
+		.dir  = STPIO_IN
+	},
+	[1] = {
+		.bank = 3,
+		.pin  = 4,
+		.dir  = STPIO_IN
+	},
+	[2] = {
+		.bank = 3,
+		.pin  = 5,
+		.dir  = STPIO_ALT_OUT
+	},
+	[3] = {
+		.bank = 3,
+		.pin  = 6,
+		.dir  = STPIO_ALT_OUT
+	}
+};
+
+static struct plat_lirc_data lirc_private_info = {
+	/* For the 7100, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv      = 0, /* automatically calculate */
+	.irbperiodmult  = 0,
+	.irbperioddiv   = 0,
+	.irbontimemult  = 0,
+	.irbontimediv   = 0,
+	.irbrxmaxperiod = 0x5000,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1,
+	.pio_pin_arr  = lirc_pios,
+	.num_pio_pins = ARRAY_SIZE(lirc_pios)
+};
+
+static struct resource lirc_resource[]= {
+        [0] = {
+		.start = 0x18018000,
+		.end   = 0x18018000 + 0xa0,
+	        .flags = IORESOURCE_MEM
+	},
+	[1] = {
+	        .start = 125,
+		.end   = 125,
+	        .flags = IORESOURCE_IRQ
+	},
+};
+
+static struct platform_device lirc_device = {
+	.name           = "lirc",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(lirc_resource),
+	.resource       = lirc_resource,
+	.dev = {
+	           .platform_data = &lirc_private_info
+	}
+};
+
+void __init stx7100_configure_lirc(void)
+{
+        platform_device_register(&lirc_device);
+}
+
+/* ASC resources ----------------------------------------------------------- */
+
+static struct platform_device stm_stasc_devices[] = {
+	STASC_DEVICE(0x18030000, 123, 0, 0, 1, 4, 7), /* oe pin: 6 */
+	STASC_DEVICE(0x18031000, 122, 1, 0, 1, 4, 5), /* oe pin: 6 */
+	STASC_DEVICE(0x18032000, 121, 4, 3, 2, 4, 5),
+	STASC_DEVICE(0x18033000, 120, 5, 0, 1, 2, 3),
+};
+
+/* the serial console device */
+struct platform_device *asc_default_console_device;
+
+/* Platform devices to register */
+static struct platform_device *stasc_configured_devices[ARRAY_SIZE(stm_stasc_devices)] __initdata;
+static int stasc_configured_devices_count __initdata = 0;
+
+/* Configure the ASC's for this board.
+ * This has to be called before console_init().
+ */
+void __init stb7100_configure_asc(const int *ascs, int num_ascs, int console)
+{
+	int i;
+	struct platform_device *pdev;
+
+	for (i=0; i<num_ascs; i++) {
+		pdev = &stm_stasc_devices[ascs[i]];
+
+		switch (ascs[i]) {
+		case 2:
+			if (sys_cfg7_0 == NULL)
+				sys_cfg7_0 = sysconf_claim(SYS_CFG, 7, 0, 0, "asc");
+			sysconf_write(sys_cfg7_0, 0);
+			break;
+		}
+
+		pdev->id = i;
+		stasc_configured_devices[stasc_configured_devices_count++] = pdev;
+	}
+
+	asc_default_console_device = stasc_configured_devices[console];
+}
+
+/* Add platform device as configured by board specific code */
+static int __init stb7100_add_asc(void)
+{
+	return platform_add_devices(stasc_configured_devices,
+				    stasc_configured_devices_count);
+}
+arch_initcall(stb7100_add_asc);
+
+/* Early resources (sysconf and PIO) --------------------------------------- */
+
+static struct platform_device sysconf_device = {
+	.name		= "sysconf",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0x19001000,
+			.end	= 0x19001000 + 0x100,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+	.dev = {
+		.platform_data = &(struct plat_sysconf_data) {
+			.sys_device_offset = 0,
+			.sys_sta_offset = 8,
+			.sys_cfg_offset = 0x100,
+		}
+	}
+};
+
+static struct platform_device stpio_devices[] = {
+	STPIO_DEVICE(0, 0x18020000, 80),
+	STPIO_DEVICE(1, 0x18021000, 84),
+	STPIO_DEVICE(2, 0x18022000, 88),
+	STPIO_DEVICE(3, 0x18023000, 115),
+	STPIO_DEVICE(4, 0x18024000, 114),
+	STPIO_DEVICE(5, 0x18025000, 113),
+};
+
+/* Initialise devices which are required early in the boot process. */
+void __init stx7100_early_device_init(void)
+{
+	struct sysconf_field *sc;
+	unsigned long devid;
+
+	/* Create a PMB mapping so that the ioremap calls these drivers
+	 * will make can be satisfied without having to call get_vm_area
+	 * or cause a fault. Its probably also a good for efficiency as
+	 * there will be lots of devices in this range.
+	 */
+	ioremap_nocache(0x18000000, 0x04000000);
+
+	/* Initialise PIO and sysconf drivers */
+
+	sysconf_early_init(&sysconf_device);
+	stpio_early_init(stpio_devices, ARRAY_SIZE(stpio_devices));
+
+	sc = sysconf_claim(SYS_DEV, 0, 0, 31, "devid");
+	devid = sysconf_read(sc);
+	chip_7109 = (((devid >> 12) & 0x3ff) == 0x02c);
+	chip_revision = (devid >> 28) + 1;
+
+	printk("%s version %ld.x\n",
+	       chip_7109 ? "STx7109" : "STx7100", chip_revision);
+
+	sc = sysconf_claim(SYS_STA, 9, 0, 7, "devid");
+	devid = sysconf_read(sc);
+	printk("Chip version %ld.%ld\n", (devid >> 4)+1, devid & 0xf);
+
+	/* Configure the ST40 RTC to source its clock from clockgenB.
+	 * In theory this should be board specific, but so far nobody
+	 * has ever done this. */
+	sc = sysconf_claim(SYS_CFG, 8, 1, 1, "rtc");
+	sysconf_write(sc, 1);
+
+	/* We haven't configured the LPC, so the sleep instruction may
+	 * do bad things. Thus we disable it here. */
+	disable_hlt();
+}
+
+static void __init pio_late_setup(void)
+{
+	int i;
+	struct platform_device *pdev = stpio_devices;
+
+	for (i=0; i<ARRAY_SIZE(stpio_devices); i++,pdev++) {
+		platform_device_register(pdev);
+	}
+}
+
+static struct platform_device ilc3_device = {
+	.name		= "ilc3",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0x18000000,
+			.end	= 0x18000000 + 0x900,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+};
+
+/* Late resources ---------------------------------------------------------- */
+
+static struct platform_device *stx710x_devices[] __initdata = {
+	&sci_device,
+	&wdt_device,
+	&rtc_device,
+	&fdma_710x_device,
+	&sysconf_device,
+	&ilc3_device,
+};
+
+static int __init stx710x_devices_setup(void)
+{
+	fdma_setup(chip_7109, chip_revision);
+	pio_late_setup();
+
+	return platform_add_devices(stx710x_devices,
+				    ARRAY_SIZE(stx710x_devices));
+}
+device_initcall(stx710x_devices_setup);
+
+/* Interrupt initialisation ------------------------------------------------ */
+
+enum {
+	UNUSED = 0,
+
+	/* interrupt sources */
+	IRL0, IRL1, IRL2, IRL3, /* only IRLM mode described here */
+	TMU0, TMU1, TMU2_TUNI, TMU2_TICPI,
+	RTC_ATI, RTC_PRI, RTC_CUI,
+	SCIF_ERI, SCIF_RXI, SCIF_BRI, SCIF_TXI,
+	WDT,
+	HUDI,
+
+	SATA_DMAC, SATA_HOSTC,
+	PIO0, PIO1, PIO2,
+	PIO5, PIO4, PIO3, MTP,			/* Group 0 */
+	SSC2, SSC1, SSC0,			/* Group 1 */
+	UART3, UART2, UART1, UART0,		/* Group 2 */
+	IRB_WAKEUP, IRB, PWM, MAFE,		/* Group 3 */
+	DISEQC, DAA, TTXT,			/* Group 4 */
+	EMPI, ETH_MAC, TS_MERGER,		/* Group 5 */
+	ST231_DELTA, ST231_AUD, DCXO, PTI1,	/* Group 6 */
+	FDMA_MBOX, FDMA_GP0, I2S2SPDIF, CPXM,	/* Group 7 */
+	PCMPLYR0, PCMPLYR1, PCMRDR, SPDIFPLYR,	/* Group 8 */
+	MPEG2, DELTA_PRE0, DELTA_PRE1, DELTA_MBE,	/* Group 9 */
+	VDP_FIFO_EMPTY, VDP_END_PROC, VTG1, VTG2,	/* Group 10 */
+	BDISP_AQ1, DVP, HDMI, HDCP,			/* Group 11 */
+	PTI, PDES_ESA0, PDES, PRES_READ_CW,		/* Group 12 */
+	SIG_CHK, TKDMA, CRIPTO_SIG_DMA, CRIPTO_SIG_CHK,	/* Group 13 */
+	OHCI, EHCI, SATA, BDISP_CQ1,			/* Group 14 */
+	ICAM3_KTE, ICAM3, MES_LMI_VID, MES_LMI_SYS,	/* Group 15 */
+
+	/* interrupt groups */
+	TMU2, RTC, SCIF,
+	SATA_SPLIT,
+	GROUP0, GROUP1, GROUP2, GROUP3,
+	GROUP4, GROUP5, GROUP6, GROUP7,
+	GROUP8, GROUP9, GROUP10, GROUP11,
+	GROUP12, GROUP13, GROUP14, GROUP15,
+};
+
+static struct intc_vect vectors[] = {
+	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
+	INTC_VECT(TMU2_TUNI, 0x440), INTC_VECT(TMU2_TICPI, 0x460),
+	INTC_VECT(RTC_ATI, 0x480), INTC_VECT(RTC_PRI, 0x4a0),
+	INTC_VECT(RTC_CUI, 0x4c0),
+	INTC_VECT(SCIF_ERI, 0x4e0), INTC_VECT(SCIF_RXI, 0x500),
+	INTC_VECT(SCIF_BRI, 0x520), INTC_VECT(SCIF_TXI, 0x540),
+	INTC_VECT(WDT, 0x560),
+	INTC_VECT(HUDI, 0x600),
+
+	INTC_VECT(SATA_DMAC, 0xa20), INTC_VECT(SATA_HOSTC, 0xa40),
+	INTC_VECT(PIO0, 0xc00), INTC_VECT(PIO1, 0xc80), INTC_VECT(PIO2, 0xd00),
+	INTC_VECT(MTP, 0x1000),INTC_VECT(PIO5, 0x1020),
+	INTC_VECT(PIO4, 0x1040), INTC_VECT(PIO3, 0x1060),
+	INTC_VECT(SSC2, 0x10a0),
+	INTC_VECT(SSC1, 0x10c0), INTC_VECT(SSC0, 0x10e0),
+	INTC_VECT(UART3, 0x1100), INTC_VECT(UART2, 0x1120),
+	INTC_VECT(UART1, 0x1140), INTC_VECT(UART0, 0x1160),
+	INTC_VECT(IRB_WAKEUP, 0x1180), INTC_VECT(IRB, 0x11a0),
+	INTC_VECT(PWM, 0x11c0), INTC_VECT(MAFE, 0x11e0),
+	INTC_VECT(DISEQC, 0x1220),
+	INTC_VECT(DAA, 0x1240), INTC_VECT(TTXT, 0x1260),
+	INTC_VECT(EMPI, 0x1280), INTC_VECT(ETH_MAC, 0x12a0),
+	INTC_VECT(TS_MERGER, 0x12c0),
+	INTC_VECT(ST231_DELTA, 0x1300), INTC_VECT(ST231_AUD, 0x1320),
+	INTC_VECT(DCXO, 0x1340), INTC_VECT(PTI1, 0x1360),
+	INTC_VECT(FDMA_MBOX, 0x1380), INTC_VECT(FDMA_GP0, 0x13a0),
+	INTC_VECT(I2S2SPDIF, 0x13c0), INTC_VECT(CPXM, 0x13e0),
+	INTC_VECT(PCMPLYR0, 0x1400), INTC_VECT(PCMPLYR1, 0x1420),
+	INTC_VECT(PCMRDR, 0x1440), INTC_VECT(SPDIFPLYR, 0x1460),
+	INTC_VECT(MPEG2, 0x1480), INTC_VECT(DELTA_PRE0, 0x14a0),
+	INTC_VECT(DELTA_PRE1, 0x14c0), INTC_VECT(DELTA_MBE, 0x14e0),
+	INTC_VECT(VDP_FIFO_EMPTY, 0x1500), INTC_VECT(VDP_END_PROC, 0x1520),
+	INTC_VECT(VTG1, 0x1540), INTC_VECT(VTG2, 0x1560),
+	INTC_VECT(BDISP_AQ1, 0x1580), INTC_VECT(DVP, 0x15a0),
+	INTC_VECT(HDMI, 0x15c0), INTC_VECT(HDCP, 0x15e0),
+	INTC_VECT(PTI, 0x1600), INTC_VECT(PDES_ESA0, 0x1620),
+	INTC_VECT(PDES, 0x1640), INTC_VECT(PRES_READ_CW, 0x1660),
+	INTC_VECT(SIG_CHK, 0x1680), INTC_VECT(TKDMA, 0x16a0),
+	INTC_VECT(CRIPTO_SIG_DMA, 0x16c0), INTC_VECT(CRIPTO_SIG_CHK, 0x16e0),
+	INTC_VECT(OHCI, 0x1700), INTC_VECT(EHCI, 0x1720),
+	INTC_VECT(SATA, 0x1740), INTC_VECT(BDISP_CQ1, 0x1760),
+	INTC_VECT(ICAM3_KTE, 0x1780), INTC_VECT(ICAM3, 0x17a0),
+	INTC_VECT(MES_LMI_VID, 0x17c0), INTC_VECT(MES_LMI_SYS, 0x17e0)
+};
+
+static struct intc_group groups[] = {
+	INTC_GROUP(TMU2, TMU2_TUNI, TMU2_TICPI),
+	INTC_GROUP(RTC, RTC_ATI, RTC_PRI, RTC_CUI),
+	INTC_GROUP(SCIF, SCIF_ERI, SCIF_RXI, SCIF_BRI, SCIF_TXI),
+
+	INTC_GROUP(SATA_SPLIT, SATA_DMAC, SATA_HOSTC),
+	INTC_GROUP(GROUP0, PIO5, PIO4, PIO3, MTP),
+	INTC_GROUP(GROUP1, SSC2, SSC1, SSC0),
+	INTC_GROUP(GROUP2, UART3, UART2, UART1, UART0),
+	INTC_GROUP(GROUP3, IRB_WAKEUP, IRB, PWM, MAFE),
+	INTC_GROUP(GROUP4, DISEQC, DAA, TTXT),
+	INTC_GROUP(GROUP5, EMPI, ETH_MAC, TS_MERGER),
+	INTC_GROUP(GROUP6, ST231_DELTA, ST231_AUD, DCXO, PTI1),
+	INTC_GROUP(GROUP7, FDMA_MBOX, FDMA_GP0, I2S2SPDIF, CPXM),
+	INTC_GROUP(GROUP8, PCMPLYR0, PCMPLYR1, PCMRDR, SPDIFPLYR),
+	INTC_GROUP(GROUP9, MPEG2, DELTA_PRE0, DELTA_PRE1, DELTA_MBE),
+	INTC_GROUP(GROUP10, VDP_FIFO_EMPTY, VDP_END_PROC, VTG1, VTG2),
+	INTC_GROUP(GROUP11, BDISP_AQ1, DVP, HDMI, HDCP),
+	INTC_GROUP(GROUP12, PTI, PDES_ESA0, PDES, PRES_READ_CW),
+	INTC_GROUP(GROUP13, SIG_CHK, TKDMA, CRIPTO_SIG_DMA, CRIPTO_SIG_CHK),
+	INTC_GROUP(GROUP14, OHCI, EHCI, SATA, BDISP_CQ1),
+	INTC_GROUP(GROUP15, ICAM3_KTE, ICAM3, MES_LMI_VID, MES_LMI_SYS),
+};
+
+static struct intc_prio priorities[] = {
+	INTC_PRIO(SCIF, 3),
+};
+
+static struct intc_prio_reg prio_registers[] = {
+					   /*   15-12, 11-8,  7-4,   3-0 */
+	{ 0xffd00004, 0, 16, 4, /* IPRA */     { TMU0, TMU1, TMU2,   RTC } },
+	{ 0xffd00008, 0, 16, 4, /* IPRB */     {  WDT,    0, SCIF,     0 } },
+	{ 0xffd0000c, 0, 16, 4, /* IPRC */     {    0,    0,    0,  HUDI } },
+	{ 0xffd00010, 0, 16, 4, /* IPRD */     { IRL0, IRL1,  IRL2, IRL3 } },
+						/* 31-28,   27-24,   23-20,   19-16 */
+						/* 15-12,    11-8,     7-4,     3-0 */
+	{ 0x00000300, 0, 32, 4, /* INTPRI00 */ {       0,       0,    PIO2,    PIO1,
+						    PIO0,       0, SATA_SPLIT,    0 } },
+	{ 0x00000304, 0, 32, 4, /* INTPRI04 */ {  GROUP7,  GROUP6,  GROUP5,  GROUP4,
+						  GROUP3,  GROUP2,  GROUP1,  GROUP0 } },
+	{ 0x00000308, 0, 32, 4, /* INTPRI08 */ { GROUP15, GROUP14, GROUP13, GROUP12,
+						 GROUP11, GROUP10,  GROUP9,  GROUP8 } },
+};
+
+static struct intc_mask_reg mask_registers[] = {
+	{ 0x00000340, 0x00000360, 32, /* INTMSK00 / INTMSKCLR00 */
+	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 31..16 */
+	    0, PIO2, PIO1, PIO0,				/* 15..12 */
+	    0, 0, 0, 0,						/* 11...8 */
+	    0, 0, 0, 0,						/*  7...4 */
+	    0, SATA_HOSTC, SATA_DMAC, 0 } },			/*  3...0 */
+	{ 0x00000344, 0x00000364, 32, /* INTMSK04 / INTMSKCLR04 */
+	  { CPXM, I2S2SPDIF, FDMA_GP0, FDMA_MBOX,		/* 31..28 */
+	    PTI1, DCXO, ST231_AUD, ST231_DELTA,			/* 27..24 */
+	    0, TS_MERGER, ETH_MAC, EMPI,			/* 23..20 */
+	    TTXT, DAA, DISEQC, 0,				/* 19..16 */
+	    MAFE, PWM, IRB, IRB_WAKEUP, 			/* 15..12 */
+	    UART0, UART1, UART2, UART3,				/* 11...8 */
+	    SSC0, SSC1, SSC2, 0,				/*  7...4 */
+	    PIO3, PIO4, PIO5, MTP } },				/*  3...0 */
+	{ 0x00000348, 0x00000368, 32, /* INTMSK08 / INTMSKCLR08 */
+	  { MES_LMI_SYS, MES_LMI_VID, ICAM3, ICAM3_KTE, 	/* 31..28 */
+	    BDISP_CQ1, SATA, EHCI, OHCI,			/* 27..24 */
+	    CRIPTO_SIG_CHK, CRIPTO_SIG_DMA, TKDMA, SIG_CHK,	/* 23..20 */
+	    PRES_READ_CW, PDES, PDES_ESA0, PTI,			/* 19..16 */
+	    HDCP, HDMI, DVP, BDISP_AQ1,				/* 15..12 */
+	    VTG2, VTG1, VDP_END_PROC, VDP_FIFO_EMPTY,		/* 11...8 */
+	    DELTA_MBE, DELTA_PRE1, DELTA_PRE0, MPEG2,		/*  7...4 */
+	    SPDIFPLYR, PCMRDR, PCMPLYR1, PCMPLYR0 } }		/*  3...0 */
+};
+
+static DECLARE_INTC_DESC(intc_desc, "stx7100", vectors, groups,
+			 priorities, mask_registers, prio_registers, NULL);
+
+static struct intc_vect vectors_irlm[] = {
+	INTC_VECT(IRL0, 0x240), INTC_VECT(IRL1, 0x2a0),
+	INTC_VECT(IRL2, 0x300), INTC_VECT(IRL3, 0x360),
+};
+
+static DECLARE_INTC_DESC(intc_desc_irlm, "stx7100_irlm", vectors_irlm, NULL,
+			 priorities, NULL, prio_registers, NULL);
+
+void __init plat_irq_setup(void)
+{
+	struct sysconf_field *sc;
+	void __iomem *intc2_base = ioremap(0x19001000, 0x400);
+	int i;
+
+	ilc_early_init(&ilc3_device);
+
+	for (i=4; i<=6; i++)
+		prio_registers[i].set_reg += intc2_base;
+	for (i=0; i<=2; i++) {
+		mask_registers[i].set_reg += intc2_base;
+		mask_registers[i].clr_reg += intc2_base;
+	}
+
+	/* Configure the external interrupt pins as inputs */
+	sc = sysconf_claim(SYS_CFG, 10, 0, 3, "irq");
+	sysconf_write(sc, 0xf);
+
+	register_intc_controller(&intc_desc);
+}
+
+#define INTC_ICR	0xffd00000UL
+#define INTC_ICR_IRLM   (1<<7)
+
+void __init plat_irq_setup_pins(int mode)
+{
+	switch (mode) {
+	case IRQ_MODE_IRQ: /* individual interrupt mode for IRL3-0 */
+		register_intc_controller(&intc_desc_irlm);
+		ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+		break;
+	default:
+		BUG();
+	}
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-stx7200.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-stx7200.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/setup-stx7200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/setup-stx7200.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,833 @@
+/*
+ * STx7200 Setup
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/io.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/soc_init.h>
+#include <linux/stm/pio.h>
+#include <linux/phy.h>
+#include <linux/stm/sysconf.h>
+#include <asm/sci.h>
+#include <asm/irq-ilc.h>
+#include <linux/stm/fdma-plat.h>
+#include <linux/stm/fdma-reqs.h>
+
+static unsigned long chip_revision;
+static struct sysconf_field *sc7_2;
+
+/* USB resources ----------------------------------------------------------- */
+
+#define UHOST2C_BASE(N)                 (0xfd200000 + ((N)*0x00100000))
+
+#define AHB2STBUS_WRAPPER_GLUE_BASE(N)  (UHOST2C_BASE(N))
+#define AHB2STBUS_RESERVED1_BASE(N)     (UHOST2C_BASE(N) + 0x000e0000)
+#define AHB2STBUS_RESERVED2_BASE(N)     (UHOST2C_BASE(N) + 0x000f0000)
+#define AHB2STBUS_OHCI_BASE(N)          (UHOST2C_BASE(N) + 0x000ffc00)
+#define AHB2STBUS_EHCI_BASE(N)          (UHOST2C_BASE(N) + 0x000ffe00)
+#define AHB2STBUS_PROTOCOL_BASE(N)      (UHOST2C_BASE(N) + 0x000fff00)
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct sysconf_field *usb_power_sc[3];
+
+static void usb_power_up(void* dev)
+{
+	struct platform_device *pdev = dev;
+	struct plat_usb_data *usb_wrapper = pdev->dev.platform_data;
+	int port = usb_wrapper->port_number;
+
+	sysconf_write(usb_power_sc[port], 0);
+}
+
+static struct plat_usb_data usb_wrapper[3] = {
+	USB_WRAPPER(0, AHB2STBUS_WRAPPER_GLUE_BASE(0), AHB2STBUS_PROTOCOL_BASE(0)),
+	USB_WRAPPER(1, AHB2STBUS_WRAPPER_GLUE_BASE(1), AHB2STBUS_PROTOCOL_BASE(1)),
+	USB_WRAPPER(2, AHB2STBUS_WRAPPER_GLUE_BASE(2), AHB2STBUS_PROTOCOL_BASE(2))
+};
+
+static struct platform_device st40_ehci_devices[3] = {
+	USB_EHCI_DEVICE(0, AHB2STBUS_EHCI_BASE(0), ILC_IRQ(80)),
+	USB_EHCI_DEVICE(1, AHB2STBUS_EHCI_BASE(1), ILC_IRQ(82)),
+	USB_EHCI_DEVICE(2, AHB2STBUS_EHCI_BASE(2), ILC_IRQ(84)),
+};
+
+static struct platform_device st40_ohci_devices[3] = {
+	USB_OHCI_DEVICE(0, AHB2STBUS_OHCI_BASE(0), ILC_IRQ(81)),
+	USB_OHCI_DEVICE(1, AHB2STBUS_OHCI_BASE(1), ILC_IRQ(83)),
+	USB_OHCI_DEVICE(2, AHB2STBUS_OHCI_BASE(2), ILC_IRQ(85)),
+};
+
+void __init stx7200_configure_usb(void)
+{
+	const unsigned char power_pins[3] = {1, 3, 4};
+	const unsigned char oc_pins[3] = {0, 2, 5};
+	static struct stpio_pin *pio;
+	struct sysconf_field *sc;
+	int port;
+
+	/* route USB and parts of MAFE instead of DVO.
+	 * conf_pad_pio[2] = 0 */
+	sc = sysconf_claim(SYS_CFG, 7, 26, 26, "usb");
+	sysconf_write(sc, 0);
+
+	/* DVO output selection (probably ignored).
+	 * conf_pad_pio[3] = 0 */
+	sc = sysconf_claim(SYS_CFG, 7, 27, 27, "usb");
+	sysconf_write(sc, 0);
+
+	/* Enable soft JTAG mode for USB and SATA
+	 * Taken from OS21, but is this correct?
+	 * soft_jtag_en = 1 */
+	sc = sysconf_claim(SYS_CFG, 33, 6, 6, "usb");
+	sysconf_write(sc, 1);
+	/* tck = tdi = trstn_usb = tms_usb = 0 */
+	sc = sysconf_claim(SYS_CFG, 33, 0, 3, "usb");
+	sysconf_write(sc, 0);
+
+	for (port=0; port<3; port++) {
+		usb_power_sc[port] = sysconf_claim(SYS_CFG, 22, 3+port,
+						   3+port, "usb");
+
+		pio = stpio_request_pin(7, power_pins[port], "USB power",
+					STPIO_ALT_OUT);
+		stpio_set_pin(pio, 1);
+		pio = stpio_request_pin(7, oc_pins[port], "USB oc",
+					STPIO_ALT_BIDIR);
+
+		platform_device_register(&st40_ohci_devices[port]);
+		platform_device_register(&st40_ehci_devices[port]);
+	}
+}
+
+/* FDMA resources ---------------------------------------------------------- */
+
+#ifdef CONFIG_STM_DMA
+
+#include <linux/stm/7200_cut1_fdma2_firmware.h>
+
+static struct fdma_regs stb7200_fdma_regs = {
+	.fdma_id= FDMA2_ID,
+	.fdma_ver = FDAM2_VER,
+	.fdma_en = FDMA2_ENABLE_REG,
+	.fdma_clk_gate = FDMA2_CLOCKGATE,
+	.fdma_rev_id = FDMA2_REV_ID,
+	.fdma_cmd_statn = STB7200_FDMA_CMD_STATn_REG,
+	.fdma_ptrn = STB7200_FDMA_PTR_REG,
+	.fdma_cntn = STB7200_FDMA_COUNT_REG,
+	.fdma_saddrn = STB7200_FDMA_SADDR_REG,
+	.fdma_daddrn = STB7200_FDMA_DADDR_REG,
+	.fdma_req_ctln = STB7200_FDMA_REQ_CTLn_REG,
+	.fdma_cmd_sta = FDMA2_CMD_MBOX_STAT_REG,
+	.fdma_cmd_set = FDMA2_CMD_MBOX_SET_REG,
+	.fdma_cmd_clr = FDMA2_CMD_MBOX_CLR_REG,
+	.fdma_cmd_mask = FDMA2_CMD_MBOX_MASK_REG,
+	.fdma_int_sta = FDMA2_INT_STAT_REG,
+	.fdma_int_set = FDMA2_INT_SET_REG,
+	.fdma_int_clr= FDMA2_INT_CLR_REG,
+	.fdma_int_mask= FDMA2_INT_MASK_REG,
+	.fdma_sync_reg= FDMA2_SYNCREG,
+	.fdma_dmem_region = STB7200_DMEM_OFFSET,
+	.fdma_imem_region = STB7200_IMEM_OFFSET,
+};
+
+static struct fdma_platform_device_data stb7200_fdma0_plat_data = {
+	.registers_ptr = &stb7200_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7200_v1.4.bin",
+	.fw.data_reg = (unsigned long*)&STB7200_DMEM_REGION,
+	.fw.imem_reg = (unsigned long*)&STB7200_IMEM_REGION,
+	.fw.imem_fw_sz = STB7200_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7200_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7200_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7200_IMEM_REGION_LENGTH
+};
+
+
+static struct fdma_platform_device_data stb7200_fdma1_plat_data = {
+	.registers_ptr = &stb7200_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7200_v1.4.bin",
+	.fw.data_reg = (unsigned long*)&STB7200_DMEM_REGION,
+	.fw.imem_reg = (unsigned long*)&STB7200_IMEM_REGION,
+	.fw.imem_fw_sz = STB7200_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7200_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7200_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7200_IMEM_REGION_LENGTH
+};
+
+#define stb7200_fdma0_plat_data_addr &stb7200_fdma0_plat_data
+#define stb7200_fdma1_plat_data_addr &stb7200_fdma1_plat_data
+#else
+#define stb7200_fdma0_plat_data_addr NULL
+#define stb7200_fdma1_plat_data_addr NULL
+#endif /* CONFIG_STM_DMA */
+
+static struct platform_device fdma0_7200_device = {
+	.name		= "stmfdma",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource = (struct resource[2]) {
+		[0] = {
+			.start = STB7200_FDMA0_BASE,
+			.end   = STB7200_FDMA0_BASE + 0x10000,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = LINUX_FDMA0_STB7200_IRQ_VECT,
+			.end   = LINUX_FDMA0_STB7200_IRQ_VECT,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = stb7200_fdma0_plat_data_addr,
+	},
+};
+
+static struct platform_device fdma1_7200_device = {
+	.name		= "stmfdma",
+	.id		= 1,
+	.resource = (struct resource[2]) {
+		[0] = {
+			.start = STB7200_FDMA1_BASE,
+			.end   = STB7200_FDMA1_BASE + 0x10000,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = LINUX_FDMA1_STB7200_IRQ_VECT,
+			.end   = LINUX_FDMA1_STB7200_IRQ_VECT,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = stb7200_fdma1_plat_data_addr,
+	},
+};
+
+static struct platform_device fdma_xbar_device = {
+	.name		= "fdma-xbar",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[1]) {
+		{
+			.start	= STB7200_XBAR_BASE,
+			.end	= STB7200_XBAR_BASE+(4*1024),
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+/* SSC resources ----------------------------------------------------------- */
+
+static struct resource ssc_resource[] = {
+	[0] = {
+		.start	= 0xfd040000,
+		.end	= 0xfd040000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0xfd041000,
+		.end	= 0xfd041000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= 0xfd042000,
+		.end	= 0xfd042000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start	= 0xfd043000,
+		.end	= 0xfd043000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+	[4] = {
+		.start	= 0xfd044000,
+		.end	= 0xfd044000 + 0x108,
+		.flags	= IORESOURCE_MEM,
+	},
+	[5] = {
+		.start	= ILC_IRQ(108),
+		.end	= ILC_IRQ(108),
+		.flags	= IORESOURCE_IRQ,
+	},
+	[6] = {
+		.start	= ILC_IRQ(109),
+		.end	= ILC_IRQ(109),
+		.flags	= IORESOURCE_IRQ,
+	},
+	[7] = {
+		.start	= ILC_IRQ(110),
+		.end	= ILC_IRQ(110),
+		.flags	= IORESOURCE_IRQ,
+	},
+	[8] = {
+		.start	= ILC_IRQ(111),
+		.end	= ILC_IRQ(111),
+		.flags	= IORESOURCE_IRQ,
+	},
+	[9] = {
+		.start	= ILC_IRQ(112),
+		.end	= ILC_IRQ(112),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+	{2, 0, 2, 1, 2, 2},
+	{3, 0, 3, 1, 3, 2},
+	{4, 0, 4, 1, 0xff, 0xff},
+	{5, 0, 5, 1, 5, 2},
+	{7, 6, 7, 7, 0xff, 0xff},
+};
+
+struct platform_device ssc_device = {
+	.name = "ssc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ssc_resource),
+	.resource = ssc_resource,
+};
+
+void __init stx7200_configure_ssc(struct plat_ssc_data *data)
+{
+	int i;
+	int capability;
+	struct sysconf_field* ssc_sc;
+
+	data->pio = ssc_pio;
+	ssc_device.dev.platform_data = data;
+
+	for (i=0, capability = data->capability;
+	     i<5;
+	     i++, capability >>= 2) {
+		if (! (capability & ((SSC_SPI_CAPABILITY|SSC_I2C_CAPABILITY) << (i*2))))
+			continue;
+
+		/* We only support SSC as master, so always set up as such.
+		 * ssc<x>_mux_sel = 0 */
+		ssc_sc = sysconf_claim(SYS_CFG, 7, i, i, "ssc");
+		sysconf_write(ssc_sc,
+			      capability & SSC_I2C_CAPABILITY ? 0 : 1);
+	}
+
+	platform_device_register(&ssc_device);
+}
+
+/* Ethernet MAC resources -------------------------------------------------- */
+
+static struct sysconf_field *mac_speed_sc[2];
+
+static void fix_mac_speed(void *priv, unsigned int speed)
+{
+	unsigned port = (unsigned)priv;
+
+	sysconf_write(mac_speed_sc[port], (speed == SPEED_100) ? 0 : 1);
+}
+
+static struct plat_stmmacenet_data stmmaceth_private_data[2] = {
+{
+	.pbl = 32,
+	.fix_mac_speed = fix_mac_speed,
+	.bsp_priv = (void*)0,
+}, {
+	.pbl = 32,
+	.fix_mac_speed = fix_mac_speed,
+	.bsp_priv = (void*)1,
+} };
+
+static struct platform_device stmmaceth_device[2] = {
+{
+	.name		= "stmmaceth",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd500000,
+			.end	= 0xfd50ffff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "macirq",
+			.start	= ILC_IRQ(92),
+			.end	= ILC_IRQ(92),
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &stmmaceth_private_data[0],
+	}
+}, {
+	.name		= "stmmaceth",
+	.id		= 1,
+	.num_resources	= 2,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd510000,
+			.end	= 0xfd51ffff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "macirq",
+			.start	= ILC_IRQ(94),
+			.end	= ILC_IRQ(94),
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &stmmaceth_private_data[1],
+	}
+} };
+
+void stx7200_configure_ethernet(int port, int rmii_mode, int ext_clk,
+				int phy_bus)
+{
+	struct sysconf_field *sc;
+
+	stmmaceth_private_data[port].bus_id = phy_bus;
+
+	/* Route Ethernet pins to output */
+	/* bit26-16: conf_pad_eth(10:0) */
+	if (port == 0) {
+		/* MII0: conf_pad_eth(0) = 0 (ethernet) */
+		sc = sysconf_claim(SYS_CFG, 41, 16, 16, "stmmac");
+		sysconf_write(sc, 0);
+	} else {
+		/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (eth)
+		 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output)
+		 * (remaining bits have no effect in ethernet mode */
+		sc = sysconf_claim(SYS_CFG, 41, 16+2, 16+10, "stmmac");
+		sysconf_write(sc, 0);
+	}
+
+	/* DISABLE_MSG_FOR_WRITE=0 */
+	sc = sysconf_claim(SYS_CFG, 41, 14+port, 14+port, "stmmac");
+	sysconf_write(sc, 0);
+
+	/* DISABLE_MSG_FOR_READ=0 */
+	sc = sysconf_claim(SYS_CFG, 41, 12+port, 12+port, "stmmac");
+	sysconf_write(sc, 0);
+
+	/* VCI_ACK_SOURCE = 0 */
+	sc = sysconf_claim(SYS_CFG, 41, 6+port, 6+port, "stmmac");
+	sysconf_write(sc, 0);
+
+	/* ETHERNET_INTERFACE_ON (aka RESET) = 1 */
+	sc = sysconf_claim(SYS_CFG, 41, 8+port, 8+port, "stmmac");
+	sysconf_write(sc, 1);
+
+	/* RMII_MODE */
+	sc = sysconf_claim(SYS_CFG, 41, 0+port, 0+port, "stmmac");
+	sysconf_write(sc, rmii_mode ? 1 : 0);
+
+	/* PHY_CLK_EXT */
+	sc = sysconf_claim(SYS_CFG, 41, 2+port, 2+port, "stmmac");
+	sysconf_write(sc, ext_clk ? 1 : 0);
+
+	/* MAC_SPEED_SEL */
+	mac_speed_sc[port] = sysconf_claim(SYS_CFG, 41, 4+port, 4+port, "stmmac");
+
+	platform_device_register(&stmmaceth_device[port]);
+}
+
+/* PWM resources ----------------------------------------------------------- */
+
+static struct resource stm_pwm_resource[]= {
+	[0] = {
+		.start	= 0xfd010000,
+		.end	= 0xfd010000 + 0x67,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start	= ILC_IRQ(114),
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device stm_pwm_device = {
+	.name		= "stm-pwm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
+	.resource	= stm_pwm_resource,
+};
+
+void stx7200_configure_pwm(struct plat_stm_pwm_data *data)
+{
+	stm_pwm_device.dev.platform_data = data;
+
+	if (data->flags & PLAT_STM_PWM_OUT0) {
+		/* Route UART2 (in and out) and PWM_OUT0 instead of SCI to pins
+		 * ssc2_mux_sel = 0 */
+		if (sc7_2 == NULL)
+			sc7_2 = sysconf_claim(SYS_CFG, 7, 2, 2, "pwm");
+		sysconf_write(sc7_2, 0);
+		stpio_request_pin(4, 6, "PWM", STPIO_ALT_OUT);
+	}
+
+	if (data->flags & PLAT_STM_PWM_OUT1) {
+		stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
+	}
+
+	platform_device_register(&stm_pwm_device);
+}
+
+/* LiRC resources ---------------------------------------------------------- */
+static struct lirc_pio lirc_pios[] = {
+	[0] = {
+		.bank = 3,
+		.pin  = 3,
+		.dir  = STPIO_IN
+	},
+	[1] = {
+		.bank = 3,
+		.pin  = 4,
+		.dir  = STPIO_IN
+	},
+	[2] = {
+		.bank = 3,
+		.pin  = 5,
+		.dir  = STPIO_ALT_OUT
+	},
+	[3] = {
+		.bank = 3,
+		.pin  = 6,
+		.dir  = STPIO_ALT_OUT
+	}
+};
+
+static struct plat_lirc_data lirc_private_info = {
+	/* For the 7200, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv      = 0, /* automatically calculate */
+	.irbperiodmult  = 0,
+	.irbperioddiv   = 0,
+	.irbontimemult  = 0,
+	.irbontimediv   = 0,
+	.irbrxmaxperiod = 0x5000,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1,
+	.pio_pin_arr  = lirc_pios,
+	.num_pio_pins = ARRAY_SIZE(lirc_pios)
+};
+
+static struct resource lirc_resource[]= {
+        [0] = {
+		.start = 0xfd018000,
+		.end   = 0xfd018000 + 0xa0,
+	        .flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = ILC_IRQ(116),
+		.end   = ILC_IRQ(116),
+	        .flags = IORESOURCE_IRQ
+	},
+};
+
+static struct platform_device lirc_device = {
+	.name           = "lirc",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(lirc_resource),
+	.resource       = lirc_resource,
+	.dev = {
+	           .platform_data = &lirc_private_info
+	}
+};
+
+void __init stx7200_configure_lirc(void)
+{
+	platform_device_register(&lirc_device);
+}
+
+/* ASC resources ----------------------------------------------------------- */
+
+static struct platform_device stm_stasc_devices[] = {
+	STASC_DEVICE(0xfd030000, ILC_IRQ(104), 0, 0, 1, 4, 7), /* oe pin: 6 */
+	STASC_DEVICE(0xfd031000, ILC_IRQ(105), 1, 0, 1, 4, 5), /* oe pin: 6 */
+	STASC_DEVICE(0xfd032000, ILC_IRQ(106), 4, 3, 2, 4, 5),
+	STASC_DEVICE(0xfd033000, ILC_IRQ(107), 5, 4, 3, 5, 6),
+};
+
+/* the serial console device */
+struct platform_device *asc_default_console_device;
+
+/* Platform devices to register */
+static struct platform_device *stasc_configured_devices[ARRAY_SIZE(stm_stasc_devices)] __initdata;
+static int stasc_configured_devices_count __initdata = 0;
+
+/* Configure the ASC's for this board.
+ * This has to be called before console_init().
+ */
+void __init stx7200_configure_asc(const int *ascs, int num_ascs, int console)
+{
+	int i;
+	struct sysconf_field *sc7_29 = NULL;
+
+	for (i=0; i<num_ascs; i++) {
+		int port;
+		struct platform_device *pdev;
+		struct sysconf_field *sc;
+
+		port = ascs[i];
+		pdev = &stm_stasc_devices[port];
+
+		if ((port == 0) || (port == 1)) {
+			/* Route UART0/1 and MPX instead of DVP to pins:
+			 * conf_pad_pio[5] = 0 */
+			if (sc7_29 == NULL)
+				sc7_29 = sysconf_claim(SYS_CFG, 7, 29, 29, "asc");
+			sysconf_write(sc7_29, 0);
+		}
+
+		switch (ascs[i]) {
+		case 0:
+			/* Route UART0 instead of PDES to pins.
+			 * pdes_scmux_out = 0 */
+#warning check these numbers
+			sc = sysconf_claim(SYS_CFG, 0,0,0, "asc");
+			sysconf_write(sc, 0);
+			break;
+
+		case 1:
+			/* Ideally we need an option here to allow section
+			 * of UART1, but with out RTS/CTS, to allow use
+			 * of PIO1[4] and PIO1[5] for dvo. At which point
+			 * this would need to become conditional.
+			 * conf_pad_pio[0] = 0 */
+			sc = sysconf_claim(SYS_CFG, 7, 24, 24, "asc");
+			sysconf_write(sc, 0);
+			break;
+
+		case 2:
+			/* Route UART2&3 or SCI inputs instead of DVP to pins.
+			 * conf_pad_dvp = 0 */
+			sc = sysconf_claim(SYS_CFG, 40, 16, 16, "asc");
+			sysconf_write(sc, 0);
+
+			/* Route UART2 (in and out) and PWM_OUT0 instead of SCI to pins.
+			 * ssc2_mux_sel = 0 */
+			if (sc7_2 == NULL)
+				sc7_2 = sysconf_claim(SYS_CFG, 7, 2, 2, "asc");
+			sysconf_write(sc7_2, 0);
+
+			/* Route UART2&3/SCI outputs instead of DVP to pins.
+			 * conf_pad_pio[1]=0 */
+			sc = sysconf_claim(SYS_CFG, 7, 25, 25, "asc");
+			sysconf_write(sc, 0);
+
+			/* No idea, more routing.
+			 * conf_pad_pio[0] = 0 */
+			sc = sysconf_claim(SYS_CFG, 7, 24, 24, "asc");
+			sysconf_write(sc, 0);
+			break;
+
+		case 3:
+			/* No idea, more routing.
+			 * conf_pad_pio[4] = 0 */
+			sc = sysconf_claim(SYS_CFG, 7, 28, 28, "asc");
+			sysconf_write(sc, 0);
+
+			/* Route UART3 (in and out) instead of SCI to pins
+			 * ssc3_mux_sel = 0 */
+			sc = sysconf_claim(SYS_CFG, 7, 3, 3, "asc");
+			sysconf_write(sc, 0);
+			break;
+		}
+
+		pdev->id = i;
+		stasc_configured_devices[stasc_configured_devices_count++] = pdev;
+	}
+
+	asc_default_console_device = stasc_configured_devices[console];
+}
+
+/* Add platform device as configured by board specific code */
+static int __init stb7200_add_asc(void)
+{
+	return platform_add_devices(stasc_configured_devices,
+				    stasc_configured_devices_count);
+}
+arch_initcall(stb7200_add_asc);
+
+/* Early resources (sysconf and PIO) --------------------------------------- */
+
+static struct platform_device sysconf_device = {
+	.name		= "sysconf",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd704000,
+			.end	= 0xfd704000 + 0x1d3,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+	.dev = {
+		.platform_data = &(struct plat_sysconf_data) {
+			.sys_device_offset = 0,
+			.sys_sta_offset = 8,
+			.sys_cfg_offset = 0x100,
+		}
+	}
+};
+
+static struct platform_device stpio_devices[] = {
+	STPIO_DEVICE(0, 0xfd020000, ILC_IRQ(96) ),
+	STPIO_DEVICE(1, 0xfd021000, ILC_IRQ(97) ),
+	STPIO_DEVICE(2, 0xfd022000, ILC_IRQ(98) ),
+	STPIO_DEVICE(3, 0xfd023000, ILC_IRQ(99) ),
+	STPIO_DEVICE(4, 0xfd024000, ILC_IRQ(100) ),
+	STPIO_DEVICE(5, 0xfd025000, ILC_IRQ(101) ),
+	STPIO_DEVICE(6, 0xfd026000, ILC_IRQ(102) ),
+	STPIO_DEVICE(7, 0xfd027000, ILC_IRQ(103) ),
+};
+
+/* Initialise devices which are required early in the boot process. */
+void __init stx7200_early_device_init(void)
+{
+	struct sysconf_field *sc;
+	unsigned long devid;
+
+	/* Initialise PIO and sysconf drivers */
+
+	sysconf_early_init(&sysconf_device);
+	stpio_early_init(stpio_devices, ARRAY_SIZE(stpio_devices));
+
+	sc = sysconf_claim(SYS_DEV, 0, 0, 31, "devid");
+	devid = sysconf_read(sc);
+	chip_revision = (devid >> 28) +1;
+	printk("STx7200 version %ld.x\n", chip_revision);
+
+	/* ClockgenB powers up with all the frequency synths bypassed.
+	 * Enable them all here.  Without this, USB 1.1 doesn't work,
+	 * as it needs a 48MHz clock which is separate from the USB 2
+	 * clock which is derived from the SATA clock. */
+	ctrl_outl(0, 0xFD701048);
+
+	/* We haven't configured the LPC, so the sleep instruction may
+	 * do bad things. Thus we disable it here. */
+	disable_hlt();
+}
+
+static void __init pio_late_setup(void)
+{
+	int i;
+	struct platform_device *pdev = stpio_devices;
+
+	for (i=0; i<ARRAY_SIZE(stpio_devices); i++,pdev++) {
+		platform_device_register(pdev);
+	}
+}
+
+static struct platform_device ilc3_device = {
+	.name		= "ilc3",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd804000,
+			.end	= 0xfd804000 + 0x900,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+};
+
+/* Late resources ---------------------------------------------------------- */
+
+static struct platform_device *stx7200_devices[] __initdata = {
+	&fdma0_7200_device,
+	//&fdma1_7200_device,
+	&fdma_xbar_device,
+	&sysconf_device,
+	&ilc3_device,
+};
+
+static int __init stx7200_devices_setup(void)
+{
+	pio_late_setup();
+
+	return platform_add_devices(stx7200_devices,
+				    ARRAY_SIZE(stx7200_devices));
+}
+device_initcall(stx7200_devices_setup);
+
+/* Interrupt initialisation ------------------------------------------------ */
+
+enum {
+	UNUSED = 0,
+
+	/* interrupt sources */
+	TMU0, TMU1, TMU2_TUNI, TMU2_TICPI,
+	RTC_ATI, RTC_PRI, RTC_CUI,
+	SCIF_ERI, SCIF_RXI, SCIF_BRI, SCIF_TXI,
+	WDT,
+	HUDI,
+
+	/* interrupt groups */
+	TMU2, RTC, SCIF,
+};
+
+static struct intc_vect vectors[] = {
+	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
+	INTC_VECT(TMU2_TUNI, 0x440), INTC_VECT(TMU2_TICPI, 0x460),
+	INTC_VECT(RTC_ATI, 0x480), INTC_VECT(RTC_PRI, 0x4a0),
+	INTC_VECT(RTC_CUI, 0x4c0),
+	INTC_VECT(SCIF_ERI, 0x4e0), INTC_VECT(SCIF_RXI, 0x500),
+	INTC_VECT(SCIF_BRI, 0x520), INTC_VECT(SCIF_TXI, 0x540),
+	INTC_VECT(WDT, 0x560),
+	INTC_VECT(HUDI, 0x600),
+};
+
+static struct intc_group groups[] = {
+	INTC_GROUP(TMU2, TMU2_TUNI, TMU2_TICPI),
+	INTC_GROUP(RTC, RTC_ATI, RTC_PRI, RTC_CUI),
+	INTC_GROUP(SCIF, SCIF_ERI, SCIF_RXI, SCIF_BRI, SCIF_TXI),
+};
+
+static struct intc_prio priorities[] = {
+	INTC_PRIO(SCIF, 3),
+};
+
+static struct intc_prio_reg prio_registers[] = {
+					/*  15-12, 11-8,  7-4,   3-0 */
+	{ 0xffd00004, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2,   RTC } },
+	{ 0xffd00008, 0, 16, 4, /* IPRB */ {  WDT,    0, SCIF,     0 } },
+	{ 0xffd0000c, 0, 16, 4, /* IPRC */ {    0,    0,    0,  HUDI } },
+};
+
+static DECLARE_INTC_DESC(intc_desc, "stx7200", vectors, groups,
+			 priorities, NULL, prio_registers, NULL);
+
+static struct irq_chip stx7200_ipr_chip = {
+	.name = "IPR",
+};
+
+void __init plat_irq_setup(void)
+{
+	int irq;
+	struct sysconf_field *sc;
+
+	/* Configure the external interrupt pins as inputs */
+	sc = sysconf_claim(SYS_CFG, 10, 0, 3, "irq");
+	sysconf_write(sc, 0xf);
+
+	register_intc_controller(&intc_desc);
+
+	for (irq=0; irq<16; irq++) {
+		set_irq_chip(irq, &dummy_irq_chip);
+		set_irq_chained_handler(irq, ilc_irq_demux);
+	}
+
+	ilc_early_init(&ilc3_device);
+	ilc_stx7200_init();
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/sh4_fpu.h linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/sh4_fpu.h
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/sh4_fpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/sh4_fpu.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,32 @@
+/*
+ * linux/arch/sh/kernel/cpu/sh4/sh4_fpu.h
+ *
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Carl Shaw <carl.shaw@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License Version 2.  See linux/COPYING for more information.
+ *
+ * Definitions for SH4 FPU operations
+ */
+
+#ifndef __CPU_SH4_FPU_H
+#define __CPU_SH4_FPU_H
+
+#define FPSCR_ENABLE_MASK	0x00000f80UL
+
+#define FPSCR_FMOV_DOUBLE	(1<<1)
+
+#define FPSCR_CAUSE_INEXACT	(1<<12)
+#define FPSCR_CAUSE_UNDERFLOW	(1<<13)
+#define FPSCR_CAUSE_OVERFLOW	(1<<14)
+#define FPSCR_CAUSE_DIVZERO	(1<<15)
+#define FPSCR_CAUSE_INVALID	(1<<16)
+#define FPSCR_CAUSE_ERROR 	(1<<17)
+
+#define FPSCR_DBL_PRECISION	(1<<19)
+#define FPSCR_ROUNDING_MODE(x)	((x >> 20) & 3)
+#define FPSCR_RM_NEAREST	(0)
+#define FPSCR_RM_ZERO		(1)
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/cpu/sh4/softfloat.c linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/softfloat.c
--- linux-2.6.23.1/arch/sh/kernel/cpu/sh4/softfloat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/cpu/sh4/softfloat.c	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,892 @@
+/*
+ * Floating point emulation support for subnormalised numbers on SH4 architecture
+ * This file is derived from the SoftFloat IEC/IEEE Floating-point Arithmetic
+ * Package, Release 2 the original license of which is reproduced below.
+ *
+ * ===============================================================================
+ *
+ * This C source file is part of the SoftFloat IEC/IEEE Floating-point
+ * Arithmetic Package, Release 2.
+ *
+ * Written by John R. Hauser.  This work was made possible in part by the
+ * International Computer Science Institute, located at Suite 600, 1947 Center
+ * Street, Berkeley, California 94704.  Funding was partially provided by the
+ * National Science Foundation under grant MIP-9311980.  The original version
+ * of this code was written as part of a project to build a fixed-point vector
+ * processor in collaboration with the University of California at Berkeley,
+ * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+ * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/
+ * arithmetic/softfloat.html'.
+ *
+ * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+ * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+ * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+ * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+ * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+ *
+ * Derivative works are acceptable, even for commercial purposes, so long as
+ * (1) they include prominent notice that the work is derivative, and (2) they
+ * include prominent notice akin to these three paragraphs for those parts of
+ * this code that are retained.
+ *
+ * ===============================================================================
+ *
+ * SH4 modifications by Ismail Dhaoui <ismail.dhaoui@st.com>
+ * and Kamel Khelifi <kamel.khelifi@st.com>
+ * */
+
+#include <linux/kernel.h>
+#include "sh4_fpu.h"
+
+#define LIT64( a ) a##LL
+
+typedef char flag;
+typedef unsigned char uint8;
+typedef signed char int8;
+typedef int uint16;
+typedef int int16;
+typedef unsigned int uint32;
+typedef signed int int32;
+
+typedef unsigned long long int bits64;
+typedef signed long long int sbits64;
+
+typedef unsigned char bits8;
+typedef signed char sbits8;
+typedef unsigned short int bits16;
+typedef signed short int sbits16;
+typedef unsigned int bits32;
+typedef signed int sbits32;
+
+typedef unsigned long long int uint64;
+typedef signed long long int int64;
+
+typedef unsigned long int float32;
+typedef unsigned long long float64;
+
+extern void float_raise(unsigned int flags);	/* in fpu.c */
+extern int float_rounding_mode(void);	/* in fpu.c */
+
+inline bits64 extractFloat64Frac(float64 a);
+inline flag extractFloat64Sign(float64 a);
+inline int16 extractFloat64Exp(float64 a);
+inline int16 extractFloat32Exp(float32 a);
+inline flag extractFloat32Sign(float32 a);
+inline bits32 extractFloat32Frac(float32 a);
+inline float64 packFloat64(flag zSign, int16 zExp, bits64 zSig);
+inline void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr);
+inline float32 packFloat32(flag zSign, int16 zExp, bits32 zSig);
+inline void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr);
+float64 float64_sub(float64 a, float64 b);
+float32 float32_sub(float32 a, float32 b);
+float32 float32_add(float32 a, float32 b);
+float64 float64_add(float64 a, float64 b);
+float64 float64_div(float64 a, float64 b);
+float32 float32_div(float32 a, float32 b);
+float32 float32_mul(float32 a, float32 b);
+float64 float64_mul(float64 a, float64 b);
+inline void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr);
+inline void sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr);
+inline void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr);
+
+static int8 countLeadingZeros32(bits32 a);
+static int8 countLeadingZeros64(bits64 a);
+static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp,
+					    bits64 zSig);
+static float64 subFloat64Sigs(float64 a, float64 b, flag zSign);
+static float64 addFloat64Sigs(float64 a, float64 b, flag zSign);
+static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig);
+static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp,
+					    bits32 zSig);
+static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig);
+static float32 subFloat32Sigs(float32 a, float32 b, flag zSign);
+static float32 addFloat32Sigs(float32 a, float32 b, flag zSign);
+static void normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr,
+				      bits64 * zSigPtr);
+static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b);
+static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
+				      bits32 * zSigPtr);
+
+inline bits64 extractFloat64Frac(float64 a)
+{
+	return a & LIT64(0x000FFFFFFFFFFFFF);
+}
+
+inline flag extractFloat64Sign(float64 a)
+{
+	return a >> 63;
+}
+
+inline int16 extractFloat64Exp(float64 a)
+{
+	return (a >> 52) & 0x7FF;
+}
+
+inline int16 extractFloat32Exp(float32 a)
+{
+	return (a >> 23) & 0xFF;
+}
+
+inline flag extractFloat32Sign(float32 a)
+{
+	return a >> 31;
+}
+
+inline bits32 extractFloat32Frac(float32 a)
+{
+	return a & 0x007FFFFF;
+}
+
+inline float64 packFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;
+}
+
+inline void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr)
+{
+	bits64 z;
+
+	if (count == 0) {
+		z = a;
+	} else if (count < 64) {
+		z = (a >> count) | ((a << ((-count) & 63)) != 0);
+	} else {
+		z = (a != 0);
+	}
+	*zPtr = z;
+}
+
+static int8 countLeadingZeros32(bits32 a)
+{
+	static const int8 countLeadingZerosHigh[] = {
+		8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+		3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+	};
+	int8 shiftCount;
+
+	shiftCount = 0;
+	if (a < 0x10000) {
+		shiftCount += 16;
+		a <<= 16;
+	}
+	if (a < 0x1000000) {
+		shiftCount += 8;
+		a <<= 8;
+	}
+	shiftCount += countLeadingZerosHigh[a >> 24];
+	return shiftCount;
+
+}
+
+static int8 countLeadingZeros64(bits64 a)
+{
+	int8 shiftCount;
+
+	shiftCount = 0;
+	if (a < ((bits64) 1) << 32) {
+		shiftCount += 32;
+	} else {
+		a >>= 32;
+	}
+	shiftCount += countLeadingZeros32(a);
+	return shiftCount;
+
+}
+
+static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros64(zSig) - 1;
+	return roundAndPackFloat64(zSign, zExp - shiftCount,
+				   zSig << shiftCount);
+
+}
+
+static float64 subFloat64Sigs(float64 a, float64 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 10;
+	bSig <<= 10;
+	if (0 < expDiff)
+		goto aExpBigger;
+	if (expDiff < 0)
+		goto bExpBigger;
+	if (aExp == 0) {
+		aExp = 1;
+		bExp = 1;
+	}
+	if (bSig < aSig)
+		goto aBigger;
+	if (aSig < bSig)
+		goto bBigger;
+	return packFloat64(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
+      bExpBigger:
+	if (bExp == 0x7FF) {
+		return packFloat64(zSign ^ 1, 0x7FF, 0);
+	}
+	if (aExp == 0) {
+		++expDiff;
+	} else {
+		aSig |= LIT64(0x4000000000000000);
+	}
+	shift64RightJamming(aSig, -expDiff, &aSig);
+	bSig |= LIT64(0x4000000000000000);
+      bBigger:
+	zSig = bSig - aSig;
+	zExp = bExp;
+	zSign ^= 1;
+	goto normalizeRoundAndPack;
+      aExpBigger:
+	if (aExp == 0x7FF) {
+		return a;
+	}
+	if (bExp == 0) {
+		--expDiff;
+	} else {
+		bSig |= LIT64(0x4000000000000000);
+	}
+	shift64RightJamming(bSig, expDiff, &bSig);
+	aSig |= LIT64(0x4000000000000000);
+      aBigger:
+	zSig = aSig - bSig;
+	zExp = aExp;
+      normalizeRoundAndPack:
+	--zExp;
+	return normalizeRoundAndPackFloat64(zSign, zExp, zSig);
+
+}
+static float64 addFloat64Sigs(float64 a, float64 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 9;
+	bSig <<= 9;
+	if (0 < expDiff) {
+		if (aExp == 0x7FF) {
+			return a;
+		}
+		if (bExp == 0) {
+			--expDiff;
+		} else {
+			bSig |= LIT64(0x2000000000000000);
+		}
+		shift64RightJamming(bSig, expDiff, &bSig);
+		zExp = aExp;
+	} else if (expDiff < 0) {
+		if (bExp == 0x7FF) {
+			return packFloat64(zSign, 0x7FF, 0);
+		}
+		if (aExp == 0) {
+			++expDiff;
+		} else {
+			aSig |= LIT64(0x2000000000000000);
+		}
+		shift64RightJamming(aSig, -expDiff, &aSig);
+		zExp = bExp;
+	} else {
+		if (aExp == 0x7FF) {
+			return a;
+		}
+		if (aExp == 0)
+			return packFloat64(zSign, 0, (aSig + bSig) >> 9);
+		zSig = LIT64(0x4000000000000000) + aSig + bSig;
+		zExp = aExp;
+		goto roundAndPack;
+	}
+	aSig |= LIT64(0x2000000000000000);
+	zSig = (aSig + bSig) << 1;
+	--zExp;
+	if ((sbits64) zSig < 0) {
+		zSig = aSig + bSig;
+		++zExp;
+	}
+      roundAndPack:
+	return roundAndPackFloat64(zSign, zExp, zSig);
+
+}
+
+inline float32 packFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	return (((bits32) zSign) << 31) + (((bits32) zExp) << 23) + zSig;
+}
+
+inline void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr)
+{
+	bits32 z;
+	if (count == 0) {
+		z = a;
+	} else if (count < 32) {
+		z = (a >> count) | ((a << ((-count) & 31)) != 0);
+	} else {
+		z = (a != 0);
+	}
+	*zPtr = z;
+}
+
+static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	flag roundNearestEven;
+	int8 roundIncrement, roundBits;
+	flag isTiny;
+
+	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
+	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
+	roundIncrement = 0x40;
+	if (!roundNearestEven) {
+		roundIncrement = 0;
+	}
+	roundBits = zSig & 0x7F;
+	if (0xFD <= (bits16) zExp) {
+		if ((0xFD < zExp)
+		    || ((zExp == 0xFD)
+			&& ((sbits32) (zSig + roundIncrement) < 0))
+		    ) {
+			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
+			return packFloat32(zSign, 0xFF,
+					   0) - (roundIncrement == 0);
+		}
+		if (zExp < 0) {
+			isTiny = (zExp < -1)
+			    || (zSig + roundIncrement < 0x80000000);
+			shift32RightJamming(zSig, -zExp, &zSig);
+			zExp = 0;
+			roundBits = zSig & 0x7F;
+			if (isTiny && roundBits)
+				float_raise(FPSCR_CAUSE_UNDERFLOW);
+		}
+	}
+	if (roundBits)
+		float_raise(FPSCR_CAUSE_INEXACT);
+	zSig = (zSig + roundIncrement) >> 7;
+	zSig &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);
+	if (zSig == 0)
+		zExp = 0;
+	return packFloat32(zSign, zExp, zSig);
+
+}
+
+static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros32(zSig) - 1;
+	return roundAndPackFloat32(zSign, zExp - shiftCount,
+				   zSig << shiftCount);
+}
+
+static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	flag roundNearestEven;
+	int16 roundIncrement, roundBits;
+	flag isTiny;
+
+	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
+	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
+	roundIncrement = 0x200;
+	if (!roundNearestEven) {
+		roundIncrement = 0;
+	}
+	roundBits = zSig & 0x3FF;
+	if (0x7FD <= (bits16) zExp) {
+		if ((0x7FD < zExp)
+		    || ((zExp == 0x7FD)
+			&& ((sbits64) (zSig + roundIncrement) < 0))
+		    ) {
+			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
+			return packFloat64(zSign, 0x7FF,
+					   0) - (roundIncrement == 0);
+		}
+		if (zExp < 0) {
+			isTiny = (zExp < -1)
+			    || (zSig + roundIncrement <
+				LIT64(0x8000000000000000));
+			shift64RightJamming(zSig, -zExp, &zSig);
+			zExp = 0;
+			roundBits = zSig & 0x3FF;
+			if (isTiny && roundBits)
+				float_raise(FPSCR_CAUSE_UNDERFLOW);
+		}
+	}
+	if (roundBits)
+		float_raise(FPSCR_CAUSE_INEXACT);
+	zSig = (zSig + roundIncrement) >> 10;
+	zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);
+	if (zSig == 0)
+		zExp = 0;
+	return packFloat64(zSign, zExp, zSig);
+
+}
+
+static float32 subFloat32Sigs(float32 a, float32 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 7;
+	bSig <<= 7;
+	if (0 < expDiff)
+		goto aExpBigger;
+	if (expDiff < 0)
+		goto bExpBigger;
+	if (aExp == 0) {
+		aExp = 1;
+		bExp = 1;
+	}
+	if (bSig < aSig)
+		goto aBigger;
+	if (aSig < bSig)
+		goto bBigger;
+	return packFloat32(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
+      bExpBigger:
+	if (bExp == 0xFF) {
+		return packFloat32(zSign ^ 1, 0xFF, 0);
+	}
+	if (aExp == 0) {
+		++expDiff;
+	} else {
+		aSig |= 0x40000000;
+	}
+	shift32RightJamming(aSig, -expDiff, &aSig);
+	bSig |= 0x40000000;
+      bBigger:
+	zSig = bSig - aSig;
+	zExp = bExp;
+	zSign ^= 1;
+	goto normalizeRoundAndPack;
+      aExpBigger:
+	if (aExp == 0xFF) {
+		return a;
+	}
+	if (bExp == 0) {
+		--expDiff;
+	} else {
+		bSig |= 0x40000000;
+	}
+	shift32RightJamming(bSig, expDiff, &bSig);
+	aSig |= 0x40000000;
+      aBigger:
+	zSig = aSig - bSig;
+	zExp = aExp;
+      normalizeRoundAndPack:
+	--zExp;
+	return normalizeRoundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+static float32 addFloat32Sigs(float32 a, float32 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 6;
+	bSig <<= 6;
+	if (0 < expDiff) {
+		if (aExp == 0xFF) {
+			return a;
+		}
+		if (bExp == 0) {
+			--expDiff;
+		} else {
+			bSig |= 0x20000000;
+		}
+		shift32RightJamming(bSig, expDiff, &bSig);
+		zExp = aExp;
+	} else if (expDiff < 0) {
+		if (bExp == 0xFF) {
+			return packFloat32(zSign, 0xFF, 0);
+		}
+		if (aExp == 0) {
+			++expDiff;
+		} else {
+			aSig |= 0x20000000;
+		}
+		shift32RightJamming(aSig, -expDiff, &aSig);
+		zExp = bExp;
+	} else {
+		if (aExp == 0xFF) {
+			return a;
+		}
+		if (aExp == 0)
+			return packFloat32(zSign, 0, (aSig + bSig) >> 6);
+		zSig = 0x40000000 + aSig + bSig;
+		zExp = aExp;
+		goto roundAndPack;
+	}
+	aSig |= 0x20000000;
+	zSig = (aSig + bSig) << 1;
+	--zExp;
+	if ((sbits32) zSig < 0) {
+		zSig = aSig + bSig;
+		++zExp;
+	}
+      roundAndPack:
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float64 float64_sub(float64 a, float64 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat64Sign(a);
+	bSign = extractFloat64Sign(b);
+	if (aSign == bSign) {
+		return subFloat64Sigs(a, b, aSign);
+	} else {
+		return addFloat64Sigs(a, b, aSign);
+	}
+
+}
+
+float32 float32_sub(float32 a, float32 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat32Sign(a);
+	bSign = extractFloat32Sign(b);
+	if (aSign == bSign) {
+		return subFloat32Sigs(a, b, aSign);
+	} else {
+		return addFloat32Sigs(a, b, aSign);
+	}
+
+}
+
+float32 float32_add(float32 a, float32 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat32Sign(a);
+	bSign = extractFloat32Sign(b);
+	if (aSign == bSign) {
+		return addFloat32Sigs(a, b, aSign);
+	} else {
+		return subFloat32Sigs(a, b, aSign);
+	}
+
+}
+
+float64 float64_add(float64 a, float64 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat64Sign(a);
+	bSign = extractFloat64Sign(b);
+	if (aSign == bSign) {
+		return addFloat64Sigs(a, b, aSign);
+	} else {
+		return subFloat64Sigs(a, b, aSign);
+	}
+}
+
+static void
+normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr, bits64 * zSigPtr)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros64(aSig) - 11;
+	*zSigPtr = aSig << shiftCount;
+	*zExpPtr = 1 - shiftCount;
+}
+
+inline void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr)
+{
+	bits64 z1;
+
+	z1 = a1 + b1;
+	*z1Ptr = z1;
+	*z0Ptr = a0 + b0 + (z1 < a1);
+}
+
+inline void
+sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+       bits64 * z1Ptr)
+{
+	*z1Ptr = a1 - b1;
+	*z0Ptr = a0 - b0 - (a1 < b1);
+}
+
+static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b)
+{
+	bits64 b0, b1;
+	bits64 rem0, rem1, term0, term1;
+	bits64 z;
+	if (b <= a0)
+		return LIT64(0xFFFFFFFFFFFFFFFF);
+	b0 = b >> 32;
+	z = (b0 << 32 <= a0) ? LIT64(0xFFFFFFFF00000000) : (a0 / b0) << 32;
+	mul64To128(b, z, &term0, &term1);
+	sub128(a0, a1, term0, term1, &rem0, &rem1);
+	while (((sbits64) rem0) < 0) {
+		z -= LIT64(0x100000000);
+		b1 = b << 32;
+		add128(rem0, rem1, b0, b1, &rem0, &rem1);
+	}
+	rem0 = (rem0 << 32) | (rem1 >> 32);
+	z |= (b0 << 32 <= rem0) ? 0xFFFFFFFF : rem0 / b0;
+	return z;
+}
+
+inline void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr)
+{
+	bits32 aHigh, aLow, bHigh, bLow;
+	bits64 z0, zMiddleA, zMiddleB, z1;
+
+	aLow = a;
+	aHigh = a >> 32;
+	bLow = b;
+	bHigh = b >> 32;
+	z1 = ((bits64) aLow) * bLow;
+	zMiddleA = ((bits64) aLow) * bHigh;
+	zMiddleB = ((bits64) aHigh) * bLow;
+	z0 = ((bits64) aHigh) * bHigh;
+	zMiddleA += zMiddleB;
+	z0 += (((bits64) (zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);
+	zMiddleA <<= 32;
+	z1 += zMiddleA;
+	z0 += (z1 < zMiddleA);
+	*z1Ptr = z1;
+	*z0Ptr = z0;
+
+}
+
+static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
+				      bits32 * zSigPtr)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros32(aSig) - 8;
+	*zSigPtr = aSig << shiftCount;
+	*zExpPtr = 1 - shiftCount;
+
+}
+
+float64 float64_div(float64 a, float64 b)
+{
+	flag aSign, bSign, zSign;
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	bits64 rem0, rem1;
+	bits64 term0, term1;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	aSign = extractFloat64Sign(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	bSign = extractFloat64Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0x7FF) {
+		if (bExp == 0x7FF) {
+		}
+		return packFloat64(zSign, 0x7FF, 0);
+	}
+	if (bExp == 0x7FF) {
+		return packFloat64(zSign, 0, 0);
+	}
+	if (bExp == 0) {
+		if (bSig == 0) {
+			if ((aExp | aSig) == 0) {
+				float_raise(FPSCR_CAUSE_INVALID);
+			}
+			return packFloat64(zSign, 0x7FF, 0);
+		}
+		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
+	}
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
+	}
+	zExp = aExp - bExp + 0x3FD;
+	aSig = (aSig | LIT64(0x0010000000000000)) << 10;
+	bSig = (bSig | LIT64(0x0010000000000000)) << 11;
+	if (bSig <= (aSig + aSig)) {
+		aSig >>= 1;
+		++zExp;
+	}
+	zSig = estimateDiv128To64(aSig, 0, bSig);
+	if ((zSig & 0x1FF) <= 2) {
+		mul64To128(bSig, zSig, &term0, &term1);
+		sub128(aSig, 0, term0, term1, &rem0, &rem1);
+		while ((sbits64) rem0 < 0) {
+			--zSig;
+			add128(rem0, rem1, 0, bSig, &rem0, &rem1);
+		}
+		zSig |= (rem1 != 0);
+	}
+	return roundAndPackFloat64(zSign, zExp, zSig);
+
+}
+
+float32 float32_div(float32 a, float32 b)
+{
+	flag aSign, bSign, zSign;
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	aSign = extractFloat32Sign(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	bSign = extractFloat32Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0xFF) {
+		if (bExp == 0xFF) {
+		}
+		return packFloat32(zSign, 0xFF, 0);
+	}
+	if (bExp == 0xFF) {
+		return packFloat32(zSign, 0, 0);
+	}
+	if (bExp == 0) {
+		if (bSig == 0) {
+			return packFloat32(zSign, 0xFF, 0);
+		}
+		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
+	}
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
+	}
+	zExp = aExp - bExp + 0x7D;
+	aSig = (aSig | 0x00800000) << 7;
+	bSig = (bSig | 0x00800000) << 8;
+	if (bSig <= (aSig + aSig)) {
+		aSig >>= 1;
+		++zExp;
+	}
+	zSig = (((bits64) aSig) << 32) / bSig;
+	if ((zSig & 0x3F) == 0) {
+		zSig |= (((bits64) bSig) * zSig != ((bits64) aSig) << 32);
+	}
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float32 float32_mul(float32 a, float32 b)
+{
+	char aSign, bSign, zSign;
+	int aExp, bExp, zExp;
+	unsigned int aSig, bSig;
+	unsigned long long zSig64;
+	unsigned int zSig;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	aSign = extractFloat32Sign(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	bSign = extractFloat32Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
+	}
+	if (bExp == 0) {
+		if (bSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
+	}
+	if ((bExp == 0xff && bSig == 0) || (aExp == 0xff && aSig == 0))
+		return roundAndPackFloat32(zSign, 0xff, 0);
+
+	zExp = aExp + bExp - 0x7F;
+	aSig = (aSig | 0x00800000) << 7;
+	bSig = (bSig | 0x00800000) << 8;
+	shift64RightJamming(((unsigned long long)aSig) * bSig, 32, &zSig64);
+	zSig = zSig64;
+	if (0 <= (signed int)(zSig << 1)) {
+		zSig <<= 1;
+		--zExp;
+	}
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float64 float64_mul(float64 a, float64 b)
+{
+	char aSign, bSign, zSign;
+	int aExp, bExp, zExp;
+	unsigned long long int aSig, bSig, zSig0, zSig1;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	aSign = extractFloat64Sign(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	bSign = extractFloat64Sign(b);
+	zSign = aSign ^ bSign;
+
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
+	}
+	if (bExp == 0) {
+		if (bSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
+	}
+	if ((aExp == 0x7ff && aSig == 0) || (bExp == 0x7ff && bSig == 0))
+		return roundAndPackFloat64(zSign, 0x7ff, 0);
+
+	zExp = aExp + bExp - 0x3FF;
+	aSig = (aSig | 0x0010000000000000LL) << 10;
+	bSig = (bSig | 0x0010000000000000LL) << 11;
+	mul64To128(aSig, bSig, &zSig0, &zSig1);
+	zSig0 |= (zSig1 != 0);
+	if (0 <= (signed long long int)(zSig0 << 1)) {
+		zSig0 <<= 1;
+		--zExp;
+	}
+	return roundAndPackFloat64(zSign, zExp, zSig0);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/entry-common.S linux-2.6.23.1-stm/arch/sh/kernel/entry-common.S
--- linux-2.6.23.1/arch/sh/kernel/entry-common.S	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/entry-common.S	2007-11-01 12:00:40.000000000 +0000
@@ -176,25 +176,6 @@
 	jmp	@r1
 	 lds	r0, pr
 work_resched:
-#if defined(CONFIG_GUSA) && !defined(CONFIG_PREEMPT)
-	! gUSA handling
-	mov.l	@(OFF_SP,r15), r0	! get user space stack pointer
-	mov	r0, r1
-	shll	r0
-	bf/s	1f
-	 shll	r0
-	bf/s	1f
-	 mov	#OFF_PC, r0
-	! 				  SP >= 0xc0000000 : gUSA mark
-	mov.l	@(r0,r15), r2		! get user space PC (program counter)
-	mov.l	@(OFF_R0,r15), r3	! end point
-	cmp/hs	r3, r2			! r2 >= r3? 
-	bt	1f
-	add	r3, r1			! rewind point #2
-	mov.l	r1, @(r0,r15)		! reset PC to rewind point #2
-	!
-1:
-#endif
 	mov.l	1f, r1
 	jsr	@r1				! schedule
 	 nop
@@ -398,6 +379,7 @@
 	bf	syscall_exit_work
 	bra	__restore_all
 	 nop
+ret_from_exception_end:
 	.align	2
 #if !defined(CONFIG_CPU_SH2)
 1:	.long	TRA
@@ -409,3 +391,73 @@
 5:	.long	trace_hardirqs_on
 6:	.long	trace_hardirqs_off
 #endif
+
+	.section	.debug_frame,"",@progbits
+.LCIE:
+	.ualong	.LCIE_end - .LCIE_start
+.LCIE_start:
+	.ualong	0xffffffff	/* CIE ID */
+	.byte	0x1		/* Version number */
+	.string	""		/* NUL-terminated augmentation string */
+	.uleb128 0x1		/* Code alignment factor */
+	.sleb128 -4		/* Data alignment factor */
+	.byte	0x11		/* Return address register column */
+				/* Augmentation length and data (none) */
+	.byte	0xc		/* DW_CFA_def_cfa */
+	.uleb128 0xf		/* r15 */
+	.uleb128 0x0		/* offset 0 */
+
+	.align 2
+.LCIE_end:
+
+	.ualong	.LFDE_end-.LFDE_start	/* Length FDE */
+.LFDE_start:
+	.ualong	.LCIE			/* CIE pointer */
+	.ualong	ret_from_exception-4	/* absolute start address */
+	.ualong	ret_from_exception_end-(ret_from_exception-4)
+					/* length */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.ualong	0			/*   by */
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.uleb128 OFF_TRA+4		/*   advance CFA by sizeof(ptregs)+4 */
+
+	.byte	0x80+0			/* DW_CFA_offset r0 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(0*4)))>>2
+	.byte	0x80+1			/* DW_CFA_offset r1 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(1*4)))>>2
+	.byte	0x80+2			/* DW_CFA_offset r2 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(2*4)))>>2
+	.byte	0x80+3			/* DW_CFA_offset r3 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(3*4)))>>2
+	.byte	0x80+4			/* DW_CFA_offset r4 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(4*4)))>>2
+	.byte	0x80+5			/* DW_CFA_offset r5 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(5*4)))>>2
+	.byte	0x80+6			/* DW_CFA_offset r6 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(6*4)))>>2
+	.byte	0x80+7			/* DW_CFA_offset r7 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(7*4)))>>2
+	.byte	0x80+8			/* DW_CFA_offset r8 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(8*4)))>>2
+	.byte	0x80+9			/* DW_CFA_offset r9 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(9*4)))>>2
+	.byte	0x80+10			/* DW_CFA_offset r10 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(10*4)))>>2
+	.byte	0x80+11			/* DW_CFA_offset r11 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(11*4)))>>2
+	.byte	0x80+12			/* DW_CFA_offset r12 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(12*4)))>>2
+	.byte	0x80+13			/* DW_CFA_offset r13 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(13*4)))>>2
+	.byte	0x80+14			/* DW_CFA_offset r14 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(14*4)))>>2
+	.byte	0x80+15			/* DW_CFA_offset r15 */
+	.uleb128 ((OFF_TRA+4)-OFF_SP)>>2
+	.byte	0x80+16			/* DW_CFA_offset r16=pc */
+	.uleb128 ((OFF_TRA+4)-OFF_PC)>>2
+	.byte	0x80+17			/* DW_CFA_offset r17=pr */
+	.uleb128 ((OFF_TRA+4)-OFF_PR)>>2
+	.align 2
+.LFDE_end:
+
+	.previous
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/head.S linux-2.6.23.1-stm/arch/sh/kernel/head.S
--- linux-2.6.23.1/arch/sh/kernel/head.S	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/head.S	2007-11-01 12:00:40.000000000 +0000
@@ -101,9 +101,10 @@
 	SYNCO()			! Wait for pending instructions..
 	
 	!			Start kernel
+	mov	#0, r1
 	mov.l	5f, r0
 	jmp	@r0
-	 nop
+	 lds	r1, pr
 
 	.balign 4
 #if defined(CONFIG_CPU_SH2)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/io.c linux-2.6.23.1-stm/arch/sh/kernel/io.c
--- linux-2.6.23.1/arch/sh/kernel/io.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/io.c	2007-11-01 12:00:43.000000000 +0000
@@ -4,7 +4,6 @@
  * Copyright (C) 2000  Stuart Menefy
  * Copyright (C) 2005  Paul Mundt
  *
- * Provide real functions which expand to whatever the header file defined.
  * Also definitions of machine independent IO functions.
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -17,33 +16,87 @@
 
 /*
  * Copy data from IO memory space to "real" memory space.
- * This needs to be optimized.
  */
 void memcpy_fromio(void *to, volatile void __iomem *from, unsigned long count)
 {
-	char *p = to;
-        while (count) {
-                count--;
-                *p = readb((void __iomem *)from);
-                p++;
-                from++;
-        }
+	/*
+	 * Would it be worthwhile doing byte and long transfers first
+	 * to try and get aligned?
+	 */
+#ifdef CONFIG_CPU_SH4
+	if ( (count >= 0x20) &&
+	     (((u32)to & 0x1f) == 0) && (((u32)from & 0x3) == 0) ) {
+		int tmp2, tmp3, tmp4, tmp5, tmp6;
+
+		__asm__ __volatile__(
+			"1:			\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	@%7+, %2	\n\t"
+			"movca.l r0, @%0	\n\t"
+			"mov.l	@%7+, %3	\n\t"
+			"mov.l	@%7+, %4	\n\t"
+			"mov.l	@%7+, %5	\n\t"
+			"mov.l	@%7+, %6	\n\t"
+			"mov.l	@%7+, r7	\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	%2, @(0x04,%0)	\n\t"
+			"mov	#0x20, %2	\n\t"
+			"mov.l	%3, @(0x08,%0)	\n\t"
+			"sub	%2, %1		\n\t"
+			"mov.l	%4, @(0x0c,%0)	\n\t"
+			"cmp/hi	%1, %2		! T if 32 > count	\n\t"
+			"mov.l	%5, @(0x10,%0)	\n\t"
+			"mov.l	%6, @(0x14,%0)	\n\t"
+			"mov.l	r7, @(0x18,%0)	\n\t"
+			"mov.l	r0, @(0x1c,%0)	\n\t"
+			"bf.s	1b		\n\t"
+			" add	#0x20, %0	\n\t"
+			: "=&r" (to), "=&r" (count),
+			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
+			  "=&r" (tmp5), "=&r" (tmp6), "=&r" (from)
+			: "7"(from), "0" (to), "1" (count)
+			: "r0", "r7", "t", "memory");
+	}
+#endif
+
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for ( ; count > 3; count -= 4) {
+			*(u32*)to = *(volatile u32*)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for ( ; count > 0; count--) {
+		*(u8*)to = *(volatile u8*)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_fromio);
 
 /*
  * Copy data from "real" memory space to IO memory space.
- * This needs to be optimized.
  */
 void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
-	const char *p = from;
-        while (count) {
-                count--;
-                writeb(*p, (void __iomem *)to);
-                p++;
-                to++;
-        }
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for ( ; count > 3; count -= 4) {
+			*(volatile u32*)to = *(u32*)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for ( ; count > 0; count--) {
+		*(volatile u8*)to = *(u8*)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_toio);
 
@@ -61,9 +114,20 @@
 }
 EXPORT_SYMBOL(memset_io);
 
-void __raw_readsl(unsigned long addr, void *datap, int len)
+void __raw_readsw(const void __iomem *addrp, void *datap, int len)
+{
+	u16 *data;
+
+	for (data = datap; len != 0; len--)
+		*data++ = ctrl_inw(addrp);
+
+}
+EXPORT_SYMBOL(__raw_readsw);
+
+void __raw_readsl(const void __iomem *addrp, void *datap, int len)
 {
 	u32 *data;
+	unsigned long addr = (unsigned long)addrp;
 
 	for (data = datap; (len != 0) && (((u32)data & 0x1f) != 0); len--)
 		*data++ = ctrl_inl(addr);
@@ -110,8 +174,20 @@
 }
 EXPORT_SYMBOL(__raw_readsl);
 
-void __raw_writesl(unsigned long addr, const void *data, int len)
+void __raw_writesw(void __iomem *addrp, const void *datap, int len)
 {
+	u16 *data;
+
+	for (data = datap; len != 0; len--)
+		ctrl_outw(*data++, addrp);
+
+}
+EXPORT_SYMBOL(__raw_writesw);
+
+void __raw_writesl(void __iomem *addrp, const void *data, int len)
+{
+	unsigned long addr = (unsigned long)addrp;
+
 	if (likely(len != 0)) {
 		int tmp1;
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/io_generic.c linux-2.6.23.1-stm/arch/sh/kernel/io_generic.c
--- linux-2.6.23.1/arch/sh/kernel/io_generic.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/io_generic.c	2007-11-01 12:00:40.000000000 +0000
@@ -28,7 +28,7 @@
 
 static inline void delay(void)
 {
-	ctrl_inw(0xa0000000);
+	ctrl_inw(CCN_PVR);
 }
 
 u8 generic_inb(unsigned long port)
@@ -104,8 +104,7 @@
 	u32 *buf = dst;
 
 	port_addr = (volatile u32 *)ioport_map(port, 4);
-	while (count--)
-		*buf++ = *port_addr;
+	__raw_readsl((void __iomem*)port, buf, count);
 
 	dummy_read();
 }
@@ -178,8 +177,7 @@
 	const u32 *buf = src;
 
 	port_addr = (volatile u32 __force *)ioport_map(port, 4);
-	while (count--)
-		*port_addr = *buf++;
+	__raw_writesl((void __iomem*)port, buf, count);
 
 	dummy_read();
 }
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/irq.c linux-2.6.23.1-stm/arch/sh/kernel/irq.c
--- linux-2.6.23.1/arch/sh/kernel/irq.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/irq.c	2007-11-01 12:00:42.000000000 +0000
@@ -107,7 +107,7 @@
 	}
 #endif
 
-	irq = irq_demux(evt2irq(irq));
+	irq = evt2irq(irq);
 
 #ifdef CONFIG_4KSTACKS
 	curctx = (union irq_ctx *)current_thread_info();
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/machvec.c linux-2.6.23.1-stm/arch/sh/kernel/machvec.c
--- linux-2.6.23.1/arch/sh/kernel/machvec.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/machvec.c	2007-11-01 12:00:42.000000000 +0000
@@ -130,7 +130,6 @@
 
 	mv_set(ioport_map);
 	mv_set(ioport_unmap);
-	mv_set(irq_demux);
 
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/process.c linux-2.6.23.1-stm/arch/sh/kernel/process.c
--- linux-2.6.23.1/arch/sh/kernel/process.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/process.c	2007-11-01 12:00:41.000000000 +0000
@@ -325,7 +325,7 @@
 	ctrl_outb(asid, UBC_BASRA);
 #endif
 
-	ctrl_outl(0, UBC_BAMRA);
+	ctrl_outb(0, UBC_BAMRA);
 
 	if (current_cpu_data.type == CPU_SH7729 ||
 	    current_cpu_data.type == CPU_SH7710 ||
@@ -350,25 +350,6 @@
 	unlazy_fpu(prev, task_pt_regs(prev));
 #endif
 
-#if defined(CONFIG_GUSA) && defined(CONFIG_PREEMPT)
-	{
-		struct pt_regs *regs;
-
-		preempt_disable();
-		regs = task_pt_regs(prev);
-		if (user_mode(regs) && regs->regs[15] >= 0xc0000000) {
-			int offset = (int)regs->regs[15];
-
-			/* Reset stack pointer: clear critical region mark */
-			regs->regs[15] = regs->regs[1];
-			if (regs->pc < regs->regs[0])
-				/* Go to rewind point */
-				regs->pc = regs->regs[0] + offset;
-		}
-		preempt_enable_no_resched();
-	}
-#endif
-
 #ifdef CONFIG_MMU
 	/*
 	 * Restore the kernel mode register
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/ptrace.c linux-2.6.23.1-stm/arch/sh/kernel/ptrace.c
--- linux-2.6.23.1/arch/sh/kernel/ptrace.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/ptrace.c	2007-11-01 12:00:39.000000000 +0000
@@ -24,6 +24,7 @@
 #include <asm/system.h>
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
+#include <asm/cacheflush.h>
 
 /*
  * does not yet catch signals sent when the child dies.
@@ -92,7 +93,12 @@
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
 	case PTRACE_PEEKDATA:
+		/* this is a somewhat over-zealous approach to solving
+		 * access_process_vm's dcache aliasing issues.
+		 */
+		flush_cache_all();
 		ret = generic_ptrace_peekdata(child, addr, data);
+		flush_cache_all();
 		break;
 
 	/* read the word at location addr in the USER area. */
@@ -127,7 +133,12 @@
 	/* when I and D space are separate, this will have to be fixed. */
 	case PTRACE_POKETEXT: /* write the word at location addr. */
 	case PTRACE_POKEDATA:
+		/* this is a somewhat over-zealous approach to solving
+		 * access_process_vm's dcache aliasing issues.
+		 */
+		flush_cache_all();
 		ret = generic_ptrace_pokedata(child, addr, data);
+		flush_cache_all();
 		break;
 
 	case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/setup.c linux-2.6.23.1-stm/arch/sh/kernel/setup.c
--- linux-2.6.23.1/arch/sh/kernel/setup.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/setup.c	2007-11-01 12:00:43.000000000 +0000
@@ -83,8 +83,18 @@
 
 static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
 
-static struct resource code_resource = { .name = "Kernel code", };
-static struct resource data_resource = { .name = "Kernel data", };
+static struct resource ram_resource = {
+	.name	= "System RAM",
+	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,
+};
+static struct resource code_resource = {
+	.name	= "Kernel code",
+	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,
+};
+static struct resource data_resource = {
+	.name	= "Kernel data",
+	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,
+};
 
 unsigned long memory_start;
 EXPORT_SYMBOL(memory_start);
@@ -96,7 +106,11 @@
 {
 	unsigned long size;
 
+#ifdef CONFIG_32BIT
+	memory_start = (unsigned long)PAGE_OFFSET;
+#else
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+#endif
 	size = memparse(p, &p);
 	memory_end = memory_start + size;
 
@@ -146,8 +160,8 @@
 	node_set_online(0);
 
 	/*
-	 * Reserve the kernel text and
-	 * Reserve the bootmem bitmap. We do this in two steps (first step
+	 * Reserve the kernel text and the bootmem bitmap.
+	 * We do this in two steps (first step
 	 * was init_bootmem()), because this catches the (definitely buggy)
 	 * case of us accidentally initializing the bootmem allocator with
 	 * an invalid RAM area.
@@ -164,21 +178,20 @@
 	sparse_memory_present_with_active_regions(0);
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
 	if (&__rd_start != &__rd_end) {
-		LOADER_TYPE = 1;
-		INITRD_START = PHYSADDR((unsigned long)&__rd_start) -
-					__MEMORY_START;
-		INITRD_SIZE = (unsigned long)&__rd_end -
-			      (unsigned long)&__rd_start;
-	}
+		initrd_start = (unsigned long)&__rd_start;
+		initrd_end = (unsigned long)&__rd_end;
+	} else if (LOADER_TYPE && INITRD_START) {
+		/* INITRD_START is the offset from the start of RAM */
+
+		unsigned long initrd_start_phys = INITRD_START;
+#ifndef CONFIG_32BIT
+		initrd_start_phys += __MEMORY_START;
+#endif
 
-	if (LOADER_TYPE && INITRD_START) {
-		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
-			reserve_bootmem(INITRD_START + __MEMORY_START,
-					INITRD_SIZE);
-			initrd_start = INITRD_START + PAGE_OFFSET +
-					__MEMORY_START;
+		if (initrd_start_phys + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
+			reserve_bootmem(initrd_start_phys, INITRD_SIZE);
+			initrd_start = initrd_start_phys + PAGE_OFFSET;
 			initrd_end = initrd_start + INITRD_SIZE;
 		} else {
 			printk("initrd extends beyond end of memory "
@@ -212,6 +225,21 @@
 extern void __init setup_memory(void);
 #endif
 
+static int __init request_standard_resources(void)
+{
+	ram_resource.start = __pa(memory_start);
+	ram_resource.end = __pa(memory_end)-1;
+	code_resource.start = virt_to_phys(_text);
+	code_resource.end = virt_to_phys(_etext)-1;
+	data_resource.start = virt_to_phys(_etext);
+	data_resource.end = virt_to_phys(_edata)-1;
+
+	request_resource(&iomem_resource, &ram_resource);
+	request_resource(&ram_resource, &code_resource);
+	request_resource(&ram_resource, &data_resource);
+	return 0;
+}
+
 void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();
@@ -231,13 +259,13 @@
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = (unsigned long) _end;
 
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
-	data_resource.end = virt_to_phys(_edata)-1;
-
+#ifdef CONFIG_32BIT
+	memory_start = (unsigned long)PAGE_OFFSET;
+#else
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+#endif
 	memory_end = memory_start + __MEMORY_SIZE;
+	request_standard_resources();
 
 #ifdef CONFIG_CMDLINE_BOOL
 	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));
@@ -269,17 +297,20 @@
 	/* Setup bootmem with available RAM */
 	setup_memory();
 	sparse_init();
+#ifdef CONFIG_32BIT
+	pmb_init();
+#endif
 
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
 #endif
 
+	paging_init();
+
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);
 
-	paging_init();
-
 #ifdef CONFIG_SMP
 	plat_smp_setup();
 #endif
@@ -296,6 +327,7 @@
 	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",
 	[CPU_SH7760]	= "SH7760",
 	[CPU_ST40RA]	= "ST40RA",	[CPU_ST40GX1]	= "ST40GX1",
+	[CPU_STB7100]	= "STb710x",	[CPU_STX7200]	= "STx7200",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/sh_ksyms.c linux-2.6.23.1-stm/arch/sh/kernel/sh_ksyms.c
--- linux-2.6.23.1/arch/sh/kernel/sh_ksyms.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/sh_ksyms.c	2007-11-01 12:00:41.000000000 +0000
@@ -124,6 +124,8 @@
 #else /* GCC 3.x */
 DECLARE_EXPORT(__movstr_i4_even);
 DECLARE_EXPORT(__movstr_i4_odd);
+DECLARE_EXPORT(__movmem_i4_even); /* movstr became movmem in gcc-4.1 */
+DECLARE_EXPORT(__movmem_i4_odd);
 DECLARE_EXPORT(__movstrSI12_i4);
 #endif /* __GNUC__ == 4 */
 #endif
@@ -133,13 +135,17 @@
 /* needed by some modules */
 EXPORT_SYMBOL(flush_cache_all);
 EXPORT_SYMBOL(flush_cache_range);
+EXPORT_SYMBOL(flush_cache_page);
 EXPORT_SYMBOL(flush_dcache_page);
+EXPORT_SYMBOL(__flush_wback_region);
 EXPORT_SYMBOL(__flush_purge_region);
+EXPORT_SYMBOL(__flush_invalidate_region);
 #endif
 
 #if !defined(CONFIG_CACHE_OFF) && defined(CONFIG_MMU) && \
 	(defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB))
 EXPORT_SYMBOL(clear_user_page);
+EXPORT_SYMBOL(copy_user_page);
 #endif
 
 EXPORT_SYMBOL(csum_partial);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/signal.c linux-2.6.23.1-stm/arch/sh/kernel/signal.c
--- linux-2.6.23.1/arch/sh/kernel/signal.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/signal.c	2007-11-01 12:00:42.000000000 +0000
@@ -33,6 +33,16 @@
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
 /*
+ * The following define adds a 64 byte gap between the signal
+ * stack frame and previous contents of the stack.  This allows
+ * frame unwinding in a function epilogue but only if a frame
+ * pointer is used in the function.  This is necessary because
+ * current gcc compilers (<4.3) do not generate unwind info on
+ * SH for function epilogues.
+ */
+#define UNWINDGUARD 64
+
+/*
  * Atomically swap in the new signal mask, and wait for a signal.
  */
 asmlinkage int
@@ -316,7 +326,7 @@
 			sp = current->sas_ss_sp + current->sas_ss_size;
 	}
 
-	return (void __user *)((sp - frame_size) & -8ul);
+	return (void __user *)((sp - (frame_size+UNWINDGUARD)) & -8ul);
 }
 
 /* These symbols are defined with the addresses in the vsyscall page.
@@ -507,24 +517,6 @@
 						ctrl_inw(regs->pc - 4));
 				break;
 		}
-#ifdef CONFIG_GUSA
-	} else {
-		/* gUSA handling */
-		preempt_disable();
-
-		if (regs->regs[15] >= 0xc0000000) {
-			int offset = (int)regs->regs[15];
-
-			/* Reset stack pointer: clear critical region mark */
-			regs->regs[15] = regs->regs[1];
-			if (regs->pc < regs->regs[0])
-				/* Go to rewind point #1 */
-				regs->pc = regs->regs[0] + offset -
-					instruction_size(ctrl_inw(regs->pc-4));
-		}
-
-		preempt_enable_no_resched();
-#endif
 	}
 
 	/* Set up the stack frame */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/sys_sh.c linux-2.6.23.1-stm/arch/sh/kernel/sys_sh.c
--- linux-2.6.23.1/arch/sh/kernel/sys_sh.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/kernel/sys_sh.c	2007-11-01 12:00:40.000000000 +0000
@@ -26,6 +26,7 @@
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 #include <asm/unistd.h>
+#include <asm/cachectl.h>
 
 /*
  * sys_pipe() is the normal C calling standard for creating
@@ -279,6 +280,52 @@
 	return -EINVAL;
 }
 
+/* sys_cacheflush -- flush (part of) the processor cache.  */
+asmlinkage int
+sys_cacheflush (unsigned long addr, unsigned long len, int op)
+{
+	struct vm_area_struct *vma;
+
+	if ((op < 0) || (op > (CACHEFLUSH_D_PURGE|CACHEFLUSH_I)))
+		return -EINVAL;
+
+	/*
+	 * Verify that the specified address region actually belongs
+	 * to this process.
+	 */
+	if (addr + len < addr)
+		return -EFAULT;
+
+	down_read(&current->mm->mmap_sem);
+	vma = find_vma (current->mm, addr);
+	if (vma == NULL || addr < vma->vm_start || addr + len > vma->vm_end) {
+		up_read(&current->mm->mmap_sem);
+		return -EFAULT;
+	}
+
+#if !defined(CONFIG_SH_CACHE_DISABLE)
+
+	switch (op & CACHEFLUSH_D_PURGE) {
+		case CACHEFLUSH_D_INVAL:
+			__flush_invalidate_region((void*)addr, len);
+			break;
+		case CACHEFLUSH_D_WB:
+			__flush_wback_region((void*)addr, len);
+			break;
+		case CACHEFLUSH_D_PURGE:
+			__flush_purge_region((void*)addr, len);
+			break;
+	}
+	if (op & CACHEFLUSH_I) {
+		flush_cache_all();
+	}
+
+#endif
+
+	up_read(&current->mm->mmap_sem);
+	return 0;
+}
+
 asmlinkage int sys_uname(struct old_utsname * name)
 {
 	int err;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/syscalls.S linux-2.6.23.1-stm/arch/sh/kernel/syscalls.S
--- linux-2.6.23.1/arch/sh/kernel/syscalls.S	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/syscalls.S	2007-11-01 12:00:40.000000000 +0000
@@ -139,7 +139,7 @@
 	.long sys_clone		/* 120 */
 	.long sys_setdomainname
 	.long sys_newuname
-	.long sys_ni_syscall	/* sys_modify_ldt */
+	.long sys_cacheflush	/* x86: sys_modify_ldt */
 	.long sys_adjtimex
 	.long sys_mprotect		/* 125 */
 	.long sys_sigprocmask
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/traps.c linux-2.6.23.1-stm/arch/sh/kernel/traps.c
--- linux-2.6.23.1/arch/sh/kernel/traps.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/traps.c	2007-11-01 12:00:42.000000000 +0000
@@ -152,13 +152,17 @@
  * desired behaviour
  * - note that PC _may not_ point to the faulting instruction
  *   (if that instruction is in a branch delay slot)
- * - return 0 if emulation okay, -EFAULT on existential error
+ * - return:
+ *   0 if emulation okay (PC unchanged)
+ *   1 if emulation OK (PC already updated)
+ *   -EFAULT on existential error
  */
 static int handle_unaligned_ins(u16 instruction, struct pt_regs *regs)
 {
 	int ret, index, count;
 	unsigned long *rm, *rn;
 	unsigned char *src, *dst;
+	const struct exception_table_entry *fixup;
 
 	index = (instruction>>8)&15;	/* 0x0F00 */
 	rn = &regs->regs[index];
@@ -325,7 +329,10 @@
 	/* Argh. Address not only misaligned but also non-existent.
 	 * Raise an EFAULT and see if it's trapped
 	 */
-	return die_if_no_fixup("Fault in unaligned fixup", regs, 0);
+	ret = die_if_no_fixup("Fault in unaligned fixup", regs, 0);
+	if (ret == 0)
+		ret = 1;
+	return ret;
 }
 
 /*
@@ -573,7 +580,7 @@
 		tmp = handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 
-		if (tmp==0)
+		if (tmp>=0)
 			return; /* sorted */
 #endif
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/kernel/vmlinux.lds.S linux-2.6.23.1-stm/arch/sh/kernel/vmlinux.lds.S
--- linux-2.6.23.1/arch/sh/kernel/vmlinux.lds.S	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/kernel/vmlinux.lds.S	2007-11-01 12:00:43.000000000 +0000
@@ -15,7 +15,11 @@
 ENTRY(_start)
 SECTIONS
 {
+#ifdef CONFIG_32BIT
+  . = CONFIG_PAGE_OFFSET + CONFIG_ZERO_PAGE_OFFSET;
+#else
   . = CONFIG_PAGE_OFFSET + CONFIG_MEMORY_START + CONFIG_ZERO_PAGE_OFFSET;
+#endif
   _text = .;			/* Text and read-only data */
   text = .;			/* Text and read-only data */
   .empty_zero_page : {
@@ -41,6 +45,13 @@
 
   BUG_TABLE
 
+  . = ALIGN(PAGE_SIZE);
+  /* Code which muct be executed uncached AND the associated data */
+  _start_uncached = .;
+  .uncached.text : { *(.uncached) }
+  .uncached.data : { *(.uncached.data) }
+  _end_uncached = .;
+
   .data : {			/* Data */
 	DATA_DATA
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/lib/delay.c linux-2.6.23.1-stm/arch/sh/lib/delay.c
--- linux-2.6.23.1/arch/sh/lib/delay.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/lib/delay.c	2007-11-01 12:00:40.000000000 +0000
@@ -21,13 +21,14 @@
 
 inline void __const_udelay(unsigned long xloops)
 {
+	xloops *= 4;
 	__asm__("dmulu.l	%0, %2\n\t"
 		"sts	mach, %0"
 		: "=r" (xloops)
 		: "0" (xloops),
-		  "r" (HZ * cpu_data[raw_smp_processor_id()].loops_per_jiffy)
+		  "r" (cpu_data[raw_smp_processor_id()].loops_per_jiffy * (HZ/4))
 		: "macl", "mach");
-	__delay(xloops);
+	__delay(++xloops);
 }
 
 void __udelay(unsigned long usecs)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/Kconfig linux-2.6.23.1-stm/arch/sh/mm/Kconfig
--- linux-2.6.23.1/arch/sh/mm/Kconfig	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/mm/Kconfig	2007-11-01 12:00:43.000000000 +0000
@@ -167,6 +167,20 @@
 	help
 	  Select ST40GX1 if you have a ST40GX1 CPU.
 
+config CPU_SUBTYPE_STB7100
+	bool "Support STb710x processors"
+	select CPU_SUBTYPE_ST40
+	select SUPPORTS_32BIT
+	help
+	  Select STB7100 if you have an STb7100 or STb7109 CPU.
+
+config CPU_SUBTYPE_STX7200
+	bool "Support STx7200 processor"
+	select CPU_SUBTYPE_ST40
+	select SUPPORTS_32BIT
+	help
+	  Select STx7200 if you have an STx7200 CPU.
+
 # SH-4A Processor Support
 
 config CPU_SUBTYPE_SH7770
@@ -176,6 +190,7 @@
 config CPU_SUBTYPE_SH7780
 	bool "Support SH7780 processor"
 	select CPU_SH4A
+	select SUPPORTS_32BIT
 
 config CPU_SUBTYPE_SH7785
 	bool "Support SH7785 processor"
@@ -183,6 +198,7 @@
 	select CPU_SHX2
 	select ARCH_SPARSEMEM_ENABLE
 	select SYS_SUPPORTS_NUMA
+	select SUPPORTS_32BIT
 
 config CPU_SUBTYPE_SHX3
 	bool "Support SH-X3 processor"
@@ -255,9 +271,13 @@
 	  as 0x00400000 which was the default value before this became
 	  configurable.
 
+config SUPPORTS_32BIT
+	bool
+	default n
+
 config 32BIT
 	bool "Support 32-bit physical addressing through PMB"
-	depends on MMU && (CPU_SUBTYPE_SH7780 || CPU_SUBTYPE_SH7785)
+	depends on MMU && SUPPORTS_32BIT
 	default y
 	help
 	  If you say Y here, physical addressing will be extended to
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/cache-debugfs.c linux-2.6.23.1-stm/arch/sh/mm/cache-debugfs.c
--- linux-2.6.23.1/arch/sh/mm/cache-debugfs.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/cache-debugfs.c	2007-11-01 12:00:43.000000000 +0000
@@ -22,7 +22,7 @@
 	CACHE_TYPE_UNIFIED,
 };
 
-static int cache_seq_show(struct seq_file *file, void *iter)
+static int __uses_jump_to_uncached cache_seq_show(struct seq_file *file, void *iter)
 {
 	unsigned int cache_type = (unsigned int)file->private;
 	struct cache_info *cache;
@@ -34,11 +34,11 @@
 	 * Go uncached immediately so we don't skew the results any
 	 * more than we already are..
 	 */
-	jump_to_P2();
+	jump_to_uncached();
 
 	ccr = ctrl_inl(CCR);
 	if ((ccr & CCR_CACHE_ENABLE) == 0) {
-		back_to_P1();
+		back_to_cached();
 
 		seq_printf(file, "disabled\n");
 		return 0;
@@ -104,7 +104,7 @@
 		addrstart += cache->way_incr;
 	}
 
-	back_to_P1();
+	back_to_cached();
 
 	return 0;
 }
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/cache-sh4.c linux-2.6.23.1-stm/arch/sh/mm/cache-sh4.c
--- linux-2.6.23.1/arch/sh/mm/cache-sh4.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/mm/cache-sh4.c	2007-11-01 12:00:43.000000000 +0000
@@ -13,6 +13,7 @@
 #include <linux/mm.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/fs.h>
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 
@@ -29,17 +30,10 @@
 					unsigned long extent);
 static void __flush_dcache_segment_4way(unsigned long start,
 					unsigned long extent);
+static void (*__flush_dcache_segment_fn)(unsigned long, unsigned long);
 
-static void __flush_cache_4096(unsigned long addr, unsigned long phys,
-			       unsigned long exec_offset);
-
-/*
- * This is initialised here to ensure that it is not placed in the BSS.  If
- * that were to happen, note that cache_init gets called before the BSS is
- * cleared, so this would get nulled out which would be hopeless.
- */
-static void (*__flush_dcache_segment_fn)(unsigned long, unsigned long) =
-	(void (*)(unsigned long, unsigned long))0xdeadbeef;
+static void __flush_cache_4096(unsigned long addr, unsigned long kaddr);
+static void (*__flush_cache_4096_uncached)(unsigned long addr, unsigned long kaddr);
 
 static void compute_alias(struct cache_info *c)
 {
@@ -113,6 +107,16 @@
 	}
 
 	emit_cache_params();
+
+	if (ioremap_page_range(P3SEG, P3SEG+(PAGE_SIZE * 4), 0, PAGE_KERNEL))
+		panic("%s failed.", __FUNCTION__);
+
+	/*
+	 * Pre-calculate the address of the uncached version of
+	 * __flush_cache_4096 so we can call it directly.
+	 */
+	__flush_cache_4096_uncached =
+		&__flush_cache_4096 + cached_to_uncached;
 }
 
 /*
@@ -190,7 +194,7 @@
  * .. which happens to be the same behavior as flush_icache_range().
  * So, we simply flush out a line.
  */
-void flush_cache_sigtramp(unsigned long addr)
+void __uses_jump_to_uncached flush_cache_sigtramp(unsigned long addr)
 {
 	unsigned long v, index;
 	unsigned long flags;
@@ -205,63 +209,79 @@
 			(v & boot_cpu_data.icache.entry_mask);
 
 	local_irq_save(flags);
-	jump_to_P2();
+	jump_to_uncached();
 
 	for (i = 0; i < boot_cpu_data.icache.ways;
 	     i++, index += boot_cpu_data.icache.way_incr)
 		ctrl_outl(0, index);	/* Clear out Valid-bit */
 
-	back_to_P1();
+	back_to_cached();
 	wmb();
 	local_irq_restore(flags);
 }
 
 static inline void flush_cache_4096(unsigned long start,
-				    unsigned long phys)
+				    unsigned long kaddr)
 {
-	unsigned long flags, exec_offset = 0;
+	unsigned long flags;
+	void (*fc4096)(unsigned long start, unsigned long kaddr);
 
 	/*
-	 * All types of SH-4 require PC to be in P2 to operate on the I-cache.
-	 * Some types of SH-4 require PC to be in P2 to operate on the D-cache.
+	 * All types of SH-4 require PC to uncached to operate on the I-cache.
+	 * Some types of SH-4 require PC to be uncached to operate on the
+	 * D-cache.
 	 */
 	if ((boot_cpu_data.flags & CPU_HAS_P2_FLUSH_BUG) ||
 	    (start < CACHE_OC_ADDRESS_ARRAY))
-		exec_offset = 0x20000000;
+		fc4096 = __flush_cache_4096_uncached;
+	else
+		fc4096 = __flush_cache_4096;
 
 	local_irq_save(flags);
-	__flush_cache_4096(start | SH_CACHE_ASSOC,
-			   P1SEGADDR(phys), exec_offset);
+	fc4096(start | SH_CACHE_ASSOC, kaddr);
 	local_irq_restore(flags);
 }
 
 /*
+ * Called just before the kernel reads a page cache page, or has written
+ * to a page cache page, which may have been mapped into user space.
  * Write back & invalidate the D-cache of the page.
  * (To avoid "alias" issues)
  */
 void flush_dcache_page(struct page *page)
 {
-	if (test_bit(PG_mapped, &page->flags)) {
-		unsigned long phys = PHYSADDR(page_address(page));
+	struct address_space *mapping = page_mapping(page);
+
+	if ((mapping != NULL) && (! mapping_mapped(mapping))) {
+		/* There are no user mappings for this page, so we can
+		 * defer the flush. */
+		__set_bit(PG_dcache_dirty, &page->flags);
+	} else {
+		/* page->mapping is NULL for argv/env pages, which
+		 * must be flushed here (there is no call to
+		 * update_mmu_cache in this case). Or there is a user
+		 * mapping for this page, so we flush. */
+
+		unsigned long kaddr = (unsigned long)page_address(page);
 		unsigned long addr = CACHE_OC_ADDRESS_ARRAY;
 		int i, n;
 
 		/* Loop all the D-cache */
 		n = boot_cpu_data.dcache.n_aliases;
 		for (i = 0; i < n; i++, addr += 4096)
-			flush_cache_4096(addr, phys);
+			flush_cache_4096(addr, kaddr);
 	}
 
 	wmb();
 }
 
 /* TODO: Selective icache invalidation through IC address array.. */
-static inline void flush_icache_all(void)
+static void __uses_jump_to_uncached flush_icache_all(void)
 {
 	unsigned long flags, ccr;
 
 	local_irq_save(flags);
-	jump_to_P2();
+	jump_to_uncached();
 
 	/* Flush I-cache */
 	ccr = ctrl_inl(CCR);
@@ -269,11 +289,11 @@
 	ctrl_outl(ccr, CCR);
 
 	/*
-	 * back_to_P1() will take care of the barrier for us, don't add
+	 * back_to_cached() will take care of the barrier for us, don't add
 	 * another one!
 	 */
 
-	back_to_P1();
+	back_to_cached();
 	local_irq_restore(flags);
 }
 
@@ -377,6 +397,9 @@
  */
 void flush_cache_mm(struct mm_struct *mm)
 {
+#if 1
+flush_cache_all();
+#else
 	/*
 	 * If cache is only 4k-per-way, there are never any 'aliases'.  Since
 	 * the cache is physically tagged, the data can just be left in there.
@@ -404,6 +427,7 @@
 	/* Only touch the icache if one of the VMAs has VM_EXEC set. */
 	if (mm->exec_vm)
 		flush_icache_all();
+#endif
 }
 
 /*
@@ -415,21 +439,21 @@
 void flush_cache_page(struct vm_area_struct *vma, unsigned long address,
 		      unsigned long pfn)
 {
-	unsigned long phys = pfn << PAGE_SHIFT;
+	unsigned long kaddr = (unsigned long)pfn_to_kaddr(pfn);
 	unsigned int alias_mask;
 
 	alias_mask = boot_cpu_data.dcache.alias_mask;
 
 	/* We only need to flush D-cache when we have alias */
-	if ((address^phys) & alias_mask) {
+	if ((address^kaddr) & alias_mask) {
 		/* Loop 4K of the D-cache */
 		flush_cache_4096(
 			CACHE_OC_ADDRESS_ARRAY | (address & alias_mask),
-			phys);
+			kaddr);
 		/* Loop another 4K of the D-cache */
 		flush_cache_4096(
-			CACHE_OC_ADDRESS_ARRAY | (phys & alias_mask),
-			phys);
+			CACHE_OC_ADDRESS_ARRAY | (kaddr & alias_mask),
+			kaddr);
 	}
 
 	alias_mask = boot_cpu_data.icache.alias_mask;
@@ -444,7 +468,7 @@
 		 */
 		flush_cache_4096(
 			CACHE_IC_ADDRESS_ARRAY | (address & alias_mask),
-			phys);
+			kaddr);
 	}
 }
 
@@ -507,23 +531,20 @@
  * @addr:  address in memory mapped cache array
  * @phys:  P1 address to flush (has to match tags if addr has 'A' bit
  *         set i.e. associative write)
- * @exec_offset: set to 0x20000000 if flush has to be executed from P2
- *               region else 0x0
  *
  * The offset into the cache array implied by 'addr' selects the
  * 'colour' of the virtual address range that will be flushed.  The
  * operation (purge/write-back) is selected by the lower 2 bits of
  * 'phys'.
  */
-static void __flush_cache_4096(unsigned long addr, unsigned long phys,
-			       unsigned long exec_offset)
+static void __uses_jump_to_uncached
+__flush_cache_4096(unsigned long addr, unsigned long kaddr)
 {
 	int way_count;
 	unsigned long base_addr = addr;
 	struct cache_info *dcache;
 	unsigned long way_incr;
 	unsigned long a, ea, p;
-	unsigned long temp_pc;
 
 	dcache = &boot_cpu_data.dcache;
 	/* Write this way for better assembly. */
@@ -531,30 +552,13 @@
 	way_incr = dcache->way_incr;
 
 	/*
-	 * Apply exec_offset (i.e. branch to P2 if required.).
-	 *
-	 * FIXME:
-	 *
-	 *	If I write "=r" for the (temp_pc), it puts this in r6 hence
-	 *	trashing exec_offset before it's been added on - why?  Hence
-	 *	"=&r" as a 'workaround'
-	 */
-	asm volatile("mov.l 1f, %0\n\t"
-		     "add   %1, %0\n\t"
-		     "jmp   @%0\n\t"
-		     "nop\n\t"
-		     ".balign 4\n\t"
-		     "1:  .long 2f\n\t"
-		     "2:\n" : "=&r" (temp_pc) : "r" (exec_offset));
-
-	/*
 	 * We know there will be >=1 iteration, so write as do-while to avoid
 	 * pointless nead-of-loop check for 0 iterations.
 	 */
 	do {
 		ea = base_addr + PAGE_SIZE;
 		a = base_addr;
-		p = phys;
+		p = kaddr;
 
 		do {
 			*(volatile unsigned long *)a = p;
@@ -576,6 +580,31 @@
  * Break the 1, 2 and 4 way variants of this out into separate functions to
  * avoid nearly all the overhead of having the conditional stuff in the function
  * bodies (+ the 1 and 2 way cases avoid saving any registers too).
+ *
+ * We want to eliminate unnecessary bus transactions, so this code uses
+ * a non-obvious technique.
+ *
+ * Loop over a cache way sized block of, one cache line at a time. For each
+ * line, use movca.a to cause the current cache line contents to be written
+ * back, but without reading anything from main memory. However this has the
+ * side effect that the cache is now caching that memory location. So follow
+ * this with a cache invalidate to mark the cache line invalid. And do all
+ * this with interrupts disabled, to avoid the cache line being accidently
+ * evicted while it is holding garbage.
+ *
+ * This also breaks in a number of circumstances:
+ * - if there are modifications to the region of memory just above
+ *   empty_zero_page (for example because a breakpoint has been placed
+ *   there), then these can be lost.
+ *
+ *   This is because the the memory address which the cache temporarily
+ *   caches in the above description is empty_zero_page. So the
+ *   movca.l hits the cache (it is assumed that it misses, or at least
+ *   isn't dirty), modifies the line and then invalidates it, losing the
+ *   required change.
+ *
+ * - If caches are disabled or configured in write back mode, then
+ *   the movca.l writes garbage directly into memory.
  */
 static void __flush_dcache_segment_1way(unsigned long start,
 					unsigned long extent_per_way)
@@ -625,6 +654,25 @@
 	} while (a0 < a0e);
 }
 
+#ifdef CONFIG_SH_WRITETHROUGH
+/* This method of cache flushing avoids the problems discussed
+ * in the comment above if writethrough caches are enabled. */
+static void __flush_dcache_segment_2way(unsigned long start,
+					unsigned long extent_per_way)
+{
+	unsigned long array_addr;
+
+	array_addr = CACHE_OC_ADDRESS_ARRAY |
+		(start & cpu_data->dcache.entry_mask);
+
+	while (extent_per_way) {
+		ctrl_outl(0, array_addr);
+		ctrl_outl(0, array_addr + cpu_data->dcache.way_incr);
+		array_addr += cpu_data->dcache.linesz;
+		extent_per_way -= cpu_data->dcache.linesz;
+	}
+}
+#else
 static void __flush_dcache_segment_2way(unsigned long start,
 					unsigned long extent_per_way)
 {
@@ -683,6 +731,7 @@
 		a1 += linesz;
 	} while (a0 < a0e);
 }
+#endif
 
 static void __flush_dcache_segment_4way(unsigned long start,
 					unsigned long extent_per_way)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/cache-sh7705.c linux-2.6.23.1-stm/arch/sh/mm/cache-sh7705.c
--- linux-2.6.23.1/arch/sh/mm/cache-sh7705.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/cache-sh7705.c	2007-11-01 12:00:43.000000000 +0000
@@ -71,7 +71,7 @@
 /*
  * Writeback&Invalidate the D-cache of the page
  */
-static void __flush_dcache_page(unsigned long phys)
+static void __uses_jump_to_uncached __flush_dcache_page(unsigned long phys)
 {
 	unsigned long ways, waysize, addrstart;
 	unsigned long flags;
@@ -92,7 +92,7 @@
 	 * possible.
 	 */
 	local_irq_save(flags);
-	jump_to_P2();
+	jump_to_uncached();
 
 	ways = current_cpu_data.dcache.ways;
 	waysize = current_cpu_data.dcache.sets;
@@ -118,7 +118,7 @@
 		addrstart += current_cpu_data.dcache.way_incr;
 	} while (--ways);
 
-	back_to_P1();
+	back_to_cached();
 	local_irq_restore(flags);
 }
 
@@ -132,15 +132,15 @@
 		__flush_dcache_page(PHYSADDR(page_address(page)));
 }
 
-void flush_cache_all(void)
+void __uses_jump_to_uncached flush_cache_all(void)
 {
 	unsigned long flags;
 
 	local_irq_save(flags);
-	jump_to_P2();
+	jump_to_uncached();
 
 	cache_wback_all();
-	back_to_P1();
+	back_to_cached();
 	local_irq_restore(flags);
 }
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/clear_page.S linux-2.6.23.1-stm/arch/sh/mm/clear_page.S
--- linux-2.6.23.1/arch/sh/mm/clear_page.S	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/clear_page.S	2007-11-01 12:00:43.000000000 +0000
@@ -50,8 +50,57 @@
 	!
 	rts
 	 nop
+
+	.balign	4
 .Llimit:	.long	(PAGE_SIZE-28)
 
+#if defined(CONFIG_CPU_SH4)
+/*
+ * __clear_page_wb
+ * @to: P1 address
+ *
+ * void __clear_page_wb(void *to)
+ */
+
+/*
+ * r0 --- zero
+ * r3 --- scratch
+ * r4 --- to
+ * r5 --- current pointer
+ */
+ENTRY(__clear_page_wb)
+	mov	#0x10, r5		!   6 EX
+	mov	r4, r3			!   5 MT (latency=0)
+
+	shll8	r5			! 102 EX
+	add	#-4, r3			!  50 EX
+	add	r5, r3			!  49 EX
+	mov	#0, r0			!   6 EX
+
+1:
+	movca.l	r0, @r3			!  40 LS (latency=3-7)
+	mov	r3, r5			!   5 MT (latency=0)
+
+	mov.l	r0,@-r5			!  30 LS
+	add	#-32, r3		!  50 EX
+
+	mov.l	r0,@-r5			!  30 LS
+	mov.l	r0,@-r5			!  30 LS
+	mov.l	r0,@-r5			!  30 LS
+	mov.l	r0,@-r5			!  30 LS
+
+	mov.l	r0,@-r5			!  30 LS
+	cmp/hi	r4, r3			!  57 MT
+
+	mov.l	r0,@-r5			!  30 LS
+	bt/s	1b			! 111 BR
+
+	 ocbwb	@r5			!  44 LS (latency=1-5)
+
+ 	rts
+ 	 nop
+#endif
+
 ENTRY(__clear_user)
 	!
 	mov	#0, r0
@@ -154,7 +203,7 @@
 #if defined(CONFIG_CPU_SH4)
 /*
  * __clear_user_page
- * @to: P3 address (with same color)
+ * @to: P3 address (with same color as user page)
  * @orig_to: P1 address
  *
  * void __clear_user_page(void *to, void *orig_to)
@@ -191,6 +240,7 @@
 	!
 	rts
 	 nop
+	.balign	4
 .Lpsz:	.long	PAGE_SIZE
 
 #endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/consistent.c linux-2.6.23.1-stm/arch/sh/mm/consistent.c
--- linux-2.6.23.1/arch/sh/mm/consistent.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/consistent.c	2007-11-01 12:00:43.000000000 +0000
@@ -8,16 +8,27 @@
  * for more details.
  */
 #include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/io.h>
 #include <linux/dma-mapping.h>
 #include <asm/cacheflush.h>
 #include <asm/addrspace.h>
 #include <asm/io.h>
 
+
 void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *handle)
 {
-	struct page *page, *end, *free;
+	struct page *page, *end;
 	void *ret;
 	int order;
+	unsigned long phys_addr;
+	void* kernel_addr;
+#ifdef CONFIG_32BIT
+	struct vm_struct * area;
+#endif
+
+	/* ignore region specifiers */
+        gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
 
 	size = PAGE_ALIGN(size);
 	order = get_order(size);
@@ -25,56 +36,96 @@
 	page = alloc_pages(gfp, order);
 	if (!page)
 		return NULL;
-	split_page(page, order);
 
-	ret = page_address(page);
-	memset(ret, 0, size);
-	*handle = virt_to_phys(ret);
+	kernel_addr = page_address(page);
+	phys_addr = virt_to_phys(kernel_addr);
+
+#ifdef CONFIG_32BIT
+	area = get_vm_area(size, VM_IOREMAP);
+	if (!area) {
+		free_pages(gfp, order);
+		return NULL;
+	}
+
+	ret = area->addr;
+	if (ioremap_page_range(ret, ret+size, phys_addr, PAGE_KERNEL_NOCACHE)) {
+		free_pages(gfp, order);
+		remove_vm_area(ret);
+		return NULL;
+	}
+
+	area->phys_addr = virt_to_phys(ret);
+#else
+	ret = P2SEGADDR(kernel_addr);
+#endif
+
+	memset(kernel_addr, 0, size);
 
 	/*
 	 * We must flush the cache before we pass it on to the device
 	 */
-	dma_cache_wback_inv(ret, size);
-
-	page = virt_to_page(ret);
-	free = page + (size >> PAGE_SHIFT);
-	end  = page + (1 << order);
+	dma_cache_wback_inv(kernel_addr, size);
 
-	while (++page < end) {
-		/* Free any unused pages */
-		if (page >= free) {
-			__free_page(page);
-		}
+	/* Free the otherwise unused pages */
+	split_page(page, order);
+	end = page + (1 << order);
+	for (page += size >> PAGE_SHIFT; page < end; page++) {
+		__free_page(page);
 	}
 
-	return P2SEGADDR(ret);
+	*handle = phys_addr;
+	return ret;
 }
 
 void consistent_free(void *vaddr, size_t size)
 {
-	unsigned long addr = P1SEGADDR((unsigned long)vaddr);
-	struct page *page=virt_to_page(addr);
+	unsigned long addr;
+	struct page *page;
 	int num_pages=(size+PAGE_SIZE-1) >> PAGE_SHIFT;
 	int i;
 
+#ifdef CONFIG_32BIT
+	struct vm_struct * area;
+
+	read_lock(&vmlist_lock);
+	for (area = vmlist; area; area = area->next) {
+		if (area->addr == vaddr)
+			break;
+	}
+        read_unlock(&vmlist_lock);
+
+	if (!area) {
+		printk("%s: bad address %p\n", __FUNCTION__, vaddr);
+                dump_stack();
+                return;
+        }
+
+	addr = phys_to_virt(area->phys_addr);
+#else
+	addr = P1SEGADDR((unsigned long)vaddr);
+#endif
+
+	page = virt_to_page(addr);
+
 	for(i=0;i<num_pages;i++) {
 		__free_page((page+i));
 	}
+#ifdef CONFIG_32BIT
+	remove_vm_area(vaddr);
+#endif
 }
 
 void consistent_sync(void *vaddr, size_t size, int direction)
 {
-	void * p1addr = (void*) P1SEGADDR((unsigned long)vaddr);
-
 	switch (direction) {
 	case DMA_FROM_DEVICE:		/* invalidate only */
-		dma_cache_inv(p1addr, size);
+		dma_cache_inv(vaddr, size);
 		break;
 	case DMA_TO_DEVICE:		/* writeback only */
-		dma_cache_wback(p1addr, size);
+		dma_cache_wback(vaddr, size);
 		break;
 	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
-		dma_cache_wback_inv(p1addr, size);
+		dma_cache_wback_inv(vaddr, size);
 		break;
 	default:
 		BUG();
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/copy_page.S linux-2.6.23.1-stm/arch/sh/mm/copy_page.S
--- linux-2.6.23.1/arch/sh/mm/copy_page.S	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/mm/copy_page.S	2007-11-01 12:00:43.000000000 +0000
@@ -24,6 +24,7 @@
  * r11 --- from
  */
 ENTRY(copy_page_slow)
+ENTRY(__copy_page_wb)
 	mov.l	r8,@-r15
 	mov.l	r10,@-r15
 	mov.l	r11,@-r15
@@ -71,7 +72,7 @@
 #if defined(CONFIG_CPU_SH4)
 /*
  * __copy_user_page
- * @to: P1 address (with same color)
+ * @to: P1 address (with same color as user page)
  * @from: P1 address
  * @orig_to: P1 address
  *
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/fault.c linux-2.6.23.1-stm/arch/sh/mm/fault.c
--- linux-2.6.23.1/arch/sh/mm/fault.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/fault.c	2007-11-01 12:00:43.000000000 +0000
@@ -17,7 +17,6 @@
 #include <linux/kprobes.h>
 #include <asm/system.h>
 #include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
 #include <asm/kgdb.h>
 
 /*
@@ -234,89 +233,3 @@
 	if (!user_mode(regs))
 		goto no_context;
 }
-
-#ifdef CONFIG_SH_STORE_QUEUES
-/*
- * This is a special case for the SH-4 store queues, as pages for this
- * space still need to be faulted in before it's possible to flush the
- * store queue cache for writeout to the remapped region.
- */
-#define P3_ADDR_MAX		(P4SEG_STORE_QUE + 0x04000000)
-#else
-#define P3_ADDR_MAX		P4SEG
-#endif
-
-/*
- * Called with interrupts disabled.
- */
-asmlinkage int __kprobes __do_page_fault(struct pt_regs *regs,
-					 unsigned long writeaccess,
-					 unsigned long address)
-{
-	pgd_t *pgd;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte;
-	pte_t entry;
-	struct mm_struct *mm = current->mm;
-	spinlock_t *ptl = NULL;
-	int ret = 1;
-
-#ifdef CONFIG_SH_KGDB
-	if (kgdb_nofault && kgdb_bus_err_hook)
-		kgdb_bus_err_hook();
-#endif
-
-	/*
-	 * We don't take page faults for P1, P2, and parts of P4, these
-	 * are always mapped, whether it be due to legacy behaviour in
-	 * 29-bit mode, or due to PMB configuration in 32-bit mode.
-	 */
-	if (address >= P3SEG && address < P3_ADDR_MAX) {
-		pgd = pgd_offset_k(address);
-		mm = NULL;
-	} else {
-		if (unlikely(address >= TASK_SIZE || !mm))
-			return 1;
-
-		pgd = pgd_offset(mm, address);
-	}
-
-	pud = pud_offset(pgd, address);
-	if (pud_none_or_clear_bad(pud))
-		return 1;
-	pmd = pmd_offset(pud, address);
-	if (pmd_none_or_clear_bad(pmd))
-		return 1;
-
-	if (mm)
-		pte = pte_offset_map_lock(mm, pmd, address, &ptl);
-	else
-		pte = pte_offset_kernel(pmd, address);
-
-	entry = *pte;
-	if (unlikely(pte_none(entry) || pte_not_present(entry)))
-		goto unlock;
-	if (unlikely(writeaccess && !pte_write(entry)))
-		goto unlock;
-
-	if (writeaccess)
-		entry = pte_mkdirty(entry);
-	entry = pte_mkyoung(entry);
-
-#ifdef CONFIG_CPU_SH4
-	/*
-	 * ITLB is not affected by "ldtlb" instruction.
-	 * So, we need to flush the entry by ourselves.
-	 */
-	local_flush_tlb_one(get_asid(), address & PAGE_MASK);
-#endif
-
-	set_pte(pte, entry);
-	update_mmu_cache(NULL, address, entry);
-	ret = 0;
-unlock:
-	if (mm)
-		pte_unmap_unlock(pte, ptl);
-	return ret;
-}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/init.c linux-2.6.23.1-stm/arch/sh/mm/init.c
--- linux-2.6.23.1/arch/sh/mm/init.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/init.c	2007-11-01 12:00:43.000000000 +0000
@@ -27,6 +27,9 @@
 void (*copy_page)(void *from, void *to);
 void (*clear_page)(void *to);
 
+extern char _start_uncached, _end_uncached;
+unsigned long cached_to_uncached;
+
 void show_mem(void)
 {
 	int total = 0, reserved = 0, free = 0;
@@ -69,7 +72,7 @@
 }
 
 #ifdef CONFIG_MMU
-static void set_pte_phys(unsigned long addr, unsigned long phys, pgprot_t prot)
+void set_pte_phys(unsigned long addr, unsigned long phys, pgprot_t prot)
 {
 	pgd_t *pgd;
 	pud_t *pud;
@@ -102,6 +105,7 @@
 
 	set_pte(pte, pfn_pte(phys >> PAGE_SHIFT, prot));
 
+	if (cached_to_uncached)
 	flush_tlb_one(get_asid(), addr);
 }
 
@@ -131,6 +135,37 @@
 
 	set_pte_phys(address, phys, prot);
 }
+
+void __init page_table_range_init(unsigned long start, unsigned long end,
+					 pgd_t *pgd_base)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	int pgd_idx;
+	unsigned long vaddr;
+
+	vaddr = start & PMD_MASK;
+	end = (end + PMD_SIZE - 1) & PMD_MASK;
+	pgd_idx = pgd_index(vaddr);
+	pgd = pgd_base + pgd_idx;
+
+	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {
+		if (pgd_none(*pgd)) BUG();
+		pud = pud_offset(pgd, 0);
+		if (pud_none(*pud)) BUG();
+		pmd = pmd_offset(pud, 0);
+
+		if (!pmd_present(*pmd)) {
+			pte_t *pte_table;
+			pte_table = (pte_t *)alloc_bootmem_low_pages(PAGE_SIZE);
+			memset(pte_table, 0, PAGE_SIZE);
+			pmd_populate_kernel(&init_mm, pmd, pte_table);
+		}
+		vaddr += PMD_SIZE;
+	}
+}
+
 #endif	/* CONFIG_MMU */
 
 /*
@@ -150,6 +185,11 @@
 	 * check for a null value. */
 	set_TTB(swapper_pg_dir);
 
+	/* Populate the relevant portions of swapper_pg_dir so that
+	 * we can use the fixmap entries without calling kmalloc.
+	 * pte's will be filled in by __set_fixmap(). */
+	page_table_range_init(FIXADDR_START, FIXADDR_TOP, swapper_pg_dir);
+
 	memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
 
 	for_each_online_node(nid) {
@@ -167,6 +207,14 @@
 	}
 
 	free_area_init_nodes(max_zone_pfns);
+
+	set_fixmap_nocache(FIX_UNCACHED_CODE, __pa(&_start_uncached));
+#if 0
+	cached_to_uncached = fix_to_virt(FIX_UNCACHED_CODE) -
+		(unsigned long)&_start_uncached;
+#elif 0
+	cached_to_uncached = 0x38000000;
+#endif
 }
 
 static struct kcore_list kcore_mem, kcore_vmalloc;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/ioremap.c linux-2.6.23.1-stm/arch/sh/mm/ioremap.c
--- linux-2.6.23.1/arch/sh/mm/ioremap.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/ioremap.c	2007-11-01 12:00:46.000000000 +0000
@@ -26,19 +26,19 @@
 
 /*
  * Remap an arbitrary physical address space into the kernel virtual
- * address space. Needed when the kernel wants to access high addresses
- * directly.
+ * address space.
  *
  * NOTE! We need to allow non-page-aligned mappings too: we will obviously
  * have to convert them into an offset in a page-aligned mapping, but the
  * caller shouldn't need to know that small detail.
  */
-void __iomem *__ioremap(unsigned long phys_addr, unsigned long size,
-			unsigned long flags)
+void __iomem *__ioremap_prot(unsigned long phys_addr, unsigned long size,
+			     pgprot_t pgprot)
 {
-	struct vm_struct * area;
-	unsigned long offset, last_addr, addr, orig_addr;
-	pgprot_t pgprot;
+	unsigned long offset, last_addr, addr;
+	int simple = (pgprot_val(pgprot) == pgprot_val(PAGE_KERNEL)) ||
+		(pgprot_val(pgprot) == pgprot_val(PAGE_KERNEL_NOCACHE));
+	int cached = pgprot_val(pgprot) & _PAGE_CACHABLE;
 
 	/* Don't allow wraparound or zero size */
 	last_addr = phys_addr + size - 1;
@@ -46,24 +46,45 @@
 		return NULL;
 
 	/*
-	 * If we're on an SH7751 or SH7780 PCI controller, PCI memory is
-	 * mapped at the end of the address space (typically 0xfd000000)
-	 * in a non-translatable area, so mapping through page tables for
-	 * this area is not only pointless, but also fundamentally
-	 * broken. Just return the physical address instead.
-	 *
-	 * For boards that map a small PCI memory aperture somewhere in
-	 * P1/P2 space, ioremap() will already do the right thing,
-	 * and we'll never get this far.
+	 * Don't allow anybody to remap normal RAM that we're using..
 	 */
-	if (is_pci_memaddr(phys_addr) && is_pci_memaddr(last_addr))
-		return (void __iomem *)phys_addr;
+	if ((phys_addr >= __pa(memory_start)) && (last_addr < __pa(memory_end))) {
+		char *t_addr, *t_end;
+		struct page *page;
+
+		t_addr = __va(phys_addr);
+		t_end = t_addr + (size - 1);
+
+		for(page = virt_to_page(t_addr); page <= virt_to_page(t_end); page++)
+			if(!PageReserved(page))
+				return NULL;
+	}
 
+#ifndef CONFIG_32BIT
 	/*
-	 * Don't allow anybody to remap normal RAM that we're using..
+	 * For physical mappings <29 bits, with simple cached or uncached
+	 * protections, this is trivial, as everything is already mapped
+	 * through P1 and P2.
 	 */
-	if (phys_addr < virt_to_phys(high_memory))
-		return NULL;
+	if (likely(IS_29BIT(phys_addr) && simple)) {
+		if (cached)
+			return (void __iomem *)P1SEGADDR(phys_addr);
+
+		return (void __iomem *)P2SEGADDR(phys_addr);
+	}
+#endif
+
+	/* Similarly, P4 uncached addresses are permanently mapped */
+	if ((PXSEG(phys_addr) == P4SEG) && simple && !cached)
+		return (void __iomem *)phys_addr;
+
+#ifndef CONFIG_32BIT
+	/* Prevent mapping P1/2 addresses, to improve portability */
+	if (unlikely(!IS_29BIT(phys_addr)))
+		return (void __iomem *)0;
+#endif
+
+	/* Simple mapping failed, so use the PMB or TLB */
 
 	/*
 	 * Mappings have to be page-aligned
@@ -72,54 +93,58 @@
 	phys_addr &= PAGE_MASK;
 	size = PAGE_ALIGN(last_addr+1) - phys_addr;
 
-	/*
-	 * Ok, go for it..
-	 */
-	area = get_vm_area(size, VM_IOREMAP);
-	if (!area)
-		return NULL;
-	area->phys_addr = phys_addr;
-	orig_addr = addr = (unsigned long)area->addr;
-
 #ifdef CONFIG_32BIT
-	/*
-	 * First try to remap through the PMB once a valid VMA has been
-	 * established. Smaller allocations (or the rest of the size
-	 * remaining after a PMB mapping due to the size not being
-	 * perfectly aligned on a PMB size boundary) are then mapped
-	 * through the UTLB using conventional page tables.
-	 *
-	 * PMB entries are all pre-faulted.
-	 */
-	if (unlikely(size >= 0x1000000)) {
-		unsigned long mapped = pmb_remap(addr, phys_addr, size, flags);
-
-		if (likely(mapped)) {
-			addr		+= mapped;
-			phys_addr	+= mapped;
-			size		-= mapped;
-		}
-	}
+	addr = pmb_remap(phys_addr, size, cached ? _PAGE_CACHABLE : 0);
+#else
+	addr = 0;
 #endif
 
-	pgprot = __pgprot(pgprot_val(PAGE_KERNEL_NOCACHE) | flags);
-	if (likely(size))
+	if (addr == 0) {
+		struct vm_struct * area;
+
+		area = get_vm_area(size, VM_IOREMAP);
+		if (!area)
+			return NULL;
+
+		area->phys_addr = phys_addr;
+		addr = (unsigned long)area->addr;
+
 		if (ioremap_page_range(addr, addr + size, phys_addr, pgprot)) {
-			vunmap((void *)orig_addr);
+			vunmap((void *)addr);
 			return NULL;
 		}
+	}
 
-	return (void __iomem *)(offset + (char *)orig_addr);
+	return (void __iomem *)(offset + (char *)addr);
 }
-EXPORT_SYMBOL(__ioremap);
+EXPORT_SYMBOL(__ioremap_prot);
+
+void __iomem *__ioremap_mode(unsigned long phys_addr, unsigned long size,
+	unsigned long flags)
+{
+	pgprot_t pgprot;
+
+	if (unlikely(flags & _PAGE_CACHABLE))
+		pgprot = PAGE_KERNEL;
+	else
+		pgprot = PAGE_KERNEL_NOCACHE;
+
+	return __ioremap_prot(phys_addr, size, pgprot);
+}
+EXPORT_SYMBOL(__ioremap_mode);
 
 void __iounmap(void __iomem *addr)
 {
 	unsigned long vaddr = (unsigned long __force)addr;
 	struct vm_struct *p;
 
-	if (PXSEG(vaddr) < P3SEG || is_pci_memaddr(vaddr))
+	if (PXSEG(phys_addr) == P4SEG)
+		return;
+
+#ifndef CONFIG_32BIT
+	if (PXSEG(vaddr) < P3SEG)
 		return;
+#endif
 
 #ifdef CONFIG_32BIT
 	/*
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/pg-sh4.c linux-2.6.23.1-stm/arch/sh/mm/pg-sh4.c
--- linux-2.6.23.1/arch/sh/mm/pg-sh4.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/arch/sh/mm/pg-sh4.c	2007-11-01 12:00:43.000000000 +0000
@@ -2,99 +2,110 @@
  * arch/sh/mm/pg-sh4.c
  *
  * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2002 - 2007  Paul Mundt
+ * Copyright (C) 2002 - 2005  Paul Mundt
  *
  * Released under the terms of the GNU GPL v2.0.
  */
+#include <linux/init.h>
+#include <linux/mman.h>
 #include <linux/mm.h>
-#include <linux/mutex.h>
-#include <linux/fs.h>
+#include <linux/threads.h>
+#include <asm/addrspace.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 
-#define CACHE_ALIAS (current_cpu_data.dcache.alias_mask)
-
-static inline void *kmap_coherent(struct page *page, unsigned long addr)
-{
-	enum fixed_addresses idx;
-	unsigned long vaddr, flags;
-	pte_t pte;
-
-	inc_preempt_count();
-
-	idx = (addr & current_cpu_data.dcache.alias_mask) >> PAGE_SHIFT;
-	vaddr = __fix_to_virt(FIX_CMAP_END - idx);
-	pte = mk_pte(page, PAGE_KERNEL);
-
-	local_irq_save(flags);
-	flush_tlb_one(get_asid(), vaddr);
-	local_irq_restore(flags);
+//extern struct semaphore p3map_sem[];
+static atomic_t concurreny_check[16];
 
-	update_mmu_cache(NULL, vaddr, pte);
-
-	return (void *)vaddr;
-}
-
-static inline void kunmap_coherent(struct page *page)
-{
-	dec_preempt_count();
-	preempt_check_resched();
-}
+#define CACHE_ALIAS (current_cpu_data.dcache.alias_mask)
 
 /*
  * clear_user_page
- * @to: P1 address
+ * @to: kernel logical address
  * @address: U0 address to be mapped
  * @page: page (virt_to_page(to))
  */
 void clear_user_page(void *to, unsigned long address, struct page *page)
 {
-	__set_bit(PG_mapped, &page->flags);
+	void __clear_page_wb(void *to);
+
 	if (((address ^ (unsigned long)to) & CACHE_ALIAS) == 0)
-		clear_page(to);
+		__clear_page_wb(to);
 	else {
-		void *vto = kmap_coherent(page, address);
-		__clear_user_page(vto, to);
-		kunmap_coherent(vto);
+		pgprot_t pgprot = __pgprot(_PAGE_PRESENT |
+					   _PAGE_RW | _PAGE_CACHABLE |
+					   _PAGE_DIRTY | _PAGE_ACCESSED |
+					   _PAGE_HW_SHARED | _PAGE_FLAGS_HARD);
+		unsigned long phys_addr = virt_to_phys(to);
+		unsigned long p3_addr = P3SEG + (address & CACHE_ALIAS);
+		pgd_t *pgd = pgd_offset_k(p3_addr);
+		pud_t *pud = pud_offset(pgd, p3_addr);
+		pmd_t *pmd = pmd_offset(pud, p3_addr);
+		pte_t *pte = pte_offset_kernel(pmd, p3_addr);
+		pte_t entry;
+		unsigned long flags;
+
+		entry = pfn_pte(phys_addr >> PAGE_SHIFT, pgprot);
+		inc_preempt_count();
+BUG_ON(atomic_inc_return(&concurreny_check[(address & CACHE_ALIAS)>>12]) != 1);
+		set_pte(pte, entry);
+		local_irq_save(flags);
+		flush_tlb_one(get_asid(), p3_addr);
+		local_irq_restore(flags);
+		update_mmu_cache(NULL, p3_addr, entry);
+		__clear_user_page((void *)p3_addr, to);
+		pte_clear(&init_mm, p3_addr, pte);
+atomic_dec(&concurreny_check[(address & CACHE_ALIAS)>>12]);
+		dec_preempt_count();
 	}
 }
 
 /*
  * copy_user_page
- * @to: P1 address
- * @from: P1 address
+ * @to: kernel logical address
+ * @from: kernel logical address
  * @address: U0 address to be mapped
  * @page: page (virt_to_page(to))
  */
 void copy_user_page(void *to, void *from, unsigned long address,
 		    struct page *page)
 {
-	__set_bit(PG_mapped, &page->flags);
+	extern void __copy_page_wb(void *to, void *from);
+
 	if (((address ^ (unsigned long)to) & CACHE_ALIAS) == 0)
-		copy_page(to, from);
+		__copy_page_wb(to, from);
 	else {
-		void *vfrom = kmap_coherent(page, address);
-		__copy_user_page(vfrom, from, to);
-		kunmap_coherent(vfrom);
-	}
-}
-
-/*
- * For SH-4, we have our own implementation for ptep_get_and_clear
- */
-inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
-{
-	pte_t pte = *ptep;
-
-	pte_clear(mm, addr, ptep);
-	if (!pte_not_present(pte)) {
-		unsigned long pfn = pte_pfn(pte);
-		if (pfn_valid(pfn)) {
-			struct page *page = pfn_to_page(pfn);
-			struct address_space *mapping = page_mapping(page);
-			if (!mapping || !mapping_writably_mapped(mapping))
-				__clear_bit(PG_mapped, &page->flags);
-		}
+		pgprot_t pgprot = __pgprot(_PAGE_PRESENT |
+					   _PAGE_RW | _PAGE_CACHABLE |
+					   _PAGE_DIRTY | _PAGE_ACCESSED |
+					   _PAGE_HW_SHARED | _PAGE_FLAGS_HARD);
+		unsigned long phys_addr = virt_to_phys(to);
+		unsigned long p3_addr = P3SEG + (address & CACHE_ALIAS);
+		pgd_t *pgd = pgd_offset_k(p3_addr);
+		pud_t *pud = pud_offset(pgd, p3_addr);
+		pmd_t *pmd = pmd_offset(pud, p3_addr);
+		pte_t *pte = pte_offset_kernel(pmd, p3_addr);
+		pte_t entry;
+		unsigned long flags;
+
+		entry = pfn_pte(phys_addr >> PAGE_SHIFT, pgprot);
+		inc_preempt_count();
+BUG_ON(atomic_inc_return(&concurreny_check[(address & CACHE_ALIAS)>>12]) != 1);
+		set_pte(pte, entry);
+		local_irq_save(flags);
+		flush_tlb_one(get_asid(), p3_addr);
+		local_irq_restore(flags);
+		update_mmu_cache(NULL, p3_addr, entry);
+		__copy_user_page((void *)p3_addr, from, to);
+		pte_clear(&init_mm, p3_addr, pte);
+atomic_dec(&concurreny_check[(address & CACHE_ALIAS)>>12]);
+		dec_preempt_count();
 	}
-	return pte;
 }
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/pmb.c linux-2.6.23.1-stm/arch/sh/mm/pmb.c
--- linux-2.6.23.1/arch/sh/mm/pmb.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/mm/pmb.c	2007-11-01 12:00:43.000000000 +0000
@@ -28,196 +28,311 @@
 #include <asm/mmu.h>
 #include <asm/io.h>
 
-#define NR_PMB_ENTRIES	16
+#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
 
-static struct kmem_cache *pmb_cache;
-static unsigned long pmb_map;
+#define NR_PMB_ENTRIES	16
+#define MIN_PMB_MAPPING_SIZE	(8*1024*1024)
 
-static struct pmb_entry pmb_init_map[] = {
-	/* vpn         ppn         flags (ub/sz/c/wt) */
+struct pmb_entry {
+	unsigned long vpn;
+	unsigned long ppn;
+	unsigned long flags;	/* Only size */
+	struct pmb_entry *next;
+	unsigned long size;
+	int pos;
+};
 
-	/* P1 Section Mappings */
-	{ 0x80000000, 0x00000000, PMB_SZ_64M  | PMB_C, },
-	{ 0x84000000, 0x04000000, PMB_SZ_64M  | PMB_C, },
-	{ 0x88000000, 0x08000000, PMB_SZ_128M | PMB_C, },
-	{ 0x90000000, 0x10000000, PMB_SZ_64M  | PMB_C, },
-	{ 0x94000000, 0x14000000, PMB_SZ_64M  | PMB_C, },
-	{ 0x98000000, 0x18000000, PMB_SZ_64M  | PMB_C, },
-
-	/* P2 Section Mappings */
-	{ 0xa0000000, 0x00000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
-	{ 0xa4000000, 0x04000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
-	{ 0xa8000000, 0x08000000, PMB_UB | PMB_SZ_128M | PMB_WT, },
-	{ 0xb0000000, 0x10000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
-	{ 0xb4000000, 0x14000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
-	{ 0xb8000000, 0x18000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+struct pmb_mapping {
+	unsigned long phys;
+	unsigned long virt;
+	unsigned long size;
+	unsigned long flags;	/* Only cache etc */
+	struct pmb_entry *entries;
+	struct pmb_mapping *next;
+	int usage;
 };
 
-static inline unsigned long mk_pmb_entry(unsigned int entry)
+static DEFINE_SPINLOCK(pmb_lock);
+static unsigned long pmb_map;
+static struct pmb_entry   pmbe[NR_PMB_ENTRIES] __attribute__ ((__section__ (".uncached.data")));
+static struct pmb_mapping pmbm[NR_PMB_ENTRIES];
+static struct pmb_mapping *pmb_mappings, *pmb_mappings_free;
+
+static __always_inline unsigned long mk_pmb_entry(unsigned int entry)
 {
 	return (entry & PMB_E_MASK) << PMB_E_SHIFT;
 }
 
-static inline unsigned long mk_pmb_addr(unsigned int entry)
+static __always_inline unsigned long mk_pmb_addr(unsigned int entry)
 {
 	return mk_pmb_entry(entry) | PMB_ADDR;
 }
 
-static inline unsigned long mk_pmb_data(unsigned int entry)
+static __always_inline unsigned long mk_pmb_data(unsigned int entry)
 {
 	return mk_pmb_entry(entry) | PMB_DATA;
 }
 
-static DEFINE_SPINLOCK(pmb_list_lock);
-static struct pmb_entry *pmb_list;
-
-static inline void pmb_list_add(struct pmb_entry *pmbe)
+static __always_inline void __set_pmb_entry(unsigned long vpn,
+	unsigned long ppn, unsigned long flags, int pos)
 {
-	struct pmb_entry **p, *tmp;
-
-	p = &pmb_list;
-	while ((tmp = *p) != NULL)
-		p = &tmp->next;
-
-	pmbe->next = tmp;
-	*p = pmbe;
+#ifdef CONFIG_CACHE_WRITETHROUGH
+	/*
+	 * When we are in 32-bit address extended mode, CCR.CB becomes
+	 * invalid, so care must be taken to manually adjust cacheable
+	 * translations.
+	 */
+	if (likely(flags & PMB_C))
+		flags |= PMB_WT;
+#endif
+	ctrl_outl(vpn | PMB_V, mk_pmb_addr(pos));
+	ctrl_outl(ppn | flags | PMB_V, mk_pmb_data(pos));
 }
 
-static inline void pmb_list_del(struct pmb_entry *pmbe)
+static void __uses_jump_to_uncached set_pmb_entry(unsigned long vpn,
+	unsigned long ppn, unsigned long flags, int pos)
 {
-	struct pmb_entry **p, *tmp;
+	jump_to_uncached();
+	__set_pmb_entry(vpn, ppn, flags, pos);
+	back_to_cached();
+}
 
-	for (p = &pmb_list; (tmp = *p); p = &tmp->next)
-		if (tmp == pmbe) {
-			*p = tmp->next;
-			return;
-		}
+static __always_inline void __clear_pmb_entry(int pos)
+{
+	ctrl_outl(0, mk_pmb_addr(pos));
 }
 
-struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
-			    unsigned long flags)
+static void __uses_jump_to_uncached clear_pmb_entry(int pos)
 {
-	struct pmb_entry *pmbe;
+	jump_to_uncached();
+	__clear_pmb_entry(pos);
+	back_to_cached();
+}
 
-	pmbe = kmem_cache_alloc(pmb_cache, GFP_KERNEL);
-	if (!pmbe)
-		return ERR_PTR(-ENOMEM);
+static __always_inline void __pmb_set_mapping(struct pmb_mapping *mapping)
+{
+	struct pmb_entry *entry = mapping->entries;
 
-	pmbe->vpn	= vpn;
-	pmbe->ppn	= ppn;
-	pmbe->flags	= flags;
+	do {
+		__set_pmb_entry(entry->vpn, entry->ppn,
+			      entry->flags | mapping->flags, entry->pos);
+		entry = entry->next;
+	} while (entry);
+}
 
-	spin_lock_irq(&pmb_list_lock);
-	pmb_list_add(pmbe);
-	spin_unlock_irq(&pmb_list_lock);
+static void pmb_set_mapping(struct pmb_mapping *mapping)
+{
+	struct pmb_entry *entry = mapping->entries;
 
-	return pmbe;
+	do {
+		set_pmb_entry(entry->vpn, entry->ppn,
+			      entry->flags | mapping->flags, entry->pos);
+		entry = entry->next;
+	} while (entry);
 }
 
-void pmb_free(struct pmb_entry *pmbe)
+static void pmb_clear_mapping(struct pmb_mapping *mapping)
 {
-	spin_lock_irq(&pmb_list_lock);
-	pmb_list_del(pmbe);
-	spin_unlock_irq(&pmb_list_lock);
+	struct pmb_entry *entry = mapping->entries;
 
-	kmem_cache_free(pmb_cache, pmbe);
+	do {
+		clear_pmb_entry(entry->pos);
+		entry = entry->next;
+	} while (entry);
 }
 
-/*
- * Must be in P2 for __set_pmb_entry()
- */
-int __set_pmb_entry(unsigned long vpn, unsigned long ppn,
-		    unsigned long flags, int *entry)
+static int pmb_alloc(int pos)
 {
-	unsigned int pos = *entry;
-
 	if (unlikely(pos == PMB_NO_ENTRY))
 		pos = find_first_zero_bit(&pmb_map, NR_PMB_ENTRIES);
 
 repeat:
 	if (unlikely(pos > NR_PMB_ENTRIES))
-		return -ENOSPC;
+		return PMB_NO_ENTRY;
 
 	if (test_and_set_bit(pos, &pmb_map)) {
 		pos = find_first_zero_bit(&pmb_map, NR_PMB_ENTRIES);
 		goto repeat;
 	}
 
-	ctrl_outl(vpn | PMB_V, mk_pmb_addr(pos));
-
-#ifdef CONFIG_CACHE_WRITETHROUGH
-	/*
-	 * When we are in 32-bit address extended mode, CCR.CB becomes
-	 * invalid, so care must be taken to manually adjust cacheable
-	 * translations.
-	 */
-	if (likely(flags & PMB_C))
-		flags |= PMB_WT;
-#endif
-
-	ctrl_outl(ppn | flags | PMB_V, mk_pmb_data(pos));
-
-	*entry = pos;
-
-	return 0;
+	return pos;
 }
 
-int set_pmb_entry(struct pmb_entry *pmbe)
+static void pmb_free(int entry)
 {
-	int ret;
-
-	jump_to_P2();
-	ret = __set_pmb_entry(pmbe->vpn, pmbe->ppn, pmbe->flags, &pmbe->entry);
-	back_to_P1();
-
-	return ret;
+	clear_bit(entry, &pmb_map);
 }
 
-void clear_pmb_entry(struct pmb_entry *pmbe)
+static struct pmb_mapping* pmb_mapping_alloc(void)
 {
-	unsigned int entry = pmbe->entry;
-	unsigned long addr;
-
-	/*
-	 * Don't allow clearing of wired init entries, P1 or P2 access
-	 * without a corresponding mapping in the PMB will lead to reset
-	 * by the TLB.
-	 */
-	if (unlikely(entry < ARRAY_SIZE(pmb_init_map) ||
-		     entry >= NR_PMB_ENTRIES))
-		return;
-
-	jump_to_P2();
+	struct pmb_mapping *mapping;
 
-	/* Clear V-bit */
-	addr = mk_pmb_addr(entry);
-	ctrl_outl(ctrl_inl(addr) & ~PMB_V, addr);
+	if (pmb_mappings_free == NULL)
+		return NULL;
 
-	addr = mk_pmb_data(entry);
-	ctrl_outl(ctrl_inl(addr) & ~PMB_V, addr);
+	mapping = pmb_mappings_free;
+	pmb_mappings_free = mapping->next;
 
-	back_to_P1();
-
-	clear_bit(entry, &pmb_map);
+	memset(mapping, 0, sizeof(*mapping));
+	return mapping;
 }
 
+static void pmb_mapping_free(struct pmb_mapping* mapping)
+{
+	mapping->next = pmb_mappings_free;
+	pmb_mappings_free = mapping;
+}
 
 static struct {
 	unsigned long size;
 	int flag;
 } pmb_sizes[] = {
-	{ .size	= 0x20000000, .flag = PMB_SZ_512M, },
-	{ .size = 0x08000000, .flag = PMB_SZ_128M, },
-	{ .size = 0x04000000, .flag = PMB_SZ_64M,  },
 	{ .size = 0x01000000, .flag = PMB_SZ_16M,  },
+	{ .size = 0x04000000, .flag = PMB_SZ_64M,  },
+	{ .size = 0x08000000, .flag = PMB_SZ_128M, },
+	{ .size	= 0x20000000, .flag = PMB_SZ_512M, },
 };
 
-long pmb_remap(unsigned long vaddr, unsigned long phys,
+static struct pmb_mapping* pmb_calc(unsigned long phys, unsigned long size,
+				    unsigned long req_virt, int *req_pos,
+				    unsigned long pmb_flags)
+{
+	struct pmb_mapping *new_mapping;
+	unsigned long alignment = 0;
+	unsigned long virt_offset = 0;
+	struct pmb_entry *prev_entry = NULL;
+	unsigned long prev_end, next_start;
+	struct pmb_mapping *next_mapping;
+	struct pmb_mapping **prev_ptr;
+	struct pmb_entry *entry;
+	unsigned long start;
+
+	new_mapping = pmb_mapping_alloc();
+	if (!new_mapping)
+		return NULL;
+
+	DPRINTK("request: phys %08lx, size %08lx\n", phys, size);
+	/* First work out the PMB entries to tile the physical region */
+	while (size > 0) {
+		int pos;
+		unsigned long best_size;	/* bytes of size covered by tile */
+		int best_i;
+		unsigned long entry_phys;
+		unsigned long entry_size;	/* total size of tile */
+		int i;
+
+		if (req_pos)
+			pos = pmb_alloc(*req_pos++);
+		else
+			pos = pmb_alloc(PMB_NO_ENTRY);
+		if (pos == PMB_NO_ENTRY)
+			goto failed;
+
+		best_size = best_i = 0;
+		for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++) {
+			unsigned long tmp_start, tmp_end, tmp_size;
+			tmp_start = phys & ~(pmb_sizes[i].size-1);
+			tmp_end = tmp_start + pmb_sizes[i].size;
+			tmp_size = min(phys+size, tmp_end)-max(phys, tmp_start);
+			if (tmp_size > best_size) {
+				best_i = i;
+				best_size = tmp_size;
+			}
+		}
+
+		BUG_ON(best_size == 0);
+
+		entry_size = pmb_sizes[best_i].size;
+		entry_phys = phys & ~(entry_size-1);
+		DPRINTK("using PMB %d: phys %08lx, size %08lx\n", pos, entry_phys, entry_size);
+
+		entry = &pmbe[pos];
+		entry->ppn   = entry_phys;
+		entry->size  = entry_size;
+		entry->flags = pmb_sizes[best_i].flag;
+
+		if (pmb_sizes[best_i].size > alignment) {
+			alignment = entry_size;
+			if (new_mapping->size)
+				virt_offset = alignment - new_mapping->size;
+		}
+
+		if (prev_entry) {
+			new_mapping->size += entry_size;
+			prev_entry->next = entry;
+		} else {
+			new_mapping->phys = entry_phys;
+			new_mapping->size = entry_size;
+			new_mapping->entries = entry;
+		}
+
+		prev_entry = entry;
+		size -= best_size;
+		phys += best_size;
+	}
+
+	DPRINTK("mapping: phys %08lx, size %08lx\n", new_mapping->phys, new_mapping->size);
+	DPRINTK("virtual alignment %08lx, offset %08lx\n", alignment, virt_offset);
+
+	/* Do we have a conflict with the requested maping? */
+	BUG_ON((req_virt & (alignment-1)) != virt_offset);
+
+	/* Next try and find a virtual address to map this */
+	prev_end = P1SEG;
+	next_mapping = pmb_mappings;
+	prev_ptr = &pmb_mappings;
+	do {
+		if (next_mapping == NULL)
+			next_start = P3SEG;
+		else
+			next_start = next_mapping->virt;
+
+		if (req_virt)
+			start = req_virt;
+		else
+			start = ALIGN(prev_end, alignment) + virt_offset;
+
+		DPRINTK("checking for virt %08lx between %08lx and %08lx\n",
+			start, prev_end, next_start);
+
+		if ((start >= prev_end) &&
+		    (start + new_mapping->size <= next_start))
+			break;
+
+		if (next_mapping == NULL)
+			goto failed;
+
+		prev_ptr = &next_mapping->next;
+		prev_end = next_mapping->virt + next_mapping->size;
+		next_mapping = next_mapping->next;
+	} while (1);
+
+	DPRINTK("success, using %08lx\n", start);
+	new_mapping->virt = start;
+	new_mapping->flags = pmb_flags;
+	new_mapping->next = *prev_ptr;
+	*prev_ptr = new_mapping;
+
+	/* Finally fill in the vpn's */
+	for (entry = new_mapping->entries; entry; entry=entry->next) {
+		entry->vpn = start;
+		start += entry->size;
+	}
+
+	return new_mapping;
+
+failed:
+	/* Need to free things here */
+	DPRINTK("failed\n");
+	return NULL;
+}
+
+long pmb_remap(unsigned long phys,
 	       unsigned long size, unsigned long flags)
 {
-	struct pmb_entry *pmbp;
-	unsigned long wanted;
-	int pmb_flags, i;
+	struct pmb_mapping *mapping;
+	int pmb_flags;
+	unsigned long offset;
 
 	/* Convert typical pgprot value to the PMB equivalent */
 	if (flags & _PAGE_CACHABLE) {
@@ -228,113 +343,120 @@
 	} else
 		pmb_flags = PMB_WT | PMB_UB;
 
-	pmbp = NULL;
-	wanted = size;
-
-again:
-	for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++) {
-		struct pmb_entry *pmbe;
-		int ret;
-
-		if (size < pmb_sizes[i].size)
-			continue;
-
-		pmbe = pmb_alloc(vaddr, phys, pmb_flags | pmb_sizes[i].flag);
-		if (IS_ERR(pmbe))
-			return PTR_ERR(pmbe);
-
-		ret = set_pmb_entry(pmbe);
-		if (ret != 0) {
-			pmb_free(pmbe);
-			return -EBUSY;
-		}
-
-		phys	+= pmb_sizes[i].size;
-		vaddr	+= pmb_sizes[i].size;
-		size	-= pmb_sizes[i].size;
-
-		/*
-		 * Link adjacent entries that span multiple PMB entries
-		 * for easier tear-down.
-		 */
-		if (likely(pmbp))
-			pmbp->link = pmbe;
-
-		pmbp = pmbe;
+	for (mapping = pmb_mappings; mapping; mapping=mapping->next) {
+		if ((phys >= mapping->phys) &&
+		    (phys+size <= mapping->phys+mapping->size) &&
+		    (pmb_flags == mapping->flags))
+			break;
 	}
 
-	if (size >= 0x1000000)
-		goto again;
+	if (mapping) {
+		/* If we hit an existing mapping, use it */
+		mapping->usage++;
+	} else if (size < MIN_PMB_MAPPING_SIZE) {
+		/* We spit upon small mappings */
+		return 0;
+	} else {
+		mapping = pmb_calc(phys, size, 0, NULL, pmb_flags);
+		if (!mapping)
+			return 0;
+		pmb_set_mapping(mapping);
+	}
 
-	return wanted - size;
+	offset = phys - mapping->phys;
+	return mapping->virt + offset;
 }
 
 void pmb_unmap(unsigned long addr)
 {
-	struct pmb_entry **p, *pmbe;
+	struct pmb_mapping *mapping;
+	struct pmb_entry *entry;
 
-	for (p = &pmb_list; (pmbe = *p); p = &pmbe->next)
-		if (pmbe->vpn == addr)
+	for (mapping = pmb_mappings; mapping; mapping=mapping->next) {
+		if ((addr >= mapping->virt) &&
+		    (addr < mapping->virt + mapping->size))
 			break;
+	}
 
-	if (unlikely(!pmbe))
+	if (unlikely(!mapping))
 		return;
 
-	WARN_ON(!test_bit(pmbe->entry, &pmb_map));
+	if (--mapping->usage == 0)
+		pmb_clear_mapping(mapping);
 
+	entry = mapping->entries;
 	do {
-		struct pmb_entry *pmblink = pmbe;
-
-		clear_pmb_entry(pmbe);
-		pmbe = pmblink->link;
-
-		pmb_free(pmblink);
-	} while (pmbe);
-}
-
-static void pmb_cache_ctor(void *pmb, struct kmem_cache *cachep,
-			   unsigned long flags)
-{
-	struct pmb_entry *pmbe = pmb;
-
-	memset(pmb, 0, sizeof(struct pmb_entry));
-
-	pmbe->entry = PMB_NO_ENTRY;
+		pmb_free(entry->pos);
+		entry = entry->next;
+	} while (entry);
+	pmb_mapping_free(mapping);
 }
 
-static int __init pmb_init(void)
+static void noinline __uses_jump_to_uncached
+apply_boot_mappings(struct pmb_mapping *uc_mapping, struct pmb_mapping *ram_mapping)
 {
-	unsigned int nr_entries = ARRAY_SIZE(pmb_init_map);
-	unsigned int entry;
+	extern char _start_uncached;
+	register int i __asm__("r1");
+	register unsigned long c2uc __asm__("r2");
+	register struct pmb_entry *entry __asm__("r3");
+	register unsigned long flags __asm__("r4");
 
-	BUG_ON(unlikely(nr_entries >= NR_PMB_ENTRIES));
+	/* We can execute this directly, as the current PMB is uncached */
+	__pmb_set_mapping(uc_mapping);
 
-	pmb_cache = kmem_cache_create("pmb", sizeof(struct pmb_entry), 0,
-				      SLAB_PANIC, pmb_cache_ctor);
+	cached_to_uncached = uc_mapping->virt -
+		(((unsigned long)&_start_uncached) & ~(uc_mapping->entries->size-1));
 
-	jump_to_P2();
+	jump_to_uncached();
 
 	/*
-	 * Ordering is important, P2 must be mapped in the PMB before we
-	 * can set PMB.SE, and P1 must be mapped before we jump back to
-	 * P1 space.
+	 * We have to be cautious here, as we will temporarily lose access to
+	 * the PMB entry which is mapping main RAM, and so loose access to
+	 * data. So make sure all data is going to be in registers or the
+	 * uncached region.
 	 */
-	for (entry = 0; entry < nr_entries; entry++) {
-		struct pmb_entry *pmbe = pmb_init_map + entry;
 
-		__set_pmb_entry(pmbe->vpn, pmbe->ppn, pmbe->flags, &entry);
-	}
+	c2uc = cached_to_uncached;
+	entry = ram_mapping->entries;
+	flags = ram_mapping->flags;
 
-	ctrl_outl(0, PMB_IRMCR);
+	for (i=0; i<NR_PMB_ENTRIES-1; i++)
+		__clear_pmb_entry(i);
 
-	/* PMB.SE and UB[7] */
-	ctrl_outl((1 << 31) | (1 << 7), PMB_PASCR);
+	do {
+		entry = (struct pmb_entry*)(((unsigned long)entry) + c2uc);
+		__set_pmb_entry(entry->vpn, entry->ppn,
+				entry->flags | flags, entry->pos);
+		entry = entry->next;
+	} while (entry);
 
-	back_to_P1();
+	back_to_cached();
+}
 
-	return 0;
+void __init pmb_init(void)
+{
+	int i;
+	int entry;
+	extern char _start_uncached, _end_uncached;
+	struct pmb_mapping *uc_mapping, *ram_mapping;
+
+	/* Create the free list of mappings */
+	pmb_mappings_free = &pmbm[0];
+	for (i=0; i<NR_PMB_ENTRIES-1; i++)
+		pmbm[i].next = &pmbm[i+1];
+	pmbm[NR_PMB_ENTRIES-1].next = NULL;
+
+	/* Initialise the PMB entrie's pos */
+	for (i=0; i<NR_PMB_ENTRIES; i++)
+		pmbe[i].pos = i;
+
+	/* Create the initial mappings */
+	entry = NR_PMB_ENTRIES-1;
+	uc_mapping = pmb_calc(__pa(&_start_uncached), &_end_uncached - &_start_uncached,
+		 P3SEG-0x01000000, &entry, PMB_WT | PMB_UB);
+	ram_mapping = pmb_calc(__MEMORY_START, __MEMORY_SIZE, P1SEG, 0, PMB_C);
+	apply_boot_mappings(uc_mapping, ram_mapping);
 }
-arch_initcall(pmb_init);
 
 static int pmb_seq_show(struct seq_file *file, void *iter)
 {
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/arch/sh/mm/tlb-sh4.c linux-2.6.23.1-stm/arch/sh/mm/tlb-sh4.c
--- linux-2.6.23.1/arch/sh/mm/tlb-sh4.c	2007-11-01 12:05:12.000000000 +0000
+++ linux-2.6.23.1-stm/arch/sh/mm/tlb-sh4.c	2007-11-01 12:00:43.000000000 +0000
@@ -22,7 +22,11 @@
 	unsigned long pteval;
 	unsigned long vpn;
 
-	/* Ptrace may call this routine. */
+	/* FIXME SIM: Do I need this test at all? Sparc doesn't */
+
+	/* vma can be null when called for a P3 address from
+	 * copy_user_page. Also ptrace may call this routine
+	 * to access an address in the process being debugged. */
 	if (vma && current->active_mm != vma->vm_mm)
 		return;
 
@@ -33,11 +37,12 @@
 		if (pfn_valid(pfn)) {
 			struct page *page = pfn_to_page(pfn);
 
-			if (!test_bit(PG_mapped, &page->flags)) {
+			if (page_mapping(page) &&
+			    test_bit(PG_dcache_dirty, &page->flags)) {
 				unsigned long phys = pte_val(pte) & PTE_PHYS_MASK;
-				__flush_wback_region((void *)P1SEGADDR(phys),
+				__flush_wback_region(phys_to_virt(phys),
 						     PAGE_SIZE);
-				__set_bit(PG_mapped, &page->flags);
+				__clear_bit(PG_dcache_dirty, &page->flags);
 			}
 		}
 	}
@@ -79,7 +84,7 @@
 	local_irq_restore(flags);
 }
 
-void local_flush_tlb_one(unsigned long asid, unsigned long page)
+void __uses_jump_to_uncached local_flush_tlb_one(unsigned long asid, unsigned long page)
 {
 	unsigned long addr, data;
 
@@ -91,7 +96,7 @@
 	 */
 	addr = MMU_UTLB_ADDRESS_ARRAY | MMU_PAGE_ASSOC_BIT;
 	data = page | asid; /* VALID bit is off */
-	jump_to_P2();
+	jump_to_uncached();
 	ctrl_outl(data, addr);
-	back_to_P1();
+	back_to_cached();
 }
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/Kconfig linux-2.6.23.1-stm/drivers/Kconfig
--- linux-2.6.23.1/drivers/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/Kconfig	2007-11-01 12:00:39.000000000 +0000
@@ -89,4 +89,7 @@
 source "drivers/uio/Kconfig"
 
 source "drivers/lguest/Kconfig"
+
+source "drivers/stm/Kconfig"
+
 endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/Makefile linux-2.6.23.1-stm/drivers/Makefile
--- linux-2.6.23.1/drivers/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -8,6 +8,9 @@
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
+# char/ comes before serial/ etc so that the VT console is the boot-time
+# default.
+obj-y				+= char/
 obj-y				+= video/
 obj-$(CONFIG_ACPI)		+= acpi/
 # PnP must come after ACPI since it will eventually need to check if acpi
@@ -17,10 +20,6 @@
 
 obj-$(CONFIG_XEN)		+= xen/
 
-# char/ comes before serial/ etc so that the VT console is the boot-time
-# default.
-obj-y				+= char/
-
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
 # i810fb and intelfb depend on char/agp/
@@ -88,3 +87,4 @@
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
+obj-$(CONFIG_STM_DRIVERS)	+= stm/
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/ata/Kconfig linux-2.6.23.1-stm/drivers/ata/Kconfig
--- linux-2.6.23.1/drivers/ata/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/ata/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -143,6 +143,15 @@
 	  enable the PATA_SIS driver in the config.
 	  If unsure, say N.
 
+config SATA_STM
+	tristate "STMicroelectronics SATA support"
+	depends on ARCH_ST200 || CPU_SUBTYPE_ST40
+	help
+	  This option enables support for the on-chip SATA controller on
+	  some STMicroelectronics embedded processors.
+
+	  If unsure, say N.
+
 config SATA_ULI
 	tristate "ULi Electronics SATA support"
 	depends on PCI
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/ata/Makefile linux-2.6.23.1-stm/drivers/ata/Makefile
--- linux-2.6.23.1/drivers/ata/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/ata/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -17,6 +17,7 @@
 obj-$(CONFIG_SATA_MV)		+= sata_mv.o
 obj-$(CONFIG_SATA_INIC162X)	+= sata_inic162x.o
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
+obj-$(CONFIG_SATA_STM)		+= sata_stm.o
 
 obj-$(CONFIG_PATA_ALI)		+= pata_ali.o
 obj-$(CONFIG_PATA_AMD)		+= pata_amd.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/ata/libata-core.c linux-2.6.23.1-stm/drivers/ata/libata-core.c
--- linux-2.6.23.1/drivers/ata/libata-core.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/ata/libata-core.c	2007-11-01 12:00:40.000000000 +0000
@@ -52,8 +52,13 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
-#include <linux/libata.h>
+// #include <linux/libata.h>
 #include <asm/io.h>
+
+
+// Moved from above so that it is after this munging.
+#include <linux/libata.h>
+
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/ata/sata_stm.c linux-2.6.23.1-stm/drivers/ata/sata_stm.c
--- linux-2.6.23.1/drivers/ata/sata_stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/ata/sata_stm.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1041 @@
+/*
+ *  sata_stm.c - STMicroelectronics SATA
+ *
+ *  Copyright 2005 STMicroelectronics Ltd.
+ *
+ *  The contents of this file are subject to the Open
+ *  Software License version 1.1 that can be found at
+ *  http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+ *  by reference.
+ *
+ *  Alternatively, the contents of this file may be used under the terms
+ *  of the GNU General Public License version 2 (the "GPL") as distributed
+ *  in the kernel source COPYING file, in which case the provisions of
+ *  the GPL are applicable instead of the above.  If you wish to allow
+ *  the use of your version of this file only under the terms of the
+ *  GPL and not to allow others to use your version of this file under
+ *  the OSL, indicate your decision by deleting the provisions above and
+ *  replace them with the notice and other provisions required by the GPL.
+ *  If you do not delete the provisions above, a recipient may use your
+ *  version of this file under either the OSL or the GPL.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <linux/libata.h>
+#include <linux/stm/soc.h>
+
+#define DRV_NAME			"sata_stm"
+#define DRV_VERSION			"0.5"
+
+/* Offsets of the component blocks */
+#define SATA_AHB2STBUS_BASE			0x00000000
+#define SATA_AHBDMA_BASE			0x00000400
+#define SATA_AHBHOST_BASE			0x00000800
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x0000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x000c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x0010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x0014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x0018)
+
+/* AHB DMA controller */
+#define DMAC_SAR0				(SATA_AHBDMA_BASE + 0x00000000)
+#define DMAC_DAR0				(SATA_AHBDMA_BASE + 0x00000008)
+#define DMAC_LLP0				(SATA_AHBDMA_BASE + 0x00000010)
+#define DMAC_CTL0_0				(SATA_AHBDMA_BASE + 0x00000018)
+#define DMAC_CTL0_1				(SATA_AHBDMA_BASE + 0x0000001c)
+#define DMAC_SSTAT0				(SATA_AHBDMA_BASE + 0x00000020)
+#define DMAC_DSTAT0				(SATA_AHBDMA_BASE + 0x00000028)
+#define DMAC_SSTATAR0				(SATA_AHBDMA_BASE + 0x00000030)
+#define DMAC_DSTATAR0				(SATA_AHBDMA_BASE + 0x00000038)
+#define DMAC_CFG0_0				(SATA_AHBDMA_BASE + 0x00000040)
+#define DMAC_CFG0_1				(SATA_AHBDMA_BASE + 0x00000044)
+#define DMAC_SGR0				(SATA_AHBDMA_BASE + 0x00000048)
+#define DMAC_DSR0				(SATA_AHBDMA_BASE + 0x00000050)
+#define DMAC_RAWTFR				(SATA_AHBDMA_BASE + 0x000002c0)
+#define DMAC_RAWBLOCK				(SATA_AHBDMA_BASE + 0x000002c8)
+#define DMAC_RAWSRCTRAN				(SATA_AHBDMA_BASE + 0x000002d0)
+#define DMAC_RAWDSTTRAN				(SATA_AHBDMA_BASE + 0x000002d8)
+#define DMAC_RAWERR				(SATA_AHBDMA_BASE + 0x000002e0)
+#define DMAC_STATUSTFR				(SATA_AHBDMA_BASE + 0x000002e8)
+#define DMAC_STATUSBLOCK			(SATA_AHBDMA_BASE + 0x000002f0)
+#define DMAC_STATUSSRCTRAN			(SATA_AHBDMA_BASE + 0x000002f8)
+#define DMAC_STATUSDSTTRAN			(SATA_AHBDMA_BASE + 0x00000300)
+#define DMAC_STATUSERR				(SATA_AHBDMA_BASE + 0x00000308)
+#define DMAC_MASKTFR				(SATA_AHBDMA_BASE + 0x00000310)
+#define DMAC_MASKBLOCK				(SATA_AHBDMA_BASE + 0x00000318)
+#define DMAC_MASKSRCTRAN			(SATA_AHBDMA_BASE + 0x00000320)
+#define DMAC_MASKDSTTRAN			(SATA_AHBDMA_BASE + 0x00000328)
+#define DMAC_MASKERR				(SATA_AHBDMA_BASE + 0x00000330)
+#define DMAC_CLEARTFR				(SATA_AHBDMA_BASE + 0x00000338)
+#define DMAC_CLEARBLOCK				(SATA_AHBDMA_BASE + 0x00000340)
+#define DMAC_CLEARSRCTRAN			(SATA_AHBDMA_BASE + 0x00000348)
+#define DMAC_CLEARDSTTRAN			(SATA_AHBDMA_BASE + 0x00000350)
+#define DMAC_CLEARERR				(SATA_AHBDMA_BASE + 0x00000358)
+#define DMAC_STATUSINT				(SATA_AHBDMA_BASE + 0x00000360)
+#define DMAC_REQSRCREG				(SATA_AHBDMA_BASE + 0x00000368)
+#define DMAC_REQDSTREG				(SATA_AHBDMA_BASE + 0x00000370)
+#define DMAC_SGLREQSRCREG			(SATA_AHBDMA_BASE + 0x00000378)
+#define DMAC_SGLREQDSTREG			(SATA_AHBDMA_BASE + 0x00000380)
+#define DMAC_LSTSRCREG				(SATA_AHBDMA_BASE + 0x00000388)
+#define DMAC_LSTDSTREG				(SATA_AHBDMA_BASE + 0x00000390)
+#define DMAC_DmaCfgReg				(SATA_AHBDMA_BASE + 0x00000398)
+#define DMAC_ChEnReg				(SATA_AHBDMA_BASE + 0x000003a0)
+#define DMAC_DMAIDREG				(SATA_AHBDMA_BASE + 0x000003a8)
+#define DMAC_DMATESTREG				(SATA_AHBDMA_BASE + 0x000003b0)
+#define DMAC_DMA_COMP_VERSION			(SATA_AHBDMA_BASE + 0x000003b8)
+#define DMAC_COMP_PARAMS_2			(SATA_AHBDMA_BASE + 0x000003e8)
+#define DMAC_COMP_TYPE				(SATA_AHBDMA_BASE + 0x000003f8)
+#define DMAC_COMP_VERSION			(SATA_AHBDMA_BASE + 0x000003fc)
+
+#define DMAC_CTL_INT_EN			(1<<0)
+#define DMAC_CTL_DST_TR_WIDTH_32	(2<<1)
+#define DMAC_CTL_SRC_TR_WIDTH_32	(2<<4)
+#define DMAC_CTL_DINC_INC		(0<<7)
+#define DMAC_CTL_DINC_DEC		(1<<7)
+#define DMAC_CTL_DINC_NC		(2<<7)
+#define DMAC_CTL_SINC_INC		(0<<9)
+#define DMAC_CTL_SINC_DEC		(1<<9)
+#define DMAC_CTL_SINC_NC		(2<<9)
+#define DMAC_CTL_DEST_MSIZE_1		(0<<11)
+#define DMAC_CTL_DEST_MSIZE_4		(1<<11)
+#define DMAC_CTL_DEST_MSIZE_8		(2<<11)
+#define DMAC_CTL_DEST_MSIZE_16		(3<<11)
+#define DMAC_CTL_SRC_MSIZE_1		(0<<14)
+#define DMAC_CTL_SRC_MSIZE_4		(1<<14)
+#define DMAC_CTL_SRC_MSIZE_8		(2<<14)
+#define DMAC_CTL_SRC_MSIZE_16		(3<<14)
+#define DMAC_CTL_SRC_GATHER_EN		(1<<17)
+#define DMAC_CTL_DST_SCATTER_EN		(1<<18)
+#define DMAC_CTL_TT_FC_M2M_DMAC		(0<<20)	/* memory to memory | DMAC */
+#define DMAC_CTL_TT_FC_M2P_DMAC		(1<<20)	/* memory to periph | DMAC */
+#define DMAC_CTL_TT_FC_P2M_DMAC		(2<<20)	/* periph to memory | DMAC */
+#define DMAC_CTL_TT_FC_P2P_DMAC		(3<<20)	/* periph to periph | DMAC */
+#define DMAC_CTL_TT_FC_P2M_PER		(4<<20)	/* periph to memory | periph */
+#define DMAC_CTL_TT_FC_P2P_SPER		(5<<20)	/* periph to periph | src periph */
+#define DMAC_CTL_TT_FC_M2P_PER		(6<<20)	/* memory to periph | periph */
+#define DMAC_CTL_TT_FC_P2P_DPER		(7<<20)	/* periph to periph | dest periph */
+#define DMAC_CTL_DMS_1		(0<<23)
+#define DMAC_CTL_DMS_2		(1<<23)
+#define DMAC_CTL_SMS_1		(0<<25)
+#define DMAC_CTL_SMS_2		(1<<25)
+#define DMAC_CTL_LLP_DST_EN	(1<<27)
+#define DMAC_CTL_LLP_SRC_EN	(1<<28)
+
+#define DMAC_CTL_BLOCK_TS	(1<<32)
+#define DMAC_CTL_DONE		(1<<44)
+
+#define DMA_CFG_CH_PRIOR_0	(0<<5)
+#define DMA_CFG_CH_SUSP		(1<<8)
+#define DMA_CFG_FIFO_EMPTY	(1<<9)
+#define DMA_CFG_HS_SEL_DST_HW	(0<<10)
+#define DMA_CFG_HS_SEL_DST_SW	(1<<10)
+#define DMA_CFG_HS_SEL_SRC_HW	(0<<11)
+#define DMA_CFG_HS_SEL_SRC_SW	(1<<11)
+/*efine DMA_CFG_LOCK_CH_L	(1<<12) not in config */
+/*efine DMA_CFG_LOCK_B_L	(1<<14) not in config */
+/*efine DMA_CFG_LOCK_CH		(1<<16) not in config */
+/*efine DMA_CFG_LOCK_B		(1<<17) not in config */
+#define DMA_CFG_DST_HS_POL_HI	(0<<18)
+#define DMA_CFG_DST_HS_POL_LO	(1<<18)
+#define DMA_CFG_SRC_HS_POL_HI	(0<<19)
+#define DMA_CFG_SRC_HS_POL_LO	(1<<19)
+#define DMA_CFG_MAX_ABRST_UNLIMITED	(0<<20)
+#define DMA_CFG_RELOAD_SRC	(1<<30)
+#define DMA_CFG_RELOAD_DST	(1<<31)
+
+#define DMA_CFG_1_FCMODE		(1<<(32-32))
+#define DMA_CFG_1_FIFO_MODE		(1<<(33-32))
+#define DMA_CFG_1_PROTCTL		(1<<(34-32))
+#define DMA_CFG_1_DS_UPD_EN		(1<<(37-32))
+/*efine DMA_CFG_1_SS_UPD_EN		(1<<(38-32)) not in config */
+#define DMA_CFG_1_SRC_PER_0		(0<<(39-32))
+#define DMA_CFG_1_SRC_PER_1		(1<<(39-32))
+#define DMA_CFG_1_DEST_PER_0		(0<<(43-32))
+#define DMA_CFG_1_DEST_PER_1		(1<<(43-32))
+
+#define DMAC_DmaCfgReg_DMA_EN	(1<<0)
+
+#define DMAC_COMP_PARAMS_2_CH0_HC_LLP	(1<<13)
+
+/* AHB host controller */
+#define SATA_CDR0				(SATA_AHBHOST_BASE + 0x00000000)
+#define SATA_CDR1				(SATA_AHBHOST_BASE + 0x00000004)
+#define SATA_CDR2				(SATA_AHBHOST_BASE + 0x00000008)
+#define SATA_CDR3				(SATA_AHBHOST_BASE + 0x0000000c)
+#define SATA_CDR4				(SATA_AHBHOST_BASE + 0x00000010)
+#define SATA_CDR5				(SATA_AHBHOST_BASE + 0x00000014)
+#define SATA_CDR6				(SATA_AHBHOST_BASE + 0x00000018)
+#define SATA_CDR7				(SATA_AHBHOST_BASE + 0x0000001c)
+#define SATA_CLR0				(SATA_AHBHOST_BASE + 0x00000020)
+#define SATA_SCR0				(SATA_AHBHOST_BASE + 0x00000024)
+#define SATA_SCR1				(SATA_AHBHOST_BASE + 0x00000028)
+#define SATA_SCR2				(SATA_AHBHOST_BASE + 0x0000002c)
+#define SATA_SCR3				(SATA_AHBHOST_BASE + 0x00000030)
+#define SATA_SCR4				(SATA_AHBHOST_BASE + 0x00000034)
+#define SATA_FPTAGR				(SATA_AHBHOST_BASE + 0x00000064)
+#define SATA_FPBOR				(SATA_AHBHOST_BASE + 0x00000068)
+#define SATA_FPTCR				(SATA_AHBHOST_BASE + 0x0000006c)
+#define SATA_DMACR				(SATA_AHBHOST_BASE + 0x00000070)
+#define SATA_DBTSR				(SATA_AHBHOST_BASE + 0x00000074)
+#define SATA_INTPR				(SATA_AHBHOST_BASE + 0x00000078)
+#define SATA_INTMR				(SATA_AHBHOST_BASE + 0x0000007c)
+#define SATA_ERRMR				(SATA_AHBHOST_BASE + 0x00000080)
+#define SATA_LLCR				(SATA_AHBHOST_BASE + 0x00000084)
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x00000088)
+#define SATA_PHYSR				(SATA_AHBHOST_BASE + 0x0000008c)
+#define SATA_RXBISTPD				(SATA_AHBHOST_BASE + 0x00000090)
+#define SATA_RXBISTD1				(SATA_AHBHOST_BASE + 0x00000094)
+#define SATA_RXBISTD2				(SATA_AHBHOST_BASE + 0x00000098)
+#define SATA_TXBISTPD				(SATA_AHBHOST_BASE + 0x0000009c)
+#define SATA_TXBISTD1				(SATA_AHBHOST_BASE + 0x000000a0)
+#define SATA_TXBISTD2				(SATA_AHBHOST_BASE + 0x000000a4)
+#define SATA_BISTCR				(SATA_AHBHOST_BASE + 0x000000a8)
+#define SATA_BISTFCTR				(SATA_AHBHOST_BASE + 0x000000ac)
+#define SATA_BISTSR				(SATA_AHBHOST_BASE + 0x000000b0)
+#define SATA_BISTDECR				(SATA_AHBHOST_BASE + 0x000000b4)
+#define SATA_TESTR				(SATA_AHBHOST_BASE + 0x000000f4)
+#define SATA_VERSIONR				(SATA_AHBHOST_BASE + 0x000000f8)
+#define SATA_IDR				(SATA_AHBHOST_BASE + 0x000000fc)
+
+
+#define SATA_DMACR_TXCHEN	(1<<0)
+#define SATA_DMACR_RXCHEN	(1<<1)
+
+/* Bit values for SATA_INTPR and SATA_INTMR */
+#define SATA_INT_DMAT		(1<<0)
+#define SATA_INT_NEWFP		(1<<1)
+#define SATA_INT_PMABORT	(1<<2)
+#define SATA_INT_ERR		(1<<3)
+#define SATA_INT_NEWBIST	(1<<4)
+
+#define SERROR_ERR_T	(1<<8)
+#define SERROR_ERR_C	(1<<9)
+#define SERROR_ERR_P	(1<<10)
+#define SERROR_ERR_E	(1<<11)
+
+#define SATA_FIS_SIZE	(8*1024)
+
+static u32 stm_sata_scr_read (struct ata_port *ap, unsigned int sc_reg);
+static void stm_sata_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val);
+
+/* Layout of a DMAC Linked List Item (LLI)
+ * DMAH_CH0_STAT_DST and DMAH_CH0_STAT_SRC are both 0 */
+struct stm_lli {
+	u32	sar;
+	u32	dar;
+	u32	llp;
+	u32	ctl0;
+	u32	ctl1;
+};
+
+struct stm_host_priv
+{
+	unsigned long phy_init;		/* Initial value for PHYCR */
+	int softsg;			/* If using softsg */
+};
+
+struct stm_port_priv
+{
+	struct stm_lli *lli;		/* Base of the allocated lli nodes */
+	dma_addr_t lli_dma;		/* Physical version of lli */
+	struct stm_lli *softsg_node;	/* Current softsg node */
+	struct stm_lli *softsg_end;	/* End of the softsg node */
+	char smallburst;		/* Small DMA burst size */
+};
+
+/* There is an undocumented restriction that DMA blocks must not span
+ * a FIS boundary. So to ensure we have enough LLIs to cope we restrict
+ * the maximum number of sectors, and assume a worst case of one
+ * LLI per sector.
+ */
+#define STM_MAX_SECTORS ATA_MAX_SECTORS
+#define STM_MAX_LLIS	ATA_MAX_SECTORS
+#define STM_LLI_BYTES	(STM_MAX_LLIS * sizeof(struct stm_lli))
+
+static void stm_phy_reset(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+	struct stm_host_priv *hpriv = ap->host->private_data;
+
+DPRINTK("ENTER\n");
+
+	/*
+	 * "sata1hostc Functional Specification" 1.4 defines the PHYCR as:
+	 * phy_ctrl[0]     sendalign
+	 * phy_ctrl[1]     at
+	 * phy_ctrl[4:2]   divdll[2:0]
+	 * phy_ctrl[6:5]   txslew[1:0]
+	 * phy_ctrl[8:7]   preemph[1:0]
+	 * phy_ctrl[10:9]  sdthres[1:0]
+	 * phy_ctrl[13:11] swing[2:0]
+	 * phy_ctrl[14]    recen
+	 * phy_ctrl[15]    ensigdet
+	 * phy_ctrl[16]    enasyncdetneg
+	 * phy_ctrl[17]    enasyncdetpos
+	 * phy_ctrl[18]    startcomzc
+	 * phy_ctrl[19]    startcomsr
+	 * phy_ctrl[24:20] iddqsub[4:0]
+	 * phy_ctrl[31:25] NOT DEFINED
+	 */
+	writel(hpriv->phy_init, mmio + SATA_PHYCR);
+        mdelay(100);
+
+	sata_phy_reset(ap);
+}
+
+/*
+ * We have two problems with the interface between the SATA and DMA
+ * controllers:
+ *  - it can only handle 32 bit quantities
+ *  - when reading from the device, if the data returned by the device
+ *    is short (ie less than the length programmed into the DMA engine),
+ *    and the end of the data doesn't coincide with a DMA burst boundary,
+ *    then the DMA will stall, and as a result the end of transfer
+ *    interrupt will never be seen.
+ */
+static int stm_check_atapi_dma(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct stm_port_priv *pp = ap->private_data;
+	u8 *scsicmd = qc->scsicmd->cmnd;
+
+	/* Whitelist commands that may use DMA. */
+	switch (scsicmd[0]) {
+	case WRITE_12:
+	case WRITE_10:
+	case WRITE_6:
+	case READ_12:
+	case READ_10:
+	case READ_6:
+		/* All data is multiples of 2048 */
+		pp->smallburst = 0;
+		return 0;
+	case 0xbe:	/* READ_CD */
+		/* Data should be a multiple of four bytes */
+		pp->smallburst = 1;
+		return 0;
+	}
+
+	return 1;
+}
+
+static void stm_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct stm_port_priv *pp = ap->private_data;
+	struct stm_host_priv *hpriv = ap->host->private_data;
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+	u32 cfg0, cfg1;
+
+	cfg0 =	DMA_CFG_CH_PRIOR_0		|
+		DMA_CFG_HS_SEL_DST_HW		|
+		DMA_CFG_HS_SEL_SRC_HW		|
+		DMA_CFG_DST_HS_POL_HI		|
+		DMA_CFG_SRC_HS_POL_HI		|
+		DMA_CFG_MAX_ABRST_UNLIMITED;
+
+	cfg1 =	DMA_CFG_1_FIFO_MODE		|
+		DMA_CFG_1_SRC_PER_0		| /* Used on reads */
+		DMA_CFG_1_DEST_PER_1;		  /* Used on writes */
+
+	writel(cfg0, mmio + DMAC_CFG0_0);
+	writel(cfg1, mmio + DMAC_CFG0_1);
+
+	/* These reads also have the side effect of flushing any posted
+	 * writes to the LLI's */
+	writel(pp->lli->ctl0, mmio + DMAC_CTL0_0);
+	writel(pp->lli->ctl1, mmio + DMAC_CTL0_1);
+
+	if (hpriv->softsg) {
+		/* Write the first node into the DMAC registers */
+		writel(pp->lli->sar, mmio + DMAC_SAR0);
+		writel(pp->lli->dar, mmio + DMAC_DAR0);
+
+		/* Clear interrupt from the final SG node of the
+		 * previous transfer */
+		writel(1<<0, mmio + DMAC_CLEARTFR);
+
+		/* If there are multiple nodes in the sg list, prepare
+		 * to set up subsequent ones in the interrupt handler.
+		 */
+		if (pp->softsg_node != pp->softsg_end) {
+			pp->softsg_node++;
+			writel(1<<8 | 1<<0, mmio + DMAC_MASKTFR);
+		}
+	} else {
+		writel(pp->lli_dma, mmio + DMAC_LLP0);
+	}
+
+	/* Set Rx and Tx FIFO threshholds to 16 DWORDS except if using
+	 * small burst reads, when we set it to 1 DWORD.
+	 * Note: this is reset by a COMRESET.
+	 */
+	if (pp->smallburst) {
+		writel((0x1 << 16) | (0x10 << 0), mmio + SATA_DBTSR);
+	} else {
+		writel((0x10 << 16) | (0x10 << 0), mmio + SATA_DBTSR);
+	}
+
+	/* Enable DMA on the SATA host */
+	writel(SATA_DMACR_TXCHEN | SATA_DMACR_RXCHEN,
+	       mmio + SATA_DMACR);
+
+DPRINTK("SAR %08lx, DAR %08lx, CTL0 %08lx CTL1 %08lx\n",
+       readl(mmio + DMAC_SAR0),
+       readl(mmio + DMAC_DAR0),
+       readl(mmio + DMAC_CTL0_0),
+       readl(mmio + DMAC_CTL0_1));
+DPRINTK("CFG0 %08lx CFG1 %08lx\n",
+       readl(mmio + DMAC_CFG0_0),
+       readl(mmio + DMAC_CFG0_1));
+DPRINTK("ChEnReg %08lx DmaCfgReg %08lx\n",
+       readl(mmio + DMAC_ChEnReg),
+       readl(mmio + DMAC_DmaCfgReg));
+
+
+	/* Enable channel 0 */
+	wmb();
+	writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+
+	/* issue r/w command */
+	ata_exec_command(ap, &qc->tf);
+}
+
+static void stm_bmdma_start(struct ata_queued_cmd *qc)
+{
+
+#if 0
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+	struct ata_port *ap = qc->ap;
+	/* Enable channel 0 */
+	writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+#endif
+}
+
+static void stm_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+
+DPRINTK("ENTER\n");
+
+	/*
+	 * Chanel is automatically disabled on completion of DMA, however
+	 * this also gets called from the timeout handler.
+	 */
+
+	/* Disable channel 0 */
+	writel((1<<8) | (0<<0), mmio + DMAC_ChEnReg);
+
+	/* Disable DMA on the SATA host */
+	writel(0, mmio + SATA_DMACR);
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_altstatus(ap);        /* dummy read */
+}
+
+static u8 stm_bmdma_status(struct ata_port *ap)
+{
+	/* We should be checking here whether the current interrupt
+	 * was raised by this SATA host. Unfortuntaly we have no
+	 * visibility of the controller's Interrupt Pending Flag (IPF).
+	 */
+	return ATA_DMA_INTR;
+}
+
+static void stm_fill_sg(struct ata_queued_cmd *qc)
+{
+	struct scatterlist *sg;
+	struct ata_port *ap = qc->ap;
+	struct stm_host_priv *hpriv = ap->host->private_data;
+        struct stm_port_priv *pp = ap->private_data;
+	unsigned int write = (qc->tf.flags & ATA_TFLAG_WRITE);
+	unsigned int idx;
+	u32 sar, dar, ctl0;
+	u32 fis_offset;
+
+	DPRINTK("ENTER\n");
+
+	WARN_ON(qc->__sg == NULL);
+	WARN_ON(qc->n_elem == 0 && qc->pad_len == 0);
+
+	ctl0 = 	DMAC_CTL_DST_TR_WIDTH_32	|
+		DMAC_CTL_SRC_TR_WIDTH_32	|
+		DMAC_CTL_DINC_INC		|
+		DMAC_CTL_SINC_INC;
+
+	if (write) {
+		/* memory (master1) to SATA host (master2) transfer */
+		ctl0 |= DMAC_CTL_DEST_MSIZE_4		|
+			DMAC_CTL_SRC_MSIZE_16		|
+			DMAC_CTL_TT_FC_M2P_DMAC		|
+			DMAC_CTL_DMS_2			|
+			DMAC_CTL_SMS_1;
+	} else {
+		/* SATA host (master2) to memory (master1) transfer */
+		ctl0 |= DMAC_CTL_DEST_MSIZE_16		|
+			(pp->smallburst ?
+				DMAC_CTL_SRC_MSIZE_1 :
+				DMAC_CTL_SRC_MSIZE_16)	|
+			DMAC_CTL_TT_FC_P2M_DMAC		|
+			DMAC_CTL_DMS_1			|
+			DMAC_CTL_SMS_2;
+	}
+
+	if (! hpriv->softsg) {
+		ctl0 |= DMAC_CTL_LLP_DST_EN	|
+			DMAC_CTL_LLP_SRC_EN;
+	}
+
+	idx = 0;
+	sar = dar = 0;
+	fis_offset = 0;
+	ata_for_each_sg(sg, qc) {
+		u32 addr;
+		u32 sg_len, len;
+
+		addr = sg_dma_address(sg);
+		sg_len = sg_dma_len(sg);
+
+		WARN_ON(sg_len & 3);
+
+		while (sg_len) {
+			/* Ensure no DMA block crosses a FIS boundary */
+			len = sg_len;
+			if (len + fis_offset > SATA_FIS_SIZE)
+				len = SATA_FIS_SIZE - fis_offset;
+
+			/* SATA host (master2) has a hardwired address of
+			 * DMADR, so leave the address set to 0. */
+			if (write) {
+				sar = addr;
+			} else {
+				dar = addr;
+			}
+
+			pp->lli[idx].sar = sar;
+			pp->lli[idx].dar = dar;
+			pp->lli[idx].llp = pp->lli_dma +
+				(sizeof(struct stm_lli) * (idx+1));
+			pp->lli[idx].ctl0 = ctl0;
+			pp->lli[idx].ctl1 = len >> 2;
+
+			DPRINTK("lli: %p: SAR %08x, DAR %08x, CTL0 %08x CTL1 %08x\n",
+				&pp->lli[idx],
+				pp->lli[idx].sar, pp->lli[idx].dar,
+				pp->lli[idx].ctl0, pp->lli[idx].ctl1);
+
+			idx++;
+			BUG_ON(idx >= STM_MAX_LLIS);
+			sg_len -= len;
+			addr += len;
+			fis_offset = (fis_offset + len) % SATA_FIS_SIZE;
+		}
+	}
+
+	WARN_ON(idx == 0);
+	pp->lli[idx-1].llp = 0;
+
+	if (hpriv->softsg) {
+		pp->softsg_node = pp->lli;
+		pp->softsg_end  = &pp->lli[idx-1];
+	}
+
+}
+
+static void stm_qc_prep(struct ata_queued_cmd *qc)
+{
+	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
+		return;
+
+	stm_fill_sg(qc);
+}
+
+static void stm_data_xfer(struct ata_device *adev, unsigned char *buf,
+		           unsigned int buflen, int write_data)
+{
+	struct ata_port *ap = adev->ap;
+	unsigned int i;
+	unsigned int words = buflen >> 1;
+	u16 *buf16 = (u16 *) buf;
+	void __iomem *mmio_base = (void __iomem *) ap->ioaddr.cmd_addr;
+	void __iomem *mmio = (void __iomem *)ap->ioaddr.data_addr;
+
+	/* Disable error reporting */
+	writel(~SERROR_ERR_E, mmio_base + SATA_ERRMR);
+
+	/* Transfer multiple of 2 bytes */
+	if (write_data) {
+		for (i = 0; i < words; i++) {
+			writew(le16_to_cpu(buf16[i]), mmio);
+			ndelay(120);
+		}
+	} else {
+		for (i = 0; i < words; i++) {
+			buf16[i] = cpu_to_le16(readw(mmio));
+			ndelay(120);
+		}
+	}
+
+	/* Transfer trailing 1 byte, if any. */
+	if (unlikely(buflen & 0x01)) {
+		u16 align_buf[1] = { 0 };
+		unsigned char *trailing_buf = buf + buflen - 1;
+
+		if (write_data) {
+			memcpy(align_buf, trailing_buf, 1);
+			writew(le16_to_cpu(align_buf[0]), mmio);
+		} else {
+			align_buf[0] = cpu_to_le16(readw(mmio));
+			memcpy(trailing_buf, align_buf, 1);
+		}
+	}
+
+	/* Clear any errors and re-enable error reporting */
+	writel(-1, mmio_base + SATA_SCR1);
+	writel(0xffffffff, mmio_base + SATA_ERRMR);
+}
+
+static unsigned long error_count;
+static unsigned int print_error=1;
+
+static irqreturn_t stm_sata_interrupt(int irq, void *dev_instance)
+{
+	struct ata_host *host = dev_instance;
+	unsigned int handled = 0;
+	unsigned int i;
+	unsigned long flags;
+
+DPRINTK("ENTER\n");
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+		void __iomem *mmio = ap->ioaddr.cmd_addr;
+
+		if (readl(mmio + DMAC_STATUSTFR) & 1) {
+			/* DMA Transfer complete update soft S/G */
+			struct stm_port_priv *pp = ap->private_data;
+
+			/* Ack the interrupt */
+			writel(1<<0, mmio + DMAC_CLEARTFR);
+
+			DPRINTK("softsg_node %p, end %p\n", pp->softsg_node, pp->softsg_end);
+
+			writel(pp->softsg_node->sar, mmio + DMAC_SAR0);
+			writel(pp->softsg_node->dar, mmio + DMAC_DAR0);
+
+			writel(pp->softsg_node->ctl0, mmio + DMAC_CTL0_0);
+			writel(pp->softsg_node->ctl1, mmio + DMAC_CTL0_1);
+
+			if (pp->softsg_node != pp->softsg_end) {
+				pp->softsg_node++;
+			} else {
+				writel(1<<8 | 0<<0, mmio + DMAC_MASKTFR);
+			}
+
+			writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+		} else
+		if (readl(mmio + DMAC_RAWERR) & 1) {
+			printk("DMA error asserted\n");
+		} else
+		if (readl(mmio + SATA_INTPR) & (SATA_INT_ERR)) {
+			/* Error code set in SError */
+			if (print_error) {
+				printk("%s: SStatus 0x%08x, SError 0x%08x\n", __FUNCTION__,
+				       stm_sata_scr_read(ap, SCR_STATUS),
+				       stm_sata_scr_read(ap, SCR_ERROR));
+			}
+			error_count++;
+			stm_sata_scr_write(ap, SCR_ERROR, -1);
+			handled = 1;
+		} else
+		if (ap && (!(ap->flags & ATA_FLAG_DISABLED))) {
+			struct ata_queued_cmd *qc;
+
+			qc = ata_qc_from_tag(ap, ap->active_tag);
+			if (qc && (!(qc->tf.ctl & ATA_NIEN)))
+				handled += ata_host_intr(ap, qc);
+		}
+
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static void stm_irq_clear(struct ata_port *ap)
+{
+	/* TODO */
+}
+
+
+static u32 stm_sata_scr_read (struct ata_port *ap, unsigned int sc_reg)
+{
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+	u32 val;
+
+	if (sc_reg > SCR_CONTROL)
+		return 0xffffffffU;
+
+	val = readl(mmio + SATA_SCR0 + (sc_reg * 4));
+	return val;
+}
+
+static void stm_sata_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val)
+{
+	void __iomem *mmio = ap->ioaddr.cmd_addr;
+
+DPRINTK("%d = %08x\n", sc_reg, val);
+	if (sc_reg > SCR_CONTROL)
+		return;
+
+	writel(val, mmio + SATA_SCR0 + (sc_reg * 4));
+}
+
+static int stm_port_start (struct ata_port *ap)
+{
+	struct device *dev = ap->host->dev;
+	struct stm_host_priv *hpriv = ap->host->private_data;
+	struct stm_port_priv *pp;
+	int rc;
+
+	pp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);
+	if (pp == NULL)
+		return -ENOMEM;
+
+	if (hpriv->softsg) {
+		pp->lli = devm_kzalloc(dev, STM_LLI_BYTES, GFP_KERNEL);
+	} else {
+		pp->lli = dmam_alloc_coherent(dev, STM_LLI_BYTES, &pp->lli_dma,
+					      GFP_KERNEL);
+	}
+
+	if (pp->lli == NULL)
+		return -ENOMEM;
+
+	pp->smallburst = 0;
+
+	rc = ata_pad_alloc(ap, dev);
+	if (rc)
+		return rc;
+
+	ap->private_data = pp;
+
+	return 0;
+}
+
+static ssize_t stm_show_serror(struct class_device *class_dev, char *buf)
+{
+	//struct Scsi_Host *host = class_to_shost(class_dev);
+	ssize_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%ld\n", error_count);
+	return len;
+}
+
+static ssize_t stm_store_serror(struct class_device * class_dev,
+			       const char * buf, size_t count)
+{
+	// struct Scsi_Host *host = class_to_shost(class_dev);
+
+	error_count = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+
+static struct class_device_attribute stm_host_stats_attr = {
+	.attr = {
+		.name =		"serror",
+		.mode =		S_IRUGO | S_IWUGO,
+	},
+	.show = stm_show_serror,
+	.store = stm_store_serror,
+};
+
+static ssize_t stm_show_printerror(struct class_device *class_dev, char *buf)
+{
+	//struct Scsi_Host *host = class_to_shost(class_dev);
+	ssize_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%d\n", print_error);
+	return len;
+}
+
+static ssize_t stm_store_printerror(struct class_device * class_dev,
+			       const char * buf, size_t count)
+{
+	// struct Scsi_Host *host = class_to_shost(class_dev);
+
+	print_error = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+
+static struct class_device_attribute stm_host_printerror_attr = {
+	.attr = {
+		.name =		"printerror",
+		.mode =		S_IRUGO | S_IWUGO,
+	},
+	.show = stm_show_printerror,
+	.store = stm_store_printerror,
+};
+
+/* Host attributes initializer */
+static struct class_device_attribute *stm_host_attrs[] = {
+	&stm_host_stats_attr,
+	&stm_host_printerror_attr,
+	NULL,
+};
+
+static struct scsi_host_template stm_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= STM_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
+	.bios_param		= ata_std_bios_param,
+	.shost_attrs		= stm_host_attrs,
+};
+
+static struct ata_port_operations stm_ops = {
+	.port_disable		= ata_port_disable,
+	.tf_load		= ata_tf_load,
+	.tf_read		= ata_tf_read,
+	.exec_command		= ata_exec_command,
+	.check_status		= ata_check_status,
+	.dev_select		= ata_noop_dev_select,
+	.phy_reset		= stm_phy_reset,
+	.check_atapi_dma	= stm_check_atapi_dma,
+	.bmdma_setup		= stm_bmdma_setup,
+	.bmdma_start		= stm_bmdma_start,
+	.bmdma_stop		= stm_bmdma_stop,
+	.bmdma_status		= stm_bmdma_status,
+	.qc_prep		= stm_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+	.eng_timeout		= ata_eng_timeout, /* ?? */
+	.data_xfer		= stm_data_xfer,
+	.irq_handler		= stm_sata_interrupt,
+	.irq_clear		= stm_irq_clear,
+	.irq_on			= ata_dummy_irq_on,
+	.scr_read		= stm_sata_scr_read,
+	.scr_write		= stm_sata_scr_write,
+	.port_start		= stm_port_start,
+};
+
+static const struct ata_port_info stm_port_info = {
+	.flags		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
+			  ATA_FLAG_MMIO | ATA_FLAG_SATA_RESET,
+	.pio_mask	= 0x1f, /* pio0-4 */
+	.mwdma_mask	= 0x07, /* mwdma0-2 */
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &stm_ops,
+};
+
+static unsigned char stm_readb(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static unsigned short stm_readw(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static void stm_writeb(unsigned char b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
+static void stm_writew(unsigned short b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
+static int __devinit stm_sata_probe(struct platform_device *pdev)
+{
+	struct plat_sata_data *sata_private_info = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct resource *mem_res;
+	unsigned long phys_base, phys_size;
+	void __iomem *mmio_base;
+	const struct ata_port_info *ppi[] = { &stm_port_info, NULL };
+	struct ata_host *host;
+	struct ata_port *ap;
+	struct stm_host_priv *hpriv = NULL;
+	unsigned long sata_rev, dmac_rev;
+
+	printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	host = ata_host_alloc_pinfo(dev, ppi, 1);
+	if (!host)
+		return -ENOMEM;
+
+	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+
+        host->private_data = hpriv;
+
+	mem_res = platform_get_resource(pdev,IORESOURCE_MEM,0);
+	phys_base = mem_res->start;
+	phys_size = mem_res->end - mem_res->start + 1;
+
+	if (!devm_request_mem_region(dev, phys_base, phys_size, "STM SATA"))
+		return -EBUSY;
+
+	mmio_base = devm_ioremap(dev, phys_base, phys_size);
+	if (mmio_base == NULL)
+		return ENOMEM;
+
+	/* Set up the ports */
+	ap = host->ports[0];
+	ap->ioaddr.cmd_addr		= mmio_base;
+	ap->ioaddr.data_addr		= mmio_base + SATA_CDR0;
+	ap->ioaddr.error_addr		= mmio_base + SATA_CDR1;
+	ap->ioaddr.feature_addr		= mmio_base + SATA_CDR1;
+	ap->ioaddr.nsect_addr		= mmio_base + SATA_CDR2;
+	ap->ioaddr.lbal_addr		= mmio_base + SATA_CDR3;
+	ap->ioaddr.lbam_addr		= mmio_base + SATA_CDR4;
+	ap->ioaddr.lbah_addr		= mmio_base + SATA_CDR5;
+	ap->ioaddr.device_addr		= mmio_base + SATA_CDR6;
+	ap->ioaddr.status_addr		= mmio_base + SATA_CDR7;
+	ap->ioaddr.command_addr		= mmio_base + SATA_CDR7;
+
+	ap->ioaddr.altstatus_addr	= mmio_base + SATA_CLR0;
+	ap->ioaddr.ctl_addr		= mmio_base + SATA_CLR0;
+
+	hpriv->phy_init = sata_private_info->phy_init;
+	hpriv->softsg = readl(mmio_base + DMAC_COMP_PARAMS_2) &
+		DMAC_COMP_PARAMS_2_CH0_HC_LLP;
+	//hpriv->softsg = 1;
+
+	printk(KERN_DEBUG DRV_NAME " using %sware scatter/gather\n",
+	       hpriv->softsg ? "soft" : "hard");
+
+	if (sata_private_info->only_32bit) {
+		printk(KERN_DEBUG DRV_NAME " forcing all byte/word ops to long\n");
+		stm_ops.readb = stm_readb;
+		stm_ops.readw = stm_readw;
+		stm_ops.writeb = stm_writeb;
+		stm_ops.writew = stm_writew;
+	}
+
+	sata_rev = readl(mmio_base + SATA_VERSIONR);
+	dmac_rev = readl(mmio_base + DMAC_COMP_VERSION);
+	printk(KERN_DEBUG DRV_NAME " SATA version %c.%c%c DMA version %c.%c%c\n",
+	       (int)(sata_rev >> 24) & 0xff,
+	       (int)(sata_rev >> 16) & 0xff,
+	       (int)(sata_rev >>  8) & 0xff,
+	       (int)(dmac_rev >> 24) & 0xff,
+	       (int)(dmac_rev >> 16) & 0xff,
+	       (int)(dmac_rev >>  8) & 0xff);
+
+	/* AHB bus wrapper setup */
+
+        // SATA_AHB2STBUS_STBUS_OPC
+        // 2:0  -- 100 = Store64/Load64
+        // 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	/* opcode = Load4 |Store 4*/
+	writel(3, mmio_base + SATA_AHB2STBUS_STBUS_OPC);
+
+        // SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+        // 3:0  -- 0111 = 128 Packets
+        // 3:0  -- 0110 =  64 Packets
+	/* WAS: Message size = 64 packet when 6 now 3*/
+	writel(3, mmio_base + SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+        // SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+        // 3:0  -- 0110 = 64 Packets
+        // 3:0  -- 0001 =  2 Packets
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(2, mmio_base + SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+        // PC_GLUE_LOGIC
+        // 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+        // 8    -- 1  = Time out enabled
+	// (has bit 8 moved to bit 16 on 7109 cut2?)
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+	writel(sata_private_info->pc_glue_logic_init,
+		mmio_base + SATA_PC_GLUE_LOGIC);
+
+	/* DMA controller set up */
+
+	/* Enable DMA controller */
+	writel(DMAC_DmaCfgReg_DMA_EN, mmio_base + DMAC_DmaCfgReg);
+
+	/* SATA host controller set up */
+
+	/* Clear serror register following probe, and before we enable
+	 * interrupts! */
+	/* scr_write(ap, SCR_ERROR, -1); */
+	writel(-1, mmio_base + SATA_SCR1);
+
+	/* Enable notification of errors */
+	writel(0xffffffff, mmio_base + SATA_ERRMR);
+	writel(SATA_INT_ERR, mmio_base + SATA_INTMR);
+
+	/* Finished hardware set up */
+
+	return ata_host_activate(host, platform_get_irq(pdev, 0),
+				 stm_sata_interrupt,
+				 IRQF_SHARED, &stm_sht);
+}
+
+static int stm_sata_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver stm_sata_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = stm_sata_probe,
+	.remove = stm_sata_remove,
+};
+
+static int __init stm_sata_init(void)
+{
+	return platform_driver_register(&stm_sata_driver);
+}
+
+static void __exit stm_sata_exit(void)
+{
+	platform_driver_unregister(&stm_sata_driver);
+}
+
+module_init(stm_sata_init);
+module_exit(stm_sata_exit);
+
+MODULE_AUTHOR("Stuart Menefy");
+MODULE_DESCRIPTION("low-level driver for STMicroelectronics SATA");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/block/pktcdvd.c linux-2.6.23.1-stm/drivers/block/pktcdvd.c
--- linux-2.6.23.1/drivers/block/pktcdvd.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/block/pktcdvd.c	2007-11-01 12:00:41.000000000 +0000
@@ -822,7 +822,7 @@
 {
 	struct packet_command cgc;
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_FLUSH_CACHE;
 	cgc.quiet = 1;
 
@@ -845,7 +845,7 @@
 	struct request_sense sense;
 	int ret;
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.sense = &sense;
 	cgc.cmd[0] = GPCMD_SET_SPEED;
 	cgc.cmd[2] = (read_speed >> 8) & 0xff;
@@ -1715,13 +1715,15 @@
 	return pkt_generic_packet(pd, cgc);
 }
 
-static int pkt_get_disc_info(struct pktcdvd_device *pd, disc_information *di)
+static int pkt_get_disc_info(struct pktcdvd_device *pd, disc_information *dip)
 {
-	struct packet_command cgc;
-	int ret;
+	DECLARE_PACKET_COMMAND(cgc);
+	int ret, buflen;
+	disc_information* di;
 
 	/* set up command and get the disc info */
-	init_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);
+	init_cdrom_command(&cgc, sizeof(*di), CGC_DATA_READ);
+	di = (disc_information*)cgc.buffer;
 	cgc.cmd[0] = GPCMD_READ_DISC_INFO;
 	cgc.cmd[8] = cgc.buflen = 2;
 	cgc.quiet = 1;
@@ -1732,22 +1734,29 @@
 	/* not all drives have the same disc_info length, so requeue
 	 * packet with the length the drive tells us it can supply
 	 */
-	cgc.buflen = be16_to_cpu(di->disc_information_length) +
+	buflen = be16_to_cpu(di->disc_information_length) +
 		     sizeof(di->disc_information_length);
 
-	if (cgc.buflen > sizeof(disc_information))
-		cgc.buflen = sizeof(disc_information);
+	if (buflen > sizeof(disc_information))
+		buflen = sizeof(disc_information);
 
-	cgc.cmd[8] = cgc.buflen;
-	return pkt_generic_packet(pd, &cgc);
+	cgc.cmd[8] = cgc.buflen = buflen;
+	if ((ret = pkt_generic_packet(pd, &cgc)))
+		return ret;
+
+	memcpy(dip, di, buflen);
+
+	return ret;
 }
 
-static int pkt_get_track_info(struct pktcdvd_device *pd, __u16 track, __u8 type, track_information *ti)
+static int pkt_get_track_info(struct pktcdvd_device *pd, __u16 track, __u8 type, track_information *tip)
 {
-	struct packet_command cgc;
-	int ret;
+	DECLARE_PACKET_COMMAND(cgc);
+	int ret, buflen;
+	track_information *ti;
 
-	init_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);
+	init_cdrom_command(&cgc, 8, CGC_DATA_READ);
+	ti = (track_information*)cgc.buffer;
 	cgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;
 	cgc.cmd[1] = type & 3;
 	cgc.cmd[4] = (track & 0xff00) >> 8;
@@ -1758,14 +1767,18 @@
 	if ((ret = pkt_generic_packet(pd, &cgc)))
 		return ret;
 
-	cgc.buflen = be16_to_cpu(ti->track_information_length) +
+	buflen = be16_to_cpu(ti->track_information_length) +
 		     sizeof(ti->track_information_length);
 
-	if (cgc.buflen > sizeof(track_information))
-		cgc.buflen = sizeof(track_information);
+	if (buflen > sizeof(track_information))
+		buflen = sizeof(track_information);
 
-	cgc.cmd[8] = cgc.buflen;
-	return pkt_generic_packet(pd, &cgc);
+	cgc.cmd[8] = cgc.buflen = buflen;
+	if ((ret = pkt_generic_packet(pd, &cgc)))
+		return ret;
+
+	memcpy(tip, ti, buflen);
+	return ret;
 }
 
 static int pkt_get_last_written(struct pktcdvd_device *pd, long *last_written)
@@ -1807,33 +1820,33 @@
  */
 static int pkt_set_write_settings(struct pktcdvd_device *pd)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct request_sense sense;
 	write_param_page *wp;
-	char buffer[128];
 	int ret, size;
 
 	/* doesn't apply to DVD+RW or DVD-RAM */
 	if ((pd->mmc3_profile == 0x1a) || (pd->mmc3_profile == 0x12))
 		return 0;
 
-	memset(buffer, 0, sizeof(buffer));
-	init_cdrom_command(&cgc, buffer, sizeof(*wp), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 128, CGC_DATA_READ);
 	cgc.sense = &sense;
 	if ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WRITE_PARMS_PAGE, 0))) {
 		pkt_dump_sense(&cgc);
 		return ret;
 	}
 
-	size = 2 + ((buffer[0] << 8) | (buffer[1] & 0xff));
-	pd->mode_offset = (buffer[6] << 8) | (buffer[7] & 0xff);
-	if (size > sizeof(buffer))
-		size = sizeof(buffer);
+	size = 2 + ((cgc.buffer[0] << 8) | (cgc.buffer[1] & 0xff));
+	pd->mode_offset = (cgc.buffer[6] << 8) | (cgc.buffer[7] & 0xff);
+	if (size > cgc.buflen)
+		size = cgc.buflen;
+
+	cleanup_cdrom_command(&cgc);
 
 	/*
 	 * now get it all
 	 */
-	init_cdrom_command(&cgc, buffer, size, CGC_DATA_READ);
+	init_cdrom_command(&cgc, size, CGC_DATA_READ);
 	cgc.sense = &sense;
 	if ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WRITE_PARMS_PAGE, 0))) {
 		pkt_dump_sense(&cgc);
@@ -1843,7 +1856,7 @@
 	/*
 	 * write page is offset header + block descriptor length
 	 */
-	wp = (write_param_page *) &buffer[sizeof(struct mode_page_header) + pd->mode_offset];
+	wp = (write_param_page *) &cgc.buffer[sizeof(struct mode_page_header) + pd->mode_offset];
 
 	wp->fp = pd->settings.fp;
 	wp->track_mode = pd->settings.track_mode;
@@ -1966,17 +1979,16 @@
 
 static int pkt_probe_settings(struct pktcdvd_device *pd)
 {
-	struct packet_command cgc;
-	unsigned char buf[12];
+	DECLARE_PACKET_COMMAND(cgc);
 	disc_information di;
 	track_information ti;
 	int ret, track;
 
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 12, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
 	cgc.cmd[8] = 8;
 	ret = pkt_generic_packet(pd, &cgc);
-	pd->mmc3_profile = ret ? 0xffff : buf[6] << 8 | buf[7];
+	pd->mmc3_profile = ret ? 0xffff : cgc.buffer[6] << 8 | cgc.buffer[7];
 
 	memset(&di, 0, sizeof(disc_information));
 	memset(&ti, 0, sizeof(track_information));
@@ -2065,13 +2077,11 @@
  */
 static int pkt_write_caching(struct pktcdvd_device *pd, int set)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct request_sense sense;
-	unsigned char buf[64];
 	int ret;
 
-	memset(buf, 0, sizeof(buf));
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 64, CGC_DATA_READ);
 	cgc.sense = &sense;
 	cgc.buflen = pd->mode_offset + 12;
 
@@ -2083,9 +2093,9 @@
 	if ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WCACHING_PAGE, 0)))
 		return ret;
 
-	buf[pd->mode_offset + 10] |= (!!set << 2);
+	cgc.buffer[pd->mode_offset + 10] |= (!!set << 2);
 
-	cgc.buflen = cgc.cmd[8] = 2 + ((buf[0] << 8) | (buf[1] & 0xff));
+	cgc.buflen = cgc.cmd[8] = 2 + ((cgc.buffer[0] << 8) | (cgc.buffer[1] & 0xff));
 	ret = pkt_mode_select(pd, &cgc);
 	if (ret) {
 		printk(DRIVER_NAME": write caching control failed\n");
@@ -2097,9 +2107,9 @@
 
 static int pkt_lock_door(struct pktcdvd_device *pd, int lockflag)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL;
 	cgc.cmd[4] = lockflag ? 1 : 0;
 	return pkt_generic_packet(pd, &cgc);
@@ -2110,15 +2120,13 @@
  */
 static int pkt_get_max_speed(struct pktcdvd_device *pd, unsigned *write_speed)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct request_sense sense;
-	unsigned char buf[256+18];
 	unsigned char *cap_buf;
 	int ret, offset;
 
-	memset(buf, 0, sizeof(buf));
-	cap_buf = &buf[sizeof(struct mode_page_header) + pd->mode_offset];
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_UNKNOWN);
+	init_cdrom_command(&cgc, 256+18, CGC_DATA_UNKNOWN);
+	cap_buf = &cgc.buffer[sizeof(struct mode_page_header) + pd->mode_offset];
 	cgc.sense = &sense;
 
 	ret = pkt_mode_sense(pd, &cgc, GPMODE_CAPABILITIES_PAGE, 0);
@@ -2171,13 +2179,12 @@
  */
 static int pkt_media_speed(struct pktcdvd_device *pd, unsigned *speed)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct request_sense sense;
-	unsigned char buf[64];
 	unsigned int size, st, sp;
 	int ret;
 
-	init_cdrom_command(&cgc, buf, 2, CGC_DATA_READ);
+	init_cdrom_command(&cgc, 2, CGC_DATA_READ);
 	cgc.sense = &sense;
 	cgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;
 	cgc.cmd[1] = 2;
@@ -2188,11 +2195,11 @@
 		pkt_dump_sense(&cgc);
 		return ret;
 	}
-	size = ((unsigned int) buf[0]<<8) + buf[1] + 2;
-	if (size > sizeof(buf))
-		size = sizeof(buf);
+	size = ((unsigned int) cgc.buffer[0]<<8) + cgc.buffer[1] + 2;
+	if (size > 64)
+		size = 64;
 
-	init_cdrom_command(&cgc, buf, size, CGC_DATA_READ);
+	init_cdrom_command(&cgc, size, CGC_DATA_READ);
 	cgc.sense = &sense;
 	cgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;
 	cgc.cmd[1] = 2;
@@ -2204,18 +2211,18 @@
 		return ret;
 	}
 
-	if (!buf[6] & 0x40) {
+	if (!cgc.buffer[6] & 0x40) {
 		printk(DRIVER_NAME": Disc type is not CD-RW\n");
 		return 1;
 	}
-	if (!buf[6] & 0x4) {
+	if (!cgc.buffer[6] & 0x4) {
 		printk(DRIVER_NAME": A1 values on media are not valid, maybe not CDRW?\n");
 		return 1;
 	}
 
-	st = (buf[6] >> 3) & 0x7; /* disc sub-type */
+	st = (cgc.buffer[6] >> 3) & 0x7; /* disc sub-type */
 
-	sp = buf[16] & 0xf; /* max speed from ATIP A1 field */
+	sp = cgc.buffer[16] & 0xf; /* max speed from ATIP A1 field */
 
 	/* Info from cdrecord */
 	switch (st) {
@@ -2243,13 +2250,13 @@
 
 static int pkt_perform_opc(struct pktcdvd_device *pd)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct request_sense sense;
 	int ret;
 
 	VPRINTK(DRIVER_NAME": Performing OPC\n");
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.sense = &sense;
 	cgc.timeout = 60*HZ;
 	cgc.cmd[0] = GPCMD_SEND_OPC;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/cdrom/cdrom.c linux-2.6.23.1-stm/drivers/cdrom/cdrom.c
--- linux-2.6.23.1/drivers/cdrom/cdrom.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/cdrom/cdrom.c	2007-11-01 12:00:41.000000000 +0000
@@ -481,27 +481,27 @@
 int cdrom_get_media_event(struct cdrom_device_info *cdi,
 			  struct media_event_desc *med)
 {
-	struct packet_command cgc;
-	unsigned char buffer[8];
-	struct event_header *eh = (struct event_header *) buffer;
+	DECLARE_PACKET_COMMAND(cgc);
+	struct event_header *eh;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 8, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;
 	cgc.cmd[1] = 1;		/* IMMED */
 	cgc.cmd[4] = 1 << 4;	/* media event */
-	cgc.cmd[8] = sizeof(buffer);
+	cgc.cmd[8] = cgc.buflen;/* sizeof(buffer); */
 	cgc.quiet = 1;
 
 	if (cdi->ops->generic_packet(cdi, &cgc))
 		return 1;
 
+	eh = (struct event_header *) cgc.buffer;
 	if (be16_to_cpu(eh->data_len) < sizeof(*med))
 		return 1;
 
 	if (eh->nea || eh->notification_class != 0x4)
 		return 1;
 
-	memcpy(med, &buffer[sizeof(*eh)], sizeof(*med));
+	memcpy(med, &cgc.buffer[sizeof(*eh)], sizeof(*med));
 	return 0;
 }
 
@@ -511,10 +511,9 @@
  */
 static int cdrom_mrw_probe_pc(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
-	char buffer[16];
+	DECLARE_PACKET_COMMAND(cgc);
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 16, CGC_DATA_READ);
 
 	cgc.timeout = HZ;
 	cgc.quiet = 1;
@@ -532,24 +531,23 @@
 
 static int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct mrw_feature_desc *mfd;
-	unsigned char buffer[16];
 	int ret;
 
 	*write = 0;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 16, CGC_DATA_READ);
 
 	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
 	cgc.cmd[3] = CDF_MRW;
-	cgc.cmd[8] = sizeof(buffer);
+	cgc.cmd[8] = cgc.buflen; /* sizeof(buffer); */
 	cgc.quiet = 1;
 
 	if ((ret = cdi->ops->generic_packet(cdi, &cgc)))
 		return ret;
 
-	mfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];
+	mfd = (struct mrw_feature_desc *)&cgc.buffer[sizeof(struct feature_header)];
 	if (be16_to_cpu(mfd->feature_code) != CDF_MRW)
 		return 1;
 	*write = mfd->write;
@@ -564,8 +562,7 @@
 
 static int cdrom_mrw_bgformat(struct cdrom_device_info *cdi, int cont)
 {
-	struct packet_command cgc;
-	unsigned char buffer[12];
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret;
 
 	printk(KERN_INFO "cdrom: %sstarting format\n", cont ? "Re" : "");
@@ -573,7 +570,7 @@
 	/*
 	 * FmtData bit set (bit 4), format type is 1
 	 */
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_WRITE);
+	init_cdrom_command(&cgc, 12, CGC_DATA_WRITE);
 	cgc.cmd[0] = GPCMD_FORMAT_UNIT;
 	cgc.cmd[1] = (1 << 4) | 1;
 
@@ -582,19 +579,19 @@
 	/*
 	 * 4 byte format list header, 8 byte format list descriptor
 	 */
-	buffer[1] = 1 << 1;
-	buffer[3] = 8;
+	cgc.buffer[1] = 1 << 1;
+	cgc.buffer[3] = 8;
 
 	/*
 	 * nr_blocks field
 	 */
-	buffer[4] = 0xff;
-	buffer[5] = 0xff;
-	buffer[6] = 0xff;
-	buffer[7] = 0xff;
+	cgc.buffer[4] = 0xff;
+	cgc.buffer[5] = 0xff;
+	cgc.buffer[6] = 0xff;
+	cgc.buffer[7] = 0xff;
 
-	buffer[8] = 0x24 << 2;
-	buffer[11] = cont;
+	cgc.buffer[8] = 0x24 << 2;
+	cgc.buffer[11] = cont;
 
 	ret = cdi->ops->generic_packet(cdi, &cgc);
 	if (ret)
@@ -605,9 +602,9 @@
 
 static int cdrom_mrw_bgformat_susp(struct cdrom_device_info *cdi, int immed)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_CLOSE_TRACK;
 
 	/*
@@ -623,9 +620,9 @@
 
 static int cdrom_flush_cache(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_FLUSH_CACHE;
 
 	cgc.timeout = 5 * 60 * HZ;
@@ -657,24 +654,20 @@
 
 static int cdrom_mrw_set_lba_space(struct cdrom_device_info *cdi, int space)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct mode_page_header *mph;
-	char buffer[16];
 	int ret, offset, size;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
-
-	cgc.buffer = buffer;
-	cgc.buflen = sizeof(buffer);
+	init_cdrom_command(&cgc, 16, CGC_DATA_READ);
 
 	if ((ret = cdrom_mode_sense(cdi, &cgc, cdi->mrw_mode_page, 0)))
 		return ret;
 
-	mph = (struct mode_page_header *) buffer;
+	mph = (struct mode_page_header *) cgc.buffer;
 	offset = be16_to_cpu(mph->desc_length);
 	size = be16_to_cpu(mph->mode_data_length) + 2;
 
-	buffer[offset + 3] = space;
+	cgc.buffer[offset + 3] = space;
 	cgc.buflen = size;
 
 	if ((ret = cdrom_mode_select(cdi, &cgc)))
@@ -687,42 +680,40 @@
 static int cdrom_get_random_writable(struct cdrom_device_info *cdi,
 			      struct rwrt_feature_desc *rfd)
 {
-	struct packet_command cgc;
-	char buffer[24];
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 24, CGC_DATA_READ);
 
 	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;	/* often 0x46 */
 	cgc.cmd[3] = CDF_RWRT;			/* often 0x0020 */
-	cgc.cmd[8] = sizeof(buffer);		/* often 0x18 */
+	cgc.cmd[8] = cgc.buflen;		/* often 0x18 */
 	cgc.quiet = 1;
 
 	if ((ret = cdi->ops->generic_packet(cdi, &cgc)))
 		return ret;
 
-	memcpy(rfd, &buffer[sizeof(struct feature_header)], sizeof (*rfd));
+	memcpy(rfd, &cgc.buffer[sizeof(struct feature_header)], sizeof (*rfd));
 	return 0;
 }
 
 static int cdrom_has_defect_mgt(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
-	char buffer[16];
+	DECLARE_PACKET_COMMAND(cgc);
 	__be16 *feature_code;
 	int ret;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 16, CGC_DATA_READ);
 
 	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
 	cgc.cmd[3] = CDF_HWDM;
-	cgc.cmd[8] = sizeof(buffer);
+	cgc.cmd[8] = cgc.buflen; /* sizeof(buffer); */
 	cgc.quiet = 1;
 
 	if ((ret = cdi->ops->generic_packet(cdi, &cgc)))
 		return ret;
 
-	feature_code = (__be16 *) &buffer[sizeof(struct feature_header)];
+	feature_code = (__be16 *) &cgc.buffer[sizeof(struct feature_header)];
 	if (be16_to_cpu(*feature_code) == CDF_HWDM)
 		return 0;
 
@@ -816,11 +807,11 @@
 
 static int mo_open_write(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
-	char buffer[255];
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret;
 
-	init_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);
+	init_cdrom_command(&cgc, 255, CGC_DATA_READ);
+	cgc.buflen = 4;
 	cgc.quiet = 1;
 
 	/*
@@ -840,7 +831,7 @@
 	if (ret)
 		return 0;
 
-	return buffer[3] & 0x80;
+	return cgc.buffer[3] & 0x80;
 }
 
 static int cdrom_ram_open_write(struct cdrom_device_info *cdi)
@@ -862,22 +853,21 @@
 
 static void cdrom_mmc3_profile(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
-	char buffer[32];
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret, mmc3_profile;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 32, CGC_DATA_READ);
 
 	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
 	cgc.cmd[1] = 0;
 	cgc.cmd[2] = cgc.cmd[3] = 0;		/* Starting Feature Number */
-	cgc.cmd[8] = sizeof(buffer);		/* Allocation Length */
+	cgc.cmd[8] = cgc.buflen;		/* Allocation Length */
 	cgc.quiet = 1;
 
 	if ((ret = cdi->ops->generic_packet(cdi, &cgc)))
 		mmc3_profile = 0xffff;
 	else
-		mmc3_profile = (buffer[6] << 8) | buffer[7];
+		mmc3_profile = (cgc.buffer[6] << 8) | cgc.buffer[7];
 
 	cdi->mmc3_profile = mmc3_profile;
 }
@@ -942,7 +932,7 @@
 
 static void cdrom_dvd_rw_close_write(struct cdrom_device_info *cdi)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 
 	if (cdi->mmc3_profile != 0x1a) {
 		cdinfo(CD_CLOSE, "%s: No DVD+RW\n", cdi->name);
@@ -957,18 +947,18 @@
 	printk(KERN_INFO "cdrom: %s: dirty DVD+RW media, \"finalizing\"\n",
 	       cdi->name);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_FLUSH_CACHE;
 	cgc.timeout = 30*HZ;
 	cdi->ops->generic_packet(cdi, &cgc);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_CLOSE_TRACK;
 	cgc.timeout = 3000*HZ;
 	cgc.quiet = 1;
 	cdi->ops->generic_packet(cdi, &cgc);
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_CLOSE_TRACK;
 	cgc.cmd[2] = 2;	 /* Close session */
 	cgc.quiet = 1;
@@ -1246,9 +1236,10 @@
 static int cdrom_read_mech_status(struct cdrom_device_info *cdi, 
 				  struct cdrom_changer_info *buf)
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
-	int length;
+	unsigned int length;
+	int ret;
 
 	/*
 	 * Sanyo changer isn't spec compliant (doesn't use regular change
@@ -1268,11 +1259,14 @@
 	length = sizeof(struct cdrom_mechstat_header) +
 		 cdi->capacity * sizeof(struct cdrom_slot);
 
-	init_cdrom_command(&cgc, buf, length, CGC_DATA_READ);
+	init_cdrom_command(&cgc, length, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_MECHANISM_STATUS;
 	cgc.cmd[8] = (length >> 8) & 0xff;
 	cgc.cmd[9] = length & 0xff;
-	return cdo->generic_packet(cdi, &cgc);
+	ret = cdo->generic_packet(cdi, &cgc);
+	if (ret == 0)
+		memcpy(buf, cgc.buffer, max(length, sizeof(*buf)));
+	return ret;
 }
 
 static int cdrom_slot_status(struct cdrom_device_info *cdi, int slot)
@@ -1329,13 +1323,13 @@
 /* If SLOT < 0, unload the current slot.  Otherwise, try to load SLOT. */
 static int cdrom_load_unload(struct cdrom_device_info *cdi, int slot) 
 {
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 
 	cdinfo(CD_CHANGER, "entering cdrom_load_unload()\n"); 
 	if (cdi->sanyo_slot && slot < 0)
 		return 0;
 
-	init_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);
+	init_cdrom_command(&cgc, 0, CGC_DATA_NONE);
 	cgc.cmd[0] = GPCMD_LOAD_UNLOAD;
 	cgc.cmd[4] = 2 + (slot >= 0);
 	cgc.cmd[8] = slot;
@@ -1529,16 +1523,25 @@
 	*curr = requested;
 }
 
-void init_cdrom_command(struct packet_command *cgc, void *buf, int len,
-			int type)
+int init_cdrom_command(struct packet_command *cgc, int len, int type)
 {
 	memset(cgc, 0, sizeof(struct packet_command));
-	if (buf)
-		memset(buf, 0, len);
-	cgc->buffer = (char *) buf;
+	if (len) {
+		cgc->buffer = kzalloc(len, GFP_KERNEL);
+		if (cgc->buffer == NULL)
+			return -ENOMEM;
+	}
 	cgc->buflen = len;
 	cgc->data_direction = type;
 	cgc->timeout = CDROM_DEF_TIMEOUT;
+
+	return 0;
+}
+
+void cleanup_cdrom_command(struct packet_command *cgc)
+{
+	if (cgc->buffer)
+		kfree(cgc->buffer);
 }
 
 /* DVD handling */
@@ -1593,13 +1596,12 @@
 static int dvd_do_auth(struct cdrom_device_info *cdi, dvd_authinfo *ai)
 {
 	int ret;
-	u_char buf[20];
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
-	rpc_state_t rpc_state;
+	rpc_state_t *rpc_state;
 
-	memset(buf, 0, sizeof(buf));
-	init_cdrom_command(&cgc, buf, 0, CGC_DATA_READ);
+	init_cdrom_command(&cgc, 20, CGC_DATA_READ);
+	cgc.buflen = 0;
 
 	switch (ai->type) {
 	/* LU data send */
@@ -1611,7 +1613,7 @@
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		ai->lsa.agid = buf[7] >> 6;
+		ai->lsa.agid = cgc.buffer[7] >> 6;
 		/* Returning data, let host change state */
 		break;
 
@@ -1622,7 +1624,7 @@
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		copy_key(ai->lsk.key, &buf[4]);
+		copy_key(ai->lsk.key, &cgc.buffer[4]);
 		/* Returning data, let host change state */
 		break;
 
@@ -1633,7 +1635,7 @@
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		copy_chal(ai->lsc.chal, &buf[4]);
+		copy_chal(ai->lsc.chal, &cgc.buffer[4]);
 		/* Returning data, let host change state */
 		break;
 
@@ -1650,10 +1652,10 @@
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		ai->lstk.cpm = (buf[4] >> 7) & 1;
-		ai->lstk.cp_sec = (buf[4] >> 6) & 1;
-		ai->lstk.cgms = (buf[4] >> 4) & 3;
-		copy_key(ai->lstk.title_key, &buf[5]);
+		ai->lstk.cpm = (cgc.buffer[4] >> 7) & 1;
+		ai->lstk.cp_sec = (cgc.buffer[4] >> 6) & 1;
+		ai->lstk.cgms = (cgc.buffer[4] >> 4) & 3;
+		copy_key(ai->lstk.title_key, &cgc.buffer[5]);
 		/* Returning data, let host change state */
 		break;
 
@@ -1664,15 +1666,15 @@
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		ai->lsasf.asf = buf[7] & 1;
+		ai->lsasf.asf = cgc.buffer[7] & 1;
 		break;
 
 	/* LU data receive (LU changes state) */
 	case DVD_HOST_SEND_CHALLENGE:
 		cdinfo(CD_DVD, "entering DVD_HOST_SEND_CHALLENGE\n"); 
 		setup_send_key(&cgc, ai->hsc.agid, 1);
-		buf[1] = 0xe;
-		copy_chal(&buf[4], ai->hsc.chal);
+		cgc.buffer[1] = 0xe;
+		copy_chal(&cgc.buffer[4], ai->hsc.chal);
 
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
@@ -1683,8 +1685,8 @@
 	case DVD_HOST_SEND_KEY2:
 		cdinfo(CD_DVD, "entering DVD_HOST_SEND_KEY2\n"); 
 		setup_send_key(&cgc, ai->hsk.agid, 3);
-		buf[1] = 0xa;
-		copy_key(&buf[4], ai->hsk.key);
+		cgc.buffer[1] = 0xa;
+		copy_key(&cgc.buffer[4], ai->hsk.key);
 
 		if ((ret = cdo->generic_packet(cdi, &cgc))) {
 			ai->type = DVD_AUTH_FAILURE;
@@ -1706,25 +1708,24 @@
 	case DVD_LU_SEND_RPC_STATE:
 		cdinfo(CD_DVD, "entering DVD_LU_SEND_RPC_STATE\n");
 		setup_report_key(&cgc, 0, 8);
-		memset(&rpc_state, 0, sizeof(rpc_state_t));
-		cgc.buffer = (char *) &rpc_state;
+		rpc_state = (rpc_state_t*)cgc.buffer;
 
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
 
-		ai->lrpcs.type = rpc_state.type_code;
-		ai->lrpcs.vra = rpc_state.vra;
-		ai->lrpcs.ucca = rpc_state.ucca;
-		ai->lrpcs.region_mask = rpc_state.region_mask;
-		ai->lrpcs.rpc_scheme = rpc_state.rpc_scheme;
+		ai->lrpcs.type = rpc_state->type_code;
+		ai->lrpcs.vra = rpc_state->vra;
+		ai->lrpcs.ucca = rpc_state->ucca;
+		ai->lrpcs.region_mask = rpc_state->region_mask;
+		ai->lrpcs.rpc_scheme = rpc_state->rpc_scheme;
 		break;
 
 	/* Set region settings */
 	case DVD_HOST_SEND_RPC_STATE:
 		cdinfo(CD_DVD, "entering DVD_HOST_SEND_RPC_STATE\n");
 		setup_send_key(&cgc, 0, 6);
-		buf[1] = 6;
-		buf[4] = ai->hrpcs.pdrc;
+		cgc.buffer[1] = 6;
+		cgc.buffer[4] = ai->hrpcs.pdrc;
 
 		if ((ret = cdo->generic_packet(cdi, &cgc)))
 			return ret;
@@ -1740,16 +1741,16 @@
 
 static int dvd_read_physical(struct cdrom_device_info *cdi, dvd_struct *s)
 {
-	unsigned char buf[21], *base;
+	unsigned char *base;
 	struct dvd_layer *layer;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
 	int ret, layer_num = s->physical.layer_num;
 
 	if (layer_num >= DVD_LAYERS)
 		return -EINVAL;
 
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 21, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[6] = layer_num;
 	cgc.cmd[7] = s->type;
@@ -1763,7 +1764,7 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 
-	base = &buf[4];
+	base = &cgc.buffer[4];
 	layer = &s->physical.layer[layer_num];
 
 	/*
@@ -1791,11 +1792,10 @@
 static int dvd_read_copyright(struct cdrom_device_info *cdi, dvd_struct *s)
 {
 	int ret;
-	u_char buf[8];
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
 
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 8, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[6] = s->copyright.layer_num;
 	cgc.cmd[7] = s->type;
@@ -1805,8 +1805,8 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 
-	s->copyright.cpst = buf[4];
-	s->copyright.rmi = buf[5];
+	s->copyright.cpst = cgc.buffer[4];
+	s->copyright.rmi = cgc.buffer[5];
 
 	return 0;
 }
@@ -1814,16 +1814,12 @@
 static int dvd_read_disckey(struct cdrom_device_info *cdi, dvd_struct *s)
 {
 	int ret, size;
-	u_char *buf;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
 
 	size = sizeof(s->disckey.value) + 4;
 
-	if ((buf = kmalloc(size, GFP_KERNEL)) == NULL)
-		return -ENOMEM;
-
-	init_cdrom_command(&cgc, buf, size, CGC_DATA_READ);
+	init_cdrom_command(&cgc, size, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[7] = s->type;
 	cgc.cmd[8] = size >> 8;
@@ -1831,20 +1827,18 @@
 	cgc.cmd[10] = s->disckey.agid << 6;
 
 	if (!(ret = cdo->generic_packet(cdi, &cgc)))
-		memcpy(s->disckey.value, &buf[4], sizeof(s->disckey.value));
+		memcpy(s->disckey.value, &cgc.buffer[4], sizeof(s->disckey.value));
 
-	kfree(buf);
 	return ret;
 }
 
 static int dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s)
 {
 	int ret;
-	u_char buf[4 + 188];
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
 
-	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	init_cdrom_command(&cgc, 4 + 188, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[7] = s->type;
 	cgc.cmd[9] = cgc.buflen & 0xff;
@@ -1852,12 +1846,12 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 
-	s->bca.len = buf[0] << 8 | buf[1];
+	s->bca.len = cgc.buffer[0] << 8 | cgc.buffer[1];
 	if (s->bca.len < 12 || s->bca.len > 188) {
 		cdinfo(CD_WARNING, "Received invalid BCA length (%d)\n", s->bca.len);
 		return -EIO;
 	}
-	memcpy(s->bca.value, &buf[4], s->bca.len);
+	memcpy(s->bca.value, &cgc.buffer[4], s->bca.len);
 
 	return 0;
 }
@@ -1865,36 +1859,29 @@
 static int dvd_read_manufact(struct cdrom_device_info *cdi, dvd_struct *s)
 {
 	int ret = 0, size;
-	u_char *buf;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	struct cdrom_device_ops *cdo = cdi->ops;
 
 	size = sizeof(s->manufact.value) + 4;
 
-	if ((buf = kmalloc(size, GFP_KERNEL)) == NULL)
-		return -ENOMEM;
-
-	init_cdrom_command(&cgc, buf, size, CGC_DATA_READ);
+	init_cdrom_command(&cgc, size, CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[7] = s->type;
 	cgc.cmd[8] = size >> 8;
 	cgc.cmd[9] = size & 0xff;
 
-	if ((ret = cdo->generic_packet(cdi, &cgc))) {
-		kfree(buf);
+	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
-	}
 
-	s->manufact.len = buf[0] << 8 | buf[1];
+	s->manufact.len = cgc.buffer[0] << 8 | cgc.buffer[1];
 	if (s->manufact.len < 0 || s->manufact.len > 2048) {
 		cdinfo(CD_WARNING, "Received invalid manufacture info length"
 				   " (%d)\n", s->manufact.len);
 		ret = -EIO;
 	} else {
-		memcpy(s->manufact.value, &buf[4], s->manufact.len);
+		memcpy(s->manufact.value, &cgc.buffer[4], s->manufact.len);
 	}
 
-	kfree(buf);
 	return ret;
 }
 
@@ -1958,11 +1945,11 @@
 				 struct cdrom_subchnl *subchnl, int mcn)
 {
 	struct cdrom_device_ops *cdo = cdi->ops;
-	struct packet_command cgc;
-	char buffer[32];
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret;
 
-	init_cdrom_command(&cgc, buffer, 16, CGC_DATA_READ);
+	init_cdrom_command(&cgc, 32, CGC_DATA_READ);
+	cgc.buflen = 16;
 	cgc.cmd[0] = GPCMD_READ_SUBCHANNEL;
 	cgc.cmd[1] = 2;     /* MSF addressing */
 	cgc.cmd[2] = 0x40;  /* request subQ data */
@@ -3092,13 +3079,15 @@
 }
 
 static int cdrom_get_track_info(struct cdrom_device_info *cdi, __u16 track, __u8 type,
-			 track_information *ti)
+			 track_information *tip)
 {
 	struct cdrom_device_ops *cdo = cdi->ops;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret, buflen;
+	track_information *ti;
 
-	init_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);
+	init_cdrom_command(&cgc, sizeof(track_information), CGC_DATA_READ);
+	cgc.buflen = 8;
 	cgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;
 	cgc.cmd[1] = type & 3;
 	cgc.cmd[4] = (track & 0xff00) >> 8;
@@ -3109,6 +3098,7 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 	
+	ti = (track_information*)cgc.buffer;
 	buflen = be16_to_cpu(ti->track_information_length) +
 		     sizeof(ti->track_information_length);
 
@@ -3119,19 +3109,24 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 
+	memcpy(tip, ti, buflen);
+
 	/* return actual fill size */
 	return buflen;
 }
 
 /* requires CD R/RW */
-static int cdrom_get_disc_info(struct cdrom_device_info *cdi, disc_information *di)
+static int cdrom_get_disc_info(struct cdrom_device_info *cdi,
+			       disc_information *dip)
 {
 	struct cdrom_device_ops *cdo = cdi->ops;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	int ret, buflen;
+	disc_information* di;
 
 	/* set up command and get the disc info */
-	init_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);
+	init_cdrom_command(&cgc, sizeof(*di), CGC_DATA_READ);
+	di = (disc_information*)cgc.buffer;
 	cgc.cmd[0] = GPCMD_READ_DISC_INFO;
 	cgc.cmd[8] = cgc.buflen = 2;
 	cgc.quiet = 1;
@@ -3152,6 +3147,8 @@
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
 
+	memcpy(dip, di, buflen);
+
 	/* return actual fill size */
 	return buflen;
 }
@@ -3279,6 +3276,7 @@
 EXPORT_SYMBOL(cdrom_mode_select);
 EXPORT_SYMBOL(cdrom_mode_sense);
 EXPORT_SYMBOL(init_cdrom_command);
+EXPORT_SYMBOL(cleanup_cdrom_command);
 EXPORT_SYMBOL(cdrom_get_media_event);
 
 #ifdef CONFIG_SYSCTL
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/Kconfig linux-2.6.23.1-stm/drivers/char/Kconfig
--- linux-2.6.23.1/drivers/char/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/Kconfig	2007-11-01 12:00:43.000000000 +0000
@@ -630,6 +630,8 @@
 	  which will also be compiled when this driver is built as a
 	  module.
 
+source "drivers/char/lirc/Kconfig"
+
 source "drivers/char/ipmi/Kconfig"
 
 source "drivers/char/watchdog/Kconfig"
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/Makefile linux-2.6.23.1-stm/drivers/char/Makefile
--- linux-2.6.23.1/drivers/char/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -7,7 +7,7 @@
 #
 FONTMAPFILE = cp437.uni
 
-obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o
+obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o lirc/
 
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/Kconfig linux-2.6.23.1-stm/drivers/char/lirc/Kconfig
--- linux-2.6.23.1/drivers/char/lirc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/Kconfig	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,285 @@
+# LIRC http://lirc.sf.net/
+# Kernel patch by Flameeyes <dgp85@users.sf.net>
+# Check for new patch at http://flameeyes.web.ctonet.it
+#
+# Thanks to Koos Vriezen <koos.vriezen@xs4all.nl> for the Homebrew support.
+# Thanks to Jeff Clark <jeff@tmtrading.com> for support when I wasn't able
+# to update it and for his patch (found at http://www.clarkmania.com/~jclark/
+# Thanks to Bernhard Rosenkraenzer <bero@arklinux.org> for SMP patch.
+# Thanks to Vince <fuzzy77@free.fr> for the temporary lirc_atiusb driver.
+# Thanks to Paul Miller <pmiller9@users.sourceforge.net> for the new working
+# lirc_atiusb driver.
+
+menu "Linux InfraRed Controller"
+
+config LIRC_SUPPORT
+	tristate "Linux InfraRed Controller"
+
+	config LIRC_I2C
+		tristate "I2C Driver"
+		depends on LIRC_SUPPORT && VIDEO_BT848 && I2C && I2C_ALGOBIT
+		help
+		  Say Y here if you need support for the following cards:
+
+		  Pixelview IR
+		  Hauppauage IR
+		  PV951 IR
+		  TV-Box IR
+		  KNC ONE IR
+		  Asus TV-Box and Creative
+		  VisionTek BreakOut-Box
+		  Leadtek Winfast PVR2000
+
+		  If these dont make sense to you, then dont use the module.
+
+	config LIRC_GPIO
+		tristate "GPIO Driver"
+		depends on LIRC_SUPPORT && VIDEO_BT848
+		help
+		  TV-card remote control support for bttv based systems:
+		    AverMedia
+		    BestBuy
+		    Winfast TV2000
+		    I-O Data GV-BCTV5/PCI
+
+	config LIRC_BT829
+		tristate "BT829 Driver"
+		depends on LIRC_SUPPORT
+		help
+		  TV-card remote control support for BT829 based systems
+
+	config LIRC_IT87
+		tristate "IT87 Driver"
+		depends on LIRC_SUPPORT
+		help
+		  ITE IT8705 and IT8712(not tested) CIR-port support
+
+	config LIRC_ATIUSB
+		tristate "ATI USB Driver"
+		depends on LIRC_SUPPORT && USB
+		help
+		  Use this driver if you have an ATI X10 USB remote
+		  or an ATI Remote Wonder or ATI Remote Wonder II
+
+	config LIRC_MCEUSB
+		tristate "MCE USB Driver"
+		depends on LIRC_SUPPORT && USB
+		help
+		  USB Microsoft IR Transceiver driver
+
+	config LIRC_MCEUSB2
+		tristate "MCE USB Driver"
+		depends on LIRC_SUPPORT && USB
+		help
+		  LIRC driver for the Philips eHome USB Infrared
+		  Transciever and the Microsoft MCE 2005 Remote Control
+
+	config LIRC_STREAMZAP
+		tristate "Streamzap Driver"
+		depends on LIRC_SUPPORT
+		help
+		  Install this driver if you have a Streamzap Remote Control
+
+	config LIRC_IGORPLUGUSB
+		tristate "Igorplugusb Driver"
+		depends on LIRC_SUPPORT
+		help
+		  Install this driver if you have a homebrew IgorPlugUSB
+		  receiver
+
+	config LIRC_IMON
+		tristate "IMON LIRC/VFD Driver"
+		depends on LIRC_SUPPORT
+		help
+		  Install this driver if you have an Ahanix/Soundgraph IMON
+		  IR receiver.  It also allows control of the VFD (display)
+
+	config LIRC_CMDIR
+		tristate "CMDIR Driver"
+		depends on LIRC_SUPPORT && USB
+		help
+		  Install this driver if you have an InnovationOne's
+		  COMMANDIR USB Transceiver
+
+	config LIRC_SASEM
+		tristate "Sasem Driver"
+		depends on LIRC_SUPPORT && USB
+		help
+		  This driver provides support for the USB Sasem Remote
+		  Controller V1.1
+
+	config LIRC_PARALLEL
+		tristate "Parallel Driver"
+		depends on LIRC_SUPPORT && !SMP && PARPORT
+
+		choice
+			prompt "Parallel Port"
+			depends on LIRC_PARALLEL
+			config LIRC_PARALLEL_LPT1
+				bool "LPT1 (0x378, 7)"
+			config LIRC_PARALLEL_LPT2
+				bool "LPT2 (0x278, 5)"
+			config LIRC_PARALLEL_LPT3
+				bool "COM3 (0x3bc, none)"
+			config LIRC_PARALLEL_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_PARALLEL
+			hex "I/O Port"
+				default "0x378" if LIRC_PARALLEL_LPT1
+				default "0x278" if LIRC_PARALLEL_LPT2
+				default "0x3bc" if LIRC_PARALLEL_LPT3
+			depends on LIRC_PARALLEL
+
+		config LIRC_IRQ_PARALLEL
+			hex "IRQ"
+				default "7" if LIRC_PARALLEL_LPT1
+				default "5" if LIRC_PARALLEL_LPT2
+			depends on LIRC_PARALLEL
+
+		config LIRC_TIMER
+			int "Timer"
+			default "65535"
+			depends on LIRC_PARALLEL
+
+	config LIRC_SERIAL
+		tristate "Serial Driver"
+		depends on LIRC_SUPPORT && SERIAL_8250
+
+		choice
+			prompt "Serial Receiver Type"
+			depends on LIRC_SERIAL
+
+			config LIRC_HOMEBREW
+				bool "Homebrew"
+
+			config LIRC_SERIAL_ANIMAX
+				bool "Animax"
+
+			config LIRC_SERIAL_IRDEO
+				bool "IRdeo"
+
+			config LIRC_SERIAL_IRDEO_REMOTE
+				bool "IRdeo Remote"
+
+			config LIRC_SERIAL_NSLU2
+				bool "NSLU2"
+
+			config LIRC_SERIAL_IGOR
+				bool "Igor Ceska's variation"
+
+		endchoice
+
+		config LIRC_SERIAL_TRANSMITTER
+			bool "With transmitter diode"
+			depends on LIRC_SERIAL && !LIRC_SERIAL_ANIMAX
+
+		config LIRC_SERIAL_SOFTCARRIER
+			bool "With software carrier"
+			depends on LIRC_SERIAL_TRANSMITTER
+
+		choice
+			prompt "Serial Port"
+			depends on LIRC_SERIAL
+			config LIRC_SERIAL_COM1
+				bool "COM1 (0x3f8, 4)"
+			config LIRC_SERIAL_COM2
+				bool "COM2 (0x2f8, 3)"
+			config LIRC_SERIAL_COM3
+				bool "COM3 (0x3e8, 4)"
+			config LIRC_SERIAL_COM4
+				bool "COM4 (0x2e8, 3)"
+			config LIRC_SERIAL_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_SERIAL
+			hex "I/O Port"
+				default "0x3f8" if LIRC_SERIAL_COM1
+				default "0x2f8" if LIRC_SERIAL_COM2
+				default "0x3e8" if LIRC_SERIAL_COM3
+				default "0x2e8" if LIRC_SERIAL_COM4
+			depends on LIRC_SERIAL
+
+		config LIRC_IRQ_SERIAL
+			hex "IRQ"
+				default "4" if LIRC_SERIAL_COM1 || LIRC_SERIAL_COM3
+				default "3" if LIRC_SERIAL_COM2 || LIRC_SERIAL_COM4
+			depends on LIRC_SERIAL
+
+	config LIRC_SIR
+		tristate "SIR Driver"
+		depends on LIRC_SUPPORT
+
+		config LIRC_ON_SA1100
+			bool "LIRC driver for StrongARM SA1100 embedded microprocessor"
+			depends on LIRC_SIR
+
+		choice
+			prompt "SIR Type"
+			depends on LIRC_SIR && !LIRC_ON_SA1100
+
+			config LIRC_SIR_IRDA
+				bool "SIR IrDA (built-in IR ports)"
+
+			config LIRC_SIR_TEKRAM
+				bool "Tekram Irmate 210 (16x50 UART compatible serial port)"
+
+			config LIRC_SIR_ACTISYS_ACT200L
+				bool "Actisys Act200L SIR driver support"
+
+		endchoice
+
+		choice
+			prompt "Serial Port"
+			depends on LIRC_SIR
+			config LIRC_SIR_COM1
+				bool "COM1 (0x3f8, 4)"
+			config LIRC_SIR_COM2
+				bool "COM2 (0x2f8, 3)"
+			config LIRC_SIR_COM3
+				bool "COM3 (0x3e8, 4)"
+			config LIRC_SIR_COM4
+				bool "COM4 (0x2e8, 3)"
+			config LIRC_SIR_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_SIR
+			hex "I/O Port"
+				default "0x3f8" if LIRC_SIR_COM1
+				default "0x2f8" if LIRC_SIR_COM2
+				default "0x3e8" if LIRC_SIR_COM3
+				default "0x2e8" if LIRC_SIR_COM4
+			depends on LIRC_SIR
+
+		config LIRC_IRQ_SIR
+			hex "IRQ"
+				default "4" if LIRC_SIR_COM1 || LIRC_SIR_COM3
+				default "3" if LIRC_SIR_COM2 || LIRC_SIR_COM4
+			depends on LIRC_SIR
+        config ST_LIRC
+                tristate "STM Lirc support"
+                depends on LIRC_SUPPORT && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB448 || SH_HMS1 || SH_ST_MB519)
+
+                choice
+                        prompt "Receiver type"
+                        depends on ST_LIRC
+			help
+			  The IRB and UHF are identical and indipendent, except
+			  that the IRB receiver does not use the noise filter.
+			  Not all the ST platforms support both type of receivers.
+
+                        config IRB_RECEIVER
+                        bool "IRB Receiver"
+			depends on ST_LIRC && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB448 || SH_HMS1 || SH_ST_MB519)
+
+                        config UHF_RECEIVER
+                        bool "UHF Receiver"
+			depends on ST_LIRC && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB519)
+
+                endchoice
+
+endmenu
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/Makefile linux-2.6.23.1-stm/drivers/char/lirc/Makefile
--- linux-2.6.23.1/drivers/char/lirc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,21 @@
+#
+# Makefile for the lirc drivers
+#
+
+obj-$(CONFIG_LIRC_SUPPORT) += lirc_dev.o
+obj-$(CONFIG_LIRC_ATIUSB) += lirc_atiusb.o
+obj-$(CONFIG_LIRC_BT829) += lirc_bt829.o
+obj-$(CONFIG_LIRC_CMDIR) += lirc_cmdir.o
+obj-$(CONFIG_LIRC_GPIO) += lirc_gpio.o
+obj-$(CONFIG_LIRC_I2C) += lirc_i2c.o
+obj-$(CONFIG_LIRC_IGORPLUGUSB) += lirc_igorplugusb.o
+obj-$(CONFIG_LIRC_IMON) += lirc_imon.o
+obj-$(CONFIG_LIRC_IT87) += lirc_it87.o
+obj-$(CONFIG_LIRC_MCEUSB2) += lirc_mceusb2.o
+obj-$(CONFIG_LIRC_MCEUSB) += lirc_mceusb.o
+obj-$(CONFIG_LIRC_PARALLEL) += lirc_parallel.o
+obj-$(CONFIG_LIRC_SASEM) += lirc_sasem.o
+obj-$(CONFIG_LIRC_SERIAL) += lirc_serial.o
+obj-$(CONFIG_LIRC_SIR) += lirc_sir.o
+obj-$(CONFIG_ST_LIRC) += lirc_stm.o
+obj-$(CONFIG_LIRC_STREAMZAP) += lirc_streamzap.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/kcompat.h linux-2.6.23.1-stm/drivers/char/lirc/kcompat.h
--- linux-2.6.23.1/drivers/char/lirc/kcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/kcompat.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,332 @@
+/*      $Id: kcompat.h,v 5.30 2007/01/02 21:45:08 lirc Exp $      */
+
+#ifndef _KCOMPAT_H
+#define _KCOMPAT_H
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#define LIRC_THIS_MODULE(x) x,
+#else /* >= 2.6.16 */
+#define LIRC_THIS_MODULE(x)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#include <linux/device.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#define LIRC_HAVE_DEVFS
+#define LIRC_HAVE_DEVFS_26
+#endif
+
+#define LIRC_HAVE_SYSFS
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+
+typedef struct class_simple lirc_class_t;
+
+static inline lirc_class_t *class_create(struct module *owner, char *name)
+{
+	return class_simple_create(owner, name);
+}
+
+static inline void class_destroy(lirc_class_t *cls)
+{
+	class_simple_destroy(cls);
+}
+
+#define lirc_class_device_create(cs, parent, dev, device, fmt, args...) \
+	class_simple_device_add(cs, dev, device, fmt, ## args)
+
+static inline void class_device_destroy(lirc_class_t *cls, dev_t devt)
+{
+	class_simple_device_remove(devt);
+}
+
+#else /* >= 2.6.13 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+
+#define lirc_class_device_create(cs, parent, dev, device, fmt, args...) \
+	class_device_create(cs, dev, device, fmt, ## args)
+
+#else /* >= 2.6.15 */
+
+#define lirc_class_device_create class_device_create
+#define LIRC_DEVFS_PREFIX
+
+#endif
+
+typedef struct class lirc_class_t;
+
+#endif
+
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#define LIRC_HAVE_DEVFS
+#define LIRC_HAVE_DEVFS_24
+#endif
+
+#ifndef LIRC_DEVFS_PREFIX
+#define LIRC_DEVFS_PREFIX "usb/"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+static inline void del_timer_sync(struct timer_list * timerlist)
+{
+	start_bh_atomic();
+	del_timer(timerlist);
+	end_bh_atomic();
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#ifdef daemonize
+#undef daemonize
+#endif
+#define daemonize(name) do {                                           \
+                                                                       \
+	lock_kernel();                                                 \
+	                                                               \
+	exit_mm(current);                                              \
+	exit_files(current);                                           \
+	exit_fs(current);                                              \
+	current->session = 1;                                          \
+	current->pgrp = 1;                                             \
+	current->euid = 0;                                             \
+	current->tty = NULL;                                           \
+	sigfillset(&current->blocked);                                 \
+	                                                               \
+	strcpy(current->comm, name);                                   \
+	                                                               \
+	unlock_kernel();                                               \
+                                                                       \
+} while (0)
+
+/* Not sure when this was introduced, sometime during 2.5.X */
+#define MODULE_PARM_int(x) MODULE_PARM(x, "i")
+#define MODULE_PARM_bool(x) MODULE_PARM(x, "i")
+#define MODULE_PARM_long(x) MODULE_PARM(x, "l")
+#define module_param(x,y,z) MODULE_PARM_##y(x)
+#else
+#include <linux/moduleparam.h>
+#endif /* Linux < 2.6.0 */
+
+/* DevFS header */
+#if defined(LIRC_HAVE_DEVFS)
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+#ifdef LIRC_HAVE_DEVFS_24
+#ifdef register_chrdev
+#undef register_chrdev
+#endif
+#define register_chrdev devfs_register_chrdev
+#ifdef unregister_chrdev
+#undef unregister_chrdev
+#endif
+#define unregister_chrdev devfs_unregister_chrdev
+#endif /* DEVFS 2.4 */
+
+#ifndef LIRC_HAVE_SYSFS
+#define class_destroy(x) do { } while(0)
+#define class_create(x,y) NULL
+#define class_device_destroy(x,y) do { } while(0)
+#define lirc_class_device_create(x, y, z, xx, yy, zz) 0
+#define IS_ERR(x) 0
+typedef struct class_simple 
+{
+	int notused;
+} lirc_class_t;	
+#endif /* No SYSFS */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+#define KERNEL_2_5
+
+/*
+ * We still are using MOD_INC_USE_COUNT/MOD_DEC_USE_COUNT in the set_use_inc 
+ * function of all modules for 2.4 kernel compatibility.
+ * 
+ * For 2.6 kernels reference counting is done in lirc_dev by 
+ * try_module_get()/module_put() because the old approach is racy.
+ * 
+ */
+#ifdef MOD_INC_USE_COUNT
+#undef MOD_INC_USE_COUNT
+#endif
+#define MOD_INC_USE_COUNT
+
+#ifdef MOD_DEC_USE_COUNT
+#undef MOD_DEC_USE_COUNT
+#endif
+#define MOD_DEC_USE_COUNT
+
+#ifdef EXPORT_NO_SYMBOLS
+#undef EXPORT_NO_SYMBOLS
+#endif
+#define EXPORT_NO_SYMBOLS
+
+#else  /* Kernel < 2.5.0 */
+
+static inline int try_module_get(struct module *module)
+{
+	return 1;
+}
+
+static inline void module_put(struct module *module)
+{
+}
+
+#endif /* Kernel >= 2.5.0 */
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(x)
+#endif
+
+#ifndef MODULE_PARM_DESC
+#define MODULE_PARM_DESC(x,y)
+#endif
+
+#ifndef MODULE_ALIAS_CHARDEV_MAJOR
+#define MODULE_ALIAS_CHARDEV_MAJOR(x)
+#endif
+
+#ifndef MODULE_DEVICE_TABLE
+#define MODULE_DEVICE_TABLE(x,y)
+#endif
+
+#include <linux/interrupt.h>
+#ifndef IRQ_RETVAL
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef MOD_IN_USE
+#ifdef CONFIG_MODULE_UNLOAD
+#define MOD_IN_USE module_refcount(THIS_MODULE)
+#else
+#error "LIRC modules currently require"
+#error "  'Loadable module support  --->  Module unloading'"
+#error "to be enabled in the kernel"
+#endif
+#endif
+
+#if !defined(local_irq_save)
+#define local_irq_save(flags) do{ save_flags(flags);cli(); } while(0)
+#endif
+#if !defined(local_irq_restore)
+#define local_irq_restore(flags) do{ restore_flags(flags); } while(0)
+#endif
+
+#if KERNEL_VERSION(2, 4, 0) <= LINUX_VERSION_CODE && LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 22)
+#include <linux/pci.h>
+static inline char *pci_name(struct pci_dev *pdev)
+{
+	return pdev->slot_name;
+}
+#endif // 2.4.0 <= kernel < 2.4.22
+
+/*************************** I2C specific *****************************/
+#include <linux/i2c.h>
+
+#ifndef I2C_CLIENT_END
+#error "********************************************************"
+#error " Sorry, this driver needs the new I2C stack.            "
+#error " You can get it at http://www2.lm-sensors.nu/~lm78/.    "
+#error "********************************************************"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+
+#undef i2c_get_clientdata
+#define i2c_get_clientdata(client) ((client)->data)
+
+
+#undef i2c_set_clientdata
+#define i2c_set_clientdata(client_ptr, new_data) do { \
+	(client_ptr)->data = new_data; \
+} while (0)
+
+
+#endif
+
+/* removed in 2.6.14 */
+#ifndef I2C_ALGO_BIT
+#   define I2C_ALGO_BIT 0
+#endif
+
+/* removed in 2.6.16 */
+#ifndef I2C_DRIVERID_EXP3
+#  define I2C_DRIVERID_EXP3 0xf003
+#endif
+
+/*************************** USB specific *****************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+#include <linux/usb.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 8)
+static inline int usb_kill_urb(struct urb *urb)
+{
+	return usb_unlink_urb(urb);
+}
+#endif
+
+/* removed in 2.6.14 */
+#ifndef URB_ASYNC_UNLINK
+#define URB_ASYNC_UNLINK 0  
+#endif
+#endif
+
+/*************************** bttv specific ****************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15) /* BTTV_* -> BTTV_BOARD_* */
+#define BTTV_BOARD_UNKNOWN         BTTV_UNKNOWN
+#define BTTV_BOARD_PXELVWPLTVPAK   BTTV_PXELVWPLTVPAK
+#define BTTV_BOARD_PXELVWPLTVPRO   BTTV_PXELVWPLTVPRO
+#define BTTV_BOARD_PV_BT878P_9B    BTTV_PV_BT878P_9B
+#define BTTV_BOARD_PV_BT878P_PLUS  BTTV_PV_BT878P_PLUS
+#define BTTV_BOARD_AVERMEDIA       BTTV_AVERMEDIA
+#define BTTV_BOARD_AVPHONE98       BTTV_AVPHONE98
+#define BTTV_BOARD_AVERMEDIA98     BTTV_AVERMEDIA98
+#define BTTV_BOARD_CHRONOS_VS2     BTTV_CHRONOS_VS2
+#define BTTV_BOARD_MIRO            BTTV_MIRO
+#define BTTV_BOARD_DYNALINK        BTTV_DYNALINK
+#define BTTV_BOARD_WINVIEW_601     BTTV_WINVIEW_601
+#ifdef BTTV_KWORLD
+#define BTTV_BOARD_KWORLD          BTTV_KWORLD
+#endif
+#define BTTV_BOARD_MAGICTVIEW061   BTTV_MAGICTVIEW061
+#define BTTV_BOARD_MAGICTVIEW063   BTTV_MAGICTVIEW063
+#define BTTV_BOARD_PHOEBE_TVMAS    BTTV_PHOEBE_TVMAS
+#ifdef BTTV_BESTBUY_EASYTV2
+#define BTTV_BOARD_BESTBUY_EASYTV  BTTV_BESTBUY_EASYTV
+#define BTTV_BOARD_BESTBUY_EASYTV2 BTTV_BESTBUY_EASYTV2
+#endif
+#define BTTV_BOARD_FLYVIDEO        BTTV_FLYVIDEO
+#define BTTV_BOARD_FLYVIDEO_98     BTTV_FLYVIDEO_98
+#define BTTV_BOARD_TYPHOON_TVIEW   BTTV_TYPHOON_TVIEW
+#ifdef BTTV_FLYVIDEO_98FM
+#define BTTV_BOARD_FLYVIDEO_98FM   BTTV_FLYVIDEO_98FM
+#endif
+#define BTTV_BOARD_WINFAST2000     BTTV_WINFAST2000
+#ifdef BTTV_GVBCTV5PCI
+#define BTTV_BOARD_GVBCTV5PCI      BTTV_GVBCTV5PCI
+#endif
+#endif  /* end BTTV_* -> BTTV_BOARD_* */
+
+
+/******************************* pm.h *********************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+typedef u32 pm_message_t;
+#endif
+
+#endif
+
+#endif /* _KCOMPAT_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_atiusb.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_atiusb.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_atiusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_atiusb.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1333 @@
+/* lirc_atiusb - USB remote support for LIRC
+ * (currently only supports X10 USB remotes)
+ * (supports ATI Remote Wonder and ATI Remote Wonder II, too)
+ *
+ * Copyright (C) 2003-2004 Paul Miller <pmiller9@users.sourceforge.net>
+ *
+ * This driver was derived from:
+ *   Vladimir Dergachev <volodya@minspring.com>'s 2002
+ *      "USB ATI Remote support" (input device)
+ *   Adrian Dewhurst <sailor-lk@sailorfrag.net>'s 2002
+ *      "USB StreamZap remote driver" (LIRC)
+ *   Artur Lipowski <alipowski@kki.net.pl>'s 2002
+ *      "lirc_dev" and "lirc_gpio" LIRC modules
+ *   Michael Wojciechowski
+ *      initial xbox support
+ *   Vassilis Virvilis <vasvir@iit.demokritos.gr> 2006
+ *      reworked the patch for lirc submission
+ *
+ * $Id: lirc_atiusb.c,v 1.61 2007/04/29 14:23:04 lirc Exp $
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.4.0 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/autoconf.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#define DRIVER_VERSION		"$Revision: 1.61 $"
+#define DRIVER_AUTHOR		"Paul Miller <pmiller9@users.sourceforge.net>"
+#define DRIVER_DESC		"USB remote driver for LIRC"
+#define DRIVER_NAME		"lirc_atiusb"
+
+#define CODE_LENGTH		code_length[ir->remote_type]
+#define CODE_MIN_LENGTH		code_min_length[ir->remote_type]
+#define DECODE_LENGTH		decode_length[ir->remote_type]
+
+#define RW2_MODENAV_KEYCODE	0x3F
+#define RW2_NULL_MODE		0xFF
+/* Fake (virtual) keycode indicating compass mouse usage */
+#define RW2_MOUSE_KEYCODE	0xFF
+#define RW2_PRESSRELEASE_KEYCODE	0xFE
+
+#define RW2_PRESS_CODE		1
+#define RW2_HOLD_CODE		2
+#define RW2_RELEASE_CODE	0
+
+/* module parameters */
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+// ATI, ATI2, XBOX
+static const int code_length[] = {5, 3, 6};
+static const int code_min_length[] = {3, 3, 6};
+static const int decode_length[] = {5, 3, 1};
+// USB_BUFF_LEN must be the maximum value of the code_length array.
+// It is used for static arrays.
+#define USB_BUFF_LEN 6
+
+static int mask = 0xFFFF;	// channel acceptance bit mask
+static int unique = 0;		// enable channel-specific codes
+static int repeat = 10;		// repeat time in 1/100 sec
+static int emit_updown = 0;	// send seperate press/release codes (rw2)
+static int emit_modekeys = 0;	// send keycodes for aux1-aux4, pc, and mouse (rw2)
+static unsigned long repeat_jiffies; // repeat timeout
+static int mdeadzone = 0;	// mouse sensitivity >= 0
+static int mgradient = 375;	// 1000*gradient from cardinal direction
+
+/* get hi and low bytes of a 16-bits int */
+#define HI(a)			((unsigned char)((a) >> 8))
+#define LO(a)			((unsigned char)((a) & 0xff))
+
+/* lock irctl structure */
+#define IRLOCK			down_interruptible(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* general constants */
+#define SUCCESS			0
+#define SEND_FLAG_IN_PROGRESS	1
+#define SEND_FLAG_COMPLETE	2
+#define FREE_ALL		0xFF
+
+/* endpoints */
+#define EP_KEYS			0
+#define EP_MOUSE		1
+#define EP_MOUSE_ADDR		0x81
+#define EP_KEYS_ADDR		0x82
+
+#define VENDOR_ATI1		0x0bc7
+#define VENDOR_ATI2		0x0471
+#define VENDOR_MS1		0x040b
+#define VENDOR_MS2		0x045e
+
+static struct usb_device_id usb_remote_table [] = {
+	{ USB_DEVICE(VENDOR_ATI1, 0x0002) },	/* X10 USB Firecracker Interface */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0003) },	/* X10 VGA Video Sender */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0004) },	/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0005) },	/* NVIDIA Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0006) },	/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0007) },	/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0008) },	/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0009) },	/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000A) },	/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000B) },	/* X10 USB Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000C) },	/* X10 USB Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000D) },	/* X10 USB Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000E) },	/* X10 USB Transceiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x000F) },	/* X10 USB Transceiver */
+
+	{ USB_DEVICE(VENDOR_ATI2, 0x0602) },	/* ATI Remote Wonder 2: Input Device */
+	{ USB_DEVICE(VENDOR_ATI2, 0x0603) },	/* ATI Remote Wonder 2: Controller (???) */
+
+	{ USB_DEVICE(VENDOR_MS1, 0x6521) }, /* Gamester Xbox DVD Movie Playback Kit IR */
+	{ USB_DEVICE(VENDOR_MS2, 0x0284) }, /* Microsoft Xbox DVD Movie Playback Kit IR */
+	{ }					/* Terminating entry */
+};
+
+
+/* init strings */
+#define USB_OUTLEN		7
+
+static char init1[] = {0x01, 0x00, 0x20, 0x14};
+static char init2[] = {0x01, 0x00, 0x20, 0x14, 0x20, 0x20, 0x20};
+
+
+
+struct in_endpt {
+	/* inner link in list of endpoints for the remote specified by ir */
+	struct list_head iep_list_link;
+	struct irctl *ir;
+	struct urb *urb;
+	struct usb_endpoint_descriptor *ep;
+	int type;
+
+	/* buffers and dma */
+	unsigned char *buf;
+	unsigned int len;
+#ifdef KERNEL_2_5
+	dma_addr_t dma;
+#endif
+
+	/* handle repeats */
+	unsigned char old[USB_BUFF_LEN];
+	unsigned long old_jiffies;
+};
+
+struct out_endpt {
+	struct irctl *ir;
+	struct urb *urb;
+	struct usb_endpoint_descriptor *ep;
+
+	/* buffers and dma */
+	unsigned char *buf;
+#ifdef KERNEL_2_5
+	dma_addr_t dma;
+#endif
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait;
+};
+
+
+/* data structure for each usb remote */
+struct irctl {
+	/* inner link in list of all remotes managed by this module */
+	struct list_head remote_list_link;
+	/* Number of usb interfaces associated with this device */
+	int dev_refcount;
+
+	/* usb */
+	struct usb_device *usbdev;
+	/* Head link to list of all inbound endpoints in this remote */
+	struct list_head iep_listhead;
+	struct out_endpt *out_init;
+	int devnum;
+
+	/* remote type based on usb_device_id tables */
+	enum {
+		ATI1_COMPATIBLE,
+		ATI2_COMPATIBLE,
+		XBOX_COMPATIBLE
+	} remote_type;
+
+	/* rw2 current mode (mirror's remote's state) */
+	int mode;
+
+	/* lirc */
+	struct lirc_plugin *p;
+	int connected;
+
+	/* locking */
+	struct semaphore lock;
+};
+
+/* list of all registered devices via the remote_list_link in irctl */
+static struct list_head remote_list;
+
+/* Convenience macros to retrieve a pointer to the surrounding struct from
+ * the given list_head reference within, pointed at by link. */
+#define get_iep_from_link(link)  list_entry((link), struct in_endpt, iep_list_link);
+#define get_irctl_from_link(link)  list_entry((link), struct irctl, remote_list_link);
+
+/* send packet - used to initialize remote */
+static void send_packet(struct out_endpt *oep, u16 cmd, unsigned char *data)
+{
+	struct irctl *ir = oep->ir;
+	DECLARE_WAITQUEUE(wait, current);
+	int timeout = HZ; /* 1 second */
+	unsigned char buf[USB_OUTLEN];
+
+	dprintk(DRIVER_NAME "[%d]: send called (%#x)\n", ir->devnum, cmd);
+
+	IRLOCK;
+	oep->urb->transfer_buffer_length = LO(cmd) + 1;
+	oep->urb->dev = oep->ir->usbdev;
+	oep->send_flags = SEND_FLAG_IN_PROGRESS;
+
+	memcpy(buf+1, data, LO(cmd));
+	buf[0] = HI(cmd);
+	memcpy(oep->buf, buf, LO(cmd)+1);
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&oep->wait, &wait);
+
+#ifdef KERNEL_2_5
+	if (usb_submit_urb(oep->urb, GFP_ATOMIC)) {
+#else
+	if (usb_submit_urb(oep->urb)) {
+#endif
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&oep->wait, &wait);
+		IRUNLOCK;
+		return;
+	}
+	IRUNLOCK;
+
+	while (timeout && (oep->urb->status == -EINPROGRESS)
+		&& !(oep->send_flags & SEND_FLAG_COMPLETE)) {
+		timeout = schedule_timeout(timeout);
+		rmb();
+	}
+
+	dprintk(DRIVER_NAME "[%d]: send complete (%#x)\n", ir->devnum, cmd);
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&oep->wait, &wait);
+#ifdef KERNEL_2_5
+	oep->urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+	usb_unlink_urb(oep->urb);
+}
+
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
+
+	lirc_unregister_plugin(p->minor);
+
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+	return SUCCESS;
+}
+
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+	struct list_head *pos, *n;
+	struct in_endpt *iep;
+	int rtn;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
+
+	MOD_INC_USE_COUNT;
+
+	IRLOCK;
+	if (!ir->connected) {
+		if (!ir->usbdev) {
+			IRUNLOCK;
+			dprintk(DRIVER_NAME "[%d]: !ir->usbdev\n", ir->devnum);
+			return -ENOENT;
+		}
+
+		/* Iterate through the inbound endpoints */
+		list_for_each_safe(pos, n, &ir->iep_listhead) {
+			/* extract the current in_endpt */
+			iep = get_iep_from_link(pos);
+			iep->urb->dev = ir->usbdev;
+			dprintk(DRIVER_NAME "[%d]: linking iep 0x%02x (%p)\n", ir->devnum, iep->ep->bEndpointAddress, iep);
+#ifdef KERNEL_2_5
+			if ((rtn = usb_submit_urb(iep->urb, GFP_ATOMIC)) < 0) {
+#else
+			if ((rtn = usb_submit_urb(iep->urb)) < 0) {
+#endif
+				printk(DRIVER_NAME "[%d]: open result = %d error "
+					"submitting urb\n", ir->devnum, rtn);
+				IRUNLOCK;
+				MOD_DEC_USE_COUNT;
+				return -EIO;
+			}
+		}
+		ir->connected = 1;
+	}
+	IRUNLOCK;
+
+	return SUCCESS;
+}
+
+static void set_use_dec(void *data)
+{
+	struct irctl *ir = data;
+	struct list_head *pos, *n;
+	struct in_endpt *iep;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
+		return;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
+
+	IRLOCK;
+	if (ir->connected) {
+		/* Free inbound usb urbs */
+		list_for_each_safe(pos, n, &ir->iep_listhead) {
+			iep = get_iep_from_link(pos);
+			dprintk(DRIVER_NAME "[%d]: unlinking iep 0x%02x (%p)\n", ir->devnum, iep->ep->bEndpointAddress, iep);
+			usb_kill_urb(iep->urb);
+		}
+		ir->connected = 0;
+	}
+	IRUNLOCK;
+	MOD_DEC_USE_COUNT;
+}
+
+static void print_data(struct in_endpt *iep, char *buf, int len)
+{
+	const int clen = code_length[iep->ir->remote_type];
+	char codes[clen * 3 + 1];
+	int i;
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len && i < clen; i++) {
+		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
+	}
+	printk(DRIVER_NAME "[%d]: data received %s (ep=0x%x length=%d)\n",
+		iep->ir->devnum, codes, iep->ep->bEndpointAddress, len);
+}
+
+static int code_check_ati1(struct in_endpt *iep, int len)
+{
+	struct irctl *ir = iep->ir;
+	int i, chan;
+
+	/* ATI RW1: some remotes emit both 4 and 5 byte length codes. */
+	/* ATI RW2: emit 3 byte codes */
+	if (len < CODE_MIN_LENGTH || len > CODE_LENGTH)
+		return -1;
+
+	// *** channel not tested with 4/5-byte Dutch remotes ***
+	chan = ((iep->buf[len-1]>>4) & 0x0F);
+
+	/* strip channel code */
+	if (!unique) {
+		iep->buf[len-1] &= 0x0F;
+		iep->buf[len-3] -= (chan<<4);
+	}
+
+	if ( !((1U<<chan) & mask) ) {
+		dprintk(DRIVER_NAME "[%d]: ignore channel %d\n", ir->devnum, chan+1);
+		return -1;
+	}
+	dprintk(DRIVER_NAME "[%d]: accept channel %d\n", ir->devnum, chan+1);
+
+	if (ir->remote_type == ATI1_COMPATIBLE) {
+		for (i = len; i < CODE_LENGTH; i++) iep->buf[i] = 0;
+		/* check for repeats */
+		if (memcmp(iep->old, iep->buf, len) == 0) {
+			if (iep->old_jiffies + repeat_jiffies > jiffies) {
+				return -1;
+			}
+		} else {
+			memcpy(iep->old, iep->buf, CODE_LENGTH);
+		}
+		iep->old_jiffies = jiffies;
+	}
+
+	return SUCCESS;
+}
+
+/*
+ * Since the ATI Remote Wonder II has quite a different structure from the
+ * prior version, this function was seperated out to clarify the sanitization
+ * process.
+ *
+ * Here is a summary of the main differences:
+ *
+ * a. The rw2 has no sense of a transmission channel.  But, it does have an
+ *    auxilliary mode state, which is set by the mode buttons Aux1 through
+ *    Aux4 and "PC".  These map respectively to 0-4 in the first byte of the
+ *    recv buffer.  Any subsequent button press sends this mode number as its
+ *    "channel code."  Annoyingly enough, the mode setting buttons all send
+ *    the same key code (0x3f), and can only be distinguished via their mode
+ *    byte.
+ *
+ *    Because of this, old-style "unique"-parameter-enabled channel squashing
+ *    kills the functionality of the aux1-aux4 and PC buttons.  However, to
+ *    not do so would cause each remote key to send a different code depending
+ *    on the active aux.  Further complicating matters, using the mouse norb
+ *    also sends an identical code as would pushing the active aux button.  To
+ *    handle this we need a seperate parameter, like rw2modes, with the
+ *    following values and meanings:
+ *
+ *    	0: Don't squash any channel info
+ *    	1: Only squash channel data for non-mode setting keys
+ *    	2: Ignore aux keypresses, but don't squash channel
+ *    	3: Ignore aux keypresses and squash channel data
+ *
+ *    Option 1 may seem useless since the mouse sends the same code, but one
+ *    need only ignore in userspace any press of a mode-setting code that only
+ *    reaffirms the current mode.  The 3rd party lirccd should be able to
+ *    handle this easily enough, but lircd doesn't keep the state necessary
+ *    for this.  TODO We could work around this in the driver by emitting a
+ *    single 02 (press) code for a mode key only if that mode is not currently
+ *    active.
+ *
+ *    Option 2 would be useful for those wanting super configurability,
+ *    offering the ability to program 5 times the number actions based on the
+ *    current mode.
+ *
+ * b. The rw2 has its own built in repeat handling; the keys endpoint
+ *    encodes this in the second byte as 1 for press, 2 for hold, and 0 for
+ *    release.  This is generally much more responsive than lirc's built-in
+ *    timeout handling.
+ *
+ *    The problem is that the remote can send the release-recieve pair
+ *    (0,1) while one is still holding down the same button if the
+ *    transmission is momentarilly interrupted.  (It seems that the receiver
+ *    manages this count instead of the remote.)  By default, this information
+ *    is squashed to 2.
+ *
+ *    In order to expose the built-in repeat code, set the emit_updown
+ *    parameter as described below.
+ *
+ * c. The mouse norb is much more sensitive than on the rw1.  It emulates
+ *    a joystick-like controller with the second byte representing the x-axis
+ *    and the third, the y-axis.  Treated as signed integers, these axes range
+ *    approximately as follows:
+ *
+ *    	x: (left) -46 ... 46 (right) (0xd2..0x2e)
+ *    	y: (up)   -46 ... 46 (down)  (0xd2..0x2e)
+ *
+ *    NB these values do not correspond to the pressure with which the mouse
+ *    norb is pushed in a given direction, but rather seems to indicate the
+ *    duration for which a given direction is held.
+ *
+ *    These are normalized to 8 cardinal directions for easy configuration via
+ *    lircd.conf.  The normalization can be fined tuned with the mdeadzone and
+ *    mgradient parameters as described below.
+ *
+ * d. The interrupt rate of the mouse vs. the normal keys is different.
+ *
+ * 	mouse: ~27Hz (37ms between interrupts)
+ * 	keys:  ~10Hz (100ms between interrupts)
+ *
+ *    This means that the normal gap mechanism for lircd won't work as
+ *    expected; is emit_updown>0 if you can get away with it.
+ */
+static int code_check_ati2(struct in_endpt *iep, int len) {
+	struct irctl *ir = iep->ir;
+	int mode, i;
+	char *buf = iep->buf;
+
+	if (len != CODE_LENGTH) {
+		dprintk(DRIVER_NAME
+			"[%d]: Huh?  Abnormal length (%d) buffer recieved.\n",
+			ir->devnum, len);
+		return -1;
+	}
+	for (i = len; i < CODE_LENGTH; i++) iep->buf[i] = 0;
+
+	mode = buf[0];
+
+	/* Squash the mode indicator if unique wasn't set non-zero */
+	if (!unique) buf[0] = 0;
+
+	if (iep->ep->bEndpointAddress == EP_KEYS_ADDR) {
+		/* ignore mouse navigation indicator key and mode-set (aux) keys */
+		if (buf[2] == RW2_MODENAV_KEYCODE) {
+			if (emit_modekeys >= 2) { /* emit raw */
+				buf[0] = mode;
+			} else if (emit_modekeys == 1) { /* translate */
+				buf[0] = mode;
+				if (ir->mode != mode) {
+					buf[1] = 0x03;
+					ir->mode = mode;
+					return SUCCESS;
+				}
+			} else {
+				dprintk(DRIVER_NAME "[%d]: ignore dummy code 0x%x (ep=0x%x)\n",
+					ir->devnum, buf[2], iep->ep->bEndpointAddress);
+				return -1;
+			}
+		}
+
+		if (buf[1] != 2) {
+			/* handle press/release codes */
+			if (emit_updown == 0) /* ignore */
+				return -1;
+			else if(emit_updown == 1) /* normalize keycode */
+				buf[2] = RW2_PRESSRELEASE_KEYCODE;
+			/* else emit raw */
+		}
+
+	} else {
+		int x = (signed char)buf[1];
+		int y = (signed char)buf[2];
+		int code = 0x00;
+		int dir_ew, dir_ns;
+
+		buf[2] = RW2_MOUSE_KEYCODE;
+
+		/* sensitivity threshold (use L2norm^2) */
+		if (mdeadzone > (x*x+y*y)) {
+			buf[1] = 0x00;
+			return SUCCESS;
+		}
+
+/* Nybble encoding: xy, 2 is -1 (S or W); 1 (N or E) */
+#define MOUSE_N		0x01
+#define MOUSE_NE	0x11
+#define MOUSE_E		0x10
+#define MOUSE_SE	0x12
+#define MOUSE_S		0x02
+#define MOUSE_SW	0x22
+#define MOUSE_W		0x20
+#define MOUSE_NW	0x21
+
+		/* cardinal leanings: positive x -> E, positive y -> S */
+		dir_ew = (x > 0) ? MOUSE_E : MOUSE_W;
+		dir_ns = (y > 0) ? MOUSE_S : MOUSE_N;
+
+		/* convert coordintes(angle) into compass direction */
+		if (x == 0) {
+			code = dir_ns;
+		} else if (y == 0) {
+			code = dir_ew;
+		} else {
+			if (abs(1000*y/x) > mgradient)
+				code = dir_ns;
+			if (abs(1000*x/y) > mgradient)
+				code |= dir_ew;
+		}
+
+		buf[1] = code;
+		dprintk(DRIVER_NAME "[%d]: mouse compass=0x%x %s%s (%d,%d)\n",
+			ir->devnum, code,
+			(code & MOUSE_S ? "S" : (code & MOUSE_N ? "N" : "")),
+			(code & MOUSE_E ? "E" : (code & MOUSE_W ? "W" : "")),
+			x, y);
+	}
+
+	return SUCCESS;
+}
+
+static int code_check_xbox(struct in_endpt *iep, int len)
+{
+	struct irctl *ir = iep->ir;
+	const int clen = CODE_LENGTH;
+
+	if (len != clen)
+	{
+		dprintk(DRIVER_NAME ": We got %d instead of %d bytes from xbox ir.. ?\n", len, clen);
+		return -1;
+	}
+
+	/* check for repeats */
+	if (memcmp(iep->old, iep->buf, len) == 0) 
+	{
+		if (iep->old_jiffies + repeat_jiffies > jiffies) 
+		{
+			return -1;
+		}
+	} 
+	else 
+	{
+		// the third byte of xbox ir packet seems to contain key info
+		// the last two bytes are.. some kind of clock?
+		iep->buf[0] = iep->buf[2];
+		memset(iep->buf + 1, 0, len - 1);
+		memcpy(iep->old, iep->buf, len);
+	}
+	iep->old_jiffies = jiffies;
+
+	return SUCCESS;
+}
+
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_remote_recv(struct urb *urb)
+#endif
+{
+	struct in_endpt *iep;
+	int len, result = -1;
+
+	if (!urb)
+		return;
+	if (!(iep = urb->context)) {
+#ifdef KERNEL_2_5
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+		usb_unlink_urb(urb);
+		return;
+	}
+	if (!iep->ir->usbdev)
+		return;
+
+	len = urb->actual_length;
+	if (debug)
+		print_data(iep,urb->transfer_buffer,len);
+
+	switch (urb->status) {
+
+	/* success */
+	case SUCCESS:
+
+		switch (iep->ir->remote_type) {
+		case XBOX_COMPATIBLE:
+			result = code_check_xbox(iep, len);
+			break;
+		case ATI2_COMPATIBLE:
+			result = code_check_ati2(iep, len);
+			break;
+		case ATI1_COMPATIBLE:
+		default:
+			result = code_check_ati1(iep, len);
+		}
+		if (result < 0) break;
+		lirc_buffer_write_1(iep->ir->p->rbuf, iep->buf);
+		wake_up(&iep->ir->p->rbuf->wait_poll);
+		break;
+
+	/* unlink */
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+#ifdef KERNEL_2_5
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+		usb_unlink_urb(urb);
+		return;
+
+	case -EPIPE:
+	default:
+		break;
+	}
+
+	/* resubmit urb */
+#ifdef KERNEL_2_5
+	usb_submit_urb(urb, GFP_ATOMIC);
+#endif
+}
+
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_remote_send(struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_remote_send(struct urb *urb)
+#endif
+{
+	struct out_endpt *oep;
+
+	if (!urb)
+		return;
+	if (!(oep = urb->context)) {
+#ifdef KERNEL_2_5
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+		usb_unlink_urb(urb);
+		return;
+	}
+	if (!oep->ir->usbdev)
+		return;
+
+	dprintk(DRIVER_NAME "[%d]: usb out called\n", oep->ir->devnum);
+
+	if (urb->status)
+		return;
+
+	oep->send_flags |= SEND_FLAG_COMPLETE;
+	wmb();
+	if (waitqueue_active(&oep->wait))
+		wake_up(&oep->wait);
+}
+
+
+/***************************************************************************
+ * Initialization and removal
+ ***************************************************************************/
+
+/*
+ * Free iep according to mem_failure which specifies a checkpoint into the
+ * initialization sequence for rollback recovery.
+ */
+static void free_in_endpt(struct in_endpt *iep, int mem_failure)
+{
+	struct irctl *ir;
+	dprintk(DRIVER_NAME ": free_in_endpt(%p, %d)\n", iep, mem_failure);
+	if (!iep) return;
+
+	ir = iep->ir;
+	if (!ir) {
+		dprintk(DRIVER_NAME ": free_in_endpt: WARNING! null ir\n");
+		return;
+	}
+	IRLOCK;
+	switch (mem_failure) {
+	case FREE_ALL:
+	case 5:
+		list_del(&iep->iep_list_link);
+		dprintk(DRIVER_NAME "[%d]: free_in_endpt removing ep=0x%0x from list\n", ir->devnum, iep->ep->bEndpointAddress);
+	case 4:
+		if (iep->urb) {
+#ifdef KERNEL_2_5
+			iep->urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			usb_unlink_urb(iep->urb);
+			usb_free_urb(iep->urb);
+			iep->urb = 0;
+		} else {
+			dprintk(DRIVER_NAME "[%d]: free_in_endpt null urb!\n", ir->devnum);
+		}
+	case 3:
+#ifdef KERNEL_2_5
+		usb_buffer_free(iep->ir->usbdev, iep->len, iep->buf, iep->dma);
+#else
+		kfree(iep->buf);
+#endif
+		iep->buf = 0;
+	case 2:
+		kfree(iep);
+	}
+	IRUNLOCK;
+}
+
+/*
+ * Construct a new inbound endpoint for this remote, and add it to the list of
+ * in_epts in ir.
+ */
+static struct in_endpt *new_in_endpt(struct irctl *ir, struct usb_endpoint_descriptor *ep)
+{
+	struct usb_device *dev = ir->usbdev;
+	struct in_endpt *iep;
+	int pipe, maxp, len, addr;
+	int mem_failure;
+
+	addr = ep->bEndpointAddress;
+	pipe = usb_rcvintpipe(dev, addr);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+//	len = (maxp > USB_BUFLEN) ? USB_BUFLEN : maxp;
+//	len -= (len % CODE_LENGTH);
+	len = CODE_LENGTH;
+
+	dprintk(DRIVER_NAME "[%d]: acceptable inbound endpoint (0x%x) found (maxp=%d len=%d)\n", ir->devnum, addr, maxp, len);
+
+	mem_failure = 0;
+	if ( !(iep = kmalloc(sizeof(*iep), GFP_KERNEL)) ) {
+		mem_failure = 1;
+	} else {
+		memset(iep, 0, sizeof(*iep));
+		iep->ir = ir;
+		iep->ep = ep;
+		iep->len = len;
+
+#ifdef KERNEL_2_5
+		if ( !(iep->buf = usb_buffer_alloc(dev, len, GFP_ATOMIC, &iep->dma)) ) {
+			mem_failure = 2;
+		} else if ( !(iep->urb = usb_alloc_urb(0, GFP_KERNEL)) ) {
+			mem_failure = 3;
+		}
+#else
+		if ( !(iep->buf = kmalloc(len, GFP_KERNEL)) ) {
+			mem_failure = 2;
+		} else if ( !(iep->urb = usb_alloc_urb(0)) ) {
+			mem_failure = 3;
+		}
+#endif
+	}
+	if (mem_failure) {
+		free_in_endpt(iep, mem_failure);
+		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n", ir->devnum, addr, mem_failure);
+		return NULL;
+	}
+	list_add_tail(&iep->iep_list_link, &ir->iep_listhead);
+	dprintk(DRIVER_NAME "[%d]: adding ep=0x%0x to list\n", ir->devnum, iep->ep->bEndpointAddress);
+	return iep;
+}
+
+static void free_out_endpt(struct out_endpt *oep, int mem_failure)
+{
+	struct irctl *ir;
+	dprintk(DRIVER_NAME ": free_out_endpt(%p, %d)\n", oep, mem_failure);
+	if (!oep) return;
+
+	wake_up_all(&oep->wait);
+
+	ir = oep->ir;
+	if (!ir) {
+		dprintk(DRIVER_NAME ": free_out_endpt: WARNING! null ir\n");
+		return;
+	}
+	IRLOCK;
+	switch (mem_failure) {
+	case FREE_ALL:
+	case 4:
+		if (oep->urb) {
+#ifdef KERNEL_2_5
+			oep->urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			usb_unlink_urb(oep->urb);
+			usb_free_urb(oep->urb);
+			oep->urb = 0;
+		} else {
+			dprintk(DRIVER_NAME "[%d]: free_out_endpt: null urb!\n", ir->devnum);
+		}
+	case 3:
+#ifdef KERNEL_2_5
+		usb_buffer_free(oep->ir->usbdev, USB_OUTLEN, oep->buf, oep->dma);
+#else
+		kfree(oep->buf);
+#endif
+		oep->buf = 0;
+	case 2:
+		kfree(oep);
+	}
+	IRUNLOCK;
+}
+
+static struct out_endpt *new_out_endpt(struct irctl *ir, struct usb_endpoint_descriptor *ep)
+{
+#ifdef KERNEL_2_5
+	struct usb_device *dev = ir->usbdev;
+#endif
+	struct out_endpt *oep;
+	int mem_failure;
+
+	dprintk(DRIVER_NAME "[%d]: acceptable outbound endpoint (0x%x) found\n", ir->devnum, ep->bEndpointAddress);
+
+	mem_failure = 0;
+	if ( !(oep = kmalloc(sizeof(*oep), GFP_KERNEL)) ) {
+		mem_failure = 1;
+	} else {
+		memset(oep, 0, sizeof(*oep));
+		oep->ir = ir;
+		oep->ep = ep;
+		init_waitqueue_head(&oep->wait);
+
+#ifdef KERNEL_2_5
+		if ( !(oep->buf = usb_buffer_alloc(dev, USB_OUTLEN, GFP_ATOMIC, &oep->dma)) ) {
+			mem_failure = 2;
+		} else if ( !(oep->urb = usb_alloc_urb(0, GFP_KERNEL)) ) {
+			mem_failure = 3;
+		}
+#else
+		if ( !(oep->buf = kmalloc(USB_OUTLEN, GFP_KERNEL)) ) {
+			mem_failure = 2;
+		} else if ( !(oep->urb = usb_alloc_urb(0)) ) {
+			mem_failure = 3;
+		}
+#endif
+	}
+	if (mem_failure) {
+		free_out_endpt(oep, mem_failure);
+		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n", ir->devnum, ep->bEndpointAddress, mem_failure);
+		return NULL;
+	}
+	return oep;
+}
+
+static void free_irctl(struct irctl *ir, int mem_failure)
+{
+	struct list_head *pos, *n;
+	struct in_endpt *in;
+	dprintk(DRIVER_NAME ": free_irctl(%p, %d)\n", ir, mem_failure);
+
+	if (!ir) return;
+
+	list_for_each_safe(pos, n, &ir->iep_listhead) {
+		in = get_iep_from_link(pos);
+		free_in_endpt(in, FREE_ALL);
+	}
+	if (ir->out_init) {
+		free_out_endpt(ir->out_init, FREE_ALL);
+		ir->out_init = NULL;
+	}
+
+	IRLOCK;
+	switch (mem_failure) {
+	case FREE_ALL:
+	case 6:
+	    	if (!--ir->dev_refcount) {
+			list_del(&ir->remote_list_link);
+			dprintk(DRIVER_NAME "[%d]: free_irctl: removing remote from list\n",
+				ir->devnum);
+		} else {
+			dprintk(DRIVER_NAME "[%d]: free_irctl: refcount at %d,"
+				"aborting free_irctl\n", ir->devnum, ir->dev_refcount);
+			IRUNLOCK;
+			return;
+		}
+	case 5:
+	case 4:
+	case 3:
+		if (ir->p) {
+			switch (mem_failure) {
+			case 5: lirc_buffer_free(ir->p->rbuf);
+			case 4: kfree(ir->p->rbuf);
+			case 3: kfree(ir->p);
+			}
+		} else {
+			printk(DRIVER_NAME "[%d]: ir->p is a null pointer!\n", ir->devnum);
+		}
+	case 2:
+		IRUNLOCK;
+		kfree(ir);
+		return;
+	}
+	IRUNLOCK;
+}
+
+static struct irctl *new_irctl(struct usb_device *dev)
+{
+	struct irctl *ir;
+	struct lirc_plugin *plugin;
+	struct lirc_buffer *rbuf;
+	int type, devnum;
+	int mem_failure;
+
+	devnum = dev->devnum;
+
+	/* determine remote type */
+	switch (cpu_to_le16(dev->descriptor.idVendor)) {
+	case VENDOR_ATI1:
+		type = ATI1_COMPATIBLE;
+		break;
+	case VENDOR_ATI2:
+		type = ATI2_COMPATIBLE;
+		break;
+	case VENDOR_MS1:
+	case VENDOR_MS2:
+		type = XBOX_COMPATIBLE;
+		break;
+	default:
+		dprintk(DRIVER_NAME "[%d]: unknown type\n", devnum);
+		return NULL;
+	}
+	dprintk(DRIVER_NAME "[%d]: remote type = %d\n", devnum, type);
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if ( !(ir = kmalloc(sizeof(*ir), GFP_KERNEL)) ) {
+		mem_failure = 1;
+	} else {
+	        // at this stage we cannot use the macro [DE]CODE_LENGTH: ir is not yet setup
+	        const int dclen = decode_length[type];
+		memset(ir, 0, sizeof(*ir));
+		/* add this infrared remote struct to remote_list, keeping track of
+		 * the number of drivers registered. */
+		dprintk(DRIVER_NAME "[%d]: adding remote to list\n", devnum);
+		list_add_tail(&ir->remote_list_link, &remote_list);
+		ir->dev_refcount=1;
+
+		if (!(plugin = kmalloc(sizeof(*plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(*rbuf), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, dclen, 1)) {
+			mem_failure = 4;
+		} else {
+			memset(plugin, 0, sizeof(*plugin));
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->code_length = dclen * 8;
+			plugin->features = LIRC_CAN_REC_LIRCCODE;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+#ifdef LIRC_HAVE_SYSFS
+			plugin->dev = &dev->dev;
+#endif
+			plugin->owner = THIS_MODULE;
+			ir->usbdev = dev;
+			ir->p = plugin;
+			ir->remote_type = type;
+			ir->devnum = devnum;
+			ir->mode = RW2_NULL_MODE;
+
+			init_MUTEX(&ir->lock);
+			INIT_LIST_HEAD(&ir->iep_listhead);
+		}
+	}
+	if (mem_failure) {
+		free_irctl(ir, mem_failure);
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n", devnum, mem_failure);
+		return NULL;
+	}
+	return ir;
+}
+
+
+/*
+ * Scan the global list of remotes to see if the device listed is one of them.
+ * If it is, the corresponding irctl is returned, with its dev_refcount
+ * incremented.  Otherwise, returns null.
+ */
+static struct irctl *get_prior_reg_ir(struct usb_device *dev) {
+	struct list_head *pos;
+	struct irctl *ir = NULL;
+
+	dprintk(DRIVER_NAME "[%d]: scanning remote_list...\n", dev->devnum);
+	list_for_each(pos, &remote_list) {
+		ir = get_irctl_from_link(pos);
+		if (ir->usbdev != dev) {
+		    dprintk(DRIVER_NAME "[%d]: device %d isn't it...", dev->devnum, ir->devnum);
+		    ir = NULL;
+		} else {
+		    dprintk(DRIVER_NAME "[%d]: prior instance found.\n", dev->devnum);
+		    ir->dev_refcount++;
+		    break;
+		}
+	}
+	return ir;
+}
+
+/* If the USB interface has an out endpoint for control (eg, the first Remote
+ * Wonder) send the appropriate initialization packets. */
+static void send_outbound_init(struct irctl *ir) {
+	if (ir->out_init) {
+		struct out_endpt *oep = ir->out_init;
+		dprintk(DRIVER_NAME "[%d]: usb_remote_probe: initializing outbound ep\n", ir->devnum);
+		usb_fill_int_urb(oep->urb, ir->usbdev,
+			usb_sndintpipe(ir->usbdev, oep->ep->bEndpointAddress), oep->buf,
+			USB_OUTLEN, usb_remote_send, oep, oep->ep->bInterval);
+
+		send_packet(oep, 0x8004, init1);
+		send_packet(oep, 0x8007, init2);
+	}
+}
+
+/* Log driver and usb info */
+static void log_usb_dev_info(struct usb_device *dev) {
+	char buf[63], name[128]="";
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", dev->devnum, name,
+	       dev->bus->busnum, dev->devnum);
+}
+
+
+#ifdef KERNEL_2_5
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *idesc;
+#else
+static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	struct usb_interface *intf = &dev->actconfig->interface[ifnum];
+	struct usb_interface_descriptor *idesc;
+#endif
+	struct usb_endpoint_descriptor *ep;
+	struct in_endpt *iep;
+	struct irctl *ir;
+	int i, type;
+
+	dprintk(DRIVER_NAME "[%d]: usb_remote_probe: dev:%p, intf:%p, id:%p)\n",
+		dev->devnum, dev, intf, id);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
+	idesc = intf->cur_altsetting;
+#else
+	idesc = &intf->altsetting[intf->act_altsetting];
+#endif
+
+	/* Check if a usb remote has already been registered for this device */
+	ir = get_prior_reg_ir(dev);
+
+	if ( !ir && !(ir = new_irctl(dev)) ) {
+#ifdef KERNEL_2_5
+		return -ENOMEM;
+#else
+		return NULL;
+#endif
+	}
+	type = ir->remote_type;
+
+	// step through the endpoints to find first in and first out endpoint
+	// of type interrupt transfer
+#ifdef KERNEL_2_5
+	for (i = 0; i < idesc->desc.bNumEndpoints; ++i) {
+		ep = &idesc->endpoint[i].desc;
+#else
+	for (i = 0; i < idesc->bNumEndpoints; ++i) {
+		ep = &idesc->endpoint[i];
+#endif
+		dprintk(DRIVER_NAME "[%d]: processing endpoint %d\n", dev->devnum, i);
+		if ( ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
+
+			if ((iep = new_in_endpt(ir,ep))) {
+				usb_fill_int_urb(iep->urb, dev,
+					usb_rcvintpipe(dev,iep->ep->bEndpointAddress), iep->buf,
+					iep->len, usb_remote_recv, iep, iep->ep->bInterval);
+			}
+		}
+
+		if ( ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)
+			&& (ir->out_init == NULL)) {
+
+			ir->out_init = new_out_endpt(ir,ep);
+		}
+	}
+	if (list_empty(&ir->iep_listhead)) {
+		printk(DRIVER_NAME "[%d]: inbound endpoint not found\n", ir->devnum);
+		free_irctl(ir, FREE_ALL);
+#ifdef KERNEL_2_5
+		return -ENODEV;
+#else
+		return NULL;
+#endif
+	}
+	if (ir->dev_refcount == 1) {
+		if ((ir->p->minor = lirc_register_plugin(ir->p)) < 0) {
+			free_irctl(ir, FREE_ALL);
+#ifdef KERNEL_2_5
+			return -ENODEV;
+#else
+			return NULL;
+#endif
+		}
+
+		/* Note new driver registration in kernel logs */
+		log_usb_dev_info(dev);
+
+		/* outbound data (initialization) */
+		send_outbound_init(ir);
+	}
+
+#ifdef KERNEL_2_5
+	usb_set_intfdata(intf, ir);
+	return SUCCESS;
+#else
+	return ir;
+#endif
+}
+
+#ifdef KERNEL_2_5
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+//	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+#else
+static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct irctl *ir = ptr;
+#endif
+
+	dprintk(DRIVER_NAME ": disconnecting remote %d:\n", (ir? ir->devnum: -1));
+	if (!ir || !ir->p)
+		return;
+
+	if (ir->usbdev) {
+		/* Only unregister once */
+		ir->usbdev = NULL;
+		unregister_from_lirc(ir);
+	}
+
+	/* This also removes the current remote from remote_list */
+	free_irctl(ir, FREE_ALL);
+}
+
+static struct usb_driver usb_remote_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+	.id_table =	usb_remote_table
+};
+
+static int __init usb_remote_init(void)
+{
+	int i;
+
+	INIT_LIST_HEAD(&remote_list);
+
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled: $Id: lirc_atiusb.c,v 1.61 2007/04/29 14:23:04 lirc Exp $\n");
+
+	request_module("lirc_dev");
+
+	repeat_jiffies = repeat*HZ/100;
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void __exit usb_remote_exit(void)
+{
+	usb_deregister(&usb_remote_driver);
+}
+
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, usb_remote_table);
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled or not (default: 0)");
+
+module_param(mask, int, 0644);
+MODULE_PARM_DESC(mask, "Set channel acceptance bit mask (default: 0xFFFF)");
+
+module_param(unique, bool, 0644);
+MODULE_PARM_DESC(unique, "Enable channel-specific codes (default: 0)");
+
+module_param(repeat, int, 0644);
+MODULE_PARM_DESC(repeat, "Repeat timeout (1/100 sec) (default: 10)");
+
+module_param(mdeadzone, int, 0644);
+MODULE_PARM_DESC(mdeadzone, "rw2 mouse sensitivity threshold (default: 0)");
+
+/*
+ * Enabling this will cause the built-in Remote Wonder II repeate coding to
+ * not be squashed.  The second byte of the keys output will then be:
+ *
+ * 	1 initial press (button down)
+ * 	2 holding (button remains pressed)
+ * 	0 release (button up)
+ *
+ * By default, the driver emits 2 for both 1 and 2, and emits nothing for 0.
+ * This is good for people having trouble getting their rw2 to send a good
+ * consistent signal to the receiver.
+ *
+ * However, if you have no troubles with the driver outputting up-down pairs
+ * at random points while you're still holding a button, then you can enable
+ * this parameter to get finer grain repeat control out of your remote:
+ *
+ * 	1 Emit a single (per-channel) virtual code for all up/down events
+ * 	2 Emit the actual rw2 output
+ *
+ * 1 is easier to write lircd configs for; 2 allows full control.
+ */
+module_param(emit_updown, int, 0644);
+MODULE_PARM_DESC(emit_updown, "emit press/release codes (rw2): 0:don't (default), 1:emit 2 codes only, 2:code for each button");
+
+module_param(emit_modekeys, int, 0644);
+MODULE_PARM_DESC(emit_modekeys, "emit keycodes for aux1-aux4, pc, and mouse (rw2): 0:don't (default), 1:emit translated codes: one for mode switch, one for same mode, 2:raw codes");
+
+module_param(mgradient, int, 0644);
+MODULE_PARM_DESC(mgradient, "rw2 mouse: 1000*gradient from E to NE (default: 500 => .5 => ~27 degrees)");
+
+EXPORT_NO_SYMBOLS;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_bt829.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_bt829.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_bt829.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_bt829.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,403 @@
+/*
+ * Remote control driver for the TV-card based on bt829
+ *
+ *  by Leonid Froenchenko <lfroen@galileo.co.il>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#error "This driver needs kernel version 2.4.0 or higher"
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/threads.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+static int poll_main(void);
+static int atir_init_start(void);
+
+static void write_index(unsigned char index,unsigned int value);
+static unsigned int read_index(unsigned char index);
+
+static void do_i2c_start(void);
+static void do_i2c_stop(void);
+
+static void seems_wr_byte(unsigned char al);
+static unsigned char seems_rd_byte(void);
+
+static unsigned int read_index(unsigned char al);
+static void write_index(unsigned char ah,unsigned int edx);
+
+static void cycle_delay(int cycle);
+
+static void do_set_bits(unsigned char bl);
+static unsigned char do_get_bits(void);
+
+#define DATA_PCI_OFF 0x7FFC00
+#define WAIT_CYCLE   20
+
+static int debug = 0;
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+static int atir_minor;
+static unsigned long pci_addr_phys;
+static unsigned char *pci_addr_lin;
+
+static struct lirc_plugin atir_plugin;
+
+static struct pci_dev *do_pci_probe(void)
+{
+	struct pci_dev *my_dev;
+#ifndef KERNEL_2_5
+	/* unnecessary with recent kernels */
+	if ( !pci_present() ) {
+		printk(KERN_ERR "ATIR: no pci in this kernel\n");
+	}
+#endif
+	my_dev = (struct pci_dev *)pci_find_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_264VT,NULL);
+	if ( my_dev ) {
+		printk(KERN_ERR "ATIR: Using device: %s\n",
+		       pci_name(my_dev));
+		pci_addr_phys = 0;
+		if ( my_dev->resource[0].flags & IORESOURCE_MEM ) {
+			pci_addr_phys = my_dev->resource[0].start;
+			printk(KERN_INFO "ATIR memory at 0x%08X \n",(unsigned int)pci_addr_phys);
+		}
+		if ( pci_addr_phys == 0 ) {
+			printk(KERN_ERR "ATIR no memory resource ?\n");
+			return NULL;
+		}
+	} else {
+		printk(KERN_ERR "ATIR: pci_prob failed\n");
+		return NULL;
+	}
+	return my_dev;
+}
+
+static int atir_add_to_buf (void* data, struct lirc_buffer* buf)
+{
+	unsigned char key;
+	int status;
+	status = poll_main();
+	key = (status >> 8) & 0xFF;
+	if( status & 0xFF )
+	{
+	//    printk(KERN_INFO "ATIR reading key %02X\n",*key);
+		lirc_buffer_write_1( buf, &key );
+		return 0;
+	}
+	return -ENODATA;
+}
+
+static int atir_set_use_inc(void* data)
+{
+	MOD_INC_USE_COUNT;
+	dprintk("ATIR driver is opened\n");
+	return 0;
+}
+
+static void atir_set_use_dec(void* data)
+{
+	MOD_DEC_USE_COUNT;
+	dprintk("ATIR driver is closed\n");
+}
+
+int init_module(void)
+{
+	struct pci_dev *pdev;
+
+	pdev = do_pci_probe();
+	if ( pdev == NULL ) {
+		return 1;
+	}
+
+	if ( !atir_init_start() ) {
+		return 1;
+	}
+
+	strcpy(atir_plugin.name,"ATIR");
+	atir_plugin.minor       = -1;
+	atir_plugin.code_length = 8;
+	atir_plugin.sample_rate = 10;
+	atir_plugin.data        = 0;
+	atir_plugin.add_to_buf  = atir_add_to_buf;
+	atir_plugin.set_use_inc = atir_set_use_inc;
+	atir_plugin.set_use_dec = atir_set_use_dec;
+#ifdef LIRC_HAVE_SYSFS
+	atir_plugin.dev         = &pdev->dev;
+#endif
+	atir_plugin.owner       = THIS_MODULE;
+
+	atir_minor = lirc_register_plugin(&atir_plugin);
+	dprintk("ATIR driver is registered on minor %d\n",atir_minor);
+
+	return 0;
+}
+
+
+void cleanup_module(void)
+{
+	lirc_unregister_plugin(atir_minor);
+}
+
+
+static int atir_init_start(void)
+{
+	pci_addr_lin = ioremap(pci_addr_phys + DATA_PCI_OFF,0x400);
+	if ( pci_addr_lin == 0 ) {
+		printk(KERN_INFO "atir: pci mem must be mapped\n");
+		return 0;
+	}
+	return 1;
+}
+
+static void cycle_delay(int cycle)
+{
+	udelay(WAIT_CYCLE*cycle);
+}
+
+
+static int poll_main()
+{
+	unsigned char status_high, status_low;
+	
+	do_i2c_start();
+
+	seems_wr_byte(0xAA);
+	seems_wr_byte(0x01);
+
+	do_i2c_start();
+
+	seems_wr_byte(0xAB);
+
+	status_low = seems_rd_byte();
+	status_high = seems_rd_byte();
+
+	do_i2c_stop();
+
+	return (status_high << 8) | status_low;
+}
+
+static void do_i2c_start(void)
+{
+	do_set_bits(3);
+	cycle_delay(4);
+
+	do_set_bits(1);
+	cycle_delay(7);
+
+	do_set_bits(0);
+	cycle_delay(2);
+}
+
+static void do_i2c_stop(void)
+{
+	unsigned char bits;
+	bits =  do_get_bits() & 0xFD;
+	do_set_bits(bits);
+	cycle_delay(1);
+
+	bits |= 1;
+	do_set_bits(bits);
+	cycle_delay(2);
+
+	bits |= 2;
+	do_set_bits(bits);
+	bits = 3;
+	do_set_bits(bits);
+	cycle_delay(2);
+}
+
+static void seems_wr_byte(unsigned char value)
+{
+	int i;
+	unsigned char reg;
+    
+	reg = do_get_bits();
+	for(i = 0;i < 8;i++) {
+		if ( value & 0x80 ) {
+			reg |= 0x02;
+		} else {
+			reg &= 0xFD;
+		}
+		do_set_bits(reg);
+		cycle_delay(1);
+
+		reg |= 1;
+		do_set_bits(reg);
+		cycle_delay(1);
+
+		reg &= 0xFE;
+		do_set_bits(reg);
+		cycle_delay(1);
+		value <<= 1;
+	}
+	cycle_delay(2);
+
+	reg |= 2;
+	do_set_bits(reg);
+
+	reg |= 1;
+	do_set_bits(reg);
+
+	cycle_delay(1);
+	do_get_bits();
+
+	reg &= 0xFE;
+	do_set_bits(reg);
+	cycle_delay(3);
+}
+
+static unsigned char seems_rd_byte(void)
+{
+	int i;
+	int rd_byte;
+	unsigned char bits_2, bits_1;
+
+	bits_1 = do_get_bits() | 2;
+	do_set_bits(bits_1);
+
+	rd_byte = 0;
+	for(i = 0;i < 8;i++) {
+		bits_1 &= 0xFE;
+		do_set_bits(bits_1);
+		cycle_delay(2);
+
+		bits_1 |= 1;
+		do_set_bits(bits_1);
+		cycle_delay(1);
+
+		if ( (bits_2 = do_get_bits()) & 2 ) {
+			rd_byte |= 1;
+		}
+		rd_byte <<= 1;
+	}
+
+	bits_1 = 0;
+	if ( bits_2 == 0 ) {
+		bits_1 |= 2;
+	}
+	do_set_bits(bits_1);
+	cycle_delay(2);
+
+	bits_1 |= 1;
+	do_set_bits(bits_1);
+	cycle_delay(3);
+
+	bits_1 &= 0xFE;
+	do_set_bits(bits_1);
+	cycle_delay(2);
+
+	rd_byte >>= 1;
+	rd_byte &= 0xFF;
+	return rd_byte;
+}
+
+static void do_set_bits(unsigned char new_bits)
+{
+	int reg_val;
+	reg_val = read_index(0x34);
+	if ( new_bits & 2 ) {
+		reg_val &= 0xFFFFFFDF;
+		reg_val |= 1;
+	} else {
+		reg_val &= 0xFFFFFFFE;
+		reg_val |= 0x20;
+	}
+	reg_val |= 0x10;
+	write_index(0x34,reg_val);
+
+	reg_val = read_index(0x31);
+	if ( new_bits & 1 ) {
+		reg_val |= 0x1000000;
+	} else {
+		reg_val &= 0xFEFFFFFF;
+	}
+	reg_val |= 0x8000000;
+	write_index(0x31,reg_val);
+}
+
+static unsigned char do_get_bits(void)
+{
+	unsigned char bits;
+	int reg_val;
+
+	reg_val = read_index(0x34);
+	reg_val |= 0x10;
+	reg_val &= 0xFFFFFFDF;
+	write_index(0x34,reg_val);
+
+	reg_val = read_index(0x34);
+	bits = 0;
+	if ( reg_val & 8 ) {
+		bits |= 2;
+	} else {
+		bits &= 0xFD;
+	}
+	reg_val = read_index(0x31);
+	if ( reg_val & 0x1000000 ) {
+		bits |= 1;	
+	} else {
+		bits &= 0xFE;
+	}
+	return bits;
+}
+
+static unsigned int read_index(unsigned char index)
+{
+	unsigned char *addr;
+	unsigned int value;
+	//  addr = pci_addr_lin + DATA_PCI_OFF + ((index & 0xFF) << 2);
+	addr = pci_addr_lin + ((index & 0xFF) << 2);
+	value = readl(addr);
+	return value;
+}
+
+static void write_index(unsigned char index,unsigned int reg_val)
+{
+	unsigned char *addr;
+	addr = pci_addr_lin + ((index & 0xFF) << 2);
+	writel(reg_val,addr);
+}
+
+MODULE_AUTHOR("Froenchenko Leonid");
+MODULE_DESCRIPTION("IR remote driver for bt829 based TV cards");
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+EXPORT_NO_SYMBOLS;
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_cmdir.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_cmdir.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_cmdir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_cmdir.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,612 @@
+/*      $Id: lirc_cmdir.c,v 1.6 2007/02/13 06:45:15 lirc Exp $      */
+
+/*
+ * lirc_cmdir.c - Driver for InnovationOne's COMMANDIR USB Transceiver
+ *
+ *  This driver requires the COMMANDIR hardware driver, available at
+ *  http://www.commandir.com/.
+ *
+ *  Copyright (C) 2005  InnovationOne - Evelyn Yeung
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+ 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+#include "kcompat.h"
+#include "lirc_cmdir.h"
+
+struct lirc_cmdir
+{
+	int features;
+};
+
+struct lirc_cmdir hardware=
+{
+	(
+	/* LIRC_CAN_SET_SEND_DUTY_CYCLE|   */
+	LIRC_CAN_SET_SEND_CARRIER|
+	LIRC_CAN_SEND_PULSE|
+	LIRC_CAN_SET_TRANSMITTER_MASK|
+	LIRC_CAN_REC_MODE2)
+	,
+};
+
+#define LIRC_DRIVER_NAME "lirc_cmdir"
+#define RBUF_LEN   256
+#define WBUF_LEN   256
+#define MAX_PACKET 64
+
+static struct lirc_buffer rbuf;
+static lirc_t wbuf[WBUF_LEN];
+static unsigned char cmdir_char[4*WBUF_LEN];
+static unsigned char write_control[MCU_CTRL_SIZE];
+static unsigned int last_mc_time = 0;
+static int usb_status=ON;
+static unsigned char signal_num=0;
+char timerval=0;
+
+unsigned int freq = 38000;
+/* unsigned int duty_cycle = 50; */
+
+
+#ifndef MAX_UDELAY_MS
+#define MAX_UDELAY_US 5000
+#else
+#define MAX_UDELAY_US (MAX_UDELAY_MS*1000)
+#endif
+
+static inline void safe_udelay(unsigned long usecs)
+{
+	while(usecs>MAX_UDELAY_US)
+	{
+		udelay(MAX_UDELAY_US);
+		usecs-=MAX_UDELAY_US;
+	}
+	udelay(usecs);
+}
+
+static unsigned int get_time_value(unsigned int firstint, unsigned int secondint, unsigned char overflow) 
+{	/* get difference between two timestamps from MCU */
+	unsigned int t_answer = 0;
+	
+	if (secondint > firstint) 
+	{
+		t_answer = secondint - firstint + overflow*65536;
+	} 
+	else 
+	{
+		if (overflow > 0) 
+		{
+			t_answer = (65536 - firstint) + secondint + (overflow - 1)*65536;
+		} 
+		else 
+		{
+			t_answer = (65536 - firstint) + secondint;
+		}
+	}
+
+	/* clamp to long signal  */
+	if (t_answer > 16000000) t_answer = PULSE_MASK;
+	
+	return t_answer;
+}
+
+
+static int set_use_inc(void* data)
+{
+	/* Init read buffer. */
+	if (lirc_buffer_init(&rbuf, sizeof(lirc_t), RBUF_LEN) < 0)
+	{
+		return -ENOMEM;
+	}
+	
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	lirc_buffer_free(&rbuf);
+	MOD_DEC_USE_COUNT;
+}
+
+
+static void usb_error_handle(int retval)
+{
+	switch (retval)
+	{
+		case -ENODEV:
+			/* device has been unplugged */
+			if (usb_status == ON)
+			{
+				usb_status = OFF;
+				printk(LIRC_DRIVER_NAME ": device is unplugged\n");
+			}
+			break;
+		default:
+			printk(LIRC_DRIVER_NAME ": usb error = %d\n", retval);
+			break;
+	}
+}
+
+static int write_to_usb(unsigned char *buffer, int count, int time_elapsed)
+{
+	int write_return;
+	
+	write_return = cmdir_write(buffer, count, NULL, time_elapsed);
+	if (write_return != count)
+	{
+		usb_error_handle(write_return);
+	}
+	else
+	{
+		if (usb_status == OFF) 
+		{
+			printk(LIRC_DRIVER_NAME ": device is now plugged in\n");
+			usb_status = ON;
+		}
+	}
+	return write_return;
+}
+
+static void set_freq(void)
+{
+	/* float tempfreq=0.0; */
+	int write_return;
+	
+	/* can't use floating point in 2.6 kernel! May be some loss of precision */
+	timerval = (1000000 / freq) / 2;
+	write_control[0]=FREQ_HEADER;
+	write_control[1]=timerval;
+	write_control[2]=0;
+	write_return = write_to_usb(write_control, MCU_CTRL_SIZE, 0);
+	if (write_return == MCU_CTRL_SIZE) printk(LIRC_DRIVER_NAME ": freq set to %dHz\n", freq);
+	else printk(LIRC_DRIVER_NAME ": freq unchanged\n");
+
+}
+
+static int cmdir_convert_RX(unsigned char *orig_rxbuffer)
+{
+	unsigned char tmp_char_buffer[80];
+	unsigned int tmp_int_buffer[20];
+	unsigned int final_data_buffer[20];	
+	unsigned int num_data_values = 0;
+	unsigned char num_data_bytes = 0;
+	unsigned int orig_index = 0;
+	int i;
+	
+	for (i=0; i<80; i++) tmp_char_buffer[i]=0;
+	for (i=0; i<20; i++) tmp_int_buffer[i]=0;
+
+	/* get number of data bytes that follow the control bytes (NOT including them)	 */
+	num_data_bytes = orig_rxbuffer[1];
+	
+	/* check if num_bytes is multiple of 3; if not, error  */
+	if (num_data_bytes%3 > 0) return -1;
+	if (num_data_bytes > 60) return -3; 
+	if (num_data_bytes < 3) return -2;
+	
+	/* get number of ints to be returned; num_data_bytes does NOT include control bytes */
+	num_data_values = num_data_bytes/3;
+	
+	for (i=0; i<num_data_values; i++) 
+	{
+		tmp_char_buffer[i*4] = orig_rxbuffer[(i+1)*3];
+		tmp_char_buffer[i*4+1] = orig_rxbuffer[(i+1)*3+1];
+		tmp_char_buffer[i*4+2] = 0;
+		tmp_char_buffer[i*4+3] = 0;
+	}
+		
+	/* convert to int array */
+	memcpy((unsigned char*)tmp_int_buffer, tmp_char_buffer, (num_data_values*4));
+
+	if (orig_rxbuffer[5] < 255) // space
+	{
+		final_data_buffer[0] = get_time_value(last_mc_time, tmp_int_buffer[0],
+			 orig_rxbuffer[5]);
+	} 
+	else 
+	{
+		/* is pulse */
+		final_data_buffer[0] = get_time_value(last_mc_time, tmp_int_buffer[0], 0);
+		final_data_buffer[0] |= PULSE_BIT;
+	}
+	for (i=1; i<num_data_values; i++) 
+	{
+		/* index of orig_rxbuffer that corresponds to overflow/pulse/space  */
+		orig_index = (i+1)*3 + 2;
+		if (orig_rxbuffer[orig_index] < 255) 
+		{
+			final_data_buffer[i] = get_time_value(tmp_int_buffer[i-1],
+				 tmp_int_buffer[i], orig_rxbuffer[orig_index]);
+		} 
+		else 
+		{
+			final_data_buffer[i] = get_time_value(tmp_int_buffer[i-1],
+				 tmp_int_buffer[i], 0);
+			final_data_buffer[i] |= PULSE_BIT;
+		}
+	}
+	last_mc_time = tmp_int_buffer[num_data_values-1];
+		
+	if(lirc_buffer_full(&rbuf))   
+	{
+		printk(KERN_ERR  LIRC_DRIVER_NAME ": lirc_buffer is full\n");
+		return -EOVERFLOW;
+	}	
+	lirc_buffer_write_n(&rbuf, (char*)final_data_buffer, num_data_values);
+
+	return 0;
+}
+
+
+static int usb_read_once(void)
+{
+	int read_retval = 0;
+	int conv_retval = 0;
+	unsigned char read_buffer[MAX_PACKET];
+	int i=0;
+	int tooFull = 5;  // read up to 5 packets 
+	
+	for (i=0; i<MAX_PACKET; i++) read_buffer[i] = 0;
+	
+	while(tooFull--){
+		read_retval = cmdir_read(read_buffer, MAX_PACKET); 
+		if(read_buffer[1] < 60) tooFull = 0;  // loop until we unload the data build-up
+		if (!(read_retval == MAX_PACKET)) 
+		{
+			if (read_retval == -ENODEV) 
+			{
+				if (usb_status==ON) 
+				{
+					printk(KERN_ALERT LIRC_DRIVER_NAME ": device is unplugged\n");
+					usb_status = OFF;
+				}
+			}
+			else
+			{
+				/* supress errors */
+				printk(KERN_ALERT LIRC_DRIVER_NAME ": usb error on read = %d\n",
+						read_retval);  
+				return -ENODATA;
+			}
+			// printk("Error 3\n");
+			return -ENODATA;
+		}
+		else
+		{
+			if (usb_status==OFF) 
+			{
+				usb_status = ON;
+				printk(LIRC_DRIVER_NAME ": device is now plugged in\n");
+			}
+		}
+	
+		if (read_buffer[0] & 0x08) 
+		{
+			conv_retval = cmdir_convert_RX(read_buffer);
+			if (conv_retval == 0) 
+			{
+				if(!tooFull) {
+					return 0; // else printk("Looping for more data...\n");
+				}
+			}
+			else
+			{
+				// printk("Error 2: %d\n", (int)conv_retval);
+				return -ENODATA;
+			}
+		} 
+		else 
+		{
+			// printk("Empty RX Buffer!\n");
+			return -ENODATA;  // There really is no data in their buffer
+		}
+	}
+	return -1;
+}
+
+int add_to_buf (void* data, struct lirc_buffer* buf)
+{
+	return usb_read_once();
+}
+
+
+static ssize_t lirc_write(struct file *file, const char *buf,
+			 size_t n, loff_t * ppos)
+{
+	int i,count;
+	int num_bytes_to_send;
+	unsigned int mod_signal_length=0;
+	unsigned int cur_freq=0;
+	unsigned int time_elapse=0;
+	unsigned int total_time_elapsed=0;
+	/* double wbuf_mod=0.0;			//no floating point in 2.6 kernel  */
+	unsigned int num_bytes_already_sent=0;
+	unsigned int hibyte=0;
+	unsigned int lobyte=0;
+	int cmdir_cnt =0;
+	unsigned int wait_this = 0;
+	struct timeval start_time; 
+	struct timeval end_time; 
+	unsigned int real_time_elapsed = 0; 
+	// int first_signal = 0;
+	
+	// save the time we started the write:
+	do_gettimeofday(&start_time);
+		
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+
+	count=n/sizeof(lirc_t);
+	if(count>WBUF_LEN || count%2==0) return(-EINVAL);	
+	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+
+	// the first time we have to flag that this is the start of a new signal
+	// otherwise COMMANDIR may receive 2 back-to-back pulses & invert the signal
+	cmdir_char[0] = TX_HEADER_NEW;
+	signal_num++;
+	cmdir_char[1] = signal_num;
+	cmdir_cnt = 2;
+	for(i=0;i<count;i++)
+	{
+		// prev_length_waited += wbuf[i];
+	
+		/* conversion to number of modulation frequency pulse edges */
+		mod_signal_length = wbuf[i] >> 3;
+
+		//if (mod_signal_length%2 == 1) mod_signal_length++;  //want even number
+		/* if (i%2==0) mod_signal_length-=5;
+		else mod_signal_length+=5;	
+		*/
+		// account for minor rounding errors - calculate length from this:
+		time_elapse += mod_signal_length * timerval;
+
+		hibyte = mod_signal_length/256;
+		lobyte = mod_signal_length%256;
+		cmdir_char[cmdir_cnt+1] = lobyte;
+		cmdir_char[cmdir_cnt] = hibyte;
+		// (unsigned short)(cmdir_char[cmdir_cnt]) = mod_signal_length;
+		cmdir_cnt += 2;
+		
+		/* write data to usb if full packet is collected */
+		if (cmdir_cnt%MAX_PACKET == 0)
+		{
+			write_to_usb(cmdir_char, MAX_PACKET,  time_elapse);
+			
+			total_time_elapsed += time_elapse;
+			
+			num_bytes_already_sent+= MAX_PACKET;
+			time_elapse = 0;
+			
+			if ((i+1)<count) // still more to send:
+			{
+				cmdir_char[0] =	TX_HEADER;  // Next Packet
+				cmdir_char[1] = signal_num;
+				cmdir_cnt = 2; // reset the count
+			}
+		}
+	}
+	
+	/* send last chunk of data */
+	if (cmdir_cnt > 0)
+	{
+		// time_elapse
+		total_time_elapsed += time_elapse; //time_elapse;
+		write_to_usb(cmdir_char, cmdir_cnt, time_elapse);
+	}
+	// ---------------------------------------------------------------------------
+	//  we need to _manually delay ourselves_ to remain backwards compatible with
+	// LIRC and prevent our queue buffer from overflowing.  Queuing in this driver
+	// is about instant, and send_start for example will fill it up quickly and 
+	// prevent send_stop from taking immediate effect.  
+	// ---------------------------------------------------------------------------
+	// printk("Total elapsed time is: %d. \n", total_time_elapsed);
+	do_gettimeofday(&end_time);
+	// udelay for the difference between endtime and start+total_time_elapsed
+	if(start_time.tv_usec < end_time.tv_usec){
+		real_time_elapsed = (end_time.tv_usec - start_time.tv_usec);
+	} else {
+		real_time_elapsed = ((end_time.tv_usec +  1000000) - start_time.tv_usec);
+	}
+	// printk("Real time elapsed was %u.\n", real_time_elapsed);
+	if(real_time_elapsed < (total_time_elapsed-1000)){
+		wait_this = total_time_elapsed - real_time_elapsed - 1000;
+	}
+	//  safe_udelay(wait_this); // enable this for backwards compatibility
+	
+	return(n);
+}
+
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		      unsigned long arg)
+{
+        int result;
+	unsigned long value;
+	unsigned int ivalue;
+	unsigned int multiplier=1;
+	unsigned int mask=0;
+	int i;
+	switch(cmd)
+	{
+	case LIRC_SET_TRANSMITTER_MASK:
+		if (!(hardware.features&LIRC_CAN_SET_TRANSMITTER_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		for(i=0;i<MAX_CHANNELS;i++) 
+		{
+			multiplier=multiplier*0x10;
+			mask|=multiplier;
+		}
+		if(ivalue >= mask) return (MAX_CHANNELS);
+		set_tx_channels(ivalue);
+		return (0);
+		break;
+				
+	case LIRC_GET_SEND_MODE:
+		if(!(hardware.features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=put_user(LIRC_SEND2MODE
+				(hardware.features&LIRC_CAN_SEND_MASK),
+				(unsigned long *) arg);
+		if(result) return(result); 
+		break;
+	
+	case LIRC_SET_SEND_MODE:
+		if(!(hardware.features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=get_user(value,(unsigned long *) arg);
+		if(result) return(result);
+		break;
+		
+	case LIRC_GET_LENGTH:
+		return(-ENOSYS);
+		break;
+		
+	case LIRC_SET_SEND_DUTY_CYCLE:
+#               ifdef DEBUG
+		printk(KERN_WARNING LIRC_DRIVER_NAME ": SET_SEND_DUTY_CYCLE\n");
+#               endif
+
+		if(!(hardware.features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
+		{
+			return(-ENOIOCTLCMD);
+		}
+				
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		
+		/* TODO: */
+		/* printk(LIRC_DRIVER_NAME ": set_send_duty_cycle not yet supported\n"); */
+	
+		return 0;
+		break;
+		
+	case LIRC_SET_SEND_CARRIER:
+#               ifdef DEBUG
+		printk(KERN_WARNING LIRC_DRIVER_NAME ": SET_SEND_CARRIER\n");
+#               endif
+		
+		if(!(hardware.features&LIRC_CAN_SET_SEND_CARRIER))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue>500000 || ivalue<24000) return(-EINVAL);
+		if (ivalue != freq) 
+		{
+			freq=ivalue;
+			set_freq();
+		}
+		return 0;
+		break;
+		
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+static struct file_operations lirc_fops =
+{
+	write:   lirc_write,
+};
+
+static struct lirc_plugin plugin = {
+	name:		LIRC_DRIVER_NAME,
+	minor:		-1,
+	code_length:	1,
+	sample_rate:	20,
+	data:		NULL,
+	add_to_buf:	add_to_buf,
+	get_queue:	NULL,
+	rbuf:		&rbuf,
+	set_use_inc:	set_use_inc,
+	set_use_dec:	set_use_dec,
+	ioctl:		lirc_ioctl,
+	fops:		&lirc_fops,
+	dev:		NULL,
+	owner:		THIS_MODULE,
+};
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Evelyn Yeung, Matt Bodkin");
+MODULE_DESCRIPTION("InnovationOne driver for CommandIR USB infrared transceiver");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+#ifndef KERNEL_2_5
+EXPORT_NO_SYMBOLS;
+#endif
+
+int init_module(void)
+{
+	plugin.features = hardware.features;
+	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) 
+	{
+		printk(KERN_ERR  LIRC_DRIVER_NAME  
+		       ": register_chrdev failed!\n");
+		return -EIO;
+	}
+	set_freq();
+	return 0;
+}
+
+void cleanup_module(void)
+{
+	lirc_unregister_plugin(plugin.minor);
+	printk(KERN_INFO  LIRC_DRIVER_NAME  ": module removed\n");
+}
+
+#endif
+
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_cmdir.h linux-2.6.23.1-stm/drivers/char/lirc/lirc_cmdir.h
--- linux-2.6.23.1/drivers/char/lirc/lirc_cmdir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_cmdir.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,26 @@
+/*      $Id: lirc_cmdir.h,v 1.2 2005/09/25 12:03:39 lirc Exp $      */
+
+/*
+ *   lirc_cmdir.h
+ */
+
+#ifndef LIRC_CMDIR_H
+#define LIRC_CMDIR_H
+
+#define ON          1
+#define OFF         0
+
+/* transmitter channel control */
+#define MAX_CHANNELS     32
+
+/* CommandIR control codes */
+#define MCU_CTRL_SIZE   3
+#define FREQ_HEADER     2
+#define TX_HEADER       7
+#define TX_HEADER_NEW		8 
+
+extern int cmdir_write (unsigned char *buffer, int count, void *callback_fct, int u);
+extern ssize_t cmdir_read (unsigned char *buffer, size_t count);
+extern int set_tx_channels (unsigned int next_tx);
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_dev.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_dev.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_dev.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,967 @@
+/*
+ * LIRC base driver
+ * 
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: lirc_dev.c,v 1.51 2007/02/13 06:45:15 lirc Exp $
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+ 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <asm/errno.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/wrapper.h>
+#endif
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+
+/* SysFS header */
+#if defined(LIRC_HAVE_SYSFS)
+#include <linux/device.h>
+#endif
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+static int debug = 0;
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+
+#define IRCTL_DEV_NAME	  "lirc"
+#define IRCTL_DEV_MAJOR   61
+
+#define SUCCESS           0
+#define NOPLUG            -1
+#define LOGHEAD           "lirc_dev (%s[%d]): "
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+#include <linux/platform_device.h>
+static struct platform_device *lirc_platform_device;
+#endif
+
+struct irctl
+{
+	struct lirc_plugin p;
+	int attached;
+	int open;
+
+	struct semaphore buffer_sem;
+	struct lirc_buffer *buf;
+
+	int tpid;
+	struct semaphore *t_notify;
+	struct semaphore *t_notify2;
+	int shutdown;
+	long jiffies_to_wait;
+
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_handle_t devfs_handle;
+#endif
+};
+
+DECLARE_MUTEX(plugin_lock);
+
+static struct irctl irctls[MAX_IRCTL_DEVICES];
+static struct file_operations fops;
+
+/* Only used for sysfs but defined to void otherwise */
+static lirc_class_t *lirc_class;
+
+/*  helper function
+ *  initializes the irctl structure
+ */
+static inline void init_irctl(struct irctl *ir)
+{
+	memset(&ir->p, 0, sizeof(struct lirc_plugin));
+	sema_init(&ir->buffer_sem, 1);
+	ir->p.minor = NOPLUG;
+
+	ir->tpid = -1;
+	ir->t_notify = NULL;
+	ir->t_notify2 = NULL;
+	ir->shutdown = 0;
+	ir->jiffies_to_wait = 0;
+
+	ir->open = 0;
+	ir->attached = 0;
+}
+
+static void cleanup(struct irctl *ir)
+{
+	dprintk(LOGHEAD "cleaning up\n", ir->p.name, ir->p.minor);
+
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_unregister(ir->devfs_handle);
+#endif
+#ifdef LIRC_HAVE_DEVFS_26
+	devfs_remove(DEV_LIRC "/%u", ir->p.minor);
+#endif
+	class_device_destroy(lirc_class,MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+
+	if (ir->buf != ir->p.rbuf){
+		lirc_buffer_free(ir->buf);
+		kfree(ir->buf);
+	}
+	ir->buf = NULL;
+	
+	init_irctl(ir);
+}
+
+/*  helper function
+ *  reads key codes from plugin and puts them into buffer
+ *  buffer free space is checked and locking performed
+ *  returns 0 on success
+ */
+static inline int add_to_buf(struct irctl *ir)
+{
+	if (lirc_buffer_full(ir->buf)) {
+		dprintk(LOGHEAD "buffer overflow\n",
+			ir->p.name, ir->p.minor);
+		return -EOVERFLOW;
+	}
+
+	if(ir->p.add_to_buf) {
+		int res = -ENODATA;
+		int got_data = 0;
+		
+		/* service the device as long as it is returning
+		 * data and we have space
+		 */
+		while( !lirc_buffer_full(ir->buf) )
+		{
+			res = ir->p.add_to_buf( ir->p.data, ir->buf );
+			if( res == SUCCESS )
+				got_data++;
+			else
+				break;
+		}
+		
+		if( res == -ENODEV )
+		{
+			ir->shutdown = 1;
+		}
+		return (got_data ? SUCCESS : res);
+	}
+	
+	return SUCCESS;
+}
+
+/* main function of the polling thread
+ */
+static int lirc_thread(void *irctl)
+{
+	struct irctl *ir = irctl;
+	
+	/* This thread doesn't need any user-level access,
+	 * so get rid of all our resources
+	 */
+	daemonize("lirc_dev");
+	
+	if (ir->t_notify != NULL) {
+		up(ir->t_notify);
+	}
+	
+	dprintk(LOGHEAD "poll thread started\n", ir->p.name, ir->p.minor);
+	
+	do {
+		if (ir->open) {
+			if (ir->jiffies_to_wait) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(ir->jiffies_to_wait);
+			} else {
+				interruptible_sleep_on(ir->p.get_queue(ir->p.data));
+			}
+			if (ir->shutdown) {
+				break;
+			}
+			if (!add_to_buf(ir)) {
+				wake_up_interruptible(&ir->buf->wait_poll);
+			}
+		} else {
+			/* if device not opened so we can sleep half a second */
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/2);
+		}
+	} while (!ir->shutdown);
+	
+	if (ir->t_notify2 != NULL) {
+		down(ir->t_notify2);
+	}
+
+	ir->tpid = -1;
+	if (ir->t_notify != NULL) {
+		up(ir->t_notify);
+	}
+	
+	dprintk(LOGHEAD "poll thread ended\n", ir->p.name, ir->p.minor);
+	
+	return 0;
+}
+
+/*
+ *
+ */
+int lirc_register_plugin(struct lirc_plugin *p)
+{
+	struct irctl *ir;
+	int minor;
+	int bytes_in_key;
+	int err;
+#ifdef LIRC_HAVE_DEVFS_24
+	char name[16];
+#endif
+	DECLARE_MUTEX_LOCKED(tn);
+
+	if (!p) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "plugin pointer must be not NULL!\n");
+		err = -EBADRQC;
+		goto out;
+	}
+
+	if (MAX_IRCTL_DEVICES <= p->minor) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "\"minor\" must be between 0 and %d (%d)!\n",
+		       MAX_IRCTL_DEVICES-1, p->minor);
+		err = -EBADRQC;
+		goto out;
+	}
+
+	if (1 > p->code_length || (BUFLEN*8) < p->code_length) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "code length in bits for minor (%d) "
+		       "must be less than %d!\n",
+		       p->minor, BUFLEN*8);
+		err = -EBADRQC;
+		goto out;
+	}
+
+	printk("lirc_dev: lirc_register_plugin: "
+	       "sample_rate: %d\n",p->sample_rate);
+	if (p->sample_rate) {
+		if (2 > p->sample_rate || HZ < p->sample_rate) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "sample_rate must be between 2 and %d!\n", HZ);
+			err = -EBADRQC;
+			goto out;
+		}
+		if (!p->add_to_buf) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "add_to_buf cannot be NULL when "
+			       "sample_rate is set\n");
+			err = -EBADRQC;
+			goto out;
+		}
+	} else if (!(p->fops && p->fops->read)
+		   && !p->get_queue && !p->rbuf) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "fops->read, get_queue and rbuf "
+		       "cannot all be NULL!\n");
+		err = -EBADRQC;
+		goto out;
+	} else if (!p->get_queue && !p->rbuf) {
+		if (!(p->fops && p->fops->read && p->fops->poll) 
+		    || (!p->fops->ioctl && !p->ioctl)) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "neither read, poll nor ioctl can be NULL!\n");
+			err = -EBADRQC;
+			goto out;
+		}
+	}
+
+#ifdef MODULE
+	if (p->owner == NULL) {
+		printk(KERN_WARNING "lirc_dev: lirc_register_plugin: "
+				    "no module owner registered\n");
+		err = -EBADRQC;
+		goto out;
+	}
+#endif
+	down(&plugin_lock);
+
+	minor = p->minor;
+
+	if (0 > minor) {
+		/* find first free slot for plugin */
+		for (minor=0; minor<MAX_IRCTL_DEVICES; minor++)
+			if (irctls[minor].p.minor == NOPLUG)
+				break;
+		if (MAX_IRCTL_DEVICES == minor) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "no free slots for plugins!\n");
+			err = -ENOMEM;
+			goto out_lock;
+		}
+	} else if (irctls[minor].p.minor != NOPLUG) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "minor (%d) just registered!\n", minor);
+		err = -EBUSY;
+		goto out_lock;
+	}
+
+	ir = &irctls[minor];
+
+	if (p->sample_rate) {
+		ir->jiffies_to_wait = HZ / p->sample_rate;
+	} else {
+                /* it means - wait for externeal event in task queue */
+		ir->jiffies_to_wait = 0;
+	} 
+
+	/* some safety check 8-) */
+	p->name[sizeof(p->name)-1] = '\0';
+
+	bytes_in_key = p->code_length/8 + (p->code_length%8 ? 1 : 0);
+	
+	if (p->rbuf) {
+		ir->buf = p->rbuf;
+	} else {
+		ir->buf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+		if(!ir->buf) {
+			err = -ENOMEM;
+			goto out_lock;
+		}
+		if(lirc_buffer_init
+		   (ir->buf, bytes_in_key, BUFLEN/bytes_in_key) != 0) {
+			kfree(ir->buf);
+			err = -ENOMEM;
+			goto out_lock;
+		}
+	}
+
+	if (p->features==0)
+		p->features = (p->code_length > 8) ?
+			LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_CODE;
+
+	ir->p = *p;
+	ir->p.minor = minor;
+
+#if defined(LIRC_HAVE_DEVFS_24)
+	sprintf (name, DEV_LIRC "/%d", ir->p.minor);
+	ir->devfs_handle = devfs_register(NULL, name, DEVFS_FL_DEFAULT,
+					  IRCTL_DEV_MAJOR, ir->p.minor,
+					  S_IFCHR | S_IRUSR | S_IWUSR,
+					  &fops, NULL);
+#elif defined(LIRC_HAVE_DEVFS_26)
+	devfs_mk_cdev(MKDEV(IRCTL_DEV_MAJOR, ir->p.minor),
+			S_IFCHR|S_IRUSR|S_IWUSR,
+			DEV_LIRC "/%u", ir->p.minor);
+#endif
+	(void) lirc_class_device_create(lirc_class, NULL, 
+					MKDEV(IRCTL_DEV_MAJOR, ir->p.minor),
+					ir->p.dev, "lirc%u", ir->p.minor);
+
+	if(p->sample_rate || p->get_queue) {
+		/* try to fire up polling thread */
+		ir->t_notify = &tn;
+		ir->tpid = kernel_thread(lirc_thread, (void*)ir, 0);
+		if (ir->tpid < 0) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "cannot run poll thread for minor = %d\n",
+			       p->minor);
+			err = -ECHILD;
+			goto out_sysfs;
+		}
+		down(&tn);
+		ir->t_notify = NULL;
+	}
+	ir->attached = 1;
+	up(&plugin_lock);
+
+/*
+ * Recent kernels should handle this autmatically by increasing/decreasing
+ * use count when a dependant module is loaded/unloaded.
+ */
+#ifndef KERNEL_2_5
+	MOD_INC_USE_COUNT;
+#endif
+	printk("lirc_dev: plugin %s registered at minor number = %d\n",
+		ir->p.name, ir->p.minor);
+	printk("lirc_dev: device interface at /dev/lirc%u\n", ir->p.minor);
+	p->minor = minor;
+	return minor;
+	
+out_sysfs:
+	class_device_destroy(lirc_class,MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_unregister(ir->devfs_handle);
+#endif
+#ifdef LIRC_HAVE_DEVFS_26
+	devfs_remove(DEV_LIRC "/%i", ir->p.minor);
+#endif
+out_lock:
+	up(&plugin_lock);
+out:
+	return err;
+}
+
+/*
+ *
+ */
+int lirc_unregister_plugin(int minor)
+{
+	struct irctl *ir;
+	DECLARE_MUTEX_LOCKED(tn);
+	DECLARE_MUTEX_LOCKED(tn2);
+
+	if (minor < 0 || minor >= MAX_IRCTL_DEVICES) {
+		printk("lirc_dev: lirc_unregister_plugin: "
+		       "\"minor\" must be between 0 and %d!\n",
+		       MAX_IRCTL_DEVICES-1);
+		return -EBADRQC;
+	}
+
+	ir = &irctls[minor];
+
+	down(&plugin_lock);
+
+	if (ir->p.minor != minor) {
+		printk("lirc_dev: lirc_unregister_plugin: "
+		       "minor (%d) device not registered!", minor);
+		up(&plugin_lock);
+		return -ENOENT;
+	}
+
+	/* end up polling thread */
+	if (ir->tpid >= 0) {
+		ir->t_notify = &tn;
+		ir->t_notify2 = &tn2;
+		ir->shutdown = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		{
+			struct task_struct *p;
+			
+			p = find_task_by_pid(ir->tpid);
+			wake_up_process(p);
+		}
+#else
+		/* 2.2.x does not export wake_up_process() */
+		wake_up_interruptible(ir->p.get_queue(ir->p.data));
+#endif
+		up(&tn2);
+		down(&tn);
+		ir->t_notify = NULL;
+		ir->t_notify2 = NULL;
+	}
+
+	dprintk("lirc_dev: plugin %s unregistered from minor number = %d\n",
+		ir->p.name, ir->p.minor);
+
+	ir->attached = 0;
+	if (ir->open) {
+		dprintk(LOGHEAD "releasing opened plugin\n",
+			ir->p.name, ir->p.minor);
+		wake_up_interruptible(&ir->buf->wait_poll);
+		down(&ir->buffer_sem);
+		ir->p.set_use_dec(ir->p.data);
+		module_put(ir->p.owner);
+		up(&ir->buffer_sem);
+	}
+	else
+	{
+		cleanup(ir);
+	}
+	up(&plugin_lock);
+
+/*
+ * Recent kernels should handle this autmatically by increasing/decreasing
+ * use count when a dependant module is loaded/unloaded.
+ */
+#ifndef KERNEL_2_5
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return SUCCESS;
+}
+
+/*
+ *
+ */
+static int irctl_open(struct inode *inode, struct file *file)
+{
+	struct irctl *ir;
+	int retval;
+	
+	if (MINOR(inode->i_rdev) >= MAX_IRCTL_DEVICES) {
+		dprintk("lirc_dev [%d]: open result = -ENODEV\n",
+			MINOR(inode->i_rdev));
+		return -ENODEV;
+	}
+
+	ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "open called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has an open function use it instead */
+	if(ir->p.fops && ir->p.fops->open)
+		return ir->p.fops->open(inode, file);
+
+	if (down_interruptible(&plugin_lock))
+	{
+		return -ERESTARTSYS;
+	}
+
+	if (ir->p.minor == NOPLUG) {
+		up(&plugin_lock);
+		dprintk(LOGHEAD "open result = -ENODEV\n",
+			ir->p.name, ir->p.minor);
+		return -ENODEV;
+	}
+
+	if (ir->open) {
+		up(&plugin_lock);
+		dprintk(LOGHEAD "open result = -EBUSY\n",
+			ir->p.name, ir->p.minor);
+		return -EBUSY;
+	}
+
+	/* there is no need for locking here because ir->open is 0 
+         * and lirc_thread isn't using buffer
+	 * plugins which use irq's should allocate them on set_use_inc,
+	 * so there should be no problem with those either.
+         */
+	ir->buf->head = ir->buf->tail;
+	ir->buf->fill = 0;
+
+#ifdef MODULE
+	if(ir->p.owner!=NULL && try_module_get(ir->p.owner))
+	{
+#endif
+		++ir->open;
+		retval = ir->p.set_use_inc(ir->p.data);
+		
+		if (retval != SUCCESS) {
+			module_put(ir->p.owner);
+			--ir->open;
+		}
+#ifdef MODULE
+	}
+	else
+	{
+		if(ir->p.owner==NULL)
+		{
+			dprintk(LOGHEAD "no module owner!!!\n", ir->p.name, ir->p.minor);
+		}
+		retval = -ENODEV;
+	}
+#endif
+
+	dprintk(LOGHEAD "open result = %d\n", ir->p.name, ir->p.minor, retval);
+	up(&plugin_lock);
+
+	return retval;
+}
+
+/*
+ *
+ */
+static int irctl_close(struct inode *inode, struct file *file)
+{
+	struct irctl *ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "close called\n", ir->p.name, ir->p.minor);
+ 
+	/* if the plugin has a close function use it instead */
+	if(ir->p.fops && ir->p.fops->release)
+		return ir->p.fops->release(inode, file);
+
+	if (down_interruptible(&plugin_lock))
+	{
+		return -ERESTARTSYS;
+	}
+
+	--ir->open;
+	if(ir->attached)
+	{
+		ir->p.set_use_dec(ir->p.data);
+		module_put(ir->p.owner);
+	}
+	else
+	{
+		cleanup(ir);
+	}
+
+	up(&plugin_lock);
+
+	return SUCCESS;
+}
+
+/*
+ *
+ */
+static unsigned int irctl_poll(struct file *file, poll_table *wait)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	unsigned int ret;
+
+	dprintk(LOGHEAD "poll called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a poll function use it instead */
+	if(ir->p.fops && ir->p.fops->poll)
+		return ir->p.fops->poll(file, wait);
+
+	down(&ir->buffer_sem);
+	if(!ir->attached)
+	{
+		up(&ir->buffer_sem);
+		return POLLERR;
+	}
+
+	poll_wait(file, &ir->buf->wait_poll, wait);
+
+	dprintk(LOGHEAD "poll result = %s\n",
+		ir->p.name, ir->p.minor, 
+		lirc_buffer_empty(ir->buf) ? "0" : "POLLIN|POLLRDNORM");
+
+	ret = lirc_buffer_empty(ir->buf) ? 0 : (POLLIN|POLLRDNORM);
+	
+	up(&ir->buffer_sem);
+	return ret;
+}
+
+/*
+ *
+ */
+static int irctl_ioctl(struct inode *inode, struct file *file,
+                       unsigned int cmd, unsigned long arg)
+{
+	unsigned long mode;
+	int result;
+	struct irctl *ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "ioctl called (0x%x)\n",
+		ir->p.name, ir->p.minor, cmd);
+
+	/* if the plugin has a ioctl function use it instead */
+	if(ir->p.fops && ir->p.fops->ioctl)
+		return ir->p.fops->ioctl(inode, file, cmd, arg);
+
+	if (ir->p.minor == NOPLUG || !ir->attached) {
+		dprintk(LOGHEAD "ioctl result = -ENODEV\n",
+			ir->p.name, ir->p.minor);
+		return -ENODEV;
+	}
+
+	/* Give the plugin a chance to handle the ioctl */
+	if(ir->p.ioctl){
+		result = ir->p.ioctl(inode, file, cmd, arg);
+		if (result != -ENOIOCTLCMD)
+			return result;
+	}
+	/* The plugin can't handle cmd */
+	result = SUCCESS;
+
+	switch(cmd)
+	{
+	case LIRC_GET_FEATURES:
+		result = put_user(ir->p.features, (unsigned long*)arg);
+		break;
+	case LIRC_GET_REC_MODE:
+		if(!(ir->p.features&LIRC_CAN_REC_MASK))
+			return(-ENOSYS);
+		
+		result = put_user(LIRC_REC2MODE
+				  (ir->p.features&LIRC_CAN_REC_MASK),
+				  (unsigned long*)arg);
+		break;
+	case LIRC_SET_REC_MODE:
+		if(!(ir->p.features&LIRC_CAN_REC_MASK))
+			return(-ENOSYS);
+
+		result = get_user(mode, (unsigned long*)arg);
+		if(!result && !(LIRC_MODE2REC(mode) & ir->p.features)) {
+			result = -EINVAL;
+		}
+		/* FIXME: We should actually set the mode somehow 
+		 * but for now, lirc_serial doesn't support mode changin
+		 * eighter */
+		break;
+	case LIRC_GET_LENGTH:
+		result = put_user((unsigned long)ir->p.code_length, 
+				  (unsigned long *)arg);
+		break;
+	default:
+		result = -ENOIOCTLCMD;
+	}
+
+	dprintk(LOGHEAD "ioctl result = %d\n",
+		ir->p.name, ir->p.minor, result);
+
+	return result;
+}
+
+/*
+ *
+ */
+static ssize_t irctl_read(struct file *file,
+			  char *buffer,   
+			  size_t length, 
+			  loff_t *ppos)     
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	unsigned char buf[ir->buf->chunk_size];
+	int ret=0, written=0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->read)
+		return ir->p.fops->read(file, buffer, length, ppos);
+
+	if(down_interruptible(&ir->buffer_sem))
+	{
+		return -ERESTARTSYS;
+	}
+	if(!ir->attached)
+	{
+		up(&ir->buffer_sem);
+		return -ENODEV;
+	}
+
+	if (length % ir->buf->chunk_size) {
+		dprintk(LOGHEAD "read result = -EINVAL\n",
+			ir->p.name, ir->p.minor);
+		up(&ir->buffer_sem);
+		return -EINVAL;
+	}
+
+	/* we add ourselves to the task queue before buffer check 
+         * to avoid losing scan code (in case when queue is awaken somewhere 
+	 * beetwen while condition checking and scheduling)
+	 */
+	add_wait_queue(&ir->buf->wait_poll, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	/* while we did't provide 'length' bytes, device is opened in blocking
+	 * mode and 'copy_to_user' is happy, wait for data.
+	 */
+	while (written < length && ret == 0) { 
+		if (lirc_buffer_empty(ir->buf)) {
+			/* According to the read(2) man page, 'written' can be
+			 * returned as less than 'length', instead of blocking
+			 * again, returning -EWOULDBLOCK, or returning
+			 * -ERESTARTSYS */
+			if (written) break;
+			if (file->f_flags & O_NONBLOCK) {
+				ret = -EWOULDBLOCK;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+			set_current_state(TASK_INTERRUPTIBLE);
+			if(!ir->attached)
+			{
+				ret = -ENODEV;
+				break;
+			}
+		} else {
+			lirc_buffer_read_1(ir->buf, buf);
+			ret = copy_to_user((void *)buffer+written, buf,
+					   ir->buf->chunk_size);
+			written += ir->buf->chunk_size;
+		}
+	}
+
+	remove_wait_queue(&ir->buf->wait_poll, &wait);
+	set_current_state(TASK_RUNNING);
+	up(&ir->buffer_sem);
+	
+	dprintk(LOGHEAD "read result = %s (%d)\n",
+		ir->p.name, ir->p.minor, ret ? "-EFAULT" : "OK", ret);
+
+	return ret ? ret : written;
+}
+
+
+void *lirc_get_pdata(struct file *file)
+{
+	void *data=NULL;
+
+	if (file && file->f_dentry && file->f_dentry->d_inode &&
+	    file->f_dentry->d_inode->i_rdev )
+	{
+		struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+		data=ir->p.data;
+	}
+
+	return data;
+}
+
+
+static ssize_t irctl_write(struct file *file, const char *buffer,
+			   size_t length, loff_t * ppos)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+
+	dprintk(LOGHEAD "write called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->write)
+		return ir->p.fops->write(file, buffer, length, ppos);
+
+	if(!ir->attached)
+	{
+		return -ENODEV;
+	}
+
+	return -EINVAL;
+}
+
+
+static struct file_operations fops = {
+	read:    irctl_read, 
+	write:   irctl_write,
+	poll:    irctl_poll,
+	ioctl:   irctl_ioctl,
+	open:    irctl_open,
+	release: irctl_close
+};
+
+
+EXPORT_SYMBOL(lirc_get_pdata);
+EXPORT_SYMBOL(lirc_register_plugin);
+EXPORT_SYMBOL(lirc_unregister_plugin);
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+static int __init lirc_probe(struct device *dev)
+{
+	lirc_platform_device=to_platform_device(dev);
+
+	if (lirc_platform_device->name != NULL)
+		printk(KERN_INFO "lirc_dev: Device probe found data for platform device %s\n", 
+                       lirc_platform_device->name);
+	else
+		printk(KERN_ERR "lirc_dev: Device probe failed.  Check your kernel SoC config!!\n");
+
+        return 0;
+}
+
+static struct device_driver lirc_device_driver = {
+        .name           = IRCTL_DEV_NAME,
+        .bus            = &platform_bus_type,
+        .probe          = lirc_probe,
+};
+
+void* lirc_get_config()
+{
+	return (void*)lirc_platform_device;
+}
+
+EXPORT_SYMBOL(lirc_get_config);
+
+#endif
+
+/*
+ *
+ */
+static int __init lirc_dev_init(void)
+{  	
+	int i;
+
+	for (i=0; i < MAX_IRCTL_DEVICES; ++i) {
+		init_irctl(&irctls[i]);	
+	}
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+	if(driver_register(&lirc_device_driver)) {
+		printk(KERN_ERR "lirc_dev: driver_register failed\n");
+		goto out;
+        }
+#endif
+	if(register_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME, &fops)) {
+		printk(KERN_ERR "lirc_dev: register_chrdev failed\n");
+		goto out;
+	}
+
+	lirc_class = class_create(THIS_MODULE, IRCTL_DEV_NAME);
+	if(IS_ERR(lirc_class)) {
+		printk(KERN_ERR "lirc_dev: class_create failed\n");
+		goto out_unregister;
+	}
+
+	printk("lirc_dev: IR Remote Control driver registered, at major %d \n", 
+	       IRCTL_DEV_MAJOR);
+
+	return SUCCESS;
+
+out_unregister:
+	unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+out:
+	return -1;
+}
+
+/* ---------------------------------------------------------------------- */
+/*
+ *
+ */
+void __exit lirc_dev_exit(void)
+{
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+	driver_unregister(&lirc_device_driver);
+#endif
+	unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+	class_destroy(lirc_class);
+        dprintk("lirc_dev: module successfully unloaded\n");
+}
+
+MODULE_DESCRIPTION("LIRC base driver module");
+MODULE_AUTHOR("Artur Lipowski");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(IRCTL_DEV_MAJOR);
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+module_init(lirc_dev_init);
+module_exit(lirc_dev_exit);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_dev.h linux-2.6.23.1-stm/drivers/char/lirc/lirc_dev.h
--- linux-2.6.23.1/drivers/char/lirc/lirc_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_dev.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,265 @@
+/*
+ * LIRC base driver
+ * 
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *        This code is licensed under GNU GPL
+ *
+ * $Id: lirc_dev.h,v 1.20 2007/04/22 10:21:37 lirc Exp $
+ *
+ */
+
+#ifndef _LINUX_LIRC_DEV_H
+#define _LINUX_LIRC_DEV_H
+
+#define MAX_IRCTL_DEVICES 4
+#define BUFLEN            16
+
+//#define LIRC_BUFF_POWER_OF_2
+#ifdef LIRC_BUFF_POWER_OF_2
+#define mod(n, div) ((n) & ((div) -1))
+#else
+#define mod(n, div) ((n) % (div))
+#endif
+#include <linux/slab.h>
+#include <linux/fs.h>
+
+struct lirc_buffer
+{
+        wait_queue_head_t wait_poll;
+	spinlock_t lock;
+
+	unsigned char *data;
+	unsigned int chunk_size;
+	unsigned int size; /* in chunks */
+	unsigned int fill; /* in chunks */
+	int head, tail;    /* in chunks */
+	/* Using chunks instead of bytes pretends to simplify boundary checking 
+	 * And should allow for some performance fine tunning later */
+};
+static inline void _lirc_buffer_clear(struct lirc_buffer *buf)
+{
+	buf->head = buf->tail = buf->fill = 0;
+}
+static inline int lirc_buffer_init(struct lirc_buffer *buf,
+				    unsigned int chunk_size,
+				    unsigned int size)
+{
+	/* Adjusting size to the next power of 2 would allow for
+	 * inconditional LIRC_BUFF_POWER_OF_2 optimization */
+	init_waitqueue_head(&buf->wait_poll);
+	spin_lock_init(&buf->lock);
+	_lirc_buffer_clear(buf);
+	buf->chunk_size = chunk_size;
+	buf->size = size;
+	buf->data = kmalloc(size*chunk_size, GFP_KERNEL);
+	if (buf->data == NULL)
+		return -1;
+	memset(buf->data, 0, size*chunk_size);
+	return 0;
+}
+static inline void lirc_buffer_free(struct lirc_buffer *buf)
+{
+	kfree(buf->data);
+	buf->data = NULL;
+	buf->head = buf->tail = buf->fill = 0;
+	buf->chunk_size = 0;
+	buf->size = 0;
+}
+static inline int  lirc_buffer_full(struct lirc_buffer *buf)
+{
+	return (buf->fill >= buf->size);
+}
+static inline int  lirc_buffer_empty(struct lirc_buffer *buf)
+{
+	return !(buf->fill);
+}
+static inline int  lirc_buffer_available(struct lirc_buffer *buf)
+{
+    return (buf->size - buf->fill);
+}
+static inline void lirc_buffer_lock(struct lirc_buffer *buf, unsigned long *flags)
+{
+	spin_lock_irqsave(&buf->lock, *flags);
+}
+static inline void lirc_buffer_unlock(struct lirc_buffer *buf, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&buf->lock, *flags);
+}
+static inline void lirc_buffer_clear(struct lirc_buffer *buf)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_clear(buf);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_remove_1(struct lirc_buffer *buf)
+{
+	buf->head = mod(buf->head+1, buf->size);
+	buf->fill -= 1;
+}
+static inline void lirc_buffer_remove_1(struct lirc_buffer *buf)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_remove_1(buf);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_read_1(struct lirc_buffer *buf,
+				     unsigned char *dest)
+{
+	memcpy(dest, &buf->data[buf->head*buf->chunk_size], buf->chunk_size);
+	buf->head = mod(buf->head+1, buf->size);
+	buf->fill -= 1;
+}
+static inline void lirc_buffer_read_1(struct lirc_buffer *buf,
+				      unsigned char *dest)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_read_1(buf, dest);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_write_1(struct lirc_buffer *buf,
+				      unsigned char *orig)
+{
+	memcpy(&buf->data[buf->tail*buf->chunk_size], orig, buf->chunk_size);
+	buf->tail = mod(buf->tail+1, buf->size);
+	buf->fill++;
+}
+static inline void lirc_buffer_write_1(struct lirc_buffer *buf,
+				       unsigned char *orig)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_write_1(buf, orig);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_write_n(struct lirc_buffer *buf,
+					unsigned char* orig, int count)
+{
+	memcpy(&buf->data[buf->tail*buf->chunk_size], orig,
+	       count*buf->chunk_size);
+	buf->tail = mod(buf->tail+count, buf->size);
+	buf->fill += count;
+}
+static inline void lirc_buffer_write_n(struct lirc_buffer *buf,
+				       unsigned char* orig, int count)
+{
+	unsigned long flags;
+	int space1;
+	lirc_buffer_lock(buf,&flags);
+	if( buf->head > buf->tail ) space1 = buf->head - buf->tail;
+	else space1 = buf->size - buf->tail;
+	
+	if( count > space1 )
+	{
+		_lirc_buffer_write_n(buf, orig, space1);
+		_lirc_buffer_write_n(buf, orig+(space1*buf->chunk_size),
+				     count-space1);
+	}
+	else
+	{
+		_lirc_buffer_write_n(buf, orig, count);
+	}
+	lirc_buffer_unlock(buf, &flags);
+}
+
+struct lirc_plugin
+{
+	char name[40];
+	int minor;
+	int code_length;
+	int sample_rate;
+	unsigned long features;
+	void* data;
+	int (*add_to_buf) (void* data, struct lirc_buffer* buf);
+	wait_queue_head_t* (*get_queue) (void* data);
+	struct lirc_buffer *rbuf;
+	int (*set_use_inc) (void* data);
+	void (*set_use_dec) (void* data);
+	int (*ioctl) (struct inode *,struct file *,unsigned int,
+		      unsigned long);
+	struct file_operations *fops;
+	struct device *dev;
+	struct module *owner;
+};
+/* name:
+ * this string will be used for logs
+ *
+ * minor:
+ * indicates minor device (/dev/lirc) number for registered plugin
+ * if caller fills it with negative value, then the first free minor 
+ * number will be used (if available)
+ *
+ * code_length:
+ * length of the remote control key code expressed in bits
+ *
+ * sample_rate:
+ * sample_rate equal to 0 means that no polling will be performed and
+ * add_to_buf will be triggered by external events (through task queue
+ * returned by get_queue)
+ *
+ * data:
+ * it may point to any plugin data and this pointer will be passed to
+ * all callback functions
+ *
+ * add_to_buf:
+ * add_to_buf will be called after specified period of the time or
+ * triggered by the external event, this behavior depends on value of
+ * the sample_rate this function will be called in user context. This
+ * routine should return 0 if data was added to the buffer and
+ * -ENODATA if none was available. This should add some number of bits
+ * evenly divisible by code_length to the buffer
+ *
+ * get_queue:
+ * this callback should return a pointer to the task queue which will
+ * be used for external event waiting
+ *
+ * rbuf:
+ * if not NULL, it will be used as a read buffer, you will have to
+ * write to the buffer by other means, like irq's (see also
+ * lirc_serial.c).
+ *
+ * set_use_inc:
+ * set_use_inc will be called after device is opened
+ *
+ * set_use_dec:
+ * set_use_dec will be called after device is closed
+ *
+ * ioctl:
+ * Some ioctl's can be directly handled by lirc_dev but will be
+ * forwared here if not NULL and only handled if it returns
+ * -ENOIOCTLCMD (see also lirc_serial.c).
+ *
+ * fops:
+ * file_operations for drivers which don't fit the current plugin model.
+ * 
+ * owner:
+ * the module owning this struct
+ *
+ */
+
+
+/* following functions can be called ONLY from user context
+ *
+ * returns negative value on error or minor number 
+ * of the registered device if success
+ * contens of the structure pointed by p is copied
+ */
+extern int lirc_register_plugin(struct lirc_plugin *p);
+
+/* returns negative value on error or 0 if success
+*/
+extern int lirc_unregister_plugin(int minor);
+
+/* Returns the private data stored in the lirc_plugin
+ * associated with the given device file pointer.
+ */
+void *lirc_get_pdata(struct file *file);
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+/* Returns the platform lirc private data */
+void* lirc_get_config(void);
+#endif
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_gpio.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_gpio.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_gpio.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,589 @@
+/*
+ * Remote control driver for the TV-card
+ * key codes are obtained from GPIO port
+ * 
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *     patch for the AverMedia by Santiago Garcia Mantinan <manty@i.am>
+ *                            and Christoph Bartelmus <lirc@bartelmus.de>
+ *     patch for the BestBuy by Miguel Angel Alvarez <maacruz@navegalia.com>
+ *     patch for the Winfast TV2000 by Juan Toledo
+ *     <toledo@users.sourceforge.net>
+ *     patch for the I-O Data GV-BCTV5/PCI by Jens C. Rasmussen
+ *     <jens.rasmussen@ieee.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: lirc_gpio.c,v 1.49 2007/02/13 06:45:15 lirc Exp $
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 4)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.2.4 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/wrapper.h>
+#endif
+#include <linux/errno.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#include "../../char/bttv.h"
+#include "../../char/bttvp.h"
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+#include "../../media/video/bttv.h"
+#include "../../media/video/bttvp.h"
+#else
+#include "../../media/video/bt8xx/bttv.h"
+#include "../../media/video/bt8xx/bttvp.h"
+#endif
+
+#if BTTV_VERSION_CODE < KERNEL_VERSION(0,7,45)
+#error "*******************************************************"
+#error " Sorry, this driver needs bttv version 0.7.45 or       "
+#error " higher. If you are using the bttv package, copy it to "
+#error " the kernel                                            "
+#error "*******************************************************"
+#endif
+
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+/* insmod parameters */
+static int debug = 0;
+static int card = 0;
+static int minor = -1;
+static int bttv_id = BTTV_BOARD_UNKNOWN;
+static unsigned long gpio_mask = 0;
+static unsigned long gpio_enable = 0;
+static unsigned long gpio_lock_mask = 0;
+static unsigned long gpio_xor_mask = 0;
+static int soft_gap = 0;
+static int sample_rate = 10;
+
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+struct rcv_info {
+	int bttv_id;
+	int card_id;
+	unsigned long gpio_mask;
+	unsigned long gpio_enable;
+	unsigned long gpio_lock_mask;
+	unsigned long gpio_xor_mask;
+	int soft_gap;
+	int sample_rate;
+	unsigned char code_length;
+};
+
+static struct rcv_info rcv_infos[] = {
+	{BTTV_BOARD_UNKNOWN,                0,          0,          0,         0,          0,   0,  1,  0},
+	{BTTV_BOARD_PXELVWPLTVPAK,          0, 0x00003e00,          0, 0x0010000,          0,   0, 15, 32},
+	{BTTV_BOARD_PXELVWPLTVPRO,          0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_BOARD_PV_BT878P_9B,           0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_BOARD_PV_BT878P_PLUS,         0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+#ifdef BTTV_BOARD_PV_M4900
+	{BTTV_BOARD_PV_M4900,               0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+#endif
+	{BTTV_BOARD_AVERMEDIA,              0, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32},
+	{BTTV_BOARD_AVPHONE98,     0x00011461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
+	{BTTV_BOARD_AVERMEDIA98,   0x00021461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
+	{BTTV_BOARD_AVPHONE98,     0x00031461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* is this one correct? */
+	{BTTV_BOARD_AVERMEDIA98,   0x00041461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* work-around for VDOMATE */
+	{BTTV_BOARD_AVERMEDIA98,   0x03001461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* reported by Danijel Korzinek, AVerTV GOw/FM */
+	{BTTV_BOARD_AVERMEDIA98,   0x00000000, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	{BTTV_BOARD_CHRONOS_VS2,            0, 0x000000f8,          0, 0x0000100,          0,   0, 20,  0},
+	/* CPH031 and CPH033 cards (?) */
+	/* MIRO was just a work-around */
+	{BTTV_BOARD_MIRO,                   0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+	{BTTV_BOARD_DYNALINK,               0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+#ifdef BTTV_BOARD_ASKEY_CPH03X
+	{BTTV_BOARD_ASKEY_CPH03X,           0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+#endif
+	{BTTV_BOARD_WINVIEW_601,            0, 0x00001f00,          0, 0x0004000,          0,   0,  0, 32},
+#ifdef BTTV_BOARD_KWORLD
+	{BTTV_BOARD_KWORLD,                 0, 0x00007f00,          0, 0x0004000,          0,   0, 12, 32},
+#endif
+	/* just a guess */
+	{BTTV_BOARD_MAGICTVIEW061,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+ 	{BTTV_BOARD_MAGICTVIEW063,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+ 	{BTTV_BOARD_PHOEBE_TVMAS,           0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+#ifdef BTTV_BOARD_BESTBUY_EASYTV2
+        {BTTV_BOARD_BESTBUY_EASYTV,         0, 0x00007F00,          0, 0x0004000,          0,   0, 10,  8},
+        {BTTV_BOARD_BESTBUY_EASYTV2,        0, 0x00007F00,          0, 0x0008000,          0,   0, 10,  8},
+#endif
+	/* lock_mask probably also 0x100, or maybe it is 0x0 for all others !?! */
+	{BTTV_BOARD_FLYVIDEO,               0, 0x000000f8,          0,         0,          0,   0,  0, 42},
+ 	{BTTV_BOARD_FLYVIDEO_98,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+ 	{BTTV_BOARD_TYPHOON_TVIEW,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+#ifdef BTTV_BOARD_FLYVIDEO_98FM
+	/* smorar@alfonzo.smuts.uct.ac.za */
+	{BTTV_BOARD_FLYVIDEO_98FM,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+#endif
+	/* The Leadtek WinFast TV 2000 XP card (id 0x6606107d) uses an
+	 * extra gpio bit compared to the original TV 2000 card (id
+	 * 0x217d6606); as the bttv-0.7.100 driver does not
+	 * distinguish between the two cards, we enable the extra bit
+	 * based on the card id: */
+	{BTTV_BOARD_WINFAST2000,   0x6606107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
+	{BTTV_BOARD_WINFAST2000,   0x6609107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
+	{BTTV_BOARD_WINFAST2000,   0xff06107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
+	/* default: */
+	{BTTV_BOARD_WINFAST2000,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 32},
+#ifdef BTTV_BOARD_GVBCTV5PCI
+	{BTTV_BOARD_GVBCTV5PCI,             0, 0x00f0b000,          0,         0,          0,   0, 20,  8},
+#endif
+};
+
+static unsigned char code_length = 0;
+static unsigned char code_bytes = 1;
+
+#define MAX_BYTES 8
+
+#define SUCCESS 0
+#define LOGHEAD "lirc_gpio (%d): "
+
+/* how many bits GPIO value can be shifted right before processing
+ * it is computed from the value of gpio_mask_parameter
+ */
+static unsigned char gpio_pre_shift = 0;
+
+
+static inline int reverse(int data, int bits)
+{
+	int i;
+	int c;
+	
+	for (c=0,i=0; i<bits; i++) {
+		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
+	}
+
+	return c;
+}
+
+static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
+{
+	unsigned long mask = gpio_mask;
+	unsigned char shift = 0;
+
+	dprintk(LOGHEAD "gpio_val is %lx\n",card,(unsigned long) gpio_val);
+	
+	gpio_val ^= gpio_xor_mask;
+	
+	if (gpio_lock_mask && (gpio_val & gpio_lock_mask)) {
+		return -EBUSY;
+	}
+	
+	switch (bttv_id)
+	{
+	case BTTV_BOARD_AVERMEDIA98:
+		if (bttv_write_gpio(card, gpio_enable, gpio_enable)) {
+			dprintk(LOGHEAD "cannot write to GPIO\n", card);
+			return -EIO;
+		}
+		if (bttv_read_gpio(card, &gpio_val)) {
+			dprintk(LOGHEAD "cannot read GPIO\n", card);
+			return -EIO;
+		}
+		if (bttv_write_gpio(card, gpio_enable, 0)) {
+			dprintk(LOGHEAD "cannot write to GPIO\n", card);
+			return -EIO;
+		}
+		break;
+	default:
+		break;
+	}
+	
+	/* extract bits from "raw" GPIO value using gpio_mask */
+	codes[0] = 0;
+	gpio_val >>= gpio_pre_shift;
+	while (mask) {
+		if (mask & 1u) {
+			codes[0] |= (gpio_val & 1u) << shift++;
+		}
+		mask >>= 1;
+		gpio_val >>= 1;
+	}
+	
+	dprintk(LOGHEAD "code is %lx\n",card,(unsigned long) codes[0]);
+	switch (bttv_id)
+	{
+	case BTTV_BOARD_AVERMEDIA:
+		codes[2] = (codes[0]<<2)&0xff;
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0x02;
+		codes[1] = 0xFD;
+		break;
+	case BTTV_BOARD_AVPHONE98:
+		codes[2] = ((codes[0]&(~0x1))<<2)&0xff;
+		codes[3] = (~codes[2])&0xff;
+		if (codes[0]&0x1) {
+			codes[0] = 0xc0;
+			codes[1] = 0x3f;
+		} else {
+			codes[0] = 0x40;
+			codes[1] = 0xbf;
+		}
+		break;
+	case BTTV_BOARD_AVERMEDIA98:
+		break;
+	case BTTV_BOARD_FLYVIDEO:
+	case BTTV_BOARD_FLYVIDEO_98:
+	case BTTV_BOARD_TYPHOON_TVIEW:
+#ifdef BTTV_BOARD_FLYVIDEO_98FM
+	case BTTV_BOARD_FLYVIDEO_98FM:
+#endif
+		codes[4]=codes[0]<<3;
+		codes[5]=((~codes[4])&0xff);
+		
+		codes[0]=0x00;
+		codes[1]=0x1A;
+		codes[2]=0x1F;
+		codes[3]=0x2F;
+		break;
+        case BTTV_BOARD_MAGICTVIEW061:
+        case BTTV_BOARD_MAGICTVIEW063:
+	case BTTV_BOARD_PHOEBE_TVMAS:
+		codes[0] = (codes[0]&0x01)
+			|((codes[0]&0x02)<<1)
+			|((codes[0]&0x04)<<2)
+			|((codes[0]&0x08)>>2)
+			|((codes[0]&0x10)>>1);
+		/* FALLTHROUGH */
+	case BTTV_BOARD_MIRO:
+	case BTTV_BOARD_DYNALINK:
+#ifdef BTTV_BOARD_ASKEY_CPH03X
+	case BTTV_BOARD_ASKEY_CPH03X:
+#endif
+	case BTTV_BOARD_PXELVWPLTVPAK:
+	case BTTV_BOARD_PXELVWPLTVPRO:
+	case BTTV_BOARD_PV_BT878P_9B:
+	case BTTV_BOARD_PV_BT878P_PLUS:
+#ifdef BTTV_BOARD_PV_M4900
+	case BTTV_BOARD_PV_M4900:
+#endif
+#ifdef BTTV_BOARD_KWORLD
+	case BTTV_BOARD_KWORLD:
+#endif
+		codes[2] = reverse(codes[0],8);
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0x61;
+		codes[1] = 0xD6;
+		break;
+#if 0
+		/* derived from e-tech config file */
+		/* 26 + 16 bits */
+		/* won't apply it until it's confirmed with a fly98 */
+ 	case BTTV_BOARD_FLYVIDEO_98:
+	case BTTV_BOARD_FLYVIDEO_98FM:
+		codes[4]=codes[0]<<3;
+		codes[5]=(~codes[4])&0xff;
+		
+		codes[0]=0x00;
+		codes[1]=0x1A;
+		codes[2]=0x1F;
+		codes[3]=0x2F;
+		break;
+#endif
+	case BTTV_BOARD_WINFAST2000:
+		/* shift extra bit */
+		codes[0] = (codes[0]&0x1f) | ((codes[0]&0x20) << 1);
+	case BTTV_BOARD_WINVIEW_601:
+		codes[2] = reverse(codes[0],8);
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0xC0;
+		codes[1] = 0x3F;
+		break;
+	default:
+		break;
+	}
+
+	return SUCCESS;
+}
+
+/* add_to_buf - copy a code to the buffer */
+static int add_to_buf(void* data, struct lirc_buffer* buf)
+{
+	static unsigned long next_time = 0;
+	static unsigned char prev_codes[MAX_BYTES];
+	unsigned long code = 0;
+	unsigned char cur_codes[MAX_BYTES];
+    
+	if (bttv_read_gpio(card, &code)) {
+		dprintk(LOGHEAD "cannot read GPIO\n", card);
+		return -EIO;
+	}
+	
+	if (build_key(code, cur_codes)) {
+		return -EFAULT;
+	}
+	
+	if (soft_gap) {
+		if (!memcmp(prev_codes, cur_codes, code_bytes) &&
+			jiffies < next_time) {
+			return -EAGAIN;
+		}
+		next_time = jiffies + soft_gap;
+	}
+	memcpy( prev_codes, cur_codes, code_bytes );
+		
+	lirc_buffer_write_1( buf, cur_codes );
+		
+	return SUCCESS;
+}
+
+static int set_use_inc(void* data)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static wait_queue_head_t* get_queue(void* data)
+{
+	return bttv_get_gpio_queue(card);
+}
+
+static struct lirc_plugin plugin = {
+	.name		= "lirc_gpio  ",
+	.add_to_buf	= add_to_buf,
+	.get_queue	= get_queue,
+	.set_use_inc	= set_use_inc,
+	.set_use_dec	= set_use_dec,
+	.dev		= NULL,
+	.owner          = THIS_MODULE,
+};
+
+/*
+ *
+ */
+static int gpio_remote_init(void)
+{  	
+	int ret;
+	unsigned int mask;
+
+	/* "normalize" gpio_mask
+	 * this means shift it right until first bit is set
+	 */
+	while (!(gpio_mask & 1u)) {
+		gpio_pre_shift++;
+		gpio_mask >>= 1;
+	}
+
+	if (code_length) {
+		plugin.code_length = code_length;
+	} else {
+		/* calculate scan code length in bits if needed */
+		plugin.code_length = 1;
+		mask = gpio_mask >> 1;
+		while (mask) {
+			if (mask & 1u) {
+				plugin.code_length++;
+			}
+			mask >>= 1;
+		}
+	}
+
+	code_bytes = (plugin.code_length/8) + (plugin.code_length%8 ? 1 : 0);
+	if (MAX_BYTES < code_bytes) {
+		printk (LOGHEAD "scan code too long (%d bytes)\n",
+			minor, code_bytes);
+		return -EBADRQC;
+	}
+
+	if (gpio_enable) {
+		if(bttv_gpio_enable(card, gpio_enable, gpio_enable)) {
+			printk(LOGHEAD "gpio_enable failure\n", minor);
+			return -EIO;
+		}
+	}
+
+
+	/* translate ms to jiffies */
+	soft_gap = (soft_gap*HZ) / 1000;
+
+	plugin.minor = minor;
+	plugin.sample_rate = sample_rate;
+
+	ret = lirc_register_plugin(&plugin);
+	
+	if (0 > ret) {
+		printk (LOGHEAD "device registration failed with %d\n",
+			minor, ret);
+		return ret;
+	}
+	
+	minor = ret;
+	printk(LOGHEAD "driver registered\n", minor);
+
+	return SUCCESS;
+}
+
+#ifdef MODULE
+/*
+ *
+ */
+int init_module(void)
+{
+	int type,cardid,card_type;
+
+	if (MAX_IRCTL_DEVICES < minor) {
+		printk("lirc_gpio: parameter minor (%d) must be less than %d!\n",
+		       minor, MAX_IRCTL_DEVICES-1);
+		return -EBADRQC;
+	}
+	
+	request_module("bttv");
+
+	/* if gpio_mask not zero then use module parameters 
+	 * instead of autodetecting TV card
+	 */
+	if (gpio_mask) {
+		if (sample_rate!=0 &&
+		    (2 > sample_rate || HZ < sample_rate)) {
+			printk(LOGHEAD "parameter sample_rate "
+			       "must be between 2 and %d!\n", minor, HZ);
+			return -EBADRQC;
+		}
+
+		if (sample_rate!=0 && soft_gap && 
+		    ((2000/sample_rate) > soft_gap || 1000 < soft_gap)) {
+			printk(LOGHEAD "parameter soft_gap "
+			       "must be between %d and 1000!\n",
+			       minor, 2000/sample_rate);
+			return -EBADRQC;
+		}
+	} else {
+		if(bttv_get_cardinfo(card,&type,&cardid)==-1) {
+			printk(LOGHEAD "could not get card type\n", minor);
+			return -EBADRQC;
+		}
+		printk(LOGHEAD "card type 0x%x, id 0x%x\n",minor,
+		       type,cardid);
+
+		if (type == BTTV_BOARD_UNKNOWN) {
+			printk(LOGHEAD "cannot detect TV card nr %d!\n",
+			       minor, card);
+			return -EBADRQC;
+		}
+		for (card_type = 1;
+		     card_type < sizeof(rcv_infos)/sizeof(struct rcv_info); 
+		     card_type++) {
+			if (rcv_infos[card_type].bttv_id == type &&
+			    (rcv_infos[card_type].card_id == 0 ||
+			     rcv_infos[card_type].card_id == cardid)) {
+				bttv_id = rcv_infos[card_type].bttv_id;
+				gpio_mask = rcv_infos[card_type].gpio_mask;
+				gpio_enable = rcv_infos[card_type].gpio_enable;
+				gpio_lock_mask = rcv_infos[card_type].gpio_lock_mask;
+				gpio_xor_mask = rcv_infos[card_type].gpio_xor_mask;
+				soft_gap = rcv_infos[card_type].soft_gap;
+				sample_rate = rcv_infos[card_type].sample_rate;
+				code_length = rcv_infos[card_type].code_length;
+				break;
+			}
+		}
+		if (type==BTTV_BOARD_AVPHONE98 && cardid==0x00011461)	{
+			bttv_id = BTTV_BOARD_AVERMEDIA98;
+		}
+		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x00041461) {
+			bttv_id = BTTV_BOARD_AVPHONE98;
+		}
+		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x03001461) {
+			bttv_id = BTTV_BOARD_AVPHONE98;
+		}
+		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x00000000) {
+			bttv_id = BTTV_BOARD_AVPHONE98;
+		}
+		if (card_type == sizeof(rcv_infos)/sizeof(struct rcv_info)) {
+			printk(LOGHEAD "TV card type 0x%x not supported!\n",
+			       minor, type);
+			return -EBADRQC;
+		}
+	}
+
+	request_module("lirc_dev");
+
+	return gpio_remote_init();
+}
+
+/*
+ *
+ */
+void cleanup_module(void)
+{
+	lirc_unregister_plugin(minor);
+
+	dprintk(LOGHEAD "module successfully unloaded\n", minor);
+}
+
+/* Dont try to use it as a static version !  */
+MODULE_DESCRIPTION("Driver module for remote control (data from bt848 GPIO port)");
+MODULE_AUTHOR("Artur Lipowski");
+MODULE_LICENSE("GPL");
+
+module_param(minor, int, 0444);
+MODULE_PARM_DESC(minor, "Preferred minor device number");
+
+module_param(card, int, 0444);
+MODULE_PARM_DESC(card, "TV card number to attach to");
+
+module_param(gpio_mask, long, 0444);
+MODULE_PARM_DESC(gpio_mask, "gpio_mask");
+
+module_param(gpio_lock_mask, long, 0444);
+MODULE_PARM_DESC(gpio_lock_mask, "gpio_lock_mask");
+
+module_param(gpio_xor_mask, long, 0444);
+MODULE_PARM_DESC(gpio_xor_mask, "gpio_xor_mask");
+
+module_param(soft_gap, int, 0444);
+MODULE_PARM_DESC(soft_gap, "Time between keypresses (in ms)");
+
+module_param(sample_rate, int, 0444);
+MODULE_PARM_DESC(sample_rate, "Sample rate (between 2 and HZ)");
+
+module_param(bttv_id, int, 0444);
+MODULE_PARM_DESC(bttv_id, "BTTV card type");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_i2c.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_i2c.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_i2c.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,653 @@
+/*      $Id: lirc_i2c.c,v 1.39 2007/02/13 06:45:15 lirc Exp $      */
+
+/*
+ * i2c IR lirc plugin for Hauppauge and Pixelview cards - new 2.3.x i2c stack
+ *
+ * Copyright (c) 2000 Gerd Knorr <kraxel@goldbach.in-berlin.de>
+ * modified for PixelView (BT878P+W/FM) by
+ *      Michal Kochanowicz <mkochano@pld.org.pl>
+ *      Christoph Bartelmus <lirc@bartelmus.de>
+ * modified for KNC ONE TV Station/Anubis Typhoon TView Tuner by
+ *      Ulrich Mueller <ulrich.mueller42@web.de>
+ * modified for Asus TV-Box and Creative/VisionTek BreakOut-Box by
+ *      Stefan Jahn <stefan@lkcc.org>
+ * modified for inclusion into kernel sources by
+ *      Jerome Brock <jbrock@users.sourceforge.net>
+ * modified for Leadtek Winfast PVR2000 by
+ *      Thomas Reitmayr (treitmayr@yahoo.com)
+ *
+ * parts are cut&pasted from the old lirc_haup.c driver
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include <asm/semaphore.h>
+
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+struct IR {
+	struct lirc_plugin l;
+	struct i2c_client  c;
+	int nextkey;
+	unsigned char b[3];
+	unsigned char bits;
+	unsigned char flag;
+};
+
+/* ----------------------------------------------------------------------- */
+
+#define DEVICE_NAME "lirc_i2c"
+
+/* ----------------------------------------------------------------------- */
+/* insmod parameters                                                       */
+
+static int debug   = 0;    /* debug output */
+static int minor   = -1;   /* minor number */
+
+#define dprintk(fmt, args...)                                           \
+	do{                                                             \
+		if(debug) printk(KERN_DEBUG DEVICE_NAME ": " fmt,       \
+				 ## args);                              \
+	}while(0)
+
+/* ----------------------------------------------------------------------- */
+
+static inline int reverse(int data, int bits)
+{
+	int i;
+	int c;
+	
+	for (c=0,i=0; i<bits; i++) {
+		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
+	}
+
+	return c;
+}
+
+static int add_to_buf_adap(void* data, struct lirc_buffer* buf)
+{
+	struct IR *ir = data;
+	unsigned char keybuf[4];
+	
+	keybuf[0] = 0x00;
+	i2c_master_send(&ir->c,keybuf,1);
+	/* poll IR chip */
+	if(i2c_master_recv(&ir->c,keybuf,sizeof(keybuf)) != sizeof(keybuf))
+	{
+		dprintk("read error\n");
+		return -EIO;
+	}
+	
+	dprintk("key (0x%02x%02x%02x%02x)\n",
+		keybuf[0], keybuf[1], keybuf[2], keybuf[3]);
+	
+	/* key pressed ? */
+	if (keybuf[2] == 0xff)
+		return -ENODATA;
+	
+	/* remove repeat bit */
+	keybuf[2] &= 0x7f;
+	keybuf[3] |= 0x80;
+	
+	lirc_buffer_write_1(buf, keybuf);
+	return 0;
+}
+
+static int add_to_buf_pcf8574(void* data, struct lirc_buffer* buf)
+{
+	struct IR *ir = data;
+	int rc;
+	unsigned char all, mask;
+	unsigned char key;
+
+	/* compute all valid bits (key code + pressed/release flag) */
+	all = ir->bits | ir->flag;
+
+	/* save IR writable mask bits */
+	mask = i2c_smbus_read_byte(&ir->c) & ~all;
+
+	/* send bit mask */
+	rc = i2c_smbus_write_byte(&ir->c, (0xff & all) | mask);
+
+	/* receive scan code */
+	rc = i2c_smbus_read_byte(&ir->c);
+
+	if (rc == -1) {
+		dprintk("%s read error\n", ir->c.name);
+		return -EIO;
+	}
+
+	/* drop duplicate polls */
+	if (ir->b[0] == (rc & all)) {
+		return -ENODATA;
+	}
+	ir->b[0] = rc & all;
+
+	dprintk("%s key 0x%02X %s\n", ir->c.name, rc & ir->bits,
+		(rc & ir->flag) ? "released" : "pressed");
+
+	if (rc & ir->flag) {
+		/* ignore released buttons */
+		return -ENODATA;
+	}
+
+	/* set valid key code */
+	key  = rc & ir->bits;
+	lirc_buffer_write_1( buf, &key );
+	return 0;
+}
+
+/* common for Hauppauge IR receivers */
+static int add_to_buf_haup_common(void* data, struct lirc_buffer* buf,
+		unsigned char* keybuf, int size, int offset)
+{
+	struct IR *ir = data;
+	__u16 code;
+	unsigned char codes[2];
+
+	/* poll IR chip */
+	if (size == i2c_master_recv(&ir->c,keybuf,size)) {
+		ir->b[0] = keybuf[offset];
+		ir->b[1] = keybuf[offset+1];
+		ir->b[2] = keybuf[offset+2];
+		dprintk("key (0x%02x/0x%02x)\n", ir->b[0], ir->b[1]);
+	} else {
+		dprintk("read error\n");
+		/* keep last successfull read buffer */
+	}
+
+	/* key pressed ? */
+	if ((ir->b[0] & 0x80) == 0)
+		return -ENODATA;
+	
+	/* look what we have */
+	code = (((__u16)ir->b[0]&0x7f)<<6) | (ir->b[1]>>2);
+	
+	codes[0] = (code >> 8) & 0xff;
+	codes[1] = code & 0xff;
+
+	/* return it */
+	lirc_buffer_write_1( buf, codes );
+	return 0;
+}
+
+/* specific for the Hauppauge PVR150 IR receiver */
+static int add_to_buf_haup_pvr150(void* data, struct lirc_buffer* buf)
+{
+	unsigned char keybuf[6];
+	/* fetch 6 bytes, first relevant is at offset 3 */
+	return add_to_buf_haup_common(data, buf, keybuf, 6, 3);
+}
+
+/* used for all Hauppauge IR receivers but the PVR150 */
+static int add_to_buf_haup(void* data, struct lirc_buffer* buf)
+{
+	unsigned char keybuf[3];
+	/* fetch 3 bytes, first relevant is at offset 0 */
+	return add_to_buf_haup_common(data, buf, keybuf, 3, 0);
+}
+
+
+static int add_to_buf_pvr2000(void* data, struct lirc_buffer* buf)
+{
+	struct IR *ir = data;
+	unsigned char key;
+	s32 flags;
+	s32 code;
+
+	/* poll IR chip */
+	if (-1 == (flags = i2c_smbus_read_byte_data(&ir->c,0x10))) {
+		dprintk("read error\n");
+		return -ENODATA;
+	}
+	/* key pressed ? */
+	if (0 == (flags & 0x80))
+		return -ENODATA;
+
+	/* read actual key code */
+	if (-1 == (code = i2c_smbus_read_byte_data(&ir->c,0x00))) {
+		dprintk("read error\n");
+		return -ENODATA;
+	}
+
+	key = code & 0xFF;
+
+	dprintk("IR Key/Flags: (0x%02x/0x%02x)\n", key, flags & 0xFF);
+
+	/* return it */
+	lirc_buffer_write_1( buf, &key );
+	return 0;
+}
+
+static int add_to_buf_pixelview(void* data, struct lirc_buffer* buf)
+{
+	struct IR *ir = data;
+	unsigned char key;
+	
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+		dprintk("read error\n");
+		return -1;
+	}
+	dprintk("key %02x\n", key);
+
+	/* return it */
+	lirc_buffer_write_1( buf, &key );
+	return 0;
+}
+
+static int add_to_buf_pv951(void* data, struct lirc_buffer* buf)
+{
+	struct IR *ir = data;
+	unsigned char key;
+	unsigned char codes[4];
+
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+		dprintk("read error\n");
+		return -ENODATA;
+	}
+	/* ignore 0xaa */
+	if (key==0xaa)
+		return -ENODATA;
+	dprintk("key %02x\n", key);
+
+	codes[0] = 0x61;
+	codes[1] = 0xD6;
+	codes[2] = reverse(key,8);
+	codes[3] = (~codes[2])&0xff;
+	
+	lirc_buffer_write_1( buf, codes );
+	return 0;
+}
+
+static int add_to_buf_knc1(void *data, struct lirc_buffer* buf)
+{
+	static unsigned char last_key = 0xFF;
+	struct IR *ir = data;
+	unsigned char key;
+	
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+		dprintk("read error\n");
+		return -ENODATA;
+	}
+	
+	/* it seems that 0xFE indicates that a button is still hold
+	   down, while 0xFF indicates that no button is hold
+	   down. 0xFE sequences are sometimes interrupted by 0xFF */
+	
+	dprintk("key %02x\n", key);
+	
+	if( key == 0xFF )
+		return -ENODATA;
+	
+	if ( key == 0xFE )
+		key = last_key;
+
+	last_key = key;
+	lirc_buffer_write_1( buf, &key );
+
+	return 0;
+}
+
+static int set_use_inc(void* data)
+{
+	struct IR *ir = data;
+	int ret;
+
+	/* lock bttv in memory while /dev/lirc is in use  */
+	ret = i2c_use_client(&ir->c);
+	if(ret != 0) return ret;
+
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	struct IR *ir = data;
+
+	i2c_release_client(&ir->c);
+	MOD_DEC_USE_COUNT;
+}
+
+static struct lirc_plugin lirc_template = {
+	name:        "lirc_i2c",
+	set_use_inc: set_use_inc,
+	set_use_dec: set_use_dec,
+	dev:         NULL,
+	owner:       THIS_MODULE
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int ir_attach(struct i2c_adapter *adap, int addr,
+		      unsigned short flags, int kind);
+static int ir_detach(struct i2c_client *client);
+static int ir_probe(struct i2c_adapter *adap);
+static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+static struct i2c_driver driver = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+        name:           "i2c ir driver",
+        flags:          I2C_DF_NOTIFY,
+#else
+	.driver = {
+		owner:  THIS_MODULE,
+		name:   "i2c ir driver",
+	},
+#endif
+        id:             I2C_DRIVERID_EXP3, /* FIXME */
+        attach_adapter: ir_probe,
+        detach_client:  ir_detach,
+        command:        ir_command,
+};
+
+static struct i2c_client client_template = 
+{
+        name:   "unset",
+        driver: &driver
+};
+
+static int ir_attach(struct i2c_adapter *adap, int addr,
+		     unsigned short flags, int kind)
+{
+        struct IR *ir;
+	
+        client_template.adapter = adap;
+        client_template.addr = addr;
+	
+        if (NULL == (ir = kmalloc(sizeof(struct IR),GFP_KERNEL)))
+                return -ENOMEM;
+        memcpy(&ir->l,&lirc_template,sizeof(struct lirc_plugin));
+        memcpy(&ir->c,&client_template,sizeof(struct i2c_client));
+	
+	ir->c.adapter = adap;
+	ir->c.addr    = addr;
+	i2c_set_clientdata(&ir->c, ir);
+	ir->l.data    = ir;
+	ir->l.minor   = minor;
+	ir->l.sample_rate = 10;
+	ir->nextkey   = -1;
+
+	switch(addr)
+	{
+	case 0x64:
+		strcpy(ir->c.name,"Pixelview IR");
+		ir->l.code_length = 8;
+		ir->l.add_to_buf=add_to_buf_pixelview;
+		break;
+	case 0x4b:
+		strcpy(ir->c.name,"PV951 IR");
+		ir->l.code_length = 32;
+		ir->l.add_to_buf=add_to_buf_pv951;
+		break;
+	case 0x71:
+		/* The PVR150 IR receiver uses the same protocol as other 
+		   Hauppauge cards, but the data flow is different, so we need
+		   to deal with it by its own.
+		 */
+		strcpy(ir->c.name,"Hauppauge IR (PVR150)");
+		ir->l.code_length = 13;
+		ir->l.add_to_buf=add_to_buf_haup_pvr150;
+		break;
+	case 0x6b:
+		strcpy(ir->c.name,"Adaptec IR");
+		ir->l.code_length = 32;
+		ir->l.add_to_buf=add_to_buf_adap;
+		break;
+	case 0x18:
+	case 0x1a:
+#ifdef I2C_HW_B_CX2341X
+		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848) ||
+		    adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2341X))
+#else
+		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848))
+#endif
+		{
+			strcpy(ir->c.name,"Hauppauge IR");
+			ir->l.code_length = 13;
+			ir->l.add_to_buf=add_to_buf_haup;
+		}
+		else /* I2C_HW_B_CX2388x */
+		{
+			strcpy(ir->c.name,"Leadtek IR");
+			ir->l.code_length = 8;
+			ir->l.add_to_buf=add_to_buf_pvr2000;
+		}
+		break;
+	case 0x30:
+		strcpy(ir->c.name,"KNC ONE IR");
+		ir->l.code_length = 8;
+		ir->l.add_to_buf=add_to_buf_knc1;
+		break;
+	case 0x21:
+	case 0x23:
+		strcpy(ir->c.name,"TV-Box IR");
+		ir->l.code_length = 8;
+		ir->l.add_to_buf=add_to_buf_pcf8574;
+		ir->bits = flags & 0xff;
+		ir->flag = (flags >> 8) & 0xff;
+		break;
+		
+	default:
+		/* shouldn't happen */
+		printk("lirc_i2c: Huh? unknown i2c address (0x%02x)?\n",addr);
+		kfree(ir);
+		return -1;
+	}
+	printk("lirc_i2c: chip found @ 0x%02x (%s)\n",addr,ir->c.name);
+	
+	/* register device */
+	i2c_attach_client(&ir->c);
+	ir->l.minor = lirc_register_plugin(&ir->l);
+	
+	return 0;
+}
+
+static int ir_detach(struct i2c_client *client)
+{
+	struct IR *ir = i2c_get_clientdata(client);
+	
+	/* unregister device */
+	lirc_unregister_plugin(ir->l.minor);
+	i2c_detach_client(&ir->c);
+
+	/* free memory */
+	kfree(ir);
+	return 0;
+}
+
+static int ir_probe(struct i2c_adapter *adap) {
+	
+	/* The external IR receiver is at i2c address 0x34 (0x35 for
+	   reads).  Future Hauppauge cards will have an internal
+	   receiver at 0x30 (0x31 for reads).  In theory, both can be
+	   fitted, and Hauppauge suggest an external overrides an
+	   internal. 
+	   
+	   That's why we probe 0x1a (~0x34) first. CB 
+
+	   The i2c address for the Hauppauge PVR-150 card is 0xe2,
+	   so we need to probe 0x71 as well.
+	*/
+	
+	static const int probe[] = {
+		0x1a, /* Hauppauge IR external */
+		0x18, /* Hauppauge IR internal */
+		0x71, /* Hauppauge IR (PVR150) */
+		0x4b, /* PV951 IR */
+		0x64, /* Pixelview IR */
+		0x30, /* KNC ONE IR */
+		0x6b, /* Adaptec IR */
+		-1};
+	struct i2c_client c; char buf; int i,rc;
+
+#ifdef I2C_HW_B_CX2341X
+	if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848) ||
+	    adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2341X))
+#else
+	if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848))
+#endif
+	{
+		memset(&c,0,sizeof(c));
+		c.adapter = adap;
+		for (i = 0; -1 != probe[i]; i++) {
+			c.addr = probe[i];
+			rc = i2c_master_recv(&c,&buf,1);
+			dprintk("probe 0x%02x @ %s: %s\n",
+				probe[i], adap->name, 
+				(1 == rc) ? "yes" : "no");
+			if (1 == rc)
+			{
+				ir_attach(adap,probe[i],0,0);
+			}
+		}
+	}
+
+#ifdef I2C_HW_B_CX2388x
+	/* Leadtek Winfast PVR2000 */
+	else if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2388x)) {
+		memset(&c,0,sizeof(c));
+		c.adapter = adap;
+		c.addr    = 0x18;
+		rc = i2c_master_recv(&c,&buf,1);
+		dprintk("probe 0x%02x @ %s: %s\n",
+			c.addr, adap->name, 
+			(1 == rc) ? "yes" : "no");
+		if (1 == rc) {
+			ir_attach(adap,c.addr,0,0);
+		}
+	}
+#endif
+
+	/* Asus TV-Box and Creative/VisionTek BreakOut-Box (PCF8574) */
+	else if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_RIVA)) {
+		/* addresses to probe;
+		   leave 0x24 and 0x25 because SAA7113H possibly uses it 
+		   0x21 and 0x22 possibly used by SAA7108E 
+		   Asus:      0x21 is a correct address (channel 1 of PCF8574)
+		   Creative:  0x23 is a correct address (channel 3 of PCF8574)
+		   VisionTek: 0x23 is a correct address (channel 3 of PCF8574)
+		*/
+		static const int pcf_probe[] = { 0x20, 0x21, 0x22, 0x23,
+						 0x24, 0x25, 0x26, 0x27, -1 };
+		int ret1, ret2, ret3, ret4;
+		unsigned char bits = 0, flag = 0;
+
+		memset(&c,0,sizeof(c));
+		c.adapter = adap;
+		for (i = 0; -1 != pcf_probe[i]; i++) {
+			c.addr = pcf_probe[i];
+			ret1 = i2c_smbus_write_byte(&c, 0xff);
+			ret2 = i2c_smbus_read_byte(&c);
+			ret3 = i2c_smbus_write_byte(&c, 0x00);
+			ret4 = i2c_smbus_read_byte(&c);
+
+			/* ensure that the writable bitmask works correctly */
+			rc = 0;
+			if (ret1 != -1 && ret2 != -1 && 
+			    ret3 != -1 && ret4 != -1) {
+				/* in the Asus TV-Box: bit 1-0 */
+				if (((ret2 & 0x03) == 0x03) && 
+				    ((ret4 & 0x03) == 0x00)) {
+					bits = (unsigned char) ~0x07;
+					flag = 0x04;
+					rc = 1;
+				}
+				/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
+				if (((ret2 & 0xc0) == 0xc0) && 
+				    ((ret4 & 0xc0) == 0x00)) {
+					bits = (unsigned char) ~0xe0;
+					flag = 0x20;
+					rc = 1;
+				}
+			}
+			dprintk("probe 0x%02x @ %s: %s\n",
+				c.addr, adap->name, rc ? "yes" : "no");
+			if (rc)
+				ir_attach(adap,pcf_probe[i],bits|(flag<<8),0);
+		}
+	}
+		
+	return 0;
+}
+
+static int ir_command(struct i2c_client *client,unsigned int cmd, void *arg)
+{
+	/* nothing */
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+#ifdef MODULE
+
+int init_module(void)
+{
+	request_module("bttv");
+	request_module("rivatv");
+	request_module("ivtv");
+	request_module("cx8800");
+	i2c_add_driver(&driver);
+	return 0;
+}
+
+void cleanup_module(void)
+{
+	i2c_del_driver(&driver);
+}
+
+MODULE_DESCRIPTION("Infrared receiver driver for Hauppauge and Pixelview cards (i2c stack)");
+MODULE_AUTHOR("Gerd Knorr, Michal Kochanowicz, Christoph Bartelmus, Ulrich Mueller, Stefan Jahn, Jerome Brock");
+MODULE_LICENSE("GPL");
+
+module_param(minor, int, 0444);
+MODULE_PARM_DESC(minor, "Preferred minor device number");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_igorplugusb.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_igorplugusb.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_igorplugusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_igorplugusb.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,672 @@
+/* lirc_igorplugusb - USB remote support for LIRC
+ *
+ * Supports the standard homebrew IgorPlugUSB receiver with Igor's firmware.
+ * See http://www.cesko.host.sk/IgorPlugUSB/IgorPlug-USB%20(AVR)_eng.htm 
+ * 
+ * The device can only record bursts of up to 36 pulses/spaces.
+ * Works fine with RC5. Longer commands lead to device buffer overrun.
+ * (Maybe a better firmware or a microcontroller with more ram can help?)
+ *
+ * Version 0.1  [beta status]
+ *
+ * Copyright (C) 2004 Jan M. Hochstein <hochstein@algo.informatik.tu-darmstadt.de>
+ *
+ * This driver was derived from:
+ *   Paul Miller <pmiller9@users.sourceforge.net>
+ *      "lirc_atiusb" module
+ *   Vladimir Dergachev <volodya@minspring.com>'s 2002
+ *      "USB ATI Remote support" (input device)
+ *   Adrian Dewhurst <sailor-lk@sailorfrag.net>'s 2002
+ *      "USB StreamZap remote driver" (LIRC)
+ *   Artur Lipowski <alipowski@kki.net.pl>'s 2002
+ *      "lirc_dev" and "lirc_gpio" LIRC modules
+ *
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.4.0 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <linux/time.h>
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#if !defined(KERNEL_2_5)
+#        define USB_CTRL_GET_TIMEOUT    5
+#endif
+
+/* lock irctl structure */
+#define IRLOCK			down_interruptible(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* module identification */
+#define DRIVER_VERSION		"0.1"
+#define DRIVER_AUTHOR		\
+        "Jan M. Hochstein <hochstein@algo.informatik.tu-darmstadt.de>"
+#define DRIVER_DESC		"USB remote driver for LIRC"
+#define DRIVER_NAME		"lirc_igorplugusb"
+
+/* debugging support */
+#ifdef CONFIG_USB_DEBUG
+        static int debug = 1;
+#else
+        static int debug = 0;
+#endif
+
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+/* general constants */
+#define SUCCESS                 0
+
+/* One mode2 pulse/space has 4 bytes. */
+#define CODE_LENGTH             sizeof(lirc_t)
+
+/* Igor's firmware cannot record bursts longer than 36. */
+#define DEVICE_BUFLEN           36
+
+/** Header at the beginning of the device's buffer:
+        unsigned char data_length
+        unsigned char data_start    (!=0 means ring-buffer overrun)
+        unsigned char counter       (incremented by each burst)
+**/
+#define DEVICE_HEADERLEN        3
+
+/* This is for the gap */
+#define ADDITIONAL_LIRC_BYTES   2
+
+/* times to poll per second */
+#define SAMPLE_RATE             10
+
+
+/**** Igor's USB Request Codes */
+
+#define SET_INFRABUFFER_EMPTY   1
+/** 
+ * Params: none
+ * Answer: empty
+ *
+**/
+
+#define GET_INFRACODE           2
+/** 
+ * Params: 
+ *   wValue: offset to begin reading infra buffer
+ *
+ * Answer: infra data
+ *
+**/
+
+#define SET_DATAPORT_DIRECTION  3
+/** 
+ * Params: 
+ *   wValue: (byte) 1 bit for each data port pin (0=in, 1=out)
+ *
+ * Answer: empty
+ *
+**/
+
+#define GET_DATAPORT_DIRECTION  4
+/** 
+ * Params: none
+ *
+ * Answer: (byte) 1 bit for each data port pin (0=in, 1=out)
+ *
+**/
+
+#define SET_OUT_DATAPORT        5
+/** 
+ * Params: 
+ *   wValue: byte to write to output data port
+ *
+ * Answer: empty
+ *
+**/
+
+#define GET_OUT_DATAPORT        6
+/** 
+ * Params: none
+ *
+ * Answer: least significant 3 bits read from output data port
+ *
+**/
+
+#define GET_IN_DATAPORT         7
+/** 
+ * Params: none
+ *
+ * Answer: least significant 3 bits read from input data port
+ *
+**/
+
+#define READ_EEPROM             8
+/** 
+ * Params: 
+ *   wValue: offset to begin reading EEPROM
+ *
+ * Answer: EEPROM bytes
+ *
+**/
+
+#define WRITE_EEPROM            9
+/** 
+ * Params: 
+ *   wValue: offset to EEPROM byte
+ *   wIndex: byte to write
+ *
+ * Answer: empty
+ *
+**/
+
+#define SEND_RS232              10
+/** 
+ * Params: 
+ *   wValue: byte to send
+ *
+ * Answer: empty
+ *
+**/
+
+#define RECV_RS232              11
+/** 
+ * Params: none
+ *
+ * Answer: byte received
+ *
+**/
+
+#define SET_RS232_BAUD          12
+/** 
+ * Params: 
+ *   wValue: byte to write to UART bit rate register (UBRR)
+ *
+ * Answer: empty
+ *
+**/
+
+#define GET_RS232_BAUD          13
+/** 
+ * Params: none
+ *
+ * Answer: byte read from UART bit rate register (UBRR)
+ *
+**/
+
+
+/* data structure for each usb remote */
+struct irctl {
+
+	/* usb */
+	struct usb_device *usbdev;
+	struct urb *urb_in;
+	int devnum;
+
+	unsigned char *buf_in;
+	unsigned int len_in;
+        int in_space;
+	struct timeval last_time;
+
+#if defined(KERNEL_2_5)
+	dma_addr_t dma_in;
+#endif
+
+	/* lirc */
+	struct lirc_plugin *p;
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait_out;
+
+	struct semaphore lock;
+};
+
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+
+	if(!ir->p)
+        	return -EINVAL;
+        
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
+
+	lirc_unregister_plugin(p->minor);
+
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+
+	lirc_buffer_free(p->rbuf);
+	kfree(p->rbuf);
+	kfree(p);
+	kfree(ir);
+        ir->p = NULL;
+	return SUCCESS;
+}
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
+
+	MOD_INC_USE_COUNT;
+
+	if (!ir->usbdev)
+	{
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void set_use_dec(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
+		return;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
+
+	MOD_DEC_USE_COUNT;
+}
+
+
+/** 
+ * Called in user context.
+ * return 0 if data was added to the buffer and
+ * -ENODATA if none was available. This should add some number of bits
+ * evenly divisible by code_length to the buffer
+**/
+static int usb_remote_poll(void* data, struct lirc_buffer* buf)
+{
+	int ret;
+	struct irctl *ir = (struct irctl *)data;
+
+	if(!ir->usbdev)  /* Has the device been removed? */
+		return -ENODEV;
+
+	memset(ir->buf_in, 0, ir->len_in);
+  
+	if((ret = usb_control_msg(
+        	ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
+		GET_INFRACODE, USB_TYPE_VENDOR|USB_DIR_IN,
+		0/* offset */, /*unused*/0, 
+		ir->buf_in, ir->len_in, 
+		/*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) > 0)
+	{
+		int i = DEVICE_HEADERLEN;
+		lirc_t code,timediff;
+                struct timeval now;
+
+		if(ret <= 1)  /* ACK packet has 1 byte --> ignore */
+			return -ENODATA;
+
+		dprintk(DRIVER_NAME ": Got %d bytes. Header: %02x %02x %02x\n", 
+                	ret, ir->buf_in[0], ir->buf_in[1], ir->buf_in[2]);
+      
+		if(ir->buf_in[2] != 0) {
+			printk(DRIVER_NAME "[%d]: Device buffer overrun.\n", 
+                        	ir->devnum);
+			i = DEVICE_HEADERLEN + ir->buf_in[2];  /* start at earliest byte */
+			/* where are we now? space, gap or pulse? */
+		}
+      
+		do_gettimeofday(&now);
+		timediff = now.tv_sec - ir->last_time.tv_sec;
+		if(timediff+1 > PULSE_MASK/1000000)
+			timediff = PULSE_MASK;
+		else {
+			timediff *= 1000000;
+			timediff += now.tv_usec - ir->last_time.tv_usec;
+		}
+		ir->last_time.tv_sec = now.tv_sec;
+		ir->last_time.tv_usec = now.tv_usec;
+
+		/* create leading gap  */
+		code = timediff;
+  		lirc_buffer_write_n(buf, (unsigned char*)&code, 1);
+		ir->in_space = 1;   /* next comes a pulse */
+
+		/* MODE2: pulse/space (PULSE_BIT) in 1us units */
+
+		while(i < ret) {
+			/* 1 Igor-tick = 85.333333 us */
+			code = (unsigned int)ir->buf_in[i] * 85 
+				+ (unsigned int)ir->buf_in[i]/3;
+			if(ir->in_space)
+				code |= PULSE_BIT;
+			lirc_buffer_write_n(buf, (unsigned char*)&code, 1);  
+			/* 1 chunk = CODE_LENGTH bytes */
+			ir->in_space ^= 1;
+			++ i;
+		}
+
+		if((ret = usb_control_msg(
+                	ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
+			SET_INFRABUFFER_EMPTY, USB_TYPE_VENDOR|USB_DIR_IN,
+			/*unused*/0, /*unused*/0, 
+			/*dummy*/ir->buf_in, /*dummy*/ir->len_in, 
+                        /*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) < 0)
+		{
+			printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: error %d\n", 
+				ir->devnum, ret);
+		}
+		return SUCCESS;
+	}
+	else {
+		printk(DRIVER_NAME "[%d]: GET_INFRACODE: error %d\n", 
+                	ir->devnum, ret);
+	}
+
+	return -ENODATA;
+}
+
+
+
+#if defined(KERNEL_2_5)
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = NULL;
+	struct usb_host_interface *idesc = NULL;
+	struct usb_host_endpoint *ep_ctl2;
+#else
+static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	struct usb_interface *intf;
+	struct usb_interface_descriptor *idesc;
+	struct usb_endpoint_descriptor *ep_ctl2;
+#endif
+	struct irctl *ir = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int devnum, pipe, maxp, bytes_in_key;
+	int minor = 0;
+	char buf[63], name[128]="";
+	int mem_failure = 0;
+	int ret;
+
+	dprintk(DRIVER_NAME ": usb probe called.\n");
+
+#if defined(KERNEL_2_5)
+	dev = interface_to_usbdev(intf);
+
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
+	idesc = &intf->altsetting[intf->act_altsetting];  /* in 2.6.4 */
+#  else
+	idesc = intf->cur_altsetting;  /* in 2.6.6 */
+#  endif
+
+	if (idesc->desc.bNumEndpoints != 1)
+		return -ENODEV;
+	ep_ctl2 = idesc->endpoint;
+	if (((ep_ctl2->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
+		|| (ep_ctl2->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+		!= USB_ENDPOINT_XFER_CONTROL)
+		return -ENODEV;
+	pipe = usb_rcvctrlpipe(dev, ep_ctl2->desc.bEndpointAddress);
+#else
+	intf = &dev->actconfig->interface[ifnum];
+	idesc = &intf->altsetting[intf->act_altsetting];
+	if (idesc->bNumEndpoints != 1)
+		return NULL;
+	ep_ctl2 = idesc->endpoint;
+	if (((ep_ctl2->bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
+		|| (ep_ctl2->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+		!= USB_ENDPOINT_XFER_CONTROL)
+		return NULL;
+	pipe = usb_rcvctrlpipe(dev, ep_ctl2->bEndpointAddress);
+#endif
+	devnum = dev->devnum;
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	bytes_in_key = CODE_LENGTH;
+
+	dprintk(DRIVER_NAME "[%d]: bytes_in_key=%d maxp=%d\n",
+		devnum, bytes_in_key, maxp);
+
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+		mem_failure = 1;
+	} else {
+		memset(ir, 0, sizeof(struct irctl));
+
+		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, bytes_in_key, 
+                		DEVICE_BUFLEN+ADDITIONAL_LIRC_BYTES)) {
+			mem_failure = 4;
+#if defined(KERNEL_2_5)
+		} else if (!(ir->buf_in = usb_buffer_alloc(dev, 
+				DEVICE_BUFLEN+DEVICE_HEADERLEN, 
+                                GFP_ATOMIC, &ir->dma_in))) {
+			mem_failure = 5;
+#else
+		} else if (!(ir->buf_in = kmalloc(
+				DEVICE_BUFLEN+DEVICE_HEADERLEN, GFP_KERNEL))) {
+			mem_failure = 5;
+#endif
+		} else {
+
+			memset(plugin, 0, sizeof(struct lirc_plugin));
+
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->code_length = bytes_in_key*8; /* in bits */
+			plugin->features = LIRC_CAN_REC_MODE2;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+			plugin->sample_rate = SAMPLE_RATE;    /* per second */
+			plugin->add_to_buf = &usb_remote_poll;
+#ifdef LIRC_HAVE_SYSFS
+			plugin->dev = &dev->dev;
+#endif
+			plugin->owner = THIS_MODULE;
+
+			init_MUTEX(&ir->lock);
+			init_waitqueue_head(&ir->wait_out);
+
+			if ((minor = lirc_register_plugin(plugin)) < 0) {
+				mem_failure = 9;
+			}
+		}
+	}
+
+	/* free allocated memory in case of failure */
+	switch (mem_failure) {
+	case 9:
+#if defined(KERNEL_2_5)
+		usb_buffer_free(dev, DEVICE_BUFLEN+DEVICE_HEADERLEN, 
+                	ir->buf_in, ir->dma_in);
+#else
+		kfree(ir->buf_in);
+#endif
+	case 5:
+		lirc_buffer_free(rbuf);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(ir);
+	case 1:
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+			devnum, mem_failure);
+#if defined(KERNEL_2_5)
+		return -ENOMEM;
+#else
+		return NULL;
+#endif
+	}
+
+	plugin->minor = minor;
+	ir->p = plugin;
+	ir->devnum = devnum;
+	ir->usbdev = dev;
+	ir->len_in = DEVICE_BUFLEN+DEVICE_HEADERLEN;
+	ir->in_space = 1; /* First mode2 event is a space. */
+	do_gettimeofday(&ir->last_time);
+
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", devnum, name,
+	       dev->bus->busnum, devnum);
+
+	/* clear device buffer */
+	if ((ret = usb_control_msg(ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
+		SET_INFRABUFFER_EMPTY, USB_TYPE_VENDOR|USB_DIR_IN,
+		/*unused*/0, /*unused*/0, 
+		/*dummy*/ir->buf_in, /*dummy*/ir->len_in, 
+		/*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) < 0)
+	{
+		printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: error %d\n", 
+			devnum, ret);
+	}
+
+#if defined(KERNEL_2_5)
+	usb_set_intfdata(intf, ir);
+	return SUCCESS;
+#else
+	return ir;
+#endif
+}
+
+
+#if defined(KERNEL_2_5)
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+#else
+static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct irctl *ir = ptr;
+#endif
+
+	if (!ir || !ir->p)
+		return;
+
+	ir->usbdev = NULL;
+	wake_up_all(&ir->wait_out);
+
+	IRLOCK;
+#if defined(KERNEL_2_5)
+	usb_buffer_free(dev, ir->len_in, ir->buf_in, ir->dma_in);
+#else
+	kfree(ir->buf_in);
+#endif
+	IRUNLOCK;
+
+	unregister_from_lirc(ir);
+}
+
+static struct usb_device_id usb_remote_id_table [] = {
+	{ USB_DEVICE(0x03eb, 0x0002) },	/* Igor Plug USB (Atmel's Manufact. ID) */
+	{ }				/* Terminating entry */
+};
+
+static struct usb_driver usb_remote_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+	.id_table =	usb_remote_id_table
+};
+
+static int __init usb_remote_init(void)
+{
+	int i;
+
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled\n");
+
+	request_module("lirc_dev");
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void __exit usb_remote_exit(void)
+{
+	usb_deregister(&usb_remote_driver);
+}
+
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
+
+#if defined(KERNEL_2_5)
+#include <linux/vermagic.h>
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+#endif
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, usb_remote_id_table);
+
+EXPORT_NO_SYMBOLS;
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_imon.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_imon.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_imon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_imon.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1331 @@
+/*
+ *   lirc_imon.c:  LIRC plugin/VFD driver for Ahanix/Soundgraph IMON IR/VFD
+ *
+ *   $Id: lirc_imon.c,v 1.19 2007/04/29 14:23:04 lirc Exp $
+ *
+ *   Version 0.3 
+ *   		Supports newer iMON models that send decoded IR signals.
+ *   			This includes the iMON PAD model.
+ *   		Removed module option for vfd_proto_6p. This driver supports
+ *   			multiple iMON devices so it is meaningless to have
+ *   			a global option to set protocol variants.
+ *
+ *   Version 0.2 beta 2 [January 31, 2005]
+ *		USB disconnect/reconnect no longer causes problems for lircd
+ *   
+ *   Version 0.2 beta 1 [January 29, 2005]
+ *		Added support for original iMON receiver (ext USB)
+ *   
+ *   Version 0.2 alpha 2 [January 24, 2005]
+ *   		Added support for VFDs with 6-packet protocol
+ *
+ *   Version 0.2 alpha 1 [January 23, 2005]
+ *   		Added support for 2.6 kernels
+ *   		Reworked disconnect handling
+ *   		Incorporated Changwoo Ryu's algorithm
+ *
+ *   Version 0.1 alpha 1 [July 5, 2004]
+ *
+ *   Copyright (C) 2004  Venky Raju (dev@venky.ws)
+ *   
+ *   lirc_imon is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+#error "*** Sorry, this driver requires kernel version 2.4.22 or higher"
+#endif
+
+#include <linux/autoconf.h>
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+
+#define MOD_AUTHOR	"Venky Raju <dev@venky.ws>"
+#define MOD_DESC	"Driver for Soundgraph iMON MultiMedian IR/VFD"
+#define MOD_NAME	"lirc_imon"
+#define MOD_VERSION	"0.3"
+
+#define VFD_MINOR_BASE	144	/* Same as LCD */
+#define DEVFS_MODE	S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
+#define DEVFS_NAME	LIRC_DEVFS_PREFIX "lcd%d"
+
+#define BUF_CHUNK_SIZE	4
+#define BUF_SIZE	128
+
+#define BIT_DURATION	250 	/* each bit received is 250us */
+
+#define SUCCESS		0
+#define	TRUE		1
+#define FALSE		0
+
+
+/* ------------------------------------------------------------
+ *                     P R O T O T Y P E S
+ * ------------------------------------------------------------
+ */
+
+/* USB Callback prototypes */
+#ifdef KERNEL_2_5
+static int imon_probe (struct usb_interface *interface,
+			const struct usb_device_id *id);
+static void imon_disconnect (struct usb_interface *interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_rx_callback (struct urb *urb, struct pt_regs *regs);
+static void usb_tx_callback (struct urb *urb, struct pt_regs *regs);
+#else
+static void usb_rx_callback (struct urb *urb);
+static void usb_tx_callback (struct urb *urb);
+#endif
+#else
+static void * imon_probe (struct usb_device * dev, unsigned int intf,
+				const struct usb_device_id *id);
+static void imon_disconnect (struct usb_device *dev, void *data);
+static void usb_rx_callback (struct urb *urb);
+static void usb_tx_callback (struct urb *urb);
+#endif
+
+/* VFD file_operations function prototypes */
+static int vfd_open (struct inode *inode, struct file *file);
+static int vfd_close (struct inode *inode, struct file *file);
+static ssize_t vfd_write (struct file *file, const char *buf,
+				size_t n_bytes, loff_t *pos);
+
+/* LIRC plugin function prototypes */
+static int ir_open (void *data);
+static void ir_close (void *data);
+
+/* Driver init/exit prototypes */
+static int __init imon_init (void);
+static void __exit imon_exit (void);
+
+/* ------------------------------------------------------------
+ *                     G L O B A L S
+ * ------------------------------------------------------------
+ */
+
+struct imon_context {
+
+	struct usb_device *dev;
+	int vfd_supported;		/* not all controllers do         */
+	int vfd_isopen;			/* VFD port has been opened       */
+#if !defined (KERNEL_2_5)
+	int subminor;			/* index into minor_table         */
+	devfs_handle_t devfs;
+#endif
+	int ir_isopen;			/* IR port has been opened        */
+	int ir_isassociating;		/* IR port has been opened for association */
+	int dev_present;		/* USB device presence            */
+	struct semaphore sem;		/* to lock this object            */
+	wait_queue_head_t remove_ok;	/* For unexpected USB disconnects */
+
+	int vfd_proto_6p;		/* VFD requires 6th packet        */
+	int ir_onboard_decode;		/* IR signals decoded onboard     */
+
+	struct lirc_plugin *plugin;
+	struct usb_endpoint_descriptor *rx_endpoint;
+	struct usb_endpoint_descriptor *tx_endpoint;
+	struct urb *rx_urb;
+	struct urb *tx_urb;
+	unsigned char usb_rx_buf [8];
+	unsigned char usb_tx_buf [8];
+
+	struct rx_data {
+		int count;		/* length of 0 or 1 sequence      */
+		int prev_bit;		/* logic level of sequence        */
+		int initial_space;	/* initial space flag             */
+
+	} rx;
+
+	struct tx_t {
+		unsigned char data_buf [35]; /* user data buffer          */
+		struct completion finished;  /* wait for write to finish  */
+		atomic_t busy;		     /* write in progress         */
+		int status;		     /* status of tx completion   */
+	} tx;
+};
+
+#define LOCK_CONTEXT	down (&context ->sem)
+#define UNLOCK_CONTEXT	up (&context ->sem)
+
+/* VFD file operations */
+static struct file_operations vfd_fops = {
+
+	.owner		= THIS_MODULE,
+	.open		= &vfd_open,
+	.write		= &vfd_write,
+	.release	= &vfd_close
+};
+
+/* USB Device ID for IMON USB Control Board */
+static struct usb_device_id imon_usb_id_table [] = {
+	{ USB_DEVICE(0x0aa8, 0xffda) },		/* IR & VFD    */
+	{ USB_DEVICE(0x0aa8, 0x8001) },		/* IR only     */
+	{ USB_DEVICE(0x15c2, 0xffda) },		/* IR & VFD    */
+	{ USB_DEVICE(0x15c2, 0xffdc) },		/* IR & VFD    */
+	{ USB_DEVICE(0x04e8, 0xff30) },		/* ext IR only */
+	{}
+};
+
+/* Some iMON VFD models requires a 6th packet */
+static unsigned short vfd_proto_6p_vendor_list [] = {
+			/* terminate this list with a 0 */
+			0x15c2,
+			0 };
+static unsigned char vfd_packet6 [] = {
+		0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };
+
+/* Newer iMON models decode the signal onboard */
+static unsigned short ir_onboard_decode_product_list [] = {
+			/* terminate this list with a 0 */
+			0xffdc,
+			0 };
+
+/* USB Device data */
+static struct usb_driver imon_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name 		= MOD_NAME,
+	.probe 		= imon_probe,
+	.disconnect 	= imon_disconnect,
+	.id_table 	= imon_usb_id_table,
+#if !defined(KERNEL_2_5)
+	.fops		= &vfd_fops,
+	.minor		= VFD_MINOR_BASE,
+#endif
+};
+
+#ifdef KERNEL_2_5
+static struct usb_class_driver imon_class = {
+	.name 		= DEVFS_NAME,
+	.fops		= &vfd_fops,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
+	.mode		= DEVFS_MODE,
+#endif
+	.minor_base	= VFD_MINOR_BASE,
+};
+#endif
+
+/* to prevent races between open() and disconnect() */
+static DECLARE_MUTEX (disconnect_sem);
+
+static int debug = 0;
+
+#if !defined(KERNEL_2_5)
+
+#define MAX_DEVICES	4	/* In case there's more than one iMON device */
+static struct imon_context * minor_table [MAX_DEVICES];
+
+/*
+static DECLARE_MUTEX (minor_table_sem);
+#define LOCK_MINOR_TABLE	down (&minor_table_sem)
+#define UNLOCK_MINOR_TABLE	up (&minor_table_sem)
+*/
+
+/* the global usb devfs handle */
+extern devfs_handle_t usb_devfs_handle;
+
+#endif
+
+/* ------------------------------------------------------------
+ *                     M O D U L E   C O D E
+ * ------------------------------------------------------------
+ */
+
+MODULE_AUTHOR (MOD_AUTHOR);
+MODULE_DESCRIPTION (MOD_DESC);
+MODULE_LICENSE ("GPL");
+MODULE_DEVICE_TABLE (usb, imon_usb_id_table);
+module_param (debug, int, 0);
+MODULE_PARM_DESC (debug, "Debug messages: 0=no, 1=yes (default: no)");
+
+static inline void delete_context (struct imon_context *context) {
+
+	if (context ->vfd_supported)
+		usb_free_urb (context ->tx_urb);
+	usb_free_urb (context ->rx_urb);
+	lirc_buffer_free (context ->plugin ->rbuf);
+	kfree (context ->plugin ->rbuf);
+	kfree (context ->plugin);
+	kfree (context);
+
+	if (debug) info ("%s: context deleted", __FUNCTION__);
+}
+
+static inline void deregister_from_lirc (struct imon_context *context) {
+
+	int retval;
+	int minor = context ->plugin ->minor;
+
+	if ((retval = lirc_unregister_plugin (minor))) {
+
+		err ("%s: unable to deregister from lirc (%d)", 
+			__FUNCTION__, retval);
+	}
+	else
+		info ("Deregistered iMON plugin (minor:%d)", minor);
+
+}
+
+/**
+ * Called when the VFD device (e.g. /dev/usb/lcd)
+ * is opened by the application.
+ */
+static int vfd_open (struct inode *inode, struct file *file)
+{
+#ifdef KERNEL_2_5
+	struct usb_interface *interface;
+#endif
+	struct imon_context *context = NULL;
+	int subminor;
+	int retval = SUCCESS;
+
+	/* prevent races with disconnect */
+	down (&disconnect_sem);
+	
+#ifdef KERNEL_2_5
+	subminor = iminor (inode);
+	interface = usb_find_interface (&imon_driver, subminor);
+	if (!interface) {
+		err ("%s: could not find interface for minor %d", __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+	context = usb_get_intfdata (interface);
+#else
+	subminor = MINOR (inode ->i_rdev) - VFD_MINOR_BASE;
+	if (subminor < 0 || subminor >= MAX_DEVICES) {
+		err ("%s: no record of minor %d", __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+	context = minor_table [subminor];
+#endif
+
+	if (!context) {
+		err ("%s: no context found for minor %d", 
+					__FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->vfd_supported) {
+		err ("%s: VFD not supported by device", __FUNCTION__);
+		retval = -ENODEV;
+	}
+	else if (context ->vfd_isopen) {
+		
+		err ("%s: VFD port is already open", __FUNCTION__);
+		retval = -EBUSY;
+	}
+	else {
+		MOD_INC_USE_COUNT;
+		context ->vfd_isopen = TRUE;
+		file ->private_data = context;
+		info ("VFD port opened");
+	}
+
+	UNLOCK_CONTEXT;
+
+exit:
+	up (&disconnect_sem);
+	return retval;
+}
+
+/**
+ * Called when the VFD device (e.g. /dev/usb/lcd)
+ * is closed by the application.
+ */
+static int vfd_close (struct inode *inode, struct file *file)
+{
+	struct imon_context *context = NULL;
+	int retval = SUCCESS;
+
+	context = (struct imon_context *) file ->private_data;
+
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->vfd_supported) {
+		err ("%s: VFD not supported by device", __FUNCTION__);
+		retval = -ENODEV;
+	}
+	else if (!context ->vfd_isopen) {
+		err ("%s: VFD is not open", __FUNCTION__);
+		retval = -EIO;
+	}
+	else {
+		context ->vfd_isopen = FALSE;
+		MOD_DEC_USE_COUNT;
+		info ("VFD port closed");
+		if (!context ->dev_present && !context ->ir_isopen) {
+
+			/* Device disconnected before close and IR port is not open.  */
+			/* If IR port is open, context will be deleted by ir_close.   */
+			UNLOCK_CONTEXT;
+			delete_context (context);
+			return retval;
+		}
+	}
+
+	UNLOCK_CONTEXT;
+	return retval;
+}
+
+/**
+ * Sends a packet to the VFD.
+ */
+static inline int send_packet (struct imon_context *context)
+{
+	unsigned int pipe;
+	int interval = 0;
+	int retval = SUCCESS;
+
+	pipe = usb_sndintpipe (context ->dev,
+			context-> tx_endpoint ->bEndpointAddress);
+#ifdef KERNEL_2_5
+	interval = context ->tx_endpoint ->bInterval;
+#endif	/* Use 0 for 2.4 kernels */
+
+	usb_fill_int_urb (context ->tx_urb, context ->dev, pipe,
+		context ->usb_tx_buf, sizeof (context ->usb_tx_buf),
+		usb_tx_callback, context, interval);
+
+	context ->tx_urb ->actual_length = 0;
+
+	init_completion (&context ->tx.finished);
+	atomic_set (&(context ->tx.busy), 1);
+
+#ifdef KERNEL_2_5
+	retval =  usb_submit_urb (context ->tx_urb, GFP_KERNEL);
+#else
+	retval =  usb_submit_urb (context ->tx_urb);
+#endif
+	if (retval != SUCCESS) {
+		atomic_set (&(context ->tx.busy), 0);
+		err ("%s: error submitting urb (%d)", __FUNCTION__, retval);
+	}
+	else {
+		/* Wait for tranmission to complete (or abort) */
+		UNLOCK_CONTEXT;
+		wait_for_completion (&context ->tx.finished);
+		LOCK_CONTEXT;
+
+		retval = context ->tx.status;
+		if (retval != SUCCESS)
+			err ("%s: packet tx failed (%d)", __FUNCTION__, retval);
+	}
+
+	return retval;
+}
+
+/**
+ * Sends an associate packet to the iMON 2.4G.
+ *
+ * This might not be such a good idea, since it has an id
+ * collition with some versions of the "IR & VFD" combo.
+ * The only way to determine if it is a RF version is to look
+ * at the product description string. (Which we currently do
+ * not fetch).
+ */
+static inline int send_associate_24g (struct imon_context *context)
+{
+	int retval;
+	const unsigned char packet[8] = { 0x01, 0x00, 0x00, 0x00,
+					  0x00, 0x00, 0x00, 0x20 };
+
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->dev_present) {
+		err ("%s: no iMON device present", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	memcpy (context ->usb_tx_buf, packet, sizeof(packet));
+	retval = send_packet (context);
+
+exit:
+	UNLOCK_CONTEXT;
+
+	return retval;
+}
+
+#ifdef KERNEL_2_5
+/**
+ * This is the sysfs functions to handle the association og the iMON 2.4G LT.
+ *
+ *
+ */
+
+static ssize_t show_associate_remote (struct device *d, struct device_attribute *attr,
+			       char *buf)
+{
+	struct imon_context *context = dev_get_drvdata (d);
+
+	if (!context)
+		return -ENODEV;
+
+	if (context ->ir_isassociating) {
+		strcpy(buf, "The device it associating press some button on the remote.\n");
+	}
+	else if (context ->ir_isopen) {
+		strcpy(buf, "Device is open and ready to associate.\n"
+		            "Echo something into this file to start the process.\n");
+	}
+	else {
+		strcpy(buf, "Device is closed, you need to open it to associate the remote (you can use irw).\n");
+	}
+	return strlen (buf);
+}
+
+static ssize_t store_associate_remote (struct device *d, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct imon_context *context;
+	
+	context = dev_get_drvdata (d);
+
+	if (!context)
+		return -ENODEV;
+
+	if (! context ->ir_isopen)
+		return -EINVAL;
+
+	if (context ->ir_isopen) {
+		context ->ir_isassociating = TRUE;
+		send_associate_24g (context);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(associate_remote, S_IWUSR | S_IRUGO, show_associate_remote, store_associate_remote);
+
+static struct attribute *imon_sysfs_entries[] = {
+	&dev_attr_associate_remote.attr,
+	NULL
+};
+
+static struct attribute_group imon_attribute_group = {
+	.attrs = imon_sysfs_entries
+};
+
+#endif
+
+
+
+/**
+ * Writes data to the VFD.  The IMON VFD is 2x16 characters
+ * and requires data in 5 consecutive USB interrupt packets,
+ * each packet but the last carrying 7 bytes.
+ *
+ * I don't know if the VFD board supports features such as
+ * scrolling, clearing rows, blanking, etc. so at 
+ * the caller must provide a full screen of data.  If fewer
+ * than 32 bytes are provided spaces will be appended to
+ * generate a full screen.
+ */
+static ssize_t vfd_write (struct file *file, const char *buf,
+				size_t n_bytes, loff_t *pos)
+{
+
+	int i;
+	int offset;
+	int seq;
+	int retval = SUCCESS;
+	struct imon_context *context;
+
+	context = (struct imon_context *) file ->private_data;
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->dev_present) {
+		err ("%s: no iMON device present", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	if (n_bytes <= 0 || n_bytes > 32) {
+		err ("%s: invalid payload size", __FUNCTION__);
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	copy_from_user (context ->tx.data_buf, buf, n_bytes);
+
+	/* Pad with spaces */
+	for (i=n_bytes; i < 32; ++i)
+		context ->tx.data_buf [i] = ' ';
+	
+	for (i=32; i < 35; ++i)
+		context ->tx.data_buf [i] = 0xFF;
+
+	offset = seq = 0;
+
+	do {
+		memcpy (context ->usb_tx_buf, context ->tx.data_buf + offset, 7);
+		context ->usb_tx_buf [7] = (unsigned char) seq;
+
+		if ((retval = send_packet (context)) != SUCCESS) {
+
+			err ("%s: send packet failed for packet #%d", 
+					__FUNCTION__, seq/2);
+			goto exit;
+		}
+		else {
+			seq += 2;
+			offset += 7;
+		}
+
+	} while (offset < 35);
+
+	if (context ->vfd_proto_6p) {
+
+		/* Send packet #6 */
+		memcpy (context ->usb_tx_buf, vfd_packet6, 7);
+		context ->usb_tx_buf [7] = (unsigned char) seq;
+		if ((retval = send_packet (context)) != SUCCESS)
+			err ("%s: send packet failed for packet #%d",
+					__FUNCTION__, seq/2);
+	}
+
+exit:
+	UNLOCK_CONTEXT;
+
+	return (retval == SUCCESS) ? n_bytes : retval;
+}
+
+/**
+ * Callback function for USB core API: transmit data
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_tx_callback (struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_tx_callback (struct urb *urb)
+#endif
+{
+	struct imon_context *context;
+
+	if (!urb || !(context = (struct imon_context *) urb->context))
+		return;
+
+	context ->tx.status = urb ->status;
+
+	/* notify waiters that write has finished */
+	atomic_set (&context ->tx.busy, 0);
+	complete (&context ->tx.finished);
+
+	return;
+}
+
+/**
+ * Called by lirc_dev when the application opens /dev/lirc
+ */
+static int ir_open (void *data)
+{
+	int retval = SUCCESS;
+	struct imon_context *context;
+
+	/* prevent races with disconnect */
+	down (&disconnect_sem);
+
+	context = (struct imon_context *) data;
+
+	LOCK_CONTEXT;
+
+	if (context ->ir_isopen) {
+		err ("%s: IR port is already open", __FUNCTION__);
+		retval = -EBUSY;
+		goto exit;
+	}
+
+	/* initial IR protocol decode variables */
+	context ->rx.count = 0;
+	context ->rx.initial_space = 1;
+	context ->rx.prev_bit = 0;
+
+	usb_fill_int_urb (context ->rx_urb, context ->dev,
+		usb_rcvintpipe (context ->dev,
+				context ->rx_endpoint-> bEndpointAddress),
+		context ->usb_rx_buf, sizeof (context ->usb_rx_buf),
+		usb_rx_callback, context, context ->rx_endpoint ->bInterval);
+
+#ifdef KERNEL_2_5
+	retval = usb_submit_urb (context ->rx_urb, GFP_KERNEL);
+#else
+	retval = usb_submit_urb (context ->rx_urb);
+#endif
+
+	if (retval) {
+		err ("%s: usb_submit_urb failed for ir_open (%d)", __FUNCTION__, retval);
+	}
+	else {
+		MOD_INC_USE_COUNT;
+		context ->ir_isopen = TRUE;
+		info ("IR port opened");
+	}
+
+exit:
+	UNLOCK_CONTEXT;
+
+	up (&disconnect_sem);
+	return SUCCESS;
+}
+
+/**
+ * Called by lirc_dev when the application closes /dev/lirc
+ */
+static void ir_close (void *data)
+{
+	struct imon_context *context;
+
+	context = (struct imon_context *)data;
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return;
+	}
+
+	LOCK_CONTEXT;
+
+	usb_kill_urb(context->rx_urb);
+	context ->ir_isopen = FALSE;
+	context ->ir_isassociating = FALSE;
+	MOD_DEC_USE_COUNT;
+	info ("IR port closed");
+
+	if (!context ->dev_present) {
+
+		/* 
+		 * Device disconnected while IR port was 
+		 * still open. Plugin was not deregistered 
+		 * at disconnect time, so do it now.
+		 */
+		deregister_from_lirc (context);
+
+		if (!context ->vfd_isopen) {
+
+			UNLOCK_CONTEXT;
+			delete_context (context);
+			return;
+		}
+		/* If VFD port is open, context will be deleted by vfd_close */
+	}
+
+	UNLOCK_CONTEXT;
+	return;
+}
+
+/**
+ * Convert bit count to time duration (in us) and submit
+ * the value to lirc_dev.
+ */
+static inline void submit_data (struct imon_context *context)
+{
+	unsigned char buf [4];
+	int value = context ->rx.count;
+	int i;
+
+	if (debug) info ("submitting data to LIRC");
+	
+	value *= BIT_DURATION;
+	value &= PULSE_MASK;
+	if (context ->rx.prev_bit)
+		value |= PULSE_BIT;
+
+	for (i=0; i < 4; ++i)
+		buf [i] = value >> (i*8);
+
+	lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
+	wake_up (&context ->plugin ->rbuf ->wait_poll);
+	return;
+}
+
+/**
+ * Process the incoming packet
+ */
+static inline void incoming_packet (struct imon_context *context, struct urb *urb)
+{
+	int len = urb ->actual_length;
+	unsigned char *buf = urb ->transfer_buffer;
+	int octet, bit;
+	unsigned char mask;
+	int chunk_num;
+
+
+	if (len != 8) {
+		warn ("%s: invalid incoming packet size (%d)", __FUNCTION__, len);
+		return;
+	}
+
+	/* iMON 2.4G associate frame */
+	if (buf [0] == 0x00 &&
+	    /* REFID */
+	    buf [2] == 0xFF &&
+	    buf [3] == 0xFF &&
+	    buf [4] == 0xFF &&
+	    buf [5] == 0xFF &&                       /* iMON 2.4G */
+	    ((buf [6] == 0x4E && buf [7] == 0xDF) || /* LT */
+	     (buf [6] == 0x5E && buf [7] == 0xDF) )) { /* DT */
+		warn ("%s: remote associated refid=%02X", __FUNCTION__, buf [1]);
+		context ->ir_isassociating = FALSE;
+	}
+
+	chunk_num = buf [7];
+	
+	if (chunk_num == 0xFF)
+		return;		/* filler frame, no data here */
+
+	if (buf [0] == 0xFF &&
+	    buf [1] == 0xFF &&
+	    buf [2] == 0xFF &&
+	    buf [3] == 0xFF &&
+	    buf [4] == 0xFF &&
+	    buf [5] == 0xFF &&                     /* iMON 2.4G */
+	    ((buf [6] == 0x4E && buf [7] == 0xAF) || /* LT */
+	     (buf [6] == 0x5E && buf [7] == 0xAF) )) /* DT */
+	        return;		/* filler frame, no data here */
+
+#ifdef DEBUG	
+	{
+		int i;
+		for (i=0; i < 8; ++i)
+			printk ("%02x ", buf [i]);
+		printk ("\n");
+	}
+#endif
+
+	if (context ->ir_onboard_decode) {
+
+		/* The signals have been decoded onboard the iMON controller */
+
+		lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
+		wake_up (&context ->plugin ->rbuf ->wait_poll);
+		return;
+	}
+	
+	/*
+	 * Translate received data to pulse and space lengths.
+	 * Received data is active low, i.e. pulses are 0 and
+	 * spaces are 1.
+	 *
+	 * My original algorithm was essentially similar to
+	 * Changwoo Ryu's with the exception that he switched
+	 * the incoming bits to active high and also fed an
+	 * initial space to LIRC at the start of a new sequence
+	 * if the previous bit was a pulse.
+	 *
+	 * I've decided to adopt his algorithm.
+	 */
+
+	if (chunk_num == 1 && context ->rx.initial_space) {
+
+		/* LIRC requires a leading space */
+		context ->rx.prev_bit = 0;
+		context ->rx.count = 4;
+		submit_data (context);
+		context ->rx.count = 0;
+	}
+
+	for (octet=0; octet < 5; ++octet) {
+
+		mask = 0x80;
+		for (bit=0; bit < 8; ++bit) {
+
+			int curr_bit = !(buf [octet] & mask);
+			if (curr_bit != context ->rx.prev_bit) {
+
+				if (context ->rx.count) {
+
+					submit_data (context);
+					context ->rx.count = 0;
+				}
+				context ->rx.prev_bit = curr_bit;
+			}
+			++context ->rx.count; 
+			mask >>= 1;
+		}
+	}
+
+	if (chunk_num == 10) {
+
+		if (context ->rx.count) {
+			submit_data (context);
+			context ->rx.count = 0;
+		}
+		context ->rx.initial_space = context ->rx.prev_bit;
+	}
+}
+
+/**
+ * Callback function for USB core API: receive data
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_rx_callback (struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_rx_callback (struct urb *urb)
+#endif
+{
+	struct imon_context *context;
+
+	if (!urb || !(context = (struct imon_context *) urb->context))
+		return;
+
+	switch (urb ->status) {
+
+		case -ENOENT: 		/* usbcore unlink successful! */ 
+			return;
+
+		case SUCCESS:
+			if (context ->ir_isopen)
+				incoming_packet (context, urb);
+		       	break;
+
+		default	:
+			warn ("%s: status (%d): ignored",
+				 __FUNCTION__, urb ->status);
+			break;
+	}
+
+#ifdef KERNEL_2_5
+	usb_submit_urb (context ->rx_urb, GFP_ATOMIC);
+#endif
+	return;
+}
+
+
+
+/**
+ * Callback function for USB core API: Probe
+ */
+#ifdef KERNEL_2_5
+static int imon_probe (struct usb_interface *interface,
+			const struct usb_device_id *id)
+#else
+static void * imon_probe (struct usb_device * dev, unsigned int intf,
+			const struct usb_device_id *id)
+#endif
+{
+#ifdef KERNEL_2_5
+	struct usb_device *dev = NULL;
+	struct usb_host_interface *iface_desc = NULL;
+#else
+	struct usb_interface *interface = NULL;
+	struct usb_interface_descriptor *iface_desc = NULL;
+	char name [10];
+	int subminor = 0;
+#endif
+	struct usb_endpoint_descriptor *rx_endpoint = NULL;
+	struct usb_endpoint_descriptor *tx_endpoint = NULL;
+	struct urb *rx_urb = NULL;
+	struct urb *tx_urb = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int lirc_minor = 0;
+	int num_endpoints;
+	int retval = SUCCESS;
+	int vfd_ep_found;
+	int ir_ep_found;
+	int alloc_status;
+	int vfd_proto_6p = FALSE;
+	int ir_onboard_decode = FALSE;
+	struct imon_context *context = NULL;
+	int i;
+
+	info ("%s: found IMON device", __FUNCTION__);
+
+#if !defined(KERNEL_2_5)
+	for (subminor = 0; subminor < MAX_DEVICES; ++subminor) {
+		if (minor_table [subminor] == NULL)
+			break;
+	}
+	if (subminor == MAX_DEVICES) {
+	
+		err ("%s: allowed number of devices already present", __FUNCTION__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+#endif
+
+#ifdef KERNEL_2_5
+	dev = usb_get_dev (interface_to_usbdev (interface));
+	iface_desc = interface ->cur_altsetting;
+	num_endpoints = iface_desc ->desc.bNumEndpoints;
+#else
+	interface = &dev ->actconfig ->interface [intf];
+	iface_desc = &interface ->altsetting [interface ->act_altsetting];
+	num_endpoints = iface_desc ->bNumEndpoints;
+#endif
+
+	/*
+	 * Scan the endpoint list and set:
+	 * 	first input endpoint = IR endpoint
+	 * 	first output endpoint = VFD endpoint
+	 */
+
+	ir_ep_found = vfd_ep_found = FALSE;
+
+	for (i=0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
+
+		struct usb_endpoint_descriptor *ep;
+		int ep_dir;
+		int ep_type;
+#ifdef KERNEL_2_5
+		ep = &iface_desc ->endpoint [i].desc;
+#else
+		ep = &iface_desc ->endpoint [i];
+#endif
+		ep_dir = ep ->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
+		ep_type = ep ->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+		if (!ir_ep_found && 
+			ep_dir == USB_DIR_IN && 
+			ep_type == USB_ENDPOINT_XFER_INT) {
+
+			rx_endpoint = ep;
+			ir_ep_found = TRUE;
+			if (debug) 
+				info ("%s: found IR endpoint", __FUNCTION__);
+
+		}
+		else if (!vfd_ep_found &&
+			ep_dir == USB_DIR_OUT && 
+			ep_type == USB_ENDPOINT_XFER_INT) {
+
+			tx_endpoint = ep;
+			vfd_ep_found = TRUE;
+			if (debug) 
+				info ("%s: found VFD endpoint", __FUNCTION__);
+		}
+		else
+			;
+
+	}
+
+	/* Input endpoint is mandatory */
+	if (!ir_ep_found) {
+
+		err ("%s: no valid input (IR) endpoint found.", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+	else {
+
+		/* Determine if the IR signals are decoded onboard */
+
+		unsigned short product_id;
+		unsigned short *id_list_item;
+
+		product_id = cpu_to_le16(dev ->descriptor.idProduct);
+		id_list_item = ir_onboard_decode_product_list;
+		while (*id_list_item) {
+			if (*id_list_item++ == product_id) {
+				ir_onboard_decode = TRUE;
+				break;
+			}
+		}
+
+		if (debug) info ("ir_onboard_decode: %d", ir_onboard_decode);
+	}
+
+	/* Determine if VFD requires 6 packets */
+	if (vfd_ep_found) {
+
+		unsigned short vendor_id;
+		unsigned short *id_list_item;
+
+		vendor_id = cpu_to_le16(dev ->descriptor.idVendor);
+		id_list_item = vfd_proto_6p_vendor_list;
+		while (*id_list_item) {
+			if (*id_list_item++ == vendor_id) {
+				vfd_proto_6p = TRUE;
+				break;
+			}
+		}
+
+		if (debug) info ("vfd_proto_6p: %d", vfd_proto_6p);
+	}
+
+
+	/* Allocate memory */
+
+	alloc_status = SUCCESS;
+
+	if (!(context = kmalloc (sizeof(struct imon_context), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for context", __FUNCTION__);
+		alloc_status = 1;
+	}
+	else if (!(plugin = kmalloc (sizeof(struct lirc_plugin), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
+		alloc_status = 2;
+	}
+	else if (!(rbuf = kmalloc (sizeof(struct lirc_buffer), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
+		alloc_status = 3;
+	}
+	else if (lirc_buffer_init (rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
+		err ("%s: lirc_buffer_init failed", __FUNCTION__);
+		alloc_status = 4;
+	}
+#ifdef KERNEL_2_5
+	else if (!(rx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+#else
+	else if (!(rx_urb = usb_alloc_urb (0))) {
+#endif
+		err ("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
+		alloc_status = 5;
+	}
+#ifdef KERNEL_2_5
+	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+#else
+	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0))) {
+#endif
+		err ("%s: usb_alloc_urb failed for VFD urb", __FUNCTION__);
+		alloc_status = 6;
+	}
+	else {
+
+		/* clear all members of imon_context and lirc_plugin */
+		memset (context, 0, sizeof (struct imon_context));
+		init_MUTEX (&context ->sem);
+		context ->vfd_proto_6p = vfd_proto_6p;
+		context ->ir_onboard_decode = ir_onboard_decode;
+
+		memset (plugin, 0, sizeof (struct lirc_plugin));
+
+		strcpy (plugin ->name, MOD_NAME);
+		plugin ->minor = -1;
+		plugin ->code_length = (ir_onboard_decode) ?
+			32 : sizeof (lirc_t) * 8;
+		plugin ->sample_rate = 0;
+		plugin ->features = (ir_onboard_decode) ?
+			LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_MODE2;
+		plugin ->data = context;
+		plugin ->rbuf = rbuf;
+		plugin ->set_use_inc = ir_open;
+		plugin ->set_use_dec = ir_close;
+#ifdef LIRC_HAVE_SYSFS
+		plugin->dev = &dev->dev;
+#endif
+		plugin->owner = THIS_MODULE;
+
+		LOCK_CONTEXT;
+
+		if ((lirc_minor = lirc_register_plugin (plugin)) < 0) {
+			err ("%s: lirc_register_plugin failed", __FUNCTION__);
+			alloc_status = 7;
+			UNLOCK_CONTEXT;
+		}
+		else
+			info ("%s: Registered iMON plugin (minor:%d)", 
+				__FUNCTION__, lirc_minor);
+	}
+
+	switch (alloc_status) {
+
+		case 7:		if (vfd_ep_found)
+					usb_free_urb (tx_urb);
+		case 6:		usb_free_urb (rx_urb);
+		case 5:		lirc_buffer_free (rbuf);
+		case 4:		kfree (rbuf);
+		case 3:		kfree (plugin);
+		case 2:		kfree (context);
+				context = NULL;
+		case 1:		retval = -ENOMEM;
+				goto exit;
+	}
+
+	// Needed while unregistering!
+	plugin ->minor = lirc_minor;
+
+	context ->dev = dev;
+	context ->dev_present = TRUE;
+	context ->rx_endpoint = rx_endpoint;
+	context ->rx_urb = rx_urb;
+	if (vfd_ep_found) {
+		
+		context ->vfd_supported = TRUE;
+		context ->tx_endpoint = tx_endpoint;
+		context ->tx_urb = tx_urb;
+	}
+	context ->plugin = plugin;
+
+#ifdef KERNEL_2_5
+	usb_set_intfdata (interface, context);
+
+	if (cpu_to_le16(dev ->descriptor.idProduct) == 0xffdc) {
+		int err;
+
+		err = sysfs_create_group(&interface ->dev.kobj, &imon_attribute_group);
+		if (err)
+			err ("%s: Could not create sysfs entries (%d)", __FUNCTION__, err);
+	}
+#else
+	minor_table [subminor] = context;
+	context ->subminor = subminor;
+#endif
+
+	if (vfd_ep_found) {
+
+		if (debug) info ("Registering VFD with devfs");
+#ifdef KERNEL_2_5
+		if (usb_register_dev (interface, &imon_class)) {
+
+			// Not a fatal error, so ignore
+			info ("%s: could not get a minor number for VFD", 
+				__FUNCTION__);
+		}
+#else
+		sprintf (name, DEVFS_NAME, subminor);
+		if (!(context ->devfs = devfs_register (usb_devfs_handle, name, 
+					DEVFS_FL_DEFAULT,
+					USB_MAJOR, VFD_MINOR_BASE + subminor,
+					DEVFS_MODE, &vfd_fops, NULL))) {
+
+			// not a fatal error so ignore
+			info ("%s: devfs register failed for VFD",
+					__FUNCTION__);
+		}
+#endif
+	}
+
+	info ("%s: iMON device on usb<%d:%d> initialized",
+			__FUNCTION__, dev ->bus ->busnum, dev ->devnum);
+
+	UNLOCK_CONTEXT;
+exit:
+#ifdef KERNEL_2_5
+	return retval;
+#else
+	return (retval == SUCCESS) ? context : NULL;
+#endif
+}
+
+/**
+ * Callback function for USB core API: disonnect
+ */
+#ifdef KERNEL_2_5
+static void imon_disconnect (struct usb_interface *interface)
+#else
+static void imon_disconnect (struct usb_device *dev, void *data)
+#endif
+{
+	struct imon_context *context;
+
+	/* prevent races with ir_open()/vfd_open() */
+	down (&disconnect_sem);
+
+#ifdef KERNEL_2_5
+	context = usb_get_intfdata (interface);
+#else
+	context = (struct imon_context *)data;
+#endif
+	LOCK_CONTEXT;
+
+	info ("%s: iMON device disconnected", __FUNCTION__);
+
+#ifdef KERNEL_2_5
+	/* sysfs_remove_group is safe to call even if sysfs_create_group hasn't been called */
+	sysfs_remove_group(&interface->dev.kobj,
+			   &imon_attribute_group);
+	usb_set_intfdata (interface, NULL);
+#else
+	minor_table [context ->subminor] = NULL;
+#endif
+	context ->dev_present = FALSE;
+
+	/* Stop reception */
+	usb_kill_urb(context->rx_urb);
+
+	/* Abort ongoing write */
+	if (atomic_read (&context ->tx.busy)) {
+
+		usb_kill_urb(context->tx_urb);
+		wait_for_completion (&context ->tx.finished);
+	}
+
+	/* De-register from lirc_dev if IR port is not open */
+	if (!context ->ir_isopen)
+		deregister_from_lirc (context);
+
+	if (context ->vfd_supported) {
+#ifdef KERNEL_2_5
+		usb_deregister_dev (interface, &imon_class);
+#else
+		if (context ->devfs)
+			devfs_unregister (context ->devfs);
+#endif
+	}
+
+	UNLOCK_CONTEXT;
+
+	if (!context ->ir_isopen && !context ->vfd_isopen)
+		delete_context (context);
+	
+	up (&disconnect_sem);
+}
+
+static int __init imon_init (void)
+{
+	int rc;
+
+	info (MOD_DESC ", v" MOD_VERSION);
+	info (MOD_AUTHOR);
+
+	if ((rc = usb_register (&imon_driver)) < 0) {
+		err ("%s: usb register failed (%d)", __FUNCTION__, rc);
+		return -ENODEV;
+	}
+	return SUCCESS;
+}
+
+static void __exit imon_exit (void)
+{
+	usb_deregister (&imon_driver);
+	info ("module removed. Goodbye!");
+}
+
+
+module_init (imon_init);
+module_exit (imon_exit);
+
+#if !defined(KERNEL_2_5)
+EXPORT_NO_SYMBOLS;
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_it87.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_it87.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_it87.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_it87.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1076 @@
+/*
+ * LIRC driver for ITE IT8712/IT8705 CIR port
+ *
+ * Copyright (C) 2001 Hans-Gnter Ltke Uphues <hg_lu@web.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ * ITE IT8705 and IT8712(not tested) CIR-port support for lirc based
+ * via cut and paste from lirc_sir.c (C) 2000 Milan Pikula
+ *
+ * Attention: Sendmode only tested with debugging logs 
+ *
+ * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
+ *   reimplemented read function
+ * 2005/06/05 Andrew Calkin implemented support for Asus Digimatrix,
+ *   based on work of the following member of the Outertrack Digimatrix 
+ *   Forum: Art103 <r_tay@hotmail.com>
+ */
+
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+ 
+#include <linux/autoconf.h>
+
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+
+#include <linux/timer.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+#include "kcompat.h"
+
+#include "lirc_it87.h"
+
+#ifdef LIRC_IT87_DIGIMATRIX
+static int digimatrix = 1;
+static int it87_freq = 36; /* kHz */
+static int irq = 9;
+#else
+static int digimatrix = 0;
+static int it87_freq = 38; /* kHz */
+static int irq = IT87_CIR_DEFAULT_IRQ;
+#endif
+
+static unsigned long it87_bits_in_byte_out = 0;
+static unsigned long it87_send_counter = 0;
+static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
+
+#define RBUF_LEN 1024
+#define WBUF_LEN 1024
+
+#define LIRC_DRIVER_NAME "lirc_it87"
+
+/* timeout for sequences in jiffies (=5/100s) */
+/* must be longer than TIME_CONST */
+#define IT87_TIMEOUT	(HZ*5/100)
+
+/* insmod parameters */
+static int debug = 0;
+#define dprintk(fmt, args...)                                     \
+	do{                                                       \
+		if(debug) printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
+                                 fmt, ## args);                   \
+	}while(0)
+
+static int io = IT87_CIR_DEFAULT_IOBASE;
+/* receiver demodulator default: off */
+static int it87_enable_demodulator = 0;
+
+static int timer_enabled = 0;
+static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static struct timer_list timerlist;
+/* time of last signal change detected */
+static struct timeval last_tv = {0, 0};
+/* time of last UART data ready interrupt */
+static struct timeval last_intr_tv = {0, 0};
+static int last_value = 0;
+
+static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
+
+static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+
+static lirc_t rx_buf[RBUF_LEN]; unsigned int rx_tail = 0, rx_head = 0;
+static lirc_t tx_buf[WBUF_LEN];
+
+/* SECTION: Prototypes */
+
+/* Communication with user-space */
+static int lirc_open(struct inode * inode,
+		     struct file * file);
+static int lirc_close(struct inode * inode,
+		      struct file *file);
+static unsigned int lirc_poll(struct file * file,
+			      poll_table * wait);
+static ssize_t lirc_read(struct file * file,
+			 char * buf,
+			 size_t count,
+			 loff_t * ppos);
+static ssize_t lirc_write(struct file * file,
+			  const char * buf,
+			  size_t n,
+			  loff_t * pos);
+static int lirc_ioctl(struct inode *node,
+		      struct file *filep,
+		      unsigned int cmd,
+		      unsigned long arg);
+static void add_read_queue(int flag,
+			   unsigned long val);
+#ifdef MODULE
+static int init_chrdev(void);
+static void drop_chrdev(void);
+#endif
+	/* Hardware */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static irqreturn_t it87_interrupt(int irq, void * dev_id,
+				 struct pt_regs * regs);
+#else
+static irqreturn_t it87_interrupt(int irq, void * dev_id);
+#endif
+static void send_space(unsigned long len);
+static void send_pulse(unsigned long len);
+static void init_send(void);
+static void terminate_send(unsigned long len);
+static int init_hardware(void);
+static void drop_hardware(void);
+	/* Initialisation */
+static int init_port(void);
+static void drop_port(void);
+int init_module(void);
+void cleanup_module(void);
+
+
+/* SECTION: Communication with user-space */
+
+static int lirc_open(struct inode * inode,
+		     struct file * file)
+{
+	spin_lock(&dev_lock);
+	if (MOD_IN_USE) {
+		spin_unlock(&dev_lock);
+		return -EBUSY;
+	}
+	MOD_INC_USE_COUNT;
+	spin_unlock(&dev_lock);
+	return 0;
+}
+
+
+static int lirc_close(struct inode * inode,
+		      struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+
+static unsigned int lirc_poll(struct file * file,
+			      poll_table * wait)
+{
+	poll_wait(file, &lirc_read_queue, wait);
+	if (rx_head != rx_tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+
+static ssize_t lirc_read(struct file * file,
+			 char * buf,
+			 size_t count,
+			 loff_t * ppos)
+{
+	int n=0;
+	int retval=0;
+	
+	while(n<count)
+	{
+		if(file->f_flags & O_NONBLOCK &&
+		   rx_head==rx_tail)
+		{
+			retval = -EAGAIN;
+			break;
+		}
+		retval=wait_event_interruptible(lirc_read_queue,
+						rx_head!=rx_tail);
+		if(retval)
+		{
+			break;
+		}
+		
+		if(copy_to_user((void *) buf+n,(void *) (rx_buf+rx_head),
+				sizeof(lirc_t)))
+		{
+			retval = -EFAULT;
+			break;
+		}
+		rx_head=(rx_head+1)&(RBUF_LEN-1);
+		n+=sizeof(lirc_t);
+	}
+	if(n)
+	{
+		return n;
+	}
+	return retval;
+}
+
+
+static ssize_t lirc_write(struct file * file,
+			  const char * buf,
+			  size_t n,
+			  loff_t * pos)
+{
+	int i;
+
+        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
+		return(-EINVAL);
+	if(copy_from_user(tx_buf, buf, n)) return -EFAULT;
+	i = 0;
+	n/=sizeof(lirc_t);
+	init_send();
+	while (1) {
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_pulse(tx_buf[i]);
+		i++;
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_space(tx_buf[i]);
+		i++;
+	}
+	terminate_send(tx_buf[i-1]);
+	return n;
+}
+
+
+static int lirc_ioctl(struct inode *node,
+		      struct file *filep,
+		      unsigned int cmd,
+		      unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+	unsigned int ivalue;
+
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE |
+			LIRC_CAN_SET_SEND_CARRIER |
+			LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+	
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+	case LIRC_GET_SEND_MODE:
+	case LIRC_GET_REC_MODE:
+		retval = put_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_CARRIER:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		ivalue /= 1000;
+		if (ivalue > IT87_CIR_FREQ_MAX ||
+		    ivalue < IT87_CIR_FREQ_MIN) return(-EINVAL);
+
+		it87_freq = ivalue;
+		{
+			unsigned long hw_flags;
+
+			spin_lock_irqsave(&hardware_lock, hw_flags);
+			outb(((inb(io + IT87_CIR_TCR2) & IT87_CIR_TCR2_TXMPW) |
+			      (it87_freq - IT87_CIR_FREQ_MIN) << 3),
+			     io + IT87_CIR_TCR2);
+			spin_unlock_irqrestore(&hardware_lock, hw_flags);
+			dprintk("demodulation frequency: %d kHz\n",
+				it87_freq);
+		}
+
+		break;
+
+	default:
+		retval = -ENOIOCTLCMD;
+	}
+	
+	if (retval)
+		return retval;
+	
+	if (cmd == LIRC_SET_REC_MODE) {
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+	} else if (cmd == LIRC_SET_SEND_MODE) {
+		if (value != LIRC_MODE_PULSE)
+			retval = -ENOSYS;
+	}
+	return retval;
+}
+
+static void add_read_queue(int flag, unsigned long val)
+{
+	unsigned int new_rx_tail;
+	lirc_t newval;
+
+	dprintk("add flag %d with val %lu\n", flag,val);
+	
+	newval = val & PULSE_MASK;
+
+	/* statistically pulses are ~TIME_CONST/2 too long: we could
+	   maybe make this more exactly but this is good enough */
+	if(flag) /* pulse */ {
+		if(newval>TIME_CONST/2) {
+			newval-=TIME_CONST/2;
+		}
+		else /* should not ever happen */ {
+			newval=1;
+		}
+		newval|=PULSE_BIT;
+	}
+	else {
+		newval+=TIME_CONST/2;
+	}
+	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
+	if (new_rx_tail == rx_head) {
+		dprintk("Buffer overrun.\n");
+		return;
+	}
+	rx_buf[rx_tail] = newval;
+	rx_tail = new_rx_tail;
+	wake_up_interruptible(&lirc_read_queue);
+}
+
+
+static struct file_operations lirc_fops = {
+	read:    lirc_read,
+	write:   lirc_write,
+	poll:    lirc_poll,
+	ioctl:   lirc_ioctl,
+	open:    lirc_open,
+	release: lirc_close,
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_INC_USE_COUNT;
+#endif
+       return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_DEC_USE_COUNT;
+#endif
+}
+static struct lirc_plugin plugin = {
+       name:           LIRC_DRIVER_NAME,
+       minor:          -1,
+       code_length:    1,
+       sample_rate:    0,
+       data:           NULL,
+       add_to_buf:     NULL,
+       get_queue:      NULL,
+       set_use_inc:    set_use_inc,
+       set_use_dec:    set_use_dec,
+       fops:           &lirc_fops,
+       dev:            NULL,
+       owner:	       THIS_MODULE,
+};
+
+
+#ifdef MODULE
+static int init_chrdev(void)
+{
+	plugin.minor = lirc_register_plugin(&plugin);
+	
+	if (plugin.minor < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+
+static void drop_chrdev(void)
+{
+	lirc_unregister_plugin(plugin.minor);
+}
+#endif
+
+
+/* SECTION: Hardware */
+static long delta(struct timeval * tv1,
+		  struct timeval * tv2)
+{
+	unsigned long deltv;
+	
+	deltv = tv2->tv_sec - tv1->tv_sec;
+	if (deltv > 15)
+		deltv = 0xFFFFFF;
+	else
+		deltv = deltv*1000000 +
+			tv2->tv_usec -
+			tv1->tv_usec;
+	return deltv;
+}
+
+static void it87_timeout(unsigned long data) 
+{
+	unsigned long flags;
+	
+	/* avoid interference with interrupt */
+ 	spin_lock_irqsave(&timer_lock, flags);
+	
+ 	if (digimatrix) {
+		/* We have timed out.
+		   Disable the RX mechanism.
+		*/
+		
+		outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+		     IT87_CIR_RCR_RXACT, io + IT87_CIR_RCR);
+		if (it87_RXEN_mask) {
+			outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
+			     io + IT87_CIR_RCR);
+		}
+		dprintk(" TIMEOUT\n");
+		timer_enabled = 0;
+
+		/* fifo clear */
+		outb(inb(io + IT87_CIR_TCR1) | IT87_CIR_TCR1_FIFOCLR,
+		     io+IT87_CIR_TCR1);
+
+	}
+	else {
+		/* if last received signal was a pulse, but receiving
+		   stopped within the 9 bit frame, we need to finish
+		   this pulse and simulate a signal change to from
+		   pulse to space. Otherwise upper layers will receive
+		   two sequences next time. */
+	
+		if (last_value) {
+			unsigned long pulse_end;
+			
+			/* determine 'virtual' pulse end: */
+	 		pulse_end = delta(&last_tv, &last_intr_tv);
+			dprintk("timeout add %d for %lu usec\n", 
+				last_value, pulse_end);
+			add_read_queue(last_value, pulse_end);
+			last_value = 0;
+			last_tv=last_intr_tv;
+		}
+	}
+	spin_unlock_irqrestore(&timer_lock, flags);		
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static irqreturn_t it87_interrupt(int irq,
+				 void * dev_id,
+				 struct pt_regs * regs)
+#else
+static irqreturn_t it87_interrupt(int irq,
+				  void * dev_id)
+#endif
+{
+	unsigned char data;
+	struct timeval curr_tv;
+	static unsigned long deltv;
+	unsigned long deltintrtv;
+	unsigned long flags, hw_flags;
+	int iir, lsr;
+	int fifo = 0;
+	static char lastbit = 0;
+	char bit;
+
+	/* Bit duration in microseconds */
+	const unsigned long bit_duration = 1000000ul / 
+		(115200 / IT87_CIR_BAUDRATE_DIVISOR);
+
+
+	iir = inb(io + IT87_CIR_IIR);
+
+	switch (iir & IT87_CIR_IIR_IID) {
+	case 0x4:
+	case 0x6:
+		lsr = inb(io + IT87_CIR_RSR) & (IT87_CIR_RSR_RXFTO |
+						IT87_CIR_RSR_RXFBC);
+		fifo = lsr & IT87_CIR_RSR_RXFBC;
+		dprintk("iir: 0x%x fifo: 0x%x\n", iir, lsr);
+	
+		/* avoid interference with timer */
+		spin_lock_irqsave(&timer_lock, flags);
+		spin_lock_irqsave(&hardware_lock, hw_flags);
+		if (digimatrix) { 
+			static unsigned long acc_pulse = 0;
+			static unsigned long acc_space = 0;
+			
+			do {
+				data = inb(io + IT87_CIR_DR);
+				data =~ data;
+				fifo--;
+				if (data != 0x00) {
+					if (timer_enabled) {
+						del_timer(&timerlist);
+					}
+					/* start timer for end of sequence detection */
+					timerlist.expires = jiffies + IT87_TIMEOUT;
+					add_timer(&timerlist);
+					timer_enabled = 1;
+				}
+				/* Loop through */
+				for(bit = 0; bit < 8; ++bit)
+				{
+					if((data >> bit) & 1)
+					{
+						++acc_pulse;
+						if(lastbit == 0)
+						{
+							add_read_queue(0, acc_space * bit_duration);
+							acc_space = 0;
+						}
+        				}
+					else
+					{
+						++acc_space;
+						if(lastbit == 1)
+						{
+							add_read_queue(1, acc_pulse * bit_duration);
+							acc_pulse = 0;
+						}
+					}
+					lastbit = (data >> bit) & 1;
+				}
+
+			} while (fifo != 0);
+	 	}
+		else {/* Normal Operation */
+			do {
+				del_timer(&timerlist);
+				data = inb(io + IT87_CIR_DR);
+
+				dprintk("data=%.2x\n", data);
+				do_gettimeofday(&curr_tv);
+				deltv = delta(&last_tv, &curr_tv);
+				deltintrtv = delta(&last_intr_tv, &curr_tv);
+
+				dprintk("t %lu , d %d\n", deltintrtv, (int)data);
+			
+				/* if nothing came in last 2 cycles,
+				   it was gap */
+				if (deltintrtv > TIME_CONST * 2) {
+					if (last_value) {
+						dprintk("GAP\n");
+
+						/* simulate signal change */
+						add_read_queue(last_value,
+							       deltv-
+							       deltintrtv);
+						last_value = 0;
+						last_tv.tv_sec = last_intr_tv.tv_sec;
+						last_tv.tv_usec = last_intr_tv.tv_usec;
+						deltv = deltintrtv;
+					}
+				}
+				data = 1;
+				if (data ^ last_value) {
+					/* deltintrtv > 2*TIME_CONST,
+					   remember ? */
+					/* the other case is timeout */
+					add_read_queue(last_value,
+						       deltv-TIME_CONST);
+					last_value = data;
+					last_tv = curr_tv;
+					if(last_tv.tv_usec>=TIME_CONST) {
+						last_tv.tv_usec-=TIME_CONST;
+					}
+					else {
+						last_tv.tv_sec--;
+						last_tv.tv_usec+=1000000-
+							TIME_CONST;
+					}
+				}
+				last_intr_tv = curr_tv;
+				if (data) {
+					/* start timer for end of sequence detection */
+					timerlist.expires = jiffies + IT87_TIMEOUT;
+					add_timer(&timerlist);
+				}
+				outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+				     IT87_CIR_RCR_RXACT,
+				     io + IT87_CIR_RCR);
+				if (it87_RXEN_mask) {
+					outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN, 
+					     io + IT87_CIR_RCR);
+				}
+				fifo--;
+			}
+			while (fifo != 0);
+		}
+		spin_unlock_irqrestore(&hardware_lock, hw_flags);
+		spin_unlock_irqrestore(&timer_lock, flags);
+		
+		return IRQ_RETVAL(IRQ_HANDLED);
+
+	default:
+		/* not our irq */
+		dprintk("unknown IRQ (shouldn't happen) !!\n");
+		return IRQ_RETVAL(IRQ_NONE);
+	}
+}
+
+
+static void send_it87(unsigned long len,
+		      unsigned long stime,
+		      unsigned char send_byte,
+		      unsigned int count_bits)
+{
+        long count = len / stime;
+	long time_left = 0;
+	static unsigned char byte_out = 0;
+
+	dprintk("%s: len=%ld, sb=%d\n", __FUNCTION__, len, send_byte);
+
+	time_left = (long)len - (long)count * (long)stime;
+	count += ((2 * time_left) / stime);
+	while (count) {
+		long i=0;
+		for (i=0; i<count_bits; i++) {
+			byte_out = (byte_out << 1) | (send_byte & 1);
+			it87_bits_in_byte_out++;
+		}
+		if (it87_bits_in_byte_out == 8) {
+			dprintk("out=0x%x, tsr_txfbc: 0x%x\n",
+				byte_out,
+				inb(io + IT87_CIR_TSR) &
+				IT87_CIR_TSR_TXFBC);
+
+			while ((inb(io + IT87_CIR_TSR) &
+				IT87_CIR_TSR_TXFBC) >= IT87_CIR_FIFO_SIZE);
+			{
+				unsigned long hw_flags;
+
+				spin_lock_irqsave(&hardware_lock, hw_flags);
+				outb(byte_out, io + IT87_CIR_DR);
+				spin_unlock_irqrestore(&hardware_lock, hw_flags);
+			}
+			it87_bits_in_byte_out = 0;
+			it87_send_counter++;
+			byte_out = 0;
+		}
+		count--;
+	}
+}
+
+
+/*
+maybe: exchange space and pulse because
+it8705 only modulates 0-bits
+*/
+
+
+static void send_space(unsigned long len)
+{
+	send_it87(len,
+		  TIME_CONST,
+		  IT87_CIR_SPACE,
+		  IT87_CIR_BAUDRATE_DIVISOR);
+}
+
+static void send_pulse(unsigned long len)
+{
+	send_it87(len,
+		  TIME_CONST,
+		  IT87_CIR_PULSE,
+		  IT87_CIR_BAUDRATE_DIVISOR);
+}
+
+
+static void init_send()
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* RXEN=0: receiver disable */
+	it87_RXEN_mask = 0;
+	outb(inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN,
+	     io + IT87_CIR_RCR);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	it87_bits_in_byte_out = 0;
+	it87_send_counter = 0;
+}
+
+
+static void terminate_send(unsigned long len)
+{
+	unsigned long flags;
+	unsigned long last = 0;
+
+	last = it87_send_counter;
+	/* make sure all necessary data has been sent */
+	while (last == it87_send_counter)
+		send_space(len);
+	/* wait until all data sent */
+	while ((inb(io + IT87_CIR_TSR) & IT87_CIR_TSR_TXFBC) != 0);
+	/* then reenable receiver */
+	spin_lock_irqsave(&hardware_lock, flags);
+	it87_RXEN_mask = IT87_CIR_RCR_RXEN;
+	outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
+	     io + IT87_CIR_RCR);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+
+static int init_hardware(void)
+{
+	unsigned long flags;
+	unsigned char it87_rcr = 0;
+	
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* init cir-port */
+	/* enable r/w-access to Baudrate-Register */
+	outb(IT87_CIR_IER_BR, io + IT87_CIR_IER);
+	outb(IT87_CIR_BAUDRATE_DIVISOR % 0x100, io+IT87_CIR_BDLR);
+	outb(IT87_CIR_BAUDRATE_DIVISOR / 0x100, io+IT87_CIR_BDHR);
+	/* Baudrate Register off, define IRQs: Input only */
+	if (digimatrix) {
+		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RFOIE, io + IT87_CIR_IER);
+		/* RX: HCFS=0, RXDCR = 001b (33,75..38,25 kHz), RXEN=1 */
+	}
+	else {
+		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
+		/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
+	}
+	it87_rcr = (IT87_CIR_RCR_RXEN & it87_RXEN_mask) | 0x1;
+	if (it87_enable_demodulator)
+		it87_rcr |= IT87_CIR_RCR_RXEND;
+	outb(it87_rcr, io + IT87_CIR_RCR);
+	if (digimatrix) {
+		/* Set FIFO depth to 1 byte, and disable TX */
+		outb(inb(io + IT87_CIR_TCR1) |  0x00,
+		     io + IT87_CIR_TCR1);
+
+		/* TX: it87_freq (36kHz), 
+		   'reserved' sensitivity setting (0x00) */
+		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x00,
+		     io + IT87_CIR_TCR2);
+	}
+	else {
+		/* TX: 38kHz, 13,3us (pulse-width */
+		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
+		     io + IT87_CIR_TCR2);
+	}
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	return 0;
+}
+
+
+static void drop_hardware(void)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hardware_lock, flags);
+	disable_irq(irq);
+	/* receiver disable */
+	it87_RXEN_mask = 0;
+	outb(0x1, io + IT87_CIR_RCR);
+	/* turn off irqs */
+	outb(0, io + IT87_CIR_IER);
+	/* fifo clear */
+        outb(IT87_CIR_TCR1_FIFOCLR, io+IT87_CIR_TCR1);
+        /* reset */
+        outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
+	enable_irq(irq);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+
+static unsigned char it87_read(unsigned char port)
+{
+	outb(port, IT87_ADRPORT);
+	return inb(IT87_DATAPORT);
+}
+
+
+static void it87_write(unsigned char port,
+		       unsigned char data)
+{
+	outb(port, IT87_ADRPORT);
+	outb(data, IT87_DATAPORT);
+}
+
+
+/* SECTION: Initialisation */
+
+static int init_port(void)
+{
+	unsigned long hw_flags;
+	int retval = 0;
+	
+	unsigned char init_bytes[4] = {IT87_INIT};
+	unsigned char it87_chipid = 0;
+	unsigned char ldn = 0;
+	unsigned int  it87_io = 0;
+	unsigned int  it87_irq = 0;
+	
+	/* Enter MB PnP Mode */
+	outb(init_bytes[0], IT87_ADRPORT);
+	outb(init_bytes[1], IT87_ADRPORT);
+	outb(init_bytes[2], IT87_ADRPORT);
+	outb(init_bytes[3], IT87_ADRPORT);
+	
+	/* 8712 or 8705 ? */
+	it87_chipid = it87_read(IT87_CHIP_ID1);
+	if (it87_chipid != 0x87) {
+		retval = -ENXIO;
+		return retval;
+	}
+	it87_chipid = it87_read(IT87_CHIP_ID2);
+	if ((it87_chipid != 0x12) && (it87_chipid != 0x05)) {
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": no IT8705/12 found, exiting..\n");
+		retval = -ENXIO;
+		return retval;
+	}
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": found IT87%.2x.\n",
+	       it87_chipid);
+
+	/* get I/O-Port and IRQ */
+	if (it87_chipid == 0x12)
+		ldn = IT8712_CIR_LDN;
+	else
+		ldn = IT8705_CIR_LDN;
+	it87_write(IT87_LDN, ldn);
+	
+	it87_io = it87_read(IT87_CIR_BASE_MSB) * 256 +
+		it87_read(IT87_CIR_BASE_LSB);
+	if (it87_io == 0) {
+		if (io == 0)
+			io = IT87_CIR_DEFAULT_IOBASE;
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": set default io 0x%x\n",
+		       io);
+		it87_write(IT87_CIR_BASE_MSB, io / 0x100);
+		it87_write(IT87_CIR_BASE_LSB, io % 0x100);
+	}
+	else
+		io = it87_io;
+	
+	it87_irq = it87_read(IT87_CIR_IRQ);
+	if (digimatrix || it87_irq == 0) {
+		if (irq == 0)
+			irq = IT87_CIR_DEFAULT_IRQ;
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": set default irq 0x%x\n",
+		       irq);
+		it87_write(IT87_CIR_IRQ, irq);
+	}
+	else
+	{
+		irq = it87_irq;
+	}
+
+	spin_lock_irqsave(&hardware_lock, hw_flags);
+	/* reset */
+	outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
+	/* fifo clear */
+	outb(IT87_CIR_TCR1_FIFOCLR |
+	     /*	     IT87_CIR_TCR1_ILE | */
+	     IT87_CIR_TCR1_TXRLE |
+	     IT87_CIR_TCR1_TXENDF, io+IT87_CIR_TCR1);
+	spin_unlock_irqrestore(&hardware_lock, hw_flags);
+	
+	/* get I/O port access and IRQ line */
+	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL)
+	{
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": i/o port 0x%.4x already in use.\n",
+		       io);
+		/* Leaving MB PnP Mode */
+		it87_write(IT87_CFGCTRL, 0x2);
+		return -EBUSY;
+	}
+
+	/* activate CIR-Device */
+	it87_write(IT87_CIR_ACT, 0x1);
+
+	/* Leaving MB PnP Mode */
+	it87_write(IT87_CFGCTRL, 0x2);
+
+	retval = request_irq(irq, it87_interrupt, 0 /*SA_INTERRUPT*/,
+			     LIRC_DRIVER_NAME, NULL);
+	if (retval < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": IRQ %d already in use.\n",
+		       irq);
+		release_region(io, 8);
+		return retval;
+	}
+
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": I/O port 0x%.4x, IRQ %d.\n",
+	       io,
+	       irq);
+
+	init_timer(&timerlist);
+	timerlist.function = it87_timeout;
+	timerlist.data = 0xabadcafe;
+	
+	return 0;
+}
+
+
+static void drop_port(void)
+{
+/*
+        unsigned char init_bytes[4] = {IT87_INIT};
+ 
+        / * Enter MB PnP Mode * /
+        outb(init_bytes[0], IT87_ADRPORT);
+        outb(init_bytes[1], IT87_ADRPORT);
+        outb(init_bytes[2], IT87_ADRPORT);
+        outb(init_bytes[3], IT87_ADRPORT);
+
+        / * deactivate CIR-Device * /
+        it87_write(IT87_CIR_ACT, 0x0);
+
+        / * Leaving MB PnP Mode * /
+        it87_write(IT87_CFGCTRL, 0x2);
+*/
+
+	del_timer_sync(&timerlist);
+	free_irq(irq, NULL);
+	release_region(io, 8);
+}
+
+
+static int init_lirc_it87(void)
+{
+	int retval;
+	
+	init_waitqueue_head(&lirc_read_queue);
+	retval = init_port();
+	if (retval < 0)
+		return retval;
+	init_hardware();
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": Installed.\n");
+	return 0;
+}
+
+
+#ifdef MODULE
+
+int init_module(void)
+{
+	int retval;
+	
+	retval=init_chrdev();
+	if(retval < 0)
+		return retval;
+	retval = init_lirc_it87();
+	if (retval) {
+		drop_chrdev();
+		return retval;
+	}
+	return 0;
+}
+
+
+void cleanup_module(void)
+{
+	drop_hardware();
+	drop_chrdev();
+	drop_port();
+	printk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");
+}
+
+MODULE_DESCRIPTION("LIRC driver for ITE IT8712/IT8705 CIR port");
+MODULE_AUTHOR("Hans-Gnter Ltke Uphues");
+MODULE_LICENSE("GPL");
+
+module_param(io, int, 0444);
+MODULE_PARM_DESC(io, "I/O base address (default: 0x310)");
+
+module_param(irq, int, 0444);
+#ifdef LIRC_IT87_DIGIMATRIX
+MODULE_PARM_DESC(irq, "Interrupt (1,3-12) (default: 9)");
+#else
+MODULE_PARM_DESC(irq, "Interrupt (1,3-12) (default: 7)");
+#endif
+
+module_param(it87_enable_demodulator, bool, 0444);
+MODULE_PARM_DESC(it87_enable_demodulator, 
+		 "Receiver demodulator enable/disable (1/0), default: 0");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+module_param(digimatrix, bool, 0644);
+#ifdef LIRC_IT87_DIGIMATRIX
+MODULE_PARM_DESC(digimatrix, 
+	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 1");
+#else
+MODULE_PARM_DESC(digimatrix, 
+	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 0");
+#endif
+
+
+module_param(it87_freq, int, 0444);
+#ifdef LIRC_IT87_DIGIMATRIX
+MODULE_PARM_DESC(it87_freq,
+    "Carrier demodulator frequency (kHz), (default: 36)");
+#else
+MODULE_PARM_DESC(it87_freq,
+    "Carrier demodulator frequency (kHz), (default: 38)");
+#endif
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
+
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_it87.h linux-2.6.23.1-stm/drivers/char/lirc/lirc_it87.h
--- linux-2.6.23.1/drivers/char/lirc/lirc_it87.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_it87.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,116 @@
+/* lirc_it87.h */
+/* SECTION: Definitions */
+
+/********************************* ITE IT87xx ************************/
+
+/* based on the following documentation from ITE:
+   a) IT8712F Preliminary CIR Programming Guide V0.1
+   b) IT8705F Simple LPC I/O Preliminary Specifiction V0.3
+   c) IT8712F EC-LPC I/O Preliminary Specification V0.5
+*/
+
+/* IT8712/05 Ports: */
+#define IT87_ADRPORT      0x2e
+#define IT87_DATAPORT     0x2f
+#define IT87_INIT         0x87, 0x01, 0x55, 0x55
+
+/* alternate Ports: */
+/*
+#define IT87_ADRPORT      0x4e
+#define IT87_DATAPORT     0x4f
+#define IT87_INIT         0x87, 0x01, 0x55, 0xaa
+ */
+
+/* IT8712/05 Registers */
+#define IT87_CFGCTRL      0x2
+#define IT87_LDN          0x7
+#define IT87_CHIP_ID1     0x20
+#define IT87_CHIP_ID2     0x21
+#define IT87_CFG_VERSION  0x22
+#define IT87_SWSUSPEND    0x23
+
+#define IT8712_CIR_LDN    0xa
+#define IT8705_CIR_LDN    0x7
+
+/* CIR Configuration Registers: */
+#define IT87_CIR_ACT      0x30
+#define IT87_CIR_BASE_MSB 0x60
+#define IT87_CIR_BASE_LSB 0x61
+#define IT87_CIR_IRQ      0x70
+#define IT87_CIR_CONFIG   0xf0
+
+/* List of IT87_CIR registers: offset to BaseAddr */
+#define IT87_CIR_DR   0
+#define IT87_CIR_IER  1
+#define IT87_CIR_RCR  2
+#define IT87_CIR_TCR1 3
+#define IT87_CIR_TCR2 4
+#define IT87_CIR_TSR  5
+#define IT87_CIR_RSR  6
+#define IT87_CIR_BDLR 5
+#define IT87_CIR_BDHR 6
+#define IT87_CIR_IIR  7
+
+/* Bit Definitionen */
+/* IER: */
+#define IT87_CIR_IER_TM_EN   0x80
+#define IT87_CIR_IER_RESEVED 0x40
+#define IT87_CIR_IER_RESET   0x20
+#define IT87_CIR_IER_BR      0x10
+#define IT87_CIR_IER_IEC     0x8
+#define IT87_CIR_IER_RFOIE   0x4
+#define IT87_CIR_IER_RDAIE   0x2
+#define IT87_CIR_IER_TLDLIE  0x1
+
+/* RCR: */
+#define IT87_CIR_RCR_RDWOS  0x80
+#define IT87_CIR_RCR_HCFS   0x40
+#define IT87_CIR_RCR_RXEN   0x20
+#define IT87_CIR_RCR_RXEND  0x10
+#define IT87_CIR_RCR_RXACT  0x8
+#define IT87_CIR_RCR_RXDCR  0x7
+
+/* TCR1: */
+#define IT87_CIR_TCR1_FIFOCLR 0x80
+#define IT87_CIR_TCR1_ILE     0x40
+#define IT87_CIR_TCR1_FIFOTL  0x30
+#define IT87_CIR_TCR1_TXRLE   0x8
+#define IT87_CIR_TCR1_TXENDF  0x4
+#define IT87_CIR_TCR1_TXMPM   0x3
+
+/* TCR2: */
+#define IT87_CIR_TCR2_CFQ   0xf8
+#define IT87_CIR_TCR2_TXMPW 0x7
+
+/* TSR: */
+#define IT87_CIR_TSR_RESERVED 0xc0
+#define IT87_CIR_TSR_TXFBC    0x3f
+
+/* RSR: */
+#define IT87_CIR_RSR_RXFTO    0x80
+#define IT87_CIR_RSR_RESERVED 0x40
+#define IT87_CIR_RSR_RXFBC    0x3f
+
+/* IIR: */
+#define IT87_CIR_IIR_RESERVED 0xf8
+#define IT87_CIR_IIR_IID      0x6
+#define IT87_CIR_IIR_IIP      0x1
+
+/* TM: */
+#define IT87_CIR_TM_IL_SEL    0x80
+#define IT87_CIR_TM_RESERVED  0x40
+#define IT87_CIR_TM_TM_REG    0x3f
+
+#define IT87_CIR_FIFO_SIZE 32
+
+/* Baudratedivisor for IT87: power of 2: only 1,2,4 or 8) */
+#define IT87_CIR_BAUDRATE_DIVISOR 0x1
+#define IT87_CIR_DEFAULT_IOBASE 0x310
+#define IT87_CIR_DEFAULT_IRQ    0x7
+#define IT87_CIR_SPACE 0x00
+#define IT87_CIR_PULSE 0xff
+#define IT87_CIR_FREQ_MIN 27
+#define IT87_CIR_FREQ_MAX 58
+#define TIME_CONST (IT87_CIR_BAUDRATE_DIVISOR * 8000000ul / 115200ul)
+
+/********************************* ITE IT87xx ************************/
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_mceusb.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_mceusb.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_mceusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_mceusb.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1027 @@
+/*
+ * USB Microsoft IR Transceiver driver - 0.2
+ *
+ * Copyright (c) 2003-2004 Dan Conti (dconti@acm.wwu.edu)
+ *
+ * This driver is based on the USB skeleton driver packaged with the
+ * kernel, and the notice from that package has been retained below.
+ *
+ * The Microsoft IR Transceiver is a neat little IR receiver with two
+ * emitters on it designed for Windows Media Center. This driver might
+ * work for all media center remotes, but I have only tested it with
+ * the philips model. The first revision of this driver only supports
+ * the receive function - the transmit function will be much more
+ * tricky due to the nature of the hardware. Microsoft chose to build
+ * this device inexpensively, therefore making it extra dumb.
+ * There is no interrupt endpoint on this device; all usb traffic
+ * happens over two bulk endpoints. As a result of this, poll() for
+ * this device is an actual hardware poll (instead of a receive queue
+ * check) and is rather expensive.
+ *
+ * All trademarks property of their respective owners. This driver was
+ * originally based on the USB skeleton driver, although significant
+ * portions of that code have been removed as the driver has evolved.
+ *
+ * 2003_11_11 - Restructured to minimalize code interpretation in the
+ *              driver. The normal use case will be with lirc.
+ *
+ * 2004_01_01 - Removed all code interpretation. Generate mode2 data
+ *              for passing off to lirc. Cleanup
+ *
+ * 2004_01_04 - Removed devfs handle. Put in a temporary workaround
+ *              for a known issue where repeats generate two
+ *              sequential spaces (last_was_repeat_gap)
+ *
+ * 2004_02_17 - Changed top level api to no longer use fops, and
+ *              instead use new interface for polling via
+ *              lirc_thread. Restructure data read/mode2 generation to
+ *              a single pass, reducing number of buffers. Rev to .2
+ *
+ * 2004_02_27 - Last of fixups to plugin->add_to_buf API. Properly
+ *              handle broken fragments from the receiver. Up the
+ *              sample rate and remove any pacing from
+ *              fetch_more_data. Fixes all known issues.
+ * 
+ * TODO
+ *   - Fix up minor number, registration of major/minor with usb subsystem
+ *
+ */
+/*
+ * USB Skeleton driver - 1.1
+ *
+ * Copyright (C) 2001-2003 Greg Kroah-Hartman (greg@kroah.com)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ *
+ * This driver is to be used as a skeleton driver to be able to create a
+ * USB driver quickly.  The design of it is based on the usb-serial and
+ * dc2xx drivers.
+ *
+ * Thanks to Oliver Neukum, David Brownell, and Alan Stern for their help
+ * in debugging this driver.
+ *
+ *
+ * History:
+ *
+ * 2003-05-06 - 1.1 - changes due to usb core changes with usb_register_dev()
+ * 2003-02-25 - 1.0 - fix races involving urb->status, unlink_urb(), and
+ *			disconnect.  Fix transfer amount in read().  Use
+ *			macros instead of magic numbers in probe().  Change
+ *			size variables to size_t.  Show how to eliminate
+ *			DMA bounce buffer.
+ * 2002_12_12 - 0.9 - compile fixes and got rid of fixed minor array.
+ * 2002_09_26 - 0.8 - changes due to USB core conversion to struct device
+ *			driver.
+ * 2002_02_12 - 0.7 - zero out dev in probe function for devices that do
+ *			not have both a bulk in and bulk out endpoint.
+ *			Thanks to Holger Waechtler for the fix.
+ * 2001_11_05 - 0.6 - fix minor locking problem in skel_disconnect.
+ *			Thanks to Pete Zaitcev for the fix.
+ * 2001_09_04 - 0.5 - fix devfs bug in skel_disconnect. Thanks to wim delvaux
+ * 2001_08_21 - 0.4 - more small bug fixes.
+ * 2001_05_29 - 0.3 - more bug fixes based on review from linux-usb-devel
+ * 2001_05_24 - 0.2 - bug fixes based on review from linux-usb-devel people
+ * 2001_05_01 - 0.1 - first version
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/usb.h>
+#ifdef KERNEL_2_5
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#else
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#endif
+
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+/* Use our own dbg macro */
+#define dprintk(fmt, args...)                             \
+	do{                                               \
+		if(debug) printk(KERN_DEBUG __FILE__ ": " \
+				 fmt "\n", ## args);      \
+	}while(0)
+
+/* Version Information */
+#define DRIVER_VERSION "v0.2"
+#define DRIVER_AUTHOR "Dan Conti, dconti@acm.wwu.edu"
+#define DRIVER_DESC "USB Microsoft IR Transceiver Driver"
+#define DRIVER_NAME "lirc_mceusb"
+
+/* Define these values to match your device */
+#define USB_MCEUSB_VENDOR_ID	0x045e
+#define USB_MCEUSB_PRODUCT_ID	0x006d
+
+/* table of devices that work with this driver */
+static struct usb_device_id mceusb_table [] = {
+	{ USB_DEVICE(USB_MCEUSB_VENDOR_ID, USB_MCEUSB_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+
+/* we can have up to this number of device plugged in at once */
+#define MAX_DEVICES		16
+
+/* Structure to hold all of our device specific stuff */
+struct usb_skel {
+	struct usb_device *	    udev;		/* save off the usb device pointer */
+	struct usb_interface *	interface;		/* the interface for this device */
+	unsigned char   minor;				/* the starting minor number for this device */
+	unsigned char   num_ports;			/* the number of ports this device has */
+	char            num_interrupt_in;		/* number of interrupt in endpoints we have */
+	char            num_bulk_in;			/* number of bulk in endpoints we have */
+	char            num_bulk_out;			/* number of bulk out endpoints we have */
+
+	unsigned char *    bulk_in_buffer;		/* the buffer to receive data */
+	int                bulk_in_size;		/* the size of the receive buffer */
+	__u8               bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
+
+	unsigned char *    bulk_out_buffer;		/* the buffer to send data */
+	int	               bulk_out_size;		/* the size of the send buffer */
+	struct urb *       write_urb;			/* the urb used to send data */
+	__u8               bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
+
+	atomic_t		write_busy;		/* true iff write urb is busy */
+	struct completion	write_finished;		/* wait for the write to finish */
+	
+	wait_queue_head_t  wait_q;			/* for timeouts */
+	int                open_count;			/* number of times this port has been opened */
+	struct semaphore   sem;				/* locks this structure */
+	
+	int			present;		/* if the device is not disconnected */		
+
+	struct lirc_plugin* plugin;
+	
+	lirc_t lircdata[256];          			/* place to store values until lirc processes them */
+	int    lircidx;                			/* current index */
+	int    lirccnt;                			/* remaining values */
+	
+	int    usb_valid_bytes_in_bulk_buffer;		/* leftover data from a previous read */
+	int    mce_bytes_left_in_packet;		/* for packets split across multiple reads */
+	
+	/* Value to hold the last received space; 0 if last value
+	 * received was a pulse
+	 */
+	int    last_space;
+	
+#ifdef KERNEL_2_5
+	dma_addr_t dma_in;
+	dma_addr_t dma_out;
+#endif
+};
+
+#define MCE_TIME_UNIT 50
+
+/* driver api */
+#ifdef KERNEL_2_5
+static int mceusb_probe		(struct usb_interface *interface, const struct usb_device_id *id);
+static void mceusb_disconnect	(struct usb_interface *interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void mceusb_write_bulk_callback	(struct urb *urb, struct pt_regs *regs);
+#else
+static void mceusb_write_bulk_callback	(struct urb *urb);
+#endif
+#else
+static void * mceusb_probe	(struct usb_device *dev, unsigned int ifnum, const struct usb_device_id *id);
+static void mceusb_disconnect	(struct usb_device *dev, void *ptr);
+static void mceusb_write_bulk_callback	(struct urb *urb);
+#endif
+
+/* read data from the usb bus; convert to mode2 */
+static int msir_fetch_more_data( struct usb_skel* dev, int dont_block );
+
+/* helper functions */
+static void msir_cleanup( struct usb_skel* dev );
+static void set_use_dec( void* data );
+static int set_use_inc( void* data );
+    
+/* array of pointers to our devices that are currently connected */
+static struct usb_skel		*minor_table[MAX_DEVICES];
+
+/* lock to protect the minor_table structure */
+static DECLARE_MUTEX (minor_table_mutex);
+static void mceusb_setup( struct usb_device *udev );
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver mceusb_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name =		DRIVER_NAME,
+	.probe =	mceusb_probe,
+	.disconnect =	mceusb_disconnect,
+	.id_table =	mceusb_table,
+};
+
+
+/**
+ *	usb_mceusb_debug_data
+ */
+static inline void usb_mceusb_debug_data (const char *function, int size,
+					  const unsigned char *data)
+{
+	int i;
+	if (!debug)
+		return;
+	
+	printk(KERN_DEBUG __FILE__": %s - length = %d, data = ", 
+	       function, size);
+	for (i = 0; i < size; ++i) {
+		printk(KERN_DEBUG "%.2x ", data[i]);
+	}
+	printk(KERN_DEBUG "\n");
+}
+
+/**
+ *mceusb_delete
+ */
+static inline void mceusb_delete (struct usb_skel *dev)
+{
+	dprintk("%s", __func__);
+	minor_table[dev->minor] = NULL;
+#ifdef KERNEL_2_5
+	usb_buffer_free(dev->udev, dev->bulk_in_size, dev->bulk_in_buffer, dev->dma_in);
+	usb_buffer_free(dev->udev, dev->bulk_out_size, dev->bulk_out_buffer, dev->dma_out);
+#else
+	if (dev->bulk_in_buffer != NULL)
+		kfree (dev->bulk_in_buffer);
+	if (dev->bulk_out_buffer != NULL)
+		kfree (dev->bulk_out_buffer);
+#endif
+	if (dev->write_urb != NULL)
+		usb_free_urb (dev->write_urb);
+	kfree (dev);
+}
+
+static void mceusb_setup( struct usb_device *udev )
+{
+	char data[8];
+	int res;
+	
+	memset( data, 0, 8 );
+
+	/* Get Status */
+	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+			      USB_REQ_GET_STATUS, USB_DIR_IN,
+			      0, 0, data, 2, HZ * 3);
+    
+	/*    res = usb_get_status( udev, 0, 0, data ); */
+	dprintk("%s - res = %d status = 0x%x 0x%x", __func__,
+		res, data[0], data[1]);
+    
+	/* This is a strange one. They issue a set address to the device
+	 * on the receive control pipe and expect a certain value pair back
+	 */
+	memset( data, 0, 8 );
+
+	res = usb_control_msg( udev, usb_rcvctrlpipe(udev, 0),
+			       5, USB_TYPE_VENDOR, 0, 0,
+			       data, 2, HZ * 3 );
+	dprintk("%s - res = %d, devnum = %d", __func__, res, udev->devnum);
+	dprintk("%s - data[0] = %d, data[1] = %d", __func__,
+		data[0], data[1] );
+
+    
+	/* set feature */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+			       0xc04e, 0x0000, NULL, 0, HZ * 3 );
+    
+	dprintk("%s - res = %d", __func__, res);
+
+	/* These two are sent by the windows driver, but stall for
+	 * me. I dont have an analyzer on the linux side so i can't
+	 * see what is actually different and why the device takes
+	 * issue with them
+	 */
+#if 0
+	/* this is some custom control message they send */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       0x04, USB_TYPE_VENDOR,
+			       0x0808, 0x0000, NULL, 0, HZ * 3 );
+    
+	dprintk("%s - res = %d", __func__, res);
+    
+	/* this is another custom control message they send */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       0x02, USB_TYPE_VENDOR,
+			       0x0000, 0x0100, NULL, 0, HZ * 3 );
+    
+	dprintk("%s - res = %d", __func__, res);
+#endif
+}
+
+static void msir_cleanup( struct usb_skel* dev )
+{
+	memset( dev->bulk_in_buffer, 0, dev->bulk_in_size );
+
+	dev->usb_valid_bytes_in_bulk_buffer = 0;
+
+	dev->last_space = PULSE_MASK;
+    
+	dev->mce_bytes_left_in_packet = 0;
+	dev->lircidx = 0;
+	dev->lirccnt = 0;
+	memset( dev->lircdata, 0, sizeof(dev->lircdata) );
+}
+
+static int set_use_inc(void* data)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * msir_fetch_more_data
+ *
+ * The goal here is to read in more remote codes from the remote. In
+ * the event that the remote isn't sending us anything, the caller
+ * will block until a key is pressed (i.e. this performs phys read,
+ * filtering, and queueing of data) unless dont_block is set to 1; in
+ * this situation, it will perform a few reads and will exit out if it
+ * does not see any appropriate data
+ *
+ * dev->sem should be locked when this function is called - fine grain
+ * locking isn't really important here anyways
+ *
+ * This routine always returns the number of words available
+ *
+ */
+static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
+{
+	int retries = 0;
+	int words_to_read = 
+		(sizeof(dev->lircdata)/sizeof(lirc_t)) - dev->lirccnt;
+	int partial, this_read = 0;
+	int bulkidx = 0;
+	int bytes_left_in_packet = 0;
+	signed char* signedp = (signed char*)dev->bulk_in_buffer;
+	
+	if( words_to_read == 0 )
+		return dev->lirccnt;
+
+	/* this forces all existing data to be read by lirc before we
+	 * issue another usb command. this is the only form of
+	 * throttling we have
+	 */
+	if( dev->lirccnt )
+	{
+		return dev->lirccnt;
+	}
+
+	/* reserve room for our leading space */
+	if( dev->last_space )
+		words_to_read--;
+		
+	while( words_to_read )
+	{
+		/* handle signals and USB disconnects */
+		if( signal_pending(current) )
+		{
+			return dev->lirccnt ? dev->lirccnt : -EINTR;
+		}
+		if( !dev->udev )
+		{
+			return -ENODEV;
+		}
+
+		bulkidx = 0;
+
+		/*
+		 * perform data read (phys or from previous buffer)
+		 */
+        
+		/* use leftovers if present, otherwise perform a read */
+		if( dev->usb_valid_bytes_in_bulk_buffer )
+		{
+			this_read = partial = 
+				dev->usb_valid_bytes_in_bulk_buffer;
+			dev->usb_valid_bytes_in_bulk_buffer = 0;
+		}
+		else
+		{
+			int retval;
+            
+			this_read = dev->bulk_in_size;
+			partial = 0;
+			retval = usb_bulk_msg
+				(dev->udev,
+				 usb_rcvbulkpipe
+				 (dev->udev, dev->bulk_in_endpointAddr),
+				 (unsigned char*)dev->bulk_in_buffer,
+				 this_read, &partial, HZ*10);
+			
+			/* retry a few times on overruns; map all
+			   other errors to -EIO */
+			if( retval )
+			{
+				if( retval == -EOVERFLOW && 
+				    retries < 5 )
+				{
+					retries++;
+					interruptible_sleep_on_timeout
+						( &dev->wait_q, HZ );
+					continue;
+				}
+				else
+				{
+					return -EIO;
+				}
+			}
+            
+			retries = 0;
+			if( partial )
+				this_read = partial;
+
+			/* skip the header */
+			bulkidx += 2;
+            
+			/* check for empty reads (header only) */
+			if( this_read == 2 )
+			{
+				/* assume no data */
+				if( dont_block )
+				{
+					break;
+				}
+
+				/* sleep for a bit before performing
+				   another read */
+				interruptible_sleep_on_timeout
+					( &dev->wait_q, 1 );
+				continue;
+			}
+		}
+
+		/*
+		 * process data
+		 */
+        
+		/* at this point this_read is > 0 */
+		while( bulkidx < this_read &&
+		       (words_to_read > (dev->last_space ? 1 : 0)) )
+			//while( bulkidx < this_read && words_to_read )
+		{
+			int keycode;
+			int pulse = 0;
+            
+			/* read packet length if needed */
+			if( !bytes_left_in_packet )
+			{
+				
+				/* we assume we are on a packet length
+				 * value. it is possible, in some
+				 * cases, to get a packet that does
+				 * not start with a length, apparently
+				 * due to some sort of fragmenting,
+				 * but occaisonally we do not receive
+				 * the second half of a fragment
+				 */
+				bytes_left_in_packet = 
+					128 + signedp[bulkidx++];
+
+				/* unfortunately rather than keep all
+				 * the data in the packetized format,
+				 * the transceiver sends a trailing 8
+				 * bytes that aren't part of the
+				 * transmittion from the remote,
+				 * aren't packetized, and dont really
+				 * have any value. we can basically
+				 * tell we have hit them if 1) we have
+				 * a loooong space currently stored
+				 * up, and 2) the bytes_left value for
+				 * this packet is obviously wrong
+				 */
+				if( bytes_left_in_packet > 4  )
+				{
+					if( dev->mce_bytes_left_in_packet )
+					{
+						bytes_left_in_packet = dev->mce_bytes_left_in_packet;
+						bulkidx--;
+					}
+					bytes_left_in_packet = 0;
+					bulkidx = this_read;
+				}
+
+				/* always clear this if we have a
+				   valid packet */
+				dev->mce_bytes_left_in_packet = 0;
+                    
+				/* continue here to verify we haven't
+				   hit the end of the bulk_in */
+				continue;
+				
+			}
+
+			/*
+			 * generate mode2
+			 */
+            
+			keycode = signedp[bulkidx++];
+			if( keycode < 0 )
+			{
+				pulse = 1;
+				keycode += 128;
+			}
+			keycode *= MCE_TIME_UNIT;
+
+			bytes_left_in_packet--;
+            
+			if( pulse )
+			{
+				if( dev->last_space )
+				{
+					dev->lircdata[dev->lirccnt++] =
+						dev->last_space;
+					dev->last_space = 0;
+					words_to_read--;
+
+					/* clear the lirc_t for the pulse */
+					dev->lircdata[dev->lirccnt] = 0;
+				}
+				dev->lircdata[dev->lirccnt] += keycode;
+				dev->lircdata[dev->lirccnt] |= PULSE_BIT;
+			}
+			else
+			{
+				/* on pulse->space transition, add one
+				   for the existing pulse */
+				if( dev->lircdata[dev->lirccnt] &&
+				    !dev->last_space )
+				{
+					dev->lirccnt++;
+					words_to_read--;
+				}
+                
+				dev->last_space += keycode;
+			}
+		}
+	}
+	
+	/* save off some info if we are exiting mid-packet, or with
+	   leftovers */
+	if( bytes_left_in_packet )
+	{
+		dev->mce_bytes_left_in_packet = bytes_left_in_packet;
+	}
+	if( bulkidx < this_read )
+	{
+		dev->usb_valid_bytes_in_bulk_buffer = (this_read - bulkidx);
+		memcpy( dev->bulk_in_buffer, &(dev->bulk_in_buffer[bulkidx]),
+			dev->usb_valid_bytes_in_bulk_buffer );
+	}
+	return dev->lirccnt;
+}
+
+/* mceusb_add_to_buf: called by lirc_dev to fetch all available keys
+ * this is used as a polling interface for us: since we set
+ * plugin->sample_rate we will periodically get the below call to
+ * check for new data returns 0 on success, or -ENODATA if nothing is
+ * available
+ */
+static int mceusb_add_to_buf(void* data, struct lirc_buffer* buf )
+{
+	struct usb_skel* dev = (struct usb_skel*) data;
+
+	down( &dev->sem );
+
+	/* verify device still present */
+	if( dev->udev == NULL )
+	{
+		up( &dev->sem );
+		return -ENODEV;
+	}
+
+	if( !dev->lirccnt )
+	{
+		int res;
+		dev->lircidx = 0;
+        
+		res = msir_fetch_more_data( dev, 1 );
+		
+		if( res == 0 )
+			res = -ENODATA;
+		if( res < 0 ) {
+			up( &dev->sem );
+			return res;
+		}
+	}
+
+	if( dev->lirccnt )
+	{
+		int keys_to_copy;
+
+		/* determine available buffer space and available data */
+		keys_to_copy = lirc_buffer_available( buf );
+		if( keys_to_copy > dev->lirccnt )
+		{
+			keys_to_copy = dev->lirccnt;
+		}
+        
+		lirc_buffer_write_n( buf, (unsigned char*) &(dev->lircdata[dev->lircidx]), keys_to_copy );
+		dev->lircidx += keys_to_copy;
+		dev->lirccnt -= keys_to_copy;
+        
+		up( &dev->sem );
+		return 0;
+	}
+
+	up( &dev->sem );
+	return -ENODATA;
+}
+
+/**
+ *	mceusb_write_bulk_callback
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void mceusb_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+#else
+static void mceusb_write_bulk_callback (struct urb *urb)
+#endif
+{
+	struct usb_skel *dev = (struct usb_skel *)urb->context;
+
+	dprintk("%s - minor %d", __func__, dev->minor);
+
+	if ((urb->status != -ENOENT) && 
+	    (urb->status != -ECONNRESET)) {
+		dprintk("%s - nonzero write buld status received: %d",
+			__func__, urb->status);
+		return;
+	}
+
+	return;
+}
+
+/**
+ *	mceusb_probe
+ *
+ *	Called by the usb core when a new device is connected that it 
+ *	thinks this driver might be interested in.
+ */
+#ifdef KERNEL_2_5 
+static int mceusb_probe(struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(interface);
+	struct usb_host_interface *iface_desc;
+#else
+static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
+			   const struct usb_device_id *id)
+{
+	struct usb_interface *interface = &udev->actconfig->interface[ifnum];
+	struct usb_interface_descriptor *iface_desc;	
+#endif
+	struct usb_skel *dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	
+	struct lirc_plugin* plugin;
+	struct lirc_buffer* rbuf;
+
+	int minor;
+	size_t buffer_size;
+	int i;
+	int retval = -ENOMEM;
+	
+	/* See if the device offered us matches what we can accept */
+	if ((cpu_to_le16(udev->descriptor.idVendor) != USB_MCEUSB_VENDOR_ID) ||
+	    (cpu_to_le16(udev->descriptor.idProduct) != USB_MCEUSB_PRODUCT_ID)) {
+	    	dprintk("Wrong Vendor/Product IDs");
+#ifdef KERNEL_2_5
+		return -ENODEV;
+#else
+		return NULL;
+#endif
+	}
+
+	/* select a "subminor" number (part of a minor number) */
+	down (&minor_table_mutex);
+	for (minor = 0; minor < MAX_DEVICES; ++minor) {
+		if (minor_table[minor] == NULL)
+			break;
+	}
+	if (minor >= MAX_DEVICES) {
+		info ("Too many devices plugged in, "
+		      "can not handle this device.");
+		goto error;
+	}
+
+	/* allocate memory for our device state and initialize it */
+	dev = kmalloc (sizeof(struct usb_skel), GFP_KERNEL);
+	if (dev == NULL) {
+		err ("Out of memory");
+#ifdef KERNEL_2_5
+		retval = -ENOMEM;
+#endif
+		goto error;
+	}
+	minor_table[minor] = dev;
+	
+	memset (dev, 0x00, sizeof (*dev));
+	init_MUTEX (&dev->sem);
+	dev->udev = udev;
+	dev->interface = interface;
+	dev->minor = minor;
+
+	/* set up the endpoint information */
+	/* check out the endpoints */
+	/* use only the first bulk-in and bulk-out endpoints */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
+	iface_desc = interface->cur_altsetting;
+#else
+	iface_desc = &interface->altsetting[0];
+#endif
+
+#ifdef KERNEL_2_5
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+#else
+	for (i = 0; i < iface_desc->bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i];
+#endif
+		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			dprintk("we found a bulk in endpoint");
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_in_size = buffer_size;
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+#ifdef KERNEL_2_5
+			dev->bulk_in_buffer = usb_buffer_alloc
+				(udev, buffer_size, GFP_ATOMIC, &dev->dma_in);
+#else
+			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
+#endif
+			if (!dev->bulk_in_buffer) {
+				err("Couldn't allocate bulk_in_buffer");
+				goto error;
+			}
+		}
+		
+		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == 0x00) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			dprintk("we found a bulk out endpoint");
+#ifdef KERNEL_2_5
+			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
+#else
+			dev->write_urb = usb_alloc_urb(0);
+#endif
+			if (!dev->write_urb) {
+				err("No free urbs available");
+				goto error;
+			}
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_out_size = buffer_size;
+			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+#ifdef KERNEL_2_5
+			dev->bulk_out_buffer = usb_buffer_alloc(udev, buffer_size, GFP_ATOMIC, &dev->dma_out);
+#else
+			dev->bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
+#endif
+			if (!dev->bulk_out_buffer) {
+				err("Couldn't allocate bulk_out_buffer");
+				goto error;
+			}
+#ifdef KERNEL_2_5
+			usb_fill_bulk_urb(dev->write_urb, udev, 
+				      usb_sndbulkpipe
+				      (udev, endpoint->bEndpointAddress),
+				      dev->bulk_out_buffer, buffer_size,
+				      mceusb_write_bulk_callback, dev);
+#else
+			FILL_BULK_URB(dev->write_urb, udev,
+				      usb_sndbulkpipe
+				      (udev, endpoint->bEndpointAddress),
+				      dev->bulk_out_buffer, buffer_size,
+				      mceusb_write_bulk_callback, dev);
+#endif 
+		}
+	}
+
+	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
+		err("Couldn't find both bulk-in and bulk-out endpoints");
+		goto error;
+	}
+
+	/* init the waitq */
+	init_waitqueue_head( &dev->wait_q );
+
+
+	/* Set up our lirc plugin */
+	if(!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+		err("out of memory");
+		goto error;
+	}
+	memset( plugin, 0, sizeof(struct lirc_plugin) );
+
+	if(!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+		err("out of memory");
+		kfree( plugin );
+		goto error;
+	}
+    
+	/* the lirc_atiusb module doesn't memset rbuf here ... ? */
+	if( lirc_buffer_init( rbuf, sizeof(lirc_t), 128)) {
+		err("out of memory");
+		kfree( plugin );
+		kfree( rbuf );
+		goto error;
+	}
+
+	strcpy(plugin->name, DRIVER_NAME " ");
+	plugin->minor       = minor;
+	plugin->code_length = sizeof(lirc_t) * 8;
+	plugin->features    = LIRC_CAN_REC_MODE2; // | LIRC_CAN_SEND_MODE2;
+	plugin->data        = dev;
+	plugin->rbuf        = rbuf;
+	plugin->ioctl       = NULL;
+	plugin->set_use_inc = &set_use_inc;
+	plugin->set_use_dec = &set_use_dec;
+	plugin->sample_rate = 80;   // sample at 100hz (10ms)
+	plugin->add_to_buf  = &mceusb_add_to_buf;
+	//    plugin->fops        = &mceusb_fops;
+#ifdef LIRC_HAVE_SYSFS
+	plugin->dev         = &udev->dev;
+#endif
+	plugin->owner       = THIS_MODULE;
+	if( lirc_register_plugin(plugin) < 0 )
+	{
+		kfree( plugin );
+		lirc_buffer_free( rbuf );
+		kfree( rbuf );
+		goto error;
+	}
+	dev->plugin = plugin;
+	
+	/* clear off the first few messages. these look like
+	 * calibration or test data, i can't really tell
+	 * this also flushes in case we have random ir data queued up
+	 */
+	{
+		char junk[64];
+		int partial = 0, retval, i;
+		for( i = 0; i < 40; i++ )
+		{
+			retval = usb_bulk_msg
+				(udev, usb_rcvbulkpipe
+				 (udev, dev->bulk_in_endpointAddr),
+				 junk, 64,
+				 &partial, HZ*10);
+		}
+	}
+    
+	msir_cleanup( dev );
+	mceusb_setup( udev );
+	
+#ifdef KERNEL_2_5
+	/* we can register the device now, as it is ready */
+	usb_set_intfdata (interface, dev);
+#endif	
+	/* let the user know what node this device is now attached to */
+	//info ("USB Microsoft IR Transceiver device now attached to msir%d", dev->minor);
+	up (&minor_table_mutex);
+#ifdef KERNEL_2_5
+	return 0;
+#else
+	return dev;
+#endif
+ error:
+	mceusb_delete (dev);
+	dev = NULL;
+	dprintk("%s: retval = %x", __func__, retval);
+	up (&minor_table_mutex);
+#ifdef KERNEL_2_5
+	return retval;
+#else
+	return NULL;
+#endif
+}
+
+/**
+ *	mceusb_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ *
+ *	This routine guarantees that the driver will not submit any more urbs
+ *	by clearing dev->udev.  It is also supposed to terminate any currently
+ *	active urbs.  Unfortunately, usb_bulk_msg(), used in skel_read(), does
+ *	not provide any way to do this.  But at least we can cancel an active
+ *	write.
+ */
+#ifdef KERNEL_2_5 
+static void mceusb_disconnect(struct usb_interface *interface)
+#else
+static void mceusb_disconnect(struct usb_device *udev, void *ptr)
+#endif
+{
+	struct usb_skel *dev;
+	int minor;
+#ifdef KERNEL_2_5
+	dev = usb_get_intfdata (interface);
+	usb_set_intfdata (interface, NULL);
+#else
+	dev = (struct usb_skel *)ptr;
+#endif
+	
+	down (&minor_table_mutex);
+	down (&dev->sem);
+	minor = dev->minor;
+
+	/* unhook lirc things */
+	lirc_unregister_plugin( minor );
+	lirc_buffer_free( dev->plugin->rbuf );
+	kfree( dev->plugin->rbuf );
+	kfree( dev->plugin );
+#ifdef KERNEL_2_5
+	/* terminate an ongoing write */
+	if (atomic_read (&dev->write_busy)) {
+		usb_kill_urb (dev->write_urb);
+		wait_for_completion (&dev->write_finished);
+	}
+
+	/* prevent device read, write and ioctl */
+	dev->present = 0;
+#endif
+	
+	mceusb_delete (dev);
+	
+	info("Microsoft IR Transceiver #%d now disconnected", minor);
+	up (&dev->sem);
+	up (&minor_table_mutex);
+}
+
+
+
+/**
+ *	usb_mceusb_init
+ */
+static int __init usb_mceusb_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&mceusb_driver);
+#ifdef KERNEL_2_5	
+	if ( result ) {
+#else
+	if ( result < 0 ) {
+#endif
+		err("usb_register failed for the " DRIVER_NAME " driver. error number %d",result);
+#ifdef KERNEL_2_5
+		return result;
+#else
+		return -1;
+#endif
+	}
+
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+}
+
+
+/**
+ *	usb_mceusb_exit
+ */
+static void __exit usb_mceusb_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&mceusb_driver);
+}
+
+ module_init (usb_mceusb_init);
+module_exit (usb_mceusb_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE (usb, mceusb_table);
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+EXPORT_NO_SYMBOLS;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_mceusb2.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_mceusb2.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_mceusb2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_mceusb2.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,968 @@
+/*
+ * LIRC driver for Philips eHome USB Infrared Transciever
+ * and the Microsoft MCE 2005 Remote Control
+ * 
+ * (C) by Martin A. Blatter <martin_a_blatter@yahoo.com>
+ *
+ * Transmitter support and reception code cleanup.
+ * (C) by Daniel Melander <lirc@rajidae.se>
+ *
+ * Derived from ATI USB driver by Paul Miller and the original
+ * MCE USB driver by Dan Corti
+ *
+ * This driver will only work reliably with kernel version 2.6.10
+ * or higher, probably because of differences in USB device enumeration
+ * in the kernel code. Device initialization fails most of the time
+ * with earlier kernel versions.
+ *
+ **********************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.6.5 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/autoconf.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#define DRIVER_VERSION          "$Revision: 1.29 $"
+#define DRIVER_AUTHOR           "Daniel Melander <lirc@rajidae.se>, Martin Blatter <martin_a_blatter@yahoo.com>"
+#define DRIVER_DESC             "Philips eHome USB IR Transciever and Microsoft MCE 2005 Remote Control driver for LIRC"
+#define DRIVER_NAME		"lirc_mceusb2"
+
+#define USB_BUFLEN              16             /* USB reception buffer length */
+#define LIRCBUF_SIZE            256            /* LIRC work buffer length */
+
+/* MCE constants */
+#define MCE_CMDBUF_SIZE         384            /* MCE Command buffer length */
+#define MCE_TIME_UNIT           50             /* Approx 50us resolution */
+#define MCE_CODE_LENGTH         5              /* Normal length of one mce packet (header included) */
+#define MCE_PACKET_SIZE         4              /* Normal length of one mce packet (header not included) */
+#define MCE_PACKET_HEADER       0x84           /* Actual header format is 0x80 + num_bytes */
+#define MCE_CONTROL_HEADER      0x9F           /* MCE status header */
+#define MCE_TX_HEADER_LENGTH    3              /* Number of bytes in the initializing tx header */
+#define MCE_MAX_CHANNELS        2              /* Two transmitters, hardware dependent? */
+#define MCE_DEFAULT_TX_MASK     0x03           /* Supported values are TX1=0x01, TX2=0x02, ALL=0x03 */
+#define MCE_PULSE_BIT           0x80           /* Pulse bit, MSB set == PULSE else SPACE */
+#define MCE_PULSE_MASK          0x7F           /* Pulse mask */
+#define MCE_MAX_PULSE_LENGTH    0x7F           /* Longest transmittable pulse symbol */
+
+
+/* module parameters */
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+/* lock irctl structure */
+//#define IRLOCK			down_interruptible(&ir->lock)
+#define IRLOCK			down(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* general constants */
+#define SUCCESS			0
+#define SEND_FLAG_IN_PROGRESS	1
+#define SEND_FLAG_COMPLETE	2
+#define RECV_FLAG_IN_PROGRESS	3
+#define RECV_FLAG_COMPLETE	4
+
+#define PHILUSB_INBOUND		1
+#define PHILUSB_OUTBOUND	2
+
+#define VENDOR_PHILIPS		0x0471
+#define VENDOR_SMK              0x0609
+#define VENDOR_TATUNG		0x1460
+#define VENDOR_GATEWAY		0x107b
+#define VENDOR_SHUTTLE		0x1308
+#define VENDOR_MITSUMI          0x03ee
+#define VENDOR_TOPSEED          0x1784 
+#define VENDOR_RICAVISION       0x179d
+#define VENDOR_ITRON            0x195d
+#define VENDOR_FIC              0x1509
+#define VENDOR_LG               0x043e
+#define VENDOR_MICROSOFT	0x045e
+
+static struct usb_device_id usb_remote_table [] = {
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },	/* Philips eHome Infrared Transciever */
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x060c) },	/* Philips Infrared Transciever - HP branded */
+	{ USB_DEVICE(VENDOR_SMK, 0x031d) },	/* SMK/Toshiba G83C0004D410 */
+	{ USB_DEVICE(VENDOR_SMK, 0x0322) },	/* SMK eHome Infrared Transceiver (Sony VAIO) */
+	{ USB_DEVICE(VENDOR_TATUNG, 0x9150) },  /* Tatung eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_SHUTTLE, 0xc001) },  /* Shuttle eHome Infrared Transceiver */
+        { USB_DEVICE(VENDOR_GATEWAY, 0x3009) },  /* Gateway eHome Infrared Transceiver */
+        { USB_DEVICE(VENDOR_MITSUMI, 0x2501) },  /* Mitsumi */
+	{ USB_DEVICE(VENDOR_TOPSEED, 0x0001) },  /* Topseed eHome Infrared Transceiver */ 
+	{ USB_DEVICE(VENDOR_RICAVISION, 0x0010) }, /* Ricavision internal Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_ITRON, 0x7002) },   /* Itron ione Libra Q-11 */
+	{ USB_DEVICE(VENDOR_FIC, 0x9242) },     /* FIC eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_LG, 0x9803) },      /* LG eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_MICROSOFT, 0x00a0) }, /* Microsoft MCE Infrared Transceiver */
+	{ }					/* Terminating entry */
+};
+
+/* data structure for each usb remote */
+struct irctl {
+
+	/* usb */
+	struct usb_device *usbdev;
+	struct urb *urb_in;
+	int devnum;
+        struct usb_endpoint_descriptor *usb_ep_in;
+        struct usb_endpoint_descriptor *usb_ep_out;
+
+	/* buffers and dma */
+	unsigned char *buf_in;
+	unsigned int len_in;
+	dma_addr_t dma_in;
+	dma_addr_t dma_out;
+
+	/* lirc */
+	struct lirc_plugin *p;
+	lirc_t lircdata;
+	unsigned char is_pulse;
+	int connected;
+	
+	unsigned char transmitter_mask;
+        unsigned int carrier_freq;
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait_out;
+   
+	struct semaphore lock;
+};
+
+/* init strings */
+static char init1[] = {0x00, 0xff, 0xaa, 0xff, 0x0b};
+static char init2[] = {0xff, 0x18};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+static inline unsigned long usecs_to_jiffies(const unsigned int u)
+{
+	if (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+#if HZ <= USEC_PER_SEC && !(USEC_PER_SEC % HZ)
+	return (u + (USEC_PER_SEC / HZ) - 1) / (USEC_PER_SEC / HZ);
+#elif HZ > USEC_PER_SEC && !(HZ % USEC_PER_SEC)
+	return u * (HZ / USEC_PER_SEC);
+#else
+	return (u * HZ + USEC_PER_SEC - 1) / USEC_PER_SEC;
+#endif
+}
+#endif
+
+
+static void usb_remote_printdata(struct irctl *ir, char *buf, int len)
+{
+	char codes[USB_BUFLEN*3 + 1];
+	int i;
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len && i < USB_BUFLEN; i++) {
+		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
+	}
+	printk(DRIVER_NAME "[%d]: data received %s (length=%d)\n",
+		ir->devnum, codes, len);
+}
+
+static void usb_async_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct irctl *ir;
+	int len;
+
+	if (!urb)
+		return;
+	
+	if ((ir = urb->context)) {
+		len = urb->actual_length;
+
+		dprintk(DRIVER_NAME "[%d]: callback called (status=%d len=%d)\n",ir->devnum,urb->status,len);
+
+		if (debug)
+			usb_remote_printdata(ir,urb->transfer_buffer,len);
+	}
+
+}
+
+
+/* request incoming or send outgoing usb packet - used to initialize remote */
+static void request_packet_async(struct irctl *ir, struct usb_endpoint_descriptor *ep, unsigned char* data, int size, int urb_type)
+{
+	int res;
+	struct urb *async_urb;
+	unsigned char *async_buf;
+
+	if (urb_type) {
+	    	if ((async_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+			/* alloc buffer */
+			if ((async_buf = kmalloc(size, GFP_KERNEL))) {
+				if (urb_type==PHILUSB_OUTBOUND) {
+					/* outbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_sndintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, (usb_complete_t) usb_async_callback, ir, ep->bInterval);
+
+					memcpy(async_buf, data, size);
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+				}
+				else {
+					/* inbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_rcvintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, (usb_complete_t) usb_async_callback, ir, ep->bInterval);
+
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+				}
+			}
+			else {
+				usb_free_urb(async_urb);
+				return;
+			}
+		}
+	}
+	else {
+		/* standard request */
+		async_urb=ir->urb_in;
+		ir->send_flags = RECV_FLAG_IN_PROGRESS;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request called (size=%#x)\n", ir->devnum, size);
+
+	async_urb->transfer_buffer_length = size;
+	async_urb->dev = ir->usbdev;
+
+	if ((res=usb_submit_urb(async_urb, GFP_ATOMIC))) {
+	    dprintk(DRIVER_NAME "[%d]: receive request FAILED! (res=%d)\n", ir->devnum, res);
+	    return;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request complete (res=%d)\n", ir->devnum, res);
+}
+
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+	int rtn;
+
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
+
+	if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+		printk(DRIVER_NAME "[%d]: error in lirc_unregister minor: %d\n"
+			"Trying again...\n", devnum, p->minor);
+		if (rtn == -EBUSY) {
+			printk(DRIVER_NAME
+				"[%d]: device is opened, will unregister"
+				" on close\n", devnum);
+			return -EAGAIN;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+			printk(DRIVER_NAME "[%d]: lirc_unregister failed\n",
+			devnum);
+		}
+	}
+
+	if (rtn != SUCCESS) {
+		printk(DRIVER_NAME "[%d]: didn't free resources\n", devnum);
+		return -EAGAIN;
+	}
+
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+
+	lirc_buffer_free(p->rbuf);
+	kfree(p->rbuf);
+	kfree(p);
+	kfree(ir);
+	return SUCCESS;
+}
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
+
+	MOD_INC_USE_COUNT;
+
+	if (!ir->connected) {
+		if (!ir->usbdev)
+			return -ENOENT;
+		ir->connected = 1;
+	}
+
+	return SUCCESS;
+}
+
+static void set_use_dec(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
+		return;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
+
+	if (ir->connected) {
+		IRLOCK;
+		ir->connected = 0;
+		IRUNLOCK;
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+static void send_packet_to_lirc(struct irctl *ir)
+{
+	if (ir->lircdata!=0)
+	{
+		lirc_buffer_write_1(ir->p->rbuf, (unsigned char*) &ir->lircdata);
+		wake_up(&ir->p->rbuf->wait_poll);
+		ir->lircdata=0;
+	}
+}
+
+static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
+{
+	struct irctl *ir;
+	int buf_len, packet_len;
+	int i, j;
+
+	if (!urb)
+		return;
+
+	if (!(ir = urb->context))
+	{
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
+	}
+
+	buf_len = urb->actual_length;
+	packet_len=0;
+	
+	if (debug)
+		usb_remote_printdata(ir,urb->transfer_buffer,buf_len);
+
+	if (ir->send_flags==RECV_FLAG_IN_PROGRESS)
+	{
+	  	ir->send_flags = SEND_FLAG_COMPLETE;
+		dprintk(DRIVER_NAME "[%d]: setup answer received %d bytes\n", ir->devnum, buf_len);
+	}
+
+	switch (urb->status)
+	{
+		/* success */
+	case SUCCESS:
+		for (i=0; i < buf_len; i++)
+		{
+			/* decode mce packets on the form (84),AA,BB,CC,DD */
+			switch(ir->buf_in[i])
+			{
+				/* data headers */
+			case 0x8F:
+			case 0x8E:
+			case 0x8D:
+			case 0x8C:
+			case 0x8B:
+			case 0x8A:
+			case 0x89:
+			case 0x88:
+			case 0x87:
+			case 0x86:
+			case 0x85:
+			case 0x84:
+			case 0x83:
+			case 0x82:
+			case 0x81:
+			case 0x80:
+				/* decode packet data */
+				packet_len=ir->buf_in[i] & MCE_PULSE_MASK;
+				for (j=1; j<=packet_len && (i+j < buf_len); j++)
+				{
+
+					/* rising/falling flank */
+					if (ir->is_pulse!=(ir->buf_in[i+j]&MCE_PULSE_BIT))
+					{
+						send_packet_to_lirc(ir);
+						ir->is_pulse=ir->buf_in[i+j]&MCE_PULSE_BIT;
+					}
+					
+					/* accumulate mce pulse/space values */
+					ir->lircdata += (ir->buf_in[i+j]&MCE_PULSE_MASK)*MCE_TIME_UNIT;
+					ir->lircdata |= (ir->is_pulse?PULSE_BIT:0);
+				}
+				
+				i+=packet_len;
+				break;
+	          
+				/* status header (0x9F) */
+			case MCE_CONTROL_HEADER:
+				/* A transmission containing one or 
+                                   more consecutive ir commands always
+                                   ends with a GAP of 100ms followed by the
+				   sequence 0x9F 0x01 0x01 0x9F 0x15
+				   0x00 0x00 0x80 */
+				
+                /* 
+                Uncomment this if the last 100ms
+                "infinity"-space should be transmitted
+                to lirc directly instead of at the beginning
+                of the next transmission. Changes pulse/space order.
+          
+				if (++i < buf_len && ir->buf_in[i]==0x01)
+					send_packet_to_lirc(ir);
+				
+                */ 
+                                                               
+				/* end decode loop */
+				i=buf_len;
+				break;
+			default:
+				break;
+			}
+		}
+	    
+		break;
+
+		/* unlink */
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
+
+	case -EPIPE:
+	default:
+		break;
+	}
+
+	/* resubmit urb */
+	usb_submit_urb(urb, GFP_ATOMIC);
+}
+
+
+static ssize_t lirc_write(struct file *file, const char *buf, size_t n, loff_t * ppos) {
+
+	int i, count=0, cmdcount=0;
+	struct irctl *ir=NULL;
+	lirc_t wbuf[LIRCBUF_SIZE];                  /* Workbuffer with values from lirc */
+	unsigned char cmdbuf[MCE_CMDBUF_SIZE];      /* MCE command buffer */
+	unsigned long signal_duration=0;            /* Singnal length in us */
+	struct timeval start_time, end_time;
+	
+	do_gettimeofday(&start_time);
+	
+	/* Retrieve lirc_plugin data for the device */
+	ir = lirc_get_pdata(file);
+	if (!ir && !ir->usb_ep_out) return -EFAULT;
+
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	count=n/sizeof(lirc_t);
+
+	/* Check if command is within limits */
+	if(count>LIRCBUF_SIZE || count%2==0) return(-EINVAL);
+	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+
+	/* MCE tx init header */
+	cmdbuf[cmdcount++]=MCE_CONTROL_HEADER;
+	cmdbuf[cmdcount++]=0x08;
+	cmdbuf[cmdcount++]=ir->transmitter_mask;
+
+	/* Generate mce packet data */
+	for(i=0;(i<count) && (cmdcount < MCE_CMDBUF_SIZE);i++)
+	{
+		signal_duration+=wbuf[i];
+		wbuf[i]=wbuf[i]/MCE_TIME_UNIT;
+
+		do { /* loop to support long pulses/spaces > 127*50us=6.35ms */
+
+			/* Insert mce packet header every 4th entry */
+			if ((cmdcount<MCE_CMDBUF_SIZE) &&
+			    (cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH==0)
+			{
+				cmdbuf[cmdcount++] = MCE_PACKET_HEADER;
+			}
+
+			/* Insert mce packet data */
+			if (cmdcount<MCE_CMDBUF_SIZE)
+			{
+				cmdbuf[cmdcount++] = (wbuf[i]<MCE_PULSE_BIT?wbuf[i]:MCE_MAX_PULSE_LENGTH) | (i & 1?0x00:MCE_PULSE_BIT);
+			}
+			else
+		       	{
+				return -EINVAL;
+			}
+		} while ((wbuf[i] > MCE_MAX_PULSE_LENGTH) &&
+			 (wbuf[i]-=MCE_MAX_PULSE_LENGTH));
+	}
+
+	/* Fix packet length in last header */
+	cmdbuf[cmdcount-(cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH] =
+		0x80+(cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH-1;
+
+	/* Check if we have room for the empty packet at the end */
+	if (cmdcount>=MCE_CMDBUF_SIZE) return -EINVAL;
+
+	/* All mce commands end with an empty packet (0x80) */
+	cmdbuf[cmdcount++]=0x80;
+
+	/* Transmit the command to the mce device */
+	request_packet_async(ir, ir->usb_ep_out, cmdbuf, cmdcount, PHILUSB_OUTBOUND);
+
+	/* The lircd gap calculation expects the write function to
+	   wait the time it takes for the ircommand to be sent before
+	   it returns. */
+	do_gettimeofday(&end_time);
+	signal_duration-=(end_time.tv_usec-start_time.tv_usec)+(end_time.tv_sec-start_time.tv_sec)*1000000;
+	
+	/* delay with the closest number of ticks */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout (usecs_to_jiffies(signal_duration));
+	
+	return n;
+}
+
+static void set_transmitter_mask(struct irctl *ir, unsigned int mask)
+{
+
+	/* SMK Transceiver does not use the inverted scheme, nor does Topseed*/
+	if ((ir->usbdev->descriptor.idVendor == VENDOR_SMK &&
+	     (ir->usbdev->descriptor.idProduct == 0x031d || ir->usbdev->descriptor.idProduct == 0x0322)) ||
+	    (ir->usbdev->descriptor.idVendor == VENDOR_TOPSEED && ir->usbdev->descriptor.idProduct == 0x0001))
+	{
+		ir->transmitter_mask = mask;
+	}
+	else
+	{
+		/* The mask begins at 0x02 and has an inverted
+		   numbering scheme */
+		ir->transmitter_mask = (mask!=0x03?mask ^ 0x03:mask) << 1;
+	}
+}
+
+
+/* Sets the send carrier frequency */
+static int set_send_carrier(struct irctl *ir, int carrier)
+{
+	int clk = 10000000;
+	int prescaler = 0, divisor = 0;
+	unsigned char cmdbuf[] = { 0x9F, 0x06, 0x01, 0x80 };
+
+	/* Carrier is changed */
+	if (ir->carrier_freq != carrier) {
+
+		if (carrier <= 0) {
+			ir->carrier_freq = carrier;
+			dprintk(DRIVER_NAME "[%d]: SET_CARRIER disabling "
+				"carrier modulation\n", ir->devnum);
+			request_packet_async(ir, ir->usb_ep_out,
+					     cmdbuf, sizeof(cmdbuf),
+					     PHILUSB_OUTBOUND);
+			return carrier;
+		}
+
+		for (prescaler = 0; prescaler < 4; ++prescaler) {
+			divisor = (clk >> (2 * prescaler)) / carrier;
+			if (divisor <= 0xFF) {
+				ir->carrier_freq = carrier;
+				cmdbuf[2] = prescaler;
+				cmdbuf[3] = divisor;
+				dprintk(DRIVER_NAME "[%d]: SET_CARRIER "
+					"requesting %d Hz\n",
+					ir->devnum, carrier);
+
+				/* Transmit the new carrier to the mce
+				   device */
+				request_packet_async(ir, ir->usb_ep_out,
+						     cmdbuf, sizeof(cmdbuf),
+						     PHILUSB_OUTBOUND);
+				return carrier;
+			}
+		}
+
+		return -EINVAL;
+
+	}
+
+	return carrier;
+}
+
+
+static int lirc_ioctl(struct inode *node, struct file *filep,
+	       	      unsigned int cmd, unsigned long arg)
+{
+	int result;
+	unsigned int ivalue;
+	unsigned long lvalue;
+	struct irctl *ir = NULL;
+
+	/* Retrieve lirc_plugin data for the device */
+	ir=lirc_get_pdata(filep);
+	if (!ir && !ir->usb_ep_out)
+		return -EFAULT;
+
+
+	switch(cmd)
+	{
+	case LIRC_SET_TRANSMITTER_MASK:
+
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+
+		switch(ivalue)
+		{
+		case 0x01: /* Transmitter 1     => 0x04 */
+		case 0x02: /* Transmitter 2     => 0x02 */
+		case 0x03: /* Transmitter 1 & 2 => 0x06 */
+			set_transmitter_mask(ir, ivalue);
+			break;
+
+		default: /* Unsupported transmitter mask */
+			return MCE_MAX_CHANNELS;
+		}
+
+		dprintk(DRIVER_NAME ": SET_TRANSMITTERS mask=%d\n", ivalue);
+		break;
+
+	case LIRC_GET_SEND_MODE:
+
+		result=put_user(LIRC_SEND2MODE (LIRC_CAN_SEND_PULSE&LIRC_CAN_SEND_MASK), (unsigned long *) arg);
+
+		if(result) return(result);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+
+		result=get_user(lvalue,(unsigned long *) arg);
+
+		if(result) return(result);
+		if(lvalue!=(LIRC_MODE_PULSE&LIRC_CAN_SEND_MASK)) return -EINVAL;
+		break;
+		
+	case LIRC_SET_SEND_CARRIER:
+
+		result = get_user(ivalue, (unsigned int *) arg);
+                if (result)
+			return (result);
+		
+                set_send_carrier(ir, ivalue);
+                break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+static struct file_operations lirc_fops =
+{
+	write:	lirc_write,
+};
+
+
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *idesc;
+	struct usb_endpoint_descriptor *ep=NULL, *ep_in=NULL, *ep_out=NULL;
+	struct usb_host_config *config;
+	struct irctl *ir = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int devnum, pipe, maxp;
+	int minor = 0;
+	int i;
+	char buf[63], name[128]="";
+	int mem_failure = 0;
+
+	dprintk(DRIVER_NAME ": usb probe called\n");
+
+	usb_reset_device(dev);
+
+	config=dev->actconfig;
+
+	idesc = intf->cur_altsetting;
+
+	/* step through the endpoints to find first bulk in and out endpoint */
+	for (i = 0; i < idesc->desc.bNumEndpoints; ++i) {
+		ep = &idesc->endpoint[i].desc;
+
+		if ((ep_in == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)
+			||  ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))) {
+
+			dprintk(DRIVER_NAME ": acceptable inbound endpoint found\n");
+			ep_in = ep;
+			ep_in->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_in->bInterval=1;
+		}
+
+		if ((ep_out == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)
+			||  ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))) {
+
+			dprintk(DRIVER_NAME ": acceptable outbound endpoint found\n");
+			ep_out = ep;
+			ep_out->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_out->bInterval=1;
+		}
+	}
+	if (ep_in == NULL) {
+		dprintk(DRIVER_NAME ": inbound and/or endpoint not found\n");
+		return -ENODEV;
+	}
+
+	devnum = dev->devnum;
+	pipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+		mem_failure = 1;
+	} else {
+		memset(ir, 0, sizeof(struct irctl));
+
+		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, sizeof(lirc_t), LIRCBUF_SIZE)) {
+			mem_failure = 4;
+		} else if (!(ir->buf_in = usb_buffer_alloc(dev, maxp, GFP_ATOMIC, &ir->dma_in))) {
+			mem_failure = 5;
+		} else if (!(ir->urb_in = usb_alloc_urb(0, GFP_KERNEL))) {
+			mem_failure = 7;
+		} else {
+
+			memset(plugin, 0, sizeof(struct lirc_plugin));
+
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->features = LIRC_CAN_SEND_PULSE |
+				LIRC_CAN_SET_TRANSMITTER_MASK |
+				LIRC_CAN_REC_MODE2 |
+				LIRC_CAN_SET_SEND_CARRIER;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+			plugin->code_length = sizeof(lirc_t) * 8;
+			plugin->ioctl = lirc_ioctl;
+			plugin->fops  = &lirc_fops;
+			plugin->dev   = &dev->dev;
+			plugin->owner = THIS_MODULE;
+
+			init_MUTEX(&ir->lock);
+			init_waitqueue_head(&ir->wait_out);
+
+			if ((minor = lirc_register_plugin(plugin)) < 0) {
+				mem_failure = 9;
+			}
+		}
+	}
+
+	/* free allocated memory incase of failure */
+	switch (mem_failure) {
+	case 9:
+		lirc_buffer_free(rbuf);
+	case 7:
+		usb_free_urb(ir->urb_in);
+	case 5:
+		usb_buffer_free(dev, maxp, ir->buf_in, ir->dma_in);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(ir);
+	case 1:
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+			devnum, mem_failure);
+		return -ENOMEM;
+	}
+
+	plugin->minor = minor;
+	ir->p = plugin;
+	ir->devnum = devnum;
+	ir->usbdev = dev;
+	ir->len_in = maxp;
+	ir->connected = 0;
+	
+        ir->lircdata=PULSE_MASK;
+        ir->is_pulse=0;
+	
+	/* ir->usbdev must be set */
+	set_transmitter_mask(ir, MCE_DEFAULT_TX_MASK);
+	/* Saving usb interface data for use by the transmitter routine */
+	ir->usb_ep_in=ep_in;
+	ir->usb_ep_out=ep_out;
+
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", devnum, name,
+	       dev->bus->busnum, devnum);
+
+	/* inbound data */
+	usb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in,
+		maxp, (usb_complete_t) usb_remote_recv, ir, ep_in->bInterval);
+
+	/* initialize device */
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init1, sizeof(init1), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init2, sizeof(init2), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, 0);
+
+	usb_set_intfdata(intf, ir);
+
+	return SUCCESS;
+}
+
+
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+
+	if (!ir || !ir->p)
+		return;
+
+	ir->usbdev = NULL;
+	wake_up_all(&ir->wait_out);
+
+	IRLOCK;
+	usb_kill_urb(ir->urb_in);
+	usb_free_urb(ir->urb_in);
+	usb_buffer_free(dev, ir->len_in, ir->buf_in, ir->dma_in);
+	IRUNLOCK;
+
+	unregister_from_lirc(ir);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int usb_remote_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct irctl *ir = usb_get_intfdata(intf);
+	printk(DRIVER_NAME "[%d]: suspend\n", ir->devnum);
+	usb_kill_urb(ir->urb_in);
+	return 0;
+}
+
+static int usb_remote_resume(struct usb_interface *intf)
+{
+	struct irctl *ir = usb_get_intfdata(intf);
+	printk(DRIVER_NAME "[%d]: resume\n", ir->devnum);
+	if (usb_submit_urb(ir->urb_in, GFP_ATOMIC))
+	{
+		return -EIO;
+	}
+	return 0;
+}
+#endif
+
+static struct usb_driver usb_remote_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	.suspend =	usb_remote_suspend,
+	.resume =	usb_remote_resume,
+#endif
+	.id_table =	usb_remote_table
+};
+
+static int __init usb_remote_init(void)
+{
+	int i;
+
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled\n");
+
+	request_module("lirc_dev");
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void __exit usb_remote_exit(void)
+{
+	usb_deregister(&usb_remote_driver);
+}
+
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, usb_remote_table);
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+EXPORT_NO_SYMBOLS;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_parallel.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_parallel.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_parallel.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_parallel.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,810 @@
+/*      $Id: lirc_parallel.c,v 5.37 2007/04/29 14:23:04 lirc Exp $      */
+
+/****************************************************************************
+ ** lirc_parallel.c *********************************************************
+ ****************************************************************************
+ * 
+ * lirc_parallel - device driver for infra-red signal receiving and
+ *                 transmitting unit built by the author
+ * 
+ * Copyright (C) 1998 Christoph Bartelmus <lirc@bartelmus.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */ 
+
+/***********************************************************************
+ *************************       Includes        ***********************
+ ***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+
+#include <linux/autoconf.h>
+
+#ifdef CONFIG_SMP
+#error "--- Sorry, this driver is not SMP safe. ---"
+#endif
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/autoconf.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/time.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/signal.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+#include <asm/div64.h>
+#endif
+
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/parport.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#include "lirc_parallel.h"
+
+#define LIRC_DRIVER_NAME "lirc_parallel"
+
+#ifndef LIRC_IRQ
+#define LIRC_IRQ 7
+#endif
+#ifndef LIRC_PORT
+#define LIRC_PORT 0x378
+#endif
+#ifndef LIRC_TIMER
+#define LIRC_TIMER 65536
+#endif
+
+/***********************************************************************
+ *************************   Globale Variablen   ***********************
+ ***********************************************************************/
+
+static int debug = 0;
+unsigned int irq = LIRC_IRQ;
+unsigned int io = LIRC_PORT;
+#ifdef LIRC_TIMER
+unsigned int timer = 0;
+unsigned int default_timer = LIRC_TIMER;
+#endif
+
+#define WBUF_SIZE (256)
+#define RBUF_SIZE (256) /* this must be a power of 2 larger than 1 */
+
+static lirc_t wbuf[WBUF_SIZE];
+static lirc_t rbuf[RBUF_SIZE];
+
+DECLARE_WAIT_QUEUE_HEAD(lirc_wait);
+
+unsigned int rptr=0,wptr=0;
+unsigned int lost_irqs=0;
+int is_open=0;
+
+struct parport *pport;
+struct pardevice *ppdevice;
+int is_claimed=0;
+
+unsigned int tx_mask = 1;
+
+/***********************************************************************
+ *************************   Interne Funktionen  ***********************
+ ***********************************************************************/
+
+static unsigned int __inline__ in(int offset)
+{
+	switch(offset)
+	{
+	case LIRC_LP_BASE:
+		return(parport_read_data(pport));
+	case LIRC_LP_STATUS:
+		return(parport_read_status(pport));
+	case LIRC_LP_CONTROL:
+		return(parport_read_control(pport));
+	}
+	return(0); /* make compiler happy */
+}
+
+static void __inline__ out(int offset, int value)
+{
+	switch(offset)
+	{
+	case LIRC_LP_BASE:
+		parport_write_data(pport,value);
+		break;
+	case LIRC_LP_CONTROL:
+		parport_write_control(pport,value);
+		break;
+	case LIRC_LP_STATUS:
+		printk(KERN_INFO "%s: attempt to write to status register\n",
+		       LIRC_DRIVER_NAME);
+		break;
+	}
+}
+
+static unsigned int __inline__ lirc_get_timer(void)
+{
+	return(in(LIRC_PORT_TIMER)&LIRC_PORT_TIMER_BIT);
+}
+
+static unsigned int __inline__  lirc_get_signal(void)
+{
+	return(in(LIRC_PORT_SIGNAL)&LIRC_PORT_SIGNAL_BIT);
+}
+
+static void __inline__ lirc_on(void)
+{
+	out(LIRC_PORT_DATA, tx_mask);
+}
+
+static void __inline__ lirc_off(void)
+{
+	out(LIRC_PORT_DATA,0);
+}
+
+static unsigned int init_lirc_timer(void)
+{
+	struct timeval tv,now;
+	unsigned int level,newlevel,timeelapsed,newtimer;
+	int count=0;
+	
+	do_gettimeofday(&tv);
+	tv.tv_sec++;                     /* wait max. 1 sec. */
+	level=lirc_get_timer();
+	do
+	{
+		newlevel=lirc_get_timer();
+		if(level==0 && newlevel!=0) count++;
+		level=newlevel;
+		do_gettimeofday(&now);
+	}
+	while(count<1000 && (now.tv_sec<tv.tv_sec 
+			     || (now.tv_sec==tv.tv_sec 
+				 && now.tv_usec<tv.tv_usec)));
+
+	timeelapsed=((now.tv_sec+1-tv.tv_sec)*1000000
+		     +(now.tv_usec-tv.tv_usec));
+	if(count>=1000 && timeelapsed>0)
+	{
+		if(default_timer==0)                    /* autodetect timer */
+		{
+			newtimer=(1000000*count)/timeelapsed;
+			printk(KERN_INFO "%s: %u Hz timer detected\n",
+			       LIRC_DRIVER_NAME,newtimer);
+			return(newtimer);
+		}
+		else
+		{
+			newtimer=(1000000*count)/timeelapsed;
+			if(abs(newtimer-default_timer)>
+			   default_timer/10) /* bad timer */
+			{
+				printk(KERN_NOTICE "%s: bad timer: %u Hz\n",
+				       LIRC_DRIVER_NAME,newtimer);
+				printk(KERN_NOTICE "%s: using default timer: "
+				       "%u Hz\n",
+				       LIRC_DRIVER_NAME,default_timer);
+				return(default_timer);
+			}
+			else
+			{
+				printk(KERN_INFO "%s: %u Hz timer detected\n",
+				       LIRC_DRIVER_NAME,newtimer);
+				return(newtimer); /* use detected value */
+			}
+		}
+	}
+	else
+	{
+		printk(KERN_NOTICE "%s: no timer detected\n",LIRC_DRIVER_NAME);
+		return(0);
+	}
+}
+
+static int lirc_claim(void)
+{
+	if(parport_claim(ppdevice)!=0)
+	{
+		printk(KERN_WARNING "%s: could not claim port\n",
+		       LIRC_DRIVER_NAME);
+		printk(KERN_WARNING "%s: waiting for port becoming available"
+		       "\n",LIRC_DRIVER_NAME);
+		if(parport_claim_or_block(ppdevice)<0)
+		{
+			printk(KERN_NOTICE "%s: could not claim port, giving"
+			       " up\n",LIRC_DRIVER_NAME);
+			return(0);
+		}
+	}
+	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
+	is_claimed=1;
+	return(1);
+}
+
+/***********************************************************************
+ *************************   interrupt handler  ************************
+ ***********************************************************************/
+
+static inline void rbuf_write(lirc_t signal)
+{
+	unsigned int nwptr;
+
+	nwptr=(wptr+1) & (RBUF_SIZE-1);
+	if(nwptr==rptr) /* no new signals will be accepted */
+	{
+		lost_irqs++;
+		printk(KERN_NOTICE "%s: buffer overrun\n",LIRC_DRIVER_NAME);
+		return;
+	}	
+	rbuf[wptr]=signal;
+	wptr=nwptr;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void irq_handler(int i,void *blah,struct pt_regs * regs)
+#else
+static void irq_handler(int i,void *blah)
+#endif
+{
+	struct timeval tv;
+	static struct timeval lasttv;
+	static int init=0;
+	long signal;
+	lirc_t data;
+	unsigned int level,newlevel;
+	unsigned int timeout;
+
+	if(!MOD_IN_USE)
+		return;
+
+	if(!is_claimed)
+	{
+		return;
+	}
+
+	/* disable interrupt */
+	/*
+	  disable_irq(irq);
+	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)&(~LP_PINTEN));
+	*/
+	if(in(1)&LP_PSELECD)
+	{
+		return;
+	}
+
+#ifdef LIRC_TIMER
+	if(init)
+	{
+		do_gettimeofday(&tv);
+		
+	        signal=tv.tv_sec-lasttv.tv_sec;
+		if(signal>15)
+		{
+			data=PULSE_MASK;  /* really long time */
+		}
+		else
+		{
+			data=(lirc_t) (signal*1000000+
+				       tv.tv_usec-lasttv.tv_usec+
+				       LIRC_SFH506_DELAY);
+		};
+
+		rbuf_write(data); /* space */
+	}
+	else
+	{
+		if(timer==0) /* wake up; we'll lose this signal 
+				but it will be garbage if the device 
+				is turned on anyway
+			      */
+		{
+			timer=init_lirc_timer();
+			/* enable_irq(irq); */
+			return;
+		}
+		init=1;
+	}
+
+	timeout=timer/10;           /* timeout after 1/10 sec. */
+	signal=1;
+	level=lirc_get_timer();
+	do{
+		newlevel=lirc_get_timer();
+		if(level==0 && newlevel!=0) signal++;
+		level=newlevel;
+
+		/* giving up */
+		if(signal>timeout || (in(1)&LP_PSELECD))
+		{
+			signal=0;
+			printk(KERN_NOTICE "%s: timeout\n",LIRC_DRIVER_NAME);
+			break;
+		}
+	}
+	while(lirc_get_signal());
+	if(signal!=0)
+	{
+		/* ajust value to usecs */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+		unsigned long long helper;
+		
+		helper = ((unsigned long long) signal)*1000000;
+		do_div(helper, timer);
+		signal = (long) helper;
+#else
+		signal=(long) ((((double) signal)*1000000)/timer);
+#endif
+
+		if(signal>LIRC_SFH506_DELAY)
+		{
+			data=signal-LIRC_SFH506_DELAY;
+		}
+		else
+		{
+			data=1;
+		}
+		rbuf_write(PULSE_BIT|data); /* pulse */
+	}
+	do_gettimeofday(&lasttv);
+#else
+	/* add your code here */
+#endif
+	
+	wake_up_interruptible(&lirc_wait);
+
+	/* enable interrupt */
+	/*
+	  enable_irq(irq);
+	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)|LP_PINTEN);
+	*/
+}
+
+/***********************************************************************
+ **************************   file_operations   ************************
+ ***********************************************************************/
+
+static loff_t lirc_lseek(struct file *filep,loff_t offset,int orig)
+{
+	return(-ESPIPE);
+}
+
+static ssize_t lirc_read(struct file *filep,char *buf,size_t n,loff_t *ppos)
+{
+	int result=0;
+	int count=0;
+	DECLARE_WAITQUEUE(wait, current);
+	
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	
+	add_wait_queue(&lirc_wait,&wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	while(count<n)
+	{
+		if(rptr!=wptr)
+		{
+			if(copy_to_user(buf+count,(char *) &rbuf[rptr],
+					sizeof(lirc_t)))
+			{
+				result = -EFAULT;
+				break;
+			}
+			rptr=(rptr+1)&(RBUF_SIZE-1);
+			count+=sizeof(lirc_t);
+		}
+		else
+		{
+			if(filep->f_flags & O_NONBLOCK)
+			{
+				result=-EAGAIN;
+				break;
+			}
+			if (signal_pending(current))
+			{
+				result=-ERESTARTSYS;
+				break;
+			}
+			schedule();
+			set_current_state(TASK_INTERRUPTIBLE);
+		}
+	}
+	remove_wait_queue(&lirc_wait,&wait);
+	set_current_state(TASK_RUNNING);
+	return(count ? count:result);
+}
+
+static ssize_t lirc_write(struct file *filep,const char *buf,size_t n,
+			  loff_t *ppos)
+{
+	int count;
+	unsigned int i;
+	unsigned int level,newlevel;
+	unsigned long flags;
+	lirc_t counttimer;
+	
+	if(!is_claimed)
+	{
+		return(-EBUSY);
+	}
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	
+	count=n/sizeof(lirc_t);
+	
+	if(count>WBUF_SIZE || count%2==0) return(-EINVAL);
+	
+	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+	
+#ifdef LIRC_TIMER
+	if(timer==0) /* try again if device is ready */
+	{
+		timer=init_lirc_timer();
+		if(timer==0) return(-EIO);
+	}
+
+	/* ajust values from usecs */
+	for(i=0;i<count;i++)
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+		unsigned long long helper;
+		
+		helper = ((unsigned long long) wbuf[i])*timer;
+		do_div(helper, 1000000);
+		wbuf[i] = (lirc_t) helper;
+#else
+		wbuf[i]=(lirc_t) (((double) wbuf[i])*timer/1000000);
+#endif
+	}
+	
+	local_irq_save(flags);
+	i=0;
+	while(i<count)
+	{
+		level=lirc_get_timer();
+		counttimer=0;
+		lirc_on();
+		do
+		{
+			newlevel=lirc_get_timer();
+			if(level==0 && newlevel!=0) counttimer++;
+			level=newlevel;
+			if(in(1)&LP_PSELECD)
+			{
+				lirc_off();
+				local_irq_restore(flags);
+				return(-EIO);
+			}
+		}
+		while(counttimer<wbuf[i]);i++;
+		
+		lirc_off();
+		if(i==count) break;
+		counttimer=0;
+		do
+		{
+			newlevel=lirc_get_timer();
+			if(level==0 && newlevel!=0) counttimer++;
+			level=newlevel;
+			if(in(1)&LP_PSELECD)
+			{
+				local_irq_restore(flags);
+				return(-EIO);
+			}
+		}
+		while(counttimer<wbuf[i]);i++;
+	}
+	local_irq_restore(flags);
+#else
+	/* 
+	   place code that handles write
+	   without extarnal timer here
+	*/
+#endif
+	return(n);
+}
+
+static unsigned int lirc_poll(struct file *file, poll_table * wait)
+{
+	poll_wait(file, &lirc_wait,wait);
+	if (rptr!=wptr)
+		return(POLLIN|POLLRDNORM);
+	return(0);
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		      unsigned long arg)
+{
+        int result;
+	unsigned long features=LIRC_CAN_SET_TRANSMITTER_MASK|LIRC_CAN_SEND_PULSE|LIRC_CAN_REC_MODE2,mode;
+	unsigned int ivalue;
+	
+	switch(cmd)
+	{
+	case LIRC_GET_FEATURES:
+		result=put_user(features,(unsigned long *) arg);
+		if(result) return(result); 
+		break;
+	case LIRC_GET_SEND_MODE:
+		result=put_user(LIRC_MODE_PULSE,(unsigned long *) arg);
+		if(result) return(result); 
+		break;
+	case LIRC_GET_REC_MODE:
+		result=put_user(LIRC_MODE_MODE2,(unsigned long *) arg);
+		if(result) return(result); 
+		break;
+	case LIRC_SET_SEND_MODE:
+		result=get_user(mode,(unsigned long *) arg);
+		if(result) return(result);
+		if(mode!=LIRC_MODE_PULSE) return(-EINVAL);
+		break;
+	case LIRC_SET_REC_MODE:
+		result=get_user(mode,(unsigned long *) arg);
+		if(result) return(result);
+		if(mode!=LIRC_MODE_MODE2) return(-ENOSYS);
+		break;
+	case LIRC_SET_TRANSMITTER_MASK:
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if((ivalue&LIRC_PARALLEL_TRANSMITTER_MASK) != ivalue) return (LIRC_PARALLEL_MAX_TRANSMITTERS);
+		tx_mask = ivalue;
+		break;
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+static int lirc_open(struct inode* node,struct file* filep)
+{
+	if(MOD_IN_USE)
+	{
+		return(-EBUSY);
+	}
+	if(!lirc_claim())
+	{
+		return(-EBUSY);
+	}
+	parport_enable_irq(pport);
+
+	/* init read ptr */
+	rptr=wptr=0;
+	lost_irqs=0;
+
+	MOD_INC_USE_COUNT;
+	is_open=1;
+	return(0);
+}
+
+static int lirc_close(struct inode* node,struct file* filep)
+{
+	if(is_claimed)
+	{
+		is_claimed=0;
+		parport_release(ppdevice);
+	}
+	is_open=0;
+	MOD_DEC_USE_COUNT;
+	return(0);
+}
+
+static struct file_operations lirc_fops = 
+{
+	llseek:  lirc_lseek,
+	read:    lirc_read,
+	write:   lirc_write,
+	poll:    lirc_poll,
+	ioctl:   lirc_ioctl,
+	open:    lirc_open,
+	release: lirc_close
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_INC_USE_COUNT;
+#endif
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_DEC_USE_COUNT;
+#endif
+}
+
+static struct lirc_plugin plugin = {
+       name:           LIRC_DRIVER_NAME,
+       minor:          -1,
+       code_length:    1,
+       sample_rate:    0,
+       data:           NULL,
+       add_to_buf:     NULL,
+       get_queue:      NULL,
+       set_use_inc:    set_use_inc,
+       set_use_dec:    set_use_dec,
+       fops:           &lirc_fops,
+       dev:            NULL,
+       owner:          THIS_MODULE,
+};
+
+#ifdef MODULE
+
+static int pf(void *handle);
+static void kf(void *handle);
+
+static struct timer_list poll_timer;
+static void poll_state(unsigned long ignored);
+
+static void poll_state(unsigned long ignored)
+{
+	printk(KERN_NOTICE "%s: time\n",
+	       LIRC_DRIVER_NAME);
+	del_timer(&poll_timer);
+	if(is_claimed)
+		return;
+	kf(NULL);
+	if(!is_claimed)
+	{
+		printk(KERN_NOTICE "%s: could not claim port, giving up\n",
+		       LIRC_DRIVER_NAME);
+		init_timer(&poll_timer);
+		poll_timer.expires=jiffies+HZ;
+		poll_timer.data=(unsigned long) current;
+		poll_timer.function=poll_state;
+		add_timer(&poll_timer);
+	}
+}
+
+static int pf(void *handle)
+{
+	parport_disable_irq(pport);
+	is_claimed=0;
+	return(0);
+}
+
+static void kf(void *handle)
+{
+	if(!is_open)
+		return;
+	if(!lirc_claim())
+		return;
+	parport_enable_irq(pport);
+	lirc_off();
+	/* this is a bit annoying when you actually print...*/
+	/*
+	printk(KERN_INFO "%s: reclaimed port\n",LIRC_DRIVER_NAME);
+	*/
+}
+
+/***********************************************************************
+ ******************   init_module()/cleanup_module()  ******************
+ ***********************************************************************/
+
+int init_module(void)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 3)
+	pport=parport_find_base(io);
+#else
+	pport=parport_enumerate();
+	while(pport!=NULL)
+	{
+		if(pport->base==io)
+		{
+			break;
+		}
+		pport=pport->next;
+	}
+#endif
+	if(pport==NULL)
+	{
+		printk(KERN_NOTICE "%s: no port at %x found\n",
+		       LIRC_DRIVER_NAME,io);
+		return(-ENXIO);
+	}
+	ppdevice=parport_register_device(pport,LIRC_DRIVER_NAME,
+					 pf,kf,irq_handler,0,NULL);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 3)
+	parport_put_port(pport);
+#endif
+	if(ppdevice==NULL)
+	{
+		printk(KERN_NOTICE "%s: parport_register_device() failed\n",
+		       LIRC_DRIVER_NAME);
+		return(-ENXIO);
+	}
+	if(parport_claim(ppdevice)!=0)
+		goto skip_init;
+	is_claimed=1;
+	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
+
+#ifdef LIRC_TIMER
+	if(debug) 
+	{
+		out(LIRC_PORT_DATA, tx_mask);
+	}
+	
+	timer=init_lirc_timer();
+
+#       if 0 	/* continue even if device is offline */
+	if(timer==0) 
+	{
+		is_claimed=0;
+		parport_release(pport);
+		parport_unregister_device(ppdevice);
+		return(-EIO);
+	}
+	
+#       endif
+	if(debug)
+	{
+		out(LIRC_PORT_DATA,0);
+	}
+#endif 
+
+	is_claimed=0;
+	parport_release(ppdevice);
+ skip_init:
+	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0)
+	{
+		printk(KERN_NOTICE "%s: register_chrdev() failed\n",LIRC_DRIVER_NAME);
+		parport_unregister_device(ppdevice);
+		return(-EIO);
+	}
+	printk(KERN_INFO "%s: installed using port 0x%04x irq %d\n",LIRC_DRIVER_NAME,io,irq);
+	return(0);
+}
+  
+void cleanup_module(void)
+{
+	parport_unregister_device(ppdevice);
+	lirc_unregister_plugin(plugin.minor);
+}
+
+MODULE_DESCRIPTION("Infrared receiver driver for parallel ports.");
+MODULE_AUTHOR("Christoph Bartelmus");
+MODULE_LICENSE("GPL");
+
+module_param(io, int, 0444);
+MODULE_PARM_DESC(io, "I/O address base (0x3bc, 0x378 or 0x278)");
+
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "Interrupt (7 or 5)");
+
+module_param(tx_mask, int, 0444);
+MODULE_PARM_DESC(tx_maxk, "Transmitter mask (default: 0x01)");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_parallel.h linux-2.6.23.1-stm/drivers/char/lirc/lirc_parallel.h
--- linux-2.6.23.1/drivers/char/lirc/lirc_parallel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_parallel.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,26 @@
+/*      $Id: lirc_parallel.h,v 5.2 2007/01/25 04:32:05 lirc Exp $      */
+
+#ifndef _LIRC_PARALLEL_H
+#define _LIRC_PARALLEL_H
+
+#include <linux/lp.h>
+
+#define LIRC_PORT_LEN 3
+
+#define LIRC_LP_BASE    0
+#define LIRC_LP_STATUS  1
+#define LIRC_LP_CONTROL 2
+
+#define LIRC_PORT_DATA           LIRC_LP_BASE    /* base */
+#define LIRC_PORT_TIMER        LIRC_LP_STATUS    /* status port */
+#define LIRC_PORT_TIMER_BIT          LP_PBUSY    /* busy signal */
+#define LIRC_PORT_SIGNAL       LIRC_LP_STATUS    /* status port */
+#define LIRC_PORT_SIGNAL_BIT          LP_PACK    /* ack signal */
+#define LIRC_PORT_IRQ         LIRC_LP_CONTROL    /* control port */
+
+#define LIRC_SFH506_DELAY 0             /* delay t_phl in usecs */
+
+#define LIRC_PARALLEL_MAX_TRANSMITTERS 8
+#define LIRC_PARALLEL_TRANSMITTER_MASK ((1<<LIRC_PARALLEL_MAX_TRANSMITTERS) - 1)
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_sasem.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_sasem.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_sasem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_sasem.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1075 @@
+/*      $Id: lirc_sasem.c,v 1.19 2007/04/29 14:23:04 lirc Exp $      */
+
+/* lirc_sasem.c - USB remote support for LIRC
+ * Version 0.5 
+ *
+ * Copyright (C) 2004-2005 Oliver Stabel <oliver.stabel@gmx.de>
+ *                         Tim Davies <tim@opensystems.net.au>
+ *
+ * This driver was derived from:
+ *   Venky Raju <dev@venky.ws>
+ *      "lirc_imon - "LIRC plugin/VFD driver for Ahanix/Soundgraph IMON IR/VFD"
+ *   Paul Miller <pmiller9@users.sourceforge.net>'s 2003-2004
+ *      "lirc_atiusb - USB remote support for LIRC"
+ *   Culver Consulting Services <henry@culcon.com>'s 2003
+ *      "Sasem OnAir VFD/IR USB driver"
+ *
+ *
+ * 2004/06/13   -   0.1
+ *                  initial version
+ *
+ * 2004/06/28   -   0.2
+ *                  added file system support to write data to VFD device (used  
+ *                  in conjunction with LCDProc)
+ *
+ * 2004/11/22   -   0.3
+ *                  Ported to 2.6 kernel - Tim Davies <tim@opensystems.net.au>
+ *
+ * 2005/03/29   -   0.4
+ *                  A few tidyups and keypress timings - Tim Davies <tim@opensystems.net.au>
+ *
+ * 2005/06/23   -   0.5
+ *                  A complete rewrite (shamelessly) based on lirc_imon.c
+ *                  Tim Davies <tim@opensystems.net.au>
+ *
+ * NOTE - The LCDproc iMon driver should work with this module.  More info at
+ *        http://www.frogstorm.info/sasem
+ */
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+#error "*** Sorry, this driver requires kernel version 2.4.22 or higher"
+#endif
+
+#include <linux/autoconf.h>
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+#include "kcompat.h"
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+
+#define MOD_AUTHOR	"Oliver Stabel <oliver.stabel@gmx.de>, Tim Davies <tim@opensystems.net.au>"
+#define MOD_DESC	"USB Driver for Sasem Remote Controller V1.1"
+#define MOD_NAME	"lirc_sasem"
+#define MOD_VERSION	"0.5"
+
+#define VFD_MINOR_BASE	144	/* Same as LCD */
+#define DEVFS_MODE	S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
+#define DEVFS_NAME	LIRC_DEVFS_PREFIX "lcd%d"
+
+#define BUF_CHUNK_SIZE	8
+#define BUF_SIZE	128
+
+#define SUCCESS		0
+#define	TRUE		1
+#define FALSE		0
+
+#define IOCTL_LCD_CONTRAST 1
+
+/* ------------------------------------------------------------
+ *                     P R O T O T Y P E S
+ * ------------------------------------------------------------
+ */
+
+/* USB Callback prototypes */
+#ifdef KERNEL_2_5
+static int sasem_probe (struct usb_interface *interface,
+			const struct usb_device_id *id);
+static void sasem_disconnect (struct usb_interface *interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_rx_callback (struct urb *urb, struct pt_regs *regs);
+static void usb_tx_callback (struct urb *urb, struct pt_regs *regs);
+#else
+static void usb_rx_callback (struct urb *urb);
+static void usb_tx_callback (struct urb *urb);
+#endif
+#else
+static void * sasem_probe (struct usb_device * dev, unsigned int intf,
+				const struct usb_device_id *id);
+static void sasem_disconnect (struct usb_device *dev, void *data);
+static void usb_rx_callback (struct urb *urb);
+static void usb_tx_callback (struct urb *urb);
+#endif
+
+/* VFD file_operations function prototypes */
+static int vfd_open (struct inode *inode, struct file *file);
+static int vfd_ioctl (struct inode *inode, struct file *file, 
+				unsigned cmd, unsigned long arg);
+static int vfd_close (struct inode *inode, struct file *file);
+static ssize_t vfd_write (struct file *file, const char *buf,
+				size_t n_bytes, loff_t *pos);
+
+/* LIRC plugin function prototypes */
+static int ir_open (void *data);
+static void ir_close (void *data);
+
+/* Driver init/exit prototypes */
+static int __init sasem_init (void);
+static void __exit sasem_exit (void);
+
+/* ------------------------------------------------------------
+ *                     G L O B A L S
+ * ------------------------------------------------------------
+ */
+
+struct sasem_context {
+
+	struct usb_device *dev;
+	int vfd_isopen;			/* VFD port has been opened       */
+	unsigned int vfd_contrast;	/* VFD contrast                   */
+#if !defined (KERNEL_2_5)
+	int subminor;			/* index into minor_table         */
+	devfs_handle_t devfs;
+#endif
+	int ir_isopen;			/* IR port has been opened        */
+	int dev_present;		/* USB device presence            */
+	struct semaphore sem;		/* to lock this object            */
+	wait_queue_head_t remove_ok;	/* For unexpected USB disconnects */
+
+	struct lirc_plugin *plugin;
+	struct usb_endpoint_descriptor *rx_endpoint;
+	struct usb_endpoint_descriptor *tx_endpoint;
+	struct urb *rx_urb;
+	struct urb *tx_urb;
+	unsigned char usb_rx_buf [8];
+	unsigned char usb_tx_buf [8];
+
+	struct tx_t {
+		unsigned char data_buf [32]; /* user data buffer          */
+		struct completion finished;  /* wait for write to finish  */
+		atomic_t busy;		     /* write in progress         */
+		int status;		     /* status of tx completion   */
+	} tx;
+
+	/* for dealing with repeat codes (wish there was a toggle bit!) */
+	struct timeval presstime;
+	char lastcode[8];
+	int codesaved;
+};
+
+#define LOCK_CONTEXT	down (&context ->sem)
+#define UNLOCK_CONTEXT	up (&context ->sem)
+
+/* VFD file operations */
+static struct file_operations vfd_fops = {
+
+	.owner		= THIS_MODULE,
+	.open		= &vfd_open,
+	.write		= &vfd_write,
+	.ioctl		= &vfd_ioctl,
+	.release	= &vfd_close
+};
+
+/* USB Device ID for Sasem USB Control Board */
+static struct usb_device_id sasem_usb_id_table [] = {
+	{ USB_DEVICE(0x11ba, 0x0101) },		/* Sasem       */
+	{}
+};
+
+/* USB Device data */
+static struct usb_driver sasem_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name 		= MOD_NAME,
+	.probe 		= sasem_probe,
+	.disconnect 	= sasem_disconnect,
+	.id_table 	= sasem_usb_id_table,
+#if !defined(KERNEL_2_5)
+	.fops		= &vfd_fops,
+	.minor		= VFD_MINOR_BASE,
+#endif
+};
+
+#ifdef KERNEL_2_5
+static struct usb_class_driver sasem_class = {
+	.name 		= DEVFS_NAME,
+	.fops		= &vfd_fops,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
+	.mode		= DEVFS_MODE,
+#endif
+	.minor_base	= VFD_MINOR_BASE,
+};
+#endif
+
+/* to prevent races between open() and disconnect() */
+static DECLARE_MUTEX (disconnect_sem);
+
+static int debug = 0;
+
+#if !defined(KERNEL_2_5)
+
+#define MAX_DEVICES	4	/* In case there's more than one Sasem device */
+static struct sasem_context * minor_table [MAX_DEVICES];
+
+/* the global usb devfs handle */
+extern devfs_handle_t usb_devfs_handle;
+
+#endif
+
+/* ------------------------------------------------------------
+ *                     M O D U L E   C O D E
+ * ------------------------------------------------------------
+ */
+
+MODULE_AUTHOR (MOD_AUTHOR);
+MODULE_DESCRIPTION (MOD_DESC);
+MODULE_LICENSE ("GPL");
+module_param (debug, int, 0);
+MODULE_PARM_DESC (debug, "Debug messages: 0=no, 1=yes (default: no)");
+
+static inline void delete_context (struct sasem_context *context) {
+
+	usb_free_urb (context ->tx_urb);  /* VFD */
+	usb_free_urb (context ->rx_urb);  /* IR */
+	lirc_buffer_free (context ->plugin ->rbuf);
+	kfree (context ->plugin ->rbuf);
+	kfree (context ->plugin);
+	kfree (context);
+
+	if (debug) info ("%s: context deleted", __FUNCTION__);
+}
+
+static inline void deregister_from_lirc (struct sasem_context *context) {
+
+	int retval;
+	int minor = context ->plugin ->minor;
+
+	if ((retval = lirc_unregister_plugin (minor))) {
+
+		err ("%s: unable to deregister from lirc (%d)", 
+			__FUNCTION__, retval);
+	}
+	else
+		info ("Deregistered Sasem plugin (minor:%d)", minor);
+
+}
+
+/**
+ * Called when the VFD device (e.g. /dev/usb/lcd)
+ * is opened by the application.
+ */
+static int vfd_open (struct inode *inode, struct file *file)
+{
+#ifdef KERNEL_2_5
+	struct usb_interface *interface;
+#endif
+	struct sasem_context *context = NULL;
+	int subminor;
+	int retval = SUCCESS;
+
+	/* prevent races with disconnect */
+	down (&disconnect_sem);
+	
+#ifdef KERNEL_2_5
+	subminor = iminor (inode);
+	interface = usb_find_interface (&sasem_driver, subminor);
+	if (!interface) {
+		err ("%s: could not find interface for minor %d", __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+	context = usb_get_intfdata (interface);
+#else
+	subminor = MINOR (inode ->i_rdev) - VFD_MINOR_BASE;
+	if (subminor < 0 || subminor >= MAX_DEVICES) {
+		err ("%s: no record of minor %d", __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+	context = minor_table [subminor];
+#endif
+
+	if (!context) {
+		err ("%s: no context found for minor %d", 
+					__FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	LOCK_CONTEXT;
+
+	if (context ->vfd_isopen) {
+		
+		err ("%s: VFD port is already open", __FUNCTION__);
+		retval = -EBUSY;
+	}
+	else {
+		MOD_INC_USE_COUNT;
+		context ->vfd_isopen = TRUE;
+		file ->private_data = context;
+		info ("VFD port opened");
+	}
+
+	UNLOCK_CONTEXT;
+
+exit:
+	up (&disconnect_sem);
+	return retval;
+}
+
+/**
+ * Called when the VFD device (e.g. /dev/usb/lcd)
+ * is closed by the application.
+ */
+static int vfd_ioctl (struct inode *inode, struct file *file, unsigned cmd, unsigned long arg)
+{
+	struct sasem_context *context = NULL;
+
+	context = (struct sasem_context *) file ->private_data;
+
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	switch (cmd) {
+		case IOCTL_LCD_CONTRAST:
+			if (arg > 1000) arg = 1000;
+			if (arg < 0) arg = 0;
+			context ->vfd_contrast = (unsigned int)arg;
+			break;  
+		default:
+			info ("Unknown IOCTL command");
+			UNLOCK_CONTEXT;
+			return -ENOIOCTLCMD;  /* not supported */
+	}
+
+	UNLOCK_CONTEXT;
+	return 0;
+}
+
+/**
+ * Called when the VFD device (e.g. /dev/usb/lcd)
+ * is closed by the application.
+ */
+static int vfd_close (struct inode *inode, struct file *file)
+{
+	struct sasem_context *context = NULL;
+	int retval = SUCCESS;
+
+	context = (struct sasem_context *) file ->private_data;
+
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->vfd_isopen) {
+		err ("%s: VFD is not open", __FUNCTION__);
+		retval = -EIO;
+	}
+	else {
+		context ->vfd_isopen = FALSE;
+		MOD_DEC_USE_COUNT;
+		info ("VFD port closed");
+		if (!context ->dev_present && !context ->ir_isopen) {
+
+			/* Device disconnected before close and IR port is not open.  */
+			/* If IR port is open, context will be deleted by ir_close.   */
+			UNLOCK_CONTEXT;
+			delete_context (context);
+			return retval;
+		}
+	}
+
+	UNLOCK_CONTEXT;
+	return retval;
+}
+
+/**
+ * Sends a packet to the VFD.
+ */
+static inline int send_packet (struct sasem_context *context)
+{
+	unsigned int pipe;
+	int interval = 0;
+	int retval = SUCCESS;
+
+	pipe = usb_sndintpipe (context ->dev,
+			context-> tx_endpoint ->bEndpointAddress);
+#ifdef KERNEL_2_5
+	interval = context ->tx_endpoint ->bInterval;
+#endif	/* Use 0 for 2.4 kernels */
+
+	usb_fill_int_urb (context ->tx_urb, context ->dev, pipe,
+		context ->usb_tx_buf, sizeof (context ->usb_tx_buf),
+		usb_tx_callback, context, interval);
+
+	context ->tx_urb ->actual_length = 0;
+
+	init_completion (&context ->tx.finished);
+	atomic_set (&(context ->tx.busy), 1);
+
+#ifdef KERNEL_2_5
+	retval =  usb_submit_urb (context ->tx_urb, GFP_KERNEL);
+#else
+	retval =  usb_submit_urb (context ->tx_urb);
+#endif
+	if (retval != SUCCESS) {
+		atomic_set (&(context ->tx.busy), 0);
+		err ("%s: error submitting urb (%d)", __FUNCTION__, retval);
+	}
+	else {
+		/* Wait for tranmission to complete (or abort) */
+		UNLOCK_CONTEXT;
+		wait_for_completion (&context ->tx.finished);
+		LOCK_CONTEXT;
+
+		retval = context ->tx.status;
+		if (retval != SUCCESS)
+			err ("%s: packet tx failed (%d)", __FUNCTION__, retval);
+	}
+
+	return retval;
+}
+
+/**
+ * Writes data to the VFD.  The Sasem VFD is 2x16 characters
+ * and requires data in 9 consecutive USB interrupt packets,
+ * each packet carrying 8 bytes.
+ */
+static ssize_t vfd_write (struct file *file, const char *buf,
+				size_t n_bytes, loff_t *pos)
+{
+	int i;
+	int retval = SUCCESS;
+	struct sasem_context *context;
+
+	context = (struct sasem_context *) file ->private_data;
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context ->dev_present) {
+		err ("%s: no Sasem device present", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	if (n_bytes <= 0 || n_bytes > 32) {
+		err ("%s: invalid payload size", __FUNCTION__);
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	copy_from_user (context ->tx.data_buf, buf, n_bytes);
+
+	/* Pad with spaces */
+	for (i=n_bytes; i < 32; ++i)
+		context ->tx.data_buf [i] = ' ';
+	
+	/* Nine 8 byte packets to be sent */
+	/* NOTE: "\x07\x01\0\0\0\0\0\0" or  "\x0c\0\0\0\0\0\0\0" will clear the VFD */
+	for (i = 0; i < 9; i++) {
+		switch (i) {
+			case 0: memcpy (context ->usb_tx_buf, "\x07\0\0\0\0\0\0\0", 8); 
+				context ->usb_tx_buf[1] = (context ->vfd_contrast)?(0x2B - (context ->vfd_contrast-1) / 250):0x2B;
+				break;
+			case 1: memcpy (context ->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8); break;
+			case 2: memcpy (context ->usb_tx_buf, "\x0b\x01\0\0\0\0\0\0", 8); break;
+			case 3: memcpy (context ->usb_tx_buf, context ->tx.data_buf, 8); break;
+			case 4: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 8, 8); break;
+			case 5: memcpy (context ->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8); break;
+			case 6: memcpy (context ->usb_tx_buf, "\x0b\x02\0\0\0\0\0\0", 8); break;
+			case 7: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 16, 8); break;
+			case 8: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 24, 8); break;
+		}
+		if ((retval = send_packet (context)) != SUCCESS) {
+
+			err ("%s: send packet failed for packet #%d", 
+					__FUNCTION__, i);
+			goto exit;
+		}
+	}
+exit:
+
+	UNLOCK_CONTEXT;
+
+	return (retval == SUCCESS) ? n_bytes : retval;
+}
+
+/**
+ * Callback function for USB core API: transmit data
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_tx_callback (struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_tx_callback (struct urb *urb)
+#endif
+{
+	struct sasem_context *context;
+
+	if (!urb || !(context = (struct sasem_context *) urb->context))
+		return;
+
+	context ->tx.status = urb ->status;
+
+	/* notify waiters that write has finished */
+	atomic_set (&context ->tx.busy, 0);
+	complete (&context ->tx.finished);
+
+	return;
+}
+
+/**
+ * Called by lirc_dev when the application opens /dev/lirc
+ */
+static int ir_open (void *data)
+{
+	int retval = SUCCESS;
+	struct sasem_context *context;
+
+	/* prevent races with disconnect */
+	down (&disconnect_sem);
+
+	context = (struct sasem_context *) data;
+
+	LOCK_CONTEXT;
+
+	if (context ->ir_isopen) {
+		err ("%s: IR port is already open", __FUNCTION__);
+		retval = -EBUSY;
+		goto exit;
+	}
+
+	usb_fill_int_urb (context ->rx_urb, context ->dev,
+		usb_rcvintpipe (context ->dev,
+				context ->rx_endpoint-> bEndpointAddress),
+		context ->usb_rx_buf, sizeof (context ->usb_rx_buf),
+		usb_rx_callback, context, context ->rx_endpoint ->bInterval);
+
+#ifdef KERNEL_2_5
+	retval = usb_submit_urb (context ->rx_urb, GFP_KERNEL);
+#else
+	retval = usb_submit_urb (context ->rx_urb);
+#endif
+
+	if (retval) {
+		err ("%s: usb_submit_urb failed for ir_open (%d)", __FUNCTION__, retval);
+	}
+	else {
+		MOD_INC_USE_COUNT;
+		context ->ir_isopen = TRUE;
+		info ("IR port opened");
+	}
+
+exit:
+	UNLOCK_CONTEXT;
+
+	up (&disconnect_sem);
+	return SUCCESS;
+}
+
+/**
+ * Called by lirc_dev when the application closes /dev/lirc
+ */
+static void ir_close (void *data)
+{
+	struct sasem_context *context;
+
+	context = (struct sasem_context *)data;
+	if (!context) {
+		err ("%s: no context for device", __FUNCTION__);
+		return;
+	}
+
+	LOCK_CONTEXT;
+
+	usb_kill_urb(context->rx_urb);
+	context ->ir_isopen = FALSE;
+	MOD_DEC_USE_COUNT;
+	info ("IR port closed");
+
+	if (!context ->dev_present) {
+
+		/* 
+		 * Device disconnected while IR port was 
+		 * still open. Plugin was not deregistered 
+		 * at disconnect time, so do it now.
+		 */
+		deregister_from_lirc (context);
+
+		if (!context ->vfd_isopen) {
+
+			UNLOCK_CONTEXT;
+			delete_context (context);
+			return;
+		}
+		/* If VFD port is open, context will be deleted by vfd_close */
+	}
+
+	UNLOCK_CONTEXT;
+	return;
+}
+
+/**
+ * Process the incoming packet
+ */
+static inline void incoming_packet (struct sasem_context *context, struct urb *urb)
+{
+	int len = urb ->actual_length;
+	unsigned char *buf = urb ->transfer_buffer;
+	long ms;
+	struct timeval tv;
+
+	if (len != 8) {
+		warn ("%s: invalid incoming packet size (%d)", __FUNCTION__, len);
+		return;
+	}
+
+#ifdef DEBUG	
+	int i;
+	for (i=0; i < 8; ++i)
+		printk ("%02x ", buf [i]);
+	printk ("\n");
+#endif
+
+	// Lirc could deal with the repeat code, but we really need to block it
+	// if it arrives too late.  Otherwise we could repeat the wrong code.
+
+	// get the time since the last button press
+	do_gettimeofday(&tv);
+	ms = (tv.tv_sec - context->presstime.tv_sec) * 1000 + (tv.tv_usec - context->presstime.tv_usec) / 1000;
+
+	if (memcmp(buf, "\x08\0\0\0\0\0\0\0", 8) == 0) {
+		// the repeat code is being sent, so we copy
+		// the old code to LIRC
+			
+		// NOTE: Only if the last code was less than 250ms ago
+		// - no one should be able to push another (undetected) button
+		//   in that time and then get a false repeat of the previous press
+		// - but it is long enough for a genuine repeat
+		if ((ms < 250) && (context->codesaved != 0)) {
+			memcpy(buf, &context->lastcode, 8);
+			context->presstime.tv_sec = tv.tv_sec; 
+			context->presstime.tv_usec = tv.tv_usec;
+		}
+		// there was no old code
+		else {
+			// Do Nothing!
+		}
+	}
+	else {
+		// save the current valid code for repeats
+		memcpy(&context->lastcode, buf, 8);
+		// set flag to signal a valid code was save;
+		// just for safety reasons
+		context->codesaved = 1;
+		context->presstime.tv_sec = tv.tv_sec; 
+		context->presstime.tv_usec = tv.tv_usec;
+	}
+
+	lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
+	wake_up (&context ->plugin ->rbuf ->wait_poll);
+}
+
+/**
+ * Callback function for USB core API: receive data
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_rx_callback (struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_rx_callback (struct urb *urb)
+#endif
+{
+	struct sasem_context *context;
+
+	if (!urb || !(context = (struct sasem_context *) urb->context))
+		return;
+
+	switch (urb ->status) {
+
+		case -ENOENT: 		/* usbcore unlink successful! */ 
+			return;
+
+		case SUCCESS:
+			if (context ->ir_isopen)
+				incoming_packet (context, urb);
+		       	break;
+
+		default	:
+			warn ("%s: status (%d): ignored",
+				 __FUNCTION__, urb ->status);
+			break;
+	}
+
+#ifdef KERNEL_2_5
+	usb_submit_urb (context ->rx_urb, GFP_ATOMIC);
+#endif
+	return;
+}
+
+
+
+/**
+ * Callback function for USB core API: Probe
+ */
+#ifdef KERNEL_2_5
+static int sasem_probe (struct usb_interface *interface,
+			const struct usb_device_id *id)
+#else
+static void * sasem_probe (struct usb_device * dev, unsigned int intf,
+			const struct usb_device_id *id)
+#endif
+{
+#ifdef KERNEL_2_5
+	struct usb_device *dev = NULL;
+	struct usb_host_interface *iface_desc = NULL;
+#else
+	struct usb_interface *interface = NULL;
+	struct usb_interface_descriptor *iface_desc = NULL;
+	char name [10];
+	int subminor = 0;
+#endif
+	struct usb_endpoint_descriptor *rx_endpoint = NULL;
+	struct usb_endpoint_descriptor *tx_endpoint = NULL;
+	struct urb *rx_urb = NULL;
+	struct urb *tx_urb = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int lirc_minor = 0;
+	int num_endpoints;
+	int retval = SUCCESS;
+	int vfd_ep_found;
+	int ir_ep_found;
+	int alloc_status;
+	struct sasem_context *context = NULL;
+	int i;
+
+	info ("%s: found Sasem device", __FUNCTION__);
+
+#if !defined(KERNEL_2_5)
+	for (subminor = 0; subminor < MAX_DEVICES; ++subminor) {
+		if (minor_table [subminor] == NULL)
+			break;
+	}
+	if (subminor == MAX_DEVICES) {
+	
+		err ("%s: allowed number of devices already present", __FUNCTION__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+#endif
+
+#ifdef KERNEL_2_5
+	dev = usb_get_dev (interface_to_usbdev (interface));
+	iface_desc = interface ->cur_altsetting;
+	num_endpoints = iface_desc ->desc.bNumEndpoints;
+#else
+	interface = &dev ->actconfig ->interface [intf];
+	iface_desc = &interface ->altsetting [interface ->act_altsetting];
+	num_endpoints = iface_desc ->bNumEndpoints;
+#endif
+
+	/*
+	 * Scan the endpoint list and set:
+	 * 	first input endpoint = IR endpoint
+	 * 	first output endpoint = VFD endpoint
+	 */
+
+	ir_ep_found = vfd_ep_found = FALSE;
+
+	for (i=0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
+
+		struct usb_endpoint_descriptor *ep;
+		int ep_dir;
+		int ep_type;
+#ifdef KERNEL_2_5
+		ep = &iface_desc ->endpoint [i].desc;
+#else
+		ep = &iface_desc ->endpoint [i];
+#endif
+		ep_dir = ep ->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
+		ep_type = ep ->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+		if (!ir_ep_found && 
+			ep_dir == USB_DIR_IN && 
+			ep_type == USB_ENDPOINT_XFER_INT) {
+
+			rx_endpoint = ep;
+			ir_ep_found = TRUE;
+			if (debug) 
+				info ("%s: found IR endpoint", __FUNCTION__);
+
+		}
+		else if (!vfd_ep_found &&
+			ep_dir == USB_DIR_OUT && 
+			ep_type == USB_ENDPOINT_XFER_INT) {
+
+			tx_endpoint = ep;
+			vfd_ep_found = TRUE;
+			if (debug) 
+				info ("%s: found VFD endpoint", __FUNCTION__);
+		}
+	}
+
+	/* Input endpoint is mandatory */
+	if (!ir_ep_found) {
+
+		err ("%s: no valid input (IR) endpoint found.", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	/* Warning if no VFD endpoint */
+	if (!vfd_ep_found) 
+		info ("%s: no valid output (VFD) endpoint found.", __FUNCTION__);
+
+
+	/* Allocate memory */
+	alloc_status = SUCCESS;
+
+	if (!(context = kmalloc (sizeof(struct sasem_context), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for context", __FUNCTION__);
+		alloc_status = 1;
+	}
+	else if (!(plugin = kmalloc (sizeof(struct lirc_plugin), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
+		alloc_status = 2;
+	}
+	else if (!(rbuf = kmalloc (sizeof(struct lirc_buffer), GFP_KERNEL))) {
+		err ("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
+		alloc_status = 3;
+	}
+	else if (lirc_buffer_init (rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
+		err ("%s: lirc_buffer_init failed", __FUNCTION__);
+		alloc_status = 4;
+	}
+#ifdef KERNEL_2_5
+	else if (!(rx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+#else
+	else if (!(rx_urb = usb_alloc_urb (0))) {
+#endif
+		err ("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
+		alloc_status = 5;
+	}
+#ifdef KERNEL_2_5
+	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+#else
+	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0))) {
+#endif
+		err ("%s: usb_alloc_urb failed for VFD urb", __FUNCTION__);
+		alloc_status = 6;
+	}
+	else {
+
+		/* clear all members of sasem_context and lirc_plugin */
+		memset (context, 0, sizeof (struct sasem_context));
+		init_MUTEX (&context ->sem);
+
+		memset (plugin, 0, sizeof (struct lirc_plugin));
+
+		strcpy (plugin ->name, MOD_NAME);
+		plugin ->minor = -1;
+		plugin ->code_length = 64;
+		plugin ->sample_rate = 0;
+		plugin ->features = LIRC_CAN_REC_LIRCCODE;
+		plugin ->data = context;
+		plugin ->rbuf = rbuf;
+		plugin ->set_use_inc = ir_open;
+		plugin ->set_use_dec = ir_close;
+#ifdef LIRC_HAVE_SYSFS
+		plugin->dev   = &dev->dev;
+#endif
+		plugin->owner = THIS_MODULE;
+
+		LOCK_CONTEXT;
+
+		if ((lirc_minor = lirc_register_plugin (plugin)) < 0) {
+			err ("%s: lirc_register_plugin failed", __FUNCTION__);
+			alloc_status = 7;
+			UNLOCK_CONTEXT;
+		}
+		else
+			info ("%s: Registered Sasem plugin (minor:%d)", 
+				__FUNCTION__, lirc_minor);
+	}
+
+	switch (alloc_status) {
+
+		case 7:		if (vfd_ep_found)
+					usb_free_urb (tx_urb);
+		case 6:		usb_free_urb (rx_urb);
+		case 5:		lirc_buffer_free (rbuf);
+		case 4:		kfree (rbuf);
+		case 3:		kfree (plugin);
+		case 2:		kfree (context);
+				context = NULL;
+		case 1:		retval = -ENOMEM;
+				goto exit;
+	}
+
+	// Needed while unregistering!
+	plugin ->minor = lirc_minor;
+
+	context ->dev = dev;
+	context ->dev_present = TRUE;
+	context ->rx_endpoint = rx_endpoint;
+	context ->rx_urb = rx_urb;
+	if (vfd_ep_found) {
+		context ->tx_endpoint = tx_endpoint;
+		context ->tx_urb = tx_urb;
+		context ->vfd_contrast = 1000;   /* range 0 - 1000 */
+	}
+	context ->plugin = plugin;
+
+#ifdef KERNEL_2_5
+	usb_set_intfdata (interface, context);
+#else
+	minor_table [subminor] = context;
+	context ->subminor = subminor;
+#endif
+
+	if (vfd_ep_found) {
+
+		if (debug) info ("Registering VFD with devfs");
+#ifdef KERNEL_2_5
+		if (usb_register_dev (interface, &sasem_class)) {
+
+			// Not a fatal error, so ignore
+			info ("%s: could not get a minor number for VFD", 
+				__FUNCTION__);
+		}
+#else
+		sprintf (name, DEVFS_NAME, subminor);
+		if (!(context ->devfs = devfs_register (usb_devfs_handle, name, 
+					DEVFS_FL_DEFAULT,
+					USB_MAJOR, VFD_MINOR_BASE + subminor,
+					DEVFS_MODE, &vfd_fops, NULL))) {
+
+			// not a fatal error so ignore
+			info ("%s: devfs register failed for VFD",
+					__FUNCTION__);
+		}
+#endif
+	}
+
+	info ("%s: Sasem device on usb<%d:%d> initialized",
+			__FUNCTION__, dev ->bus ->busnum, dev ->devnum);
+
+	UNLOCK_CONTEXT;
+exit:
+#ifdef KERNEL_2_5
+	return retval;
+#else
+	return (retval == SUCCESS) ? context : NULL;
+#endif
+}
+
+/**
+ * Callback function for USB core API: disonnect
+ */
+#ifdef KERNEL_2_5
+static void sasem_disconnect (struct usb_interface *interface)
+#else
+static void sasem_disconnect (struct usb_device *dev, void *data)
+#endif
+{
+	struct sasem_context *context;
+
+	/* prevent races with ir_open()/vfd_open() */
+	down (&disconnect_sem);
+
+#ifdef KERNEL_2_5
+	context = usb_get_intfdata (interface);
+#else
+	context = (struct sasem_context *)data;
+#endif
+	LOCK_CONTEXT;
+
+	info ("%s: Sasem device disconnected", __FUNCTION__);
+
+#ifdef KERNEL_2_5
+	usb_set_intfdata (interface, NULL);
+#else
+	minor_table [context ->subminor] = NULL;
+#endif
+	context ->dev_present = FALSE;
+
+	/* Stop reception */
+	usb_kill_urb(context->rx_urb);
+
+	/* Abort ongoing write */
+	if (atomic_read (&context ->tx.busy)) {
+
+		usb_kill_urb(context->tx_urb);
+		wait_for_completion (&context ->tx.finished);
+	}
+
+	/* De-register from lirc_dev if IR port is not open */
+	if (!context ->ir_isopen)
+		deregister_from_lirc (context);
+
+#ifdef KERNEL_2_5
+	usb_deregister_dev (interface, &sasem_class);
+#else
+	if (context ->devfs)
+		devfs_unregister (context ->devfs);
+#endif
+
+	UNLOCK_CONTEXT;
+
+	if (!context ->ir_isopen && !context ->vfd_isopen)
+		delete_context (context);
+	
+	up (&disconnect_sem);
+}
+
+static int __init sasem_init (void)
+{
+	int rc;
+
+	info (MOD_DESC ", v" MOD_VERSION);
+	info (MOD_AUTHOR);
+
+	if ((rc = usb_register (&sasem_driver)) < 0) {
+		err ("%s: usb register failed (%d)", __FUNCTION__, rc);
+		return -ENODEV;
+	}
+	return SUCCESS;
+}
+
+static void __exit sasem_exit (void)
+{
+	usb_deregister (&sasem_driver);
+	info ("module removed. Goodbye!");
+}
+
+
+module_init (sasem_init);
+module_exit (sasem_exit);
+
+#if !defined(KERNEL_2_5)
+EXPORT_NO_SYMBOLS;
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_serial.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_serial.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_serial.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1395 @@
+/*      $Id: lirc_serial.c,v 5.80 2007/05/11 16:40:24 lirc Exp $      */
+
+/****************************************************************************
+ ** lirc_serial.c ***********************************************************
+ ****************************************************************************
+ *
+ * lirc_serial - Device driver that records pulse- and pause-lengths
+ *               (space-lengths) between DDCD event on a serial port.
+ *
+ * Copyright (C) 1996,97 Ralph Metzler <rjkm@thp.uni-koeln.de>
+ * Copyright (C) 1998 Trent Piepho <xyzzy@u.washington.edu>
+ * Copyright (C) 1998 Ben Pfaff <blp@gnu.org>
+ * Copyright (C) 1999 Christoph Bartelmus <lirc@bartelmus.de>
+ * Copyright (C) 2007 Andrei Tanas <andrei@tanas.ca> (suspend/resume support)
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* Steve's changes to improve transmission fidelity:
+     - for systems with the rdtsc instruction and the clock counter, a 
+       send_pule that times the pulses directly using the counter.
+       This means that the LIRC_SERIAL_TRANSMITTER_LATENCY fudge is
+       not needed. Measurement shows very stable waveform, even where
+       PCI activity slows the access to the UART, which trips up other
+       versions.
+     - For other system, non-integer-microsecond pulse/space lengths,
+       done using fixed point binary. So, much more accurate carrier
+       frequency.
+     - fine tuned transmitter latency, taking advantage of fractional
+       microseconds in previous change
+     - Fixed bug in the way transmitter latency was accounted for by
+       tuning the pulse lengths down - the send_pulse routine ignored
+       this overhead as it timed the overall pulse length - so the
+       pulse frequency was right but overall pulse length was too
+       long. Fixed by accounting for latency on each pulse/space
+       iteration.
+
+   Steve Davies <steve@daviesfam.org>  July 2001
+*/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+ 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+
+#include <linux/autoconf.h>
+
+#if defined(CONFIG_SERIAL) || defined(CONFIG_SERIAL_8250)
+#warning "******************************************"
+#warning " Your serial port driver is compiled into "
+#warning " the kernel. You will have to release the "
+#warning " port you want to use for LIRC with:      "
+#warning "    setserial /dev/ttySx uart none        "
+#warning "******************************************"
+#endif
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/platform_device.h>
+#endif
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+
+#if defined(LIRC_SERIAL_NSLU2)
+#include <asm/hardware.h>
+/* From Intel IXP42X Developer's Manual (#252480-005): */
+/* ftp://download.intel.com/design/network/manuals/25248005.pdf */
+#define UART_IE_IXP42X_UUE   0x40 /* IXP42X UART Unit enable */
+#define UART_IE_IXP42X_RTOIE 0x10 /* IXP42X Receiver Data Timeout int.enable */
+#endif
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#if defined(LIRC_SERIAL_SOFTCARRIER) && !defined(LIRC_SERIAL_TRANSMITTER)
+#warning "Software carrier only affects transmitting"
+#endif
+
+#if defined(rdtsc)
+
+#define USE_RDTSC
+#warning "Note: using rdtsc instruction"
+#endif
+
+#ifdef LIRC_SERIAL_ANIMAX
+#ifdef LIRC_SERIAL_TRANSMITTER
+#warning "******************************************"
+#warning " This receiver does not have a            "
+#warning " transmitter diode                        "
+#warning "******************************************"
+#endif
+#endif
+
+#define LIRC_DRIVER_NAME "lirc_serial"
+
+struct lirc_serial
+{
+	int signal_pin;
+	int signal_pin_change;
+	int on;
+	int off;
+	long (*send_pulse)(unsigned long length);
+	void (*send_space)(long length);
+	int features;
+};
+
+#define LIRC_HOMEBREW        0
+#define LIRC_IRDEO           1
+#define LIRC_IRDEO_REMOTE    2
+#define LIRC_ANIMAX          3
+#define LIRC_IGOR            4
+#define LIRC_NSLU2           5
+
+#ifdef LIRC_SERIAL_IRDEO
+static int type=LIRC_IRDEO;
+#elif defined(LIRC_SERIAL_IRDEO_REMOTE)
+static int type=LIRC_IRDEO_REMOTE;
+#elif defined(LIRC_SERIAL_ANIMAX)
+static int type=LIRC_ANIMAX;
+#elif defined(LIRC_SERIAL_IGOR)
+static int type=LIRC_IGOR;
+#elif defined(LIRC_SERIAL_NSLU2)
+static int type=LIRC_NSLU2;
+#else
+static int type=LIRC_HOMEBREW;
+#endif
+
+/* Set defaults for NSLU2 */
+#if defined(LIRC_SERIAL_NSLU2)
+#ifndef LIRC_IRQ
+#define LIRC_IRQ IRQ_IXP4XX_UART2
+#endif
+#ifndef LIRC_PORT
+#define LIRC_PORT (IXP4XX_UART2_BASE_VIRT + REG_OFFSET)
+#endif
+#ifndef LIRC_IOMMAP
+#define LIRC_IOMMAP IXP4XX_UART2_BASE_PHYS
+#endif
+#ifndef LIRC_IOSHIFT
+#define LIRC_IOSHIFT 2
+#endif
+#ifndef LIRC_ALLOW_MMAPPED_IO
+#define LIRC_ALLOW_MMAPPED_IO
+#endif
+#endif
+
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+#ifndef LIRC_IOMMAP
+#define LIRC_IOMMAP 0
+#endif
+#ifndef LIRC_IOSHIFT
+#define LIRC_IOSHIFT 0
+#endif
+static int iommap = LIRC_IOMMAP;
+static int ioshift = LIRC_IOSHIFT;
+#endif
+
+#ifdef LIRC_SERIAL_SOFTCARRIER
+static int softcarrier=1;
+#else
+static int softcarrier=0;
+#endif
+
+static int share_irq = 0;
+static int debug = 0;
+
+#define dprintk(fmt, args...)                                   \
+	do{                                                     \
+		if(debug)                                       \
+	                printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
+                               fmt, ## args);                   \
+	}while(0)
+
+/* forward declarations */
+static long send_pulse_irdeo(unsigned long length);
+static long send_pulse_homebrew(unsigned long length);
+static void send_space_irdeo(long length);
+static void send_space_homebrew(long length);
+
+static struct lirc_serial hardware[]=
+{
+	/* home-brew receiver/transmitter */
+	{
+		UART_MSR_DCD,
+		UART_MSR_DDCD,
+		UART_MCR_RTS|UART_MCR_OUT2|UART_MCR_DTR,
+		UART_MCR_RTS|UART_MCR_OUT2,
+		send_pulse_homebrew,
+		send_space_homebrew,
+		(
+#ifdef LIRC_SERIAL_TRANSMITTER
+		 LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SET_SEND_CARRIER|
+		 LIRC_CAN_SEND_PULSE|
+#endif
+		 LIRC_CAN_REC_MODE2)
+	},
+	
+	/* IRdeo classic */
+	{
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_OUT2,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		send_pulse_irdeo,
+		send_space_irdeo,
+		(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SEND_PULSE|
+		 LIRC_CAN_REC_MODE2)
+	},
+	
+	/* IRdeo remote */
+	{
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		send_pulse_irdeo,
+		send_space_irdeo,
+		(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SEND_PULSE|
+		 LIRC_CAN_REC_MODE2)
+	},
+	
+	/* AnimaX */
+	{
+		UART_MSR_DCD,
+		UART_MSR_DDCD,
+		0,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		NULL,
+		NULL,
+		LIRC_CAN_REC_MODE2
+	},
+	
+	/* home-brew receiver/transmitter (Igor Cesko's variation) */
+	{
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_RTS|UART_MCR_OUT2|UART_MCR_DTR,
+		UART_MCR_RTS|UART_MCR_OUT2,
+		send_pulse_homebrew,
+		send_space_homebrew,
+		(
+#ifdef LIRC_SERIAL_TRANSMITTER
+		 LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SET_SEND_CARRIER|
+		 LIRC_CAN_SEND_PULSE|
+#endif
+		 LIRC_CAN_REC_MODE2)
+	},
+	
+#if defined(LIRC_SERIAL_NSLU2)
+	/* Modified Linksys Network Storage Link USB 2.0 (NSLU2):
+	   We receive on CTS of the 2nd serial port (R142,LHS), we
+	   transmit with a IR diode between GPIO[1] (green status LED),
+	   and ground (Matthias Goebl <matthias.goebl@goebl.net>).
+	   See also http://www.nslu2-linux.org for this device */
+	{
+		UART_MSR_CTS,
+		UART_MSR_DCTS,
+		UART_MCR_RTS|UART_MCR_OUT2|UART_MCR_DTR,
+		UART_MCR_RTS|UART_MCR_OUT2,
+		send_pulse_homebrew,
+		send_space_homebrew,
+		(
+#ifdef LIRC_SERIAL_TRANSMITTER
+		 LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SET_SEND_CARRIER|
+		 LIRC_CAN_SEND_PULSE|
+#endif
+		 LIRC_CAN_REC_MODE2)
+	},
+#endif
+	
+};
+
+#define RS_ISR_PASS_LIMIT 256
+
+/* A long pulse code from a remote might take upto 300 bytes.  The
+   daemon should read the bytes as soon as they are generated, so take
+   the number of keys you think you can push before the daemon runs
+   and multiply by 300.  The driver will warn you if you overrun this
+   buffer.  If you have a slow computer or non-busmastering IDE disks,
+   maybe you will need to increase this.  */
+
+/* This MUST be a power of two!  It has to be larger than 1 as well. */
+
+#define RBUF_LEN 256
+#define WBUF_LEN 256
+
+static int sense = -1;   /* -1 = auto, 0 = active high, 1 = active low */
+static int txsense = 0;   /* 0 = active high, 1 = active low */
+
+#ifndef LIRC_IRQ
+#define LIRC_IRQ 4
+#endif
+#ifndef LIRC_PORT
+#define LIRC_PORT 0x3f8
+#endif
+
+static int io = LIRC_PORT;
+static int irq = LIRC_IRQ;
+
+static struct timeval lasttv = {0, 0};
+
+static struct lirc_buffer rbuf;
+
+static lirc_t wbuf[WBUF_LEN];
+
+static unsigned int freq = 38000;
+static unsigned int duty_cycle = 50;
+
+/* Initialized in init_timing_params() */
+static unsigned long period = 0;
+static unsigned long pulse_width = 0;
+static unsigned long space_width = 0;
+
+#if defined(__i386__)
+/*
+  From:
+  Linux I/O port programming mini-HOWTO
+  Author: Riku Saikkonen <Riku.Saikkonen@hut.fi>
+  v, 28 December 1997
+  
+  [...]
+  Actually, a port I/O instruction on most ports in the 0-0x3ff range
+  takes almost exactly 1 microsecond, so if you're, for example, using
+  the parallel port directly, just do additional inb()s from that port
+  to delay.
+  [...]
+*/
+/* transmitter latency 1.5625us 0x1.90 - this figure arrived at from
+ * comment above plus trimming to match actual measured frequency.
+ * This will be sensitive to cpu speed, though hopefully most of the 1.5us
+ * is spent in the uart access.  Still - for reference test machine was a
+ * 1.13GHz Athlon system - Steve
+ */
+
+/* changed from 400 to 450 as this works better on slower machines;
+   faster machines will use the rdtsc code anyway */
+
+#define LIRC_SERIAL_TRANSMITTER_LATENCY 450
+
+#else
+
+/* does anybody have information on other platforms ? */
+/* 256 = 1<<8 */
+#define LIRC_SERIAL_TRANSMITTER_LATENCY 256
+
+#endif  /* __i386__ */
+
+static inline unsigned int sinp(int offset)
+{
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+	if(iommap != 0) /* the register is memory-mapped */
+	{
+		offset <<= ioshift;
+		return readb(io + offset);
+	} 
+#endif
+	return inb(io + offset);
+}
+
+static inline void soutp(int offset, int value)
+{
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+	if(iommap != 0) /* the register is memory-mapped */
+	{
+		offset <<= ioshift;
+		writeb(value, io + offset);
+	}
+#endif
+	outb(value, io + offset);
+}
+
+static inline void on(void)
+{
+#if defined(LIRC_SERIAL_NSLU2)
+	/* On NSLU2, we put the transmit diode between the output of the green
+	   status LED and ground */
+	if(type == LIRC_NSLU2)
+	{
+		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_LOW);
+		return;
+	}
+#endif
+	if (txsense)
+	{
+		soutp(UART_MCR,hardware[type].off);
+	}
+	else
+	{
+		soutp(UART_MCR,hardware[type].on);
+	}
+}
+  
+static inline void off(void)
+{
+#if defined(LIRC_SERIAL_NSLU2)
+	if(type == LIRC_NSLU2)
+	{
+		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_HIGH);
+		return;
+	}
+#endif
+	if (txsense)
+	{
+		soutp(UART_MCR,hardware[type].on);
+	}
+	else
+	{
+		soutp(UART_MCR,hardware[type].off);
+	}
+}
+
+#ifndef MAX_UDELAY_MS
+#define MAX_UDELAY_US 5000
+#else
+#define MAX_UDELAY_US (MAX_UDELAY_MS*1000)
+#endif
+
+static inline void safe_udelay(unsigned long usecs)
+{
+	while(usecs>MAX_UDELAY_US)
+	{
+		udelay(MAX_UDELAY_US);
+		usecs-=MAX_UDELAY_US;
+	}
+	udelay(usecs);
+}
+
+#ifdef USE_RDTSC
+/* This is an overflow/precision juggle, complicated in that we can't
+   do long long divide in the kernel */
+
+/* When we use the rdtsc instruction to measure clocks, we keep the
+ * pulse and space widths as clock cycles.  As this is CPU speed
+ * dependent, the widths must be calculated in init_port and ioctl
+ * time
+ */
+
+/* So send_pulse can quickly convert microseconds to clocks */
+static unsigned long conv_us_to_clocks = 0;
+
+static inline int init_timing_params(unsigned int new_duty_cycle,
+		unsigned int new_freq)
+{
+	unsigned long long loops_per_sec,work;
+	
+	duty_cycle=new_duty_cycle;
+	freq=new_freq;
+
+	loops_per_sec=current_cpu_data.loops_per_jiffy;
+	loops_per_sec*=HZ;
+	
+	/* How many clocks in a microsecond?, avoiding long long divide */
+	work=loops_per_sec;
+	work*=4295;  /* 4295 = 2^32 / 1e6 */
+	conv_us_to_clocks=(work>>32);
+	
+	/* Carrier period in clocks, approach good up to 32GHz clock,
+           gets carrier frequency within 8Hz */
+	period=loops_per_sec>>3;
+	period/=(freq>>3);
+
+	/* Derive pulse and space from the period */
+
+	pulse_width = period*duty_cycle/100;
+	space_width = period - pulse_width;
+	dprintk("in init_timing_params, freq=%d, duty_cycle=%d, "
+		"clk/jiffy=%ld, pulse=%ld, space=%ld, "
+		"conv_us_to_clocks=%ld\n",
+		freq, duty_cycle, current_cpu_data.loops_per_jiffy,
+		pulse_width, space_width, conv_us_to_clocks);
+	return 0;
+}
+#else /* ! USE_RDTSC */
+static inline int init_timing_params(unsigned int new_duty_cycle,
+		unsigned int new_freq)
+{
+/* period, pulse/space width are kept with 8 binary places -
+ * IE multiplied by 256. */
+	if(256*1000000L/new_freq*new_duty_cycle/100<=
+	   LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
+	if(256*1000000L/new_freq*(100-new_duty_cycle)/100<=
+	   LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
+	duty_cycle=new_duty_cycle;
+	freq=new_freq;
+	period=256*1000000L/freq;
+	pulse_width=period*duty_cycle/100;
+	space_width=period-pulse_width;
+	dprintk("in init_timing_params, freq=%d pulse=%ld, "
+		"space=%ld\n", freq, pulse_width, space_width);
+	return 0;
+}
+#endif /* USE_RDTSC */
+
+
+/* return value: space length delta */
+
+static long send_pulse_irdeo(unsigned long length)
+{
+	long rawbits;
+	int i;
+	unsigned char output;
+	unsigned char chunk,shifted;
+	
+	/* how many bits have to be sent ? */
+	rawbits=length*1152/10000;
+	if(duty_cycle>50) chunk=3;
+	else chunk=1;
+	for(i=0,output=0x7f;rawbits>0;rawbits-=3)
+	{
+		shifted=chunk<<(i*3);
+		shifted>>=1;
+		output&=(~shifted);
+		i++;
+		if(i==3)
+		{
+			soutp(UART_TX,output);
+			while(!(sinp(UART_LSR) & UART_LSR_THRE));
+			output=0x7f;
+			i=0;
+		}
+	}
+	if(i!=0)
+	{
+		soutp(UART_TX,output);
+		while(!(sinp(UART_LSR) & UART_LSR_TEMT));
+	}
+
+	if(i==0)
+	{
+		return((-rawbits)*10000/1152);
+	}
+	else
+	{
+		return((3-i)*3*10000/1152+(-rawbits)*10000/1152);
+	}
+}
+
+#ifdef USE_RDTSC
+/* Version that uses Pentium rdtsc instruction to measure clocks */
+
+/* This version does sub-microsecond timing using rdtsc instruction,
+ * and does away with the fudged LIRC_SERIAL_TRANSMITTER_LATENCY
+ * Implicitly i586 architecture...  - Steve
+ */
+
+static inline long send_pulse_homebrew_softcarrier(unsigned long length)
+{
+	int flag;
+	unsigned long target, start, now;
+
+	/* Get going quick as we can */
+	rdtscl(start);on();
+	/* Convert length from microseconds to clocks */
+	length*=conv_us_to_clocks;
+	/* And loop till time is up - flipping at right intervals */
+	now=start;
+	target=pulse_width;
+	flag=1;
+	while((now-start)<length)
+	{
+		/* Delay till flip time */
+		do
+		{
+			rdtscl(now);
+		}
+		while ((now-start)<target);
+		/* flip */
+		if(flag)
+		{
+			rdtscl(now);off();
+			target+=space_width;
+		}
+		else
+		{
+			rdtscl(now);on();
+			target+=pulse_width;
+		}
+		flag=!flag;
+	}
+	rdtscl(now);
+	return(((now-start)-length)/conv_us_to_clocks);
+}
+#else /* ! USE_RDTSC */
+/* Version using udelay() */
+
+/* here we use fixed point arithmetic, with 8
+   fractional bits.  that gets us within 0.1% or so of the right average
+   frequency, albeit with some jitter in pulse length - Steve */
+
+/* To match 8 fractional bits used for pulse/space length */
+
+static inline long send_pulse_homebrew_softcarrier(unsigned long length)
+{
+	int flag;
+	unsigned long actual, target, d;
+	length<<=8;
+
+	actual=target=0; flag=0;
+	while(actual<length)
+	{
+		if(flag)
+		{
+			off();
+			target+=space_width;
+		}
+		else
+		{
+			on();
+			target+=pulse_width;
+		}
+		d=(target-actual-LIRC_SERIAL_TRANSMITTER_LATENCY+128)>>8;
+		/* Note - we've checked in ioctl that the pulse/space
+		   widths are big enough so that d is > 0 */
+		udelay(d);
+		actual+=(d<<8)+LIRC_SERIAL_TRANSMITTER_LATENCY;
+		flag=!flag;
+	}
+	return((actual-length)>>8);
+}
+#endif /* USE_RDTSC */
+
+static long send_pulse_homebrew(unsigned long length)
+{
+	if(length<=0) return 0;
+	if(softcarrier)
+	{
+		return send_pulse_homebrew_softcarrier(length);
+	}
+	else
+	{
+		on();
+		safe_udelay(length);
+		return(0);
+	}
+}
+
+static void send_space_irdeo(long length)
+{
+	if(length<=0) return;
+	safe_udelay(length);
+}
+
+static void send_space_homebrew(long length)
+{
+        off();
+	if(length<=0) return;
+	safe_udelay(length);
+}
+
+static void inline rbwrite(lirc_t l)
+{
+	if(lirc_buffer_full(&rbuf))    /* no new signals will be accepted */
+	{
+		dprintk("Buffer overrun\n");
+		return;
+	}
+	_lirc_buffer_write_1(&rbuf, (void *)&l);
+}
+
+static void inline frbwrite(lirc_t l)
+{
+	/* simple noise filter */
+	static lirc_t pulse=0L,space=0L;
+	static unsigned int ptr=0;
+	
+	if(ptr>0 && (l&PULSE_BIT))
+	{
+		pulse+=l&PULSE_MASK;
+		if(pulse>250)
+		{
+			rbwrite(space);
+			rbwrite(pulse|PULSE_BIT);
+			ptr=0;
+			pulse=0;
+		}
+		return;
+	}
+	if(!(l&PULSE_BIT))
+	{
+		if(ptr==0)
+		{
+			if(l>20000)
+			{
+				space=l;
+				ptr++;
+				return;
+			}
+		}
+		else
+		{
+			if(l>20000)
+			{
+				space+=pulse;
+				if(space>PULSE_MASK) space=PULSE_MASK;
+				space+=l;
+				if(space>PULSE_MASK) space=PULSE_MASK;
+				pulse=0;
+				return;
+			}
+			rbwrite(space);
+			rbwrite(pulse|PULSE_BIT);
+			ptr=0;
+			pulse=0;
+		}
+	}
+	rbwrite(l);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+static irqreturn_t irq_handler(int i, void *blah)
+#else
+static irqreturn_t irq_handler(int i, void *blah, struct pt_regs *regs)
+#endif
+{
+	struct timeval tv;
+	int status,counter,dcd;
+	long deltv;
+	lirc_t data;
+	
+	if((sinp(UART_IIR) & UART_IIR_NO_INT))
+	{
+		/* not our interrupt */
+		return IRQ_RETVAL(IRQ_NONE);
+	}
+	
+	counter=0;
+	do{
+		counter++;
+		status=sinp(UART_MSR);
+		if(counter>RS_ISR_PASS_LIMIT)
+		{
+			printk(KERN_WARNING LIRC_DRIVER_NAME ": AIEEEE: "
+			       "We're caught!\n");
+			break;
+		}
+		if((status&hardware[type].signal_pin_change) && sense!=-1)
+		{
+			/* get current time */
+			do_gettimeofday(&tv);
+			
+			/* New mode, written by Trent Piepho 
+			   <xyzzy@u.washington.edu>. */
+			
+			/* The old format was not very portable.
+			   We now use the type lirc_t to pass pulses
+			   and spaces to user space.
+			   
+			   If PULSE_BIT is set a pulse has been
+			   received, otherwise a space has been
+			   received.  The driver needs to know if your
+			   receiver is active high or active low, or
+			   the space/pulse sense could be
+			   inverted. The bits denoted by PULSE_MASK are
+			   the length in microseconds. Lengths greater
+			   than or equal to 16 seconds are clamped to
+			   PULSE_MASK.  All other bits are unused.
+			   This is a much simpler interface for user
+			   programs, as well as eliminating "out of
+			   phase" errors with space/pulse
+			   autodetection. */
+
+			/* calculate time since last interrupt in
+			   microseconds */
+			dcd=(status & hardware[type].signal_pin) ? 1:0;
+			
+			deltv=tv.tv_sec-lasttv.tv_sec;
+			if(tv.tv_sec<lasttv.tv_sec ||
+			   (tv.tv_sec==lasttv.tv_sec &&
+			    tv.tv_usec<lasttv.tv_usec))
+			{
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				       ": AIEEEE: your clock just jumped "
+				       "backwards\n");
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				       ": %d %d %lx %lx %lx %lx\n",
+				       dcd,sense,
+				       tv.tv_sec,lasttv.tv_sec,
+				       tv.tv_usec,lasttv.tv_usec);
+				data=PULSE_MASK;
+			}
+			else if(deltv>15) 
+			{
+				data=PULSE_MASK; /* really long time */
+				if(!(dcd^sense)) /* sanity check */
+				{
+					printk(KERN_WARNING LIRC_DRIVER_NAME
+					       "AIEEEE: %d %d %lx %lx %lx %lx\n",
+					       dcd,sense,
+					       tv.tv_sec,lasttv.tv_sec,
+					       tv.tv_usec,lasttv.tv_usec);
+				        /* detecting pulse while this
+					   MUST be a space! */
+				        sense=sense ? 0:1;
+				}
+			}
+			else
+			{
+				data=(lirc_t) (deltv*1000000+
+					       tv.tv_usec-
+					       lasttv.tv_usec);
+			}
+			frbwrite(dcd^sense ? data : (data|PULSE_BIT));
+			lasttv=tv;
+			wake_up_interruptible(&rbuf.wait_poll);
+		}
+	} while(!(sinp(UART_IIR) & UART_IIR_NO_INT)); /* still pending ? */
+	return IRQ_RETVAL(IRQ_HANDLED);
+}
+
+static void hardware_init_port(void)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+	
+	/* Clear registers. */
+	sinp(UART_LSR);
+	sinp(UART_RX);
+	sinp(UART_IIR);
+	sinp(UART_MSR);
+	
+#if defined(LIRC_SERIAL_NSLU2)
+	if(type == LIRC_NSLU2) /* Setup NSLU2 UART */
+	{
+		/* Enable UART */
+		soutp(UART_IER, sinp(UART_IER) | UART_IE_IXP42X_UUE);
+		/* Disable Receiver data Time out interrupt */
+		soutp(UART_IER, sinp(UART_IER) & ~UART_IE_IXP42X_RTOIE);
+		/* set out2 = interupt unmask; off() doesn't set MCR
+		   on NSLU2 */
+		soutp(UART_MCR,UART_MCR_RTS|UART_MCR_OUT2);
+	}
+#endif
+
+	/* Set line for power source */
+	off();
+	
+	/* Clear registers again to be sure. */
+	sinp(UART_LSR);
+	sinp(UART_RX);
+	sinp(UART_IIR);
+	sinp(UART_MSR);
+
+	switch(type)
+	{
+	case LIRC_IRDEO:
+	case LIRC_IRDEO_REMOTE:
+		/* setup port to 7N1 @ 115200 Baud */
+		/* 7N1+start = 9 bits at 115200 ~ 3 bits at 38kHz */
+		
+		/* Set DLAB 1. */
+		soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+		/* Set divisor to 1 => 115200 Baud */
+		soutp(UART_DLM,0);
+		soutp(UART_DLL,1);
+		/* Set DLAB 0 +  7N1 */
+		soutp(UART_LCR,UART_LCR_WLEN7);
+		/* THR interrupt already disabled at this point */
+		break;
+	default:
+		break;
+	}
+	
+	local_irq_restore(flags);
+}
+	
+static int init_port(void)
+{
+	int i, nlow, nhigh;
+	
+	/* Reserve io region. */
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+	/* Future MMAP-Developers: Attention!
+	   For memory mapped I/O you *might* need to use ioremap() first,
+	   for the NSLU2 it's done in boot code. */
+	if(((iommap != 0)
+	    && (request_mem_region(iommap, 8<<ioshift,
+				   LIRC_DRIVER_NAME) == NULL))
+	   || ((iommap == 0)
+	       && (request_region(io, 8, LIRC_DRIVER_NAME) == NULL)))
+#else
+	if(request_region(io, 8, LIRC_DRIVER_NAME)==NULL)
+#endif
+	{
+		printk(KERN_ERR  LIRC_DRIVER_NAME  
+		       ": port %04x already in use\n", io);
+		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		       ": use 'setserial /dev/ttySX uart none'\n");
+		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		       ": or compile the serial port driver as module and\n");
+		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		       ": make sure this module is loaded first\n");
+		return(-EBUSY);
+	}
+	
+	hardware_init_port();
+
+	/* Initialize pulse/space widths */
+	init_timing_params(duty_cycle, freq);
+
+	/* If pin is high, then this must be an active low receiver. */
+	if(sense==-1)
+	{
+		/* wait 1/2 sec for the power supply */
+		
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/2);
+		
+		/* probe 9 times every 0.04s, collect "votes" for
+		   active high/low */
+		nlow = 0;
+		nhigh = 0;
+		for(i = 0; i < 9; i ++)
+		{
+			if (sinp(UART_MSR) & hardware[type].signal_pin)
+			{
+				nlow++;
+			}
+			else
+			{
+				nhigh++;
+			}
+			schedule_timeout(HZ/25);
+		}
+		sense = (nlow >= nhigh ? 1 : 0);
+		printk(KERN_INFO  LIRC_DRIVER_NAME  ": auto-detected active "
+		       "%s receiver\n",sense ? "low":"high");
+	}
+	else
+	{
+		printk(KERN_INFO  LIRC_DRIVER_NAME  ": Manually using active "
+		       "%s receiver\n",sense ? "low":"high");
+	};
+	
+	return 0;
+}
+
+static int set_use_inc(void* data)
+{
+	int result;
+	unsigned long flags;
+	
+	/* Init read buffer. */
+	if (lirc_buffer_init(&rbuf, sizeof(lirc_t), RBUF_LEN) < 0)
+		return -ENOMEM;
+	
+	/* initialize timestamp */
+	do_gettimeofday(&lasttv);
+
+	result=request_irq(irq,irq_handler,
+			   SA_INTERRUPT | (share_irq ? SA_SHIRQ:0),
+			   LIRC_DRIVER_NAME,(void *)&hardware);
+	
+	switch(result)
+	{
+	case -EBUSY:
+		printk(KERN_ERR LIRC_DRIVER_NAME ": IRQ %d busy\n", irq);
+                lirc_buffer_free(&rbuf);
+		return -EBUSY;
+	case -EINVAL:
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": Bad irq number or handler\n");
+                lirc_buffer_free(&rbuf);
+		return -EINVAL;
+	default:
+		dprintk("Interrupt %d, port %04x obtained\n", irq, io);
+		break;
+	};
+
+	local_irq_save(flags);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);
+	
+	local_irq_restore(flags);
+	
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{	unsigned long flags;
+	
+	local_irq_save(flags);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+	local_irq_restore(flags);
+
+	free_irq(irq, (void *)&hardware);
+	
+	dprintk("freed IRQ %d\n", irq);
+	lirc_buffer_free(&rbuf);
+	
+	MOD_DEC_USE_COUNT;
+}
+
+static ssize_t lirc_write(struct file *file, const char *buf,
+			 size_t n, loff_t * ppos)
+{
+	int i,count;
+	unsigned long flags;
+	long delta=0;
+	
+	if(!(hardware[type].features&LIRC_CAN_SEND_PULSE))
+	{
+		return(-EBADF);
+	}
+	
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	count=n/sizeof(lirc_t);
+	if(count>WBUF_LEN || count%2==0) return(-EINVAL);
+	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+	local_irq_save(flags);
+	if(type == LIRC_IRDEO)
+	{
+		/* DTR, RTS down */
+		on();
+	}
+	for(i=0;i<count;i++)
+	{
+		if(i%2) hardware[type].send_space(wbuf[i]-delta);
+		else delta=hardware[type].send_pulse(wbuf[i]);
+	}
+	off();
+	local_irq_restore(flags);
+	return(n);
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		      unsigned long arg)
+{
+        int result;
+	unsigned long value;
+	unsigned int ivalue;
+	
+	switch(cmd)
+	{
+	case LIRC_GET_SEND_MODE:
+		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=put_user(LIRC_SEND2MODE
+				(hardware[type].features&LIRC_CAN_SEND_MASK),
+				(unsigned long *) arg);
+		if(result) return(result); 
+		break;
+		
+	case LIRC_SET_SEND_MODE:
+		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=get_user(value,(unsigned long *) arg);
+		if(result) return(result);
+		/* only LIRC_MODE_PULSE supported */
+		if(value!=LIRC_MODE_PULSE) return(-ENOSYS);
+		break;
+		
+	case LIRC_GET_LENGTH:
+		return(-ENOSYS);
+		break;
+		
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		dprintk("SET_SEND_DUTY_CYCLE\n");
+		if(!(hardware[type].features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		return init_timing_params(ivalue, freq);
+		break;
+		
+	case LIRC_SET_SEND_CARRIER:
+		dprintk("SET_SEND_CARRIER\n");
+		if(!(hardware[type].features&LIRC_CAN_SET_SEND_CARRIER))
+		{
+			return(-ENOIOCTLCMD);
+		}
+		
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
+		return init_timing_params(duty_cycle, ivalue);
+		break;
+		
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+static struct file_operations lirc_fops =
+{
+	write:   lirc_write,
+};
+
+static struct lirc_plugin plugin = {
+	name:		LIRC_DRIVER_NAME,
+	minor:		-1,
+	code_length:	1,
+	sample_rate:	0,
+	data:		NULL,
+	add_to_buf:	NULL,
+	get_queue:	NULL,
+	rbuf:		&rbuf,
+	set_use_inc:	set_use_inc,
+	set_use_dec:	set_use_dec,
+	ioctl:		lirc_ioctl,
+	fops:		&lirc_fops,
+	dev:		NULL,
+	owner:		THIS_MODULE,
+};
+
+#ifdef MODULE
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+static struct platform_device *lirc_serial_dev;
+
+static int __devinit lirc_serial_probe(struct platform_device *dev) {
+	return 0;
+}
+
+static int __devexit lirc_serial_remove(struct platform_device * dev) {
+	return 0;
+}
+
+static int lirc_serial_suspend(struct platform_device *dev, pm_message_t state) {
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	/* Disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+
+	/* Clear registers. */
+	sinp(UART_LSR);
+	sinp(UART_RX);
+	sinp(UART_IIR);
+	sinp(UART_MSR);
+
+	return 0;
+}
+
+static int lirc_serial_resume(struct platform_device *dev) {
+	unsigned long flags;
+
+	hardware_init_port();
+
+	local_irq_save(flags);
+	/* Enable Interrupt */
+	do_gettimeofday(&lasttv);
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);
+	off();
+
+	lirc_buffer_clear(&rbuf);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static struct platform_driver lirc_serial_driver = {
+	.probe		= lirc_serial_probe,
+	.remove	= 	__devexit_p(lirc_serial_remove),
+	.suspend	= lirc_serial_suspend,
+	.resume		= lirc_serial_resume,
+	.driver		= {
+		.name	= "lirc_serial",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lirc_serial_init(void)
+{
+	int result;
+
+	lirc_serial_dev = platform_device_alloc("lirc_serial", 0);
+	if (!lirc_serial_dev)
+		return -ENOMEM;
+	result = platform_device_add(lirc_serial_dev);
+	if (result) {
+		platform_device_put(lirc_serial_dev);
+		return result;
+	}
+	result = platform_driver_register(&lirc_serial_driver);
+	if (result) {
+		printk("lirc register returned %d\n", result);
+		platform_device_del(lirc_serial_dev);
+		platform_device_put(lirc_serial_dev);
+		return result;
+	}
+	return 0;
+}
+#endif
+
+int __init init_module(void)
+{
+	int result;
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	result = lirc_serial_init();
+	if(result) return result;
+#endif
+	switch(type)
+	{
+	case LIRC_HOMEBREW:
+	case LIRC_IRDEO:
+	case LIRC_IRDEO_REMOTE:
+	case LIRC_ANIMAX:
+	case LIRC_IGOR:
+#if defined(LIRC_SERIAL_NSLU2)
+	case LIRC_NSLU2:
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+	if(!softcarrier)
+	{
+		switch(type)
+		{
+		case LIRC_HOMEBREW:
+		case LIRC_IGOR:
+		case LIRC_NSLU2:
+			hardware[type].features&=
+				~(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+				  LIRC_CAN_SET_SEND_CARRIER);
+			break;
+		}
+	}
+	if((result = init_port()) < 0)
+	{
+		return result;
+	}
+	plugin.features = hardware[type].features;
+	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) {
+		printk(KERN_ERR  LIRC_DRIVER_NAME  
+		       ": register_chrdev failed!\n");
+		release_region(io, 8);
+		return -EIO;
+	}
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+static void __exit lirc_serial_exit(void)
+{
+	struct platform_device *pdev = lirc_serial_dev;
+	lirc_serial_dev = NULL;
+	platform_driver_unregister(&lirc_serial_driver);
+	platform_device_unregister(pdev);
+}
+#endif
+
+void __exit cleanup_module(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	lirc_serial_exit();
+#endif
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+	if(iommap != 0)
+	{
+		release_mem_region(iommap, 8<<ioshift);
+	}
+	else
+	{
+		release_region(io, 8);
+	}
+#else
+	release_region(io, 8);
+#endif
+	lirc_unregister_plugin(plugin.minor);
+	dprintk("cleaned up module\n");
+}
+
+MODULE_DESCRIPTION("Infra-red receiver driver for serial ports.");
+MODULE_AUTHOR("Ralph Metzler, Trent Piepho, Ben Pfaff, Christoph Bartelmus, Andrei Tanas");
+MODULE_LICENSE("GPL");
+
+module_param(type, int, 0444);
+#if defined(LIRC_SERIAL_NSLU2)
+MODULE_PARM_DESC(type, "Hardware type (0 = home-brew, 1 = IRdeo,"
+		 " 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug,"
+		 " 5 = NSLU2 RX:CTS2/TX:GreenLED"
+		 );
+#else
+MODULE_PARM_DESC(type, "Hardware type (0 = home-brew, 1 = IRdeo,"
+		 " 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug"
+		 );
+#endif
+
+module_param(io, int, 0444);
+MODULE_PARM_DESC(io, "I/O address base (0x3f8 or 0x2f8)");
+
+#if defined(LIRC_ALLOW_MMAPPED_IO)
+/* some architectures (e.g. intel xscale) have memory mapped registers */
+module_param(iommap, bool, 0444);
+MODULE_PARM_DESC(iommap, "physical base for memory mapped I/O"
+		" (0 = no memory mapped io)");
+
+/* some architectures (e.g. intel xscale) align the 8bit serial registers
+   on 32bit word boundaries.
+   See linux-kernel/drivers/serial/8250.c serial_in()/out() */
+module_param(ioshift, int, 0444);
+MODULE_PARM_DESC(ioshift, "shift I/O register offset (0 = no shift)");
+#endif
+
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "Interrupt (4 or 3)");
+
+module_param(share_irq, bool, 0444);
+MODULE_PARM_DESC(share_irq, "Share interrupts (0 = off, 1 = on)");
+
+module_param(sense, bool, 0444);
+MODULE_PARM_DESC(sense, "Override autodetection of IR receiver circuit"
+		 " (0 = active high, 1 = active low )");
+
+#ifdef LIRC_SERIAL_TRANSMITTER
+module_param(txsense, bool, 0444);
+MODULE_PARM_DESC(txsense, "Sense of transmitter circuit"
+		 " (0 = active high, 1 = active low )");
+#endif
+
+module_param(softcarrier, bool, 0444);
+MODULE_PARM_DESC(softcarrier, "Software carrier (0 = off, 1 = on)");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_sir.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_sir.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_sir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_sir.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1365 @@
+/*
+ * LIRC SIR driver, (C) 2000 Milan Pikula <www@fornax.sk>
+ *
+ * lirc_sir - Device driver for use with SIR (serial infra red)
+ * mode of IrDA on many notebooks.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * 2000/09/16 Frank Przybylski <mail@frankprzybylski.de> :
+ *  added timeout and relaxed pulse detection, removed gap bug
+ *
+ * 2000/12/15 Christoph Bartelmus <lirc@bartelmus.de> : 
+ *   added support for Tekram Irmate 210 (sending does not work yet,
+ *   kind of disappointing that nobody was able to implement that
+ *   before),
+ *   major clean-up
+ *
+ * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> : 
+ *   added support for StrongARM SA1100 embedded microprocessor
+ *   parts cut'n'pasted from sa1100_ir.c (C) 2000 Russell King
+ */
+
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+#include <linux/module.h>
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+ 
+#include <linux/autoconf.h>
+
+#if !defined(LIRC_ON_SA1100) && !defined(CONFIG_SERIAL_MODULE)
+#warning "******************************************"
+#warning " Your serial port driver is compiled into "
+#warning " the kernel. You will have to release the "
+#warning " port you want to use for LIRC with:      "
+#warning "    setserial /dev/ttySx uart none        "
+#warning "******************************************"
+#endif
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+#ifdef LIRC_ON_SA1100
+#include <asm/hardware.h>
+#ifdef CONFIG_SA1100_COLLIE
+#include <asm/arch/tc35143.h>
+#include <asm/ucb1200.h>
+#endif
+#endif
+
+#include <linux/timer.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+#include "kcompat.h"
+
+/* SECTION: Definitions */
+
+/**************************** Tekram dongle ***************************/
+#ifdef LIRC_SIR_TEKRAM
+/* stolen from kernel source */
+/* definitions for Tekram dongle */
+#define TEKRAM_115200 0x00
+#define TEKRAM_57600  0x01
+#define TEKRAM_38400  0x02
+#define TEKRAM_19200  0x03
+#define TEKRAM_9600   0x04
+#define TEKRAM_2400   0x08
+
+#define TEKRAM_PW 0x10 /* Pulse select bit */
+
+/* 10bit * 1s/115200bit in miliseconds = 87ms*/
+#define TIME_CONST (10000000ul/115200ul)
+
+#endif
+
+#ifdef LIRC_SIR_ACTISYS_ACT200L
+static void init_act200(void);
+#elif defined(LIRC_SIR_ACTISYS_ACT220L)
+static void init_act220(void);
+#endif
+
+/******************************* SA1100 ********************************/
+#ifdef LIRC_ON_SA1100
+struct sa1100_ser2_registers
+{
+	/* HSSP control register */
+	unsigned char hscr0;
+	/* UART registers */
+	unsigned char utcr0;
+	unsigned char utcr1;
+	unsigned char utcr2;
+	unsigned char utcr3;
+	unsigned char utcr4;
+	unsigned char utdr;
+	unsigned char utsr0;
+	unsigned char utsr1;
+} sr;
+
+static int irq=IRQ_Ser2ICP;
+
+#define LIRC_ON_SA1100_TRANSMITTER_LATENCY 0
+
+/* pulse/space ratio of 50/50 */
+static unsigned long pulse_width = (13-LIRC_ON_SA1100_TRANSMITTER_LATENCY);
+/* 1000000/freq-pulse_width */
+static unsigned long space_width = (13-LIRC_ON_SA1100_TRANSMITTER_LATENCY);
+static unsigned int freq = 38000;      /* modulation frequency */
+static unsigned int duty_cycle = 50;   /* duty cycle of 50% */
+
+#endif
+
+#define RBUF_LEN 1024
+#define WBUF_LEN 1024
+
+#define LIRC_DRIVER_NAME "lirc_sir"
+
+#define PULSE '['
+
+#ifndef LIRC_SIR_TEKRAM
+/* 9bit * 1s/115200bit in milli seconds = 78.125ms*/
+#define TIME_CONST (9000000ul/115200ul)
+#endif
+
+
+/* timeout for sequences in jiffies (=5/100s) */
+/* must be longer than TIME_CONST */
+#define SIR_TIMEOUT	(HZ*5/100)
+
+#ifndef LIRC_ON_SA1100
+#ifndef LIRC_IRQ
+#define LIRC_IRQ 4
+#endif
+#ifndef LIRC_PORT
+#define LIRC_PORT 0x3e8
+#endif
+
+static int io = LIRC_PORT;
+static int irq = LIRC_IRQ;
+static int threshold = 3;
+#endif
+
+static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static struct timer_list timerlist;
+/* time of last signal change detected */
+static struct timeval last_tv = {0, 0};
+/* time of last UART data ready interrupt */
+static struct timeval last_intr_tv = {0, 0};
+static int last_value = 0;
+
+static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
+
+static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+
+static lirc_t rx_buf[RBUF_LEN]; 
+static unsigned int rx_tail = 0, rx_head = 0;
+static lirc_t tx_buf[WBUF_LEN];
+
+static int debug = 0;
+#define dprintk(fmt, args...)                                     \
+	do{                                                       \
+		if(debug) printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
+                                 fmt, ## args);                   \
+	}while(0)
+
+/* SECTION: Prototypes */
+
+/* Communication with user-space */
+static int lirc_open(struct inode * inode, struct file * file);
+static int lirc_close(struct inode * inode, struct file *file);
+static unsigned int lirc_poll(struct file * file, poll_table * wait);
+static ssize_t lirc_read(struct file * file, char * buf, size_t count,
+		loff_t * ppos);
+static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos);
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		unsigned long arg);
+static void add_read_queue(int flag, unsigned long val);
+#ifdef MODULE
+static int init_chrdev(void);
+static void drop_chrdev(void);
+#endif
+	/* Hardware */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static irqreturn_t sir_interrupt(int irq, void * dev_id,
+				 struct pt_regs * regs);
+#else
+static irqreturn_t sir_interrupt(int irq, void * dev_id);
+#endif
+static void send_space(unsigned long len);
+static void send_pulse(unsigned long len);
+static int init_hardware(void);
+static void drop_hardware(void);
+	/* Initialisation */
+static int init_port(void);
+static void drop_port(void);
+int init_module(void);
+void cleanup_module(void);
+
+#ifdef LIRC_ON_SA1100
+static void inline on(void)
+{
+	PPSR|=PPC_TXD2;
+}
+  
+static void inline off(void)
+{
+	PPSR&=~PPC_TXD2;
+}
+#else
+static inline unsigned int sinp(int offset)
+{
+	return inb(io + offset);
+}
+
+static inline void soutp(int offset, int value)
+{
+	outb(value, io + offset);
+}
+#endif
+
+#ifndef MAX_UDELAY_MS
+#define MAX_UDELAY_US 5000
+#else
+#define MAX_UDELAY_US (MAX_UDELAY_MS*1000)
+#endif
+
+static inline void safe_udelay(unsigned long usecs)
+{
+	while(usecs>MAX_UDELAY_US)
+	{
+		udelay(MAX_UDELAY_US);
+		usecs-=MAX_UDELAY_US;
+	}
+	udelay(usecs);
+}
+
+/* SECTION: Communication with user-space */
+
+static int lirc_open(struct inode * inode, struct file * file)
+{
+	spin_lock(&dev_lock);
+	if (MOD_IN_USE) {
+		spin_unlock(&dev_lock);
+		return -EBUSY;
+	}
+	MOD_INC_USE_COUNT;
+	spin_unlock(&dev_lock);
+	return 0;
+}
+
+static int lirc_close(struct inode * inode, struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static unsigned int lirc_poll(struct file * file, poll_table * wait)
+{
+	poll_wait(file, &lirc_read_queue, wait);
+	if (rx_head != rx_tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t lirc_read(struct file * file, char * buf, size_t count,
+		loff_t * ppos)
+{
+	int n=0;
+	int retval = 0;
+	DECLARE_WAITQUEUE(wait,current);
+	
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	
+	add_wait_queue(&lirc_read_queue,&wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	while(n<count)
+	{
+		if(rx_head!=rx_tail)
+		{
+			if(copy_to_user((void *) buf+n,
+					(void *) (rx_buf+rx_head),
+					sizeof(lirc_t)))
+			{
+				retval=-EFAULT;
+				break;
+			}
+			rx_head=(rx_head+1)&(RBUF_LEN-1);
+			n+=sizeof(lirc_t);
+		}
+		else
+		{
+			if(file->f_flags & O_NONBLOCK)
+			{
+				retval=-EAGAIN;
+				break;
+			}
+			if(signal_pending(current))
+			{
+				retval=-ERESTARTSYS;
+				break;
+			}
+			schedule();
+			set_current_state(TASK_INTERRUPTIBLE);
+		}
+	}
+	remove_wait_queue(&lirc_read_queue,&wait);
+	set_current_state(TASK_RUNNING);
+	return (n ? n : retval);
+}
+static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos)
+{
+	unsigned long flags;
+	int i;
+
+        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
+		return(-EINVAL);
+	if(copy_from_user(tx_buf, buf, n)) return -EFAULT;
+	i = 0;
+	n/=sizeof(lirc_t);
+#ifdef LIRC_ON_SA1100
+	/* disable receiver */
+	Ser2UTCR3=0;
+#endif
+	local_irq_save(flags);
+	while (1) {
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_pulse(tx_buf[i]);
+		i++;
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_space(tx_buf[i]);
+		i++;
+	}
+	local_irq_restore(flags);
+#ifdef LIRC_ON_SA1100
+	off();
+	udelay(1000); /* wait 1ms for IR diode to recover */
+	Ser2UTCR3=0;
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	/* enable receiver */
+	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
+#endif
+	return n;
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+#ifdef LIRC_ON_SA1100
+	unsigned int ivalue;
+
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE |
+			LIRC_CAN_SET_SEND_DUTY_CYCLE |
+			LIRC_CAN_SET_SEND_CARRIER |
+			LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+#else
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+#endif
+
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+	case LIRC_GET_SEND_MODE:
+	case LIRC_GET_REC_MODE:
+		retval = put_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *) arg);
+		break;
+#ifdef LIRC_ON_SA1100
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		/* (ivalue/100)*(1000000/freq) */
+		duty_cycle=ivalue;
+		pulse_width=(unsigned long) duty_cycle*10000/freq;
+		space_width=(unsigned long) 1000000L/freq-pulse_width;
+		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		break;
+	case LIRC_SET_SEND_CARRIER:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
+		freq=ivalue;
+		pulse_width=(unsigned long) duty_cycle*10000/freq;
+		space_width=(unsigned long) 1000000L/freq-pulse_width;
+		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		break;
+#endif
+	default:
+		retval = -ENOIOCTLCMD;
+
+	}
+	
+	if (retval)
+		return retval;
+	if (cmd == LIRC_SET_REC_MODE) {
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+	} else if (cmd == LIRC_SET_SEND_MODE) {
+		if (value != LIRC_MODE_PULSE)
+			retval = -ENOSYS;
+	}
+
+	return retval;
+}
+
+static void add_read_queue(int flag, unsigned long val)
+{
+	unsigned int new_rx_tail;
+	lirc_t newval;
+
+	dprintk("add flag %d with val %lu\n", flag, val);
+
+	newval = val & PULSE_MASK;
+
+	/* statistically pulses are ~TIME_CONST/2 too long: we could
+	   maybe make this more exactly but this is good enough */
+	if(flag) /* pulse */
+	{
+		if(newval>TIME_CONST/2)
+		{
+			newval-=TIME_CONST/2;
+		}
+		else /* should not ever happen */
+		{
+			newval=1;
+		}
+		newval|=PULSE_BIT;
+	}
+	else
+	{
+		newval+=TIME_CONST/2;
+	}
+	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
+	if (new_rx_tail == rx_head) {
+		dprintk("Buffer overrun.\n");
+		return;
+	}
+	rx_buf[rx_tail] = newval;
+	rx_tail = new_rx_tail;
+	wake_up_interruptible(&lirc_read_queue);
+}
+
+static struct file_operations lirc_fops =
+{
+	read:    lirc_read,
+	write:   lirc_write,
+	poll:    lirc_poll,
+	ioctl:   lirc_ioctl,
+	open:    lirc_open,
+	release: lirc_close,
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_INC_USE_COUNT;
+#endif
+       return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+	MOD_DEC_USE_COUNT;
+#endif
+}
+static struct lirc_plugin plugin = {
+       name:           LIRC_DRIVER_NAME,
+       minor:          -1,
+       code_length:    1,
+       sample_rate:    0,
+       data:           NULL,
+       add_to_buf:     NULL,
+       get_queue:      NULL,
+       set_use_inc:    set_use_inc,
+       set_use_dec:    set_use_dec,
+       fops:           &lirc_fops,
+       dev:            NULL,
+       owner:          THIS_MODULE,
+};
+
+
+#ifdef MODULE
+static int init_chrdev(void)
+{
+	plugin.minor = lirc_register_plugin(&plugin);
+	if (plugin.minor < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void drop_chrdev(void)
+{
+	lirc_unregister_plugin(plugin.minor);
+}
+#endif
+
+/* SECTION: Hardware */
+static long delta(struct timeval * tv1, struct timeval * tv2)
+{
+	unsigned long deltv;
+	
+	deltv = tv2->tv_sec - tv1->tv_sec;
+	if (deltv > 15)
+		deltv = 0xFFFFFF;
+	else
+		deltv = deltv*1000000 +
+			tv2->tv_usec -
+			tv1->tv_usec;
+	return deltv;
+}
+
+static void sir_timeout(unsigned long data) 
+{
+	/* if last received signal was a pulse, but receiving stopped
+	   within the 9 bit frame, we need to finish this pulse and
+	   simulate a signal change to from pulse to space. Otherwise
+	   upper layers will receive two sequences next time. */
+	
+	unsigned long flags;
+	unsigned long pulse_end;
+	
+	/* avoid interference with interrupt */
+ 	spin_lock_irqsave(&timer_lock, flags);
+	if (last_value)
+	{
+#ifndef LIRC_ON_SA1100
+		/* clear unread bits in UART and restart */
+		outb(UART_FCR_CLEAR_RCVR, io + UART_FCR);
+#endif
+		/* determine 'virtual' pulse end: */
+	 	pulse_end = delta(&last_tv, &last_intr_tv);
+		dprintk("timeout add %d for %lu usec\n",last_value,pulse_end);
+		add_read_queue(last_value,pulse_end);
+		last_value = 0;
+		last_tv=last_intr_tv;
+	}
+	spin_unlock_irqrestore(&timer_lock, flags);		
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static irqreturn_t sir_interrupt(int irq, void * dev_id,
+				 struct pt_regs * regs)
+#else
+static irqreturn_t sir_interrupt(int irq, void * dev_id)
+#endif
+{
+	unsigned char data;
+	struct timeval curr_tv;
+	static unsigned long deltv;
+#ifdef LIRC_ON_SA1100
+	int status;
+	static int n=0;
+	
+	//printk("interrupt\n");
+	status = Ser2UTSR0;
+	/*
+	 * Deal with any receive errors first.  The bytes in error may be
+	 * the only bytes in the receive FIFO, so we do this first.
+	 */
+	while (status & UTSR0_EIF)
+	{
+		int bstat;
+
+		if(debug) {
+			dprintk("EIF\n");
+			bstat = Ser2UTSR1;
+		
+			if (bstat & UTSR1_FRE)
+				dprintk("frame error\n");
+			if (bstat & UTSR1_ROR)
+				dprintk("receive fifo overrun\n");
+			if (bstat & UTSR1_PRE)
+				dprintk("parity error\n");
+		}
+		
+		bstat = Ser2UTDR;
+		n++;
+		status = Ser2UTSR0;
+	}
+
+	if (status & (UTSR0_RFS | UTSR0_RID))
+	{
+		do_gettimeofday(&curr_tv);
+		deltv = delta(&last_tv, &curr_tv);
+		do
+		{
+			data=Ser2UTDR;
+			dprintk("%d data: %u\n", n, (unsigned int) data);
+			n++;
+		}
+		while(status&UTSR0_RID && /* do not empty fifo in
+                                             order to get UTSR0_RID in
+                                             any case */
+		      Ser2UTSR1 & UTSR1_RNE); /* data ready */
+		
+		if(status&UTSR0_RID)
+		{
+			//printk("add\n");
+			add_read_queue(0,deltv-n*TIME_CONST); /*space*/
+			add_read_queue(1,n*TIME_CONST); /*pulse*/
+			n=0;
+			last_tv=curr_tv;
+		}
+	}
+
+	if (status & UTSR0_TFS) {
+
+		printk("transmit fifo not full, shouldn't ever happen\n");
+	}
+
+	/*
+	 * We must clear certain bits.
+	 */
+	status &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	if (status)
+		Ser2UTSR0 = status;
+#else
+	unsigned long deltintrtv;
+	unsigned long flags;
+	int iir, lsr;
+
+	while ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {
+		switch (iir&UART_IIR_ID) { /* FIXME toto treba preriedit */
+		case UART_IIR_MSI:
+			(void) inb(io + UART_MSR);
+			break;
+		case UART_IIR_RLSI:
+			(void) inb(io + UART_LSR);
+			break;
+		case UART_IIR_THRI:
+#if 0
+			if (lsr & UART_LSR_THRE) /* FIFO is empty */
+				outb(data, io + UART_TX)
+#endif
+			break;
+		case UART_IIR_RDI:
+			/* avoid interference with timer */
+		 	spin_lock_irqsave(&timer_lock, flags);
+			do
+			{
+				del_timer(&timerlist);
+				data = inb(io + UART_RX);
+				do_gettimeofday(&curr_tv);
+				deltv = delta(&last_tv, &curr_tv);
+				deltintrtv = delta(&last_intr_tv, &curr_tv);
+				dprintk("t %lu , d %d\n", deltintrtv, (int)data);
+				/* if nothing came in last X cycles,
+				   it was gap */
+				if (deltintrtv > TIME_CONST * threshold) {
+					if (last_value) {
+						dprintk("GAP\n");
+						/* simulate signal change */
+						add_read_queue(last_value,
+							       deltv-
+							       deltintrtv);
+						last_value = 0;
+						last_tv.tv_sec = last_intr_tv.tv_sec;
+						last_tv.tv_usec = last_intr_tv.tv_usec;
+						deltv = deltintrtv;
+					}
+				}
+				data = 1;
+				if (data ^ last_value) {
+					/* deltintrtv > 2*TIME_CONST,
+                                           remember ? */
+					/* the other case is timeout */
+					add_read_queue(last_value,
+						       deltv-TIME_CONST);
+					last_value = data;
+					last_tv = curr_tv;
+					if(last_tv.tv_usec>=TIME_CONST)
+					{
+						last_tv.tv_usec-=TIME_CONST;
+					}
+					else
+					{
+						last_tv.tv_sec--;
+						last_tv.tv_usec+=1000000-
+							TIME_CONST;
+					}
+				}
+				last_intr_tv = curr_tv;
+				if (data)
+				{
+					/* start timer for end of sequence detection */
+					timerlist.expires = jiffies + SIR_TIMEOUT;
+					add_timer(&timerlist);
+				}
+			}
+			while ((lsr = inb(io + UART_LSR))
+				& UART_LSR_DR); /* data ready */
+			spin_unlock_irqrestore(&timer_lock, flags);
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	return IRQ_RETVAL(IRQ_HANDLED);
+}
+
+#ifdef LIRC_ON_SA1100
+static void send_pulse(unsigned long length)
+{
+	unsigned long k,delay;
+	int flag;
+
+	if(length==0) return;
+	/* this won't give us the carrier frequency we really want
+	   due to integer arithmetic, but we can accept this inaccuracy */
+
+	for(k=flag=0;k<length;k+=delay,flag=!flag)
+	{
+		if(flag)
+		{
+			off();
+			delay=space_width;
+		}
+		else
+		{
+			on();
+			delay=pulse_width;
+		}
+		safe_udelay(delay);
+	}
+	off();
+}
+
+static void send_space(unsigned long length)
+{
+	if(length==0) return;
+	off();
+	safe_udelay(length);
+}
+#else
+static void send_space(unsigned long len)
+{
+	safe_udelay(len);
+}
+
+static void send_pulse(unsigned long len)
+{
+	long bytes_out = len / TIME_CONST;
+	long time_left;
+
+	time_left = (long)len - (long)bytes_out * (long)TIME_CONST;
+	if (bytes_out == 0)
+	{
+		bytes_out++;
+		time_left = 0;
+	}
+	while (bytes_out--)
+       	{
+		outb(PULSE, io + UART_TX);
+		/* FIXME treba seriozne cakanie z drivers/char/serial.c */
+		while (!(inb(io + UART_LSR) & UART_LSR_THRE));
+	}
+#if 0
+	if (time_left > 0)
+		safe_udelay(time_left);
+#endif
+}
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+static inline int sa1100_irda_set_power_collie(int state)
+{
+	if (state) {
+		/*
+		 *  0 - off
+		 *  1 - short range, lowest power
+		 *  2 - medium range, medium power
+		 *  3 - maximum range, high power
+		 */
+		ucb1200_set_io_direction(TC35143_GPIO_IR_ON,
+					 TC35143_IODIR_OUTPUT);
+		ucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_LOW);
+		udelay(100);
+	}
+	else {
+		/* OFF */
+		ucb1200_set_io_direction(TC35143_GPIO_IR_ON,
+					 TC35143_IODIR_OUTPUT);
+		ucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_HIGH);
+	}
+	return 0;
+}
+#endif
+
+static int init_hardware(void)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* reset UART */
+#ifdef LIRC_ON_SA1100
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		printk("Power on IR module\n");
+		set_bitsy_egpio(EGPIO_BITSY_IR_ON);
+	}
+#endif
+#ifdef CONFIG_SA1100_COLLIE
+	sa1100_irda_set_power_collie(3);	/* power on */
+#endif
+	sr.hscr0=Ser2HSCR0;
+
+	sr.utcr0=Ser2UTCR0;
+	sr.utcr1=Ser2UTCR1;
+	sr.utcr2=Ser2UTCR2;
+	sr.utcr3=Ser2UTCR3;
+	sr.utcr4=Ser2UTCR4;
+
+	sr.utdr=Ser2UTDR;
+	sr.utsr0=Ser2UTSR0;
+	sr.utsr1=Ser2UTSR1;
+
+	/* configure GPIO */
+	/* output */
+	PPDR|=PPC_TXD2;
+	PSDR|=PPC_TXD2;
+	/* set output to 0 */
+	off();
+	
+	/*
+	 * Enable HP-SIR modulation, and ensure that the port is disabled.
+	 */
+	Ser2UTCR3=0;
+	Ser2HSCR0=sr.hscr0 & (~HSCR0_HSSP);
+	
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	
+	/* 7N1 */
+	Ser2UTCR0=UTCR0_1StpBit|UTCR0_7BitData;
+	/* 115200 */
+	Ser2UTCR1=0;
+	Ser2UTCR2=1;
+	/* use HPSIR, 1.6 usec pulses */
+	Ser2UTCR4=UTCR4_HPSIR|UTCR4_Z1_6us;
+	
+	/* enable receiver, receive fifo interrupt */
+	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
+	
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	
+#elif defined(LIRC_SIR_TEKRAM)
+	/* disable FIFO */ 
+	soutp(UART_FCR,
+	      UART_FCR_CLEAR_RCVR|
+	      UART_FCR_CLEAR_XMIT|
+	      UART_FCR_TRIGGER_1);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+	
+	/* Set DLAB 1. */
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+	
+	/* Set divisor to 12 => 9600 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,12);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+	
+	/* power supply */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	safe_udelay(50*1000);
+	
+	/* -DTR low -> reset PIC */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
+	udelay(1*1000);
+	
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(100);
+
+
+        /* -RTS low -> send control byte */
+	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(7);
+	soutp(UART_TX, TEKRAM_115200|TEKRAM_PW);
+	
+	/* one byte takes ~1042 usec to transmit at 9600,8N1 */
+	udelay(1500);
+	
+	/* back to normal operation */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(50);
+
+	udelay(1500);
+	
+	/* read previous control byte */
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": 0x%02x\n",sinp(UART_RX));
+	
+	/* Set DLAB 1. */
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+	
+	/* Set divisor to 1 => 115200 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,1);
+
+	/* Set DLAB 0, 8 Bit */
+	soutp(UART_LCR, UART_LCR_WLEN8);
+	/* enable interrupts */
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);
+#else
+	outb(0, io + UART_MCR);
+	outb(0, io + UART_IER);
+	/* init UART */
+		/* set DLAB, speed = 115200 */
+	outb(UART_LCR_DLAB | UART_LCR_WLEN7, io + UART_LCR);
+	outb(1, io + UART_DLL); outb(0, io + UART_DLM);
+		/* 7N1+start = 9 bits at 115200 ~ 3 bits at 44000 */
+	outb(UART_LCR_WLEN7, io + UART_LCR);
+		/* FIFO operation */
+	outb(UART_FCR_ENABLE_FIFO, io + UART_FCR);
+		/* interrupts */
+	// outb(UART_IER_RLSI|UART_IER_RDI|UART_IER_THRI, io + UART_IER);
+	outb(UART_IER_RDI, io + UART_IER);	
+	/* turn on UART */
+	outb(UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2, io + UART_MCR);
+#ifdef LIRC_SIR_ACTISYS_ACT200L
+	init_act200();
+#elif defined(LIRC_SIR_ACTISYS_ACT220L)
+	init_act220();
+#endif
+#endif
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	return 0;
+}
+
+static void drop_hardware(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+
+#ifdef LIRC_ON_SA1100
+	Ser2UTCR3=0;
+	
+	Ser2UTCR0=sr.utcr0;
+	Ser2UTCR1=sr.utcr1;
+	Ser2UTCR2=sr.utcr2;
+	Ser2UTCR4=sr.utcr4;
+	Ser2UTCR3=sr.utcr3;
+	
+	Ser2HSCR0=sr.hscr0;
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		clr_bitsy_egpio(EGPIO_BITSY_IR_ON);
+	}
+#endif
+#ifdef CONFIG_SA1100_COLLIE
+	sa1100_irda_set_power_collie(0);	/* power off */
+#endif
+#else
+	/* turn off interrupts */
+	outb(0, io + UART_IER);	
+#endif
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+/* SECTION: Initialisation */
+
+static int init_port(void)
+{
+	int retval;
+	
+	/* get I/O port access and IRQ line */
+#ifndef LIRC_ON_SA1100
+	if(request_region(io, 8, LIRC_DRIVER_NAME) == NULL)
+	{
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": i/o port 0x%.4x already in use.\n", io);
+		return -EBUSY;
+	}
+#endif
+	retval = request_irq(irq, sir_interrupt, SA_INTERRUPT,
+			     LIRC_DRIVER_NAME, NULL);
+	if (retval < 0) {
+#               ifndef LIRC_ON_SA1100
+		release_region(io, 8);
+#               endif
+		printk(KERN_ERR LIRC_DRIVER_NAME
+			": IRQ %d already in use.\n",
+			irq);
+		return retval;
+	}
+#ifndef LIRC_ON_SA1100
+	printk(KERN_INFO LIRC_DRIVER_NAME
+		": I/O port 0x%.4x, IRQ %d.\n",
+		io, irq);
+#endif
+
+	init_timer(&timerlist);
+	timerlist.function = sir_timeout;
+	timerlist.data = 0xabadcafe;
+
+	return 0;
+}
+
+static void drop_port(void)
+{
+	free_irq(irq, NULL);
+	del_timer_sync(&timerlist);
+#ifndef LIRC_ON_SA1100
+	release_region(io, 8);
+#endif
+}
+
+#ifdef LIRC_SIR_ACTISYS_ACT200L
+/******************************************************/
+/* Crystal/Cirrus CS8130 IR transceiver, used in Actisys Act200L dongle */
+/* some code borrowed from Linux IRDA driver */
+
+/* Regsiter 0: Control register #1 */
+#define ACT200L_REG0    0x00
+#define ACT200L_TXEN    0x01 /* Enable transmitter */
+#define ACT200L_RXEN    0x02 /* Enable receiver */
+#define ACT200L_ECHO    0x08 /* Echo control chars */
+
+/* Register 1: Control register #2 */
+#define ACT200L_REG1    0x10
+#define ACT200L_LODB    0x01 /* Load new baud rate count value */
+#define ACT200L_WIDE    0x04 /* Expand the maximum allowable pulse */
+
+/* Register 3: Transmit mode register #2 */
+#define ACT200L_REG3    0x30
+#define ACT200L_B0      0x01 /* DataBits, 0=6, 1=7, 2=8, 3=9(8P)  */
+#define ACT200L_B1      0x02 /* DataBits, 0=6, 1=7, 2=8, 3=9(8P)  */
+#define ACT200L_CHSY    0x04 /* StartBit Synced 0=bittime, 1=startbit */
+
+/* Register 4: Output Power register */
+#define ACT200L_REG4    0x40
+#define ACT200L_OP0     0x01 /* Enable LED1C output */
+#define ACT200L_OP1     0x02 /* Enable LED2C output */
+#define ACT200L_BLKR    0x04
+
+/* Register 5: Receive Mode register */
+#define ACT200L_REG5    0x50
+#define ACT200L_RWIDL   0x01 /* fixed 1.6us pulse mode */
+    /*.. other various IRDA bit modes, and TV remote modes..*/
+
+/* Register 6: Receive Sensitivity register #1 */
+#define ACT200L_REG6    0x60
+#define ACT200L_RS0     0x01 /* receive threshold bit 0 */
+#define ACT200L_RS1     0x02 /* receive threshold bit 1 */
+
+/* Register 7: Receive Sensitivity register #2 */
+#define ACT200L_REG7    0x70
+#define ACT200L_ENPOS   0x04 /* Ignore the falling edge */
+
+/* Register 8,9: Baud Rate Dvider register #1,#2 */
+#define ACT200L_REG8    0x80
+#define ACT200L_REG9    0x90
+
+#define ACT200L_2400    0x5f
+#define ACT200L_9600    0x17
+#define ACT200L_19200   0x0b
+#define ACT200L_38400   0x05
+#define ACT200L_57600   0x03
+#define ACT200L_115200  0x01
+
+/* Register 13: Control register #3 */
+#define ACT200L_REG13   0xd0
+#define ACT200L_SHDW    0x01 /* Enable access to shadow registers */
+
+/* Register 15: Status register */
+#define ACT200L_REG15   0xf0
+
+/* Register 21: Control register #4 */
+#define ACT200L_REG21   0x50
+#define ACT200L_EXCK    0x02 /* Disable clock output driver */
+#define ACT200L_OSCL    0x04 /* oscillator in low power, medium accuracy mode */
+
+static void init_act200(void)
+{
+	int i;
+	__u8 control[] = {
+		ACT200L_REG15,
+		ACT200L_REG13 | ACT200L_SHDW,
+		ACT200L_REG21 | ACT200L_EXCK | ACT200L_OSCL,
+		ACT200L_REG13,
+		ACT200L_REG7  | ACT200L_ENPOS,
+		ACT200L_REG6  | ACT200L_RS0  | ACT200L_RS1,
+		ACT200L_REG5  | ACT200L_RWIDL,
+		ACT200L_REG4  | ACT200L_OP0  | ACT200L_OP1 | ACT200L_BLKR,
+		ACT200L_REG3  | ACT200L_B0,
+		ACT200L_REG0  | ACT200L_TXEN | ACT200L_RXEN,
+		ACT200L_REG8 |  (ACT200L_115200       & 0x0f),
+		ACT200L_REG9 | ((ACT200L_115200 >> 4) & 0x0f),
+		ACT200L_REG1 | ACT200L_LODB | ACT200L_WIDE
+	};
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);
+	
+	/* Set divisor to 12 => 9600 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,12);
+	
+	/* Set DLAB 0. */
+	soutp(UART_LCR, UART_LCR_WLEN8);
+	/* Set divisor to 12 => 9600 Baud */
+
+	/* power supply */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	for (i=0; i<50; i++) {
+		safe_udelay(1000);
+	}
+
+		/* Reset the dongle : set RTS low for 25 ms */
+	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
+	for (i=0; i<25; i++) {
+		udelay(1000);
+	}
+
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(100);
+
+	/* Clear DTR and set RTS to enter command mode */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
+	udelay(7);
+
+/* send out the control register settings for 115K 7N1 SIR operation */
+	for (i=0; i<sizeof(control); i++) {
+		soutp(UART_TX, control[i]);
+		/* one byte takes ~1042 usec to transmit at 9600,8N1 */
+		udelay(1500);
+	}
+
+	/* back to normal operation */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(50);
+
+	udelay(1500);
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);
+
+	/* Set divisor to 1 => 115200 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,1);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* Set DLAB 0, 7 Bit */
+	soutp(UART_LCR, UART_LCR_WLEN7);
+
+	/* enable interrupts */
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);
+}
+#endif
+
+#ifdef LIRC_SIR_ACTISYS_ACT220L
+/* Derived from linux IrDA driver (drivers/net/irda/actisys.c) 
+ * Drop me a mail for any kind of comment: maxx@spaceboyz.net */
+
+void init_act220(void) {
+	int i;
+
+	/* DLAB 1 */
+	soutp(UART_LCR, UART_LCR_DLAB|UART_LCR_WLEN7);
+
+	/* 9600 baud */
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 12);
+
+	/* DLAB 0 */
+	soutp(UART_LCR, UART_LCR_WLEN7);
+
+	/* reset the dongle, set DTR low for 10us */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
+	udelay(10);
+
+	/* back to normal (still 9600) */
+	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2);
+
+	/* send RTS pulses until we reach 115200
+	 * i hope this is really the same for act220l/act220l+ */
+	for(i = 0; i < 3; i++)
+	{
+		udelay(10);
+		/* set RTS low for 10 us */
+		soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
+		udelay(10);
+		/* set RTS high for 10 us */
+		soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	}
+	
+	/* back to normal operation */
+	udelay(1500); /* better safe than sorry ;) */
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);
+
+	/* Set divisor to 1 => 115200 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,1);
+
+	/* Set DLAB 0, 7 Bit */
+	/* The dongle doesn't seem to have any problems with operation
+	   at 7N1 */
+	soutp(UART_LCR, UART_LCR_WLEN7);
+
+	/* enable interrupts */
+	soutp(UART_IER, UART_IER_RDI);
+}
+#endif
+
+static int init_lirc_sir(void)
+{
+	int retval;
+
+	init_waitqueue_head(&lirc_read_queue);
+	retval = init_port();
+	if (retval < 0)
+		return retval;
+	init_hardware();
+	printk(KERN_INFO LIRC_DRIVER_NAME
+		": Installed.\n");
+	return 0;
+}
+
+#ifdef MODULE
+
+int init_module(void)
+{
+	int retval;
+	
+	retval=init_chrdev();
+	if(retval < 0)
+		return retval;
+	retval = init_lirc_sir();
+	if (retval) {
+		drop_chrdev();
+		return retval;
+	}
+	return 0;
+}
+
+void cleanup_module(void)
+{
+	drop_hardware();
+	drop_chrdev();
+	drop_port();
+	printk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");
+}
+
+#ifdef LIRC_SIR_TEKRAM
+MODULE_DESCRIPTION("Infrared receiver driver for Tekram Irmate 210");
+MODULE_AUTHOR("Christoph Bartelmus");
+#elif defined(LIRC_ON_SA1100)
+MODULE_DESCRIPTION("LIRC driver for StrongARM SA1100 embedded microprocessor");
+MODULE_AUTHOR("Christoph Bartelmus");
+#elif defined(LIRC_SIR_ACTISYS_ACT200L)
+MODULE_DESCRIPTION("LIRC driver for Actisys Act200L");
+MODULE_AUTHOR("Karl Bongers");
+#elif defined(LIRC_SIR_ACTISYS_ACT220L)
+MODULE_DESCRIPTION("LIRC driver for Actisys Act220L(+)");
+MODULE_AUTHOR("Jan Roemisch");
+#else
+MODULE_DESCRIPTION("Infrared receiver driver for SIR type serial ports");
+MODULE_AUTHOR("Milan Pikula");
+#endif
+MODULE_LICENSE("GPL");
+
+#ifdef LIRC_ON_SA1100
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "Interrupt (16)");
+#else
+module_param(io, int, 0444);
+MODULE_PARM_DESC(io, "I/O address base (0x3f8 or 0x2f8)");
+
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "Interrupt (4 or 3)");
+
+module_param(threshold, int, 0444);
+MODULE_PARM_DESC(threshold, "space detection threshold (3)");
+#endif
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_stm.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_stm.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_stm.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1052 @@
+/*
+ * LIRC plugin for the STMicroelectronics IRDA devices
+ *
+ * Copyright (C) 2004-2005 STMicroelectronics
+ *
+ * June 2004:  first implementation for a 2.4 Linux kernel
+ *             Giuseppe Cavallaro  <peppe.cavallaro@st.com>
+ * Marc 2005:  review to support pure raw mode and to adapt to Linux 2.6
+ *             Giuseppe Cavallaro  <peppe.cavallaro@st.com>
+ * June 2005:  Change to a MODE2 receive driver and made into a generic
+ *             ST driver.
+ *             Carl Shaw <carl.shaw@st.com>
+ * July 2005:  fix STB7100 MODE2 implementation and improve performance
+ *             of STm8000 version. <carl.shaw@st.com>
+ * Aug  2005:  Added clock autoconfiguration support.  Fixed module exit code.
+ * 	       Added UHF support (kernel build only).
+ * 	       Carl Shaw <carl.shaw@st.com>
+ * Sep  2005:  Added first transmit support
+ *             Added ability to set rxpolarity register
+ * 	       Angelo Castello <angelo.castello@st.com>
+ * 	       and Carl Shaw <carl.shaw@st.com>
+ * Oct  2005:  Added 7100 transmit
+ *             Added carrier width configuration
+ * 	       Carl Shaw <carl.shaw@st.com>
+ * Sept 2006:  Update:
+ * 		fix timing issues (bugzilla 764)
+ * 		Thomas Betker <thomas.betker@siemens.com>
+ * 		allocate PIO pins in driver
+ * 		update transmit
+ * 		improve fault handling on init
+ * 		Carl Shaw <carl.shaw@st.com>
+ * Oct  2007:  Added both lirc-0.8.2 common interface and integrated out IRB driver  
+ *             to be working for linux-2.6.23-rc7. Removed old platform support...
+ *             Sti5528 STb8000. Added new IR rx intq mechanism to reduce the amount 
+ *             intq needed to identify one button. Fix TX transmission loop setting up 
+ *             correctly the irq clean register.
+ * 	       Angelo Castello <angelo.castello@st.com>
+ *
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/clock.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/time.h>
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+/* General debugging */
+#undef LIRC_STM_DEBUG
+
+/* TX wait queue */
+static DECLARE_WAIT_QUEUE_HEAD(tx_waitq);
+
+#ifdef  LIRC_STM_DEBUG
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+/*
+ * Infra Red: hardware register map
+ */
+#if defined(CONFIG_IRB_RECEIVER) || defined(MODULE)
+static int ir_uhf_switch = 0;
+#else
+static int ir_uhf_switch = 1;
+#endif
+
+static int ir_or_uhf_offset = 0;	/* = 0 for IR mode */
+static int irb_irq = 0;		/* IR block irq */
+static void *irb_base_address;	/* IR block register base address */
+
+/* RX timing fine control */
+static int rx_symbol_mult;
+static int rx_symbol_div;
+static int rx_pulse_mult;
+static int rx_pulse_div;
+
+/* TX timing fine control */
+static unsigned int tx_mult;
+static unsigned int tx_div;
+static unsigned int tx_carrier_freq = 38000;	// in Hz
+
+
+/* IR transmitter registers */
+#define IRB_TX_PRESCALAR		(irb_base_address + 0x00)	/* clock prescalar */
+#define IRB_TX_SUBCARRIER		(irb_base_address + 0x04)	/* subcarrier frequency */
+#define IRB_TX_SYMPERIOD		(irb_base_address + 0x08)	/* symbol period (space + pulse) */
+#define IRB_TX_ONTIME			(irb_base_address + 0x0c)	/* symbol pulse time */
+#define IRB_TX_INT_ENABLE		(irb_base_address + 0x10)	/* TX irq enable */
+#define IRB_TX_INT_STATUS		(irb_base_address + 0x14)	/* TX irq status */
+#define IRB_TX_ENABLE			(irb_base_address + 0x18)	/* TX enable */
+#define IRB_TX_INT_CLEAR		(irb_base_address + 0x1c)	/* TX interrupt clear */
+#define IRB_TX_SUBCARRIER_WIDTH		(irb_base_address + 0x20)	/* subcarrier frequency width */
+#define IRB_TX_STATUS			(irb_base_address + 0x24)	/* TX status */
+
+#define TX_INT_PENDING			0x01
+#define TX_INT_UNDERRUN			0x02
+
+#define TX_FIFO_DEPTH			7
+#define TX_FIFO_USED			((readl(IRB_TX_STATUS) >> 8) & 0x07)
+
+/* IR receiver registers */
+#define IRB_RX_ON	    		(irb_base_address + 0x40 + ir_or_uhf_offset)	/* RX pulse time capture */
+#define IRB_RX_SYS          		(irb_base_address + 0x44 + ir_or_uhf_offset)	/* RX sym period capture */
+#define IRB_RX_INT_EN	    		(irb_base_address + 0x48 + ir_or_uhf_offset)	/* RX IRQ enable (R/W)   */
+#define IRB_RX_INT_STATUS      		(irb_base_address + 0x4C + ir_or_uhf_offset)	/* RX IRQ status (R/W)   */
+#define IRB_RX_EN	    		(irb_base_address + 0x50 + ir_or_uhf_offset)	/* Receive enable (R/W)  */
+#define IRB_MAX_SYM_PERIOD  		(irb_base_address + 0x54 + ir_or_uhf_offset)	/* end of sym. max value */
+#define IRB_RX_INT_CLEAR 		(irb_base_address + 0x58 + ir_or_uhf_offset)	/* overrun status (W)    */
+#define IRB_RX_STATUS	    		(irb_base_address + 0x6C + ir_or_uhf_offset)	/* receive status        */
+#define IRB_RX_NOISE_SUPPR  		(irb_base_address + 0x5C + ir_or_uhf_offset)	/* noise suppression     */
+#define IRB_RX_POLARITY_INV 		(irb_base_address + 0x68 + ir_or_uhf_offset)	/* polarity inverter     */
+
+/* IRB and UHF common registers */
+#define IRB_RX_RATE_COMMON   		(irb_base_address + 0x64)	/* sampling frequency divisor */
+#define IRB_RX_CLOCK_SELECT  		(irb_base_address + 0x70)	/* clock selection (for low-power mode) */
+#define IRB_RX_CLOCK_SELECT_STATUS 	(irb_base_address + 0x74)	/* clock selection status */
+#define IRB_RX_NOISE_SUPP_WIDTH 	(irb_base_address + 0x9C)
+
+#define LIRC_STM_NAME	"lirc_stm"
+#define LIRC_STM_MINOR		0
+
+/* SOC dependent section - these values are set in the appropriate 
+ * arch/sh/kernel/cpu/sh4/setup-* files and
+ * transfered when the lirc device is opened
+ */
+
+static unsigned int rx_fifo_has_data = 0;
+static unsigned int rx_clear_overrun = 0;
+static unsigned int rx_overrun_err = 0;
+static unsigned int rx_sampling_freq_div = 0;
+static unsigned int rx_enable_irq = 0;
+#define RX_CLEAR_IRQ(x) writel((x), IRB_RX_INT_CLEAR)
+#define HOW_MANY_WORDS_IN_FIFO() (readl(IRB_RX_STATUS) & 0x0700 )
+
+/* Definition of a single RC symbol */
+typedef struct symbol_s {
+	unsigned int PulseUs;
+	unsigned int SpaceUs;
+} symbol_t;
+
+/* InfraRed receive control structure */
+#define MAX_SYMBOLS	100
+struct st_plugin_data_t {
+	int open_count;		/* INC at any open                      */
+	int error;		/* true if receive error.. skip symbols */
+	int symbols;		/* how many symbols in buf..            */
+	symbol_t buf[MAX_SYMBOLS];
+	struct timeval sync;	/* start of sync space */
+	unsigned int sumUs;	/* sum of symbols */
+} pd;
+
+/* IR transmit buffer */
+static lirc_t wbuf[MAX_SYMBOLS];
+static volatile int off_wbuf = 0;
+
+/* LIRC subsytem symbol buffer */
+struct lirc_buffer stlirc_buffer;	/* managed only via common lirc routines */
+/* user process read symbols from here  */
+
+static inline void reset_irq_data(struct st_plugin_data_t *pd)
+{
+	pd->error = 0;
+	pd->symbols = 0;
+	memset((unsigned char *)pd->buf, 0, sizeof(pd->buf));
+	pd->sumUs = 0;
+}
+
+#ifdef LIRC_STM_DEBUG
+/* For debug only: in memory structure to trace interrupt
+ * status registers and symbols timing received.
+ */
+#define MAX_IRD		200
+typedef struct ird_t {
+	unsigned int a_intsta;
+	unsigned int b_intsta;
+	unsigned int c_intsta;
+	unsigned int a_status;
+	unsigned int b_status;
+	unsigned int sym;
+	unsigned int mark;
+	unsigned int sr;
+} ird_t;
+static int ird_valid = -1;
+static ird_t ird[MAX_IRD];
+
+static void trace_prt(void)
+{
+	int i;
+
+	if (ird_valid == -1)
+		return;
+
+	DPRINTK
+	    ("  #   IRQst  stats      S      M   IRQst  stats  IRQst   s.r\n");
+	for (i = 0; i < ird_valid; i++)
+		DPRINTK
+		    ("%3d    %04x  %04x   %5d  %5d    %04x   %04x   %04x   %3d\n",
+		     i, ird[i].a_intsta, ird[i].a_status, ird[i].sym,
+		     ird[i].mark, ird[i].b_intsta, ird[i].b_status,
+		     ird[i].c_intsta, ird[i].sr);
+	memset(ird, 0, sizeof(ird));
+	ird_valid = -1;
+}
+
+#define TRACEA(a,b)   { if (ird_valid >= MAX_IRD) \
+				ird_valid = -1; \
+			ird_valid++; \
+			ird[ird_valid].a_intsta = (a); \
+			ird[ird_valid].a_status = (b); }
+#define TRACES(a,b,c) { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+			{\
+				ird[ird_valid].sym  = (a); \
+				ird[ird_valid].mark = (b); \
+				ird[ird_valid].sr   = (c); \
+			}\
+		      }
+#define TRACEC(a,b)   { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+	                {\
+				ird[ird_valid].b_intsta = (a); \
+				ird[ird_valid].b_status = (b); \
+			}\
+		      }
+#define TRACEE(a)     { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+				ird[ird_valid].c_intsta = (a); }
+#define TRACE_PRT()     trace_prt();
+#else
+#define TRACEA(a,b)
+#define TRACES(a,b,c)
+#define TRACEC(a,b)
+#define TRACEE(a)
+#define TRACE_PRT()
+
+#endif
+
+static inline unsigned int lirc_stm_time_to_cycles(unsigned int microsecondtime)
+{
+	/* convert a microsecond time to the nearest number of subcarrier clock
+	 * cycles
+	 */
+	microsecondtime *= tx_mult;
+	microsecondtime /= tx_div;
+	return (microsecondtime * tx_carrier_freq / 1000000);
+}
+
+static void lirc_stm_tx_interrupt(int irq, void *dev_id)
+{
+	unsigned int symbol, mark, done = 0;
+	unsigned int tx_irq_status = readl(IRB_TX_INT_STATUS);
+        
+	if ((tx_irq_status & TX_INT_PENDING) != TX_INT_PENDING) 
+            return;
+
+        while (done == 0) {
+            if ((readl(IRB_TX_INT_STATUS) & TX_INT_UNDERRUN) ==
+                TX_INT_UNDERRUN) {
+                /* There has been an underrun - clear flag, switch
+                 * off transmitter and signal possible exit
+                 */
+                printk(KERN_ERR "lirc_stm: transmit underrun!\n");
+                writel(0x02, IRB_TX_INT_CLEAR);
+                writel(0x00, IRB_TX_INT_ENABLE);
+                writel(0x00, IRB_TX_ENABLE);
+                done = 1;
+                DPRINTK("disabled TX\n");
+                wake_up_interruptible(&tx_waitq);
+            } else {
+                int fifoslots = TX_FIFO_USED;
+
+                while (fifoslots < TX_FIFO_DEPTH) {
+                    mark = wbuf[(off_wbuf * 2)];
+                    symbol = mark + wbuf[(off_wbuf * 2) + 1];
+                    DPRINTK("TX raw m %d s %d ", mark, symbol);
+
+                    mark =lirc_stm_time_to_cycles(mark) + 1;
+                    symbol =lirc_stm_time_to_cycles(symbol) + 2;
+                    DPRINTK("cal m %d s %d\n", mark, symbol);
+
+                    if ((wbuf[(off_wbuf * 2)] == 0xFFFF) || 
+                        (wbuf[(off_wbuf * 2) + 1] == 0xFFFF)) 
+                    {
+                        /* Dump out last symbol */
+                        writel(mark * 2, IRB_TX_SYMPERIOD);
+                        writel(mark, IRB_TX_ONTIME);
+
+                        DPRINTK("TX end m %d s %d\n", mark, mark * 2);
+
+                        /* flush transmit fifo */
+                        while (TX_FIFO_USED != 0) {
+                        };
+                        writel(0, IRB_TX_SYMPERIOD);
+                        writel(0, IRB_TX_ONTIME);
+                        /* spin until TX fifo empty */
+                        while (TX_FIFO_USED != 0) {
+                        };
+                        /* disable tx interrupts and transmitter */
+                        writel(0x07, IRB_TX_INT_CLEAR);
+                        writel(0x00, IRB_TX_INT_ENABLE);
+                        writel(0x00, IRB_TX_ENABLE);
+                        DPRINTK("TX disabled\n");
+                        off_wbuf = 0;
+                        fifoslots = 999;
+                        done = 1;
+                    } else {
+                        writel(symbol,IRB_TX_SYMPERIOD);
+                        writel(mark, IRB_TX_ONTIME);
+
+                        DPRINTK("Nm %d s %d\n", mark, symbol);
+
+                        off_wbuf++;
+                        fifoslots = TX_FIFO_USED;
+                    }
+                }
+            }
+        }
+}
+
+static void lirc_stm_rx_interrupt(int irq, void *dev_id)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)dev_id;
+	unsigned int symbol, mark = 0;
+	int lastSymbol, clear_irq = 1;
+
+	for (;;) {
+		/* if received FIFO is empty exit from loop */
+		/* also deal with fifo underrun interrupt */
+		if (HOW_MANY_WORDS_IN_FIFO() == 0) {
+			RX_CLEAR_IRQ(rx_fifo_has_data | 0x02);
+                        writel(rx_enable_irq, IRB_RX_INT_EN);
+                        clear_irq = 1;
+			break;
+		} else {
+			unsigned int rx_irq_status = readl(IRB_RX_INT_STATUS);
+
+			/* discard the entire collection in case of errors!  */
+			if (rx_irq_status & rx_overrun_err) {
+				printk(KERN_INFO "IR overrun\n");
+				writel(rx_clear_overrun, IRB_RX_INT_CLEAR);
+				pd->error = 1;
+			}
+
+			TRACEA(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
+
+			/* get the symbol times from FIFO */
+			symbol = (readl(IRB_RX_SYS));
+			mark = (readl(IRB_RX_ON));
+
+                        if (clear_irq) {
+                            /*  Clear the interrupt (not required for some boards) 
+                             * and take only the underrun irq enabled */
+                            RX_CLEAR_IRQ(rx_fifo_has_data);
+                            writel(0x04, IRB_RX_INT_EN);
+                            clear_irq = 0;
+                        }
+
+			if (pd->symbols >= MAX_SYMBOLS) {
+				printk("IR too many symbols (max %d)\n",
+				       MAX_SYMBOLS);
+				pd->error = 1;
+			}
+
+			/* now handle the data depending on error condition */
+			if (pd->error) {
+				/*  Try again */
+				reset_irq_data(pd);
+				continue;
+			}
+                        if (symbol == 0xFFFF)
+                             lastSymbol = 1;
+                        else lastSymbol = 0;
+
+			/* A sequence seems to start with a constant time symbol (1us)
+			 * pulse and symbol time length, both of 1us. We ignore this.
+			 */
+			if ((mark > 2) && (symbol > 1)) {
+				TRACES(symbol, mark, pd->symbols);
+
+				/* Make fine adjustments to timings */
+				symbol -= mark;	/* to get space timing */
+				symbol *= rx_symbol_mult;
+				symbol /= rx_symbol_div;
+				mark *= rx_pulse_mult;
+				mark /= rx_pulse_div;
+
+				/* The ST hardware returns the pulse time and the period, which is
+				 * the pulse time + space time, so we need to subtract the pulse time from
+				 * the period to get the space time.
+				 * For a pulse in LIRC MODE2, we need to set the PULSE_BIT ON
+				 */
+				pd->buf[pd->symbols].PulseUs = mark | PULSE_BIT;
+				pd->buf[pd->symbols].SpaceUs = symbol;
+				pd->sumUs += mark + symbol;
+				pd->symbols++;
+
+				if (lastSymbol) {
+                                    /* move the entire collection into user buffer if enough
+                                     * space, drop it otherwise (perhaps too crude a recovery?)
+                                     */
+                                    if (lirc_buffer_available(&stlirc_buffer) >=
+                                        (2 * pd->symbols)) {
+                                        struct timeval now;
+                                        lirc_t syncSpace;
+
+                                        DPRINTK("W symbols = %d\n", pd->symbols);
+
+                                        /*  Calculate and write the leading space
+                                         *  All spaces and pulses together sum up to the microseconds
+                                         *  elapsed since we sent the previous block of data
+                                         */
+                                        do_gettimeofday(&now);
+                                        if (now.tv_sec - pd->sync.tv_sec < 0)
+                                            syncSpace = 0;
+                                        else if (now.tv_sec - pd->sync.tv_sec
+							 > PULSE_MASK / 1000000)
+                                            syncSpace = PULSE_MASK;
+                                        else {
+                                            syncSpace = (now.tv_sec - pd->sync.tv_sec) * 
+                                                1000000	+ (now.tv_usec -pd->sync.tv_usec);
+                                            syncSpace-= (pd->sumUs - pd->buf[pd->symbols - 1].SpaceUs);
+                                            if (syncSpace < 0)
+                                                syncSpace = 0;
+                                            else if (syncSpace > PULSE_MASK)
+                                                syncSpace = PULSE_MASK;
+                                        }
+                                        lirc_buffer_write_1(&stlirc_buffer,
+                                                            (unsigned char *)&syncSpace);
+                                        pd->sync = now;
+
+                                        /*  Now write the pulse / space pairs EXCEPT FOR THE LAST SPACE
+                                         *  The last space value should be 0xFFFF to denote a timeout
+                                         */
+                                        lirc_buffer_write_n(&stlirc_buffer,
+                                                            (unsigned char *)pd->buf,
+                                                            (2 * pd->symbols) - 1);
+						wake_up(&stlirc_buffer.wait_poll);
+					} else
+						printk(KERN_ERR
+						       "Not enough space in user buffer\n");
+
+					TRACE_PRT();
+					reset_irq_data(pd);
+				}
+			}
+			TRACEC(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
+		} /* receive handler */
+	}
+
+	TRACEE(readl(IRB_RX_INT_STATUS));
+}
+
+static irqreturn_t lirc_stm_interrupt(int irq, void *dev_id)
+{
+	lirc_stm_tx_interrupt(irq, dev_id);
+
+	lirc_stm_rx_interrupt(irq, dev_id);
+
+	return IRQ_HANDLED;
+}
+
+static int stm_set_use_inc(void *data)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
+
+	DPRINTK("entering (open N. %d)\n", pd->open_count);
+
+	/* enable the device only at the first open */
+	if (pd->open_count++ == 0) {
+		unsigned long flags;
+		DPRINTK("Enabled\n");
+		local_irq_save(flags);
+
+		/* enable interrupts and receiver */
+		writel(rx_enable_irq, IRB_RX_INT_EN);
+		writel(0x01, IRB_RX_EN);
+		reset_irq_data(pd);
+		pd->sync.tv_sec = 0;
+		pd->sync.tv_usec = 0;
+		local_irq_restore(flags);
+	} else
+		DPRINTK("Already open\n");
+
+	return 0;
+}
+
+static void flush_stm_lirc(struct st_plugin_data_t *pd)
+{
+        /* Disable receiver */ 
+	writel(0x00, IRB_RX_EN);
+        /* TBD: set one word in FIFO ??? and disable interrupt */
+        writel(0x20, IRB_RX_INT_EN);
+        /* clean the buffer */
+	reset_irq_data(pd);
+}
+
+/*
+** Called by lirc_dev as a last action on a real close
+*/
+static void stm_set_use_dec(void *data)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
+	DPRINTK("entering (close N. %d)\n", pd->open_count);
+
+	/* The last close disable the receiver */
+	if (--pd->open_count == 0)
+		flush_stm_lirc(pd);
+	TRACE_PRT();
+}
+
+static int lirc_stm_ioctl(struct inode *node, struct file *filep,
+			  unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+	char *msg = "";
+
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+		/*
+		 * Our driver can receive in mode2 and send in pulse mode.
+		 * TODO: We can generate our own carrier freq (LIRC_CAN_SET_SEND_CARRIER)
+		 *       and also change duty cycle (LIRC_CAN_SET_SEND_DUTY_CYCLE)
+		 */
+		DPRINTK("LIRC_GET_FEATURES return REC_MODE2|SEND_PULSE\n");
+		retval = put_user(LIRC_CAN_REC_MODE2 |
+				  LIRC_CAN_SEND_PULSE, (unsigned long *)arg);
+		break;
+
+	case LIRC_GET_REC_MODE:
+		DPRINTK("LIRC_GET_REC_MODE return LIRC_MODE_MODE2\n");
+		retval = put_user(LIRC_MODE_MODE2, (unsigned long *)arg);
+		break;
+
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *)arg);
+		DPRINTK("LIRC_SET_REC_MODE to 0x%lx\n", value);
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+		break;
+
+	case LIRC_GET_SEND_MODE:
+		DPRINTK("LIRC_GET_SEND_MODE return LIRC_MODE_PULSE\n");
+		retval = put_user(LIRC_MODE_PULSE, (unsigned long *)arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+		retval = get_user(value, (unsigned long *)arg);
+		DPRINTK("LIRC_SET_SEND_MODE to 0x%lx\n", value);
+		/* only LIRC_MODE_PULSE supported */
+		if (value != LIRC_MODE_PULSE)
+			return (-ENOSYS);
+		break;
+
+	case LIRC_GET_REC_RESOLUTION:
+		msg = "LIRC_GET_REC_RESOLUTION";
+		goto _not_supported;
+
+	case LIRC_GET_REC_CARRIER:
+		msg = "LIRC_GET_REC_CARRIER";
+		goto _not_supported;
+
+	case LIRC_SET_REC_CARRIER:
+		msg = "LIRC_SET_REC_CARRIER";
+		goto _not_supported;
+
+	case LIRC_GET_SEND_CARRIER:
+		msg = "LIRC_GET_SEND_CARRIER";
+		goto _not_supported;
+
+	case LIRC_SET_SEND_CARRIER:
+		msg = "LIRC_SET_SEND_CARRIER";
+		goto _not_supported;
+
+	case LIRC_GET_REC_DUTY_CYCLE:
+		msg = "LIRC_GET_REC_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_SET_REC_DUTY_CYCLE:
+		msg = "LIRC_SET_REC_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_GET_SEND_DUTY_CYCLE:
+		msg = "LIRC_GET_SEND_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		msg = "LIRC_SET_SEND_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_GET_LENGTH:
+		msg = "LIRC_GET_LENGTH";
+		goto _not_supported;
+
+	default:
+		msg = "???";
+	      _not_supported:
+		DPRINTK("command %s (0x%x) not supported\n", msg, cmd);
+		retval = -ENOIOCTLCMD;
+	}
+
+	return retval;
+}
+
+static ssize_t lirc_stm_write(struct file *file, const char *buf,
+			      size_t n, loff_t * ppos)
+{
+	int i;
+	size_t rdn = n / sizeof(size_t);
+	unsigned int symbol, mark;
+	int fifosyms;
+
+	if (n % sizeof(lirc_t))
+		return -EINVAL;
+
+	if (off_wbuf != 0 && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+
+	/* Wait for transmit to become free... */
+	if (wait_event_interruptible(tx_waitq, off_wbuf == 0))
+		return -ERESTARTSYS;
+
+	/* Prevent against buffer overflow... */
+	if (rdn > MAX_SYMBOLS) rdn = MAX_SYMBOLS;
+
+	n -= rdn * sizeof(size_t);
+
+	if (copy_from_user((char *)wbuf, buf, rdn * sizeof(size_t))) {
+		return -EFAULT;
+	}
+
+	if (n == 0) wbuf[rdn - 1] = 0xFFFF;
+
+	/* load the first words into the FIFO */
+	fifosyms = rdn;
+
+	if (fifosyms > TX_FIFO_DEPTH)
+		fifosyms = TX_FIFO_DEPTH;
+
+	for (i = 0; i < fifosyms; i++) {
+            mark = wbuf[(i * 2)];
+            symbol = mark + wbuf[(i * 2) + 1];
+            DPRINTK("TX raw m %d s %d ", mark, symbol);
+
+            mark = lirc_stm_time_to_cycles(mark) + 1;
+            symbol = lirc_stm_time_to_cycles(symbol) + 2;
+            DPRINTK("cal m %d s %d\n", mark, symbol);
+
+            off_wbuf++;
+            writel(mark, IRB_TX_ONTIME);
+            writel(symbol, IRB_TX_SYMPERIOD);
+	}
+
+	/* enable the transmit */
+	writel(0x07, IRB_TX_INT_ENABLE);
+	writel(0x01, IRB_TX_ENABLE);
+        DPRINTK("TX enabled\n");
+
+	return n;
+}
+
+static void lirc_stm_calc_tx_clocks(unsigned int clockfreq,
+				    unsigned int carrierfreq,
+				    unsigned int subwidthpercent)
+{
+	/*  We know the system base clock and the required IR carrier frequency
+	 *  We now want a divisor of the system base clock that gives the nearest
+	 *  integer multiple of the carrier frequency
+	 */
+
+	const unsigned int clkratio = clockfreq / carrierfreq;
+	unsigned int scalar, n;
+	int delta;
+	unsigned int diffbest = clockfreq, nbest = 0, scalarbest = 0;
+	unsigned int nmin = clkratio / 255;
+
+	if ((nmin & 0x01) == 1)
+		nmin++;
+
+	for (n = nmin; n < clkratio; n += 2) {
+		scalar = clkratio / n;
+		if ((scalar & 0x01) == 0 && scalar != 0) {
+			delta = clockfreq - (scalar * carrierfreq * n);
+			if (delta < 0)
+				delta *= -1;
+
+			if (delta < diffbest) {	/* better set of parameters ? */
+				diffbest = delta;
+				nbest = n;
+				scalarbest = scalar;
+			}
+			if (delta == 0)	/* an exact multiple */
+				break;
+		}
+	}
+
+	scalarbest /= 2;
+	nbest *= 2;
+
+	DPRINTK("TX clock scalar = %d\n", scalarbest);
+	DPRINTK("TX subcarrier scalar = %d\n", nbest);
+
+	/*  Set the registers now  */
+
+	writel(scalarbest, IRB_TX_PRESCALAR);
+	writel(nbest, IRB_TX_SUBCARRIER);
+	writel(nbest * subwidthpercent / 100, IRB_TX_SUBCARRIER_WIDTH);
+
+	/*  Now calculate timing to subcarrier cycles factors which compensate for
+	 *  any remaining difference between our clock ratios and real times in
+	 *  microseconds
+	 */
+
+	if (diffbest == 0) {
+		/* no adjustment required - our clock is running at the required speed */
+		tx_mult = 1;
+		tx_div = 1;
+	} else {
+		/* adjustment is required */
+		delta = scalarbest * carrierfreq * nbest;
+		tx_mult = delta / (clockfreq / 10000);
+
+		if (delta < clockfreq) {	/* our clock is running too fast */
+			DPRINTK("Clock running slow at %d\n", delta);
+			tx_div = tx_mult;
+			tx_mult = 10000;
+		} else {	/* our clock is running too slow */
+
+			DPRINTK("Clock running fast at %d\n", delta);
+			tx_div = 10000;
+		}
+	}
+
+	DPRINTK("TX fine adjustment mult = %d\n", tx_mult);
+	DPRINTK("TX fine adjustment div  = %d\n", tx_div);
+}
+
+static struct file_operations lirc_stm_fops = {
+      write:lirc_stm_write,
+};
+
+static struct lirc_plugin lirc_stm_plugin = {
+	.name  = LIRC_STM_NAME,
+	.minor = LIRC_STM_MINOR,
+	.code_length = 1,
+	.sample_rate = 0,
+	/* plugin can receive raw pulse and space timings for each symbol */
+	.features = LIRC_CAN_REC_MODE2,
+	/* plugin private data  */
+	.data = (void *)&pd,
+	/* buffer handled by upper layer */
+	.add_to_buf = NULL,
+	.get_queue = NULL,
+	.set_use_inc = stm_set_use_inc,
+	.set_use_dec = stm_set_use_dec,
+	.ioctl = lirc_stm_ioctl,
+	.fops = &lirc_stm_fops,
+	.rbuf = &stlirc_buffer,
+	.owner = THIS_MODULE,
+};
+
+static int __init lirc_stm_init(void)
+{
+	int ret = -EINVAL;
+	struct platform_device *lirc_plat_dev = NULL;
+	struct plat_lirc_data *lirc_private_data = NULL;
+	struct resource *res;
+	int baseclock;
+	int piopins;
+	unsigned int scwidth;
+	struct clk *clk;
+	struct lirc_pio *p;
+
+	DPRINTK("initializing the IR receiver...\n");
+
+	/* inform the top level driver that we use our own user buffer */
+	if (lirc_buffer_init(&stlirc_buffer, sizeof(lirc_t), (2 * MAX_SYMBOLS))) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: buffer init failed\n");
+		goto lirc_out4;
+	}
+
+	request_module("lirc_dev");
+	if ((ret = lirc_register_plugin(&lirc_stm_plugin)) < 0) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: plug-in registration failed\n");
+		goto lirc_out4;
+	}
+
+	/*  At this point, we need to get a pointer to the platform-specific data */
+	if ((lirc_plat_dev = (struct platform_device *)lirc_get_config()) == NULL) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: platform data not found\n");
+		goto lirc_out4;
+	}
+
+	/* Request the IRQ */
+	if ((irb_irq = platform_get_irq(lirc_plat_dev, 0)) == 0) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: IRQ configuration not found\n");
+		ret = -ENODEV;
+		goto lirc_out4;
+	}
+
+	if ((ret = request_irq(irb_irq, lirc_stm_interrupt, IRQF_SHARED,
+			       LIRC_STM_NAME, (void *)&pd)) < 0) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: IRQ register failed\n");
+		ret = -EIO;
+		goto lirc_out4;
+	}
+
+	/* Configure for ir or uhf. ir_uhf_switch==1 is IRB */
+	if (ir_uhf_switch) 
+             ir_or_uhf_offset = 0x40;
+	else ir_or_uhf_offset = 0x00;
+
+	printk(KERN_INFO "lirc_stm: STM LIRC plugin has IRQ %d using %s mode\n", 
+               irb_irq, (ir_or_uhf_offset == 0 ? "IRB" : "UHF"));
+
+	/* Hardware IR block setup - the PIO ports should already be set up
+	 * in the board-dependent configuration.  We need to remap the
+	 * IR registers into kernel space - we do this in one chunk
+	 */
+
+	res = platform_get_resource(lirc_plat_dev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR "lirc_stm: lirc_stm_init: IO MEM not found\n");
+		ret = -ENODEV;
+		goto lirc_out3;
+	}
+
+	if (!request_mem_region(res->start, 
+                                res->end - res->start, 
+                                LIRC_STM_NAME)) {
+		printk(KERN_ERR
+		       "lirc_stm: lirc_stm_init: request_mem_region failed\n");
+		ret = -EBUSY;
+		goto lirc_out3;
+	}
+
+	irb_base_address = ioremap(res->start, res->end - res->start);
+	if (irb_base_address == NULL) {
+		printk(KERN_ERR "lirc_stm: lirc_stm_init: ioremap failed\n");
+		release_mem_region(res->start, res->end - res->start);
+		ret = -ENOMEM;
+		goto lirc_out2;
+	}
+
+	DPRINTK(KERN_INFO "ioremapped register block at 0x%lx\n", res->start);
+	DPRINTK(KERN_INFO "ioremapped to 0x%x\n",
+		(unsigned int)irb_base_address);
+
+	/*  set up the hardware version dependent setup parameters */
+	lirc_private_data = (struct plat_lirc_data *)lirc_plat_dev->dev.platform_data;
+
+	/* Allocate the PIO pins */
+	piopins = lirc_private_data->num_pio_pins;
+	while (piopins > 0) {
+		p = &(lirc_private_data->pio_pin_arr[piopins - 1]);
+		if (!(p->pinaddr = stpio_request_pin(p->bank, 
+                                                     p->pin,
+						     LIRC_STM_NAME, 
+                                                     p->dir))) {
+			printk(KERN_ERR
+			       "lirc_stm: lirc_stm_init: STPIO[%d,%d] request failed\n",
+			       p->bank, p->pin);
+			ret = -EBUSY;
+			goto lirc_out1;
+		}
+		piopins--;
+	}
+
+	/* Set the polarity inversion bit to the correct state */
+	writel(lirc_private_data->rxpolarity, IRB_RX_POLARITY_INV);
+
+	rx_overrun_err   = 0x04;
+        rx_fifo_has_data = 0x38;
+        rx_clear_overrun = 0x04;
+        /* IRQ set: Enable full FIFO                 1  -> bit  3;
+         *          Enable overrun IRQ               1  -> bit  2;
+         *          Enable last symbol IRQ           1  -> bit  1:
+         *          Enable RX interrupt              1  -> bit  0;
+         */
+        rx_enable_irq = 0x0f;
+
+	/*  Get or calculate the clock and timing adjustment values.
+	 *  We can auto-calculate these in some cases
+	 */
+
+	if (lirc_private_data->irbclock == 0) {
+		clk = clk_get(NULL, "comms_clk");
+		baseclock = clk_get_rate(clk) / lirc_private_data->sysclkdiv;
+	} else
+		baseclock = lirc_private_data->irbclock;
+
+	if (lirc_private_data->irbclkdiv == 0) {
+		/* Auto-calculate clock divisor */
+
+		int freqdiff;
+
+		rx_sampling_freq_div = baseclock / 10000000;
+
+		/* Work out the timing adjustment factors */
+		freqdiff = baseclock - (rx_sampling_freq_div * 10000000);
+
+		/* freqdiff contains the difference between our clock and a
+		 * true 10 MHz clock which the IR block wants
+		 */
+
+		if (freqdiff == 0) {
+			/* no adjustment required - our clock is running at the required speed */
+			rx_symbol_mult = 1;
+			rx_pulse_mult = 1;
+			rx_symbol_div = 1;
+			rx_pulse_div = 1;
+		} else {
+			/* adjustment is required */
+			rx_symbol_mult =
+			    baseclock / (10000 * rx_sampling_freq_div);
+
+			if (freqdiff > 0) {
+				/* our clock is running too fast */
+				rx_pulse_mult = 1000;
+				rx_pulse_div = rx_symbol_mult;
+				rx_symbol_mult = rx_pulse_mult;
+				rx_symbol_div = rx_pulse_div;
+			} else {
+				/* our clock is running too slow */
+				rx_symbol_div = 1000;
+				rx_pulse_mult = rx_symbol_mult;
+				rx_pulse_div = 1000;
+			}
+
+		}
+
+	} else {
+		rx_sampling_freq_div = (lirc_private_data->irbclkdiv);
+		rx_symbol_mult = (lirc_private_data->irbperiodmult);
+		rx_symbol_div = (lirc_private_data->irbperioddiv);
+		rx_pulse_mult = (lirc_private_data->irbontimemult);
+		rx_pulse_div = (lirc_private_data->irbontimediv);
+	}
+
+	writel(rx_sampling_freq_div, IRB_RX_RATE_COMMON);
+	DPRINTK(KERN_INFO "IRB clock is %d\n", baseclock);
+	DPRINTK(KERN_INFO "IRB clock divisor is %d\n", rx_sampling_freq_div);
+	DPRINTK(KERN_INFO "IRB clock divisor readlack is %d\n",
+		readl(IRB_RX_RATE_COMMON));
+	DPRINTK(KERN_INFO "IRB period mult factor is %d\n", rx_symbol_mult);
+	DPRINTK(KERN_INFO "IRB period divisor factor is %d\n", rx_symbol_div);
+	DPRINTK(KERN_INFO "IRB pulse mult factor is %d\n", rx_pulse_mult);
+	DPRINTK(KERN_INFO "IRB pulse divisor factor is %d\n", rx_pulse_div);
+
+        {
+            /* maximum symbol period.  
+             * Symbol periods longer than this will generate
+             * an interrupt and terminate a command
+             */
+            unsigned int rx_max_symbol_per;
+            if ((lirc_private_data->irbrxmaxperiod) != 0)
+		rx_max_symbol_per =
+		    (lirc_private_data->irbrxmaxperiod) * rx_symbol_mult /
+		    rx_symbol_div;
+            else
+		rx_max_symbol_per = 0;
+
+            DPRINTK(KERN_INFO "IRB RX Maximum symbol period register 0x%x\n",
+                    rx_max_symbol_per);
+            writel(rx_max_symbol_per, IRB_MAX_SYM_PERIOD);
+        }
+        
+	/*  Set up the transmit timings  */
+	if (lirc_private_data->subcarrwidth != 0)
+		scwidth = lirc_private_data->subcarrwidth;
+	else
+		scwidth = 50;
+
+	if (scwidth > 100)
+		scwidth = 50;
+
+	DPRINTK(KERN_INFO "Subcarrier width set to %d %%\n", scwidth);
+	lirc_stm_calc_tx_clocks(baseclock, tx_carrier_freq, scwidth);
+
+	printk(KERN_INFO "STMicroelectronics LIRC driver configured\n");
+
+	return 0;
+
+      lirc_out1:
+	while (piopins < lirc_private_data->num_pio_pins)
+		stpio_free_pin(lirc_private_data->pio_pin_arr[piopins++].
+			       pinaddr);
+	iounmap(irb_base_address);
+      lirc_out2:
+	release_mem_region(res->start, res->end - res->start);
+      lirc_out3:
+	free_irq(irb_irq, (void *)&pd);
+      lirc_out4:
+	return ret;
+}
+
+void __exit lirc_stm_release(void)
+{
+	int ret_value, piopins;
+	struct resource *res;
+	struct platform_device *lirc_plat_dev = NULL;
+	struct plat_lirc_data *lirc_private_data = NULL;
+
+	DPRINTK("removing STM lirc plugin\n");
+
+	flush_stm_lirc(&pd);
+
+        /* unplug the lirc stm driver */
+	if ((ret_value = lirc_unregister_plugin(LIRC_STM_MINOR)) < 0)
+		printk(KERN_ERR "STM InfraRed plug-in unregister failed\n");
+
+	iounmap(irb_base_address);
+
+        /* deallocate the STPIO pins */
+	lirc_plat_dev = (struct platform_device *)lirc_get_config();
+	lirc_private_data = (struct plat_lirc_data *)lirc_plat_dev->dev.platform_data;
+	piopins = lirc_private_data->num_pio_pins;
+	while (piopins > 0)
+		stpio_free_pin(lirc_private_data->pio_pin_arr[--piopins].
+			       pinaddr);
+
+        /* release platform resource */
+	res = platform_get_resource(lirc_plat_dev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start);
+
+	free_irq(irb_irq, (void *)&pd);
+	printk(KERN_INFO "STMicroelectronics LIRC driver removed\n");
+}
+
+module_param(ir_uhf_switch, bool, 0644);
+MODULE_PARM_DESC(ir_uhf_switch, "Enable uhf mode");
+
+module_init(lirc_stm_init);
+module_exit(lirc_stm_release);
+MODULE_DESCRIPTION
+    ("Linux InfraRed receiver plugin for STMicroelectronics platforms");
+MODULE_AUTHOR("Carl Shaw <carl.shaw@st.com>");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_streamzap.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_streamzap.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_streamzap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_streamzap.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,936 @@
+/*      $Id: lirc_streamzap.c,v 1.22 2007/04/29 14:23:04 lirc Exp $      */
+
+/*
+ * Streamzap Remote Control driver
+ *
+ * Copyright (c) 2005 Christoph Bartelmus <lirc@bartelmus.de>
+ * 
+ * This driver was based on the work of Greg Wickham and Adrian
+ * Dewhurst. It was substantially rewritten to support correct signal
+ * gaps and now maintains a delay buffer, which is used to present
+ * consistent timing behaviour to user space applications. Without the
+ * delay buffer an ugly hack would be required in lircd, which can
+ * cause sluggish signal decoding in certain situations.
+ *
+ * This driver is based on the USB skeleton driver packaged with the
+ * kernel; copyright (C) 2001-2003 Greg Kroah-Hartman (greg@kroah.com)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include	<linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.4.0 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+#define DRIVER_VERSION	"$Revision: 1.22 $"
+#define DRIVER_NAME	"lirc_streamzap"
+#define DRIVER_DESC     "Streamzap Remote Control driver"
+
+/* ------------------------------------------------------------------ */
+
+static int debug = 0;
+
+#define USB_STREAMZAP_VENDOR_ID		0x0e9c
+#define USB_STREAMZAP_PRODUCT_ID	0x0000
+
+/* Use our own dbg macro */
+#define dprintk(fmt, args...)                                   \
+	do{                                                     \
+		if(debug)                                       \
+	                printk(KERN_DEBUG DRIVER_NAME "[%d]: "  \
+                               fmt "\n", ## args);              \
+	}while(0)
+
+/*
+ * table of devices that work with this driver
+ */
+static struct usb_device_id streamzap_table [] = {
+	{ USB_DEVICE(USB_STREAMZAP_VENDOR_ID, USB_STREAMZAP_PRODUCT_ID) },
+	{ }	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, streamzap_table);
+
+#define STREAMZAP_PULSE_MASK 0xf0
+#define STREAMZAP_SPACE_MASK 0x0f
+#define STREAMZAP_RESOLUTION 256
+
+/* number of samples buffered */
+#define STREAMZAP_BUFFER_SIZE 64
+
+enum StreamzapDecoderState
+{
+	PulseSpace,
+	FullPulse,
+	FullSpace,
+	IgnorePulse
+};
+
+/* Structure to hold all of our device specific stuff */
+/* some remarks regarding locking:
+   theoretically this struct can be accessed from three threads:
+   
+   - from lirc_dev through set_use_inc/set_use_dec
+   
+   - from the USB layer throuh probe/disconnect/irq
+   
+     Careful placement of lirc_register_plugin/lirc_unregister_plugin
+     calls will prevent conflicts. lirc_dev makes sure that
+     set_use_inc/set_use_dec are not being executed and will not be
+     called after lirc_unregister_plugin returns.
+
+   - by the timer callback
+   
+     The timer is only running when the device is connected and the
+     LIRC device is open. Making sure the timer is deleted by
+     set_use_dec will make conflicts impossible.
+*/
+struct usb_streamzap {
+
+	/* usb */
+	/* save off the usb device pointer */
+	struct usb_device *	udev;
+	/* the interface for this device */
+	struct usb_interface *	interface;
+
+	/* buffer & dma */
+	unsigned char *		buf_in;
+	dma_addr_t		dma_in;
+	unsigned int		buf_in_len;
+
+	struct usb_endpoint_descriptor *endpoint;
+
+	/* IRQ */
+	struct urb		*urb_in;
+
+	/* lirc */
+	struct lirc_plugin	plugin;	
+	struct lirc_buffer      delay_buf;
+	struct lirc_buffer      lirc_buf;
+	
+	/* timer used to support delay buffering */
+	struct timer_list	delay_timer;
+	int                     timer_running;
+	spinlock_t              timer_lock;
+	
+	/* tracks whether we are currently receiving some signal */
+	int                     idle;
+	/* sum of signal lengths received since signal start */
+	unsigned long           sum;
+	/* start time of signal; necessary for gap tracking */
+	struct timeval          signal_last;
+	struct timeval          signal_start;
+	enum StreamzapDecoderState decoder_state;
+	struct timer_list	flush_timer;
+	int                     flush;
+	int                     in_use;
+};
+
+
+/* local function prototypes */
+#ifdef KERNEL_2_5
+static int streamzap_probe(struct usb_interface *interface,
+			   const struct usb_device_id *id);
+static void streamzap_disconnect(struct usb_interface *interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_streamzap_irq(struct urb *urb, struct pt_regs *regs);
+#else
+static void usb_streamzap_irq(struct urb *urb);
+#endif
+#else
+static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
+			     const struct usb_device_id *id);
+static void streamzap_disconnect(struct usb_device *dev, void *ptr);
+static void usb_streamzap_irq(struct urb *urb);
+#endif
+static int streamzap_use_inc( void *data );
+static void streamzap_use_dec( void *data );
+static int streamzap_ioctl(struct inode *node, struct file *filep,
+			   unsigned int cmd, unsigned long arg);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int streamzap_suspend(struct usb_interface *intf, pm_message_t message);
+static int streamzap_resume(struct usb_interface *intf);
+#endif
+
+/* usb specific object needed to register this driver with the usb subsystem */
+
+static struct usb_driver streamzap_driver = {
+	LIRC_THIS_MODULE(.owner = THIS_MODULE)
+	.name =		DRIVER_NAME,
+	.probe =	streamzap_probe,
+	.disconnect =	streamzap_disconnect,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	.suspend =	streamzap_suspend,
+	.resume =	streamzap_resume,
+#endif
+	.id_table =	streamzap_table,
+};
+
+static void stop_timer(struct usb_streamzap *sz)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sz->timer_lock, flags);
+	if(sz->timer_running)
+	{
+		sz->timer_running = 0;
+		del_timer_sync(&sz->delay_timer);
+	}
+	spin_unlock_irqrestore(&sz->timer_lock, flags);
+}
+
+static void flush_timeout(unsigned long arg)
+{
+	struct usb_streamzap *sz = (struct usb_streamzap *) arg;
+	
+	/* finally start accepting data */
+	sz->flush = 0;
+}
+static void delay_timeout(unsigned long arg)
+{
+	unsigned long flags;
+	/* deliver data every 10 ms */
+	static unsigned long timer_inc = 
+		(10000/(1000000/HZ)) == 0 ? 1:(10000/(1000000/HZ));
+	struct usb_streamzap *sz = (struct usb_streamzap *) arg;
+	lirc_t data;
+	
+	spin_lock_irqsave(&sz->timer_lock, flags);
+	if(!lirc_buffer_empty(&sz->delay_buf))
+	{
+		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
+		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
+	}
+	if(!lirc_buffer_empty(&sz->delay_buf))
+	{
+		while(lirc_buffer_available(&sz->delay_buf) < 
+		      STREAMZAP_BUFFER_SIZE/2)
+		{
+			lirc_buffer_read_1( &sz->delay_buf,
+					    (unsigned char *) &data);
+			lirc_buffer_write_1(&sz->lirc_buf,
+					    (unsigned char *) &data);
+		}
+		if(sz->timer_running)
+		{
+			sz->delay_timer.expires += timer_inc;
+			add_timer(&sz->delay_timer);
+		}
+	}
+	else
+	{
+		sz->timer_running = 0;
+	}
+	if(!lirc_buffer_empty(&sz->lirc_buf))
+	{
+		wake_up(&sz->lirc_buf.wait_poll);
+	}
+	spin_unlock_irqrestore(&sz->timer_lock, flags);
+}
+
+static inline void flush_delay_buffer(struct usb_streamzap *sz)
+{
+	lirc_t data;
+	int empty = 1;
+	
+	while(!lirc_buffer_empty(&sz->delay_buf))
+	{
+		empty = 0;
+		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
+		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
+	}
+	if(!empty) wake_up( &sz->lirc_buf.wait_poll );
+}
+
+static inline void push(struct usb_streamzap *sz, unsigned char *data)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sz->timer_lock, flags);
+	if(lirc_buffer_full(&sz->delay_buf))
+	{
+		lirc_t data;
+		
+		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
+		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
+		
+		dprintk("buffer overflow", sz->plugin.minor);
+	}
+	
+	lirc_buffer_write_1(&sz->delay_buf, data);
+	
+	if(!sz->timer_running)
+	{
+		sz->delay_timer.expires = jiffies + HZ/10;
+		add_timer(&sz->delay_timer);
+		sz->timer_running = 1;
+	}
+
+	spin_unlock_irqrestore(&sz->timer_lock, flags);
+}
+
+static inline void push_full_pulse(struct usb_streamzap *sz,
+				   unsigned char value)
+{
+	lirc_t pulse;
+	
+	if(sz->idle)
+	{
+		long deltv;
+		lirc_t tmp;
+			
+		sz->signal_last = sz->signal_start;
+		do_gettimeofday(&sz->signal_start);
+		
+		deltv=sz->signal_start.tv_sec-sz->signal_last.tv_sec;
+		if(deltv>15) 
+		{
+			tmp=PULSE_MASK; /* really long time */
+		}
+		else
+		{
+			tmp=(lirc_t) (deltv*1000000+
+				      sz->signal_start.tv_usec-
+				      sz->signal_last.tv_usec);
+			tmp-=sz->sum;
+		}
+		dprintk("ls %u", sz->plugin.minor, tmp);
+		push(sz, (char *)&tmp);
+		
+		sz->idle = 0;
+		sz->sum = 0;
+	}
+	
+	pulse = ((lirc_t) value)*STREAMZAP_RESOLUTION;
+	pulse += STREAMZAP_RESOLUTION/2;
+	sz->sum += pulse;
+	pulse |= PULSE_BIT;
+	
+	dprintk("p %u", sz->plugin.minor, pulse&PULSE_MASK);
+	push(sz, (char *)&pulse);
+}
+
+static inline void push_half_pulse(struct usb_streamzap *sz,
+				   unsigned char value)
+{
+	push_full_pulse(sz, (value & STREAMZAP_PULSE_MASK)>>4);
+}
+
+static inline void push_full_space(struct usb_streamzap *sz,
+				   unsigned char value)
+{
+	lirc_t space;
+	
+	space = ((lirc_t) value)*STREAMZAP_RESOLUTION;
+	space += STREAMZAP_RESOLUTION/2;
+	sz->sum += space;
+	dprintk("s %u", sz->plugin.minor, space);
+	push(sz, (char *)&space);
+}
+
+static inline void push_half_space(struct usb_streamzap *sz,
+				   unsigned char value)
+{
+	push_full_space(sz, value & STREAMZAP_SPACE_MASK);
+}
+
+/*
+ * usb_streamzap_irq - IRQ handler
+ *
+ * This procedure is invoked on reception of data from
+ * the usb remote.
+ */
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void usb_streamzap_irq(struct urb *urb, struct pt_regs *regs) 
+#else
+static void usb_streamzap_irq(struct urb *urb) 
+#endif
+{
+	struct usb_streamzap *sz;
+	int		len;
+	unsigned int	i = 0;
+
+	if ( ! urb )
+		return;
+
+	sz = urb->context;
+	len = urb->actual_length;
+
+	switch (urb->status)
+	{
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		/* sz might already be invalid at this point */
+		dprintk("urb status: %d", -1, urb->status);
+		return;
+	default:
+		break;
+	}
+
+	dprintk("received %d", sz->plugin.minor, urb->actual_length);
+	if(!sz->flush) for (i=0; i < urb->actual_length; i++)
+	{
+		dprintk("%d: %x", sz->plugin.minor,
+			i, (unsigned char) sz->buf_in[i]);
+		switch(sz->decoder_state)
+		{
+		case PulseSpace:
+			if( (sz->buf_in[i]&STREAMZAP_PULSE_MASK) ==
+			    STREAMZAP_PULSE_MASK)
+			{
+				sz->decoder_state = FullPulse;
+				continue;
+			}
+			else if( (sz->buf_in[i]&STREAMZAP_SPACE_MASK) ==
+				 STREAMZAP_SPACE_MASK)
+			{
+				push_half_pulse(sz, sz->buf_in[i]);
+				sz->decoder_state = FullSpace;
+				continue;
+			}
+			else
+			{
+				push_half_pulse(sz, sz->buf_in[i]);
+				push_half_space(sz, sz->buf_in[i]);
+			}
+			break;
+		
+		case FullPulse:
+			push_full_pulse(sz, sz->buf_in[i]);
+			sz->decoder_state = IgnorePulse;
+			break;
+		
+		case FullSpace:
+			if(sz->buf_in[i] == 0xff)
+			{
+				sz->idle=1;
+				stop_timer(sz);
+				flush_delay_buffer(sz);
+			}
+			else
+			{
+				push_full_space(sz, sz->buf_in[i]);
+			}
+			sz->decoder_state = PulseSpace;
+			break;
+		
+		case IgnorePulse:
+			if( (sz->buf_in[i]&STREAMZAP_SPACE_MASK) == 
+			    STREAMZAP_SPACE_MASK)
+			{
+				sz->decoder_state = FullSpace;
+				continue;
+			}
+			push_half_space(sz, sz->buf_in[i]);
+			sz->decoder_state = PulseSpace;
+			break;
+		}
+	}
+
+#ifdef KERNEL_2_5
+	/* resubmit only for 2.6 */
+	usb_submit_urb( urb, GFP_ATOMIC );
+#endif
+
+	return;
+}
+
+/**
+ *	streamzap_probe
+ *
+ *	Called by usb-core to associated with a candidate device
+ *	On any failure the return value is the ERROR
+ *	On success return 0
+ */
+#ifdef KERNEL_2_5
+static int streamzap_probe( struct usb_interface *interface, const struct usb_device_id *id )
+{
+	struct usb_device *udev = interface_to_usbdev(interface);
+	struct usb_host_interface *iface_host;
+#else
+static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
+			     const struct usb_device_id *id)
+{
+	struct usb_interface *interface = &udev->actconfig->interface[ifnum];
+	struct usb_interface_descriptor *iface_host;
+#endif
+	int retval = -ENOMEM;
+	struct usb_streamzap *sz = NULL;
+	char buf[63], name[128] = "";
+
+	/***************************************************
+	 * Allocate space for device driver specific data
+	 */
+	if (( sz = kmalloc (sizeof(struct usb_streamzap), GFP_KERNEL)) == NULL )
+		goto error;
+
+	memset(sz, 0, sizeof(*sz));
+        sz->udev = udev;
+        sz->interface = interface;
+	
+	/***************************************************
+	 * Check to ensure endpoint information matches requirements
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
+	iface_host = interface->cur_altsetting;
+#else
+	iface_host = &interface->altsetting[interface->act_altsetting];
+#endif
+
+#ifdef KERNEL_2_5
+        if (iface_host->desc.bNumEndpoints != 1) {
+#else
+	if(iface_host->bNumEndpoints != 1) {
+#endif
+#ifdef KERNEL_2_5
+                err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
+		    iface_host->desc.bNumEndpoints);
+#else
+                err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
+		    iface_host->bNumEndpoints);
+#endif
+		retval = -ENODEV;
+                goto error;
+        }
+
+#ifdef KERNEL_2_5
+	sz->endpoint = &(iface_host->endpoint[0].desc);
+#else
+	sz->endpoint = &(iface_host->endpoint[0]);
+#endif
+        if (( sz->endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+	    != USB_DIR_IN) {
+                err("%s: endpoint doesn't match input device 02%02x",
+		    __FUNCTION__, sz->endpoint->bEndpointAddress );
+                retval = -ENODEV;
+                goto error;
+        }
+
+        if (( sz->endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	    != USB_ENDPOINT_XFER_INT) {
+                err("%s: endpoint attributes don't match xfer 02%02x",
+		    __FUNCTION__, sz->endpoint->bmAttributes );
+                retval = -ENODEV;
+                goto error;
+        }
+
+        if ( sz->endpoint->wMaxPacketSize == 0 ) {
+                err("%s: endpoint message size==0? ", __FUNCTION__);
+                retval = -ENODEV;
+                goto error;
+        }
+
+	/***************************************************
+	 * Allocate the USB buffer and IRQ URB 
+	 */
+
+	sz->buf_in_len = sz->endpoint->wMaxPacketSize;
+#ifdef KERNEL_2_5
+        if((sz->buf_in = usb_buffer_alloc(sz->udev, sz->buf_in_len,
+					  GFP_ATOMIC, &sz->dma_in)) == NULL )
+	{
+                goto error;
+	}
+	if (!( sz->urb_in = usb_alloc_urb(0, GFP_KERNEL)))
+		goto error;
+#else
+	if( (sz->buf_in = kmalloc(sz->buf_in_len, GFP_KERNEL))
+	    == NULL)
+	{
+		goto error;
+	}
+	if( (sz->urb_in = usb_alloc_urb(0)) == NULL)
+	{
+		goto error;
+	}
+#endif
+	/***************************************************
+	 * Connect this device to the LIRC sub-system
+	 */
+
+	if(lirc_buffer_init(&sz->lirc_buf, sizeof(lirc_t),
+			    STREAMZAP_BUFFER_SIZE))
+	{
+		goto error;
+	}
+	if(lirc_buffer_init(&sz->delay_buf, sizeof(lirc_t),
+			    STREAMZAP_BUFFER_SIZE))
+	{
+		lirc_buffer_free(&sz->lirc_buf);
+		goto error;
+	}
+
+	/***************************************************
+	 * As required memory is allocated now populate the plugin structure
+	 */
+
+	memset(&sz->plugin, 0, sizeof(sz->plugin));
+
+	strcpy(sz->plugin.name, DRIVER_NAME);
+	sz->plugin.minor = -1;
+	sz->plugin.sample_rate = 0;
+	sz->plugin.code_length = sizeof(lirc_t) * 8;
+	sz->plugin.features = LIRC_CAN_REC_MODE2;
+	sz->plugin.data = sz;
+	sz->plugin.rbuf = &sz->lirc_buf;
+	sz->plugin.set_use_inc = &streamzap_use_inc;
+	sz->plugin.set_use_dec = &streamzap_use_dec;
+	sz->plugin.ioctl = streamzap_ioctl;
+#ifdef LIRC_HAVE_SYSFS
+	sz->plugin.dev = &udev->dev;
+#endif
+	sz->plugin.owner = THIS_MODULE;
+
+	sz->idle = 1;
+	sz->decoder_state = PulseSpace;
+	init_timer(&sz->delay_timer);
+	sz->delay_timer.function = delay_timeout;
+	sz->delay_timer.data = (unsigned long) sz;
+	sz->timer_running = 0;
+	spin_lock_init(&sz->timer_lock);
+
+	init_timer(&sz->flush_timer);
+	sz->flush_timer.function = flush_timeout;
+	sz->flush_timer.data = (unsigned long) sz;
+	/***************************************************
+	 * Complete final initialisations
+	 */
+
+	usb_fill_int_urb(sz->urb_in, udev,
+		usb_rcvintpipe( udev, sz->endpoint->bEndpointAddress ),
+		sz->buf_in, sz->buf_in_len, usb_streamzap_irq, sz,
+		sz->endpoint->bInterval);
+
+        if ( udev->descriptor.iManufacturer
+                && usb_string( udev,  udev->descriptor.iManufacturer, buf, 63) > 0)
+                strncpy(name, buf, 128);
+
+        if ( udev->descriptor.iProduct
+                && usb_string( udev,  udev->descriptor.iProduct, buf, 63) > 0)
+                snprintf(name, 128, "%s %s", name, buf);
+
+        printk(KERN_INFO DRIVER_NAME "[%d]: %s on usb%d:%d attached\n",
+	       sz->plugin.minor, name,
+	       udev->bus->busnum, sz->udev->devnum);
+
+#ifdef KERNEL_2_5
+	usb_set_intfdata( interface , sz );
+#endif
+
+	if(lirc_register_plugin(&sz->plugin) < 0)
+	{
+		lirc_buffer_free(&sz->delay_buf);
+		lirc_buffer_free(&sz->lirc_buf);
+		goto error;
+	}
+
+#ifdef KERNEL_2_5
+	return 0;
+#else
+	return sz;
+#endif
+
+error:
+
+	/***************************************************
+	 * Premise is that a 'goto error' can be invoked from inside the
+	 * probe function and all necessary cleanup actions will be taken
+	 * including freeing any necessary memory blocks
+	 */
+
+	if ( retval == -ENOMEM )
+		err ("Out of memory");
+
+	if ( sz ) {
+
+		if ( sz->urb_in )
+			usb_free_urb( sz->urb_in );
+
+		if ( sz->buf_in )
+		{
+#ifdef KERNEL_2_5
+			usb_buffer_free(udev, sz->buf_in_len,
+					sz->buf_in, sz->dma_in);
+#else
+			kfree(sz->buf_in);
+#endif
+		}
+		kfree( sz );
+	}
+
+#ifdef KERNEL_2_5
+	return retval;
+#else
+	return NULL;
+#endif
+}
+
+static int streamzap_use_inc(void *data)
+{
+	struct usb_streamzap *sz = data;
+
+	if(!sz)
+	{
+		dprintk("%s called with no context", -1, __FUNCTION__);
+		return -EINVAL;
+	}
+	dprintk("set use inc", sz->plugin.minor);
+
+	MOD_INC_USE_COUNT;
+	
+	while(!lirc_buffer_empty(&sz->lirc_buf))
+		lirc_buffer_remove_1(&sz->lirc_buf);
+	while(!lirc_buffer_empty(&sz->delay_buf))
+		lirc_buffer_remove_1(&sz->delay_buf);
+		
+	sz->flush_timer.expires = jiffies + HZ;
+	sz->flush = 1;
+	add_timer(&sz->flush_timer);
+
+	sz->urb_in->dev = sz->udev;
+#ifdef KERNEL_2_5
+	if (usb_submit_urb(sz->urb_in, GFP_ATOMIC))
+#else
+	if (usb_submit_urb(sz->urb_in))
+#endif
+	{
+		dprintk("open result = -EIO error submitting urb",
+			sz->plugin.minor);
+		MOD_DEC_USE_COUNT;
+		return -EIO;
+	}
+	sz->in_use++;
+	
+	return 0;
+}
+
+static void streamzap_use_dec(void *data)
+{
+        struct usb_streamzap *sz = data;
+
+        if (!sz) {
+                dprintk("%s called with no context", -1, __FUNCTION__);
+                return;
+        }
+        dprintk("set use dec", sz->plugin.minor);
+	
+	if(sz->flush)
+	{
+		sz->flush = 0;
+		del_timer_sync(&sz->flush_timer);
+	}
+	
+	stop_timer(sz);
+	
+	usb_kill_urb(sz->urb_in);
+	
+        MOD_DEC_USE_COUNT;
+	sz->in_use--;
+}
+
+static int streamzap_ioctl(struct inode *node, struct file *filep,
+			   unsigned int cmd, unsigned long arg)
+{
+        int result;
+	
+	switch(cmd)
+	{
+	case LIRC_GET_REC_RESOLUTION:
+		result=put_user(STREAMZAP_RESOLUTION, (unsigned long *) arg);
+		if(result) return(result); 
+		break;
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+/**
+ *	streamzap_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ *
+ *	This routine guarantees that the driver will not submit any more urbs
+ *	by clearing dev->udev.  It is also supposed to terminate any currently
+ *	active urbs.  Unfortunately, usb_bulk_msg(), used in streamzap_read(), does
+ *	not provide any way to do this.
+ */
+#ifdef KERNEL_2_5
+static void streamzap_disconnect( struct usb_interface *interface )
+#else
+static void streamzap_disconnect(struct usb_device *dev, void *ptr)
+#endif
+{
+	struct usb_streamzap *sz;
+	int errnum;
+	int minor;
+
+#ifdef KERNEL_2_5
+	sz = usb_get_intfdata( interface );
+#else
+	sz = ptr;
+#endif
+
+	/*
+	 * unregister from the LIRC sub-system
+	 */
+
+        if (( errnum = lirc_unregister_plugin( sz->plugin.minor )) != 0) {
+
+                dprintk("error in lirc_unregister: (returned %d)",
+			sz->plugin.minor, errnum );
+        }
+
+	lirc_buffer_free(&sz->delay_buf);
+	lirc_buffer_free(&sz->lirc_buf);
+
+	/*
+	 * unregister from the USB sub-system
+	 */
+
+	usb_free_urb( sz->urb_in );
+
+#ifdef KERNEL_2_5
+        usb_buffer_free( sz->udev , sz->buf_in_len, sz->buf_in, sz->dma_in );
+#else
+	kfree(sz->buf_in);
+#endif
+
+	minor = sz->plugin.minor;
+	kfree( sz );
+
+        printk(KERN_INFO DRIVER_NAME "[%d]: disconnected\n", minor);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int streamzap_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct usb_streamzap *sz = usb_get_intfdata(intf);
+	
+	printk(DRIVER_NAME "[%d]: suspend\n", sz->plugin.minor);
+	if(sz->in_use)
+	{
+		if(sz->flush)
+		{
+			sz->flush = 0;
+			del_timer_sync(&sz->flush_timer);
+		}
+		
+		stop_timer(sz);
+		
+		usb_kill_urb(sz->urb_in);
+	}
+	return 0;
+}
+
+static int streamzap_resume(struct usb_interface *intf)
+{
+	struct usb_streamzap *sz = usb_get_intfdata(intf);
+	
+	while(!lirc_buffer_empty(&sz->lirc_buf))
+		lirc_buffer_remove_1(&sz->lirc_buf);
+	while(!lirc_buffer_empty(&sz->delay_buf))
+		lirc_buffer_remove_1(&sz->delay_buf);
+		
+	if(sz->in_use)
+	{
+		sz->flush_timer.expires = jiffies + HZ;
+		sz->flush = 1;
+		add_timer(&sz->flush_timer);
+
+		sz->urb_in->dev = sz->udev;
+#ifdef KERNEL_2_5
+		if (usb_submit_urb(sz->urb_in, GFP_ATOMIC))
+#else
+		if (usb_submit_urb(sz->urb_in))
+#endif
+		{
+			dprintk("open result = -EIO error submitting urb",
+				sz->plugin.minor);
+			MOD_DEC_USE_COUNT;
+			return -EIO;
+		}
+	}
+	return 0;
+}
+#endif
+
+#ifdef MODULE
+
+/**
+ *	usb_streamzap_init
+ */
+static int __init usb_streamzap_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+
+	result = usb_register( &streamzap_driver );
+
+	if (result) {
+		err("usb_register failed. Error number %d",
+		    result);
+		return result;
+	}
+
+	printk(KERN_INFO DRIVER_NAME " " DRIVER_VERSION " registered\n");
+	return 0;
+}
+
+/**
+ *	usb_streamzap_exit
+ */
+static void __exit usb_streamzap_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&streamzap_driver);
+}
+
+
+module_init (usb_streamzap_init);
+module_exit (usb_streamzap_exit);
+
+MODULE_AUTHOR("Christoph Bartelmus, Greg Wickham, Adrian Dewhurst");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+EXPORT_NO_SYMBOLS;
+
+#endif /* MODULE */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/lirc/lirc_ttusbir.c linux-2.6.23.1-stm/drivers/char/lirc/lirc_ttusbir.c
--- linux-2.6.23.1/drivers/char/lirc/lirc_ttusbir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/lirc/lirc_ttusbir.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,349 @@
+/****************************************************************************
+ ** lirc_ttusbir.c ***********************************************************
+ ****************************************************************************
+ *
+ * lirc_ttusbir - LIRC device driver for the TechnoTrend USB IR Receiver
+ *
+ * Copyright (C) 2007 Stefan Macher <st_maker-lirc@yahoo.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+
+#include <linux/lirc.h>
+#include "kcompat.h"
+#include "lirc_dev.h"
+
+MODULE_DESCRIPTION("TechnoTrend USB IR device driver for LIRC");
+MODULE_AUTHOR("Stefan Macher (st_maker-lirc@yahoo.de)");
+MODULE_LICENSE("GPL");
+
+/* @TODO Is it enough to have only two, I guess yes */
+#define NUM_URBS 4 /* Number of URBs used in the queue */
+
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINTK printk
+#else
+#define DPRINTK(_x_, a...)
+#endif
+
+/* function declarations */
+static int probe(struct usb_interface *intf, const struct usb_device_id *id);
+static void disconnect(struct usb_interface *intf);
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void urb_complete(struct urb* urb, struct pt_regs* pt_regs);
+#else
+static void urb_complete(struct urb* urb);
+#endif
+static int set_use_inc(void* data);
+static void set_use_dec(void* data);
+
+/* table of devices that work with this driver */
+static struct usb_device_id device_id_table [ ] = {
+    { USB_DEVICE(0x0B48, 0x2003) },
+    { } /* Terminating entry */
+};
+MODULE_DEVICE_TABLE (usb, device_id_table);
+
+/* USB driver definition */
+static struct usb_driver driver = {
+    .name = "TTUSBIR",
+    .id_table = &(device_id_table[0]),
+    .probe = probe,
+    .disconnect = disconnect,
+};
+
+/* USB device definition */
+struct ttusbir_device
+{
+	struct usb_driver* driver;
+	struct usb_device* udev;
+	struct usb_interface* interf;
+	struct usb_class_driver class_driver;
+	unsigned int ifnum; /* Interface number to use */
+	unsigned int alt_setting; /* alternate setting to use */
+	unsigned int endpoint; /* Endpoint to use */
+	struct urb *urb[NUM_URBS];
+	char buffer[NUM_URBS][128];
+	struct lirc_buffer rbuf; /* Buffer towards LIRC */
+	struct lirc_plugin plugin;
+	int minor;
+	int last_pulse; /* remembers if last received byte was a pulse or a space */
+	int last_num; /* remembers how many last bytes appeared */
+	int opened;
+};
+
+/*************************************
+ * LIRC specific functions
+ */
+static int set_use_inc(void* data)
+{
+	int i;
+	struct ttusbir_device *ttusbir = data;
+
+	DPRINTK("Sending first URBs\n");
+
+	ttusbir->opened = 1;
+
+	for(i = 0; i < NUM_URBS; i++)
+		usb_submit_urb(ttusbir->urb[i], GFP_KERNEL);
+
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	struct ttusbir_device *ttusbir = data;
+
+	DPRINTK("Device closed\n");
+
+	ttusbir->opened = 0;
+}
+
+/*************************************
+ * USB specific functions
+ */
+
+/* This mapping table is used to do a very simple filtering of the input signal
+ * For a value with at least 4 bits set it returns 0xFF otherwise 0x00.
+ * For faster IR signals this can not be used. But for RC-5 we still have
+ * about 14 bytes per pulse/space
+ */
+const unsigned char map_table[] =
+{
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+#if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void urb_complete(struct urb* urb, struct pt_regs* pt_regs)
+#else
+static void urb_complete(struct urb* urb)
+#endif
+{
+	struct ttusbir_device *ttusbir;
+	unsigned char *buf;
+	int i;
+	lirc_t l;
+
+	ttusbir = urb->context;
+
+	if(!ttusbir->opened)
+		return;
+
+	buf = (unsigned char*)urb->transfer_buffer;
+
+	for(i=0; i < 128; i++) {
+		buf[i] = ~map_table[buf[i]];
+		if(ttusbir->last_pulse == buf[i]) {
+			if(ttusbir->last_num < PULSE_MASK/63)
+				ttusbir->last_num++;
+			/* else we are in a idle period and do not need to increment any longer */
+		}
+		else {
+			l = ttusbir->last_num * 62; /* about 62 = s/byte */
+			if(ttusbir->last_pulse) /* pulse or space? */
+				l |= PULSE_BIT;
+			if(!lirc_buffer_full(&ttusbir->rbuf)) {
+				lirc_buffer_write_1(&ttusbir->rbuf, (void *)&l);
+				wake_up_interruptible(&ttusbir->rbuf.wait_poll);
+			}
+			ttusbir->last_num = 0;
+			ttusbir->last_pulse = buf[i];
+		}
+	}
+	usb_submit_urb(urb, GFP_ATOMIC); /* keep data rolling :-) */
+}
+
+/* Called whenever the USB subsystem thinks we could be the right driver
+   to handle this device
+*/
+static int probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	int alt_set, endp;
+	int found = 0;
+	int i, j;
+	struct usb_host_interface* host_interf;
+	struct usb_interface_descriptor *interf_desc;
+	struct usb_host_endpoint *host_endpoint;
+	struct ttusbir_device *ttusbir;
+
+	DPRINTK("Module ttusbir probe\n");
+
+	ttusbir = (struct ttusbir_device*)kzalloc(sizeof(struct ttusbir_device), GFP_KERNEL);
+	if(!ttusbir)
+		return -ENOMEM;
+	ttusbir->driver = &driver;
+	ttusbir->alt_setting = -1;
+	ttusbir->udev = usb_get_dev(interface_to_usbdev(intf));
+	ttusbir->interf = intf;
+	ttusbir->last_pulse = 0x00;
+	ttusbir->last_num = 0;
+
+	/* Now look for interface setting we can handle
+	   We are searching for the alt setting where end point
+	   0x82 has max packet size 16
+	*/
+	for(alt_set=0; alt_set < intf->num_altsetting && !found; alt_set++) {
+		host_interf = &intf->altsetting[alt_set];
+		interf_desc = &host_interf->desc;
+		for(endp=0; endp < interf_desc->bNumEndpoints; endp++) {
+			host_endpoint = &host_interf->endpoint[endp];
+			if( (host_endpoint->desc.bEndpointAddress == 0x82) &&
+			    (host_endpoint->desc.wMaxPacketSize == 0x10) ) {
+				ttusbir->alt_setting = alt_set;
+				ttusbir->endpoint = endp;
+				found = 1;
+				break;
+			}
+		}
+	}
+	if(ttusbir->alt_setting != -1)
+		DPRINTK("alt setting: %d\n", ttusbir->alt_setting);
+	else {
+		err("Could not find alternate setting\n");
+		kfree(ttusbir);
+		return -EINVAL;
+	}
+
+	/* OK lets setup this interface setting */
+	usb_set_interface(ttusbir->udev, 0, ttusbir->alt_setting);
+
+	/* Store device info in interface structure */
+	usb_set_intfdata(intf, ttusbir);
+
+	/* Register as a LIRC plugin */
+	if(lirc_buffer_init(&ttusbir->rbuf, sizeof(lirc_t), 256 ) < 0) {
+		err("Could not get memory for LIRC data buffer\n");
+		usb_set_intfdata(intf, NULL);
+		kfree(ttusbir);
+		return -ENOMEM;
+	}
+	strcpy(ttusbir->plugin.name, "TTUSBIR");
+	ttusbir->plugin.minor = -1;
+	ttusbir->plugin.code_length = 1;
+	ttusbir->plugin.sample_rate = 0;
+	ttusbir->plugin.data = ttusbir;
+	ttusbir->plugin.add_to_buf = NULL;
+	ttusbir->plugin.get_queue = NULL;
+	ttusbir->plugin.rbuf = &ttusbir->rbuf;
+	ttusbir->plugin.set_use_inc = set_use_inc;
+	ttusbir->plugin.set_use_dec = set_use_dec;
+	ttusbir->plugin.ioctl = NULL;
+	ttusbir->plugin.fops = NULL;
+	ttusbir->plugin.owner = THIS_MODULE;
+	ttusbir->plugin.features = LIRC_CAN_REC_MODE2;
+	if ((ttusbir->minor = lirc_register_plugin(&ttusbir->plugin)) < 0) {
+		err("Error registering as LIRC plugin\n");
+		usb_set_intfdata(intf, NULL);
+		lirc_buffer_free(&ttusbir->rbuf);
+		kfree(ttusbir);
+		return -EIO;
+	}
+
+	/* Allocate and setup the URB that we will use to talk to the device */
+	for(i=0; i < NUM_URBS; i++) {
+		ttusbir->urb[i] = usb_alloc_urb(8, GFP_KERNEL);
+		if(!ttusbir->urb[i]) {
+			err("Could not allocate memory for the URB\n");
+			for(j=i-1; j >= 0; j--)
+				kfree(ttusbir->urb[j]);
+			lirc_buffer_free(&ttusbir->rbuf);
+			lirc_unregister_plugin(ttusbir->minor);
+			kfree(ttusbir);
+			usb_set_intfdata(intf, NULL);
+			return -ENOMEM;
+		}
+		ttusbir->urb[i]->dev = ttusbir->udev;
+		ttusbir->urb[i]->context = ttusbir;
+		ttusbir->urb[i]->pipe = usb_rcvisocpipe(ttusbir->udev, ttusbir->endpoint);
+		ttusbir->urb[i]->interval = 1;
+		ttusbir->urb[i]->transfer_flags = URB_ISO_ASAP;
+		ttusbir->urb[i]->transfer_buffer = &ttusbir->buffer[i][0];
+		ttusbir->urb[i]->complete = urb_complete;
+		ttusbir->urb[i]->number_of_packets = 8;
+		ttusbir->urb[i]->transfer_buffer_length = 128;
+		for(j=0; j < 8; j++) {
+			ttusbir->urb[i]->iso_frame_desc[j].offset = j*16;
+			ttusbir->urb[i]->iso_frame_desc[j].length = 16;
+		}
+	}
+	return 0;
+}
+
+/* Called when the driver is unloaded or the device is unplugged
+ */
+static void disconnect(struct usb_interface *intf)
+{
+	int i;
+	struct ttusbir_device *ttusbir;
+
+	DPRINTK("Module ttusbir disconnect\n");
+
+	lock_kernel();
+	ttusbir = (struct ttusbir_device*) usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+	lirc_unregister_plugin(ttusbir->minor);
+	unlock_kernel();
+
+	for(i=0; i < NUM_URBS; i++)
+		usb_free_urb(ttusbir->urb[i]);
+	lirc_buffer_free(&ttusbir->rbuf);
+	kfree(ttusbir);
+}
+
+static int ttusbir_init_module(void)
+{
+	int result;
+
+	DPRINTK( KERN_DEBUG "Module ttusbir init\n" );
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&driver);
+	if (result)
+		err("usb_register failed. Error number %d", result);
+	return result;
+}
+
+static void ttusbir_exit_module(void)
+{
+	printk( KERN_DEBUG "Module ttusbir exit\n" );
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&driver);
+}
+
+module_init(ttusbir_init_module);
+module_exit(ttusbir_exit_module);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/char/watchdog/Kconfig linux-2.6.23.1-stm/drivers/char/watchdog/Kconfig
--- linux-2.6.23.1/drivers/char/watchdog/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/char/watchdog/Kconfig	2007-11-01 12:00:40.000000000 +0000
@@ -666,6 +666,7 @@
 config SH_WDT
 	tristate "SuperH Watchdog"
 	depends on SUPERH && (CPU_SH3 || CPU_SH4)
+	select SH_FAST_HZ
 	help
 	  This driver adds watchdog support for the integrated watchdog in the
 	  SuperH processors. If you have one of these processors and wish
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/hwmon/Kconfig linux-2.6.23.1-stm/drivers/hwmon/Kconfig
--- linux-2.6.23.1/drivers/hwmon/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/hwmon/Kconfig	2007-11-01 12:00:40.000000000 +0000
@@ -530,6 +530,17 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called thmc50.
 
+config SENSORS_STM_PWM
+	tristate "STM PWM Support"
+	depends on HWMON && CPU_SUBTYPE_ST40
+	default n
+	help
+	  This is a simple driver for the PWM (Pulse Width Modulation)
+	  hardware present on many ST chips. Although the PWM hardware can
+	  be used for many things, this driver simply allows the mark/space
+	  ratio to be set, which is sufficient for many purposes, including
+	  controlling the speed of a fan.
+
 config SENSORS_VIA686A
 	tristate "VIA686A"
 	depends on PCI
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/hwmon/Makefile linux-2.6.23.1-stm/drivers/hwmon/Makefile
--- linux-2.6.23.1/drivers/hwmon/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/hwmon/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -56,6 +56,7 @@
 obj-$(CONFIG_SENSORS_SMSC47B397)+= smsc47b397.o
 obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
+obj-$(CONFIG_SENSORS_STM_PWM)	+= stm-pwm.o
 obj-$(CONFIG_SENSORS_THMC50)	+= thmc50.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_VT1211)	+= vt1211.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/hwmon/stm-pwm.c linux-2.6.23.1-stm/drivers/hwmon/stm-pwm.c
--- linux-2.6.23.1/drivers/hwmon/stm-pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/hwmon/stm-pwm.c	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Contains code copyright (C) Echostar Technologies Corporation
+ * Author: Anthony Jackson <anthony.jackson@echostar.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/stm/soc.h>
+#include <asm/io.h>
+
+struct stm_pwm {
+	struct resource *mem;
+	void* base;
+	struct class_device *class_dev;
+};
+
+/* PWM registers */
+#define PWM0_VAL		0x00
+#define PWM1_VAL		0x04
+#define PWM_CTRL		0x50
+#define PWM_CTRL_PWM_EN			(1<<9)
+#define PWM_CTRL_PWM_CLK_VAL0_SHIFT	0
+#define PWM_CTRL_PWM_CLK_VAL0_MASK	0x0f
+#define PWM_CTRL_PWM_CLK_VAL4_SHIFT	11
+#define PWM_CTRL_PWM_CLK_VAL4_MASK	0xf0
+#define PWM_INT_EN		0x54
+
+/* Prescale value (clock dividor):
+ * 0: divide by 1
+ * 0xff: divide by 256 */
+#define PWM_CLK_VAL		0
+
+static ssize_t show_pwm(struct device *dev, char * buf, int offset)
+{
+	struct stm_pwm *pwm = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%ld\n", readl(pwm->base + offset));
+}
+
+static ssize_t store_pwm(struct device *dev, const char * buf, size_t count,
+			 int offset)
+{
+	struct stm_pwm *pwm = dev_get_drvdata(dev);
+	char* p;
+	long val = simple_strtol(buf, &p, 10);
+
+	if (p != buf) {
+		val &= 0xff;
+		writel(val, pwm->base + offset);
+		return p-buf;
+	}
+	return -EINVAL;
+}
+
+#define pwm_fns(n)							\
+static ssize_t								\
+show_pwm##n(struct device *dev,	struct device_attribute *attr,		\
+	    char *buf)							\
+{									\
+	return show_pwm(dev, buf, PWM##n##_VAL);			\
+}									\
+static ssize_t								\
+store_pwm##n(struct device *dev, struct device_attribute *attr,		\
+	     const char *buf, size_t count)				\
+{									\
+	return store_pwm(dev, buf, count, PWM##n##_VAL);		\
+}									\
+static DEVICE_ATTR(pwm##n, S_IRUGO| S_IWUSR, show_pwm##n, store_pwm##n);
+
+pwm_fns(0)
+pwm_fns(1)
+
+static void
+stm_pwm_init(struct platform_device* pdev, struct stm_pwm *pwm,
+	     struct plat_stm_pwm_data *pwm_private_info)
+{
+	u32 reg = 0;
+
+	/* disable PWM if currently running */
+	reg = readl(pwm->base + PWM_CTRL);
+	reg &= ~PWM_CTRL_PWM_EN;
+	writel(reg, pwm->base + PWM_CTRL);
+
+	/* disable all PWM related interrupts */
+	reg = 0;
+	writel(reg, pwm->base + PWM_INT_EN);
+
+	/* Set global PWM state:
+	 * disable capture... */
+	reg = 0;
+
+	/* set prescale value... */
+	reg |= (PWM_CLK_VAL & PWM_CTRL_PWM_CLK_VAL0_MASK) << PWM_CTRL_PWM_CLK_VAL0_SHIFT;
+	reg |= (PWM_CLK_VAL & PWM_CTRL_PWM_CLK_VAL4_MASK) << PWM_CTRL_PWM_CLK_VAL4_SHIFT;
+
+	/* enable */
+	reg |= PWM_CTRL_PWM_EN;
+	writel(reg, pwm->base + PWM_CTRL);
+
+	/* Initial value */
+	writel(0, pwm->base + PWM0_VAL);
+	writel(0, pwm->base + PWM1_VAL);
+
+	if (pwm_private_info->flags & PLAT_STM_PWM_OUT0) {
+		device_create_file(&pdev->dev, &dev_attr_pwm0);
+	}
+	if (pwm_private_info->flags & PLAT_STM_PWM_OUT1) {
+		device_create_file(&pdev->dev, &dev_attr_pwm1);
+	}
+}
+
+static int stm_pwm_probe(struct platform_device *pdev)
+{
+	struct plat_stm_pwm_data *pwm_private_info = pdev->dev.platform_data;
+	struct resource *res;
+	struct stm_pwm *pwm;
+	int err;
+
+	pwm = kmalloc(sizeof(struct stm_pwm), GFP_KERNEL);
+	if (pwm == NULL) {
+		return -ENOMEM;
+	}
+	memset(pwm, 0, sizeof(*pwm));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+                err = -ENODEV;
+		goto failed1;
+	}
+
+	pwm->mem = request_mem_region(res->start, res->end - res->start + 1, "stm-pwn");
+	if (pwm->mem == NULL) {
+		dev_err(&pdev->dev, "failed to claim memory region\n");
+                err = -EBUSY;
+		goto failed1;
+	}
+
+	pwm->base = ioremap(res->start, res->end - res->start + 1);
+	if (pwm->base == NULL) {
+		dev_err(&pdev->dev, "failed ioremap");
+		err = -EINVAL;
+		goto failed2;
+	}
+
+	pwm->class_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(pwm->class_dev)) {
+		err = PTR_ERR(pwm->class_dev);
+		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
+		goto failed3;
+	}
+
+	platform_set_drvdata(pdev, pwm);
+	dev_info(&pdev->dev, "registers at 0x%lx, mapped to 0x%p\n",
+		 res->start, pwm->base);
+
+	stm_pwm_init(pdev, pwm, pwm_private_info);
+
+	return 0;
+
+failed3:
+	iounmap(pwm->base);
+failed2:
+	release_resource(pwm->mem);
+failed1:
+	kfree(pwm);
+	return err;
+}
+
+static int stm_pwm_remove(struct platform_device *dev)
+{
+	struct stm_pwm *pwm = platform_get_drvdata(dev);
+	if (pwm) {
+		hwmon_device_unregister(pwm->class_dev);
+		iounmap(pwm->base);
+		release_resource(pwm->mem);
+		kfree(pwm);
+	}
+	return 0;
+}
+
+static struct platform_driver stm_pwm_driver = {
+	.driver = {
+		.name		= "stm-pwm",
+	},
+	.probe		= stm_pwm_probe,
+	.remove		= stm_pwm_remove,
+};
+
+static int __init stm_pwm_module_init(void)
+{
+	return platform_driver_register(&stm_pwm_driver);
+}
+
+static void __exit stm_pwm_module_exit(void)
+{
+	platform_driver_unregister(&stm_pwm_driver);
+}
+
+module_init(stm_pwm_module_init);
+module_exit(stm_pwm_module_exit);
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics simple PWM driver");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/busses/Kconfig linux-2.6.23.1-stm/drivers/i2c/busses/Kconfig
--- linux-2.6.23.1/drivers/i2c/busses/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/busses/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -654,4 +654,36 @@
 	  This driver can also be built as module. If so, the module
 	  will be called i2c-pmcmsp.
 
+choice
+	prompt "STMicroelectronics I2C support"
+	depends on I2C && CPU_SUBTYPE_ST40
+	help
+	  STMicroelectronics SoCs support the I2C bus using either a bit-banging
+	  PIO driver or using the hardware SSC.
+
+config I2C_ST40_PIO
+	tristate "I2C bit-banging PIO driver"
+	select I2C_ALGOBIT
+	help
+	  If you say yes to this option, support will be included for the
+	  PIO driven I2C in bit-banging mode.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-st40-pio
+
+config I2C_STM
+	tristate "I2C hardware SSC driver"
+	select STM_SSC
+	help
+	  If you say yes to this option, support will be included for the
+	  SSC driven I2C.
+
+endchoice
+
+config I2C_STM_HW_FIFO
+	bool "I2C hardware SSC Fifo support"
+	depends on I2C_STM
+	help
+	  Enable this option to print out information on STM I2C (SSC) device driver
+
 endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/busses/Makefile linux-2.6.23.1-stm/drivers/i2c/busses/Makefile
--- linux-2.6.23.1/drivers/i2c/busses/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/busses/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -52,6 +52,8 @@
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_ST40_PIO)      += i2c-st40-pio.o
+obj-$(CONFIG_I2C_STM)           += i2c-stm.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/busses/i2c-st40-pio.c linux-2.6.23.1-stm/drivers/i2c/busses/i2c-st40-pio.c
--- linux-2.6.23.1/drivers/i2c/busses/i2c-st40-pio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/busses/i2c-st40-pio.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,289 @@
+/* linux/drivers/i2c/busses/i2c-st40-pio.c
+
+   Copyright (c) 2004 STMicroelectronics Limited
+   Author: Stuart Menefy <stuart.menefy@st.com>
+
+   ST40 I2C bus driver using PIO pins
+
+   Derived from i2c-velleman.c which was:
+   Copyright (C) 1995-96, 2000 Simon G. Vogl
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/stm/pio.h>
+#include <asm/io.h>
+#include <asm/param.h> /* for HZ */
+
+#define NAME "i2c_st40_pio"
+
+typedef struct {
+	int sclbank;
+	int sclpin;
+	int sdabank;
+	int sdapin;
+} pio_address;
+
+typedef struct {
+	struct stpio_pin* scl;
+	struct stpio_pin* sda;
+} pio_pins;
+
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+
+#define NR_I2C_BUSSES 1
+static pio_address i2c_address[NR_I2C_BUSSES] = {{3,1,3,0}};
+
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+#if defined(CONFIG_SH_STM8000_DEMO)
+#define NR_I2C_BUSSES 2
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{6,0,6,1},
+	{6,2,6,3}  // This isn't strictly speaking I2C but some boards use it as such
+};
+#elif defined(CONFIG_SH_ST220_EVAL)
+#define NR_I2C_BUSSES 1
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{6,0,6,1}
+	//  The "second" bus on the eval board is unconnected and hence floating
+	//  this causes a temporary hang on probe
+};
+#endif
+
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+
+#if defined(CONFIG_SH_ST_MB442)
+
+#define NR_I2C_BUSSES 2
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{2,0,2,1},
+	{4,0,4,1}
+};
+
+#else
+
+#define NR_I2C_BUSSES 3
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{2,0,2,1},
+	{3,0,3,1},
+	{4,0,4,1}
+};
+
+#endif
+
+#elif defined(CONFIG_CPU_SUBTYPE_STX7200)
+
+#define NR_I2C_BUSSES 5
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+       {2,0,2,1},
+       {3,0,3,1},
+       {4,0,4,1},
+       {5,0,5,1},
+       {7,6,7,7},
+};
+
+#else
+#error Need to configure the default I2C pins for this chip
+#endif
+
+static pio_pins i2c_busses[NR_I2C_BUSSES] = {{0}};
+
+static void bit_st40_pio_setscl(void *data, int state)
+{
+	stpio_set_pin(((pio_pins*)data)->scl, state);
+}
+
+static void bit_st40_pio_setsda(void *data, int state)
+{
+	stpio_set_pin(((pio_pins*)data)->sda, state);
+}
+
+static int bit_st40_pio_getscl(void *data)
+{
+	return stpio_get_pin(((pio_pins*)data)->scl);
+}
+
+static int bit_st40_pio_getsda(void *data)
+{
+	return stpio_get_pin(((pio_pins*)data)->sda);
+}
+
+static int bit_st40_pio_init(void)
+{
+	int i;
+	for(i = 0; i<NR_I2C_BUSSES; i++) {
+		i2c_busses[i].scl = stpio_request_pin(i2c_address[i].sclbank,
+						      i2c_address[i].sclpin,
+						      "I2C Clock",
+						      STPIO_BIDIR);
+
+		printk(KERN_INFO NAME ": allocated pin (%d,%d) for scl (0x%p)\n",i2c_address[i].sclbank, i2c_address[i].sclpin, i2c_busses[i].scl);
+
+		i2c_busses[i].sda = stpio_request_pin(i2c_address[i].sdabank,
+						      i2c_address[i].sdapin,
+						      "I2C Data",
+						      STPIO_BIDIR);
+
+		printk(KERN_INFO NAME ": allocated pin (%d,%d) for sda (0x%p)\n",i2c_address[i].sdabank, i2c_address[i].sdapin, i2c_busses[i].sda);
+
+		if(i2c_busses[i].scl == NULL || i2c_busses[i].sda == NULL)
+		{
+			printk(KERN_INFO NAME ": failed to allocate bus pins\n");
+			return -1;
+		}
+
+
+		stpio_set_pin(i2c_busses[i].sda, 0);
+		stpio_set_pin(i2c_busses[i].scl, 0);
+	}
+
+	return 0;
+}
+
+static void bit_st40_pio_free(void)
+{
+	int i;
+	for(i=0; i<NR_I2C_BUSSES; i++) {
+		if(i2c_busses[i].scl)
+		{
+			stpio_free_pin(i2c_busses[i].scl);
+			i2c_busses[i].scl = NULL;
+		}
+
+		if(i2c_busses[i].sda)
+		{
+			stpio_free_pin(i2c_busses[i].sda);
+			i2c_busses[i].sda = NULL;
+		}
+	}
+}
+
+static struct i2c_algo_bit_data bit_st40_pio_data[NR_I2C_BUSSES] = {
+{
+	.data		= &i2c_busses[0],
+	.setsda		= bit_st40_pio_setsda,
+	.setscl		= bit_st40_pio_setscl,
+	.getsda		= bit_st40_pio_getsda,
+	.getscl		= bit_st40_pio_getscl,
+	.udelay		= 10,
+	.timeout	= HZ
+},
+#if NR_I2C_BUSSES > 1
+{
+	.data		= &i2c_busses[1],
+	.setsda		= bit_st40_pio_setsda,
+	.setscl		= bit_st40_pio_setscl,
+	.getsda		= bit_st40_pio_getsda,
+	.getscl		= bit_st40_pio_getscl,
+	.udelay		= 10,
+	.timeout	= HZ
+},
+#if NR_I2C_BUSSES > 2
+{
+        .data           = &i2c_busses[2],
+        .setsda         = bit_st40_pio_setsda,
+        .setscl         = bit_st40_pio_setscl,
+        .getsda         = bit_st40_pio_getsda,
+        .getscl         = bit_st40_pio_getscl,
+        .udelay         = 10,
+        .timeout        = HZ
+},
+#endif
+#endif
+};
+
+static struct i2c_adapter bit_st40_pio_ops[NR_I2C_BUSSES] = {
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[0],
+},
+#if NR_I2C_BUSSES > 1
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[1],
+},
+#if NR_I2C_BUSSES > 2
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[2],
+}
+#endif
+#endif
+};
+
+static void bit_st40_pio_unregister(void)
+{
+	int i;
+
+	for(i=0;i<NR_I2C_BUSSES;i++)
+	{
+		i2c_del_adapter(&bit_st40_pio_ops[i]);
+	}
+
+	bit_st40_pio_free();
+}
+
+static int __init i2c_st40_pio_init(void)
+{
+	int i;
+
+	printk(KERN_INFO NAME ": ST40 PIO based I2C Driver\n");
+
+	if (bit_st40_pio_init() < 0) {
+		printk(KERN_INFO NAME ": initialization failed\n");
+		bit_st40_pio_free();
+	}
+
+	for(i=0;i<NR_I2C_BUSSES;i++)
+	{
+		printk(KERN_INFO NAME " bus %d: SCL=PIO%u[%u], SDA=PIO%u[%u]\n", i,
+			i2c_address[i].sclbank, i2c_address[i].sclpin,
+			i2c_address[i].sdabank, i2c_address[i].sdapin);
+
+		if (i2c_bit_add_bus(&bit_st40_pio_ops[i]) < 0) {
+			printk(KERN_ERR NAME ": adapter registration failed\n");
+			bit_st40_pio_unregister();
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static void __exit i2c_st40_pio_exit(void)
+{
+	bit_st40_pio_unregister();
+}
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("ST40 PIO based I2C Driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_st40_pio_init);
+module_exit(i2c_st40_pio_exit);
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/busses/i2c-stm.c linux-2.6.23.1-stm/drivers/i2c/busses/i2c-stm.c
--- linux-2.6.23.1/drivers/i2c/busses/i2c-stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/busses/i2c-stm.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,783 @@
+/*
+ * --------------------------------------------------------------------
+ *
+ * i2c-stm.c
+ * i2c algorithms for STMicroelectronics SSC device
+ * Version: 2.0 (1 April 2007)
+ *
+ * --------------------------------------------------------------------
+ *
+ *  Copyright (C) 2006  Virlinzi Francesco
+ *                   <francesco.virlinzi@st.com>
+ *
+ * 23 August 2006 - Modified to support the 2.6.17 kernel version
+ *	Virlinzi Francesco <francesco.virlinzi@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/stm/pio.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/errno.h>
+#include <linux/preempt.h>
+#include <asm/processor.h>
+#include <asm/delay.h>
+#include "./i2c-stm.h"
+#include "../../stm/stm_ssc.h"
+
+#undef dgb_print
+
+#ifdef  CONFIG_I2C_DEBUG_BUS
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#undef dgb_print2
+#ifdef  CONFIG_I2C_DEBUG_ALGO
+#define dgb_print2(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print2(fmt, args...)
+#endif
+
+/* --- Defines for I2C --- */
+#define DEVICE_ID                    0x041175
+
+#define I2C_RATE_NORMAL            100000
+#define I2C_RATE_FASTMODE          400000
+#define NANOSEC_PER_SEC            1000000000
+
+#define REP_START_HOLD_TIME_NORMAL   4000	/* standard */
+#define REP_START_HOLD_TIME_FAST      600	/* it was 3500 but 600 is standard*/
+#define START_HOLD_TIME_NORMAL       4000	/* standard */
+#define START_HOLD_TIME_FAST          600	/* standard */
+#define REP_START_SETUP_TIME_NORMAL  4700	/* standard */
+#define REP_START_SETUP_TIME_FAST     600	/* standard */
+#define DATA_SETUP_TIME_NORMAL        250	/* standard */
+#define DATA_SETUP_TIME_FAST          100	/* standard */
+#define STOP_SETUP_TIME_NORMAL       4000	/* standard */
+#define STOP_SETUP_TIME_FAST          600	/* standard */
+#define BUS_FREE_TIME_NORMAL         4700	/* standard */
+#define BUS_FREE_TIME_FAST           1300	/* standard */
+
+/* To manage normal vs fast mode */
+#define IIC_STM_CONFIG_SPEED_MASK          0x1
+#define IIC_STM_CONFIG_SPEED_NORMAL        0x0
+#define IIC_STM_CONFIG_SPEED_FAST          0x1
+
+#define IIC_STM_CONFIG_BAUDRATE_MASK       0xffff0000
+
+typedef enum _iic_state_machine_e {
+	IIC_FSM_VOID = 0,
+	IIC_FSM_PREPARE,
+	IIC_FSM_START,
+	IIC_FSM_DATA_WRITE,
+	IIC_FSM_PREPARE_2_READ,
+	IIC_FSM_DATA_READ,
+	IIC_FSM_STOP,
+	IIC_FSM_COMPLETE,
+	IIC_FSM_REPSTART,
+	IIC_FSM_REPSTART_ADDR,
+	IIC_FSM_ABORT
+} iic_state_machine_e;
+
+typedef enum _iic_fsm_error_e {
+	IIC_E_NO_ERROR = 0x0,
+	IIC_E_RUNNING = 0x1,
+	IIC_E_NOTACK = 0x2
+} iic_fsm_error_e;
+
+struct iic_ssc {
+	unsigned int iic_idx;
+	struct i2c_adapter adapter;
+	unsigned long config;
+	struct list_head list;
+};
+
+/*
+ * With the struct iic_transaction more information
+ * on the required transaction are moved on
+ * the thread stack instead of (iic_ssc) adapter descriptor...
+ */
+struct iic_transaction {
+	struct iic_ssc *adapter;
+	iic_state_machine_e start_state;
+	iic_state_machine_e state;
+	iic_state_machine_e next_state;
+	struct i2c_msg *msgs_queue;
+	int attempt;
+	int queue_length;
+	int current_msg;		/* the message on going */
+	int idx_current_msg;		/* the byte in the message */
+	iic_fsm_error_e status_error;
+	int waitcondition;
+};
+
+#define jump_on_fsm_start(x)	{ (x)->state = IIC_FSM_START;	\
+				goto be_fsm_start;	}
+
+#define jump_on_fsm_repstart(x)	{ (x)->state = IIC_FSM_REPSTART; \
+                                goto be_fsm_repstart;	}
+
+#define jump_on_fsm_complete(x)	{ (x)->state = IIC_FSM_COMPLETE; \
+				goto be_fsm_complete;	}
+
+#define jump_on_fsm_stop(x)	{ (x)->state = IIC_FSM_STOP;	\
+                                  goto be_fsm_stop;	}
+
+#define jump_on_fsm_abort(x)	{ (x)->state = IIC_FSM_ABORT;    \
+                                  goto be_fsm_abort;	}
+
+#define check_fastmode(adap)	(((adap)->config & \
+                                 IIC_STM_CONFIG_SPEED_MASK ) ? 1 : 0 )
+
+
+static void iic_stm_setup_timing(struct iic_ssc *adap);
+
+static void iic_state_machine(struct iic_transaction *trsc)
+{
+	struct iic_ssc* adap = trsc->adapter;
+	struct ssc_t *ssc_bus =
+		(struct ssc_t *)container_of(adap->adapter.dev.parent,struct ssc_t, pdev.dev);
+	unsigned short status;
+	short tx_fifo_status;
+	unsigned int idx;
+	unsigned short address;
+	struct i2c_msg *pmsg;
+	char fast_mode;
+	union {
+		char bytes[2];
+		short word;
+	} tmp;
+
+	dgb_print2("\n");
+
+	fast_mode = check_fastmode(adap);
+	pmsg = trsc->msgs_queue + trsc->current_msg;
+
+	trsc->state = trsc->next_state;
+
+	barrier();
+	switch (trsc->state) {
+	case IIC_FSM_PREPARE:
+		dgb_print2("-Prepare\n");
+		/*
+		 * Here we set the right Pio configuration
+		 * because in the future SPI could change them
+		 */
+		stpio_set_pin(ssc_bus->pio_clk,  STPIO_ALT_BIDIR);
+		stpio_set_pin(ssc_bus->pio_data, STPIO_ALT_BIDIR);
+		/*
+		 * check if the i2c timing register
+		 * of ssc are ready to use
+		 */
+		if (check_fastmode(adap) && ssc_bus->i2c_timing != SSC_I2C_READY_FAST ||
+		   !check_fastmode(adap) && ssc_bus->i2c_timing != SSC_I2C_READY_NORMAL )
+			iic_stm_setup_timing(adap);
+		jump_on_fsm_start(trsc);
+		break;
+
+	case IIC_FSM_START:
+	      be_fsm_start:
+		dgb_print2("-Start address 0x%x\n", pmsg->addr);
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | 0x1);
+		ssc_store16(ssc_bus, SSC_BRG,
+			    (adap->config &
+			     IIC_STM_CONFIG_BAUDRATE_MASK) >> 16);
+		ssc_store16(ssc_bus, SSC_CTL,
+			    SSC_CTL_EN | SSC_CTL_MS |
+			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    (SSC_I2C_I2CFSMODE * fast_mode));
+		address = (pmsg->addr << 2) | 0x1;
+		trsc->start_state = IIC_FSM_START;
+		trsc->next_state  = IIC_FSM_DATA_WRITE;
+		if (pmsg->flags & I2C_M_RD){
+			address |= 0x2;
+			trsc->next_state = IIC_FSM_PREPARE_2_READ;
+		}
+		trsc->idx_current_msg = 0;
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN);
+		ssc_store16(ssc_bus, SSC_TBUF, address);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    SSC_I2C_STRTG | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * fast_mode));
+		break;
+	case IIC_FSM_PREPARE_2_READ:
+		/* Just to clear th RBUF */
+		ssc_load16(ssc_bus, SSC_RBUF);
+		status = ssc_load16(ssc_bus, SSC_STA);
+		dgb_print2(" Prepare to Read... Status=0x%x\n", status);
+		if (status & SSC_STA_NACK)
+			jump_on_fsm_abort(trsc);
+		trsc->next_state = IIC_FSM_DATA_READ;
+#if !defined(CONFIG_I2C_STM_HW_FIFO)
+		if (!pmsg->len) {
+			dgb_print("Zero Read\n");
+			jump_on_fsm_stop(trsc);
+		}
+		ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+		if (pmsg->len == 1) {
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    (SSC_I2C_I2CFSMODE * fast_mode));
+		} else {
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    SSC_I2C_ACKG |
+				    (SSC_I2C_I2CFSMODE * fast_mode));
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_RIEN);
+		}
+                break;
+#else
+		switch (pmsg->len) {
+		case 0: dgb_print2("Zero Read\n");
+			jump_on_fsm_stop(trsc);
+
+		case 1: ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				(SSC_I2C_I2CFSMODE * fast_mode));
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN);
+		   break;
+		default:
+			/* enable the fifos */
+			ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+				SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |
+				SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO );
+			ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG |
+				(SSC_I2C_I2CFSMODE * fast_mode));
+			/* P.S.: in any case the last byte has to be
+			 *       managed in a different manner
+			 */
+			for ( idx = 0;  idx < SSC_RXFIFO_SIZE &&
+					idx < pmsg->len-1 ;  ++idx )
+				ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN);
+		}
+		break;
+#endif
+	case IIC_FSM_DATA_READ:
+#if !defined(CONFIG_I2C_STM_HW_FIFO)
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if (!(status & SSC_STA_TE))
+			return;
+		tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+		tmp.word = tmp.word >> 1;
+		pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];
+		dgb_print2(" Data Read...Status=0x%x %d-%c\n",
+			status, tmp.bytes[0], tmp.bytes[0]);
+		/*Did we finish? */
+		if (trsc->idx_current_msg == pmsg->len) {
+			status &= ~SSC_STA_NACK;
+			jump_on_fsm_stop(trsc);
+		} else {
+			ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+			/*Is this the last byte? */
+			if (trsc->idx_current_msg == (pmsg->len - 1)) {
+				ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+					 (SSC_I2C_I2CFSMODE * fast_mode));
+				ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN);
+			}
+		}
+		break;
+#else
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if (!(status & SSC_STA_TE))
+			return;
+		dgb_print2(" Data Read...Status=0x%x\n",status);
+		/* 1.0 Is it the last byte */
+		if (trsc->idx_current_msg == pmsg->len-1) {
+			tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+			tmp.word = tmp.word >> 1;
+			pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];
+			dgb_print2(" Rx Data %d-%c\n",tmp.bytes[0], tmp.bytes[0]);
+		} else
+		/* 1.1 take the bytes from Rx fifo */
+		for (idx = 0 ;  idx < SSC_RXFIFO_SIZE &&
+			trsc->idx_current_msg < pmsg->len-1; ++idx ) {
+				tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+				tmp.word = tmp.word >> 1;
+				pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];
+				dgb_print2(" Rx Data %d-%c\n",tmp.bytes[0], tmp.bytes[0]);
+				}
+		/* 2. Do we finish? */
+		if (trsc->idx_current_msg == pmsg->len) {
+			status &= ~SSC_STA_NACK;
+			jump_on_fsm_stop(trsc);
+		}
+		/* 3. Ask other 'idx' bytes in fifo mode
+		 *    but we want save the latest [pmsg->len-1]
+		 *    in any case...
+		 */
+		for (idx=0; idx<SSC_TXFIFO_SIZE &&
+			   (trsc->idx_current_msg+idx)<pmsg->len-1; ++idx)
+			ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+		dgb_print2(" Asked %x bytes in fifo mode\n",idx);
+		ssc_store16(ssc_bus,SSC_IEN,SSC_IEN_RIEN | SSC_IEN_TIEN);
+		/*Is the next byte the last byte? */
+		if (trsc->idx_current_msg == (pmsg->len - 1)) {
+			dgb_print2(" Asked the last byte\n");
+			ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+			/* disable the fifos */
+			ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+				SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 );
+			ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+					    (SSC_I2C_I2CFSMODE * fast_mode) );
+			ssc_store16(ssc_bus,SSC_IEN,SSC_IEN_NACKEN);
+		}
+		break;
+#endif
+	case IIC_FSM_DATA_WRITE:
+		/* just to clear some bits in the STATUS register */
+		ssc_load16(ssc_bus, SSC_RBUF);
+/*
+ * Be careful!!!!
+ * Here I don't have to use 0xdc0 for
+ * the SSC_CLR register
+ */
+		ssc_store16(ssc_bus, SSC_CLR, 0x9c0);
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if (status & SSC_STA_NACK)
+			jump_on_fsm_abort(trsc);
+#if defined(CONFIG_I2C_STM_HW_FIFO)
+		tx_fifo_status = ssc_load16(ssc_bus,SSC_TX_FSTAT);
+		if ( tx_fifo_status ) {
+			dgb_print2(" Fifo not empty\n");
+			break;
+		}
+#endif
+		if (trsc->idx_current_msg == pmsg->len || !(pmsg->len))
+			jump_on_fsm_stop(trsc);
+		dgb_print2(" Data Write...Status=0x%x 0x%x-%c\n", status,
+			  pmsg->buf[trsc->idx_current_msg],
+			  pmsg->buf[trsc->idx_current_msg]);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * fast_mode));
+
+		trsc->next_state = IIC_FSM_DATA_WRITE;
+#if !defined(CONFIG_I2C_STM_HW_FIFO)
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_NACKEN);
+#else
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TIEN | SSC_IEN_NACKEN);
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+                            SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |
+			    SSC_CTL_EN_TX_FIFO);
+		for (; tx_fifo_status < SSC_TXFIFO_SIZE &&
+			trsc->idx_current_msg < pmsg->len ;++tx_fifo_status )
+#endif
+		{
+		tmp.bytes[0] = pmsg->buf[trsc->idx_current_msg++];
+		ssc_store16(ssc_bus, SSC_TBUF, tmp.word << 1 | 0x1);
+		}
+		break;
+
+	case IIC_FSM_ABORT:
+	      be_fsm_abort:
+		dgb_print2(" Abort\n");
+		trsc->status_error |= IIC_E_NOTACK;
+		/* Don't ADD the break */
+
+	case IIC_FSM_STOP:
+	      be_fsm_stop:
+		if (!(status & SSC_STA_NACK) &&
+		    (++trsc->current_msg < trsc->queue_length)) {
+			jump_on_fsm_repstart(trsc);
+		}
+		dgb_print2(" Stop\n");
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    SSC_I2C_TXENB | SSC_I2C_STOPG |
+			    (SSC_I2C_I2CFSMODE * fast_mode));
+		trsc->next_state = IIC_FSM_COMPLETE;
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_STOPEN);
+		break;
+
+	case IIC_FSM_COMPLETE:
+		be_fsm_complete:
+		dgb_print2(" Complete\n");
+		ssc_store16(ssc_bus, SSC_IEN, 0x0);
+/*
+ *  If there was some problem i can try again for adap->adapter.retries time...
+ */
+		if ((trsc->status_error & IIC_E_NOTACK) &&	/* there was a problem */
+		    trsc->start_state == IIC_FSM_START &&	/* it cames from start state */
+		    trsc->idx_current_msg == 0 &&		/* the problem is on address */
+		    ++trsc->attempt <= adap->adapter.retries) {
+			trsc->status_error = 0;
+			jump_on_fsm_start(trsc);
+		}
+		if (!(trsc->status_error & IIC_E_NOTACK))
+			trsc->status_error = IIC_E_NO_ERROR;
+		trsc->waitcondition = 0;
+		wake_up(&(ssc_bus->wait_queue));
+		break;
+	case IIC_FSM_REPSTART:
+	      be_fsm_repstart:
+		pmsg = trsc->msgs_queue + trsc->current_msg;
+		dgb_print2("-Rep Start (0x%x)\n",pmsg->addr);
+		trsc->start_state = IIC_FSM_REPSTART;
+		trsc->idx_current_msg = 0;
+		trsc->next_state = IIC_FSM_REPSTART_ADDR;
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB
+			    | SSC_I2C_REPSTRTG | (SSC_I2C_I2CFSMODE *
+						  fast_mode));
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_REPSTRTEN);
+		break;
+	case IIC_FSM_REPSTART_ADDR:
+		dgb_print2("-Rep Start addr 0x%x\n", pmsg->addr);
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * fast_mode));
+		address = (pmsg->addr << 2) | 0x1;
+		trsc->next_state = IIC_FSM_DATA_WRITE;
+		if (pmsg->flags & I2C_M_RD) {
+			address |= 0x2;
+			trsc->next_state = IIC_FSM_PREPARE_2_READ;
+		}
+		ssc_store16(ssc_bus, SSC_TBUF, address);
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN);
+		break;
+	default:
+		printk(KERN_ERR " Error in the FSM\n");
+		;
+	}
+	return;
+}
+
+static void iic_wait_stop_condition(struct ssc_t *ssc_bus)
+{
+  unsigned int idx;
+/*
+ * Look for a stop condition on the bus
+ */
+  dgb_print("\n");
+  for ( idx = 0; idx < 5 ; ++idx )
+    if ((ssc_load16(ssc_bus,SSC_STA) & SSC_STA_STOP) == 0)
+        mdelay(2);
+/*
+ * At this point I hope I detected a stop condition
+ * but in any case I return and I will tour off the ssc....
+ */
+}
+
+static void iic_wait_free_bus(struct ssc_t *ssc_bus)
+{
+#if 1
+  unsigned int idx;
+/*
+ * Look for a free condition on the bus
+ */
+  dgb_print("\n");
+  for ( idx = 0; idx < 5 ; ++idx ) {
+    if (!(ssc_load16(ssc_bus,SSC_STA) & SSC_STA_BUSY) )
+	return ;
+    mdelay(2);
+  }
+#endif
+/*
+ * At this point I hope I detected a free bus
+ * but in any case I return and I will tour off the ssc....
+ */
+}
+
+/*
+ * Description: Prepares the controller for a transaction
+ */
+static int iic_stm_xfer(struct i2c_adapter *i2c_adap,
+			     struct i2c_msg msgs[], int num)
+{
+	unsigned int flag;
+	int result;
+	int timeout;
+	struct iic_ssc *adap =
+			(struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);
+	struct ssc_t *ssc_bus =
+			(struct ssc_t *)container_of(i2c_adap->dev.parent,struct ssc_t, pdev.dev);
+	struct iic_transaction transaction = {
+			.adapter      = adap,
+			.msgs_queue   = msgs,
+			.queue_length = num,
+			.current_msg  = 0x0,
+			.attempt      = 0x0,
+			.status_error = IIC_E_RUNNING,
+			.next_state   = IIC_FSM_PREPARE,
+			.waitcondition = 1,
+		};
+
+	dgb_print("\n");
+	ssc_request_bus(ssc_bus, iic_state_machine, &transaction);
+	iic_wait_free_bus(ssc_bus);
+
+	iic_state_machine(&transaction);
+
+	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
+					(transaction.waitcondition==0),
+					i2c_adap->timeout *HZ );
+
+	local_irq_save(flag);
+
+	result = transaction.current_msg;
+
+	if (unlikely(transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {
+		/* There was some problem */
+		if(timeout<=0){
+			/* There was a timeout !!!
+			   - disable the interrupt
+			   - generate a stop condition on the bus
+			   all this task are done without interrupt....
+			 */
+			ssc_store16(ssc_bus, SSC_IEN, 0x0);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    SSC_I2C_STOPG | SSC_I2C_TXENB |
+				    (SSC_I2C_I2CFSMODE * check_fastmode(adap)));
+			/* wait until the ssc detects a Stop condition on the bus */
+			/* but before we do that we enable all the interrupts     */
+			local_irq_restore(flag);
+
+			iic_wait_stop_condition(ssc_bus);
+
+			/* turn off the ssc */
+/*
+ * Don't disable the SSC as this causes the SDA to go low, causing problems
+ * for some slave devices.
+ *			ssc_store16(ssc_bus, SSC_I2C, 0 );
+ *			ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR);
+ *			ssc_store16(ssc_bus, SSC_CTL, 0 );
+ */
+		} else
+			local_irq_restore(flag);
+
+		if (!timeout){
+			printk(KERN_ERR
+			       "stm-i2c: Error timeout in the finite state machine\n");
+			result = -ETIMEDOUT;
+		} else if (timeout < 0) {
+			dgb_print("stm-i2c: interrupt or error in wait event\n");
+			result = timeout;
+		} else
+			result = -EREMOTEIO;
+	} else
+		local_irq_restore(flag);
+
+	ssc_release_bus(ssc_bus);
+
+	return result;
+}
+
+static void iic_stm_timing_trace(struct iic_ssc *adap)
+{
+	struct ssc_t *ssc_bus =
+			container_of(adap->adapter.dev.parent, struct ssc_t, pdev.dev);
+	dgb_print("SSC_BRG  %d\n", adap->config >> 16);
+	dgb_print("SSC_REP_START_HOLD %d\n",
+		  ssc_load16(ssc_bus, SSC_REP_START_HOLD));
+	dgb_print("SSC_REP_START_SETUP %d\n",
+		  ssc_load16(ssc_bus, SSC_REP_START_SETUP));
+	dgb_print("SSC_START_HOLD %d\n", ssc_load16(ssc_bus, SSC_START_HOLD));
+	dgb_print("SSC_DATA_SETUP %d\n", ssc_load16(ssc_bus, SSC_DATA_SETUP));
+	dgb_print("SSC_STOP_SETUP %d\n", ssc_load16(ssc_bus, SSC_STOP_SETUP));
+	dgb_print("SSC_BUS_FREE %d\n", ssc_load16(ssc_bus, SSC_BUS_FREE));
+	dgb_print("SSC_PRE_SCALER_BRG %d\n",
+		  ssc_load16(ssc_bus, SSC_PRE_SCALER_BRG));
+	dgb_print("SSC_AGFR 0x%x\n", ssc_load8(ssc_bus, SSC_AGFR));
+	dgb_print("SSC_PRSC %d\n", ssc_load8(ssc_bus, SSC_PRSC));
+}
+
+static void iic_stm_setup_timing(struct iic_ssc *adap)
+{
+	struct ssc_t *ssc_bus =
+			container_of(adap->adapter.dev.parent, struct ssc_t, pdev.dev);
+	unsigned long iic_baudrate;
+	unsigned short iic_rep_start_hold;
+	unsigned short iic_start_hold, iic_rep_start_setup;
+	unsigned short iic_data_setup, iic_stop_setup;
+	unsigned short iic_bus_free, iic_pre_scale_baudrate;
+	unsigned char iic_agfr, iic_prsc;
+	unsigned long clock = ssc_get_clock();
+	unsigned long NSPerCyc = NANOSEC_PER_SEC / clock;
+
+	NSPerCyc = NANOSEC_PER_SEC /clock;
+	dgb_print("Assuming %d MHz for the Timing Setup %d\n",
+		  clock / 1000000,NSPerCyc);
+
+	iic_agfr = 0x0;
+	iic_prsc = (int)clock / 10000000;
+	iic_pre_scale_baudrate = 0x1;
+
+	if (check_fastmode(adap)) {
+		ssc_bus->i2c_timing = SSC_I2C_READY_FAST;
+		iic_baudrate = clock / (2 * I2C_RATE_FASTMODE);
+		iic_rep_start_hold = REP_START_HOLD_TIME_FAST / NSPerCyc;
+		iic_start_hold = START_HOLD_TIME_FAST / NSPerCyc;
+		iic_rep_start_setup = REP_START_SETUP_TIME_FAST / NSPerCyc;
+		iic_data_setup = DATA_SETUP_TIME_FAST / NSPerCyc;
+		iic_stop_setup = STOP_SETUP_TIME_FAST / NSPerCyc;
+		iic_bus_free = BUS_FREE_TIME_FAST / NSPerCyc;
+	} else {
+		ssc_bus->i2c_timing = SSC_I2C_READY_NORMAL;
+		iic_baudrate = clock  / (2 * I2C_RATE_NORMAL);
+		iic_rep_start_hold = REP_START_HOLD_TIME_NORMAL / NSPerCyc;
+		iic_start_hold = START_HOLD_TIME_NORMAL / NSPerCyc;
+		iic_rep_start_setup = REP_START_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_data_setup = DATA_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_stop_setup = STOP_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_bus_free = BUS_FREE_TIME_NORMAL / NSPerCyc;
+	}
+
+	adap->config &= ~IIC_STM_CONFIG_BAUDRATE_MASK;
+	adap->config |= iic_baudrate << 16;
+
+	ssc_store16(ssc_bus, SSC_REP_START_HOLD, iic_rep_start_hold);
+	ssc_store16(ssc_bus, SSC_START_HOLD, iic_start_hold);
+	ssc_store16(ssc_bus, SSC_REP_START_SETUP, iic_rep_start_setup);
+	ssc_store16(ssc_bus, SSC_DATA_SETUP, iic_data_setup);
+	ssc_store16(ssc_bus, SSC_STOP_SETUP, iic_stop_setup);
+	ssc_store16(ssc_bus, SSC_BUS_FREE, iic_bus_free);
+	ssc_store8(ssc_bus, SSC_AGFR, iic_agfr);
+	ssc_store8(ssc_bus, SSC_PRSC, iic_prsc);
+	ssc_store16(ssc_bus, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);
+	iic_stm_timing_trace(adap);
+	return;
+}
+
+static int iic_stm_control(struct i2c_adapter *adapter,
+				unsigned int cmd, unsigned long arg)
+{
+	struct iic_ssc *iic_adap =
+	    container_of(adapter, struct iic_ssc, adapter);
+	switch (cmd) {
+	case I2C_STM_IOCTL_FAST:
+		dgb_print("ioctl fast\n");
+		iic_adap->config &= ~IIC_STM_CONFIG_SPEED_MASK;
+		if (arg)
+			iic_adap->config |=
+			    IIC_STM_CONFIG_SPEED_FAST;
+		break;
+	default:
+		printk(KERN_WARNING" i2c-ioctl not managed\n");
+	}
+/*
+ * the timeout and the retries ioctl
+ * are managed by i2c core system
+ */
+	return 0;
+}
+
+static u32 iic_stm_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm iic_stm_algo = {
+	.master_xfer   = iic_stm_xfer,
+	.functionality = iic_stm_func,
+	.algo_control  = iic_stm_control
+};
+
+static ssize_t iic_bus_show_fastmode(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);
+	struct iic_ssc     *iic_stm = container_of(adapter,struct iic_ssc,adapter);
+	return sprintf(buf, "%u\n",check_fastmode(iic_stm));
+}
+
+static ssize_t iic_bus_store_fastmode(struct device *dev,struct device_attribute *attr,
+			 const char *buf,size_t count)
+{
+	struct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	iic_stm_control(adapter,I2C_STM_IOCTL_FAST,val);
+
+	return count;
+}
+
+static DEVICE_ATTR(fastmode, S_IRUGO | S_IWUSR, iic_bus_show_fastmode,
+			iic_bus_store_fastmode);
+
+static LIST_HEAD(stm_busses);
+
+static int __init iic_stm_bus_init(void)
+{
+	unsigned int ssc_number = ssc_device_available();
+	unsigned int idx;
+	unsigned int adapnr = 0;
+	struct iic_ssc *iic_stm;
+
+	for (idx = 0; idx < ssc_number; ++idx) {
+		if (!(ssc_capability(idx) & SSC_I2C_CAPABILITY))
+			continue;
+		iic_stm =
+		    (struct iic_ssc *)kzalloc(sizeof(struct iic_ssc), GFP_KERNEL);
+		if (!iic_stm) {
+			printk(KERN_EMERG
+			       "Error on initialization of  ssc-i2c adapter module\n");
+			return -ENODEV;
+		}
+/*
+ * P.S.: with the "kzalloc" the iic_stm->config is zero
+ *       this means:
+ *       - i2c speed  = normal
+ */
+		iic_stm->adapter.owner = THIS_MODULE;
+		iic_stm->adapter.id = I2C_HW_STM_SSC;
+		iic_stm->adapter.timeout = 4;
+		iic_stm->adapter.class   = I2C_CLASS_ALL;
+		sprintf(iic_stm->adapter.name,"i2c-ssc-%d",adapnr);
+		iic_stm->adapter.algo = &iic_stm_algo;
+//		iic_stm->adapter.dev.bus = &i2c_bus_type;
+		iic_stm->adapter.dev.parent = &(ssc_device_request(idx)->pdev.dev);
+/*
+		iic_stm->adapter.dev.release
+*/
+		iic_stm_setup_timing(iic_stm);
+
+		if (i2c_add_adapter(&(iic_stm->adapter)) < 0) {
+			printk(KERN_ERR
+			       "i2c/stm: The I2C Core refuses the i2c/stm adapter\n");
+			kfree(iic_stm);
+			return -ENODEV;
+		} else {
+			device_create_file(&(iic_stm->adapter.dev), &dev_attr_fastmode);
+		}
+		list_add(&(iic_stm->list), &(stm_busses));
+		adapnr ++;
+	}
+	return 0;
+}
+
+static void __exit iic_stm_bus_exit(void)
+{
+	struct iic_ssc *iic_stm;
+	struct i2c_adapter *iic_adapter;
+	struct list_head *item;
+	dgb_print("\n");
+	list_for_each(item, &(stm_busses)) {
+		iic_stm = container_of(item, struct iic_ssc, list);
+		list_del(&iic_stm->list);
+		iic_adapter = &(iic_stm->adapter);
+		i2c_del_adapter(iic_adapter);
+		kfree(iic_stm);
+	}
+}
+
+late_initcall(iic_stm_bus_init);
+
+module_exit(iic_stm_bus_exit);
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("i2c-stm algorithm for ssc device");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/busses/i2c-stm.h linux-2.6.23.1-stm/drivers/i2c/busses/i2c-stm.h
--- linux-2.6.23.1/drivers/i2c/busses/i2c-stm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/busses/i2c-stm.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,6 @@
+#ifndef I2C_STM
+#define I2C_STM
+
+#define I2C_STM_IOCTL_FAST           0xfa57
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/chips/Kconfig linux-2.6.23.1-stm/drivers/i2c/chips/Kconfig
--- linux-2.6.23.1/drivers/i2c/chips/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/chips/Kconfig	2007-11-01 12:00:41.000000000 +0000
@@ -40,6 +40,29 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called ds1682.
 
+config I2C_AT24C
+	tristate "EEPROMs from most vendors"
+	depends on I2C && EXPERIMENTAL
+	help
+	  Enable this driver to get read/write support to most I2C EEPROMs,
+	  after you configure the driver to know about each eeprom on on
+	  your target board.  Use these generic chip names, instead of
+	  vendor-specific ones like at24c64 or 24lc02:
+
+	     24c00, 24c01, 24c02, dimm (readonly 24c02), 24c04, 24c08,
+	     24c16, 24c32, 24c64, 24c128, 24c256, 24c512, 24c1024
+
+	  Unless you like data loss puzzles, always be sure that any chip
+	  you configure as a 24c32 (32 Kbits) or larger is NOT really a
+	  24c16 (16 Kbits) or smaller.  (Marking the chip as readonly won't
+	  help recover from this.)
+
+	  The current version of this driver demands full I2C bus support,
+	  so it won't yet work on most PCs (limited to SMBUS).
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called at24c.
+
 config SENSORS_EEPROM
 	tristate "EEPROM reader"
 	depends on EXPERIMENTAL
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/chips/Makefile linux-2.6.23.1-stm/drivers/i2c/chips/Makefile
--- linux-2.6.23.1/drivers/i2c/chips/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/chips/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -2,6 +2,9 @@
 # Makefile for miscellaneous I2C chip drivers.
 #
 
+# let 'at24c' get a chance before the less powerful 'eeprom'
+obj-$(CONFIG_I2C_AT24C)		+= at24c.o
+
 obj-$(CONFIG_SENSORS_DS1337)	+= ds1337.o
 obj-$(CONFIG_SENSORS_DS1374)	+= ds1374.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/i2c/chips/at24c.c linux-2.6.23.1-stm/drivers/i2c/chips/at24c.c
--- linux-2.6.23.1/drivers/i2c/chips/at24c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/i2c/chips/at24c.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,745 @@
+/*
+ * at24c.c -- support many I2C EEPROMs, including Atmel AT24C models
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+// #define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+
+#ifdef CONFIG_ARM
+#include <asm/mach-types.h>
+#endif
+
+
+/* If all the bus drivers are statically linked, I2C drivers often won't
+ * need hotplug support.  Iff that's true in your config, you can #define
+ * NO_I2C_DYNAMIC_BUSSES and shrink this driver's runtime footprint.
+ */
+#define NO_I2C_DYNAMIC_BUSSES
+
+#ifdef	NO_I2C_DYNAMIC_BUSSES
+#undef	__devinit
+#undef	__devinitdata
+#undef	__devexit
+#undef	__devexit_p
+/* no I2C devices will be hotplugging */
+#define	__devinit	__init
+#define	__devinitdata	__initdata
+#define	__devexit	__exit
+#define	__devexit_p	__exit_p
+#endif
+
+
+/* I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.
+ * Differences between different vendor product lines (like Atmel AT24C or
+ * MicroChip 24LC, etc) won't much matter for typical read/write access.
+ *
+ * However, misconfiguration can lose data (e.g. "set 16 bit memory address"
+ * could be interpreted as "write data at 8 bit address", or writing with too
+ * big a page size), so board-specific EEPROM configuration should use static
+ * board descriptions rather than dynamic probing when there's much potential
+ * for confusion.
+ *
+ * Using /etc/modprobe.conf you might configure a system with several EEPROMs
+ * something like this:
+ *
+ *   options at24c	chip_names=24c00,dimm,dimm,24c64  \
+ *			probe=0,50,1,50,1,51,2,52 \
+ *			readonly=Y,Y,Y,N
+ *
+ * Or, add some board-specific code at the end of this driver, before
+ * registering the driver.
+ *
+ * CONFIGURATION MECHANISM IS SUBJECT TO CHANGE!!
+ *
+ * Key current(*) differences from "eeprom" driver:
+ *  (a) "at24c" also supports write access
+ *  (b) "at24c" handles all common eeproms, not just 24c02 compatibles
+ *  (c) "eeprom" will probe i2c and set up a 24c02 at each address;
+ *      "at24c" expects a static config, with part types and addresses
+ *  (d) "eeprom" also works on SMBUS-only pc type hardware
+ *
+ * (*) Patches accepted...
+ */
+static unsigned short probe[I2C_CLIENT_MAX_OPTS] __devinitdata
+	= I2C_CLIENT_DEFAULTS;
+static unsigned n_probe __devinitdata;
+module_param_array(probe, ushort, &n_probe, 0);
+MODULE_PARM_DESC(probe, "List of adapter,address pairs for I2C eeproms");
+
+static unsigned short ignore[] __devinitdata = { I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data __devinitdata = {
+	.normal_i2c	= ignore,
+	.probe		= probe,
+	.ignore		= ignore,
+	.forces		= NULL,
+};
+
+static char *chip_names[I2C_CLIENT_MAX_OPTS / 2] __devinitdata;
+static unsigned n_chip_names __devinitdata;
+module_param_array(chip_names, charp, &n_chip_names, 0);
+MODULE_PARM_DESC(chip_names,
+		"Type of chip; one chip name per probe pair");
+
+static int readonly[I2C_CLIENT_MAX_OPTS / 2] __devinitdata;
+static unsigned n_readonly __devinitdata;
+module_param_array(readonly, bool, &n_readonly, 0);
+MODULE_PARM_DESC(chip_names, "Readonly flags, one per probe pair");
+
+
+/* As seen through Linux I2C, differences between the most common types
+ * of I2C memory include:
+ *	- How many I2C addresses the chip consumes: 1, 2, 4, or 8?
+ *	- Memory address space for one I2C address:  256 bytes, or 64 KB?
+ *	- How full that memory space is:  16 bytes, 256, 32Kb, etc?
+ *	- What write page size does it support?
+ */
+struct chip_desc {
+	u32		byte_len;		/* of 1..8 i2c addrs, total */
+	char		name[10];
+	u16		page_size;		/* for writes */
+	u8		i2c_addr_mask;		/* for multi-addr chips */
+	u8		flags;
+#define	EE_ADDR2	0x0080			/* 16 bit addrs; <= 64 KB */
+#define	EE_READONLY	0x0040
+#define	EE_24RF08	0x0001
+};
+
+struct at24c_data {
+	struct i2c_client	client;
+	struct semaphore	lock;
+	struct bin_attribute	bin;
+
+	struct chip_desc	chip;
+
+	/* each chip has an internal "memory address" pointer;
+	 * we remember it for faster read access.
+	 */
+	u32			next_addr;
+
+	/* some chips tie up multiple I2C addresses ... */
+	int			users;
+	struct i2c_client	extras[];
+};
+
+/* Specs often allow 5 msec for a page write, sometimes 20 msec;
+ * it's important to recover from write timeouts.
+ */
+#define	EE_TIMEOUT	25
+
+
+/*-------------------------------------------------------------------------*/
+
+static struct chip_desc chips[] __devinitdata = {
+
+/* this first block of EEPROMS uses 8 bit memory addressing
+ * and can be accessed using standard SMBUS requests.
+ */
+{
+	/* 128 bit chip */
+	.name		= "24c00",
+	.byte_len	= 128 / 8,
+	.i2c_addr_mask	= 0x07,			/* I2C A0-A2 ignored */
+	.page_size	= 1,
+}, {
+	/* 1 Kbit chip */
+	.name		= "24c01",
+	.byte_len	= 1024 / 8,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 2 Kbit chip */
+	.name		= "24c02",
+	.byte_len	= 2048 / 8,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 2 Kbit chip */
+	.name		= "dimm",		/* 24c02 in memory DIMMs */
+	.byte_len	= 2048 / 8,
+	.flags		= EE_READONLY,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 4 Kbit chip */
+	.name		= "24c04",
+	.byte_len	= 4096 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x01,			/* I2C A0 is MEM A8 */
+}, {
+	/* 8 Kbit chip */
+	.name		= "24c08",
+	.byte_len	= 8192 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x03, 		/* I2C A1-A0 is MEM A9-A8 */
+}, {
+	/* 8 Kbit chip */
+	.name		= "24rf08",
+	.byte_len	= 8192 / 8,
+	.flags		= EE_24RF08,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x03, 		/* I2C A1-A0 is MEM A9-A8 */
+}, {
+	/* 16 Kbit chip */
+	.name		= "24c16",
+	.byte_len	= 16384 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x07,			/* I2C A2-A0 is MEM A10-A8 */
+},
+
+/* this second block of EEPROMS uses 16 bit memory addressing
+ * and can't be accessed using standard SMBUS requests.
+ * REVISIT maybe SMBUS 2.0 requests could work ...
+ */
+{
+	/* 32 Kbits */
+	.name		= "24c32",
+	.byte_len	= 32768 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 32,
+}, {
+	/* 64 Kbits */
+	.name		= "24c64",
+	.byte_len	= 65536 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 32,
+}, {
+	/* 128 Kbits */
+	.name		= "24c128",
+	.byte_len	= 131072 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 64,
+}, {
+	/* 256 Kbits */
+	.name		= "24c256",
+	.byte_len	= 262144 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 64,
+}, {
+	/* 512 Kbits */
+	.name		= "24c512",
+	.byte_len	= 524288 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 128,
+}, {
+	/* 1 Mbits */
+	.name		= "24c1024",
+	.byte_len	= 1048576 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 256,
+	.i2c_addr_mask	= 0x01,			/* I2C A0 is MEM A16 */
+}
+
+};
+
+static inline const struct chip_desc *__devinit
+find_chip(const char *s)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(chips); i++)
+		if (strnicmp(s, chips[i].name, sizeof chips[i].name) == 0)
+			return &chips[i];
+	return NULL;
+}
+
+static inline const struct chip_desc *__devinit
+which_chip(struct i2c_adapter *adapter, int address, int *writable)
+{
+	unsigned	i;
+	int		adap_id = i2c_adapter_id(adapter);
+
+	for (i = 0; i < n_probe; i++) {
+		const struct chip_desc	*chip;
+		char			*name;
+
+		if (probe[i++] != adap_id)
+			continue;
+		if (probe[i] != address)
+			continue;
+
+		i >>= 1;
+		if ((name = chip_names[i]) == NULL) {
+			dev_err(&adapter->dev, "no chipname for addr %d\n",
+				address);
+			return NULL;
+
+		}
+		chip = find_chip(name);
+		if (chip == NULL)
+			dev_err(&adapter->dev, "unknown chipname %s\n", name);
+
+		/* user specified r/o value will overide the default */
+		if (i < n_readonly)
+			*writable = !readonly[i];
+		else
+			*writable = !(chip->flags & EE_READONLY);
+		return chip;
+	}
+
+	/* "can't happen" */
+	dev_dbg(&adapter->dev, "addr %d not in probe[]\n", address);
+	return NULL;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* This parameter is to help this driver avoid blocking other drivers
+ * out of I2C for potentially troublesome amounts of time.  With a
+ * 100 KHz I2C clock, one 256 byte read takes about 1/43 second.
+ * VALUE MUST BE A POWER OF TWO so writes will align on pages!!
+ * Note that SMBUS has a 32 byte ceiling...
+ */
+static unsigned io_limit = 128;
+module_param(io_limit, uint, 0);
+MODULE_PARM_DESC(io_limit, "maximum bytes per i/o (default 128)");
+
+static inline int at24c_ee_address(
+	const struct chip_desc	*chip,
+	struct i2c_msg		*msg,
+	unsigned		*offset,
+	u32			*next_addr
+)
+{
+	unsigned	per_address = 256;
+
+	if (*offset >= chip->byte_len)
+		return -EINVAL;
+
+	/* Nothing to do unless accessing that memory would go to some
+	 * later I2C address.  In that case, modify the output params.
+	 * Yes, it can loop more than once on 24c08 and 24c16.
+	 */
+	if (chip->flags & EE_ADDR2)
+		per_address = 64 * 1024;
+	while (*offset >= per_address) {
+		msg->addr++;
+		*offset -= per_address;
+		*next_addr -= per_address;
+	}
+	return 0;
+}
+
+static ssize_t
+at24c_ee_read(
+	struct at24c_data	*at24c,
+	char			*buf,
+	unsigned		offset,
+	size_t			count
+)
+{
+	struct i2c_msg		msg;
+	ssize_t			status;
+	u32			next_addr;
+	size_t			transferred = 0;
+	unsigned long		timeout, retries;
+
+	down(&at24c->lock);
+	msg.addr = at24c->client.addr;
+	msg.flags = 0;
+
+	/* maybe adjust i2c address and offset
+	 * NOTE:  we could now search at24c->extras to choose use
+	 * some i2c_client other than the main one...
+	 */
+	next_addr = at24c->next_addr;
+	status = at24c_ee_address(&at24c->chip, &msg, &offset, &next_addr);
+	if (status < 0)
+		goto done;
+
+	/* REVISIT at least some key cases here can use just the
+	 * SMBUS subset; one issue is 16 byte "register" writes.
+	 */
+
+	timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+	retries = 0;
+	/* Maybe change the current on-chip address with a dummy write */
+	if (next_addr != offset) {
+		do {
+			u8	tmp[2];
+			msg.buf = tmp;
+			tmp[1] = (u8) offset;
+			tmp[0] = (u8) (offset >> 8);
+			if (at24c->chip.flags & EE_ADDR2) {
+				msg.len = 2;
+			} else {
+				msg.len = 1;
+				msg.buf++;
+			}
+			status = i2c_transfer(at24c->client.adapter, &msg, 1);
+			dev_dbg(&at24c->client.dev,
+					"addr %02x, set current to %d --> %d\n",
+					msg.addr, offset, status);
+			if (status < 0) {
+				if (retries++ < 3 || time_after(timeout, jiffies)) {
+					/* REVISIT:  at HZ=100, this is sloooow */
+					msleep(1);
+					continue;
+				}
+				goto done;
+			}
+		} while (status < 0);
+		next_addr = at24c->next_addr = offset;
+	}
+
+	/* issue bounded sequential reads for the data bytes, knowing that
+	 * read page rollover goes to the next page and/or memory block.
+	 */
+	while (count > 0) {
+		unsigned	segment;
+
+		if (count > io_limit)
+			segment = io_limit;
+		else
+			segment = count;
+
+		msg.len = segment;
+		msg.buf = buf;
+		msg.flags = I2C_M_RD;
+		status = i2c_transfer(at24c->client.adapter, &msg, 1);
+		dev_dbg(&at24c->client.dev, "read %d, %d --> %d\n",
+				transferred, count, status);
+
+		if (status < 0)
+			break;
+
+		count -= segment;
+
+		at24c->next_addr += segment;
+		offset += segment;
+		buf += segment;
+		transferred += segment;
+	}
+done:
+	if (status <= 0)
+		at24c->next_addr = at24c->bin.size;
+	up(&at24c->lock);
+	return transferred ? transferred : status;
+}
+
+static ssize_t
+at24c_bin_read(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client	*client;
+	struct at24c_data	*at24c;
+
+	client = to_i2c_client(container_of(kobj, struct device, kobj));
+	at24c = i2c_get_clientdata(client);
+
+	if (unlikely(off >= at24c->bin.size))
+		return 0;
+	if ((off + count) > at24c->bin.size)
+		count = at24c->bin.size - off;
+	if (unlikely(!count))
+		return count;
+
+	/* we don't maintain caches for any data:  simpler, cheaper */
+	return at24c_ee_read(at24c, buf, off, count);
+}
+
+
+/* Note that if the hardware write-protect pin is pulled high, the whole
+ * chip is normally write protected.  But there are plenty of product
+ * variants here, including OTP fuses and partial chip protect.
+ */
+static ssize_t
+at24c_ee_write(struct at24c_data *at24c, char *buf, loff_t off, size_t count)
+{
+	struct i2c_msg		msg;
+	ssize_t			status = 0;
+	unsigned		written = 0;
+	u32			scratch;
+	unsigned		buf_size;
+	unsigned long		timeout, retries;
+
+	/* temp buffer lets us stick the address at the beginning */
+	buf_size = at24c->chip.page_size;
+	if (buf_size > io_limit)
+		buf_size = io_limit;
+	msg.buf = kmalloc(buf_size + 2, GFP_KERNEL);
+	if (!msg.buf)
+		return -ENOMEM;
+	msg.flags = 0;
+
+	/* For write, rollover is within the page ... so we write at
+	 * most one page, then manually roll over to the next page.
+	 */
+	down(&at24c->lock);
+	timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+	retries = 0;
+	do {
+		unsigned	segment;
+		unsigned	offset = (unsigned) off;
+
+		/* maybe adjust i2c address and offset */
+		msg.addr = at24c->client.addr;
+		status = at24c_ee_address(&at24c->chip, &msg,
+						&offset, &scratch);
+		if (status < 0)
+			break;
+
+		/* write as much of a page as we can */
+		segment = buf_size - (offset % buf_size);
+		if (segment > count)
+			segment = count;
+		msg.len = segment + 1;
+		if (at24c->chip.flags & EE_ADDR2) {
+			msg.len++;
+			msg.buf[1] = (u8) offset;
+			msg.buf[0] = (u8) (offset >> 8);
+			memcpy(&msg.buf[2], buf, segment);
+		} else {
+			msg.buf[0] = offset;
+			memcpy(&msg.buf[1], buf, segment);
+		}
+
+		/* The chip may take a while to finish its previous write;
+		 * this write also polls for completion of the last one.
+		 * So we always retry a few times.
+		 */
+		status = i2c_transfer(at24c->client.adapter, &msg, 1);
+		dev_dbg(&at24c->client.dev,
+			"write %d bytes to %02x at %d --> %d (%ld)\n",
+			segment, msg.addr, offset, status, jiffies);
+		if (status < 0) {
+			if (retries++ < 3 || time_after(timeout, jiffies)) {
+				/* REVISIT:  at HZ=100, this is sloooow */
+				msleep(1);
+				continue;
+			}
+			dev_err(&at24c->client.dev,
+				"write %d bytes offset %d to %02x, "
+				"%ld ticks err %d\n",
+				segment, offset, msg.addr,
+				jiffies - (timeout - EE_TIMEOUT),
+				status);
+			status = -ETIMEDOUT;
+			break;
+		}
+
+		off += segment;
+		buf += segment;
+		count -= segment;
+		written += segment;
+		if (status < 0 || count == 0) {
+			if (written != 0)
+				status = written;
+			break;
+		}
+
+		/* yielding may avoid the losing msleep() path above */
+		yield();
+		timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+		retries = 0;
+	} while (count > 0);
+	at24c->next_addr = at24c->bin.size;
+	up(&at24c->lock);
+
+	kfree(msg.buf);
+	return status;
+}
+
+static ssize_t
+at24c_bin_write(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client	*client;
+	struct at24c_data	*at24c;
+
+	client = to_i2c_client(container_of(kobj, struct device, kobj));
+	at24c = i2c_get_clientdata(client);
+
+	if (unlikely(off >= at24c->bin.size))
+		return -EFBIG;
+	if ((off + count) > at24c->bin.size)
+		count = at24c->bin.size - off;
+	if (unlikely(!count))
+		return count;
+
+	return at24c_ee_write(at24c, buf, off, count);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver at24c_driver;
+
+static void __devinit
+at24c_activate(
+	struct i2c_adapter	*adapter,
+	int			address,
+	const struct chip_desc	*chip,
+	int			writable
+)
+{
+	struct at24c_data	*at24c;
+	int			err = -ENOMEM;
+
+	if (!(at24c = kcalloc(1, sizeof(struct at24c_data)
+			+ chip->i2c_addr_mask * sizeof(struct i2c_client),
+			GFP_KERNEL)))
+		goto fail;
+
+	init_MUTEX(&at24c->lock);
+	at24c->chip = *chip;
+	snprintf(at24c->client.name, I2C_NAME_SIZE,
+			"%s I2C EEPROM", at24c->chip.name);
+
+	/* Export the EEPROM bytes through sysfs, since that's convenient.
+	 * By default, only root should see the data (maybe passwords etc)
+	 */
+	at24c->bin.attr.name = "eeprom";
+	at24c->bin.attr.mode = S_IRUSR;
+	at24c->bin.attr.owner = THIS_MODULE;
+	at24c->bin.read = at24c_bin_read;
+
+	at24c->bin.size = at24c->chip.byte_len;
+	at24c->next_addr = at24c->bin.size;
+	if (writable) {
+		at24c->bin.write = at24c_bin_write;
+		at24c->bin.attr.mode |= S_IWUSR;
+	}
+
+	/* register the first chip address */
+	address &= ~at24c->chip.i2c_addr_mask;
+
+	at24c->client.addr = address;
+	at24c->client.adapter = adapter;
+	at24c->client.driver = &at24c_driver;
+	at24c->client.flags = 0;
+	i2c_set_clientdata(&at24c->client, at24c);
+
+	/* prevent AT24RF08 corruption, a possible consequence of the
+	 * probe done by the i2c core (verifying a chip is present).
+	 */
+	if (chip->flags & EE_24RF08)
+		i2c_smbus_write_quick(&at24c->client, 0);
+
+	if ((err = i2c_attach_client(&at24c->client)))
+		goto fail;
+	at24c->users++;
+
+	/* then register any other addresses, so other drivers can't */
+	if (chip->i2c_addr_mask) {
+		unsigned		i;
+		struct i2c_client	*c;
+
+		for (i = 0; i < chip->i2c_addr_mask; i++) {
+			c = &at24c->extras[i];
+			c->addr = address + i + 1;
+			c->adapter = adapter;
+			c->driver = &at24c_driver;
+
+			i2c_set_clientdata(c, at24c);
+			snprintf(c->name, sizeof c->name,
+				"%s address %d", chip->name, i + 2);
+			err = i2c_attach_client(c);
+			if (err == 0)
+				at24c->users++;
+		}
+	}
+
+	sysfs_create_bin_file(&at24c->client.dev.kobj, &at24c->bin);
+
+	dev_info(&at24c->client.dev, "%d byte %s%s\n",
+		at24c->bin.size, at24c->client.name,
+		writable ? " (writable)" : "");
+	dev_dbg(&at24c->client.dev, "page_size %d, i2c_addr_mask %d\n",
+		at24c->chip.page_size, at24c->chip.i2c_addr_mask);
+	return;
+fail:
+	dev_dbg(&adapter->dev, "%s probe, err %d\n", at24c_driver.driver.name, err);
+	kfree(at24c);
+}
+
+static int __devinit
+at24c_old_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	const struct chip_desc	*chip;
+	int			writable;
+
+	chip = which_chip(adapter, address, &writable);
+	if (chip)
+		at24c_activate(adapter, address, chip, writable);
+	return 0;
+}
+
+
+static int __devinit at24c_attach_adapter(struct i2c_adapter *adapter)
+{
+	/* REVISIT: using SMBUS calls would improve portability, though
+	 * maybe at the cost of support for 16 bit memory addressing...
+	 */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_dbg(&adapter->dev, "%s probe, no I2C\n",
+			at24c_driver.driver.name);
+		return 0;
+	}
+	return i2c_probe(adapter, &addr_data, at24c_old_probe);
+}
+
+static int __devexit at24c_detach_client(struct i2c_client *client)
+{
+	int			err;
+	struct at24c_data	*at24c;
+
+	err = i2c_detach_client(client);
+	if (err) {
+		dev_err(&client->dev, "deregistration failed, %d\n", err);
+		return err;
+	}
+
+	/* up to eight clients per chip, detached in any order... */
+	at24c = i2c_get_clientdata(client);
+	if (at24c->users-- == 0)
+		kfree(at24c);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver at24c_driver = {
+	.driver = {
+		.name	= "at24c",
+		.owner	= THIS_MODULE,
+	},
+	.attach_adapter	= at24c_attach_adapter,
+	.detach_client	= __devexit_p(at24c_detach_client),
+};
+
+static int __init at24c_init(void)
+{
+#ifdef CONFIG_OMAP_OSK_MISTRAL
+	if (machine_is_omap_osk()) {
+		n_chip_names = 1;
+		n_probe = 1;
+		chip_names[0] = "24c04";
+		probe[0] = 0;
+		probe[1] = 0x50;
+	}
+
+#endif
+	return i2c_add_driver(&at24c_driver);
+}
+module_init(at24c_init);
+
+static void __exit at24c_exit(void)
+{
+	i2c_del_driver(&at24c_driver);
+}
+module_exit(at24c_exit);
+
+MODULE_DESCRIPTION("Driver for AT24C series (and compatible) I2C EEPROMs");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/ide/ide-cd.c linux-2.6.23.1-stm/drivers/ide/ide-cd.c
--- linux-2.6.23.1/drivers/ide/ide-cd.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/ide/ide-cd.c	2007-11-01 12:00:41.000000000 +0000
@@ -2689,7 +2689,7 @@
 {
 	struct cdrom_info *info = drive->driver_data;
 	struct cdrom_device_info *cdi = &info->devinfo;
-	struct packet_command cgc;
+	DECLARE_PACKET_COMMAND(cgc);
 	int stat, attempts = 3, size = sizeof(*cap);
 
 	/*
@@ -2700,12 +2700,13 @@
 	    !strcmp(drive->id->model, "WPI CDS-32X")))
 		size -= sizeof(cap->pad);
 
-	init_cdrom_command(&cgc, cap, size, CGC_DATA_UNKNOWN);
+	init_cdrom_command(&cgc, size, CGC_DATA_UNKNOWN);
 	do { /* we seem to get stat=0x01,err=0x00 the first time (??) */
 		stat = cdrom_mode_sense(cdi, &cgc, GPMODE_CAPABILITIES_PAGE, 0);
 		if (!stat)
 			break;
 	} while (--attempts);
+	memcpy(cap, cgc.buffer, size);
 	return stat;
 }
 
@@ -3397,38 +3398,36 @@
 
 static int idecd_set_spindown(struct cdrom_device_info *cdi, unsigned long arg)
 {
-	struct packet_command cgc;
-	char buffer[16];
+	DECLARE_PACKET_COMMAND(cgc);
 	int stat;
 	char spindown;
 
 	if (copy_from_user(&spindown, (void __user *)arg, sizeof(char)))
 		return -EFAULT;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_UNKNOWN);
+	init_cdrom_command(&cgc, 16, CGC_DATA_UNKNOWN);
 
 	stat = cdrom_mode_sense(cdi, &cgc, GPMODE_CDROM_PAGE, 0);
 	if (stat)
 		return stat;
 
-	buffer[11] = (buffer[11] & 0xf0) | (spindown & 0x0f);
+	cgc.buffer[11] = (cgc.buffer[11] & 0xf0) | (spindown & 0x0f);
 	return cdrom_mode_select(cdi, &cgc);
 }
 
 static int idecd_get_spindown(struct cdrom_device_info *cdi, unsigned long arg)
 {
-	struct packet_command cgc;
-	char buffer[16];
+	DECLARE_PACKET_COMMAND(cgc);
 	int stat;
  	char spindown;
 
-	init_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_UNKNOWN);
+	init_cdrom_command(&cgc, 16, CGC_DATA_UNKNOWN);
 
 	stat = cdrom_mode_sense(cdi, &cgc, GPMODE_CDROM_PAGE, 0);
 	if (stat)
 		return stat;
 
-	spindown = buffer[11] & 0x0f;
+	spindown = cgc.buffer[11] & 0x0f;
 	if (copy_to_user((void __user *)arg, &spindown, sizeof (char)))
 		return -EFAULT;
 	return 0;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/leds/Kconfig linux-2.6.23.1-stm/drivers/leds/Kconfig
--- linux-2.6.23.1/drivers/leds/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/leds/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -101,6 +101,13 @@
 	  outputs. To be useful the particular board must have LEDs
 	  and they must be connected to the GPIO lines.
 
+config LEDS_MB374
+	tristate "LED Support for STMicroelectronics mb374 LEDs"
+	depends on LEDS_CLASS && SH_ST_MB374
+	help
+	  This option enables support for the LEDs on the STMicroelectronics
+	  mb374 (ST40RA Starter board).
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/leds/Makefile linux-2.6.23.1-stm/drivers/leds/Makefile
--- linux-2.6.23.1/drivers/leds/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/leds/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -17,6 +17,10 @@
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
 obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
+obj-$(CONFIG_LEDS_MB374)		+= leds-mb374.o
+obj-$(CONFIG_SH_ST_MB411)		+= leds-mb411.o
+obj-$(CONFIG_SH_ST_MB411)		+= leds-mb411.o
+obj-$(CONFIG_SH_ST_MB519)		+= leds-mb519.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/leds/leds-mb374.c linux-2.6.23.1-stm/drivers/leds/leds-mb374.c
--- linux-2.6.23.1/drivers/leds/leds-mb374.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/leds/leds-mb374.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,98 @@
+/*
+ * linux/drivers/leds/leds-mb374.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <linux/stm/pio.h>
+#include <asm/io.h>
+#include <asm/mb374/harp.h>
+
+struct mb374_led {
+	struct led_classdev	cdev;
+	union {
+		struct stpio_pin *pio;
+		int bit;
+	} u;
+};
+
+static void mb374_led_pio_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	struct mb374_led *led_dev =
+		container_of(led_cdev, struct mb374_led, cdev);
+	stpio_set_pin(led_dev->u.pio, brightness);
+}
+
+static void mb374_led_epld_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	struct mb374_led *led_dev =
+		container_of(led_cdev, struct mb374_led, cdev);
+	ctrl_outl(1 << led_dev->u.bit, brightness ? EPLD_LED_SET : EPLD_LED_CLR);
+}
+
+#define MB374_EPLD_LED(_n, _bit)				\
+	{							\
+		.cdev = {					\
+			.name = "mb374-led" #_n,		\
+			.brightness_set = mb374_led_epld_set,	\
+		},						\
+		.u.bit = _bit					\
+	}
+#define MB374_PIO_LED(_n)					\
+	{							\
+		.cdev = {					\
+			.name = "mb374-led" #_n,		\
+			.brightness_set = mb374_led_pio_set,	\
+		},						\
+	}
+
+static struct mb374_led mb374_leds[8] = {
+	MB374_EPLD_LED(0,0),
+	MB374_EPLD_LED(1,1),
+	MB374_EPLD_LED(2,2),
+	MB374_EPLD_LED(3,3),
+	MB374_EPLD_LED(4,4),
+	MB374_EPLD_LED(5,5),
+	MB374_PIO_LED(6),
+	MB374_PIO_LED(7)
+};
+
+static int __init mb374_led_init(void)
+{
+	int i;
+
+	mb374_leds[6].u.pio = stpio_request_pin(0,3, "LED", STPIO_OUT);
+	mb374_leds[7].u.pio = stpio_request_pin(0,0, "LED", STPIO_OUT);
+
+	mb374_leds[0].cdev.default_trigger = "heartbeat";
+
+	for (i=0; i<8; i++) {
+		led_classdev_register(NULL, &mb374_leds[i].cdev);
+	}
+}
+
+static void __exit mb374_led_exit(void)
+{
+	int i;
+
+	for (i=0; i<8; i++) {
+		led_classdev_unregister(&mb374_leds[i].cdev);
+	}
+}
+
+module_init(mb374_led_init);
+module_exit(mb374_led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Front LED support for Mb374 Server");
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/leds/leds-mb411.c linux-2.6.23.1-stm/drivers/leds/leds-mb411.c
--- linux-2.6.23.1/drivers/leds/leds-mb411.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/leds/leds-mb411.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,46 @@
+/*
+ * linux/drivers/leds/leds-mb411.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <asm/io.h>
+#include <asm/mb411/harp.h>
+
+static void mb411_led_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	ctrl_outl(EPLD_LED, brightness ? EPLD_LED_ON : EPLD_LED_OFF);
+}
+
+static struct led_classdev mb411_led = {
+	.name = "mb411-led",
+	.brightness_set = mb411_led_set,
+	.default_trigger = "heartbeat";
+};
+
+static int __init mb411_led_init(void)
+{
+	led_classdev_register(NULL, &mb411_led);
+}
+
+static void __exit mb411_led_exit(void)
+{
+	led_classdev_unregister(&mb411_led);
+}
+
+module_init(mb411_led_init);
+module_exit(mb411_led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LED support for STMicroelectronics mb411");
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/leds/leds-mb519.c linux-2.6.23.1-stm/drivers/leds/leds-mb519.c
--- linux-2.6.23.1/drivers/leds/leds-mb519.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/leds/leds-mb519.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+ * linux/drivers/leds/leds-mb519.c
+ *
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This actually controls the heartbeat LED (LD12T) on the mb520 application
+ * board, as the mb519 has no software controllable LEDs itself.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <linux/stm/pio.h>
+#include <asm/io.h>
+
+static struct stpio_pin *led;
+
+static void mb519_led_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	stpio_set_pin(led, !brightness);
+}
+
+static struct led_classdev mb519_led = {
+	.name = "mb519-led",
+	.brightness_set = mb519_led_set,
+	.default_trigger = "heartbeat";
+};
+
+static int __init mb519_led_init(void)
+{
+	led = stpio_request_pin(4, 7, "LED", STPIO_OUT);
+	if (led != NULL)
+		led_classdev_register(NULL, &mb519_led);
+}
+
+static void __exit mb519_led_exit(void)
+{
+	led_classdev_unregister(&mb519_led);
+}
+
+module_init(mb519_led_init);
+module_exit(mb519_led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LED support for STMicroelectronics mb519");
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/mtd/chips/cfi_cmdset_0001.c linux-2.6.23.1-stm/drivers/mtd/chips/cfi_cmdset_0001.c
--- linux-2.6.23.1/drivers/mtd/chips/cfi_cmdset_0001.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/mtd/chips/cfi_cmdset_0001.c	2007-11-01 12:00:41.000000000 +0000
@@ -184,11 +184,12 @@
 }
 #endif
 
-static void fixup_st_m28w320ct(struct mtd_info *mtd, void* param)
+static void fixup_st_m28wXX0_disable_bufferwrite(struct mtd_info *mtd, void* param)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 
+	printk(KERN_INFO "Using word write for ST M28WXX0 FLASH\n");
 	cfi->cfiq->BufWriteTimeoutTyp = 0;	/* Not supported */
 	cfi->cfiq->BufWriteTimeoutMax = 0;	/* Not supported */
 }
@@ -239,11 +240,17 @@
 #ifdef CMDSET0001_DISABLE_WRITE_SUSPEND
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_no_write_suspend, NULL },
 #endif
+	{ CFI_MFR_ST, 0x00ba, /* M28W320CT */ fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x00bb, /* M28W320CB */ fixup_st_m28w320cb, NULL },
+	{ CFI_MFR_ST, 0x8857, fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x8858, fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x8859, fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x880a, fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x880b, fixup_st_m28wXX0_disable_bufferwrite, NULL },
+	{ CFI_MFR_ST, 0x880c, fixup_st_m28wXX0_disable_bufferwrite, NULL },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL },
 #endif
-	{ CFI_MFR_ST, 0x00ba, /* M28W320CT */ fixup_st_m28w320ct, NULL },
-	{ CFI_MFR_ST, 0x00bb, /* M28W320CB */ fixup_st_m28w320cb, NULL },
 	{ MANUFACTURER_INTEL, 0x891c,	      fixup_use_powerup_lock, NULL, },
 	{ 0, 0, NULL, NULL }
 };
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/Kconfig linux-2.6.23.1-stm/drivers/net/Kconfig
--- linux-2.6.23.1/drivers/net/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/Kconfig	2007-11-01 12:00:43.000000000 +0000
@@ -135,6 +135,17 @@
 
 	  If you don't know what to use this for, you don't need it.
 
+config NWHW_CONFIG
+	bool "Configure network hardware from the command line"
+	depends on NETDEVICES
+	---help---
+	  Many network drivers now support hardware level configuration via
+	  utilities such as ifconfig, ethtool and mii-tool. However sometimes
+	  these settings need to be adjusted before a file system is
+	  available (typically if the root file system uses NFS). This
+	  option adds a simple kernel command line interface to configure
+	  some common network parameters.
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on PNP
@@ -883,6 +894,64 @@
 	help
 	  Use Reduced PHY MII Interface
 
+config SMSC911x
+	tristate "SMSC 911x support"
+	depends on NET_ETHERNET && SUPERH
+	select CRC32
+	---help---
+	  This is a driver for SMSC's 911x series of Ethernet chips,
+	  including the SMSC9118. Say Y if you want it
+	  compiled into the kernel, and read the file
+	  <file:drivers/net/smsc_911x/readme.txt> and the Ethernet-HOWTO,
+	  available from  <http://www.linuxdoc.org/docs.html#howto>.
+
+	  This is a modified version of the driver available from
+	  SMSC: http://www.smsc.com/main/catalog/lan9118.html
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>. The module
+	  will be called smsc911x.
+
+choice
+	depends on SMSC911x
+	prompt "SMSC 911x DMA support"
+	default SMSC911x_DMA_NONE
+
+config SMSC911x_DMA_NONE
+	bool "None"
+	---help---
+	  DMA support is disabled
+
+config SMSC911x_DMA_FIFOSEL
+	bool "Use freerunning 1D DMA and FIFOSEL"
+	---help---
+	  This transfer mode uses freerunning DMA transfers to a linear
+	  block of memory (hence the 1D transfer) which maps onto the
+	  911x's FIFO register. To do this the the FIFOSEL pin must be
+	  connected to EMI address pin A16.
+
+config SMSC911x_DMA_2D
+	bool "Use freerunning 2D DMA"
+	---help---
+	  This transfer mode uses freerunning 2D transfers to the main
+	  911x register bank. This is slightly slower than either of the
+	  other options, because it makes less efficient use of the STbus,
+	  but doesn't require the FIFOSEL pin to be wired up or any
+	  pacing signals.
+
+config SMSC911x_DMA_PACED
+	bool "Use paced non-incrementing DMA"
+	---help---
+	  Enabling this option will cause SMSC 911x DMA receive transfers to
+	  use paced rather than freerunning DMA. This mainly used on boards
+	  which do not have the FIFOSEL pin wired up.
+
+	  To do this the driver needs two pacing signals which are
+	  permanently active, by default this is SSC 1 and 2 Tx empty, but
+	  this may need to be changed if either SSC is in use.
+
+endchoice
+
 config SMC9194
 	tristate "SMC 9194 support"
 	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
@@ -1958,6 +2027,17 @@
 source "drivers/net/fec_8xx/Kconfig"
 source "drivers/net/fs_enet/Kconfig"
 
+config STMMAC_ETH
+	tristate "MAC 10/100 Ethernet driver"
+	select MII
+	select PHYLIB
+	depends on NETDEVICES && (CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200)
+	---help---
+	  This is the driver for the MAC 10/100 on-chip Ethernet controller.
+	  The STb7109 ETH subsystem is composed of three main layers:
+	  a DMA layer, a Transaction Layer Interface (TLI), and a Media Access
+	  Controller layer (MAC).
+
 endif # NET_ETHERNET
 
 #
@@ -2426,6 +2506,12 @@
 	  To compile this driver as a module, choose M here.  The module
 	  will be called atl1.
 
+config STMGMAC_ETH
+	tristate "Gigabit Ethernet support (EXPERIMENTAL)"
+	depends on NETDEVICES && NOT_YET_SUPPORTED
+	---help---
+	  This is the driver for the GMAC on-chip Ethernet controller.
+
 endif # NETDEV_1000
 
 #
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/Makefile linux-2.6.23.1-stm/drivers/net/Makefile
--- linux-2.6.23.1/drivers/net/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -91,6 +91,7 @@
 obj-$(CONFIG_SHAPER) += shaper.o
 obj-$(CONFIG_HP100) += hp100.o
 obj-$(CONFIG_SMC9194) += smc9194.o
+obj-$(CONFIG_SMSC911x) += smsc_911x/
 obj-$(CONFIG_FEC) += fec.o
 obj-$(CONFIG_68360_ENET) += 68360enet.o
 obj-$(CONFIG_WD80x3) += wd.o 8390.o
@@ -207,6 +208,7 @@
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 obj-$(CONFIG_PASEMI_MAC) += pasemi_mac.o
 obj-$(CONFIG_MLX4_CORE) += mlx4/
+obj-$(CONFIG_STMMAC_ETH) += stmmac/
 
 obj-$(CONFIG_MACB) += macb.o
 
@@ -236,3 +238,6 @@
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
 obj-$(CONFIG_NETXEN_NIC) += netxen/
+
+# This needs to be after any devices which may use it
+obj-$(CONFIG_NWHW_CONFIG) += nwhwconfig.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/nwhwconfig.c linux-2.6.23.1-stm/drivers/net/nwhwconfig.c
--- linux-2.6.23.1/drivers/net/nwhwconfig.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/nwhwconfig.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,258 @@
+/*
+ * Configuration of network device hardware from the kernel command line.
+ *
+ * Copyright (c) STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/utsname.h>
+#include <linux/in.h>
+#include <linux/if.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/socket.h>
+#include <linux/route.h>
+#include <linux/udp.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/ipconfig.h>
+
+#include <asm/uaccess.h>
+#include <net/checksum.h>
+#include <asm/processor.h>
+
+#undef NWHWDEBUG
+#define NWHW_MAX_DEV NETDEV_BOOT_SETUP_MAX
+
+static struct eth_dev {
+	char user_dev_name[IFNAMSIZ];
+	char user_hw_addr[18];
+	int user_speed;
+	int user_duplex;
+} nwhwdev[NWHW_MAX_DEV];
+
+static int __init hex_conv_nibble(char x)
+{
+	if ((x >= '0') && (x <= '9'))
+		return x - '0';
+	if ((x >= 'a') && (x <= 'f'))
+		return x - 'a' + 10;
+	if ((x >= 'A') && (x <= 'F'))
+		return x - 'A' + 10;
+
+	return -1;
+}
+
+static int __init parse_ether(const char *mac_addr_str, struct sockaddr *addr)
+{
+	int i, c1, c2;
+	char *mac_addr = addr->sa_data;
+
+	/*
+	 * Pull out 6 two-digit hex chars
+	 */
+	for (i = 0; i < 6; i++) {
+
+		c1 = hex_conv_nibble(*mac_addr_str++);
+		c2 = hex_conv_nibble(*mac_addr_str++);
+
+		if ((c1 == -1) || (c2 == -1))
+			return 0;
+
+		mac_addr[i] = (c1 << 4) | c2;
+
+		if ((i != 5) && (*mac_addr_str++ != ':'))
+			return 0;
+	}
+
+	return 1;
+}
+
+/**
+ *  nwhw_config
+ *  @dev : net device pointer
+ *  Description:
+ *	it sets the MAC address.
+ *	Note that if the network device driver already uses a right
+ *	address this function doesn't replace any value.
+ */
+static int __init nwhw_config(void)
+{
+	struct net_device *dev;
+	struct sockaddr ether_addr;
+	int valid_ether;
+	int ndev = 0;
+
+	while ((ndev < NWHW_MAX_DEV) &&
+	       (dev = __dev_get_by_name(nwhwdev[ndev].user_dev_name))) {
+
+		if (!dev)
+			break;
+
+		if (!is_valid_ether_addr(dev->dev_addr)) {
+			valid_ether = nwhwdev[ndev].user_hw_addr[0];
+
+			if (valid_ether) {
+				valid_ether =
+				    parse_ether(nwhwdev[ndev].user_hw_addr,
+						&ether_addr);
+				if (!valid_ether) {
+					printk("failed to parse addr: %s\n",
+					       nwhwdev[ndev].user_hw_addr);
+				}
+			}
+			printk(KERN_INFO "%s: (%s) setting mac address: %s\n",
+			       __FUNCTION__, nwhwdev[ndev].user_dev_name,
+			       nwhwdev[ndev].user_hw_addr);
+
+			if (valid_ether) {
+				if ((!dev->set_mac_address ||
+				     dev->set_mac_address(dev, &ether_addr))) {
+					printk(KERN_WARNING
+					       "%s: not set MAC address...\n",
+					       __FUNCTION__);
+				}
+			}
+		}
+
+		if ((nwhwdev[ndev].user_speed != -1) ||
+		    (nwhwdev[ndev].user_duplex != -1)) {
+			struct ethtool_cmd cmd = { ETHTOOL_GSET };
+
+			if (!dev->ethtool_ops->get_settings ||
+			    (dev->ethtool_ops->get_settings(dev, &cmd) < 0)) {
+				printk
+				    ("Failed to read ether device settings\n");
+			} else {
+				cmd.cmd = ETHTOOL_SSET;
+				cmd.autoneg = AUTONEG_DISABLE;
+				if (nwhwdev[ndev].user_speed != -1)
+					cmd.speed = nwhwdev[ndev].user_speed;
+				if (nwhwdev[ndev].user_duplex != -1)
+					cmd.duplex = nwhwdev[ndev].user_duplex;
+				if (!dev->ethtool_ops->set_settings ||
+				    (dev->ethtool_ops->set_settings(dev, &cmd) <
+				     0)) {
+					printk
+					    ("Failed to set ether device settings\n");
+				}
+			}
+		}
+		ndev++;
+	}
+	return (0);
+}
+
+device_initcall(nwhw_config);
+
+#if defined (CONFIG_NETPOLL)
+void nwhw_uconfig(struct net_device *dev)
+{
+	struct sockaddr ether_addr;
+	int ndev = 0;
+	int valid_ether = valid_ether = nwhwdev[ndev].user_hw_addr[0];
+
+	printk(KERN_DEBUG "%s\n", __FUNCTION__);
+	while (ndev < NWHW_MAX_DEV) {
+		if (valid_ether) {
+			valid_ether = parse_ether(nwhwdev[ndev].user_hw_addr,
+						  &ether_addr);
+			if (!valid_ether) {
+				printk(KERN_WARNING
+				       "\tfailed to parse ether addr\n");
+			}
+		}
+		if (valid_ether) {
+			if (!dev->set_mac_address ||
+			    dev->set_mac_address(dev, &ether_addr)) {
+				printk(KERN_WARNING "\tnot set MAC address\n");
+			}
+		}
+		ndev++;
+	}
+	return;
+}
+#endif
+
+static void nwhw_print_args(void)
+{
+#ifdef NWHWDEBUG
+	int i;
+	printk("%s\n", __FUNCTION__);
+	for (i = 0; i < NWHW_MAX_DEV; i++) {
+		printk("\t%d) %s, addr %s, speed %d, duplex %s\n", i,
+		       nwhwdev[i].user_dev_name, nwhwdev[i].user_hw_addr,
+		       nwhwdev[i].user_speed,
+		       (nwhwdev[i].user_duplex) ? "Full" : "Half");
+	}
+#endif
+	return;
+}
+
+/**
+ *  nwhw_config_setup - parse the nwhwconfig parameters
+ *  @str : pointer to the nwhwconfig parameter
+ *  Description:
+ *  This function parses the nwhwconfig command line argumets.
+ *  Command line syntax:
+ *	nwhwconf=device:eth0,hwaddr:<mac0>[,speed:<speed0>][,duplex:<duplex0>];
+		 device:eth1,hwaddr:<mac1>[,speed:<speed1>][,duplex:<duplex1>];
+		...
+ */
+static int __init nwhw_config_setup(char *str)
+{
+	char *opt;
+	int j = 0;
+
+	if (!str || !*str)
+		return 0;
+	while (((opt = strsep(&str, ";")) != NULL) && (j < NWHW_MAX_DEV)) {
+		char *p;
+		nwhwdev[j].user_speed = -1;
+		nwhwdev[j].user_duplex = -1;
+		while ((p = strsep(&opt, ",")) != NULL) {
+			if (!strncmp(p, "device:", 7)) {
+				strlcpy(nwhwdev[j].user_dev_name, p + 7,
+					sizeof(nwhwdev[j].user_dev_name));
+			} else if (!strncmp(p, "hwaddr:", 7)) {
+				strlcpy(nwhwdev[j].user_hw_addr, p + 7,
+					sizeof(nwhwdev[j].user_hw_addr));
+			} else if (!strncmp(p, "speed:", 6)) {
+				switch (simple_strtoul(p + 6, NULL, 0)) {
+				case 10:
+					nwhwdev[j].user_speed = SPEED_10;
+					break;
+				case 100:
+					nwhwdev[j].user_speed = SPEED_100;
+					break;
+				}
+			} else if (!strcmp(p, "duplex:full")) {
+				nwhwdev[j].user_duplex = DUPLEX_FULL;
+			} else if (!strcmp(p, "duplex:half")) {
+				nwhwdev[j].user_duplex = DUPLEX_HALF;
+			}
+		}
+		j++;
+	}
+
+	nwhw_print_args();
+
+	return (0);
+}
+
+__setup("nwhwconf=", nwhw_config_setup);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/Kconfig linux-2.6.23.1-stm/drivers/net/phy/Kconfig
--- linux-2.6.23.1/drivers/net/phy/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/Kconfig	2007-11-01 12:00:40.000000000 +0000
@@ -13,7 +13,7 @@
 
 if PHYLIB
 
-comment "MII PHY device drivers"
+comment "PHY device drivers"
 
 config MARVELL_PHY
 	tristate "Drivers for Marvell PHYs"
@@ -60,6 +60,24 @@
 	---help---
 	  Currently supports the IP175C PHY.
 
+config STE10XP
+	depends on PHYLIB
+        tristate "Driver for STM STe10Xp PHY"
+        ---help---
+          This is the driver for the STe100p and STe101p PHYs.
+	  The STe101p PHY is found on the ST DB666 daughter card for the MB411.
+	  The STe100p PHY is found on the STb7109REF (CoCo) board.
+          Say Y if you want it compiled into the kernel. To compile this
+          driver as a module, choose M here.
+
+config LAN8700
+	depends on PHYLIB
+        bool "Driver for SMSC Lan8700 PHY"
+        ---help---
+          This is the driver for the SMSC Lan8700 PHY.
+          Say Y if you want it compiled into the kernel. To compile this
+          driver as a module, choose M here.
+
 config FIXED_PHY
 	tristate "Drivers for PHY emulation on fixed speed/link"
 	---help---
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/Makefile linux-2.6.23.1-stm/drivers/net/phy/Makefile
--- linux-2.6.23.1/drivers/net/phy/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -12,4 +12,6 @@
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
 obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+obj-$(CONFIG_STE10XP)		+= ste10Xp.o
+obj-$(CONFIG_LAN8700)		+= smsc8700.o
 obj-$(CONFIG_FIXED_PHY)		+= fixed.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/mdio_bus.c linux-2.6.23.1-stm/drivers/net/phy/mdio_bus.c
--- linux-2.6.23.1/drivers/net/phy/mdio_bus.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/mdio_bus.c	2007-11-01 12:00:41.000000000 +0000
@@ -81,6 +81,7 @@
 		 * 5) mii_bus
 		 * And, we need to register it */
 		if (phydev) {
+			printk(KERN_DEBUG "mdiobus_register: found PHY and assigning IRQ %d\n", bus->irq[i]);
 			phydev->irq = bus->irq[i];
 
 			phydev->dev.parent = bus->dev;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/phy_device.c linux-2.6.23.1-stm/drivers/net/phy/phy_device.c
--- linux-2.6.23.1/drivers/net/phy/phy_device.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/phy_device.c	2007-11-01 12:00:40.000000000 +0000
@@ -105,8 +105,8 @@
 
 	phy_id |= (phy_reg & 0xffff);
 
-	/* If the phy_id is all Fs, there is no device there */
-	if (0xffffffff == phy_id)
+	/* If the phy_id is mostly Fs, there is no device there */
+	if ((phy_id & 0x1fffffff) == 0x1fffffff)
 		return NULL;
 
 	dev = phy_device_create(bus, addr, phy_id);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/smsc8700.c linux-2.6.23.1-stm/drivers/net/phy/smsc8700.c
--- linux-2.6.23.1/drivers/net/phy/smsc8700.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/smsc8700.c	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,181 @@
+/* ============================================================================
+ * This is a driver for the SMSC LAN8700 PHY controller
+ *
+ * Copyright (C) 2006 ST Microelectronics (R&D) Ltd.
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   Sep 2006
+ *	Converted PHY driver to new 2.6.17 PHY device
+ *	Carl Shaw <carl.shaw@st.com>
+ *	Added contributions by Steve Glendinning <Steve.Glendinning@smsc.com>
+ *   July 2006
+ *	Copied from the STe101p PHY driver (originally written by
+ *	Giuseppe Cavallaro <peppe.cavallaro@st.com>) by
+ *	Nigel Hathaway <nigel.hathaway@st.com>
+ * ===========================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/delay.h>
+
+#undef PHYDEBUG
+#define DEFAULT_PHY_ID  0
+#define RESOURCE_NAME	"lan8700"
+
+
+/* LAN8700 vendor-specific registers */
+#define MII_REV		0x10	/* Silicon revision register */
+#define MII_MCSR	0x11	/* Mode control/status register */
+#define MII_SMR		0x12	/* Special modes register */
+#define MII_SCSIR	0x1b	/* Special control/status indications register */
+#define MII_SITCR	0x1c	/* Special internal testability controls register */
+#define MII_ISR		0x1d	/* Interrupt source register */
+#define MII_IMR		0x1e	/* Interrupt mask register */
+#define MII_PSCSR	0x1f	/* PHY Special control/status register */
+
+#define MII_SCSIR_AMDIXCTRL	0x8000	/* Auto-MDIX control (1 to disable AMDIX) */
+#define MII_SCSIR_CH_SELECT	0x2000	/* MDIX control (1 for AMDIX) */
+
+/* LAN8700 Interrupt Source Register values */
+#define MII_ISR_ANPR	0x0002	/* Auto-Negotiation page received */
+#define MII_ISR_PDF	0x0004	/* Parallel detection fault */
+#define MII_ISR_ANLA	0x0008	/* Auto-Negotiation LP Acknowledge */
+#define MII_ISR_LINK	0x0010	/* Link down (status negated) */
+#define MII_ISR_RFLT	0x0020	/* Remote fault detected */
+#define MII_ISR_ANC	0x0040	/* Auto-Negotiation completed */
+#define MII_ISR_EOG	0x0080	/* ENERGYON generated */
+
+/* LAN8700 PHY Special control/status register values */
+#define MII_PSCSR_ANC		0x1000	/* Auto-Negotiation done */
+#define MII_PSCSR_SPD_MASK	0x001C	/* HCDSPEED value */
+#define MII_PSCSR_SPD_10	0x0004	/* 10Mbps */
+#define MII_PSCSR_SPD_100	0x0008	/* 100Mbps */
+#define MII_PSCSR_SPD_FDPLX	0x0010	/* Full Duplex */
+
+#define MII_IMR_INTSRC_ENERGYON             0x0080
+#define MII_IMR_INTSRC_AUTONEGCOM           0x0040
+#define MII_IMR_INTSRC_REMFLT               0x0020
+#define MII_IMR_INTSRC_LNKDN                0x0010
+#define MII_IMR_INTSRC_AUTONEGLP            0x0008
+#define MII_IMR_INTSRC_PARFLT               0x0004
+#define MII_IMR_INTSRC_AUTONEGPR            0x0002
+
+#define MII_IMR_DEFAULT_MASK (MII_IMR_INTSRC_AUTONEGCOM | MII_IMR_INTSRC_REMFLT | MII_IMR_INTSRC_LNKDN)
+
+
+/* LAN8700 phy identifier values */
+#define LAN8700_PHY_ID		0x0007c0c0
+#define LAN8700_PHY_LO_ID_REVA 	0xc0c1
+#define LAN8700_PHY_LO_ID_REVB 	0xc0c2
+#define LAN8700_PHY_LO_ID_REVC 	0xc0c3
+#define LAN8700_PHY_LO_ID_REVD 	0xc0c4
+#define LAN8700_PHY_LO_ID_REVE 	0xc0c5
+#define LAN8700_PHY_LO_ID_REVF 	0xc0c6
+#define LAN8700_PHY_LO_ID_REVG 	0xc0c7
+
+static int lan8700_config_init(struct phy_device *phydev)
+{
+	int value, err;
+	int timeout = 1000;
+
+	/* Enable the MODE pins to enable autoneg */
+	value = phy_read(phydev, MII_SMR);
+	if (value < 0)
+                return value;
+	value |= 0x0E0;
+	err = phy_write(phydev, MII_SMR, value);
+	if (err < 0)
+		return err;
+	/* Software Reset PHY */
+	value = phy_read(phydev, MII_BMCR);
+	if (value < 0)
+		return value;
+
+	value |= BMCR_RESET;
+	err = phy_write(phydev, MII_BMCR, value);
+	if (err < 0)
+		return err;
+
+	do{
+		mdelay(1);
+		value = phy_read(phydev, MII_BMCR);
+	} while ((value & BMCR_RESET) && (--timeout));
+
+	if (!timeout){
+		printk(KERN_ERR "LAN8700 PHY timed out during reset!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int lan8700_config_intr(struct phy_device *phydev)
+{
+        int err, value;
+
+        if(phydev->interrupts == PHY_INTERRUPT_ENABLED){
+		/* Enable interrupts */
+		err = phy_write(phydev, MII_IMR, MII_IMR_DEFAULT_MASK);
+		/* clear any pending interrupts */
+		if (err == 0){
+			value = phy_read(phydev, MII_ISR);
+			if (value <0){
+				err = value;
+			}
+		}
+	} else
+		err = phy_write(phydev, MII_IMR, 0);
+
+        return err;
+}
+
+static int lan8700_ack_interrupt(struct phy_device *phydev)
+{
+        int err = phy_read(phydev, MII_ISR);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+static struct phy_driver lan8700_pdriver = {
+        .phy_id         = LAN8700_PHY_ID,
+        .phy_id_mask    = 0xfffffff0,
+        .name           = "LAN8700",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = lan8700_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = lan8700_ack_interrupt,
+        .config_intr    = lan8700_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static int __init lan8700_init(void)
+{
+	int retval;
+
+	return phy_driver_register(&lan8700_pdriver);
+}
+
+static void __exit lan8700_exit(void)
+{
+	phy_driver_unregister(&lan8700_pdriver);
+}
+
+module_init(lan8700_init);
+module_exit(lan8700_exit);
+
+MODULE_DESCRIPTION("SMSC LAN8700 PHY driver");
+MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/phy/ste10Xp.c linux-2.6.23.1-stm/drivers/net/phy/ste10Xp.c
--- linux-2.6.23.1/drivers/net/phy/ste10Xp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/phy/ste10Xp.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,157 @@
+/* ============================================================================
+ * This is a driver for the STe101p and STe100p PHY controllers.
+ *
+ * Copyright (C) 2006 by Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   May 2007
+ *      Changed 101p PHY ID and mask to allow REV B variants
+ *   Aug  2006
+ *	Converted PHY driver to new 2.6.17 PHY device
+ *	Added STe100p support
+ *	Carl Shaw <carl.shaw@st.com>
+ *   July 2006
+ *	- Minor fixes.
+ *   May 2006
+ *	- It's indipendend from the STb7109eth driver.
+ *   April 2006 (first release of the driver):
+ *	- Added the RMII interface support.
+ * 	- The driver has been tested, on the MB411 platform with the DB666
+ * 	  daughter board, using:
+ *		- the clock through the STPIO3[7],
+ *		- the clock through an external clock generator device.
+ *	- Added the "fix_mac_speed" function: it is used for changing
+ *	  the MAC speed field in the SYS_CFG7 register.
+ *	  (required when we are using the RMII interface).
+ *
+ * ----------------------------------------------------------------------------
+ * Known bugs:
+ * 	The SMII mode is not supported yet.
+ * ===========================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#undef PHYDEBUG
+#define DEFAULT_PHY_ID  0
+#define RESOURCE_NAME	"ste10Xp"
+
+#define MII_XCIIS   	0x11 /* Configuration Info IRQ & Status Reg*/
+#define MII_XIE     	0x12 /* Interrupt Enable Register*/
+#define MII_XIE_DEFAULT_MASK 0x0070 /* ANE complete, Remote Fault, Link Down */
+
+/* STE101P phy identifier values */
+#define STE101P_PHY_ID		0x00061c50
+
+/* STe100P phy identifier values */
+#define STE100P_PHY_ID       	0x1c040011
+
+static int ste10Xp_config_init(struct phy_device *phydev)
+{
+	int value, err;
+
+	/* Software Reset PHY */
+	value = phy_read(phydev, MII_BMCR);
+	if (value < 0)
+		return value;
+
+	value |= BMCR_RESET;
+	err = phy_write(phydev, MII_BMCR, value);
+	if (err < 0)
+		return err;
+
+	do{
+		value = phy_read(phydev, MII_BMCR);
+	} while (value & BMCR_RESET);
+
+	return 0;
+}
+
+static int ste10Xp_config_intr(struct phy_device *phydev)
+{
+        int err, value;
+
+        if(phydev->interrupts == PHY_INTERRUPT_ENABLED){
+		/* Enable all STe101P interrupts (PR12) */
+		err = phy_write(phydev, MII_XIE, MII_XIE_DEFAULT_MASK);
+		/* clear any pending interrupts */
+		if (err == 0){
+			value = phy_read(phydev, MII_XCIIS);
+			if (value <0){
+				err = value;
+			}
+		}
+	} else
+		err = phy_write(phydev, MII_XIE, 0);
+
+        return err;
+}
+
+static int ste10Xp_ack_interrupt(struct phy_device *phydev)
+{
+        int err = phy_read(phydev, MII_XCIIS);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+static struct phy_driver ste101p_pdriver = {
+        .phy_id         = STE101P_PHY_ID,
+        .phy_id_mask    = 0xfffffff0,
+        .name           = "STe101p",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = ste10Xp_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = ste10Xp_ack_interrupt,
+        .config_intr    = ste10Xp_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static struct phy_driver ste100p_pdriver = {
+        .phy_id         = STE100P_PHY_ID,
+        .phy_id_mask    = 0xffffffff,
+        .name           = "STe100p",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = ste10Xp_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = ste10Xp_ack_interrupt,
+        .config_intr    = ste10Xp_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static int __init ste10Xp_init(void)
+{
+	int retval;
+
+	retval = phy_driver_register(&ste100p_pdriver);
+	if (retval < 0)
+		return retval;
+	return phy_driver_register(&ste101p_pdriver);
+}
+
+static void __exit ste10Xp_exit(void)
+{
+	phy_driver_unregister(&ste100p_pdriver);
+	phy_driver_unregister(&ste101p_pdriver);
+}
+
+module_init(ste10Xp_init);
+module_exit(ste10Xp_exit);
+
+MODULE_DESCRIPTION("STe10Xp PHY driver");
+MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smc91x.c linux-2.6.23.1-stm/drivers/net/smc91x.c
--- linux-2.6.23.1/drivers/net/smc91x.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smc91x.c	2007-11-01 12:00:40.000000000 +0000
@@ -1740,6 +1740,140 @@
 	lp->msg_enable = level;
 }
 
+static int smc_ethtool_get_eeprom_len(struct net_device *dev)
+{
+	return EEPROM_SIZE;
+}
+
+static int smc_eeprom_rw(struct net_device *dev, int offset, u16* val,
+			 int write)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long endtime;
+	unsigned long ioaddr = dev->base_addr;
+	int res = 0;
+	unsigned int ctl;
+	unsigned int cmd = write ? CTL_STORE : CTL_RELOAD;
+
+	spin_lock_irq(&lp->lock);
+
+	/* We want RELOAD operations to affect the GP */
+	SMC_SELECT_BANK(1);
+	ctl = SMC_GET_CTL();
+	SMC_SET_CTL(ctl | CTL_EEPROM_SELECT);
+
+	/* Set the address */
+	SMC_SELECT_BANK(2);
+	SMC_SET_PTR(offset);
+
+	SMC_SELECT_BANK(1);
+
+	if (write) {
+		SMC_outw(*val, ioaddr, GP_REG);
+	}
+
+	/* Trigger read or write */
+	SMC_SET_CTL(ctl | CTL_EEPROM_SELECT | cmd);
+
+	/* Wait for completion of read or write */
+	endtime = jiffies + (HZ/10);
+	do {
+		if (time_after(jiffies, endtime)) {
+			printk(KERN_WARNING "%s: Failed to read EEPROM\n", dev->name);
+			res = -EFAULT;
+			goto out;
+		}
+	} while (SMC_GET_CTL() & cmd);
+
+	if (! write) {
+		*val = SMC_inw(ioaddr, GP_REG);
+	}
+
+out:
+	/* Restore Control Register */
+	SMC_SET_CTL(ctl);
+	SMC_SELECT_BANK(2);
+
+	spin_unlock_irq(&lp->lock);
+	return res;
+}
+
+static int smc_ethtool_geteeprom(struct net_device *dev,
+        struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	int res;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset + len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		*bytes++ = tmp >> 8;
+		offset++;
+		len--;
+	}
+
+	for ( ; len > 1; len -= 2) {
+		res = smc_eeprom_rw(dev, offset >> 1, (u16*)bytes, 0);
+		if (res) return res;
+		bytes += 2;
+		offset += 2;
+	}
+
+	if (len > 0) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		*bytes = tmp & 0xff;
+	}
+
+	return 0;
+}
+
+static int smc_ethtool_seteeprom(struct net_device *dev,
+	struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	int res;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset + len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		tmp = (*bytes++ << 8) | (tmp & 0xff);
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 1);
+		if (res) return res;
+		offset++;
+		len--;
+	}
+
+	for ( ; len > 1; len -= 2) {
+		res = smc_eeprom_rw(dev, offset >> 1, (u16*)bytes, 1);
+		if (res) return res;
+		bytes += 2;
+		offset += 2;
+	}
+
+	if (len > 0) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		tmp = (tmp & 0xff00) | (*bytes);
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 1);
+		if (res) return res;
+	}
+
+	return 0;
+}
+
 static const struct ethtool_ops smc_ethtool_ops = {
 	.get_settings	= smc_ethtool_getsettings,
 	.set_settings	= smc_ethtool_setsettings,
@@ -1749,8 +1883,9 @@
 	.set_msglevel	= smc_ethtool_setmsglevel,
 	.nway_reset	= smc_ethtool_nwayreset,
 	.get_link	= ethtool_op_get_link,
-//	.get_eeprom	= smc_ethtool_geteeprom,
-//	.set_eeprom	= smc_ethtool_seteeprom,
+	.get_eeprom_len	= smc_ethtool_get_eeprom_len,
+	.get_eeprom	= smc_ethtool_geteeprom,
+	.set_eeprom	= smc_ethtool_seteeprom,
 };
 
 /*
@@ -2030,15 +2165,14 @@
 		printk("%s%s\n", nowait ? " [nowait]" : "",
 			THROTTLE_TX_PKTS ? " [throttle_tx]" : "");
 
+		/* Print the Ethernet address */
+		printk("%s: Ethernet addr: ", dev->name);
+		for (i = 0; i < 5; i++)
+			printk("%2.2x:", dev->dev_addr[i]);
+		printk("%2.2x\n", dev->dev_addr[5]);
 		if (!is_valid_ether_addr(dev->dev_addr)) {
 			printk("%s: Invalid ethernet MAC address.  Please "
 			       "set using ifconfig\n", dev->name);
-		} else {
-			/* Print the Ethernet address */
-			printk("%s: Ethernet addr: ", dev->name);
-			for (i = 0; i < 5; i++)
-				printk("%2.2x:", dev->dev_addr[i]);
-			printk("%2.2x\n", dev->dev_addr[5]);
 		}
 
 		if (lp->phy_type == 0) {
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smc91x.h linux-2.6.23.1-stm/drivers/net/smc91x.h
--- linux-2.6.23.1/drivers/net/smc91x.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smc91x.h	2007-11-01 12:00:42.000000000 +0000
@@ -268,6 +268,61 @@
 
 #define SMC_IRQ_FLAGS		(0)
 
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
+
+#if defined(CONFIG_SH_ST_MB411) || \
+      defined(CONFIG_SH_ST_MB442) || \
+      defined(CONFIG_SH_ST_MB448)
+/* 16 bit on board SMC91C111. No address shifting required.
+ * Note we can't set SMC_CAN_USE_32BIT. This would causes SMC_SELECT_BANK
+ * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
+ * This bypasses the special logic which would prevent this also updating
+ * this interrupt mask register. */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_CAN_USE_32BIT_DATA	1
+#define SMC_IO_SHIFT		0
+#else
+#error Unknown board
+#endif
+
+#define SMC_NOWAIT		0
+#define SMC_IRQ_FLAGS		0
+
+#ifdef SMC_STEM_BS_MASK
+/*
+ * We have to shift all addresses up by 1, because the STEM
+ * module connects A2 from the CPU to to A1 on the SMC device.
+ * This was done for compatibility with the ST20 EMI, which
+ * apparently does the opposite.
+ * However the byte strobes are not shifted in hardware, so
+ * these need to be left in place.
+ */
+#define REG_OFFSET(base,reg) ({                         		\
+        u_int __reg = (reg);                            		\
+        __reg = ( (__reg & (~SMC_STEM_BS_MASK))                 ) |	\
+                ( (__reg & ( SMC_STEM_BS_MASK)) >> SMC_IO_SHIFT );	\
+	(void __iomem *)((base) + __reg); })
+#else
+#define REG_OFFSET(base,reg) ((void __iomem*)((base) + (reg)))
+#endif
+
+#define dprintk(str, ...) // printk(str, ## __VA_ARGS__)
+#define SMC_inb(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = readb(_p); dprintk("SMC_inb(%08p) = %02x\n", _p, _v); _v; })
+#define SMC_inw(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = readw(_p); dprintk("SMC_inw(%08p) = %04x\n", _p, _v); _v; })
+#define SMC_inl(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = readl(_p); dprintk("SMC_inl(%08p) = %08x\n", _p, _v); _v; })
+#define SMC_outb(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = (v);  dprintk("SMC_outb(%02x, %08p)\n", _v, _p); writeb(_v, _p); })
+#define SMC_outw(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = (v);  dprintk("SMC_outw(%04x, %08p)\n", _v, _p); writew(_v, _p); })
+#define SMC_outl(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = (v);  dprintk("SMC_outl(%08x, %08p)\n", _v, _p); writel(_v, _p); })
+#define SMC_insl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); readsl(_p, p, l); })
+#define SMC_outsl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); writesl(_p, p, l); })
+
+#define set_irq_type(irq, type)
+
+#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
+#define RPC_LSB_DEFAULT		RPC_LED_100_10
+
 #elif	defined(CONFIG_ISA)
 
 #define SMC_CAN_USE_8BIT	1
@@ -563,7 +618,7 @@
  * use of them.
  */
 
-#if ! SMC_CAN_USE_32BIT
+#if ! (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA)
 #define SMC_inl(ioaddr, reg)		({ BUG(); 0; })
 #define SMC_outl(x, ioaddr, reg)	BUG()
 #define SMC_insl(a, r, p, l)		BUG()
@@ -1000,6 +1055,11 @@
 
 #define ATTRIB_SIZE		((64*1024) << SMC_IO_SHIFT)
 
+/*
+ . EEPROM defintions
+ */
+#define EEPROM_SIZE		(64*2)	/* 64 x 16 bit words */
+
 
 /*
  * Macros to abstract register access according to the data bus
@@ -1219,7 +1279,7 @@
 
 #define SMC_PUSH_DATA(p, l)						\
 	do {								\
-		if (SMC_CAN_USE_32BIT) {				\
+		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
 			void __iomem *__ioaddr = ioaddr;		\
@@ -1243,7 +1303,7 @@
 
 #define SMC_PULL_DATA(p, l)						\
 	do {								\
-		if (SMC_CAN_USE_32BIT) {				\
+		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
 			void __iomem *__ioaddr = ioaddr;		\
@@ -1275,4 +1335,21 @@
 			SMC_insb(ioaddr, DATA_REG, p, l);		\
 	} while (0)
 
+#if defined(CONFIG_SH_STI5528_ESPRESSO)
+/*
+ * The Espresso doesn't appear to correctly connect the SMSC's ARDY pin
+ * to the 5528's WAIT pin. The only time this has been observed to be a
+ * problem is after setting the pointer register there may be insufficient
+ * delay before reading from the FIFO. Insert a delay here.
+ */
+#undef SMC_SET_PTR
+#define SMC_SET_PTR(x)							\
+	do {								\
+		unsigned int __val16 = (x);				\
+		SMC_outw( __val16, ioaddr, PTR_REG );			\
+		if (__val16 & PTR_READ)					\
+			ndelay(370);					\
+	} while (0)
+#endif
+
 #endif  /* _SMC91X_H_ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/COPYING linux-2.6.23.1-stm/drivers/net/smsc_911x/COPYING
--- linux-2.6.23.1/drivers/net/smsc_911x/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/COPYING	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/Makefile linux-2.6.23.1-stm/drivers/net/smsc_911x/Makefile
--- linux-2.6.23.1/drivers/net/smsc_911x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,7 @@
+obj-$(CONFIG_SMSC911x) := smsc9118.o
+
+pf-$(CONFIG_CPU_SUBTYPE_ST40)	:= st40.c
+pf-$(CONFIG_CPU_XSCALE)	:= xscale_linux_2.4.c
+
+CFLAGS_smsc9118.o += -DUSE_DEBUG
+CFLAGS_smsc9118.o += -DPLATFORM_SOURCE=\"$(pf-y)\"
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/cmd9118.c linux-2.6.23.1-stm/drivers/net/smsc_911x/cmd9118.c
--- linux-2.6.23.1/drivers/net/smsc_911x/cmd9118.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/cmd9118.c	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,1583 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: cmd9118.c
+ */
+#ifdef USING_LINT
+#include "lint.h"
+#else //not USING_LINT
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <linux/delay.h>
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <net/if.h>
+
+#include <sys/ioctl.h>
+#include <net/if_arp.h>
+#include <arpa/inet.h>
+#endif //not USING_LINT
+
+#include "ioctl_118.h"
+
+char *iam=NULL;
+
+typedef enum _bool {
+  false=0,
+  true=1
+} bool;
+
+typedef struct _COMMAND_DATA {
+	int hSockFD;
+	struct ifreq IfReq;
+	SMSC9118_IOCTL_DATA IoctlData;
+} COMMAND_DATA, *PCOMMAND_DATA;
+
+#define SOCKET	int
+#define INVALID_SOCKET	(-1)
+#define SOCKET_ERROR	(-1)
+#define DEFAULT_PORT_NUMBER		(11118U)
+SOCKET server_sock=INVALID_SOCKET;
+
+typedef struct _FLOW_PARAMS
+{
+    unsigned long MeasuredMaxThroughput;
+	unsigned long MeasuredMaxPacketCount;
+	unsigned long MaxThroughput;
+	unsigned long MaxPacketCount;
+	unsigned long PacketCost;
+	unsigned long BurstPeriod;
+	unsigned long MaxWorkLoad;
+	unsigned long IntDeas;
+} FLOW_PARAMS, * PFLOW_PARAMS;
+
+bool ParseNumber(const char *str,unsigned long *number);
+void DisplayUsage(void);
+void GetMacAddress(PCOMMAND_DATA commandData);
+void SetMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl);
+void LoadMacAddress(PCOMMAND_DATA commandData);
+void SaveMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl);
+void LanDumpRegs(PCOMMAND_DATA commandData);
+void MacDumpRegs(PCOMMAND_DATA commandData);
+void DumpEEPROM(PCOMMAND_DATA commandData);
+void DumpTemp(PCOMMAND_DATA commandData);
+void PhyDumpRegs(PCOMMAND_DATA commandData);
+void SetDebugMode(PCOMMAND_DATA commandData,
+				  unsigned long debug_mode);
+void SetLinkMode(PCOMMAND_DATA commandData,
+				 unsigned long link_mode);
+void SetPowerMode(PCOMMAND_DATA commandData,
+				  unsigned long power_mode);
+void GetLinkMode(PCOMMAND_DATA commandData);
+void CheckLink(PCOMMAND_DATA commandData);
+void GetPowerMode(PCOMMAND_DATA commandData);
+void GetFlowParams(PCOMMAND_DATA commandData);
+void GetConfiguration(PCOMMAND_DATA commandData);
+void ReadByte(PCOMMAND_DATA commandData,unsigned long address);
+void ReadWord(PCOMMAND_DATA commandData, unsigned long address);
+void ReadDWord(PCOMMAND_DATA commandData,unsigned long address);
+void WriteByte(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void WriteWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void WriteDWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void LanGetReg(PCOMMAND_DATA commandData,unsigned long address);
+void LanSetReg(PCOMMAND_DATA commandData, unsigned long address, unsigned long data);
+void MacGetReg(PCOMMAND_DATA commandData, unsigned long address);
+void MacSetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data);
+void PhyGetReg(PCOMMAND_DATA commandData, unsigned long address);
+void PhySetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data);
+bool Initialize(PCOMMAND_DATA commandData,const char *ethName);
+bool ReceiveULong(SOCKET sock,unsigned long * pDWord);
+bool SendULong(SOCKET sock,unsigned long data);
+void process_requests(PCOMMAND_DATA commandData);
+void RunServer(PCOMMAND_DATA commandData,unsigned short portNumber);
+bool ReceiveFlowParams(SOCKET sock,PFLOW_PARAMS flowParams);
+bool SendFlowParams(SOCKET sock,PFLOW_PARAMS flowParams);
+void DisplayFlowParams(PFLOW_PARAMS flowParams);
+unsigned long ReadThroughput(char * fileName);
+void RunTuner(const char *hostName,unsigned short portNum);
+
+
+bool ParseNumber(const char *str,unsigned long *number) {
+	if(str==NULL) return false;
+	if(str[0]==0) return false;
+	if((str[0]=='0')&&(str[1]=='x')) {
+		if(sscanf(&(str[2]),"%lx",number)==1) {
+			return true;
+		}
+	}
+	if(sscanf(str,"%ld",number)==1) {
+		return true;
+	}
+	return false;
+}
+
+void DisplayUsage(void) {
+	printf("usage: %s [-h] [-e adaptername] [-c command] [-a address] [-d data]\n",iam);
+	printf("       [-H host_address] [-p port_number]\n");
+	printf("  -h displays this usage information, other options ignored.\n");
+	printf("  -e specifies the adapter name (eth0,eth1...)\n");
+	printf("       if not specified then %s will attempt to\n",iam);
+	printf("       auto detect.\n");
+	printf("  -c specifies the command code\n");
+	printf("       SERVER = run in server mode\n");
+	printf("          may use -p to specify port to listen on\n");
+	printf("       TUNER = connects remotely to server to run\n");
+	printf("          automatic flow control tuning.\n");
+	printf("          use -H to specify host address\n");
+	printf("          use -p to specify port\n");
+	printf("       GET_CONFIG = gets internal variables of driver\n");
+	printf("       DUMP_REGS = dumps the LAN9118 memory mapped registers\n");
+	printf("       DUMP_MAC = dumps the LAN9118 MAC registers\n");
+	printf("       DUMP_PHY = dumps the LAN9118 PHY registers\n");
+	printf("       DUMP_EEPROM = dumps the first 8 bytes of the EEPROM\n");
+	printf("       DUMP_TEMP = dumps temp data space used for debugging\n");
+	printf("       GET_MAC = gets MAC address from ADDRH and ADDRL\n");
+	printf("       SET_MAC = sets MAC address in ADDRH and ADDRL\n");
+	printf("         -a specifies the value to write to ADDRH\n");
+	printf("         -d specifies the value to write to ADDRL\n");
+	printf("       LOAD_MAC = causes the LAN9118 to reload the MAC address\n");
+	printf("           from the external EEPROM. Also displays it\n");
+	printf("       SAVE_MAC = writes a MAC address to the EEPROM\n");
+	printf("         -a specifies the part of the MAC address that would\n");
+	printf("            appear in ADDRH\n");
+	printf("         -d specifies the part of the MAC address that would\n");
+	printf("            appear in ADDRL\n");
+	printf("       SET_DEBUG = sets the driver's internal debug_mode value\n");
+	printf("         -d specifies the debug mode\n");
+	printf("             0x01, bit 0, enables trace messages\n");
+	printf("             0x02, bit 1, enables warning messages\n");
+	printf("             0x04, bit 2, enables GPO signals\n");
+	printf("          NOTE: trace, and warning messages will only show if\n");
+	printf("             they have been turned on at driver compile time.\n");
+	printf("       SET_LINK = sets the driver's internal link_mode value\n");
+	printf("             and also attempts to relink with the new setting\n");
+	printf("         -d specifies the link mode\n");
+	printf("             1 = 10HD, 2 = 10FD, 4 = 100HD, 8 = 100FD\n");
+	printf("             to specify multiple link modes, add the values\n");
+	printf("             of each mode you want and use the sum as the link mode\n");
+	printf("       GET_LINK = gets the driver's internal link_mode value\n");
+	printf("     Warning!! Power management is not implemented as of version 0.54\n");
+	printf("       SET_POWER = sets the LAN9118 power mode\n");
+	printf("         -d specifies the power state\n");
+	printf("             0 = D0, 1 = D1, 2 = D2, 3 = D3\n");
+	printf("       GET_POWER = gets the LAN9118 power mode\n");
+	printf("       CHECK_LINK = causes the driver to recheck its link status\n");
+	printf("     Warning!! the following read and write commands may cause\n");
+	printf("     unpredictable results, including system lock up or crash.\n");
+	printf("     Use with caution\n");
+	printf("       READ_REG = reads a value from the LAN9118 Memory Map\n");
+	printf("         -a specifies offset into LAN9118 Memory Map\n");
+	printf("       WRITE_REG = writes a value to the LAN9118 Memory Map\n");
+	printf("         -a specifies offset into LAN9118 Memory Map\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_MAC = reads a value from the LAN9118 Mac registers\n");
+	printf("         -a specifies the Mac register index\n");
+	printf("       WRITE_MAC = writes a value to the LAN9118 Mac registers\n");
+	printf("         -a specifies the Mac register index\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_PHY = reads a value from the LAN9118 Phy registers\n");
+	printf("         -a specifies the Phy register index\n");
+	printf("       WRITE_PHY = writes a value to the LAN9118 Phy registers\n");
+	printf("         -a specifies the Phy register index\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_BYTE = reads a byte from a location in memory\n");
+	printf("         -a address\n");
+	printf("       READ_WORD = reads a word from a location in memory\n");
+	printf("         -a address\n");
+	printf("       READ_DWORD = reads a dword from a location in memory\n");
+	printf("         -a address\n");
+	printf("       WRITE_BYTE = write a byte to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("       WRITE_WORD = write a word to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("       WRITE_DWORD = write a dword to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("  -a specifies the address, index, or offset of a register\n");
+	printf("  -d specifies the data to write to a register\n");
+	printf("       can be decimal or hexadecimal\n");
+}
+
+void GetMacAddress(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_MAC_ADDRESS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Mac Address == 0x%04lX%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Get Mac Address\n");
+	}
+}
+void SetMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SET_MAC_ADDRESS;
+	commandData->IoctlData.Data[0]=addrh;
+	commandData->IoctlData.Data[1]=addrl;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Set Mac Address\n");
+	}
+}
+void LoadMacAddress(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LOAD_MAC_ADDRESS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Mac Address == 0x%04lX%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Load Mac Address\n");
+	}
+}
+void SaveMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SAVE_MAC_ADDRESS;
+	commandData->IoctlData.Data[0]=addrh;
+	commandData->IoctlData.Data[1]=addrl;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Save Mac Address\n");
+	}
+}
+
+void LanDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_LAN_REGS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("offset 0x50, ID_REV       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_ID_REV]);
+		printf("offset 0x54, INT_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_CFG]);
+		printf("offset 0x58, INT_STS      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_STS]);
+		printf("offset 0x5C, INT_EN       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_EN]);
+		printf("offset 0x64, BYTE_TEST    = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_BYTE_TEST]);
+		printf("offset 0x68, FIFO_INT     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FIFO_INT]);
+		printf("offset 0x6C, RX_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_CFG]);
+		printf("offset 0x70, TX_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_TX_CFG]);
+		printf("offset 0x74, HW_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_HW_CFG]);
+		printf("offset 0x78, RX_DP_CTRL   = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_DP_CTRL]);
+		printf("offset 0x7C, RX_FIFO_INF  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_FIFO_INF]);
+		printf("offset 0x80, TX_FIFO_INF  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_TX_FIFO_INF]);
+		printf("offset 0x84, PMT_CTRL     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_PMT_CTRL]);
+		printf("offset 0x88, GPIO_CFG     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPIO_CFG]);
+		printf("offset 0x8C, GPT_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPT_CFG]);
+		printf("offset 0x90, GPT_CNT      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPT_CNT]);
+		printf("offset 0x94, FPGA_REV     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FPGA_REV]);
+		printf("offset 0x98, ENDIAN       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_ENDIAN]);
+		printf("offset 0x9C, FREE_RUN     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FREE_RUN]);
+		printf("offset 0xA0, RX_DROP      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_DROP]);
+		printf("offset 0xA4, MAC_CSR_CMD  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_MAC_CSR_CMD]);
+		printf("offset 0xA8, MAC_CSR_DATA = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_MAC_CSR_DATA]);
+		printf("offset 0xAC, AFC_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_AFC_CFG]);
+		printf("offset 0xB0, E2P_CMD      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_E2P_CMD]);
+		printf("offset 0xB4, E2P_DATA     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_E2P_DATA]);
+	} else {
+		printf("Failed to DUMP registers\n");
+	}
+}
+
+void MacDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_MAC_REGS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("index 1, MAC_CR   = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MAC_CR]);
+		printf("index 2, ADDRH    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_ADDRH]);
+		printf("index 3, ADDRL    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_ADDRL]);
+		printf("index 4, HASHH    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_HASHH]);
+		printf("index 5, HASHL    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_HASHL]);
+		printf("index 6, MII_ACC  = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MII_ACC]);
+		printf("index 7, MII_DATA = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MII_DATA]);
+		printf("index 8, FLOW     = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_FLOW]);
+		printf("index 9, VLAN1    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_VLAN1]);
+		printf("index A, VLAN2    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_VLAN2]);
+		printf("index B, WUFF     = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_WUFF]);
+		printf("index C, WUCSR    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_WUCSR]);
+	} else {
+		printf("Failed to Dump Mac Registers\n");
+	}
+}
+
+void DumpEEPROM(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_EEPROM;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("EEPROM[0]=0x%02lX\n",commandData->IoctlData.Data[0]);
+		printf("EEPROM[1]=0x%02lX\n",commandData->IoctlData.Data[1]);
+		printf("EEPROM[2]=0x%02lX\n",commandData->IoctlData.Data[2]);
+		printf("EEPROM[3]=0x%02lX\n",commandData->IoctlData.Data[3]);
+		printf("EEPROM[4]=0x%02lX\n",commandData->IoctlData.Data[4]);
+		printf("EEPROM[5]=0x%02lX\n",commandData->IoctlData.Data[5]);
+		printf("EEPROM[6]=0x%02lX\n",commandData->IoctlData.Data[6]);
+		printf("EEPROM[7]=0x%02lX\n",commandData->IoctlData.Data[7]);
+	} else {
+		printf("Failed to Dump EEPROM\n");
+	}
+}
+
+void DumpTemp(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_TEMP;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		unsigned long c=0;
+		for(c=0;c<0x10;c++) {
+			printf("temp[0x%02lX]=0x%08lX, ",c,commandData->IoctlData.Data[c]);
+			printf("temp[0x%02lX]=0x%08lX, ",c+0x10,commandData->IoctlData.Data[c+0x10]);
+			printf("temp[0x%02lX]=0x%08lX, ",c+0x20,commandData->IoctlData.Data[c+0x20]);
+			printf("temp[0x%02lX]=0x%08lX\n",c+0x30,commandData->IoctlData.Data[c+0x30]);
+		}
+	} else {
+		printf("Failed to dump temp data.\n");
+	}
+}
+
+void PhyDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_PHY_REGS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("index 0, Basic Control Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_0]);
+		printf("index 1, Basic Status Reg  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_1]);
+		printf("index 2, PHY identifier 1  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_2]);
+		printf("index 3, PHY identifier 2  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_3]);
+		printf("index 4, Auto Negotiation Advertisement Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_4]);
+		printf("index 5, Auto Negotiation Link Partner Ability Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_5]);
+		printf("index 6, Auto Negotiation Expansion Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_6]);
+		printf("index 16, Silicon Revision Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_16]);
+		printf("index 17, Mode Control/Status Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_17]);
+		printf("index 18, Special Modes = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_18]);
+		printf("index 20, TSTCNTL = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_20]);
+		printf("index 21, TSTREAD1 = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_21]);
+		printf("index 22, TSTREAD2 = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_22]);
+		printf("index 23, TSTWRITE = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_23]);
+		printf("index 27, Control/Status Indication = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_27]);
+		printf("index 28, Special internal testability = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_28]);
+		printf("index 29, Interrupt Source Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_29]);
+		printf("index 30, Interrupt Mask Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_30]);
+		printf("index 31, PHY Special Control/Status Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_31]);
+	} else {
+		printf("Failed to DUMP Phy Registers\n");
+	}
+}
+
+void SetDebugMode(PCOMMAND_DATA commandData,
+				  unsigned long debug_mode)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SET_DEBUG_MODE;
+	commandData->IoctlData.Data[0]=debug_mode;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to set debug mode.\n");
+	}
+}
+
+void SetLinkMode(PCOMMAND_DATA commandData,
+				 unsigned long link_mode)
+{
+	if(link_mode<=0x7F) {
+		if(commandData==NULL) return;
+		commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+		commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_SET_LINK_MODE;
+		commandData->IoctlData.Data[0]=link_mode;
+		ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+			printf("Failed to set link mode.\n");
+		}
+	} else {
+		printf("Invalid Link Mode, %ld\n",link_mode);
+	}
+}
+
+void SetPowerMode(PCOMMAND_DATA commandData,
+				  unsigned long power_mode)
+{
+	if(power_mode<4) {
+		if(commandData==NULL) return;
+		commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+		commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_SET_POWER_MODE;
+		commandData->IoctlData.Data[0]=power_mode;
+		ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+			printf("Failed to set power mode.\n");
+		}
+	} else {
+		printf("Invalid Power Mode, %ld\n",power_mode);
+	}
+}
+
+void GetLinkMode(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_LINK_MODE;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		unsigned long link_mode=commandData->IoctlData.Data[0];
+		printf("link_mode == 0x%02lX == %s,%s,%s,%s,%s,%s,%s\n",
+			link_mode,
+			(link_mode&0x40)?"ANEG":"",
+			(link_mode&0x20)?"SYMP":"",
+			(link_mode&0x10)?"ASYMP":"",
+			(link_mode&0x08)?"100FD":"",
+			(link_mode&0x04)?"100HD":"",
+			(link_mode&0x02)?"10FD":"",
+			(link_mode&0x01)?"10HD":"");
+	} else {
+		printf("Failed to get link mode\n");
+	}
+}
+
+void CheckLink(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_CHECK_LINK;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Checked link successfully\n");
+	} else {
+		printf("Failed to check link\n");
+	}
+}
+
+void GetPowerMode(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_POWER_MODE;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("PMT_CTRL == 0x%08lX, PM_MODE == D%ld\n",
+			commandData->IoctlData.Data[0],
+			(((commandData->IoctlData.Data[0])&0x00030000UL)>>16));
+	} else {
+		printf("Failed to get power mode\n");
+	}
+}
+
+void GetFlowParams(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_FLOW_PARAMS;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		const unsigned long * data=commandData->IoctlData.Data;
+		printf("Flow Control Parameters\n");
+		printf("  RxFlowMeasuredMaxThroughput     = 0x%08lX\n",data[0]);
+		printf("  RxFlowMeasuredMaxPacketCount    = 0x%08lX\n",data[1]);
+		printf("  RxFlowParameters.MaxThroughput  = 0x%08lX\n",data[2]);
+
+		printf("  RxFlowParameters.MaxPacketCount = 0x%08lX\n",data[3]);
+		printf("  RxFlowParameters.PacketCost     = 0x%08lX\n",data[4]);
+		printf("  RxFlowParameters.BurstPeriod    = 0x%08lX\n",data[5]);
+		printf("  RxFlowMaxWorkLoad               = 0x%08lX\n",data[6]);
+		printf("  INT_CFG.INT_DEAS                = 0x%08lX\n",data[7]);
+	} else {
+		printf("Failed to get flow control parameters\n");
+	}
+}
+
+void GetConfiguration(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_CONFIGURATION;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		const unsigned long * data=commandData->IoctlData.Data;
+		printf("Compiled: %s\n",commandData->IoctlData.Strng1);
+		printf("Driver Version = %lX.%02lX\n",
+			data[0]>>8,data[0]&0xFFUL);
+		printf("Driver Parameters\n");
+		printf("  lan_base         = 0x%08lX\n",data[1]);
+		printf("  bus_width        = 0x%08lX\n",data[2]);
+		printf("  link_mode        = 0x%08lX\n",data[3]);
+		printf("  irq              = 0x%08lX\n",data[4]);
+		printf("  int_deas         = 0x%08lX\n",data[5]);
+		printf("  irq_pol          = 0x%08lX\n",data[6]);
+		printf("  irq_type         = 0x%08lX\n",data[7]);
+		printf("  rx_dma           = 0x%08lX\n",data[8]);
+		printf("  tx_dma           = 0x%08lX\n",data[9]);
+		printf("  dma_threshold    = 0x%08lX\n",data[10]);
+		printf("  mac_addr_hi16    = 0x%08lX\n",data[11]);
+		printf("  mac_addr_lo32    = 0x%08lX\n",data[12]);
+		printf("  debug_mode       = 0x%08lX\n",data[13]);
+		printf("  tx_fif_sz        = 0x%08lX\n",data[14]);
+		printf("  afc_cfg          = 0x%08lX\n",data[15]);
+		printf("  tasklets         = 0x%08lX\n",data[16]);
+		printf("  max_throughput   = 0x%08lX\n",data[17]);
+		printf("  max_packet_count = 0x%08lX\n",data[18]);
+		printf("  packet_cost      = 0x%08lX\n",data[19]);
+		printf("  burst_period     = 0x%08lX\n",data[20]);
+		printf("  max_work_load    = 0x%08lX\n",data[21]);
+		printf("privateData\n");
+		printf("  ifName                       = \"%s\"\n",
+			commandData->IoctlData.Strng2);
+		printf("  dwIdRev                      = 0x%08lX\n",data[22]);
+		printf("  dwFpgaRev                    = 0x%08lX\n",data[23]);
+		printf("  bPhyAddress                  = 0x%08lX\n",data[24]);
+		printf("  dwPhyId                      = 0x%08lX\n",data[25]);
+		printf("  bPhyModel                    = 0x%08lX\n",data[26]);
+		printf("  bPhyRev                      = 0x%08lX\n",data[27]);
+		printf("  dwLinkSpeed                  = 0x%08lX\n",data[28]);
+		printf("  RxFlowMeasuredMaxThroughput  = 0x%08lX\n",data[29]);
+		printf("  RxFlowMeasuredMaxPacketCount = 0x%08lX\n",data[30]);
+		printf("  RxFlowMaxThroughput          = 0x%08lX\n",data[31]);
+		printf("  RxFlowMaxPacketCount         = 0x%08lX\n",data[32]);
+		printf("  RxFlowPacketCost             = 0x%08lX\n",data[33]);
+		printf("  RxFlowBurstPeriod            = 0x%08lX\n",data[34]);
+		printf("  RxFlowMaxWorkLoad            = 0x%08lX\n",data[35]);
+	} else {
+		printf("Failed to get driver configuration\n");
+	}
+}
+
+void ReadByte(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_BYTE;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%02lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]&0xFFUL);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+}
+void ReadWord(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_WORD;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%04lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]&0xFFFFUL);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+
+}
+void ReadDWord(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_DWORD;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+}
+void WriteByte(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_BYTE;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data&0xFFUL;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+void WriteWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_WORD;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data&0xFFFFUL;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+void WriteDWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_DWORD;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+
+void LanGetReg(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LAN_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Mem Map Offset == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Register\n");
+	}
+}
+void LanSetReg(PCOMMAND_DATA commandData, unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LAN_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Register\n");
+	}
+}
+void MacGetReg(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_MAC_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Mac Index == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to read Mac Register\n");
+	}
+}
+void MacSetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_MAC_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Mac Register\n");
+	}
+}
+void PhyGetReg(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_PHY_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+		printf("Phy Index == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Phy Register\n");
+	}
+}
+void PhySetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_PHY_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC9118_DRIVER_SIGNATURE) {
+		printf("Failed to Write Phy Register\n");
+	}
+}
+
+bool Initialize(PCOMMAND_DATA commandData,const char *ethName) {
+
+	if(commandData==NULL) return false;
+	if(ethName==NULL) return false;
+	commandData->hSockFD=socket(AF_INET,SOCK_DGRAM,0);
+	if((commandData->hSockFD) < 0) {
+		perror("\r\nFailed to create socket !! ->");
+		return false;
+   	}
+	commandData->IfReq.ifr_data= (void *)&(commandData->IoctlData);
+	memset(&(commandData->IoctlData),0,sizeof(SMSC9118_IOCTL_DATA));
+	if(ethName[0]!=0) {
+		strncpy(commandData->IfReq.ifr_name,ethName,IFNAMSIZ);
+		commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_GET_SIGNATURE;
+		ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+			return true;
+		}
+		printf("Failed to find 9118 driver on %s\n",commandData->IfReq.ifr_name);
+	} else {
+		int ifNumber;
+		for(ifNumber=0;ifNumber<8;ifNumber++) {
+			sprintf(commandData->IfReq.ifr_name,"eth%d",ifNumber);
+			commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+			commandData->IoctlData.dwCommand=COMMAND_GET_SIGNATURE;
+			commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+			ioctl(commandData->hSockFD,SMSC9118_IOCTL,&(commandData->IfReq));
+			if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+				//printf("found 9118 on %s\n",commandData->IfReq.ifr_name);
+				return true;
+			}
+		}
+		printf("Failed to find 9118 driver on eth0 .. eth7\n");
+	}
+	printf("Either the driver has not been installed or there is\n");
+	printf("a possible version mismatch between smsc9118.o and cmd9118\n");
+	return false;
+}
+
+bool ReceiveULong(SOCKET sock,unsigned long * pDWord)
+{
+	bool result=false;
+	unsigned long data=0;
+	unsigned char ch=0;
+	if(recv(sock,&ch,1,0)>0) {
+		data=(unsigned long)ch;
+		if(recv(sock,&ch,1,0)>0) {
+			data|=(((unsigned long)ch)<<8);
+			if(recv(sock,&ch,1,0)>0) {
+				data|=(((unsigned long)ch)<<16);
+				if(recv(sock,&ch,1,0)>0) {
+					data|=(((unsigned long)ch)<<24);
+					(*pDWord)=data;
+					result=true;
+				}
+			}
+		}
+	}
+	return result;
+}
+
+bool SendULong(SOCKET sock,unsigned long data)
+{
+	bool result=false;
+	unsigned char ch=(unsigned char)(data&0x000000FFUL);
+	if(send(sock,&ch,1,0)==1) {
+		ch=(unsigned char)((data>>8)&0x000000FFUL);
+		if(send(sock,&ch,1,0)==1) {
+			ch=(unsigned char)((data>>16)&0x000000FFUL);
+			if(send(sock,&ch,1,0)==1) {
+				ch=(unsigned char)((data>>24)&0x000000FFUL);
+				if(send(sock,&ch,1,0)==1) {
+					result=true;
+				}
+			}
+		}
+	}
+	return result;
+}
+
+void process_requests(PCOMMAND_DATA commandData)
+{
+	unsigned long requestCode=0;
+	while(ReceiveULong(server_sock,&requestCode)) {
+		switch(requestCode) {
+		case COMMAND_GET_FLOW_PARAMS:
+			commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+			commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+			commandData->IoctlData.dwCommand=COMMAND_GET_FLOW_PARAMS;
+			ioctl(commandData->hSockFD,
+				SMSC9118_IOCTL,&(commandData->IfReq));
+			if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+				SendULong(server_sock,1);//1==success
+				SendULong(server_sock,commandData->IoctlData.Data[0]);//RxFlowMeasuredMaxThroughput
+				SendULong(server_sock,commandData->IoctlData.Data[1]);//RxFlowMeasuredMaxPacketCount
+				SendULong(server_sock,commandData->IoctlData.Data[2]);//RxFlowParameters.MaxThroughput
+				SendULong(server_sock,commandData->IoctlData.Data[3]);//RxFlowParameters.MaxPacketCount
+				SendULong(server_sock,commandData->IoctlData.Data[4]);//RxFlowParameters.PacketCost
+				SendULong(server_sock,commandData->IoctlData.Data[5]);//RxFlowParameters.BurstPeriod
+				SendULong(server_sock,commandData->IoctlData.Data[6]);//RxFlowMaxWorkLoad
+				SendULong(server_sock,commandData->IoctlData.Data[7]);//INT_CFG.INT_DEAS
+			} else {
+				SendULong(server_sock,0);//0==failed
+			}
+			break;
+		case COMMAND_SET_FLOW_PARAMS:
+			{
+				unsigned long data=0;
+				commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+				commandData->IoctlData.dwSignature=SMSC9118_APP_SIGNATURE;
+				commandData->IoctlData.dwCommand=COMMAND_SET_FLOW_PARAMS;
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[0]=data;//RxFlowMeasuredMaxThroughput
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[1]=data;//RxFlowMeasuredMaxPacketCount
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[2]=data;//RxFlowParameters.MaxThroughput
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[3]=data;//RxFlowParameters.MaxPacketCount
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[4]=data;//RxFlowParameters.PacketCost
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[5]=data;//RxFlowParameters.BurstPeriod
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[6]=data;//RxFlowMaxWorkLoad
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[7]=data;//INT_CFG.INT_DEAS
+				ioctl(commandData->hSockFD,
+					SMSC9118_IOCTL,&(commandData->IfReq));
+				if(commandData->IoctlData.dwSignature==SMSC9118_DRIVER_SIGNATURE) {
+					SendULong(server_sock,1);//1==success
+				} else {
+					SendULong(server_sock,0);//0==failed
+				}
+			}
+			break;
+		default:
+			printf("WARNING, unknown requestCode=0x%08lX\n",requestCode);
+			break;
+		}
+	}
+}
+
+void RunServer(PCOMMAND_DATA commandData,unsigned short portNumber)
+{
+    struct sockaddr *server;
+	struct sockaddr_in server4;
+	int sockaddr_len;
+	struct sockaddr peeraddr;
+	SOCKET server_control;
+	int on=1;
+
+	if(portNumber==0) {
+		portNumber=DEFAULT_PORT_NUMBER;
+	}
+
+	server4.sin_port=htons(portNumber);
+	server4.sin_addr.s_addr=INADDR_ANY;
+	server4.sin_family=AF_INET;
+	sockaddr_len=sizeof(struct sockaddr_in);
+	server=(struct sockaddr *)&server4;
+
+	printf("Starting server at port %d\n",portNumber);
+	server_control = socket(server->sa_family,SOCK_STREAM,0);
+	if(server_control==INVALID_SOCKET)
+	{
+		printf("Error creating the socket\n");
+		exit(1);
+	}
+	if(setsockopt(server_control,
+		SOL_SOCKET,
+		SO_REUSEADDR,
+		(char *)&on,
+		sizeof(on))==SOCKET_ERROR)
+	{
+		printf("Error: SO_REUSEADDR\n");
+		exit(1);
+	}
+	if(bind(server_control,server,sockaddr_len)==SOCKET_ERROR)
+	{
+		printf("Error binding the socket\n");
+		exit(1);
+	}
+	if(listen(server_control,5)==SOCKET_ERROR)
+	{
+		printf("Error listening\n");
+		exit(1);
+	}
+	switch(fork()) {
+	case -1:
+		printf("Error on fork\n");
+		exit(1);
+	case 0:
+		fclose(stdin);
+		fclose(stderr);
+		setsid();
+		for(;;)
+		{
+			if((server_sock=accept(server_control,
+					&peeraddr,
+					&sockaddr_len)) == INVALID_SOCKET)
+			{
+				printf("Error accept failed\n");
+				exit(1);
+			}
+			switch(fork()) {
+			case -1:
+				//something went wrong
+				exit(1);
+			case 0:
+				//we are the child process
+				close(server_control);
+				process_requests(commandData);
+				close(server_sock);
+				exit(0);
+				break;
+			default:
+				//we are the parent process
+				close(server_sock);
+				break;
+			}
+		}
+
+		break;
+	default:
+		exit(0);
+	}
+}
+
+bool ReceiveFlowParams(SOCKET sock,PFLOW_PARAMS flowParams)
+{
+	bool result=false;
+	if(SendULong(sock,COMMAND_GET_FLOW_PARAMS)) {
+		unsigned long data=0;
+		if(!ReceiveULong(sock,&data)) goto DONE;
+		if(data) {
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MeasuredMaxThroughput=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MeasuredMaxPacketCount=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxThroughput=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxPacketCount=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->PacketCost=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->BurstPeriod=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxWorkLoad=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->IntDeas=data;
+			result=true;
+		}
+	}
+DONE:
+	return result;
+}
+
+bool SendFlowParams(SOCKET sock,PFLOW_PARAMS flowParams)
+{
+	bool result=false;
+	unsigned long timeout=100;
+	unsigned long data=0;
+AGAIN:
+	SendULong(sock,COMMAND_SET_FLOW_PARAMS);
+	SendULong(sock,flowParams->MeasuredMaxThroughput);
+	SendULong(sock,flowParams->MeasuredMaxPacketCount);
+	SendULong(sock,flowParams->MaxThroughput);
+	SendULong(sock,flowParams->MaxPacketCount);
+	SendULong(sock,flowParams->PacketCost);
+	SendULong(sock,flowParams->BurstPeriod);
+	SendULong(sock,flowParams->MaxWorkLoad);
+	SendULong(sock,flowParams->IntDeas);
+	if(ReceiveULong(sock,&data)) {
+		if(data) {
+			result=true;
+		} else {
+			//If flow control was active this command will fail
+			//  therefore wait and try again later.
+			if(timeout>0) {
+				timeout--;
+				sleep(5);
+				goto AGAIN;
+			}
+		}
+	}
+	return result;
+}
+
+void DisplayFlowParams(PFLOW_PARAMS flowParams)
+{
+	printf("Flow Control Parameters\n");
+	printf("  MaxThroughput          = 0x%08lX\n",flowParams->MaxThroughput);
+	printf("  MaxPacketCount         = 0x%08lX\n",flowParams->MaxPacketCount);
+	printf("  PacketCost             = 0x%08lX\n",flowParams->PacketCost);
+	printf("  BurstPeriod            = 0x%08lX\n",flowParams->BurstPeriod);
+	printf("  IntDeas                = 0x%08lX\n",flowParams->IntDeas);
+}
+
+unsigned long ReadThroughput(char * fileName)
+{
+	unsigned long result=0;
+	bool clearFlag=true;
+	FILE * filePtr=NULL;
+	filePtr=fopen(fileName,"r");
+	if(filePtr!=NULL) {
+		char ch=0;
+		while(fread(&ch,1,1,filePtr)!=0) {
+			switch(ch) {
+			case '0':case '1':case '2':case '3':case '4':
+
+			case '5':case '6':case '7':case '8':case '9':
+				if(clearFlag) {
+					result=0;
+					clearFlag=false;
+				}
+				result*=10;
+				result+=(unsigned long)(ch-'0');
+				break;
+			case '.':
+				break;
+			default:
+				clearFlag=true;
+				break;
+			}
+		}
+		fclose(filePtr);
+	} else {
+		printf("ReadThroughput: unable to open file\n");
+	}
+	return result;
+}
+
+void RunTuner(const char *hostName,unsigned short portNum)
+{
+	SOCKET controlSocket=INVALID_SOCKET;
+	struct sockaddr_in server;
+    unsigned int addr;
+	char command[128];
+	char outputFile[]="npout.txt";
+	FLOW_PARAMS flowParams;
+	FLOW_PARAMS origParams;
+	FLOW_PARAMS bestParams;
+	unsigned long bestMeasurement=0;
+	unsigned long currentSetting=0;
+	unsigned long currentMeasurement=0;
+	unsigned long tempLow=0;
+	unsigned long tempHigh=0;
+	int salen;
+	memset((char *)&server,0,sizeof(server));
+
+	if(portNum==0) {
+		portNum=DEFAULT_PORT_NUMBER;
+	}
+	server.sin_port=htons(portNum);
+	if((addr=inet_addr(hostName))==0xFFFFFFFFUL) {
+		printf("Invalid: hostName==\"%s\"",hostName);
+		printf("   must be in IP form\n");
+		return;
+	} else {
+		server.sin_addr.s_addr=addr;
+		server.sin_family=AF_INET;
+	}
+	salen=sizeof(server);
+
+	controlSocket=socket(AF_INET,SOCK_STREAM,0);
+	if(controlSocket==INVALID_SOCKET) {
+		printf("error creating control socket\n");
+		return;
+	}
+	if(connect(controlSocket,
+		(struct sockaddr *)&server,
+		salen) == INVALID_SOCKET)
+	{
+		printf("failed to connect to %s:%d\n",hostName,portNum);
+		goto DONE;
+	}
+
+	if(!ReceiveFlowParams(controlSocket,&origParams)) goto FAILED;
+	memcpy(&bestParams,&origParams,sizeof(FLOW_PARAMS));
+	bestParams.MeasuredMaxThroughput=0;
+	bestParams.MeasuredMaxPacketCount=0;
+	bestParams.MaxThroughput=0;
+	bestParams.MaxPacketCount=0;
+	bestParams.BurstPeriod=100;
+	bestParams.MaxWorkLoad=0;
+	bestParams.IntDeas=0;
+	memcpy(&flowParams,&bestParams,sizeof(FLOW_PARAMS));
+
+	printf("Entire tuning process will take about one hour.\n");
+	printf("TUNING IntDeas\n");
+	sprintf(command,"./netperf -H%s > %s",hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=0;currentSetting<80;currentSetting++) {
+		flowParams.IntDeas=currentSetting;
+		if(!SendFlowParams(controlSocket,&flowParams)) {
+			printf("Failed to send new setting: IntDeas=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.IntDeas=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("IntDeas = %ld, Throughput = %ld\n",currentSetting,currentMeasurement);
+	}
+	printf("Best: IntDeas = %ld, Throughput = %ld\n",bestParams.IntDeas,bestMeasurement);
+	flowParams.IntDeas=bestParams.IntDeas;
+	if(!SendFlowParams(controlSocket,&flowParams)) {
+		goto FAILED;
+	}
+	//getting the FlowParams back will make sure the measurements are clear.
+	if(!ReceiveFlowParams(controlSocket,&flowParams)) goto FAILED;
+	if(flowParams.IntDeas!=bestParams.IntDeas) {
+		printf("new setting did not stick\n");
+		goto FAILED;
+	}
+	printf("Measuring Max Throughput, and Max Packet Count\n");
+	if(system(command)!=0) goto FAILED;
+	if(system(command)!=0) goto FAILED;
+	if(system(command)!=0) goto FAILED;
+	if(!ReceiveFlowParams(controlSocket,&flowParams)) goto FAILED;
+	bestParams.MeasuredMaxThroughput=flowParams.MeasuredMaxThroughput;
+	bestParams.MeasuredMaxPacketCount=flowParams.MeasuredMaxPacketCount;
+	bestParams.MaxThroughput=bestParams.MeasuredMaxThroughput;
+	bestParams.MaxPacketCount=bestParams.MeasuredMaxPacketCount;
+	bestParams.PacketCost=0;
+	bestParams.MaxWorkLoad=0xFFFFFFFFUL;
+	bestParams.BurstPeriod=100;
+	memcpy(&flowParams,&bestParams,sizeof(FLOW_PARAMS));
+
+	printf("TUNING Burst Period\n");
+	sprintf(command,"./netperf -H%s -tUDP_STREAM -l10 -- -m1472 > %s",
+		hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=10;currentSetting<120;currentSetting++) {
+		flowParams.BurstPeriod=currentSetting;
+		if(!SendFlowParams(controlSocket,&flowParams)) {
+			printf("Failed to send new setting: BurstPeriod=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.BurstPeriod=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("BurstPeriod = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	printf("Best: BurstPeriod = %ld, Throughput = %ld\n",
+		bestParams.BurstPeriod,bestMeasurement);
+	flowParams.BurstPeriod=bestParams.BurstPeriod;
+
+	printf("TUNING PacketCost\n");
+	sprintf(command,"./netperf -H%s -tUDP_STREAM -l10 -- -m16 > %s",
+		hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=0;currentSetting<500;currentSetting+=10) {
+		flowParams.PacketCost=currentSetting;
+		if(!SendFlowParams(controlSocket, &flowParams)) {
+			printf("Failed to send new setting: PacketCost=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.PacketCost=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("PacketCost = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	bestMeasurement=0;
+	if(bestParams.PacketCost>20) {
+		tempLow=bestParams.PacketCost-20;
+	} else {
+		tempLow=0;
+	}
+	tempHigh=bestParams.PacketCost+20;
+	for(currentSetting=tempLow;currentSetting<tempHigh;currentSetting++) {
+		flowParams.PacketCost=currentSetting;
+		if(!SendFlowParams(controlSocket, &flowParams)) {
+			printf("Failed to send new setting: PacketCost=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.PacketCost=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("PacketCost = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	printf("Best: PacketCost = %ld, Throughput = %ld\n",
+		bestParams.PacketCost,bestMeasurement);
+	printf("Best ");DisplayFlowParams(&bestParams);
+	if(!SendFlowParams(controlSocket, &origParams)) {
+		printf("Failed to restore original setting\n");
+		goto FAILED;
+	}
+
+DONE:
+	close(controlSocket);
+	return;
+FAILED:
+	close(controlSocket);
+	printf("Something went wrong\n");
+}
+
+int main(ac,av)
+int ac;
+char * av[];
+{
+	int oc=0;
+	bool eSet=false;
+	char ethName[IFNAMSIZ];
+	COMMAND_DATA commandData;
+	bool cSet=false;
+	bool aSet=false;
+	unsigned long address=0;
+	bool dSet=false;
+	unsigned long data=0;
+	unsigned long commandCode=0;
+	char hostName[128];
+	bool hSet=false;
+	unsigned long portNum=0;
+	bool pSet=false;
+
+
+	iam=av[0];
+	ethName[0]=0;
+	hostName[0]=0;
+
+	while((oc=getopt(ac,av,"hH:p:e:c:a:d:"))!=-1) {
+		switch(oc) {
+		case 'h'://help
+			goto BAD_USAGE;
+		case 'H'://Host address
+			if(hSet) goto BAD_USAGE;
+			strcpy(hostName,optarg);
+			hSet=true;
+			break;
+		case 'p':
+			if(pSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&portNum)) {
+				goto BAD_USAGE;
+			}
+			if(portNum>0xFFFFUL) goto BAD_USAGE;
+			pSet=true;
+			break;
+		case 'e':
+			if(eSet) goto BAD_USAGE;
+			eSet=true;
+			strncpy(ethName,optarg,IFNAMSIZ);
+			ethName[IFNAMSIZ-1]=0;
+			break;
+		case 'c':
+			if(cSet) goto BAD_USAGE;
+			if(strcmp(optarg,"GET_CONFIG")==0) {
+				commandCode=COMMAND_GET_CONFIGURATION;
+			} else if(strcmp(optarg,"DUMP_REGS")==0) {
+				commandCode=COMMAND_DUMP_LAN_REGS;
+			} else if(strcmp(optarg,"DUMP_MAC")==0) {
+				commandCode=COMMAND_DUMP_MAC_REGS;
+			} else if(strcmp(optarg,"DUMP_PHY")==0) {
+				commandCode=COMMAND_DUMP_PHY_REGS;
+			} else if(strcmp(optarg,"DUMP_EEPROM")==0) {
+				commandCode=COMMAND_DUMP_EEPROM;
+			} else if(strcmp(optarg,"DUMP_TEMP")==0) {
+				commandCode=COMMAND_DUMP_TEMP;
+			} else if(strcmp(optarg,"GET_MAC")==0) {
+				commandCode=COMMAND_GET_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SET_MAC")==0) {
+				commandCode=COMMAND_SET_MAC_ADDRESS;
+			} else if(strcmp(optarg,"LOAD_MAC")==0) {
+				commandCode=COMMAND_LOAD_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SAVE_MAC")==0) {
+				commandCode=COMMAND_SAVE_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SET_DEBUG")==0) {
+				commandCode=COMMAND_SET_DEBUG_MODE;
+			} else if(strcmp(optarg,"SET_POWER")==0) {
+				commandCode=COMMAND_SET_POWER_MODE;
+			} else if(strcmp(optarg,"GET_POWER")==0) {
+				commandCode=COMMAND_GET_POWER_MODE;
+			} else if(strcmp(optarg,"SET_LINK")==0) {
+				commandCode=COMMAND_SET_LINK_MODE;
+			} else if(strcmp(optarg,"GET_LINK")==0) {
+				commandCode=COMMAND_GET_LINK_MODE;
+			} else if(strcmp(optarg,"CHECK_LINK")==0) {
+				commandCode=COMMAND_CHECK_LINK;
+			} else if(strcmp(optarg,"READ_REG")==0) {
+				commandCode=COMMAND_LAN_GET_REG;
+			} else if(strcmp(optarg,"WRITE_REG")==0) {
+				commandCode=COMMAND_LAN_SET_REG;
+			} else if(strcmp(optarg,"READ_MAC")==0) {
+				commandCode=COMMAND_MAC_GET_REG;
+			} else if(strcmp(optarg,"WRITE_MAC")==0) {
+				commandCode=COMMAND_MAC_SET_REG;
+			} else if(strcmp(optarg,"READ_PHY")==0) {
+				commandCode=COMMAND_PHY_GET_REG;
+			} else if(strcmp(optarg,"WRITE_PHY")==0) {
+				commandCode=COMMAND_PHY_SET_REG;
+			} else if(strcmp(optarg,"READ_BYTE")==0) {
+				commandCode=COMMAND_READ_BYTE;
+			} else if(strcmp(optarg,"READ_WORD")==0) {
+				commandCode=COMMAND_READ_WORD;
+			} else if(strcmp(optarg,"READ_DWORD")==0) {
+				commandCode=COMMAND_READ_DWORD;
+			} else if(strcmp(optarg,"WRITE_BYTE")==0) {
+				commandCode=COMMAND_WRITE_BYTE;
+			} else if(strcmp(optarg,"WRITE_WORD")==0) {
+				commandCode=COMMAND_WRITE_WORD;
+			} else if(strcmp(optarg,"WRITE_DWORD")==0) {
+				commandCode=COMMAND_WRITE_DWORD;
+			} else if(strcmp(optarg,"SERVER")==0) {
+				commandCode=COMMAND_RUN_SERVER;
+			} else if(strcmp(optarg,"TUNER")==0) {
+				commandCode=COMMAND_RUN_TUNER;
+			} else if(strcmp(optarg,"GET_FLOW")==0) {
+				commandCode=COMMAND_GET_FLOW_PARAMS;
+			} else {
+				goto BAD_USAGE;
+			}
+			cSet=true;
+			break;
+		case 'a':
+			if(aSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&address)) {
+				goto BAD_USAGE;
+			}
+			aSet=true;
+			break;
+		case 'd':
+			if(dSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&data)) {
+				goto BAD_USAGE;
+			}
+
+			dSet=true;
+			break;
+		default:
+			goto BAD_USAGE;
+		}
+	}
+
+	if(commandCode==COMMAND_RUN_TUNER) {
+		//This command must be run before initialize because
+		//  it will typically be run on machines that do not
+		//  have the smsc9118 driver installed.
+		RunTuner(hostName,(unsigned short)portNum);
+		return 1;
+	}
+
+	if(!Initialize(&commandData,ethName)) {
+		return 1;
+	}
+
+	switch(commandCode) {
+	case COMMAND_RUN_SERVER:
+		RunServer(&commandData,(unsigned short)portNum);
+		break;
+	case COMMAND_GET_FLOW_PARAMS:
+		GetFlowParams(&commandData);
+		break;
+	case COMMAND_GET_CONFIGURATION:
+		GetConfiguration(&commandData);
+		break;
+	case COMMAND_DUMP_LAN_REGS:
+		LanDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_MAC_REGS:
+		MacDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_PHY_REGS:
+		PhyDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_EEPROM:
+		DumpEEPROM(&commandData);
+		break;
+	case COMMAND_DUMP_TEMP:
+		DumpTemp(&commandData);
+		break;
+	case COMMAND_GET_MAC_ADDRESS:
+		GetMacAddress(&commandData);
+		break;
+	case COMMAND_SET_MAC_ADDRESS:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		SetMacAddress(&commandData,address,data);
+		break;
+	case COMMAND_LOAD_MAC_ADDRESS:
+		LoadMacAddress(&commandData);
+		break;
+	case COMMAND_SAVE_MAC_ADDRESS:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		SaveMacAddress(&commandData,address,data);
+		break;
+	case COMMAND_SET_DEBUG_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetDebugMode(&commandData,data);
+		break;
+	case COMMAND_SET_LINK_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetLinkMode(&commandData,data);
+		break;
+	case COMMAND_GET_LINK_MODE:
+		GetLinkMode(&commandData);
+		break;
+	case COMMAND_CHECK_LINK:
+		CheckLink(&commandData);
+		break;
+	case COMMAND_SET_POWER_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetPowerMode(&commandData,data);
+		break;
+	case COMMAND_GET_POWER_MODE:
+		GetPowerMode(&commandData);
+		break;
+	case COMMAND_LAN_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		LanGetReg(&commandData,address);
+		break;
+	case COMMAND_LAN_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		LanSetReg(&commandData,address,data);
+		break;
+	case COMMAND_MAC_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		MacGetReg(&commandData,address);
+		break;
+	case COMMAND_MAC_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		MacSetReg(&commandData,address,data);
+		break;
+	case COMMAND_PHY_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		PhyGetReg(&commandData,address);
+		break;
+	case COMMAND_PHY_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		PhySetReg(&commandData,address,data);
+		break;
+	case COMMAND_READ_BYTE:
+		if(!aSet) goto BAD_USAGE;
+		ReadByte(&commandData,address);
+		break;
+	case COMMAND_READ_WORD:
+		if(!aSet) goto BAD_USAGE;
+		ReadWord(&commandData,address);
+		break;
+	case COMMAND_READ_DWORD:
+		if(!aSet) goto BAD_USAGE;
+		ReadDWord(&commandData,address);
+		break;
+	case COMMAND_WRITE_BYTE:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteByte(&commandData,address,data);
+		break;
+	case COMMAND_WRITE_WORD:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteWord(&commandData,address,data);
+		break;
+	case COMMAND_WRITE_DWORD:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteDWord(&commandData,address,data);
+		break;
+	default:
+		goto BAD_USAGE;
+	}
+
+	return 1;
+BAD_USAGE:
+	DisplayUsage();
+	return 1;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/ioctl_118.h linux-2.6.23.1-stm/drivers/net/smsc_911x/ioctl_118.h
--- linux-2.6.23.1/drivers/net/smsc_911x/ioctl_118.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/ioctl_118.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,148 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: ioctl_118.h
+ */
+
+#ifndef IOCTL_118_H
+#define IOCTL_118_H
+
+#define DRIVER_VERSION	(0x00000125UL)
+
+#define SMSC9118_DRIVER_SIGNATURE	(0x82745BACUL+DRIVER_VERSION)
+#define SMSC9118_APP_SIGNATURE		(0x987BEF28UL+DRIVER_VERSION)
+
+#define SMSC9118_IOCTL				(SIOCDEVPRIVATE + 0xB)
+
+#define COMMAND_BASE				(0x974FB832UL)
+
+#define COMMAND_GET_SIGNATURE		(COMMAND_BASE+0)
+
+#define COMMAND_LAN_GET_REG			(COMMAND_BASE+1)
+#define COMMAND_LAN_SET_REG			(COMMAND_BASE+2)
+
+#define COMMAND_MAC_GET_REG			(COMMAND_BASE+3)
+#define COMMAND_MAC_SET_REG			(COMMAND_BASE+4)
+
+#define COMMAND_PHY_GET_REG			(COMMAND_BASE+5)
+#define COMMAND_PHY_SET_REG			(COMMAND_BASE+6)
+
+#define COMMAND_DUMP_LAN_REGS		(COMMAND_BASE+7)
+#define LAN_REG_ID_REV			(0)
+#define LAN_REG_INT_CFG			(1)
+#define LAN_REG_INT_STS			(2)
+#define LAN_REG_INT_EN			(3)
+#define LAN_REG_BYTE_TEST		(4)
+#define LAN_REG_FIFO_INT		(5)
+#define LAN_REG_RX_CFG			(6)
+#define LAN_REG_TX_CFG			(7)
+#define LAN_REG_HW_CFG			(8)
+#define LAN_REG_RX_DP_CTRL		(9)
+#define LAN_REG_RX_FIFO_INF		(10)
+#define LAN_REG_TX_FIFO_INF		(11)
+#define LAN_REG_PMT_CTRL		(12)
+#define LAN_REG_GPIO_CFG		(13)
+#define LAN_REG_GPT_CFG			(14)
+#define LAN_REG_GPT_CNT			(15)
+#define LAN_REG_FPGA_REV		(16)
+#define LAN_REG_ENDIAN			(17)
+#define LAN_REG_FREE_RUN		(18)
+#define LAN_REG_RX_DROP			(19)
+#define LAN_REG_MAC_CSR_CMD		(21)
+#define LAN_REG_MAC_CSR_DATA	(22)
+#define LAN_REG_AFC_CFG			(23)
+#define LAN_REG_E2P_CMD			(24)
+#define LAN_REG_E2P_DATA		(25)
+
+#define COMMAND_DUMP_MAC_REGS		(COMMAND_BASE+8)
+#define MAC_REG_MAC_CR			(0)
+#define MAC_REG_ADDRH			(1)
+#define MAC_REG_ADDRL			(2)
+#define MAC_REG_HASHH			(3)
+#define MAC_REG_HASHL			(4)
+#define MAC_REG_MII_ACC			(5)
+#define MAC_REG_MII_DATA		(6)
+#define MAC_REG_FLOW			(7)
+#define MAC_REG_VLAN1			(8)
+#define MAC_REG_VLAN2			(9)
+#define MAC_REG_WUFF			(10)
+#define MAC_REG_WUCSR			(11)
+
+#define COMMAND_DUMP_PHY_REGS		(COMMAND_BASE+9)
+#define PHY_REG_0				(0)
+#define PHY_REG_1				(1)
+#define PHY_REG_2				(2)
+#define PHY_REG_3				(3)
+#define PHY_REG_4				(4)
+#define PHY_REG_5				(5)
+#define PHY_REG_6				(6)
+#define PHY_REG_16				(7)
+#define PHY_REG_17				(8)
+#define PHY_REG_18				(9)
+#define PHY_REG_20				(10)
+#define PHY_REG_21				(11)
+#define PHY_REG_22				(12)
+#define PHY_REG_23				(13)
+#define PHY_REG_27				(14)
+#define PHY_REG_28				(15)
+#define PHY_REG_29				(16)
+#define PHY_REG_30				(17)
+#define PHY_REG_31				(18)
+
+#define COMMAND_DUMP_EEPROM			(COMMAND_BASE+10)
+
+#define COMMAND_GET_MAC_ADDRESS		(COMMAND_BASE+11)
+#define COMMAND_SET_MAC_ADDRESS		(COMMAND_BASE+12)
+#define COMMAND_LOAD_MAC_ADDRESS	(COMMAND_BASE+13)
+#define COMMAND_SAVE_MAC_ADDRESS	(COMMAND_BASE+14)
+#define COMMAND_SET_DEBUG_MODE		(COMMAND_BASE+15)
+
+#define COMMAND_SET_POWER_MODE		(COMMAND_BASE+16)
+#define COMMAND_GET_POWER_MODE		(COMMAND_BASE+17)
+
+#define COMMAND_SET_LINK_MODE		(COMMAND_BASE+18)
+#define COMMAND_GET_LINK_MODE		(COMMAND_BASE+19)
+#define COMMAND_GET_CONFIGURATION	(COMMAND_BASE+20)
+#define COMMAND_DUMP_TEMP			(COMMAND_BASE+21)
+#define COMMAND_READ_BYTE			(COMMAND_BASE+22)
+#define COMMAND_READ_WORD			(COMMAND_BASE+23)
+#define COMMAND_READ_DWORD			(COMMAND_BASE+24)
+#define COMMAND_WRITE_BYTE			(COMMAND_BASE+25)
+#define COMMAND_WRITE_WORD			(COMMAND_BASE+26)
+#define COMMAND_WRITE_DWORD			(COMMAND_BASE+27)
+#define COMMAND_CHECK_LINK			(COMMAND_BASE+28)
+
+//the following codes are intended for cmd9118 only
+//  they are not intended to have any use in the driver
+#define COMMAND_RUN_SERVER			(COMMAND_BASE+29)
+#define COMMAND_RUN_TUNER			(COMMAND_BASE+30)
+
+#define COMMAND_GET_FLOW_PARAMS		(COMMAND_BASE+31)
+#define COMMAND_SET_FLOW_PARAMS		(COMMAND_BASE+32)
+
+typedef struct _SMSC9118_IOCTL_DATA {
+	unsigned long dwSignature;
+	unsigned long dwCommand;
+	unsigned long Data[0x60];
+	char Strng1[30];
+	char Strng2[10];
+} SMSC9118_IOCTL_DATA, *PSMSC9118_IOCTL_DATA;
+
+#endif
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/lint.h linux-2.6.23.1-stm/drivers/net/smsc_911x/lint.h
--- linux-2.6.23.1/drivers/net/smsc_911x/lint.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/lint.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,406 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ ***************************************************************************
+ * Additionally it deserves noting that the everything in this file is
+ *   for the purpose of making the lint tool happy. Therefore everything
+ *   declared or defined in this file has been thoroughly customized. It
+ *   is not suitable to be use as a reference nor compatible for any
+ *   other purpose.
+ *   For proper declarations and definitions see the linux source code.
+ ***************************************************************************
+ * File: lint.h
+ */
+
+#ifndef LINT_H
+#define LINT_H
+
+/********************************************************
+******************SHARED*********************************
+********************************************************/
+#define IFNAMSIZ	(10)
+#define SIOCDEVPRIVATE (10000UL)
+struct ifreq
+{
+//#define IFHWADDRLEN	6
+//#define	IFNAMSIZ	16
+#ifdef CMD9118
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	} ifr_ifrn;
+#endif
+
+	union {
+//		struct	sockaddr ifru_addr;
+//		struct	sockaddr ifru_dstaddr;
+//		struct	sockaddr ifru_broadaddr;
+//		struct	sockaddr ifru_netmask;
+//		struct  sockaddr ifru_hwaddr;
+//		short	ifru_flags;
+//		int	ifru_ivalue;
+//		int	ifru_mtu;
+//		struct  ifmap ifru_map;
+//		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
+//		char	ifru_newname[IFNAMSIZ];
+		char *	ifru_data;
+//		struct	if_settings ifru_settings;
+	} ifr_ifru;
+};
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+
+#define NULL ((void *)(0))
+extern void memset(void *__s, int __c, unsigned int __count);
+extern void memcpy(void *a,const void * b,unsigned int c);
+extern void sprintf(char * a,const char * b,...);
+extern void strcpy(signed char * s,const signed char * s);
+
+/***********************************************************
+************DRIVER ONLY*************************************
+************************************************************/
+#ifndef CMD9118
+
+#define LINUX_VERSION_CODE 132113
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+
+//typedef void irqreturn_t;
+//#define IRQ_NONE
+//#define IRQ_HANDLED
+//#define IRQ_RETVAL(x)
+
+
+//typedef long TIME_SPAN;
+//#define MAX_TIME_SPAN	((TIME_SPAN)(0x7FFFFFFFUL))
+//typedef unsigned long DWORD;
+//typedef unsigned short WORD;
+//typedef unsigned char BYTE;
+//typedef unsigned char BOOLEAN;
+//#define TRUE	((BOOLEAN)1)
+//#define FALSE	((BOOLEAN)0)
+//
+//#define HIBYTE(word)  ((BYTE)(((WORD)(word))>>8))
+//#define LOBYTE(word)  ((BYTE)(((WORD)(word))&0x00FFU))
+//#define HIWORD(dWord) ((WORD)(((DWORD)(dWord))>>16))
+//#define LOWORD(dWord) ((WORD)(((DWORD)(dWord))&0x0000FFFFUL))
+typedef unsigned long spinlock_t;
+
+typedef unsigned long ULONG;
+typedef unsigned char UCHAR;
+
+//extern void SMSC_TRACE(const char * a,...);
+//extern void SMSC_WARNING(const char * a,...);
+//extern void SMSC_ASSERT(BOOLEAN condition);
+
+//#define TRANSFER_PIO			((DWORD)256)
+//#define TRANSFER_REQUEST_DMA	((DWORD)255)
+
+//DMA Transfer structure
+//typedef struct _DMA_XFER
+//{
+//	DWORD dwLanReg;
+//	DWORD *pdwBuf;
+//	DWORD dwDmaCh;
+//	DWORD dwDwCnt;
+//	BOOLEAN fMemWr;
+//} DMA_XFER, *PDMA_XFER;
+//
+//typedef struct _FLOW_CONTROL_PARAMETERS
+//{
+//	DWORD MaxThroughput;
+//	DWORD MaxPacketCount;
+//	DWORD PacketCost;
+//	DWORD BurstPeriod;
+//	DWORD IntDeas;
+//} FLOW_CONTROL_PARAMETERS, *PFLOW_CONTROL_PARAMETERS;
+
+struct net_device_stats
+{
+	ULONG	rx_packets;
+	ULONG	tx_packets;
+	ULONG	rx_bytes;
+	ULONG	tx_bytes;
+	ULONG	rx_errors;
+	ULONG	tx_errors;
+	ULONG	rx_dropped;
+	ULONG	multicast;
+	ULONG	collisions;
+	ULONG	rx_length_errors;
+	ULONG	rx_crc_errors;
+	ULONG	tx_aborted_errors;
+	ULONG	tx_carrier_errors;
+};
+
+struct timer_list {
+	ULONG expires;
+	ULONG data;
+	void (*function)(ULONG param);
+};
+
+#define MODULE_PARM(var,type)		 	\
+const char __module_parm_##var[] = type
+
+#define MODULE_PARM_DESC(var,desc)		\
+const char __module_parm_desc_##var[] = desc
+
+#define MODULE_LICENSE(license) 	\
+static const char __module_license[] =license
+
+#define MOD_INC_USE_COUNT	do { } while (0)
+#define MOD_DEC_USE_COUNT	do { } while (0)
+
+#define MAX_ADDR_LEN (6)
+
+struct dev_mc_list
+{
+	struct dev_mc_list	*next;
+	UCHAR dmi_addr[MAX_ADDR_LEN];
+	UCHAR dmi_addrlen;
+};
+
+struct net_device
+{
+	char name[IFNAMSIZ];
+	struct net_device_stats* (*get_stats)(struct net_device *dev);
+	unsigned short flags;
+//	spinlock_t xmit_lock;
+	void * priv;
+	UCHAR dev_addr[MAX_ADDR_LEN];
+	struct dev_mc_list * mc_list;
+	int mc_count;
+//	int (*init)(struct net_device *dev);
+	int	(*open)(struct net_device *dev);
+	int	(*stop)(struct net_device *dev);
+	int	(*hard_start_xmit) (struct sk_buff *skb,struct net_device *dev);
+	void (*set_multicast_list)(struct net_device *dev);
+	int (*do_ioctl)(struct net_device *dev, struct ifreq *ifr,int cmd);
+};
+
+struct mii_ioctl_data {
+	ULONG	phy_id;
+	ULONG	reg_num;
+	ULONG	val_in;
+	ULONG	val_out;
+};
+
+#define SIOCGMIIPHY	(1000UL)
+#define SIOCGMIIREG	(1001UL)
+#define SIOCSMIIREG	(1002UL)
+
+
+struct sk_buff {
+	struct net_device	*dev;
+	unsigned int 	len;
+	unsigned char	ip_summed;
+	unsigned short	protocol;
+	unsigned char	*head;
+	unsigned char	*data;
+	unsigned char	*tail;
+};
+
+struct tasklet_struct
+{
+	struct tasklet_struct *next;
+	unsigned long state;
+	unsigned long count;
+	void (*func)(unsigned long param);
+	unsigned long data;
+};
+
+#define DECLARE_TASKLET(name, func, data) \
+struct tasklet_struct name = { NULL, 0, 0, func, data }
+
+extern struct sk_buff *dev_alloc_skb(unsigned int length);
+extern unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev);
+extern void netif_carrier_on(struct net_device *dev);
+extern void netif_carrier_off(struct net_device *dev);
+extern int netif_rx(struct sk_buff *skb);
+extern void netif_start_queue(struct net_device *dev);
+extern void netif_wake_queue(struct net_device *dev);
+extern void netif_stop_queue(struct net_device *dev);
+extern void free_irq(unsigned int Irq, void *isr);
+extern int check_mem_region(unsigned long a, unsigned long b);
+extern void release_mem_region(unsigned long a, unsigned long b);
+extern void tasklet_schedule(struct tasklet_struct *t);
+extern void del_timer_sync(struct timer_list * timer);
+extern void init_timer(struct timer_list * timer);
+extern void ether_setup(struct net_device *dev);
+extern int register_netdev(struct net_device *dev);
+extern void add_timer(struct timer_list * timer);
+extern void spin_lock(spinlock_t *s);
+extern void spin_unlock(spinlock_t *s);
+extern void spin_lock_init(spinlock_t *s);
+extern void spin_lock_irqsave(spinlock_t *s,unsigned long f);
+extern void spin_unlock_irqrestore(spinlock_t *s,unsigned long f);
+extern void unregister_netdev(struct net_device *dev);
+extern void udelay(unsigned long usecs);
+#define SET_MODULE_OWNER(some_struct) do { } while (0)
+extern void request_mem_region(unsigned long start, unsigned long n, const signed char *name);
+extern int request_irq(unsigned int a,
+		       void (*handler)(int a, void * b, struct pt_regs * c),
+		       unsigned long c, const signed char * d, void * e);
+extern void dev_kfree_skb(struct sk_buff *skb);
+extern void skb_reserve(struct sk_buff *skb, unsigned int len);
+extern void skb_put(struct sk_buff *skb, unsigned int len);
+
+
+#define NET_RX_SUCCESS		0
+#define NET_RX_DROP			1
+#define NET_RX_CN_LOW		2
+#define NET_RX_CN_MOD		3
+#define NET_RX_CN_HIGH		4
+
+#define CHECKSUM_NONE 0
+
+#define	ENOMEM		12
+#define	EFAULT		14
+#define	ENODEV		19
+
+#define GFP_KERNEL	(1)
+
+#define IFF_MULTICAST   (1U)
+#define IFF_PROMISC		(2U)
+#define IFF_ALLMULTI	(4U)
+
+#define SA_INTERRUPT	0x20000000
+
+extern void *kmalloc(unsigned int a, int b);
+extern void kfree(const void *a);
+
+extern unsigned long volatile jiffies;
+#define HZ 100
+
+#endif //not CMD9118
+
+
+/*******************************************************
+*************XSCALE DRIVER******************************
+*******************************************************/
+#ifdef USE_XSCALE
+#define MST_EXP_BASE (0x80000000UL)
+#define MST_EXP_PHYS (0x00000005UL)
+#define MSC2 (*((volatile unsigned long *)(0x48000000UL)))
+#define MAINSTONE_nExBRD_IRQ (50UL)
+#define DCSR_RUN (1UL)
+#define DCSR_STOPSTATE (2UL)
+#define DCSR_NODESC (4UL)
+#define DCMD_INCTRGADDR (1UL)
+#define DCMD_INCSRCADDR (2UL)
+#define DCMD_BURST32 (4UL)
+#define DCMD_LENGTH (8UL)
+#define DCSR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DTADR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DSADR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DCMD(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+extern unsigned long virt_to_bus(unsigned long arg);
+#endif //USE_XSCALE
+
+
+/********************************************************
+**************PEAKS DRIVER*******************************
+********************************************************/
+#if (defined(USE_PEAKS)||defined(USE_PEAKS_LITE))
+struct hw_interrupt_type {
+	const char * typename;
+	unsigned int (*startup)(unsigned int irq);
+	void (*shutdown)(unsigned int irq);
+	void (*enable)(unsigned int irq);
+	void (*disable)(unsigned int irq);
+	void (*ack)(unsigned int irq);
+	void (*end)(unsigned int irq);
+	void (*set_affinity)(unsigned int irq, unsigned long mask);
+};
+#define Gicr(arg) (*(volatile WORD *)(arg))
+typedef struct _IRQ_TYPE {
+	struct hw_interrupt_type *handler;
+} IRQ_TYPE, * PIRQ_TYPE;
+PIRQ_TYPE irq_desc=NULL;
+extern void purge_cache(unsigned long arg1,unsigned long arg2,unsigned long arg3);
+#endif //USE_PEAKS or USE_PEAKS_LITE
+
+
+/**********************************************************
+***************COMMAND APPLICATION*************************
+**********************************************************/
+#ifdef CMD9118
+#define AF_INET		(0)
+#define SOCK_DGRAM	(0)
+struct in_addr {
+	unsigned long s_addr;
+};
+#define INADDR_ANY (0xFFFFFFFFUL)
+struct sockaddr_in {
+  unsigned short int	sin_family;	/* Address family		*/
+  unsigned short int	sin_port;	/* Port number			*/
+  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+//  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+//			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+struct sockaddr {
+  unsigned short int	sa_family;	/* Address family		*/
+//  unsigned short int	sin_port;	/* Port number			*/
+//  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+//  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+//			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+
+#define SOCK_STREAM		(1)
+#define SOL_SOCKET		(2)
+#define SO_REUSEADDR	(3)
+
+#define FILE void
+
+extern void * fopen(const char * fileName,const char * mode);
+
+extern void * stdin;
+extern void * stderr;
+extern const char * optarg;
+extern void printf(const char * b,...);
+extern int recv(int sock,unsigned char *ch,int a,int b);
+extern int send(int sock,unsigned char *ch,int a,int b);
+extern unsigned int inet_addr(const char * hostname);
+extern int socket(int a,int b,int c);
+extern void close(int a);
+extern int fork(void);
+extern int system(const char * command);
+extern void fclose(void *);
+extern void strncpy(char * a, const char *b, int c);
+extern void perror(char * c);
+extern unsigned short htons(unsigned short a);
+extern void sleep(int s);
+extern void exit(int x);
+extern int sscanf(const char *a,char *b,...);
+extern int accept(int a,struct sockaddr *b,int *c);
+extern int listen(int a,int b);
+extern int strcmp(const char *a,const char *b);
+extern int bind(int a,struct sockaddr *b,int c);
+extern int connect(int a,struct sockaddr *b,int c);
+extern int fread(char *a,int b,int c,void *d);
+extern void ioctl(int a,int b,struct ifreq *c);
+extern int getopt(int a,char **b,char *c);
+extern int setsockopt(int a,int b,int c,char *d,int e);
+extern void setsid(void);
+
+
+#endif //CMD9118
+
+#endif //LINT_H
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/readme.txt linux-2.6.23.1-stm/drivers/net/smsc_911x/readme.txt
--- linux-2.6.23.1/drivers/net/smsc_911x/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/readme.txt	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,1523 @@
+/***************************************************************************
+ *
+ * Copyright (c) 2004-2005, SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: Readme.txt
+ */
+
+This is the users/programmers guide for the LAN9118 Linux Driver
+The following sections can be found below
+*  Revision History
+*  Files
+*  Features
+*  Driver Parameters
+*  Rx Performance Tuning
+*  Tested Platforms
+*  Rx Code Path
+*  Tx Code Path
+*  Platform Interface Descriptions
+
+#######################################################
+############### REVISION HISTORY ######################
+#######################################################
+06/04/2004 Bryan Whitehead. Version 0.50:
+This is the first beta version
+
+06/21/2004 Bryan Whitehead, Version 0.51:
+added multicast
+added private ioctls to set mac address and write eeprom (not tested)
+removed timeout function, which served no purpose anyway.
+
+07/09/2004 Bryan Whitehead, Version 0.52
+Improved Flow Control
+More Control on Link Management
+   the driver parameter link_mode is now a bit wise field that
+     specifies any combination of 4 or fewer link speeds
+     1=10HD,2=10FD,4=100HD,8=100FD
+     Still Autonegotiation is always used.
+
+07/13/2004 Bryan Whitehead, Version 0.53
+EEPROM has been fixed and tested.
+   If there is an EEPROM connected and loaded correctly, its
+     mac address will be loaded into the 118
+Improved Flow Control again. Measured >10X improvement
+    in UDP_STREAM test with small packets.
+
+07/30/2004 Bryan Whitehead, Version 0.54
+Added many IOCTL codes for use with the command app, cmd9118.
+Added functions to the Platform interface
+	Platform_RequestDmaChannel
+	Platform_ReleaseDmaChannel
+Added Macros to Platform interface
+	PLATFORM_DEFAULT_RX_DMA
+	PLATFORM_DEFAULT_TX_DMA
+
+08/12/2004 Bryan Whitehead, Version 0.55
+Updated driver documentation
+Consolidated most driver source files into smsc9118.c
+Minor changes to the platform interface
+
+08/13/2004 Bryan Whitehead, Version 0.56
+Added Ioctl COMMAND_GET_CONFIGURATION
+  this command used with "cmd9118 -cGET_CONFIG"
+  will display driver information, which is especially
+  useful if trace points have been disabled.
+
+08/24/2004 Bryan Whitehead, Version 0.57
+Implemented software patch to resynchronize Rx fifos after an
+overrun is detected.
+
+08/24/2004 Bryan Whitehead, Version 0.58
+Turned on LEDs which were accidentally turned off in version 0.57
+
+08/25/2004 Bryan Whitehead, Version 0.59
+Added extra driver context variables useful for debugging
+They can be accessed with the following command
+# cmd9118 -cGET_CONFIG
+
+08/30/2004 Bryan Whitehead, Version 0.60
+Fixed bug in software patch (0.57) that caused the receiver to be turned
+off and not turned back on.
+Added symple packet filter to detect bad packets. If a bad packet
+is detected the driver will handle it like an overrun. That is, turn off
+receiver, empty fifos, clear fifo pointers(RX_DUMP), and turn on receiver.
+This method allows the driver to recover after a fifo synchronization fault.
+
+09/01/2004 Bryan Whitehead, Version 0.61
+This version was used for testing the patch. It was for internal purposes only
+
+09/03/2004 Bryan Whitehead, Version 0.62
+This version fixes some bugs in 0.60 and includes extra work around code
+to improve patch reliability.
+
+09/07/2004 Bryan Whitehead, Version 0.63
+Added IOCTLs for reading and writing to general memory
+
+09/13/2004 Bryan Whitehead, Version 0.64
+As the hardware issue is now fully understood, this patch includes
+a few changes to make the work around reliable in all situations.
+This version also has a the beginnings of new flow control feature,
+however this feature is disable for this version because it is
+still in progress.
+The build process has also changed. Now instead of building one
+debug driver, you can build a release and debug driver by choosing
+to include or not include the define USE_DEBUG. The release version
+enables activity LEDs, and removes all trace, warning, and assertion
+messages. The debug version enables GPIO signals, and enables trace,
+warning, and assertion messages.
+
+09/15/2004 Bryan Whitehead, Version 0.65
+Removed packet filter from 0.64
+Added non-Auto-Negotiate link modes. See description of the
+  link_mode driver parameter below
+
+09/28/2004 Bryan Whitehead, Version 0.66/0.67
+Added Rx flow control which is only turned on when the driver
+detects a lack of flow control in the higher layers.
+
+10/07/2004 Bryan Whitehead, Version 0.68
+Added support for Peakslite, and Polaris.
+Implemented support for Phy management tools
+  such as mii-diag and mii-tool.
+
+10/13/2004 Bryan Whitehead, Version 0.69
+Fixed some issues with Linux 2.6.
+
+10/18/2004 Bryan Whitehead, Version 0.70
+Added support for new chips 115, 116, 117.
+	NOTE: 115, and 116 may still require bus timing
+		adjustment.
+Disabled workaround when rev b is detected.
+
+10/20/2004 Bryan Whitehead, Version 0.71/0.72
+Added support for tasklets, which allow the bulk of the
+Rx processing to be done with out blocking interrupts for
+the rest of the system.
+
+10/27/2004 Bryan Whitehead, Version 1.00
+Tuned the PLATFORM_INT_DEAS for sh3 platforms to get better
+TCP performance. Bumped up version number to 1.00 because this
+will be the first official release.
+
+10/27/2004 Bryan Whitehead, Version 1.01
+Changed sh3 POLARIS platform to use cycle steal DMA
+
+11/11/2004 Bryan Whitehead, Version 1.02/1.03
+Changed tasklets to default to off, (tasklets=0)
+Testing has shown that tasklets are not stable yet. So changing the
+default allows us to release this version. The user may still turn
+tasklets on but does so at there own risk.
+
+11/11/2004 Bryan Whitehead, Version 1.04
+Fixed Tasklet Issue.
+Changed tasklets to be ON by default, (tasklets=1)
+
+11/18/2004 Bryan Whitehead, Version 1.05
+Improved software flow control.
+Updated platform code to handle all chips 118/117/116/115
+
+11/19/2004 Bryan Whitehead, Version 1.06
+Added support to provide separate flow control parameters
+  for 118/117 and 116/115. And the driver will use which
+  ever is appropriate.
+
+11/23/2004 Bryan Whitehead, Version 1.07
+Changed the driver so that PAUSE frames will be enable or disabled
+based on state of the local and remote pause bits, as specified in
+IEEE Standard 802.3, 2000 Edition, page 1360, Table 28B-3-Pause Resolution
+
+12/01/2004 Bryan Whitehead, Version 1.08
+Added support for external phy.
+To enable use of external phy use the follow driver parameter setting
+    ext_phy=1
+other wise the driver will use the internal phy as it always has before.
+
+12/01/2004 Bryan Whitehead, Version 1.09
+replace the ext_phy parameter with phy_addr which works as follows
+if(phy_addr==0xFFFFFFFF) {
+	//use internal phy
+} else if (phy_addr<32) {
+	//use external phy at address specified by phy_addr
+	//  if external phy can not be found use internal phy
+} else {
+	//attempt to auto detect external phy
+	//  if external phy can not be found use internal phy
+}
+
+02/14/2005 Bryan Whitehead, Version 1.11
+Automated the tuning procedure. See RX PERFORMANCE TUNING.
+Changed all register access to use a Macro instead of
+   a memory mapped structure. This should simplify porting,
+   if register access is ever done through IO space.
+Tuned all current platforms.
+Increased time out of Rx_FastForward to 500.
+Fixed faulty define TX_CMD_A_BUF_SIZE_
+Fixed faulty define TX_CMD_B_PKT_BYTE_LENGTH_
+Changed Phy reset to use PHY_BCR_RESET
+Cleaned driver with Lint tool
+Updated Rx_CountErrors
+	Only count length error if length/type field is set
+	If there is a CRC error don't count length error or
+	  multicast
+Changed access to Mac and Phy registers. Now requires only
+	one lock, MacPhyLock. This replaces the MacAccessLock,
+	PhyAccessLock, and RxSwitchLock.
+
+02/28/2005 Bryan Whitehead, Version 1.12
+Added date_code static constant
+
+02/28/2005 Bryan Whitehead, Version 1.13
+Added support for LAN9112
+
+03/21/2005 Bryan Whitehead, Version 1.13
+Updated Platforms ".h" file to include a version number in
+   the PLATFORM_NAME macro. This version number is platform
+   specific and independent of the common code version
+   number.
+Merged in STMICRO platform code to release tree
+
+03/22/2005 Bryan Whitehead, Version 1.13
+Updated platform code see st40.c for changes
+
+03/23/2005 Bryan Whitehead, Version 1.13
+Changed the format of the platform version to rN,
+  where N is the number of the platform revision.
+  This is visible in the PLATFORM_NAME macro.
+
+04/11/2005 Bryan Whitehead, Version 1.14
+Added Platform_CleanUp function, to be used in the event
+	that a particular platform should release resources
+	when the driver is unloaded from memory
+Moved register access and data port access from common
+	code to platform code. This is to support the
+	possibility that a big endian system may need to do
+	byte swapping.
+
+
+Changed Lan_SetRegDW to use Platform_SetRegDW
+Changed Lan_GetRegDW to use Platform_GetRegDW
+Changed Lan_ClrBitsDW to use Platform_S/GetRegDW
+Changed Lan_SetBitsDW to use Platform_S/GetRegDW
+Changed Tx_WriteFifo to Platform_WriteFifo
+Changed Rx_ReadFifo to Platform_ReadFifo
+Changed the way platform files are included.
+	Now the Macros PLATFORM_HEADER and PLATFORM_SOURCE
+	will define a string that is the path to those
+	header and source files.
+
+04/15/2005 Bryan Whitehead, Version 1.15
+Migrated source control to perforce.
+Merged platform ".h" and ".c" file to a single
+	platform ".c" file
+
+05/26/2005 M David Gelbman, Version 1.16
+Integrated Beacon PHY work-around into both Concord and
+Beacon versions.
+LED1 - 10/100 LED activity corrected to go OFF when link
+state goes DOWN.
+
+07/12/2005 Bryan Whitehead, Version 1.17
+Fixed issue where driver parameter phy_addr was not used.
+
+07/20/2005 Bryan Whitehead, Version 1.18
+Preserve Platform Data from close to reopen.
+
+07/26/2005 Phong Le
+Version 1.19 Make delay time for EEPROM longer.
+Fix bugs
+Bug#1 external/internal problem. These are bugs introduced
+when making LED work around and PHY work around.
+Bug#2 Fix bug when bring down a driver, then bring up, driver crashed.
+
+08/29/2005 - Phong Le
+Version 1.20 Integrate fixes for false statistic error count report.
+
+10/31/2005 - Phong Le
+Version 1.21 Integrate fixes for Rx Multicast work around.
+
+11/02/2005 - Phong Le
+Still version 1.21 Fix bugs for version 1.21.
+
+11/07/2005 - Phong Le
+Still version 1.21 Fix bugs for version 1.21.
+
+12/06/2005 Bryan Whitehead, Version 1.22
+Added support for LAN9218, LAN9217, LAN9216, LAN9215
+
+03/03/2006 Bryan Whitehead, Version 1.23
+Fixed External Phy Support for LAN9217, LAN9215 (Bug 102)
+Fixed Interrupt handler to only process enabled interrupts (Bug 96)
+Fixed Multicast workaround to not rely on link status
+   which may have been out dated (Bug 95)
+
+03/22/2006 Bryan Whitehead, Version 1.24
+Made driver future proof. Such that if the revision of a
+chip increases it should still work.
+
+03/23/2006 Bryan Whitehead, Version 1.25
+Added print message to display date code on start up
+Updated chip names to LAN9218, LAN9217, LAN9216, LAN9215
+
+#######################################################
+#################### FILES ############################
+#######################################################
+readme.txt: this file
+
+smsc9118.c: Main driver source code file.
+       This file contains all platform independent code
+       It also includes platform dependent code based
+       on the following defines
+          USE_SH3
+          USE_PEAKS
+          USE_XSCALE
+       One of these should be defined in the build batch file
+        or makefile
+
+peaks.h
+xscale.h
+sh3.h
+      These files are platform dependent files. They define
+      the platform dependent structure, PLATFORM_DATA.
+      They also define some platform dependent constants for
+      use by smsc9118.c. see PLATFORM INTERFACE DESCRIPTIONS
+      below for more information
+
+peaks.c
+xscale.c
+sh3.c
+       These files implement the platform dependent functions
+       used by smsc9118.c. see PLATFORM INTERFACE DESCRIPTIONS
+       below for more information
+
+ioctl_118.h
+      defines ioctl codes common between the driver(smsc9118.c)
+      and the helper application (cmd9118.c)
+
+cmd9118.c
+       This is the source code for the helper application.
+       It provides the means by which one can send any ioctl code
+       to the driver (smsc9118.c).
+
+buildp: This batch file is used for building the driver for the
+        peaks platform, and the helper application
+        usage: bash buildp
+
+builds: This batch file is used for building the driver for the
+        sh3 platform, and the helper application
+        usage: bash builds
+
+buildx: This batch file is used for building the driver for the
+        xscale platform, and the helper application
+        usage: bash buildx
+
+smsc9118.o: this is the driver binary obtained after building
+        smsc9118.c
+
+cmd9118: this is the helper application binary obtained after
+        building cmd9118.c
+
+lint.h:
+	This is a header file for use only with the lint tool.
+	It provides structure definitions and function declarations
+	used by the driver so the lint tool does not need to
+	scan the real header files. This is done because the real
+	header files generate too many error messages.
+
+cmd9118.Lnt:
+smsc9118-*.Lnt:
+	These are lint configuration files used with the lint tool
+
+cmd9118-Lnt.txt
+smsc9118-*-Lnt.txt:
+	These are lint output files created by the lint tool.
+
+COPYING:
+
+	This is a copy of the GNU GENERAL PUBLIC LICENSE
+
+
+############################################################
+################### FEATURES ###############################
+############################################################
+transmit and receive for pio and dma
+Automatic Flow control for Tx, and Rx
+Multicast capable
+Mac Address Management
+External Phy support
+
+
+############################################################
+################## DRIVER PARAMETERS #######################
+############################################################
+The following are load time modifiable driver parameters.
+They can be set when using insmod
+Example:
+# insmod smsc9118.o rx_dma=0 tx_dma=1 irq=5
+
+lan_base
+    specifies the physical base location in memory where the
+    LAN9118 can be accessed. By default the location will be
+    choosen by Platform_Initialize.
+
+bus_width
+    specifies the bus_width to be configured by
+    Platform_Initialize. Must be set to either 16, or 32.
+    Any other value or by default Platform_Initialize will
+    attempt to autodetect the bus width
+
+
+link_mode
+    specifies the link mode used. Each bit has different meanings
+      bit 0, 0x01, 10Mbps Half Duplex,
+      bit 1, 0x02, 10Mbps Full Duplex,
+      bit 2, 0x04, 100Mbps Half Duplex,
+      bit 3, 0x08, 100Mbps Full Duplex,
+      bit 4, 0x10, Symmetrical Pause,
+      bit 5, 0x20, Asymmetrical Pause,
+      bit 6, 0x40, Auto Negotiate,
+
+    if bit 6 is set, then Auto Negotiation is used, and bits 0 through 5
+      define what modes are advertised.
+
+    if bit 6 is clear, then Auto Negotiation is not used, and bits 0
+      through 3 select which speed and duplex setting to use. In this case,
+      only the most significant set bit is used to set the speed and duplex.
+      Example, the following are bits 6 to 0, and the resulting setting
+      bits 6 5 4 3 2 1 0
+           0 x x 0 0 0 x, 10Mbps Half Duplex
+           0 x x 0 0 1 x, 10Mbps Full Duplex
+           0 x x 0 1 x x, 100Mbps Half Duplex
+           0 x x 1 x x x, 100Mbps Full Duplex
+
+    by default link_mode=0x7F which uses Auto Negotiation and advertises
+       all modes.
+
+irq
+    specifies the irq number to use. The default value is decided
+    by the platform layer with the macro PLATFORM_IRQ
+
+int_deas
+    specifies the interrupt deassertion period to be written to
+    INT_DEAS of INT_CFG register. The default value is decided by
+    the platform layer with the macro PLATFORM_INT_DEAS
+
+irq_pol
+    specifies the value to be written to IRQ_POL of INT_CFG register.
+    The default value is decided by the platform layer with the
+    macro PLATFORM_INT_POL.
+
+irq_type
+    specifies the value to be written to IRQ_TYPE of INT_CFG register.
+    The default value is decided by the platform layer with the
+    macro PLATFORM_IRQ_TYPE
+
+rx_dma
+    specifies the dma channel to use for receiving packets. It may
+    also be set to the following values
+        256 = TRANSFER_PIO
+            the driver will not use dma, it will use PIO.
+        255 = TRANSFER_REQUEST_DMA
+            the driver will call the Platform_RequestDmaChannel
+            to get an available dma channel
+    the default value is decided by the platform layer with the
+    macro PLATFORM_RX_DMA
+
+tx_dma
+    specifies the dma channel to use for transmitting packets. It may
+    also be set to the following values
+        256 = TRANSFER_PIO
+            the driver will not use dma, it will use PIO.
+        255 = TRANSFER_REQUEST_DMA
+            the driver will call the Platform_RequestDmaChannel
+            to get an available dma channel
+    the default value is decided by the platform layer with the
+    macro PLATFORM_TX_DMA
+
+dma_threshold
+    specifies the minimum size a packet must be for using DMA.
+    Otherwise the driver will use PIO. For small packets PIO may
+    be faster than DMA because DMA requires a certain amount of set
+    up time where as PIO can start almost immediately. Setting this
+    value to 0 means dma will always be used where dma has been enabled.
+
+    The default value is decided by the platform layer with the
+    macro PLATFORM_DMA_THRESHOLD
+
+mac_addr_hi16
+    Specifies the high word of the mac address. If it was not
+    specified then the driver will try to read the mac address
+    from the eeprom. If that failes then the driver will set it
+    to a valid value. Both mac_addr_hi16 and mac_addr_lo32 must be
+    used together or not at all.
+
+mac_addr_lo32
+    Specifies the low dword of the mac address. If it was not
+    specified then the driver will try to read the mac address
+    from the eeprom. If that failes then the driver will set it to
+    a valid value. Both mac_addr_hi16 and mac_addr_lo32 must be
+    used together or not at all.
+
+debug_mode
+    specifies the debug mode
+        0x01, bit 0 display trace messages
+        0x02, bit 1 display warning messages
+        0x04, bit 2 enable GPO signals
+
+    Trace messages will only display if the driver was compiled
+        with USE_TRACE defined.
+    Warning message will only display if the driver was compiled
+        with USE_WARNING defined.
+
+tx_fifo_sz
+    specifies the value to write to TX_FIFO_SZ of the
+    HW_CFG register. It should be set to a value from 0 to 15
+    that has been left shifted 16 bits.
+    The default value is 0x00050000UL
+
+afc_cfg
+    specifies the value to write to write to the AFC_CFG register
+    during initialization. By default the driver will choose a value
+    that seems resonable for the tx_fifo_sz setting. However it
+    should be noted that the driver has only be tested using the
+    default setting for tx_fifo_sz
+
+tasklets
+	A non zero value specifies that most of the receive work
+	should be done in a tasklet, thereby enabling other system interrupts.
+	A zero value specifies that all receive work is done in the ISR,
+	where interrupts are not enabled. A single burst of receive work has
+	been seen to take as long as 3 mS. It would not be friendly for this
+	driver to hold the CPU for that long, there for tasklets are enabled
+	by default. However there are some tests that measure a mild performance
+	drop when using tasklets, therefor this parameter is included so the
+	end user can choose to disable tasklets.
+	NOTE:10/29/2004: as of version 1.02 tasklets are disabled by default because
+	testing has not confirmed their stability. The user may still turn on
+	tasklets but does so at there own risk.
+	NOTE:11/05/2004: as of version 1.04 tasklets are enabled by default because
+	the issue observed before has been solved.
+
+phy_addr
+	The default value of 0xFFFFFFFF tells the driver to use the internal phy.
+	A value less than or equal to 31 tells the driver to use the external phy
+	    at that address. If the external phy is not found the internal phy
+	    will be used.
+	Any other value tells the driver to search for the external phy on all
+	    addresses from 0 to 31. If the external phy is not found the internal
+	    phy will be used.
+
+max_throughput
+    This is one of the software flow control parameters. It specifies the
+    maximum throughput in a 100mS period that was measured during an rx
+    TCP_STREAM test. It is used to help the driver decide when to activate
+    software flow control and what work load to maintain when flow control
+    is active. By default the driver will decide what value to use.
+    See RX PERFORMANCE TUNING.
+
+max_packet_count
+	This is one of the software flow control parameters. It specifies the
+	maximum packets counted in a 100mS period during an rx TCP_STREAM test.
+	It is used to help the driver decide when to activate software flow
+	control, and what work load to maintain when flow control is active.
+	By default the driver will decide what value to use.
+	See RX PERFORMANCE TUNING.
+
+packet_cost
+	This is one of the software flow control parameters. It specifies the
+	ideal packet cost. This allows the driver achieve the best performance
+	with both large and small packets, when flow control is active.
+	By default the driver will decide what value to use.
+	See RX PERFORMANCE TUNING.
+
+burst_period
+	This is one of the software flow control parameters. When flow control is active
+	the driver will do work in bursts. This value specifies the length of
+	the burst period in 100uS units. By default the driver will decide what value to
+	use. See RX PERFORMANCE TUNING.
+
+max_work_load
+	This is one of the software flow control parameters. It specifies the amount
+	of work the driver can do in a 100mS period. By default it is set as
+	max_work_load = max_throughput + (max_packet_count*packet_cost);
+	See RX PERFORMANCE TUNING.
+
+
+###########################################################
+################# RX PERFORMANCE TUNING ###################
+###########################################################
+
+Under most real world conditions traffic is flow controlled at
+the upper layers of the protocol stack. The most common example is
+TCP traffic. Even UDP traffic is usually flow controlled in the sense
+that the transmitter does not normally send continuous wirespeed traffic.
+When high level flow control is in use, it usually produces the
+best performance on its own with no intervention from the driver.
+But if high level flow control is not in use, then the driver will be
+working as fast as it can to receive packets and pass them up to
+the OS. In doing so it will hog CPU time and the OS may drop packets
+due to lack of an ability to process them. It has been found that
+during these heavy traffic conditions, throughput can be significantly
+improved if the driver voluntarily releases the CPU. Yes, this will
+cause more packets to be dropped on the wire but a greater number
+of packets are spared because the OS has more time to process them.
+
+As of version 1.05 and later, the driver implements a new flow control
+detection method that operates like this. If the driver detects an
+excessive work load in the period of 100mS, then the driver
+assumes there is insufficient flow control in use. Therefor it will
+turn on driver level flow control. Which significantly reduces the
+amount of time the driver holds the CPU, and causes more packets to
+be dropped on the wire. So a balancing/tuning, needs to be performed
+on each system to get the best performance under these conditions.
+If however the driver detects a tolerable work load in a period of
+100mS then it assumes flow control is being managed well and does
+not attempt to intervene by releasing the CPU. Under these conditions
+the driver will naturally release the CPU to the OS, since the system
+as a whole is keeping up with traffic.
+
+Now that the background has been discussed, its necessary to talk
+about how the driver implements flow control. The method used is a
+work load model. This is similar but not exactly the same as
+throughput. Work load is the sum of all the packet sizes plus a constant
+packet cost for each packet. This provides more balance. For instance
+a stream of max size packets will give a large throughput with fewer
+packets, while a stream of min size packets will give a low throughput
+with many packets. Adding a per packet cost to the work load allows these
+two cases to both activate and manage flow control. If work load only
+counted packet sizes then only a stream of max size packets would
+activate flow control, while a stream of min size packets would not.
+
+There are five primary parameters responsible for managing flow control.
+They can be found in the FLOW_CONTROL_PARAMETERS structure.
+They are
+	MaxThroughput, Represents the maximum throughput measured in a
+		100mS period, during an rx TCP_STREAM test.
+	MaxPacketCount, Represents the maximum packet count measured in a
+		100mS period, during an rx TCP_STREAM test.
+	PacketCost, Represents the optimal per packet cost
+	BurstPeriod, Represents the optimal burst period in 100uS units.
+	IntDeas, This is the value for the interrupt deassertion period.
+	    It is set to INT_DEAS field of the INT_CFG register.
+The driver will call Platform_GetFlowControlParameters to get these
+
+parameters for the specific platform and current configuration.
+These parameters must be carefully choosen by the driver writer so
+optimal performance can be achieved. Therefor it is necessary to
+describe how the driver uses each parameter.
+
+The first three parameters MaxThroughput, MaxPacketCount, and PacketCost,
+are used to calculate the secondary parameter, MaxWorkLoad according
+to the following formula.
+	MaxWorkLoad=MaxThroughput+(MaxPacketCount*PacketCost);
+MaxWorkLoad represents the maximum work load the system can handle during
+a 100mS period.
+	The driver will use MaxWorkLoad and BurstPeriod to determine
+BurstPeriodMaxWorkLoad, which represents the maximum amount of work the
+system can handle during a single burst period. It is calculated as follows
+	BurstPeriodMaxWorkLoad=(MaxWorkLoad*BurstPeriod)/1000;
+
+Every 100mS the driver measures the CurrentWorkLoad by the following
+algorithm.
+
+	At the beginning of a 100mS period
+		CurrentWorkLoad=0;
+
+	During a 100mS period CurrentWorkLoad is adjusted when a packet
+	arrives according to the following formula.
+		CurrentWorkLoad+=PacketSize+PacketCost;
+
+	At the end of a 100mS period
+		if(CurrentWorkLoad>((MaxWorkLoad*(100+ActivationMargin))/100))
+		{
+			if(!FlowControlActive) {
+				FlowControlActive=TRUE;
+				//Do other flow control initialization
+				BurstPeriodCurrentWorkLoad=0;
+			}
+		}
+		if(CurrentWorkLoad<((MaxWorkLoad*(100-DeactivationMargin))/100))
+		{
+			if(FlowControlActive) {
+				FlowControlActive=FALSE;
+				//Do other flow control clean up
+				Enable Receiver interrupts
+			}
+		}
+
+During periods where flow control is active, that is
+FlowControlActive==TRUE, the driver will manage flow control by the
+following algorithm.
+
+	At the end/beginning of a burst period
+		if(BurstPeriodCurrentWorkLoad>BurstPeriodMaxWorkLoad) {
+			BurstPeriodCurrentWorkLoad-=BurstPeriodMaxWorkLoad;
+		} else {
+			BurstPeriodCurrentWorkLoad=0;
+		}
+		Enable Receiver Interrupts;
+
+	When checking if a packet arrives
+		if(BurstPeriodCurrentWorkLoad<BurstPeriodMaxWorkLoad) {
+			//check for packet normally
+			BurstPeriodCurrentWorkLoad+=PacketSize+PacketCost;
+		} else {
+			//Do not check for packet, but rather
+			//  behave as though there is no new packet.
+			Disable Receiver interrupts
+		}
+
+This algorithm will allow the driver to do a specified amount
+of work and then give up the CPU until the next burst period. Doing this
+allows the OS to process all the packets that have been sent to it.
+
+So that is generally how the driver manages flow control. For more
+detail you can refer to the source code. Now it is necessary to
+describe the exact method for obtaining the optimal flow control
+parameters.
+
+When obtaining the optimal flow control parameters it is important
+to note the configuration you are using. Generally there are 8
+configurations for each platform. They involve the following options
+	DMA or PIO
+	16 bit or 32 bit
+	118/117/112 or 116/115
+Some platforms may only use 16 bit mode. While other platforms may
+have a selectable clock rate. What ever the options are, every combination
+should be identifiable, and Platform_GetFlowControlParameters should be
+implemented to provide the correct flow control parameters. It is important
+to be sure that the carefully selected parameters are applied to the
+same configuration used during tuning.
+
+Flow control tuning requires a publically available program called
+netperf, and netserver, which are a client/server pair. These are built
+with the same make file and can be found on the web.
+
+Fortunately, as of version 1.10, smsc9118 and cmd9118 supports an automated
+tuning mechanism. The process takes about one hour and can be initiated as
+follows
+
+AUTOMATED TUNING:
+
+Choose the configuration you want to tune.
+That is choose between
+  DMA or PIO,
+  16 bit or 32 bit,
+  118/117/112 or 116/115,
+Make sure there is a direct connection between the target platform
+and the host platform. Do not use a hub, or switch. The target
+platform is the platform that will run this driver. The host platform
+should be a PC easily capable of sending wire speed traffic.
+
+Install the driver on your target platform with your choosen configuration.
+	insmod smsc9118d.o
+	ifconfig eth1 192.1.1.118
+load servers on target platform
+	netserver
+	cmd9118 -cSERVER
+On host platform, make sure the netperf executable is
+located in the same directory and the cmd9118 executable. While in that
+directory run the following.
+	cmd9118 -cTUNER -H192.1.1.118
+This command, if successful, will begin the one hour tuning process.
+At the end you will get a dump of the optimal flow control parameters.
+The key parameters needed are
+    MaxThroughput
+    MaxPacketCount
+    PacketCost
+    BurstPeriod
+    IntDeas
+These value must be assigned in Platform_GetFlowControlParameters to
+	flowControlParameters->MaxThroughput
+	flowControlParameters->MaxPacketCount
+	flowControlParameters->PacketCost
+	flowControlParameters->BurstPeriod
+	flowControlParameters->IntDeas
+Make sure the Platform_GetFlowControlParameters checks the current configuration
+and will only set those parameters if the current configuration matches the
+configuration you tuned with.
+
+Next start over but choose a configuration you haven't already tuned.
+
+
+MANUAL TUNING:
+In the off chance that the automated tuning fails to work properly, you may
+use the following manual tuning procedure.
+
+STEP 1:
+	Select a configuration. That is choose between DMA or PIO, 16 bit or
+	32 bit, 118/117/112 or 116/115.
+	Make sure there is a direct connection between the target platform
+	and the host platform. Do not use a hub, or switch. The target
+	platform is the platform that will run this driver. The host platform
+	should be a PC easily capable of sending wire speed traffic.
+
+STEP 2:
+	load the driver on the target platform with the following commands
+		insmod smsc9118.o max_work_load=0 int_deas=ID
+		ifconfig eth1 192.1.1.118
+		netserver
+	ID will be replated by the number you will be adjusting to obtain the
+		best throughput score in STEP 3, initially a goog number to start
+		with is 0.
+
+STEP 3:
+	On  the host platform run the following command
+		netperf -H192.1.1.118
+	Examine the output. The goal is to maximize the number on the
+		Throughput column.
+	If you are satisfied with the throughput remember the ID number
+		you used and move on to STEP 4.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc9118
+		goto STEP 2 and use a different value for ID
+
+
+STEP 4:
+	unload the driver with
+		ifconfig eth1 down
+		rmmod smsc9118
+	load driver on the target platform with the following commands
+		insmod smsc9118.o max_work_load=0 int_deas=ID
+		ifconfig eth1 192.1.1.118
+		netserver
+	NOTE: the driver will be making traffic measurements. Therefor
+		it is important not to insert any steps between 4 and 6.
+
+STEP 5:
+	run netperf on the host platform
+		netperf -H192.1.1.118
+	repeat two more times.
+
+STEP 6:
+	on target platform run the following
+		cmd9118 -cGET_FLOW
+	Many variables will be displayed. Two of them are measurements we need.
+	You can set the following two parameters as follows.
+		MaxThroughput  = RxFlowMeasuredMaxThroughput;
+		MaxPacketCount = RxFlowMeasuredMaxPacketCount;
+
+STEP 7:
+	Unload the driver on target platform with
+		ifconfig eth1 down
+		rmmod smsc9118
+	Apply the parameters obtained in STEP 6 and 2/3 to the appropriate location,
+		given the configuration choosen in STEP 1, in
+		Platform_GetFlowControlParameters. The parameters for your
+		choosen configuration should be set as follows
+			MaxThroughput = (RxFlowMeasuredMaxThroughput from step 6);
+			MaxPacketCount = (RxFlowMeasuredMaxPacketCount from step 6);
+			PacketCost=0; //temporarily set to 0
+			BurstPeriod=100; //temporarily set to 100
+			IntDeas= (ID from step 2/3).
+	recompile driver.
+
+STEP 8:
+	Again make sure your still using the same configuration you selected
+		in STEP 1.
+	Load recompiled driver on target platform with the following commands
+		insmod smsc9118.o burst_period=BP
+		ifconfig eth1 192.1.1.118
+	BP will be replaced by the number you will be adjusting to obtain the
+		best throughput score in STEP 9, initially a good number to
+		start with is 100.
+
+STEP 9:
+	On Host platform run the following command
+		netperf -H192.1.1.118 -tUDP_STREAM -l10 -- -m1472
+	Examine the output.	The goal is to maximize the lower
+		number on the Throughput column.
+	If you are satisfied with the throughput remember the BP number
+		you used and move on to STEP 10.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc9118
+		goto STEP 8 and use a different value for BP.
+
+STEP 10:
+	unload the driver on target platform
+		ifconfig eth1 192.1.1.118 down
+		rmmod smsc9118
+	Again make sure your still using the same configuration you selected
+		in STEP 1.
+	Load the recompiled driver from STEP 7 on target platform with
+		insmod smsc9118.o burst_period=BP packet_cost=PC
+		ifconfig eth1 192.1.1.118
+	BP will be replaced with the value you settled on in STEP 8/9.
+	PC will be replaced by the number you will be adjusting to
+		obtain the best throughput score in STEP 11, typically PC ends
+		up somewhere between 100 and 200.
+
+STEP 11:
+	On Host platform run the following command
+		netperf -H192.1.1.118 -tUDP_STREAM -l10 -- -m16
+	Examine the output. The goal is to maximize the lower
+		number on the Throughput column.
+	If you are satisfied with the throughput remember the PC number
+		you used and move on the STEP 12.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc9118
+		goto STEP 10 and use a different value for PC
+
+STEP 12:
+	Apply the parameters to the appropriate location, given the
+	configuration choosen in step 1, in Platform_GetFlowControlParameters.
+		PacketCost= (PC from step 10/11);
+
+		BurstPeriod= (BP from step 8/9);
+	recompile driver.
+	Now the values you applied will be the default values used when that
+		same configuration is used again.
+	Goto STEP 1 and choose a configuration you have not yet tuned.
+
+###########################################################
+################### TESTED PLATFORMS ######################
+###########################################################
+This driver has been tested on the following platforms.
+The driver was loaded as a module with the following command
+line.
+
+	insmod smsc9118.o
+
+===========================================================
+Platform:
+	SH3 SE01
+Motherboard:
+	Hitachi/Renesas, MS7727SE01/02
+SMSC LAN9118 Board:
+	LAN9118 FPGA DEV BOARD, ASSY 6337 REV A
+LAN9118:
+	LAN9118
+Linux Kernel Version:
+	2.4.18
+Driver Resources:
+	LAN_BASE=0xB4000000
+	IRQ=8
+
+===========================================================
+Platform:
+	XSCALE
+Motherboard:
+	Intel Corp, MAINSTONE II MAIN BOARD REV 2.1
+SMSC LAN9118 Board:
+	LAN9118 XSCALE FPGA DEV BOARD, ASSY 6343 REV A
+LAN9118:
+	LAN9118
+Linux Kernel Version:
+	2.4.21
+Driver Resources:
+	LAN_BASE=0xF2000000
+	IRQ=198
+
+###########################################################
+##################### RX CODE PATH ########################
+###########################################################
+The purpose of this section is to describe how the driver
+receives packets out of the LAN9118 and passes them to the
+Linux OS. Most functions in the Rx code path start with Rx_
+
+During initialization (Smsc9118_open) the function
+Rx_Initialize is called. This call enables interrupts for
+receiving packets.
+
+When a packet is received the LAN9118 signals an interrupt,
+which causes Smsc9118_ISR to be called. The Smsc9118_ISR function
+is the main ISR which passes control to various handler routines.
+One such handler routine that gets called is Rx_HandleInterrupt.
+
+Rx_HandleInterrupt first checks to make sure the proper
+interrupt has been signaled (INT_STS_RSFL_). If it has not
+it returns immediately. If it has been signaled then it decides
+if it should use PIO or DMA to read the data.
+
+In both cases the process is like this
+    An Rx status DWORD is read using Rx_PopRxStatus
+    If there is an error
+        the packet is purged from the LAN9118
+            data fifo with Rx_FastForward
+    If there is no error
+        an sk_buff is allocated to receive the data
+        The data is read into the sk_buff using PIO or DMA.
+        After data is read the sk_buff is sent to linux using
+            Rx_HandOffSkb
+    The process continues until Rx_PopRxStatus returns 0
+
+DMA is a little more complicated than PIO because it is written
+to take advantage of concurrent processing. To get as much useful
+work done as possible while a DMA operation is in progress.
+Therefor DMA has the best performance boost when there are
+several packets to service on a single call to Rx_HandleInterrupt
+
+This is the purpose of the INT_DEAS field of INT_CFG. When that
+field is set (using the driver parameter int_deas or platform macro
+PLATFORM_INT_DEAS) it forces interrupts to be paced, so more packets
+can arrive before a single call to the ISR.
+
+The LAN9118 has been proven to receive at about 94Mbps on the
+xscale platform. However other platforms run slower and require
+some means of flow control. Rx flow control is built into the
+LAN9118. It is configured by writing the AFC_CFG register. The
+user can set this value at load time using the afc_cfg parameter.
+
+Basically it works like this. If the Rx Data fifo fills up to
+a level specified by AFC_HI in AFC_CFG then the LAN9118 will begin
+flow control. If the link is half duplex then the LAN9118 will
+exert back pressure by forcing a collision on the wire when a
+packet is arriving. This will cause the sender to retransmit later.
+If the link is full duplex then the LAN9118 will transmit a Pause
+frame requesting the partner to stop sending packets. Then when
+the Rx Data fifo drops to AFC_LO in AFC_CFG then the LAN9118 will
+stop exerting back pressure in half duplex, or in full duplex it
+will transmit another pause frame that lets the partner know it
+can start sending packets again. See the LAN9118 specification
+for more information. But all of this is done with out the help
+of the driver.
+
+Still the driver must participate in Rx flow control because of
+platform speed limitations. Rx flow control in the driver is handled
+in the functions Rx_HandOffSkb, and Rx_PopRxStatus. The function
+Rx_HandOffSkb calls netif_rx which returns a congestion level.
+If any congestion is detected then Rx_HandOffSkb will set the
+RxCongested flag. The next time the driver calls Rx_PopRxStatus it
+will see the RxCongested flag is set and will not Pop a new status
+off the RX_STATUS_FIFO, but rather it will disable and re-enable
+interrupts. This action will cause the interrupt deassertion interval
+to begin. The ISR will return, and not be called again until the
+deassertion interval has expired. This gives CPU time to linux so it
+can handle the packets that have been sent to it and lower the
+congestion level. In this case the driver voluntarily stops
+servicing packets, which means the RX Data Fifo will fill up.
+Eventually the hardware flow control will start up to slow down the
+sender. Many times this will still result in an overflow of the
+Rx Data fifo and packets will be lost under heavy traffic conditions.
+But if the driver did not release the CPU to linux, then linux would
+
+drop almost all the packets. So it is better to let the packets be
+lost on the wire, rather than over consuming resources to service
+them.
+
+
+###########################################################
+##################### TX CODE PATH ########################
+###########################################################
+When Linux wants to transmit a packet it will call
+Smsc9118_hard_start_xmit. This function performs some checks
+then calles Tx_SendSkb to send the packet.
+
+Tx_SendSkb works with PIO or DMA depending on the selected
+mode.
+
+The basic sequence is this.
+First Write TxCmdA and TxCmdB into the TX_DATA_FIFO.
+Then Write the packet data into the TX_DATA_FIFO with
+    adjustments for offset and end alignment.
+Then free the skb using dev_kfree_skb
+
+DMA is a little more complicated than PIO because it is written
+to take advantage of concurrent processing. To get as much useful
+work done as possible while a DMA operation is in progress.
+Therefor DMA has the best performance boost when there are
+a burst of large packets to transmit.
+
+Tx Flow control works like this.
+If the free space in the TX_DATA_FIFO after writing the data
+is determined to be less than about the size of one full size
+packet then the driver can't be sure it can transmit the next
+packet without overflowing. Therefor the driver turns off the
+Tx queue by calling Tx_StopQueue. Then it prepares an interrupt
+to be signaled when the free space in the TX_DATA_FIFO has risen
+to an acceptable level. When that level of free space has been
+reached the interrupt is signaled and the handler will turn on
+the Tx queue by calling Tx_WakeQueue
+
+Statistic counters are updated after about every 30 packets or
+when linux calls Smsc9118_get_stats
+
+###########################################################
+########## PLATFORM INTERFACE DESCRIPTIONS ################
+###########################################################
+The platform interface provides a platform independent
+interface for the driver (smsc9118.c) This interface
+simplifies the task of porting the driver to other platforms.
+
+All functions that start with Platform_ are part of the
+platform interface. All macros that start with PLATFORM_
+are part of the platform interface.
+
+Below are descriptions of PLATFORM_ macros.
+for examples of usage see sh3.h, xscale.h or peaks.h
+
+PLATFORM_CACHE_LINE_BYTES
+      This macro is set to the size of a cache line in bytes.
+      It is used with dma operations to insure cache line
+          alignment which generally improves dma efficiency
+      It is also used to insure that the IP header of received
+          packets will be aligned on a cache line boundary
+
+PLATFORM_IRQ_POL
+      This macro is set to 0 or 1 and indicates the default
+      value the driver will use when setting the IRQ_POL bit
+      of the INT_CFG register. The user can override this
+      value at load time by setting the driver parameter irq_pol.
+
+PLATFORM_IRQ_TYPE
+      This macro is set to 0 or 1 and indicates the default
+      value the driver will use when setting the IRQ_TYPE bit
+      of the INT_CFG register. The user can override this
+      value at load time by setting the driver parameter irq_type.
+
+PLATFORM_IRQ
+      This macro indicates the default irq the driver will
+      use when requesting an ISR.
+      The user can override this value at load time by setting
+      the driver parameter irq.
+
+PLATFORM_RX_DMA
+      This macro indicates the default dma channel to use for
+
+      receiving packets. It may also be set to the following
+      macros
+         TRANSFER_PIO = 256
+             the driver will not use dma. It will use PIO.
+         TRANSFER_REQUEST_DMA = 255
+             the driver will call the Platform_RequestDmaChannel
+             to get an available dma channel
+      The user can override this value at load time by setting
+      the driver parameter rx_dma.
+
+PLATFORM_TX_DMA
+      This macro indicates the default dma channel to use for
+      transmitting packets. It may also be set to the following
+      macros
+         TRANSFER_PIO = 256
+             the driver will not use dma. It will use PIO.
+         TRANSFER_REQUEST_DMA = 255
+             the driver will call the Platform_RequestDmaChannel
+             to get an available dma channel
+      The user can override this value at load time by setting
+      the driver parameter
+
+PLATFORM_DMA_THRESHOLD
+      This macro indicates the default value for dma_threshold.
+      This value specifies the minimum size a packet must be
+      for using DMA. Otherwise the driver will use PIO. For small
+      packets PIO may be faster than DMA because DMA requires a
+      certain amount of set up time where as PIO can start almost
+      immediately. Setting this value to 0 means dma will always
+      be used where dma has been enabled.
+
+The platform specific header files (sh3.h, and xscale.h)
+must also define the platform specific data structure
+PLATFORM_DATA, and its pointer PPLATFORM_DATA.
+this structure is passed to most Platform_ functions. It
+allows the platform layer to maintain its own context information.
+
+The following are descriptions of the Platform_ functions
+for examples of usage see the files sh3.c, or xscale.c
+
+/************************************************************
+FUNCTION: Platform_Initialize
+PARAMETERS:
+	platformData, pointer to platform specified data structure
+	dwLanBase,	user specified physical base address for the LAN9118
+		= 0, let this function decide
+	dwBusWidth,
+		= 16, user specifies 16 bit mode operation, bypass autodetection
+		= 32, user specifies 32 bit mode operation, bypass autodetection
+		= any other value, driver should auto detect bus width
+DESCRIPTION:
+    This is the first Platform_xxx function that will be called
+	This function will initialize the PLATFORM_DATA structure.
+	This function will prepare the system to access the LAN9118.
+	It will properly initialize the bus and return the virtual
+	memory location where the LAN9118 can be access.
+RETURN VALUE:
+	0 = failed,
+	any other value is the virtual base address where the LAN9118
+	   can be accessed
+************************************************************/
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,
+	DWORD dwBusWidth);
+
+/***********************************************************
+FUNCTION: Platform_CleanUp
+PARAMETERS:
+	platformData, pointer to platform specified data structure
+DESCRIPTION:
+	This function is called so the platform layer can clean up
+	any resources that may have been acquired in Platform_Initialize.
+	If Platform_Initialize returned 0, then this function will
+	not be called.
+***********************************************************/
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData);
+
+/************************************************************
+FUNCTION: Platform_SetRegDW
+PARAMETERS:
+	DWORD dwLanBase, the virtual base address returned by
+			Platform_Initialize
+	DWORD dwOffset, the byte offset into the Lan address space
+			where the register of interest is located.
+			dwOffset should be DWORD aligned.
+	DWORD dwVal, the value to write to the register of interest
+DESCRIPTION:
+	This function is used to provide a platform independent
+		method of register access. It allows platform code
+		for big endian systems to do byte swapping, if necessary.
+	Because this function is very simple, it is recommended that
+		it should be implemented as inline or as a macro.
+RETURN VALUE: void
+************************************************************/
+inline void Platform_SetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset,
+	DWORD dwVal);
+
+/************************************************************
+FUNCTION: Platform_GetRegDW
+PARAMETERS:
+	DWORD dwLanBase, the virtual base address returned by
+			Platform_Initialize
+	DWORD dwOffset, the byte offset into the Lan address space
+			where the register of interest is located.
+			dwOffset should be DWORD aligned.
+DESCRIPTION:
+	This function is used to provide a platform independent
+		method of register access. It allows platform code
+		for big endian systems to do byte swapping if necessary.
+	Because this function is very simple, it is recommended that
+		it should be implemented as inline or as a macro.
+RETURN VALUE:
+	The DWORD value read from the register of interest;
+************************************************************/
+inline DWORD Platform_GetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset);
+
+/***********************************************************
+FUNCTION: Platform_Is16BitMode
+PARAMETER:
+	platformData, pointer to platform specific data structure
+RETURN VALUE:
+	TRUE if the platform is configured for 16 bit mode
+	FALSE if the platform is configured for 32 bit mode
+NOTE: this function is not currently used.
+***********************************************************/
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData);
+
+/************************************************************
+FUNCTION: Platform_RequestIRQ
+DESCRIPTION:
+    Used to request and set up the ISR
+PARAMETERS:
+	platformData, pointer to platform specific data structure
+	dwIrq,
+	  = 0xFFFFFFFF, let this function decide what IRQ to use
+	  = any other value is the IRQ requested by the user
+	pIsr, pointer to the ISR, to be registered.
+	dev_id, pointer to the driver specific structure
+	   used when registering the ISR with Linux
+RETURN VALUE:
+    TRUE if successful
+	FALSE is unsuccessful
+************************************************************/
+BOOLEAN Platform_RequestIRQ(
+
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	void (*pIsr)(int irq,void *dev_id,struct pt_regs *regs),
+	void *dev_id);
+
+/***********************************************************
+FUNCTION: Platform_CurrentIRQ
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+RETURN VALUE:
+	The IRQ number actually used by Platform_RequestIRQ
+	  This may be different than the requested IRQ
+***********************************************************/
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData);
+
+/**********************************************************
+FUNCTION: Platform_FreeIRQ
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+DESCRIPTION:
+    uninstalls the ISR installed from Platform_RequestIRQ
+**********************************************************/
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData);
+
+/*********************************************************
+FUNCTION: Platform_IsValidDmaChannel
+PARAMETERS:
+	dwDmaCh, the dma channel number to test for validity
+DESCRIPTION:
+    This function is used to test the validity of the
+    channels request with parameters rx_dma, and tx_dma
+RETURN VALUE:
+	TRUE if the dma channel may be used
+	FALSE if the dma channel may not be used
+NOTE: this function does not use PLATFORM_DATA because
+    it is called before the driver allocates memory for
+    PLATFORM_DATA
+*********************************************************/
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh);
+
+/********************************************************
+FUNCTION: Platform_DmaInitialize
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	dwDmaCh, the Dma channel to initialize
+RETURN VALUE:
+	TRUE, on Success
+	FALSE, on Failure
+********************************************************/
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh);
+
+/********************************************************
+FUNCTION: Platform_DmaDisable
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	dwDmaCh, the Dma channel to disable
+RETURN VALUE:
+	TRUE on success
+	FALSE on failure
+********************************************************/
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/*******************************************************
+FUNCTION: Platform_CacheInvalidate
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	pStartAddress, the starting virtual address of the region
+	dwLengthInBytes, the length in bytes of the region to invalidate
+DESCRIPTION:
+	Invalidates a specified memory region if it exists in cache.
+	  Does not necessarily write the data back to memory.
+*******************************************************/
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+
+/*******************************************************
+FUNCTION: Platform_CachePurge
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	pStartAddress, the starting virtual address of the region
+	dwLengthInBytes, the length in bytes of the region to purge
+DESCRIPTION:
+    Writes back data to a specified memory region if it
+      exists in cache.
+*******************************************************/
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+
+/******************************************************
+FUNCTION: Platform_RequestDmaChannel
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+DESCRIPTION:
+	If the OS supports Dma Channel allocation then this function
+	  will use that support to reserve a dma channel.
+	If the OS does not support Dma Channel allocation, or a
+	  channel can not be reserved then this function
+	  will return TRANSFER_PIO
+RETURN VALUE:
+	returns the DMA channel number that has been reserved
+	if a channel can not be reserved then return TRANSFER_PIO
+******************************************************/
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData);
+
+/*****************************************************
+FUNCTION: Platform_ReleaseDmaChannel
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	dwDmaChannel, the Dma channel number to be released
+DESCRIPTION:
+	Releases the DMA channel specified by dwDmaChannel,
+	  which was previously returned by Platform_RequestDmaChannel
+    If the OS supports it this function will notify the OS
+	  that the dma channel is free to be used by other devices
+******************************************************/
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel);
+
+/*****************************************************
+FUNCTION: Platform_DmaStartXfer
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+    pDmaXfer, pointer to DMA_XFER structure
+	    which describes the requested transfer
+DESCRIPTION:
+    Begins a new dma transfer,
+	Should not be called if another transfer is in progress
+RETURN VALUE:
+    TRUE if dma has begun the transfer
+	FALSE for any error
+******************************************************/
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer);
+
+/*******************************************************
+FUNCTION: Platform_DmaGetDwCnt
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	dwDmaCh, Dma channel number
+RETURN VALUE:
+    0, if the DMA channel is ready to handle another
+	   request from Platform_DmaStartXfer
+   non zero, is the number of DWORDS left for the
+       dma channel to transfer
+*******************************************************/
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/******************************************************
+FUNCTION: Platform_DmaComplete
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+	dwDmaCh, dma channel number
+DESCRIPTION:
+	Waits for the specified dma channel to finish
+	transfering data. Upon return the dma channel should
+	be ready to handle another request from
+	Platform_DmaStartXfer
+	This function should be the same as waiting for
+	Platform_DmaGetDwCnt to return 0
+******************************************************/
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/*****************************************************
+FUNCTION: Platform_GetFlowControlParameters
+PARAMETERS:
+	platformData, pointer to platform specific data structure
+	flowControlParameters, pointer to structure which receives
+	     the flow control parameters.
+    useDma, flag which specifies whether to get flow control
+         parameters for PIO(FALSE) or DMA(TRUE).
+DESCRIPTION:
+	fills the structure pointed to by flowControlParameters,
+	with the appropriate flow control parameters for the
+	current combination of ((118/117/112) or (116/115)),
+	(16 or 32 bit mode), and (PIO or DMA).
+******************************************************/
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma);
+
+/******************************************************
+FUNCTION: Platform_WriteFifo
+PARAMETERS:
+	DWORD dwLanBase, the lan base address
+	DWORD * pdwBuf, a pointer to and array of DWORDs to
+		be written to the TX_DATA_FIFO
+	DWORD dwDwordCount, the number of DWORDs in the dword
+		array pointed to by pdwBuf
+DESCRIPTION:
+	This function is during PIO transfers to write packet
+	data to the TX_DATA_FIFO. This function was made
+	platform dependent to allow platforms to perform
+	byte swapping on big endian systems, if necessary.
+******************************************************/
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD * pdwBuf,
+	DWORD dwDwordCount);
+
+/******************************************************
+FUNCTION: Platform_ReadFifo
+PARAMETERS:
+	DWORD dwLanBase, the lan base address
+	DWORD * pdwBuf, a pointer to and array of DWORDs which
+		will be read from the RX_DATA_FIFO
+	DWORD dwDwordCount, the number of DWORDs in the dword
+		array pointed to by pdwBuf
+DESCRIPTION:
+	This function is during PIO transfers to read packet
+	data from the RX_DATA_FIFO. This function was made
+	platform dependent to allow platforms to perform
+	byte swapping on big endian systems, if necessary.
+******************************************************/
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD * pdwBuf,
+	DWORD dwDwordCount);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/smsc9118.c linux-2.6.23.1-stm/drivers/net/smsc_911x/smsc9118.c
--- linux-2.6.23.1/drivers/net/smsc_911x/smsc9118.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/smsc9118.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,5560 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: smsc9118.c
+ *   see readme.txt for programmers guide
+ */
+
+
+#ifndef __KERNEL__
+#	define __KERNEL__
+#endif
+
+#ifdef USING_LINT
+#include "lint.h"
+#else //not USING_LINT
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/bitops.h>
+#include <linux/version.h>
+
+#endif //not USING_LINT
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#else
+#define LINUX_2_6_OR_NEWER
+#endif
+
+#ifdef USE_DEBUG
+//select debug modes
+#define USE_WARNING
+#define USE_TRACE
+#define USE_ASSERT
+#endif //USE_DEBUG
+
+#define	USE_LED1_WORK_AROUND	// 10/100 LED link-state inversion
+#define	USE_PHY_WORK_AROUND		// output polarity inversion
+
+typedef long TIME_SPAN;
+#define MAX_TIME_SPAN	((TIME_SPAN)(0x7FFFFFFFUL))
+typedef unsigned long DWORD;
+typedef unsigned short WORD;
+typedef unsigned char BYTE;
+typedef unsigned char BOOLEAN;
+#define TRUE	((BOOLEAN)1)
+#define FALSE	((BOOLEAN)0)
+
+#define HIBYTE(word)  ((BYTE)(((WORD)(word))>>8))
+#define LOBYTE(word)  ((BYTE)(((WORD)(word))&0x00FFU))
+#define HIWORD(dWord) ((WORD)(((DWORD)(dWord))>>16))
+#define LOWORD(dWord) ((WORD)(((DWORD)(dWord))&0x0000FFFFUL))
+
+#define TRANSFER_PIO			(256UL)
+#define TRANSFER_REQUEST_DMA	(255UL)
+//these are values that can be assigned to
+//PLATFORM_RX_DMA
+//PLATFORM_TX_DMA
+// in addition to any specific dma channel
+
+/*******************************************************
+* Macro: SMSC_TRACE
+* Description:
+*    This macro is used like printf.
+*    It can be used anywhere you want to display information
+*    For any release version it should not be left in
+*      performance sensitive Tx and Rx code paths.
+*    To use this macro define USE_TRACE and set bit 0 of debug_mode
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_TRACE(const char * a, ...);
+#else //not USING_LINT
+#ifdef USE_TRACE
+extern DWORD debug_mode;
+#ifndef USE_WARNING
+#define USE_WARNING
+#endif
+#	define SMSC_TRACE(msg,args...)			\
+	if(debug_mode&0x01UL) {					\
+		printk("SMSC: " msg "\n", ## args);	\
+	}
+#else
+#	define SMSC_TRACE(msg,args...)
+#endif
+#endif //not USING_LINT
+
+/*******************************************************
+* Macro: SMSC_WARNING
+* Description:
+*    This macro is used like printf.
+*    It can be used anywhere you want to display warning information
+*    For any release version it should not be left in
+*      performance sensitive Tx and Rx code paths.
+*    To use this macro define USE_TRACE or
+*      USE_WARNING and set bit 1 of debug_mode
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_WARNING(const char * a, ...);
+#else //not USING_LINT
+#ifdef USE_WARNING
+extern DWORD debug_mode;
+#ifndef USE_ASSERT
+#define USE_ASSERT
+#endif
+#	define SMSC_WARNING(msg, args...)				\
+	if(debug_mode&0x02UL) {							\
+		printk("SMSC_WARNING: " msg "\n",## args);	\
+	}
+#else
+#	define SMSC_WARNING(msg, args...)
+#endif
+#endif //not USING_LINT
+
+
+/*******************************************************
+* Macro: SMSC_ASSERT
+* Description:
+*    This macro is used to test assumptions made when coding.
+*    It can be used anywhere, but is intended only for situations
+*      where a failure is fatal.
+*    If code execution where allowed to continue it is assumed that
+*      only further unrecoverable errors would occur and so this macro
+*      includes an infinite loop to prevent further corruption.
+*    Assertions are only intended for use during developement to
+*      insure consistency of logic through out the driver.
+*    A driver should not be released if assertion failures are
+*      still occuring.
+*    To use this macro define USE_TRACE or USE_WARNING or
+*      USE_ASSERT
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_ASSERT(BOOLEAN condition);
+#else //not USING_LINT
+#ifdef USE_ASSERT
+#	define SMSC_ASSERT(condition)													\
+	if(!(condition)) {																\
+		printk("SMSC_ASSERTION_FAILURE: File=" __FILE__ ", Line=%d\n",__LINE__);	\
+		while(1);																	\
+	}
+#else
+#	define SMSC_ASSERT(condition)
+#endif
+#endif //not USING_LINT
+
+//Below are the register offsets and bit definitions
+//  of the Lan9118 memory space
+#define RX_DATA_FIFO	    (0x00UL)
+
+#define TX_DATA_FIFO        (0x20UL)
+#define		TX_CMD_A_INT_ON_COMP_		(0x80000000UL)
+#define		TX_CMD_A_INT_BUF_END_ALGN_	(0x03000000UL)
+#define		TX_CMD_A_INT_4_BYTE_ALGN_	(0x00000000UL)
+#define		TX_CMD_A_INT_16_BYTE_ALGN_	(0x01000000UL)
+#define		TX_CMD_A_INT_32_BYTE_ALGN_	(0x02000000UL)
+#define		TX_CMD_A_INT_DATA_OFFSET_	(0x001F0000UL)
+#define		TX_CMD_A_INT_FIRST_SEG_		(0x00002000UL)
+#define		TX_CMD_A_INT_LAST_SEG_		(0x00001000UL)
+#define		TX_CMD_A_BUF_SIZE_			(0x000007FFUL)
+#define		TX_CMD_B_PKT_TAG_			(0xFFFF0000UL)
+#define		TX_CMD_B_ADD_CRC_DISABLE_	(0x00002000UL)
+#define		TX_CMD_B_DISABLE_PADDING_	(0x00001000UL)
+#define		TX_CMD_B_PKT_BYTE_LENGTH_	(0x000007FFUL)
+
+#define RX_STATUS_FIFO      (0x40UL)
+#define		RX_STS_ES_			(0x00008000UL)
+#define		RX_STS_MCAST_		(0x00000400UL)
+#define RX_STATUS_FIFO_PEEK (0x44UL)
+#define TX_STATUS_FIFO		(0x48UL)
+#define TX_STATUS_FIFO_PEEK (0x4CUL)
+#define ID_REV              (0x50UL)
+#define		ID_REV_CHIP_ID_		(0xFFFF0000UL)	// RO
+#define		ID_REV_REV_ID_		(0x0000FFFFUL)	// RO
+
+#define INT_CFG				(0x54UL)
+#define		INT_CFG_INT_DEAS_	(0xFF000000UL)	// R/W
+#define		INT_CFG_IRQ_INT_	(0x00001000UL)	// RO
+#define		INT_CFG_IRQ_EN_		(0x00000100UL)	// R/W
+#define		INT_CFG_IRQ_POL_	(0x00000010UL)	// R/W Not Affected by SW Reset
+#define		INT_CFG_IRQ_TYPE_	(0x00000001UL)	// R/W Not Affected by SW Reset
+
+#define INT_STS				(0x58UL)
+#define		INT_STS_SW_INT_		(0x80000000UL)	// R/WC
+#define		INT_STS_TXSTOP_INT_	(0x02000000UL)	// R/WC
+#define		INT_STS_RXSTOP_INT_	(0x01000000UL)	// R/WC
+#define		INT_STS_RXDFH_INT_	(0x00800000UL)	// R/WC
+#define		INT_STS_RXDF_INT_	(0x00400000UL)	// R/WC
+#define		INT_STS_TX_IOC_		(0x00200000UL)	// R/WC
+#define		INT_STS_RXD_INT_	(0x00100000UL)	// R/WC
+#define		INT_STS_GPT_INT_	(0x00080000UL)	// R/WC
+#define		INT_STS_PHY_INT_	(0x00040000UL)	// RO
+#define		INT_STS_PME_INT_	(0x00020000UL)	// R/WC
+#define		INT_STS_TXSO_		(0x00010000UL)	// R/WC
+#define		INT_STS_RWT_		(0x00008000UL)	// R/WC
+#define		INT_STS_RXE_		(0x00004000UL)	// R/WC
+#define		INT_STS_TXE_		(0x00002000UL)	// R/WC
+#define		INT_STS_ERX_		(0x00001000UL)	// R/WC
+#define		INT_STS_TDFU_		(0x00000800UL)	// R/WC
+#define		INT_STS_TDFO_		(0x00000400UL)	// R/WC
+#define		INT_STS_TDFA_		(0x00000200UL)	// R/WC
+#define		INT_STS_TSFF_		(0x00000100UL)	// R/WC
+#define		INT_STS_TSFL_		(0x00000080UL)	// R/WC
+#define		INT_STS_RDFO_		(0x00000040UL)	// R/WC
+#define		INT_STS_RDFL_		(0x00000020UL)	// R/WC
+#define		INT_STS_RSFF_		(0x00000010UL)	// R/WC
+#define		INT_STS_RSFL_		(0x00000008UL)	// R/WC
+#define		INT_STS_GPIO2_INT_	(0x00000004UL)	// R/WC
+#define		INT_STS_GPIO1_INT_	(0x00000002UL)	// R/WC
+#define		INT_STS_GPIO0_INT_	(0x00000001UL)	// R/WC
+
+#define INT_EN				(0x5CUL)
+#define		INT_EN_SW_INT_EN_		(0x80000000UL)	// R/W
+#define		INT_EN_TXSTOP_INT_EN_	(0x02000000UL)	// R/W
+#define		INT_EN_RXSTOP_INT_EN_	(0x01000000UL)	// R/W
+#define		INT_EN_RXDFH_INT_EN_	(0x00800000UL)	// R/W
+#define		INT_EN_RXDF_INT_EN_		(0x00400000UL)	// R/W
+#define		INT_EN_TIOC_INT_EN_		(0x00200000UL)	// R/W
+#define		INT_EN_RXD_INT_EN_		(0x00100000UL)	// R/W
+#define		INT_EN_GPT_INT_EN_		(0x00080000UL)	// R/W
+#define		INT_EN_PHY_INT_EN_		(0x00040000UL)	// R/W
+#define		INT_EN_PME_INT_EN_		(0x00020000UL)	// R/W
+#define		INT_EN_TXSO_EN_			(0x00010000UL)	// R/W
+#define		INT_EN_RWT_EN_			(0x00008000UL)	// R/W
+#define		INT_EN_RXE_EN_			(0x00004000UL)	// R/W
+#define		INT_EN_TXE_EN_			(0x00002000UL)	// R/W
+#define		INT_EN_ERX_EN_			(0x00001000UL)	// R/W
+#define		INT_EN_TDFU_EN_			(0x00000800UL)	// R/W
+#define		INT_EN_TDFO_EN_			(0x00000400UL)	// R/W
+#define		INT_EN_TDFA_EN_			(0x00000200UL)	// R/W
+#define		INT_EN_TSFF_EN_			(0x00000100UL)	// R/W
+#define		INT_EN_TSFL_EN_			(0x00000080UL)	// R/W
+#define		INT_EN_RDFO_EN_			(0x00000040UL)	// R/W
+#define		INT_EN_RDFL_EN_			(0x00000020UL)	// R/W
+#define		INT_EN_RSFF_EN_			(0x00000010UL)	// R/W
+#define		INT_EN_RSFL_EN_			(0x00000008UL)	// R/W
+#define		INT_EN_GPIO2_INT_		(0x00000004UL)	// R/W
+#define		INT_EN_GPIO1_INT_		(0x00000002UL)	// R/W
+#define		INT_EN_GPIO0_INT_		(0x00000001UL)	// R/W
+
+#define BYTE_TEST				(0x64UL)
+#define FIFO_INT				(0x68UL)
+#define		FIFO_INT_TX_AVAIL_LEVEL_	(0xFF000000UL)	// R/W
+#define		FIFO_INT_TX_STS_LEVEL_		(0x00FF0000UL)	// R/W
+#define		FIFO_INT_RX_AVAIL_LEVEL_	(0x0000FF00UL)	// R/W
+#define		FIFO_INT_RX_STS_LEVEL_		(0x000000FFUL)	// R/W
+
+#define RX_CFG					(0x6CUL)
+#define		RX_CFG_RX_END_ALGN_		(0xC0000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN4_		(0x00000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN16_		(0x40000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN32_		(0x80000000UL)	// R/W
+#define		RX_CFG_RX_DMA_CNT_		(0x0FFF0000UL)	// R/W
+#define		RX_CFG_RX_DUMP_			(0x00008000UL)	// R/W
+#define		RX_CFG_RXDOFF_			(0x00001F00UL)	// R/W
+#define		RX_CFG_RXBAD_			(0x00000001UL)	// R/W
+
+#define TX_CFG					(0x70UL)
+#define		TX_CFG_TX_DMA_LVL_		(0xE0000000UL)	// R/W
+#define		TX_CFG_TX_DMA_CNT_		(0x0FFF0000UL)	// R/W Self Clearing
+#define		TX_CFG_TXS_DUMP_		(0x00008000UL)	// Self Clearing
+#define		TX_CFG_TXD_DUMP_		(0x00004000UL)	// Self Clearing
+#define		TX_CFG_TXSAO_			(0x00000004UL)	// R/W
+#define		TX_CFG_TX_ON_			(0x00000002UL)	// R/W
+#define		TX_CFG_STOP_TX_			(0x00000001UL)	// Self Clearing
+
+#define HW_CFG					(0x74UL)
+#define		HW_CFG_TTM_				(0x00200000UL)	// R/W
+#define		HW_CFG_SF_				(0x00100000UL)	// R/W
+#define		HW_CFG_TX_FIF_SZ_		(0x000F0000UL)	// R/W
+#define		HW_CFG_TR_				(0x00003000UL)	// R/W
+#define     HW_CFG_PHY_CLK_SEL_		(0x00000060UL)  // R/W
+#define         HW_CFG_PHY_CLK_SEL_INT_PHY_	(0x00000000UL) // R/W
+#define         HW_CFG_PHY_CLK_SEL_EXT_PHY_	(0x00000020UL) // R/W
+#define         HW_CFG_PHY_CLK_SEL_CLK_DIS_ (0x00000040UL) // R/W
+#define     HW_CFG_SMI_SEL_			(0x00000010UL)  // R/W
+#define     HW_CFG_EXT_PHY_DET_		(0x00000008UL)  // RO
+#define     HW_CFG_EXT_PHY_EN_		(0x00000004UL)  // R/W
+#define		HW_CFG_32_16_BIT_MODE_	(0x00000004UL)	// RO
+#define     HW_CFG_SRST_TO_			(0x00000002UL)  // RO
+#define		HW_CFG_SRST_			(0x00000001UL)	// Self Clearing
+
+#define RX_DP_CTRL				(0x78UL)
+#define		RX_DP_CTRL_RX_FFWD_		(0x00000FFFUL)	// R/W
+#define		RX_DP_CTRL_FFWD_BUSY_	(0x80000000UL)	// RO
+
+#define RX_FIFO_INF				(0x7CUL)
+#define		RX_FIFO_INF_RXSUSED_	(0x00FF0000UL)	// RO
+#define		RX_FIFO_INF_RXDUSED_	(0x0000FFFFUL)	// RO
+
+#define TX_FIFO_INF				(0x80UL)
+#define		TX_FIFO_INF_TSUSED_		(0x00FF0000UL)  // RO
+#define		TX_FIFO_INF_TSFREE_		(0x00FF0000UL)	// RO
+#define		TX_FIFO_INF_TDFREE_		(0x0000FFFFUL)	// RO
+
+#define PMT_CTRL				(0x84UL)
+#define		PMT_CTRL_PM_MODE_			(0x00018000UL)	// Self Clearing
+#define		PMT_CTRL_PHY_RST_			(0x00000400UL)	// Self Clearing
+#define		PMT_CTRL_WOL_EN_			(0x00000200UL)	// R/W
+#define		PMT_CTRL_ED_EN_				(0x00000100UL)	// R/W
+#define		PMT_CTRL_PME_TYPE_			(0x00000040UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_WUPS_				(0x00000030UL)	// R/WC
+#define			PMT_CTRL_WUPS_NOWAKE_		(0x00000000UL)	// R/WC
+#define			PMT_CTRL_WUPS_ED_			(0x00000010UL)	// R/WC
+#define			PMT_CTRL_WUPS_WOL_			(0x00000020UL)	// R/WC
+#define			PMT_CTRL_WUPS_MULTI_		(0x00000030UL)	// R/WC
+#define		PMT_CTRL_PME_IND_		(0x00000008UL)	// R/W
+#define		PMT_CTRL_PME_POL_		(0x00000004UL)	// R/W
+#define		PMT_CTRL_PME_EN_		(0x00000002UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_READY_			(0x00000001UL)	// RO
+
+#define GPIO_CFG				(0x88UL)
+#define		GPIO_CFG_LED3_EN_		(0x40000000UL)	// R/W
+#define		GPIO_CFG_LED2_EN_		(0x20000000UL)	// R/W
+#define		GPIO_CFG_LED1_EN_		(0x10000000UL)	// R/W
+#define		GPIO_CFG_GPIO2_INT_POL_	(0x04000000UL)	// R/W
+#define		GPIO_CFG_GPIO1_INT_POL_	(0x02000000UL)	// R/W
+#define		GPIO_CFG_GPIO0_INT_POL_	(0x01000000UL)	// R/W
+#define		GPIO_CFG_EEPR_EN_		(0x00E00000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF2_		(0x00040000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF1_		(0x00020000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF0_		(0x00010000UL)	// R/W
+#define		GPIO_CFG_GPIODIR2_		(0x00000400UL)	// R/W
+#define		GPIO_CFG_GPIODIR1_		(0x00000200UL)	// R/W
+#define		GPIO_CFG_GPIODIR0_		(0x00000100UL)	// R/W
+#define		GPIO_CFG_GPIOD4_		(0x00000020UL)	// R/W
+#define		GPIO_CFG_GPIOD3_		(0x00000010UL)	// R/W
+#define		GPIO_CFG_GPIOD2_		(0x00000004UL)	// R/W
+#define		GPIO_CFG_GPIOD1_		(0x00000002UL)	// R/W
+#define		GPIO_CFG_GPIOD0_		(0x00000001UL)	// R/W
+
+#define GPT_CFG					(0x8CUL)
+#define		GPT_CFG_TIMER_EN_		(0x20000000UL)	// R/W
+#define		GPT_CFG_GPT_LOAD_		(0x0000FFFFUL)	// R/W
+
+#define GPT_CNT					(0x90UL)
+#define		GPT_CNT_GPT_CNT_		(0x0000FFFFUL)	// RO
+
+#define FPGA_REV				(0x94UL)
+#define		FPGA_REV_FPGA_REV_		(0x0000FFFFUL)	// RO
+
+#define ENDIAN					(0x98UL)
+#define FREE_RUN				(0x9CUL)
+#define RX_DROP					(0xA0UL)
+#define MAC_CSR_CMD				(0xA4UL)
+#define		MAC_CSR_CMD_CSR_BUSY_	(0x80000000UL)	// Self Clearing
+#define		MAC_CSR_CMD_R_NOT_W_	(0x40000000UL)	// R/W
+#define		MAC_CSR_CMD_CSR_ADDR_	(0x000000FFUL)	// R/W
+
+#define MAC_CSR_DATA			(0xA8UL)
+#define AFC_CFG					(0xACUL)
+#define		AFC_CFG_AFC_HI_			(0x00FF0000UL)	// R/W
+#define		AFC_CFG_AFC_LO_			(0x0000FF00UL)	// R/W
+#define		AFC_CFG_BACK_DUR_		(0x000000F0UL)	// R/W
+#define		AFC_CFG_FCMULT_			(0x00000008UL)	// R/W
+#define		AFC_CFG_FCBRD_			(0x00000004UL)	// R/W
+#define		AFC_CFG_FCADD_			(0x00000002UL)	// R/W
+#define		AFC_CFG_FCANY_			(0x00000001UL)	// R/W
+
+#define E2P_CMD					(0xB0UL)
+#define		E2P_CMD_EPC_BUSY_		(0x80000000UL)	// Self Clearing
+#define		E2P_CMD_EPC_CMD_		(0x70000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_READ_	(0x00000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWDS_	(0x10000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWEN_	(0x20000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRITE_	(0x30000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRAL_	(0x40000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERASE_	(0x50000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERAL_	(0x60000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_RELOAD_	(0x70000000UL)  // R/W
+#define		E2P_CMD_EPC_TIMEOUT_	(0x00000200UL)	// R
+#define		E2P_CMD_MAC_ADDR_LOADED_	(0x00000100UL)	// RO
+#define		E2P_CMD_EPC_ADDR_		(0x000000FFUL)	// R/W
+
+#define E2P_DATA				(0xB4UL)
+#define		E2P_DATA_EEPROM_DATA_	(0x000000FFUL)	// R/W
+//end of lan register offsets and bit definitions
+
+#define LAN_REGISTER_EXTENT		(0x00002000UL)
+
+//The following describes the synchronization policies used in this driver.
+//Register Name				Policy
+//RX_DATA_FIFO				Only used by the Rx Thread, Rx_ProcessPackets
+//TX_DATA_FIFO				Only used by the Tx Thread, Tx_SendSkb
+//RX_STATUS_FIFO			Only used by the Rx Thread, Rx_ProcessPackets
+//RX_STATUS_FIFO_PEEK		Not used.
+//TX_STATUS_FIFO			Used in	Tx_CompleteTx in Tx_UpdateTxCounters.
+//							protected by TxCounterLock
+//TX_STATUS_FIFO_PEEK		Not used.
+//ID_REV					Read only
+//INT_CFG					Set in Lan_Initialize,
+//							protected by IntEnableLock
+//INT_STS					Sharable,
+//INT_EN					Initialized at startup,
+//							Used in Rx_ProcessPackets
+//							otherwise protected by IntEnableLock
+//BYTE_TEST					Read Only
+//FIFO_INT					Initialized at startup,
+//                          During run time only accessed by
+//                              Tx_HandleInterrupt, and Tx_SendSkb and done in a safe manner
+//RX_CFG					Used during initialization
+//                          During runtime only used by Rx Thread
+//TX_CFG					Only used during initialization
+//HW_CFG					Only used during initialization
+//RX_DP_CTRL				Only used in Rx Thread, in Rx_FastForward
+//RX_FIFO_INF				Read Only, Only used in Rx Thread, in Rx_PopRxStatus
+//TX_FIFO_INF				Read Only, Only used in Tx Thread, in Tx_GetTxStatusCount, Tx_SendSkb, Tx_CompleteTx
+//PMT_CTRL					Not Used
+//GPIO_CFG					used during initialization, in Lan_Initialize
+//                          used for debugging
+//                          used during EEPROM access.
+//                          safe enough to not require a lock
+//GPT_CFG					protected by GpTimerLock
+//GPT_CNT					Not Used
+//ENDIAN					Not Used
+//FREE_RUN					Read only
+//RX_DROP					Used in Rx Interrupt Handler,
+//                          and get_stats.
+//                          safe enough to not require a lock.
+//MAC_CSR_CMD				Protected by MacPhyLock
+//MAC_CSR_DATA				Protected by MacPhyLock
+//                          Because the two previous MAC_CSR_ registers are protected
+//                            All MAC, and PHY registers are protected as well.
+//AFC_CFG					Used during initialization, in Lan_Initialize
+//                          During run time, used in timer call back, in Phy_UpdateLinkMode
+//E2P_CMD					Used during initialization, in Lan_Initialize
+//                          Used in EEPROM functions
+//E2P_DATA					Used in EEPROM functions
+
+//DMA Transfer structure
+typedef struct _DMA_XFER
+{
+	DWORD dwLanReg;
+	DWORD *pdwBuf;
+	DWORD dwDmaCh;
+	DWORD dwDwCnt;
+	BOOLEAN fMemWr;
+} DMA_XFER;
+
+typedef struct _FLOW_CONTROL_PARAMETERS
+{
+	DWORD MaxThroughput;
+	DWORD MaxPacketCount;
+	DWORD PacketCost;
+	DWORD BurstPeriod;
+	DWORD IntDeas;
+} FLOW_CONTROL_PARAMETERS, *PFLOW_CONTROL_PARAMETERS;
+
+#include PLATFORM_SOURCE
+//PLATFORM_SOURCE is defined from the command line
+//  with the -D option
+//  example: -D"PLATFORM_SOURCE=\"platform.c\""
+
+#define Lan_GetRegDW(dwOffset)	\
+	Platform_GetRegDW(privateData->dwLanBase,dwOffset)
+
+#define Lan_SetRegDW(dwOffset,dwVal) \
+	Platform_SetRegDW(privateData->dwLanBase,dwOffset,dwVal)
+
+#define Lan_ClrBitsDW(dwOffset,dwBits)						\
+	Platform_SetRegDW(privateData->dwLanBase,				\
+		dwOffset,Platform_GetRegDW(privateData->dwLanBase,	\
+		dwOffset)&(~dwBits))
+
+#define Lan_SetBitsDW(dwOffset,dwBits)						\
+	Platform_SetRegDW(privateData->dwLanBase,				\
+		dwOffset,Platform_GetRegDW(privateData->dwLanBase,	\
+		dwOffset)|dwBits);
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+#define MAX_RX_SKBS 10
+
+typedef unsigned long VL_KEY;
+typedef struct _VERIFIABLE_LOCK {
+	spinlock_t Lock;
+	VL_KEY KeyCode;
+} VERIFIABLE_LOCK, * PVERIFIABLE_LOCK;
+
+void Vl_InitLock(PVERIFIABLE_LOCK pVl);
+BOOLEAN Vl_CheckLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode);
+VL_KEY Vl_WaitForLock(PVERIFIABLE_LOCK pVl,DWORD *pdwIntFlags);
+void Vl_ReleaseLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode,DWORD *pdwIntFlags);
+
+typedef struct _PRIVATE_DATA {
+	DWORD dwLanBase;
+	DWORD dwIdRev;
+	DWORD dwFpgaRev;
+	struct net_device *dev;
+	DWORD dwGeneration;//used to decide which workarounds apply
+
+	spinlock_t IntEnableLock;
+	BOOLEAN LanInitialized;
+	VERIFIABLE_LOCK MacPhyLock;
+
+	DWORD dwTxDmaCh;
+	BOOLEAN TxDmaChReserved;
+	DMA_XFER TxDmaXfer;
+	DWORD dwTxDmaThreshold;
+	DWORD dwTxQueueDisableMask;
+	struct sk_buff *TxSkb;
+	spinlock_t TxSkbLock;
+	spinlock_t TxQueueLock;
+	spinlock_t TxCounterLock;
+	BOOLEAN TxInitialized;
+
+	DWORD dwRxDmaCh;
+	struct sk_buff *RxSkbs[MAX_RX_SKBS];
+	struct scatterlist RxSgs[MAX_RX_SKBS];
+	DWORD RxSkbsCount;
+	DWORD RxSkbsMax;
+	DWORD RxDropOnCallback;
+	BOOLEAN RxDmaChReserved;
+	DWORD dwRxDmaThreshold;
+	BOOLEAN RxCongested;
+	DWORD dwRxOffCount;
+	BOOLEAN RxOverrun;
+	DWORD RxOverrunCount;
+	DWORD RxStatusDWReadCount;
+	DWORD RxDataDWReadCount;
+	DWORD RxPacketReadCount;
+	DWORD RxFastForwardCount;
+	DWORD RxPioReadCount;
+	DWORD RxDmaReadCount;
+	DWORD RxCongestedCount;
+	DWORD RxDumpCount;
+	DWORD LastReasonForReleasingCPU;
+	DWORD LastRxStatus1;
+	DWORD LastRxStatus2;
+	DWORD LastRxStatus3;
+	DWORD LastIntStatus1;
+	DWORD LastIntStatus2;
+	DWORD LastIntStatus3;
+	DWORD RxUnloadProgress;
+	DWORD RxUnloadPacketProgress;
+	DWORD RxMaxDataFifoSize;
+
+	DWORD RxFlowCurrentThroughput;
+	DWORD RxFlowCurrentPacketCount;
+	DWORD RxFlowCurrentWorkLoad;
+	BOOLEAN MeasuringRxThroughput;
+	DWORD RxFlowMeasuredMaxThroughput;
+	DWORD RxFlowMeasuredMaxPacketCount;
+
+//RX_FLOW_ACTIVATION specifies the percentage that RxFlowCurrentWorkLoad must exceed
+//     RxFlowMaxWorkLoad in order to activate flow control
+#define RX_FLOW_ACTIVATION	(4UL)
+
+//RX_FLOW_DEACTIVATION specifies the percentage that RxFlowCurrentWorkLoad must reduce
+//     from RxFlowMaxWorkLoad in order to deactivate flow control
+#define RX_FLOW_DEACTIVATION (25UL)
+	DWORD RxFlowMaxWorkLoad;
+
+	FLOW_CONTROL_PARAMETERS RxFlowParameters;
+
+	DWORD RxFlowBurstWorkLoad;
+	DWORD RxFlowBurstMaxWorkLoad;
+	BOOLEAN RxFlowControlActive;
+	BOOLEAN RxFlowBurstActive;
+	DWORD RxInterrupts;
+
+#define GPT_SCHEDULE_DEPTH	(3)
+	void *GptFunction[GPT_SCHEDULE_DEPTH];
+	DWORD GptCallTime[GPT_SCHEDULE_DEPTH];
+	DWORD Gpt_scheduled_slot_index;
+	spinlock_t GpTimerLock;
+
+	BOOLEAN Running;
+	struct net_device_stats stats;
+
+	DWORD dwPhyAddress;
+	DWORD dwPhyId;
+#ifdef USE_LED1_WORK_AROUND
+	DWORD NotUsingExtPhy;
+#endif
+	BYTE bPhyModel;
+	BYTE bPhyRev;
+	DWORD dwLinkSpeed;
+	DWORD dwLinkSettings;
+	DWORD dwRemoteFaultCount;
+	struct timer_list LinkPollingTimer;
+	BOOLEAN StopLinkPolling;
+	WORD wLastADV;
+	WORD wLastADVatRestart;
+#ifdef USE_PHY_WORK_AROUND
+#define MIN_PACKET_SIZE (64)
+	DWORD dwTxStartMargen;
+	BYTE LoopBackTxPacket[MIN_PACKET_SIZE];
+	DWORD dwTxEndMargen;
+	DWORD dwRxStartMargen;
+	BYTE LoopBackRxPacket[MIN_PACKET_SIZE];
+	DWORD dwRxEndMargen;
+	DWORD dwResetCount;
+#endif
+
+	BOOLEAN SoftwareInterruptSignal;
+
+	PLATFORM_DATA PlatformData;
+
+#define SMSC_IF_NAME_SIZE	(10)
+	char ifName[SMSC_IF_NAME_SIZE];
+
+	/* for Rx Multicast work around */
+	volatile DWORD HashLo;
+	volatile DWORD HashHi;
+	volatile BOOLEAN MulticastUpdatePending;
+	volatile DWORD set_bits_mask;
+	volatile DWORD clear_bits_mask;
+
+} PRIVATE_DATA, *PPRIVATE_DATA;
+
+
+/*
+ ****************************************************************************
+ ****************************************************************************
+ *	MAC Control and Status Register (Indirect Address)
+ *	Offset (through the MAC_CSR CMD and DATA port)
+ ****************************************************************************
+ ****************************************************************************
+ *
+ */
+#define MAC_CR				(0x01UL)	// R/W
+
+	/* MAC_CR - MAC Control Register */
+	#define MAC_CR_RXALL_		(0x80000000UL)
+	#define MAC_CR_HBDIS_		(0x10000000UL)
+	#define MAC_CR_RCVOWN_		(0x00800000UL)
+	#define MAC_CR_LOOPBK_		(0x00200000UL)
+	#define MAC_CR_FDPX_		(0x00100000UL)
+	#define MAC_CR_MCPAS_		(0x00080000UL)
+	#define MAC_CR_PRMS_		(0x00040000UL)
+	#define MAC_CR_INVFILT_		(0x00020000UL)
+	#define MAC_CR_PASSBAD_		(0x00010000UL)
+	#define MAC_CR_HFILT_		(0x00008000UL)
+	#define MAC_CR_HPFILT_		(0x00002000UL)
+	#define MAC_CR_LCOLL_		(0x00001000UL)
+	#define MAC_CR_BCAST_		(0x00000800UL)
+	#define MAC_CR_DISRTY_		(0x00000400UL)
+	#define MAC_CR_PADSTR_		(0x00000100UL)
+	#define MAC_CR_BOLMT_MASK_	(0x000000C0UL)
+	#define MAC_CR_DFCHK_		(0x00000020UL)
+	#define MAC_CR_TXEN_		(0x00000008UL)
+	#define MAC_CR_RXEN_		(0x00000004UL)
+
+#define ADDRH				(0x02UL)	// R/W mask 0x0000FFFFUL
+#define ADDRL				(0x03UL)	// R/W mask 0xFFFFFFFFUL
+#define HASHH				(0x04UL)	// R/W
+#define HASHL				(0x05UL)	// R/W
+
+#define MII_ACC				(0x06UL)	// R/W
+	#define MII_ACC_PHY_ADDR_	(0x0000F800UL)
+	#define MII_ACC_MIIRINDA_	(0x000007C0UL)
+	#define MII_ACC_MII_WRITE_	(0x00000002UL)
+	#define MII_ACC_MII_BUSY_	(0x00000001UL)
+
+#define MII_DATA			(0x07UL)	// R/W mask 0x0000FFFFUL
+
+#define FLOW				(0x08UL)	// R/W
+	#define FLOW_FCPT_			(0xFFFF0000UL)
+	#define FLOW_FCPASS_		(0x00000004UL)
+	#define FLOW_FCEN_			(0x00000002UL)
+	#define FLOW_FCBSY_			(0x00000001UL)
+
+#define VLAN1				(0x09UL)	// R/W mask 0x0000FFFFUL
+#define VLAN2				(0x0AUL)	// R/W mask 0x0000FFFFUL
+
+#define WUFF				(0x0BUL)	// WO
+
+#define WUCSR				(0x0CUL)	// R/W
+	#define WUCSR_GUE_			(0x00000200UL)
+	#define WUCSR_WUFR_			(0x00000040UL)
+	#define WUCSR_MPR_			(0x00000020UL)
+	#define WUCSR_WAKE_EN_		(0x00000004UL)
+	#define WUCSR_MPEN_			(0x00000002UL)
+
+BOOLEAN Mac_Initialize(PPRIVATE_DATA privateData);
+static BOOLEAN MacNotBusy(PPRIVATE_DATA privateData,VL_KEY keyCode);
+DWORD Mac_GetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,VL_KEY keyCode);
+void Mac_SetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,DWORD dwVal,VL_KEY keyCode);
+
+/*
+ ****************************************************************************
+ *	Chip Specific MII Defines
+ ****************************************************************************
+ *
+ *	Phy register offsets and bit definitions
+ *
+ */
+#define LAN9118_PHY_ID	(0x00C0001C)
+
+#define PHY_BCR		((DWORD)0U)
+#define PHY_BCR_RESET_					((WORD)0x8000U)
+#define PHY_BCR_LOOPBACK_			((WORD)0x4000U)
+#define PHY_BCR_SPEED_SELECT_		((WORD)0x2000U)
+#define PHY_BCR_AUTO_NEG_ENABLE_	((WORD)0x1000U)
+#define PHY_BCR_RESTART_AUTO_NEG_	((WORD)0x0200U)
+#define PHY_BCR_DUPLEX_MODE_		((WORD)0x0100U)
+
+#define PHY_BSR		((DWORD)1U)
+	#define PHY_BSR_LINK_STATUS_	((WORD)0x0004U)
+	#define PHY_BSR_REMOTE_FAULT_	((WORD)0x0010U)
+	#define PHY_BSR_AUTO_NEG_COMP_	((WORD)0x0020U)
+
+#define PHY_ID_1	((DWORD)2U)
+#define PHY_ID_2	((DWORD)3U)
+
+#define PHY_ANEG_ADV    ((DWORD)4U)
+#define PHY_ANEG_ADV_PAUSE_ ((WORD)0x0C00)
+#define PHY_ANEG_ADV_ASYMP_	((WORD)0x0800)
+#define PHY_ANEG_ADV_SYMP_	((WORD)0x0400)
+#define PHY_ANEG_ADV_10H_	((WORD)0x20)
+#define PHY_ANEG_ADV_10F_	((WORD)0x40)
+#define PHY_ANEG_ADV_100H_	((WORD)0x80)
+#define PHY_ANEG_ADV_100F_	((WORD)0x100)
+#define PHY_ANEG_ADV_SPEED_	((WORD)0x1E0)
+
+#define PHY_ANEG_LPA	((DWORD)5U)
+#define PHY_ANEG_LPA_ASYMP_		((WORD)0x0800)
+#define PHY_ANEG_LPA_SYMP_		((WORD)0x0400)
+#define PHY_ANEG_LPA_100FDX_	((WORD)0x0100)
+#define PHY_ANEG_LPA_100HDX_	((WORD)0x0080)
+#define PHY_ANEG_LPA_10FDX_		((WORD)0x0040)
+#define PHY_ANEG_LPA_10HDX_		((WORD)0x0020)
+
+#define PHY_MODE_CTRL_STS		((DWORD)17)	// Mode Control/Status Register
+	#define MODE_CTRL_STS_FASTRIP_		((WORD)0x4000U)
+	#define MODE_CTRL_STS_EDPWRDOWN_	((WORD)0x2000U)
+	#define MODE_CTRL_STS_LOWSQEN_		((WORD)0x0800U)
+	#define MODE_CTRL_STS_MDPREBP_		((WORD)0x0400U)
+	#define MODE_CTRL_STS_FARLOOPBACK_	((WORD)0x0200U)
+	#define MODE_CTRL_STS_FASTEST_		((WORD)0x0100U)
+	#define MODE_CTRL_STS_REFCLKEN_		((WORD)0x0010U)
+	#define MODE_CTRL_STS_PHYADBP_		((WORD)0x0008U)
+	#define MODE_CTRL_STS_FORCE_G_LINK_	((WORD)0x0004U)
+	#define MODE_CTRL_STS_ENERGYON_		((WORD)0x0002U)
+
+#define PHY_INT_SRC			((DWORD)29)
+#define PHY_INT_SRC_ENERGY_ON_			((WORD)0x0080U)
+#define PHY_INT_SRC_ANEG_COMP_			((WORD)0x0040U)
+#define PHY_INT_SRC_REMOTE_FAULT_		((WORD)0x0020U)
+#define PHY_INT_SRC_LINK_DOWN_			((WORD)0x0010U)
+
+#define PHY_INT_MASK		((DWORD)30)
+#define PHY_INT_MASK_ENERGY_ON_		((WORD)0x0080U)
+#define PHY_INT_MASK_ANEG_COMP_		((WORD)0x0040U)
+#define PHY_INT_MASK_REMOTE_FAULT_	((WORD)0x0020U)
+#define PHY_INT_MASK_LINK_DOWN_		((WORD)0x0010U)
+
+#define PHY_SPECIAL			((DWORD)31)
+#define PHY_SPECIAL_SPD_	((WORD)0x001CU)
+#define PHY_SPECIAL_SPD_10HALF_		((WORD)0x0004U)
+#define PHY_SPECIAL_SPD_10FULL_		((WORD)0x0014U)
+#define PHY_SPECIAL_SPD_100HALF_	((WORD)0x0008U)
+#define PHY_SPECIAL_SPD_100FULL_	((WORD)0x0018U)
+
+BOOLEAN Phy_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwPhyAddress,
+	DWORD dwLinkMode);
+void Phy_SetLink(PPRIVATE_DATA privateData,
+				 DWORD dwLinkRequest);
+WORD Phy_GetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	VL_KEY keyCode);
+void Phy_SetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	WORD wVal,
+	VL_KEY keyCode);
+void Phy_UpdateLinkMode(
+	PPRIVATE_DATA privateData);
+void Phy_GetLinkMode(
+	PPRIVATE_DATA privateData,
+	VL_KEY keyCode);
+void Phy_CheckLink(unsigned long ptr);
+
+TIME_SPAN Gpt_FreeRunCompare(DWORD time1,DWORD time2);
+void Gpt_ScheduleInterrupt(PPRIVATE_DATA privateData,TIME_SPAN timeSpan);
+void Gpt_CancelInterrupt(PPRIVATE_DATA privateData);
+void Gpt_CancelCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData));
+void Gpt_ScheduleCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData),
+	DWORD callBackTime);//100uS units relative to now
+BOOLEAN Gpt_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts);
+void GptCB_RxCompleteMulticast(PPRIVATE_DATA privateData);
+void GptCB_RestartBurst(PPRIVATE_DATA privateData);
+void GptCB_MeasureRxThroughput(PPRIVATE_DATA privateData);
+
+void Tx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwTxDmaCh,
+	DWORD dwTxDmaThreshold);
+void Tx_SendSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb);
+BOOLEAN Tx_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts);
+
+void Tx_StopQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource);
+void Tx_WakeQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource);
+
+static DWORD Tx_GetTxStatusCount(
+	PPRIVATE_DATA privateData);
+static void Tx_DmaCompletionCallback(void* param);
+static DWORD Tx_CompleteTx(
+	PPRIVATE_DATA privateData);
+void Tx_UpdateTxCounters(
+	PPRIVATE_DATA privateData);
+
+void Tx_CompleteDma(
+	PPRIVATE_DATA privateData);
+
+void Rx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwRxDmaCh,
+	DWORD dwDmaThreshold);
+
+void Rx_CompleteMulticastUpdate (PPRIVATE_DATA privateData);
+static void Rx_HandleOverrun(PPRIVATE_DATA privateData);
+static void Rx_HandOffSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb);
+static DWORD Rx_PopRxStatus(
+	PPRIVATE_DATA privateData);
+void Rx_CountErrors(PPRIVATE_DATA privateData,DWORD dwRxStatus);
+void Rx_FastForward(PPRIVATE_DATA privateData,DWORD dwDwordCount);
+void Rx_ProcessPackets(PPRIVATE_DATA privateData);
+void Rx_BeginMulticastUpdate (PPRIVATE_DATA privateData);
+
+unsigned long Rx_TaskletParameter=0;
+
+void Rx_ProcessPacketsTasklet(unsigned long data);
+DECLARE_TASKLET(Rx_Tasklet,Rx_ProcessPacketsTasklet,0);
+
+static void Rx_DmaCompletionCallback(void* param);
+
+BOOLEAN RxStop_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts);
+BOOLEAN Rx_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts);
+static DWORD Rx_Hash(BYTE addr[6]);
+
+void Rx_SetMulticastList(
+	struct net_device *dev);
+void Rx_ReceiverOff(
+	PPRIVATE_DATA privateData);
+void Rx_ReceiverOn(
+	PPRIVATE_DATA privateData, VL_KEY callerKeyCode);
+
+
+void Eeprom_EnableAccess(PPRIVATE_DATA privateData);
+void Eeprom_DisableAccess(PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_IsMacAddressLoaded(PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_IsBusy(PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_Timeout(PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_ReadLocation(
+	PPRIVATE_DATA privateData,BYTE address, BYTE * data);
+BOOLEAN Eeprom_EnableEraseAndWrite(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_DisableEraseAndWrite(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_WriteLocation(
+	PPRIVATE_DATA privateData,BYTE address,BYTE data);
+BOOLEAN Eeprom_EraseAll(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_Reload(
+	PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_SaveMacAddress(
+	PPRIVATE_DATA privateData,
+	DWORD dwHi16,DWORD dwLo32);
+
+
+#define OLD_REGISTERS(privData) (((privData->dwIdRev)==0x01180000UL)&& \
+								 ((privData->dwFpgaRev)>=0x01)&& \
+								 ((privData->dwFpgaRev)<=0x25))
+
+extern volatile DWORD g_GpioSetting;
+extern DWORD debug_mode;
+#define GP_0	(0x01UL)
+#define GP_1	(0x02UL)
+#define GP_2	(0x04UL)
+#define GP_3	(0x08UL)
+#define GP_4	(0x10UL)
+#define GP_OFF  (0x00UL)
+#define GP_ISR	GP_OFF
+#define GP_RX	GP_OFF
+#define GP_TX	GP_OFF
+#define GP_BEGIN_MULTICAST_UPDATE		GP_OFF
+#define GP_COMPLETE_MULTICAST_UPDATE	GP_OFF
+
+#define SET_GPIO(gpioBit)					\
+if(debug_mode&0x04UL) {						\
+	g_GpioSetting|=gpioBit;					\
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);	\
+}
+
+#define CLEAR_GPIO(gpioBit)					\
+if(debug_mode&0x04UL) {						\
+	g_GpioSetting&=(~gpioBit);				\
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);	\
+}
+
+#define PULSE_GPIO(gpioBit,count)	\
+if(debug_mode&0x04UL) {				\
+	DWORD pulseNum=0;				\
+	/*make first pulse longer */	\
+	SET_GPIO(gpioBit);				\
+	while(pulseNum<count) {			\
+		SET_GPIO(gpioBit);			\
+		CLEAR_GPIO(gpioBit);		\
+		pulseNum++;					\
+	}								\
+}
+#ifdef USE_LED1_WORK_AROUND
+volatile DWORD g_GpioSettingOriginal;
+#endif
+
+BOOLEAN Lan_Initialize(
+	PPRIVATE_DATA privateData,DWORD dwIntCfg,
+	DWORD dwTxFifSz,DWORD dwAfcCfg);
+void Lan_EnableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask);
+void Lan_DisableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask);
+void Lan_EnableIRQ(PPRIVATE_DATA privateData);
+void Lan_DisableIRQ(PPRIVATE_DATA privateData);
+void Lan_SetIntDeas(PPRIVATE_DATA privateData,DWORD dwIntDeas);
+void Lan_SetTDFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetTSFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetRDFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetRSFL(PPRIVATE_DATA privateData,BYTE level);
+
+void Lan_SignalSoftwareInterrupt(PPRIVATE_DATA privateData);
+BOOLEAN Lan_HandleSoftwareInterrupt(PPRIVATE_DATA privateData,DWORD dwIntSts);
+
+void Lan_ShowRegs(PPRIVATE_DATA privateData);
+
+#include "ioctl_118.h"
+
+DWORD lan_base=0x0UL;
+module_param(lan_base,ulong,0);
+MODULE_PARM_DESC(lan_base,"Base Address of LAN9118, (default: choosen by platform code)");
+
+DWORD bus_width=0UL;
+module_param(bus_width,ulong,0);
+MODULE_PARM_DESC(bus_width,"Force bus width of 16 or 32 bits, default: autodetect");
+
+DWORD link_mode=0x7FUL;
+module_param(link_mode,ulong,0);
+MODULE_PARM_DESC(link_mode,"Set Link speed and Duplex, 1=10HD,2=10FD,4=100HD,8=100FD,default=0xF");
+
+DWORD irq=PLATFORM_IRQ;
+module_param(irq,ulong,0);
+MODULE_PARM_DESC(irq,"Force use of specific IRQ, (default: choosen by platform code)");
+
+DWORD int_deas=0xFFFFFFFFUL;
+module_param(int_deas,ulong,0);
+MODULE_PARM_DESC(int_deas,"Interrupt Deassertion Interval in 10uS units");
+
+DWORD irq_pol=PLATFORM_IRQ_POL;
+module_param(irq_pol,ulong,0);
+MODULE_PARM_DESC(irq_pol,"IRQ Polarity bit, see definition of INT_CFG register");
+
+DWORD irq_type=PLATFORM_IRQ_TYPE;
+module_param(irq_type,ulong,0);
+MODULE_PARM_DESC(irq_type,"IRQ Buffer Type bit, see definition of INT_CFG register");
+
+DWORD rx_dma=PLATFORM_RX_DMA;
+module_param(rx_dma,ulong,0);
+MODULE_PARM_DESC(rx_dma,"Receiver DMA Channel, 255=find available channel, 256=use PIO");
+
+DWORD tx_dma=PLATFORM_TX_DMA;
+module_param(tx_dma,ulong,0);
+MODULE_PARM_DESC(tx_dma,"Transmitter DMA Channel, 255=find available channel, 256=use PIO");
+
+DWORD dma_threshold=PLATFORM_DMA_THRESHOLD;
+module_param(dma_threshold,ulong,0);
+MODULE_PARM_DESC(dma_threshold,"Specifies the minimum packet size for DMA to be used.");
+
+DWORD mac_addr_hi16=0xFFFFFFFFUL;
+module_param(mac_addr_hi16,ulong,0);
+MODULE_PARM_DESC(mac_addr_hi16,"Specifies the high 16 bits of the mac address");
+
+DWORD mac_addr_lo32=0xFFFFFFFFUL;
+module_param(mac_addr_lo32,ulong,0);
+MODULE_PARM_DESC(mac_addr_lo32,"Specifies the low 32 bits of the mac address");
+
+#ifdef USE_DEBUG
+DWORD debug_mode=0x7UL;
+#else
+DWORD debug_mode=0x0UL;
+#endif
+module_param(debug_mode,ulong,0);
+MODULE_PARM_DESC(debug_mode,"bit 0 enables trace points, bit 1 enables warning points, bit 2 enables gpios");
+
+DWORD tx_fif_sz=0x00050000UL;
+module_param(tx_fif_sz,ulong,0);
+MODULE_PARM_DESC(tx_fif_sz,"Specifies TX_FIF_SZ of the HW_CFG register");
+
+DWORD afc_cfg=0xFFFFFFFFUL;
+module_param(afc_cfg,ulong,0);
+MODULE_PARM_DESC(afc_cfg,"Specifies the setting for the AFC_CFG register");
+
+DWORD tasklets=1UL;
+module_param(tasklets,ulong,0);
+MODULE_PARM_DESC(tasklets,"non-zero== use tasklets for receiving packets, zero==receive packets in ISR");
+
+DWORD phy_addr=0xFFFFFFFFUL;
+module_param(phy_addr,ulong,0);
+MODULE_PARM_DESC(phy_addr,"phy_addr, 0xFFFFFFFF=use interal phy, 0-31=use external phy with specified address, else autodetect external phy addr");
+
+DWORD max_throughput=0xFFFFFFFFUL;
+module_param(max_throughput,ulong,0);
+MODULE_PARM_DESC(max_throughput,"See readme.txt");
+
+DWORD max_packet_count=0xFFFFFFFFUL;
+module_param(max_packet_count,ulong,0);
+MODULE_PARM_DESC(max_packet_count,"See Readme.txt");
+
+DWORD packet_cost=0xFFFFFFFFUL;
+module_param(packet_cost,ulong,0);
+MODULE_PARM_DESC(packet_cost,"See Readme.txt");
+
+DWORD burst_period=0xFFFFFFFFUL;
+module_param(burst_period,ulong,0);
+MODULE_PARM_DESC(burst_period,"See Readme.txt");
+
+DWORD max_work_load=0xFFFFFFFFUL;
+module_param(max_work_load,ulong,0);
+MODULE_PARM_DESC(max_work_load,"See Readme.txt");
+
+MODULE_LICENSE("GPL");
+
+int Smsc9118_init_module(void);
+void Smsc9118_cleanup_module(void);
+int Smsc9118_init(struct net_device *dev);
+int Smsc9118_open(struct net_device *dev);
+int Smsc9118_stop(struct net_device *dev);
+int Smsc9118_hard_start_xmit(struct sk_buff *skb, struct net_device *dev);
+struct net_device_stats * Smsc9118_get_stats(struct net_device *dev);
+void Smsc9118_set_multicast_list(struct net_device *dev);
+int Smsc9118_do_ioctl(struct net_device *dev, struct ifreq *ifr,int cmd);
+irqreturn_t Smsc9118_ISR(int irq,void *dev_id);
+
+#ifdef USING_LINT
+struct net_device SMSC9118;
+#else //not USING_LINT
+struct net_device SMSC9118 = {init: Smsc9118_init,};
+#endif //not USING_LINT
+
+int Smsc9118_init_module(void)
+{
+	int result=0;
+	int device_present=0;
+
+	SMSC_TRACE("--> init_module()");
+	SMSC_TRACE("Driver Version = %lX.%02lX",
+		(DRIVER_VERSION>>8),(DRIVER_VERSION&0xFFUL));
+	SMSC_TRACE("Compiled: %s, %s",__DATE__,__TIME__);
+	SMSC_TRACE("Platform: %s",PLATFORM_NAME);
+	SMSC_TRACE("Date Code: %s",date_code);
+	SMSC_TRACE("Driver Parameters");
+	if(lan_base==0UL) {
+		SMSC_TRACE("  lan_base         = 0x%08lX, driver will decide",lan_base);
+	} else {
+		SMSC_TRACE("  lan_base         = 0x%08lX",lan_base);
+	}
+	if((bus_width==16UL)||(bus_width==32UL)) {
+		SMSC_TRACE("  bus_width        = %ld",bus_width);
+	} else {
+		SMSC_TRACE("  bus_width        = %ld, driver will autodetect",bus_width);
+	}
+	if(link_mode>0x7FUL) {
+		SMSC_WARNING("  link_mode     = %ld, Unknown",link_mode);
+		link_mode=0x7FUL;
+		SMSC_WARNING("    resetting link_mode to %ld, 100FD,100HD,10FD,10HD,ASYMP,SYMP,ANEG",link_mode);
+	} else if(link_mode==0UL) {
+		SMSC_TRACE("  link_mode        = %ld, LINK_OFF",link_mode);
+	} else {
+		SMSC_TRACE("  link_mode        = 0x%lX, %s,%s,%s,%s,%s,%s,%s",
+			link_mode,
+			(link_mode&LINK_SPEED_10HD)?"10HD":"",
+			(link_mode&LINK_SPEED_10FD)?"10FD":"",
+			(link_mode&LINK_SPEED_100HD)?"100HD":"",
+			(link_mode&LINK_SPEED_100FD)?"100FD":"",
+			(link_mode&LINK_ASYMMETRIC_PAUSE)?"ASYMP":"",
+			(link_mode&LINK_SYMMETRIC_PAUSE)?"SYMP":"",
+			(link_mode&LINK_AUTO_NEGOTIATE)?"ANEG":"");
+	}
+	SMSC_TRACE(    "  irq              = %ld",irq);
+	if(int_deas!=0xFFFFFFFFUL) {
+		if(int_deas>0xFFUL) {
+			SMSC_WARNING("  int_deas     = %ld, too high",int_deas);
+			int_deas=0xFFFFFFFFUL;
+			SMSC_WARNING("    resetting int_deas to %ld",int_deas);
+		}
+	}
+	if(int_deas==0xFFFFFFFFUL) {
+		SMSC_TRACE(    "  int_deas         = 0x%08lX, use platform default",int_deas);
+	} else {
+		SMSC_TRACE(    "  int_deas         = %ld, %lduS",int_deas,10UL*int_deas);
+	}
+	if(irq_pol) {
+		SMSC_TRACE("  irq_pol          = %ld, IRQ output is active high",irq_pol);
+	} else {
+		SMSC_TRACE("  irq_pol          = %ld, IRQ output is active low",irq_pol);
+	}
+	if(irq_type) {
+		SMSC_TRACE("  irq_type         = %ld, IRQ output is Push-Pull driver",irq_type);
+	} else {
+		SMSC_TRACE("  irq_type         = %ld, IRQ output is Open-Drain buffer",irq_type);
+	}
+	if(rx_dma<TRANSFER_REQUEST_DMA) {
+		if(Platform_IsValidDmaChannel(rx_dma)) {
+			SMSC_TRACE(
+				   "  rx_dma           = %ld, DMA Channel %ld",rx_dma,rx_dma);
+		} else {
+			SMSC_WARNING("  rx_dma        = %ld, Invalid Dma Channel",rx_dma);
+			rx_dma=TRANSFER_PIO;
+			SMSC_WARNING("    resetting rx_dma to %ld, RX will use PIO",rx_dma);
+		}
+	} else if(rx_dma==TRANSFER_REQUEST_DMA) {
+		SMSC_TRACE("  rx_dma           = %ld, RX will try to find available channel",rx_dma);
+	} else {
+		SMSC_TRACE("  rx_dma           = %ld, RX will use PIO",rx_dma);
+	}
+	if(tx_dma<TRANSFER_REQUEST_DMA) {
+		if(Platform_IsValidDmaChannel(tx_dma)) {
+			if(tx_dma!=rx_dma) {
+				SMSC_TRACE(
+				   "  tx_dma           = %ld, DMA Channel %ld",tx_dma,tx_dma);
+			} else {
+				SMSC_WARNING("  tx_dma == rx_dma");
+				tx_dma=TRANSFER_PIO;
+				SMSC_WARNING("    resetting tx_dma to %ld, TX will use PIO",tx_dma);
+			}
+		} else {
+			SMSC_WARNING("  tx_dma        = %ld, Invalid Dma Channel",tx_dma);
+			tx_dma=TRANSFER_PIO;
+			SMSC_WARNING("    resetting tx_dma to %ld, TX will use PIO",tx_dma);
+		}
+	} else if(tx_dma==TRANSFER_REQUEST_DMA) {
+		SMSC_TRACE("  tx_dma           = %ld, TX will try to find available channel",tx_dma);
+	} else {
+		SMSC_TRACE("  tx_dma           = %ld, TX will use PIO",tx_dma);
+	}
+	SMSC_TRACE(    "  dma_threshold    = %ld",dma_threshold);
+
+	if(mac_addr_hi16==0xFFFFFFFFUL) {
+		SMSC_TRACE("  mac_addr_hi16    = 0x%08lX, will attempt to read from LAN9118",mac_addr_hi16);
+		SMSC_TRACE("  mac_addr_lo32    = 0x%08lX, will attempt to read from LAN9118",mac_addr_lo32);
+	} else {
+		if(mac_addr_hi16&0xFFFF0000UL) {
+			//The high word is reserved
+			SMSC_WARNING("  mac_addr_hi16 = 0x%08lX, reserved bits are high.",mac_addr_hi16);
+			mac_addr_hi16&=0x0000FFFFUL;
+			SMSC_WARNING("    reseting to mac_addr_hi16 = 0x%08lX",mac_addr_hi16);
+		}
+		if(mac_addr_lo32&0x00000001UL) {
+			//bit 0 is the I/G bit
+			SMSC_WARNING("  mac_addr_lo32 = 0x%08lX, I/G bit is set.",mac_addr_lo32);
+			mac_addr_lo32&=0xFFFFFFFEUL;
+			SMSC_WARNING("    reseting to mac_addr_lo32 = 0x%08lX",mac_addr_lo32);
+		}
+		SMSC_TRACE("  mac_addr_hi16    = 0x%08lX",mac_addr_hi16);
+		SMSC_TRACE("  mac_addr_lo32    = 0x%08lX",mac_addr_lo32);
+	}
+	SMSC_TRACE(    "  debug_mode       = 0x%08lX",debug_mode);
+	if(tx_fif_sz&(~HW_CFG_TX_FIF_SZ_)) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is invalid",tx_fif_sz);
+		tx_fif_sz&=HW_CFG_TX_FIF_SZ_;
+		SMSC_WARNING("  resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	if(tx_fif_sz>0x000E0000UL) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is too high",tx_fif_sz);
+		tx_fif_sz=0x000E0000UL;
+		SMSC_WARNING(" resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	if(tx_fif_sz<0x00020000UL) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is too low",tx_fif_sz);
+		tx_fif_sz=0x00020000UL;
+		SMSC_WARNING(" resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	SMSC_TRACE(    "  tx_fif_sz        = 0x%08lX",tx_fif_sz);
+	if(afc_cfg==0xFFFFFFFFUL) {
+		SMSC_TRACE("  afc_cfg          = 0x%08lX, driver will decide",afc_cfg);
+	} else {
+		if(afc_cfg&0xFF000000UL) {
+			SMSC_WARNING("afc_cfg = 0x%08lX is invalid",afc_cfg);
+			afc_cfg&=0xFFFFFFFFUL;
+			SMSC_WARNING(" resetting to afc_cfg = 0x%08lX, driver will decide",afc_cfg);
+		} else {
+			SMSC_TRACE(
+				   "  afc_cfg          = 0x%08lX",afc_cfg);
+		}
+	}
+	if(tasklets) {
+		SMSC_TRACE("  tasklets         = 0x%08lX, Tasklets enabled",tasklets);
+	} else {
+		SMSC_TRACE("  tasklets         = 0, Tasklets disabled");
+	}
+	if(phy_addr==0xFFFFFFFFUL) {
+		SMSC_TRACE("  phy_addr         = 0xFFFFFFFF, Use internal phy");
+	} else if(phy_addr<=31UL) {
+		SMSC_TRACE("  phy_addr         = 0x%08lX, use this address for external phy",phy_addr);
+	} else {
+		SMSC_TRACE("  phy_addr         = 0x%08lX, auto detect external phy",phy_addr);
+	}
+	if(max_throughput) {
+		SMSC_TRACE("  max_throughput   = 0x%08lX, Use platform default",max_throughput);
+	} else {
+		SMSC_TRACE("  max_throughput   = 0x%08lX",max_throughput);
+	}
+	if(max_packet_count) {
+		SMSC_TRACE("  max_packet_count = 0x%08lX, Use platform default",max_packet_count);
+	} else {
+		SMSC_TRACE("  max_packet_count = 0x%08lX",max_packet_count);
+	}
+	if(packet_cost) {
+		SMSC_TRACE("  packet_cost      = 0x%08lX, Use platform default",packet_cost);
+	} else {
+		SMSC_TRACE("  packet_cost      = 0x%08lX",packet_cost);
+	}
+	if(burst_period) {
+		SMSC_TRACE("  burst_period     = 0x%08lX, Use platform default",burst_period);
+	} else {
+		SMSC_TRACE("  burst_period     = 0x%08lX",burst_period);
+	}
+	if(max_work_load) {
+		SMSC_TRACE("  max_work_load    = 0x%08lX, Use platform default",max_work_load);
+	} else {
+		SMSC_TRACE("  max_work_load    = 0x%08lX",max_work_load);
+	}
+
+	strcpy(SMSC9118.name,"eth%d");
+
+	result=register_netdev(&SMSC9118);
+	if(result) {
+		SMSC_WARNING("error %i registering device",result);
+	} else {
+		device_present=1;
+		SMSC_TRACE("  Interface Name = \"%s\"",SMSC9118.name);
+	}
+	result=result;//make lint happy
+	SMSC_TRACE("<-- init_module()");
+	return device_present ? 0 : -ENODEV;
+}
+
+void Smsc9118_cleanup_module(void)
+{
+	SMSC_TRACE("--> cleanup_module()");
+	if(SMSC9118.priv!=NULL) {
+		PPRIVATE_DATA privateData=(PPRIVATE_DATA)SMSC9118.priv;
+		PPLATFORM_DATA platformData=(PPLATFORM_DATA)&(privateData->PlatformData);
+		Platform_CleanUp(platformData);
+		kfree(SMSC9118.priv);
+		SMSC9118.priv=NULL;
+	}
+	unregister_netdev(&SMSC9118);
+	SMSC_TRACE("<-- cleanup_module()");
+}
+
+int Smsc9118_init(struct net_device *dev)
+{
+	DWORD dwLanBase=0UL;
+	DWORD dwIdRev=0UL;
+	DWORD dwFpgaRev=0UL;
+	PPRIVATE_DATA privateData=NULL;
+	PPLATFORM_DATA platformData=NULL;
+	BOOLEAN platformInitialized=FALSE;
+	int result=-ENODEV;
+	SMSC_TRACE("-->Smsc9118_init(dev=0x%08lX)",(DWORD)dev);
+
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc9118_init(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+
+	if(dev->priv!=NULL) {
+		SMSC_WARNING("dev->priv!=NULL, going to overwrite pointer");
+	}
+	dev->priv=kmalloc(sizeof(PRIVATE_DATA),GFP_KERNEL);
+	if(dev->priv==NULL) {
+		SMSC_WARNING("Unable to allocate PRIVATE_DATA");
+		result=-ENOMEM;
+		goto DONE;
+	}
+	memset(dev->priv,0,sizeof(PRIVATE_DATA));
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	platformData=&(privateData->PlatformData);
+
+	dwLanBase=Platform_Initialize(
+		platformData,
+		lan_base,bus_width);
+
+	if(dwLanBase==0UL) {
+		SMSC_WARNING("dwLanBase==0x00000000");
+		result=-ENODEV;
+		goto DONE;
+	}
+	platformInitialized=TRUE;
+	SMSC_TRACE("dwLanBase=0x%08lX",dwLanBase);
+
+	if(check_mem_region(dwLanBase,LAN_REGISTER_EXTENT)!=0) {
+		SMSC_WARNING("  Memory Region specified (0x%08lX to 0x%08lX) is not available.",
+			dwLanBase,dwLanBase+LAN_REGISTER_EXTENT-1UL);
+		result=-ENOMEM;
+		goto DONE;
+	}
+
+	privateData->dwLanBase=dwLanBase;
+	dwIdRev=Lan_GetRegDW(ID_REV);
+	if(HIWORD(dwIdRev)==LOWORD(dwIdRev)) {
+		//this may mean the chip is set for 32 bit
+		//  while the bus is reading as 16 bit
+UNKNOWN_CHIP:
+		SMSC_WARNING("  LAN9118 Family NOT Identified, dwIdRev==0x%08lX",dwIdRev);
+		result=-ENODEV;
+		goto DONE;
+	}
+	switch(dwIdRev&0xFFFF0000UL) {
+	case 0x01180000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9118 Beacon identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=0;
+			break;
+		case 1UL:
+			SMSC_TRACE("  LAN9118 Concord A0 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=1;
+			break;
+		case 2UL:
+			SMSC_TRACE("  LAN9118 Concord A1 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		default:
+			SMSC_TRACE("  LAN9118 Concord A1 identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		};break;
+	case 0x01170000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9117 Beacon identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=0;
+			break;
+		case 1UL:
+			SMSC_TRACE("  LAN9117 Concord A0 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=1;
+			break;
+		case 2UL:
+			SMSC_TRACE("  LAN9117 Concord A1 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		default:
+			SMSC_TRACE("  LAN9117 Concord A1 identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		};break;
+	case 0x01160000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			goto UNKNOWN_CHIP;
+		case 1UL:
+			SMSC_TRACE("  LAN9116 Concord A0 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=1;
+			break;
+		case 2UL:
+			SMSC_TRACE("  LAN9116 Concord A1 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		default:
+			SMSC_TRACE("  LAN9116 Concord A1 identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		};break;
+	case 0x01150000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			goto UNKNOWN_CHIP;
+		case 1UL:
+			SMSC_TRACE("  LAN9115 Concord A0 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=1;
+			break;
+		case 2UL:
+			SMSC_TRACE("  LAN9115 Concord A1 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		default:
+			SMSC_TRACE("  LAN9115 Concord A1 identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		};break;
+	case 0x01120000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			goto UNKNOWN_CHIP;
+		case 1UL:
+			SMSC_TRACE("  LAN9112 Concord A0 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=1;
+			break;
+		case 2UL:
+			SMSC_TRACE("  LAN9112 Concord A1 identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		default:
+			SMSC_TRACE("  LAN9112 Concord A1 identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=2;
+			break;
+		};break;
+	case 0x118A0000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9218 Boylston identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		default:
+			SMSC_TRACE("  LAN9218 Boylston identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		};break;
+	case 0x117A0000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9217 Boylston identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		default:
+			SMSC_TRACE("  LAN9217 Boylston identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		};break;
+	case 0x116A0000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9216 Boylston identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		default:
+			SMSC_TRACE("  LAN9216 Boylston identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		};break;
+	case 0x115A0000UL:
+		switch(dwIdRev&0x0000FFFFUL) {
+		case 0UL:
+			SMSC_TRACE("  LAN9215 Boylston identified, dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		default:
+			SMSC_TRACE("  LAN9215 Boylston identified (NEW), dwIdRev==0x%08lX",dwIdRev);
+			privateData->dwGeneration=3;
+			break;
+		};break;
+	default:
+		SMSC_TRACE("  unrecognised dwIdRev=0x%08lX",dwIdRev);
+		break;
+	}
+	dwFpgaRev=Lan_GetRegDW(FPGA_REV);
+	SMSC_TRACE("  FPGA_REV == 0x%08lX",dwFpgaRev);
+
+	ether_setup(dev);
+	dev->open=				Smsc9118_open;
+	dev->stop=				Smsc9118_stop;
+	dev->hard_start_xmit=	Smsc9118_hard_start_xmit;
+	dev->get_stats=			Smsc9118_get_stats;
+	dev->do_ioctl=			Smsc9118_do_ioctl;
+	dev->set_multicast_list=Smsc9118_set_multicast_list;
+	dev->flags|=IFF_MULTICAST;
+
+	// set an invalid MAC address (so we can observe if its value is changed)
+	memset(dev->dev_addr, 0xff, 6);
+
+	SET_MODULE_OWNER(dev);
+
+	privateData->dwIdRev=dwIdRev;
+	privateData->dwFpgaRev=dwFpgaRev&(0x000000FFUL);
+	privateData->dev=dev;
+
+	sprintf(privateData->ifName,"%s",dev->name);
+	result=0;
+
+DONE:
+	if(result!=0) {
+		if(dev!=NULL) {
+			if(dev->priv!=NULL) {
+				if(platformInitialized) {
+					Platform_CleanUp(platformData);
+				}
+				kfree(dev->priv);
+				dev->priv=NULL;
+			}
+		}
+	}
+	SMSC_TRACE("<--Smsc9118_init(), result=%d",result);
+	return result;
+}
+
+int Smsc9118_open(struct net_device *dev)
+{
+	int i;
+	int result=-ENODEV;
+	PPRIVATE_DATA privateData=NULL;
+	PPLATFORM_DATA platformData=NULL;
+	BOOLEAN acquired_mem_region=FALSE;
+	BOOLEAN acquired_isr=FALSE;
+	SMSC_TRACE("-->Smsc9118_open(dev=0x%08lX)",(DWORD)dev);
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc9118_open(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc9118_open(privateData==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	platformData=&(privateData->PlatformData);
+
+	for (i = 0; i < GPT_SCHEDULE_DEPTH; i++) {
+		privateData->GptFunction [i] = NULL;
+	}
+	privateData->Gpt_scheduled_slot_index = GPT_SCHEDULE_DEPTH;
+
+	//get memory region
+	if(check_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT)!=0)
+	{
+		SMSC_WARNING("Device memory is already in use.");
+		result=-ENOMEM;
+		goto DONE;
+	}
+	request_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT,"SMSC_LAN9118");
+	acquired_mem_region=TRUE;
+
+	//initialize the LAN9118
+	{
+		DWORD dwIntCfg=0;
+		if(irq_pol) {
+			dwIntCfg|=INT_CFG_IRQ_POL_;
+		}
+		if(irq_type) {
+			dwIntCfg|=INT_CFG_IRQ_TYPE_;
+		}
+		if(!Lan_Initialize(privateData,dwIntCfg,tx_fif_sz,afc_cfg))
+		{
+			SMSC_WARNING("Failed Lan_Initialize");
+			result=-ENODEV;
+			goto DONE;
+		}
+	}
+
+	if(!Platform_RequestIRQ(platformData,irq,Smsc9118_ISR,privateData)) {
+		result=-ENODEV;
+		goto DONE;
+	}
+	acquired_isr=TRUE;
+
+	//must now test the IRQ connection to the ISR
+	SMSC_TRACE("Testing ISR using IRQ %ld",Platform_CurrentIRQ(platformData));
+	{
+		DWORD dwTimeOut=100000;
+		Lan_SignalSoftwareInterrupt(privateData);
+		do {
+			udelay(10);
+			dwTimeOut--;
+		} while((dwTimeOut)&&(!(privateData->SoftwareInterruptSignal)));
+		if(!(privateData->SoftwareInterruptSignal)) {
+			SMSC_WARNING("ISR failed signaling test");
+			result=-ENODEV;
+			goto DONE;
+		}
+	}
+	SMSC_TRACE("ISR passed test using IRQ %ld",Platform_CurrentIRQ(platformData));
+
+	if(!Mac_Initialize(privateData)) {
+		SMSC_WARNING("Failed Mac_Initialize");
+		result=-ENODEV;
+		goto DONE;
+	}
+	{//get mac address
+		DWORD dwHigh16=0;
+		DWORD dwLow32=0;
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode;
+
+		// if the dev_addr has been set use via set_mac_address then let this override everything
+		if (!(dev->dev_addr[0] == 0xff && dev->dev_addr[1] == 0xff &&
+		      dev->dev_addr[2] == 0xff && dev->dev_addr[3] == 0xff &&
+		      dev->dev_addr[4] == 0xff && dev->dev_addr[5] == 0xff)) {
+			mac_addr_lo32 = dev->dev_addr[0]       | dev->dev_addr[1] <<  8 |
+			                dev->dev_addr[2] << 16 | dev->dev_addr[3] << 24;
+			mac_addr_hi16 = dev->dev_addr[4]       | dev->dev_addr[5] <<  8;
+		}
+
+		keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		if(mac_addr_hi16==0xFFFFFFFF) {
+			dwHigh16=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			dwLow32=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			if((dwHigh16==0x0000FFFFUL)&&(dwLow32==0xFFFFFFFF))
+			{
+				dwHigh16=0x00000070UL;
+				dwLow32=0x110F8000UL;
+				Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+				Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+				SMSC_TRACE("Mac Address is set by default to 0x%04lX%08lX",
+					dwHigh16,dwLow32);
+			} else {
+				SMSC_TRACE("Mac Address is read from LAN9118 as 0x%04lX%08lX",
+					dwHigh16,dwLow32);
+			}
+		} else {
+			//SMSC_ASSERT((mac_addr_hi16&0xFFFF8000UL)==0);
+			dwHigh16=mac_addr_hi16;
+			dwLow32=mac_addr_lo32;
+			Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+			Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+			SMSC_TRACE("Mac Address is set by parameter to 0x%04lX%08lX",
+				dwHigh16,dwLow32);
+		}
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+		dev->dev_addr[0]=LOBYTE(LOWORD(dwLow32));
+		dev->dev_addr[1]=HIBYTE(LOWORD(dwLow32));
+		dev->dev_addr[2]=LOBYTE(HIWORD(dwLow32));
+		dev->dev_addr[3]=HIBYTE(HIWORD(dwLow32));
+		dev->dev_addr[4]=LOBYTE(LOWORD(dwHigh16));
+		dev->dev_addr[5]=HIBYTE(LOWORD(dwHigh16));
+	}
+
+	privateData->MulticastUpdatePending = FALSE;
+
+#ifdef USE_PHY_WORK_AROUND
+	netif_carrier_off(dev);
+	if(!Phy_Initialize(
+		privateData,
+		phy_addr,
+		link_mode))
+	{
+		SMSC_WARNING("Failed to initialize Phy");
+		result=-ENODEV;
+		goto DONE;
+	}
+#endif
+
+	{
+		DWORD dwRxDmaCh=rx_dma;
+		DWORD dwTxDmaCh=tx_dma;
+		privateData->RxDmaChReserved=FALSE;
+
+	spin_lock_init(&(privateData->GpTimerLock));
+
+		if(rx_dma==TRANSFER_REQUEST_DMA) {
+			dwRxDmaCh=Platform_RequestDmaChannelSg(&(privateData->PlatformData));
+			SMSC_ASSERT(dwRxDmaCh!=TRANSFER_REQUEST_DMA);
+			if(dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->RxDmaChReserved=TRUE;
+			}
+		}
+		privateData->TxDmaChReserved=FALSE;
+		if(tx_dma==TRANSFER_REQUEST_DMA) {
+			dwTxDmaCh=Platform_RequestDmaChannel(&(privateData->PlatformData));
+			SMSC_ASSERT(dwTxDmaCh!=TRANSFER_REQUEST_DMA);
+			if(dwTxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->TxDmaChReserved=TRUE;
+			}
+		}
+		Tx_Initialize(privateData,dwTxDmaCh,dma_threshold);
+		Rx_Initialize(privateData,dwRxDmaCh,dma_threshold);
+	}
+
+#ifndef LINUX_2_6_OR_NEWER
+	MOD_INC_USE_COUNT;
+#endif
+	privateData->Running=TRUE;
+	netif_start_queue(dev);
+	Tx_StopQueue(privateData,0x01UL);
+
+
+	Lan_EnableInterrupt(privateData,INT_EN_GPT_INT_EN_);
+#ifndef USE_PHY_WORK_AROUND
+	netif_carrier_off(dev);
+	if(!Phy_Initialize(
+		privateData,
+		phy_addr,
+		link_mode))
+	{
+		SMSC_WARNING("Failed to initialize Phy");
+		result=-ENODEV;
+		goto DONE;
+	}
+#endif
+
+	result=0;
+
+DONE:
+	if(result!=0) {
+#ifndef LINUX_2_6_OR_NEWER
+		MOD_DEC_USE_COUNT;
+#endif
+		if(privateData!=NULL) {
+			if(privateData->TxDmaChReserved) {
+				Platform_ReleaseDmaChannel(platformData,
+					privateData->dwTxDmaCh);
+				privateData->TxDmaChReserved=FALSE;
+			}
+			if(privateData->RxDmaChReserved) {
+				Platform_ReleaseDmaChannel(platformData,
+					privateData->dwRxDmaCh);
+				privateData->RxDmaChReserved=FALSE;
+			}
+			if(acquired_isr) {
+				Platform_FreeIRQ(platformData);
+			}
+			if(acquired_mem_region) {
+				release_mem_region(
+					privateData->dwLanBase,
+					LAN_REGISTER_EXTENT);
+			}
+		}
+	}
+	SMSC_TRACE("<--Smsc9118_open, result=%d",result);
+	return result;
+}
+
+int Smsc9118_stop(struct net_device *dev)
+{
+	int result=0;
+	PPRIVATE_DATA privateData=NULL;
+	SMSC_TRACE("-->Smsc9118_stop(dev=0x%08lX)",(DWORD)dev);
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc9118_stop(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc9118_stop(privateData==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+
+	privateData->StopLinkPolling=TRUE;
+	del_timer_sync(&(privateData->LinkPollingTimer));
+
+	Lan_DisableInterrupt(privateData,INT_EN_GPT_INT_EN_);
+
+	Tx_UpdateTxCounters(privateData);
+	privateData->Running=FALSE;
+	Lan_DisableIRQ(privateData);
+
+	Tx_CompleteDma(privateData);
+
+	Tx_StopQueue(privateData,0x01UL);
+
+#ifndef LINUX_2_6_OR_NEWER
+	MOD_DEC_USE_COUNT;
+#endif
+
+	if(privateData->TxDmaChReserved) {
+		Platform_ReleaseDmaChannel(
+			&(privateData->PlatformData),
+			privateData->dwTxDmaCh);
+		privateData->TxDmaChReserved=FALSE;
+	}
+	if(privateData->RxDmaChReserved) {
+		Platform_ReleaseDmaChannel(
+			&(privateData->PlatformData),
+			privateData->dwRxDmaCh);
+		privateData->RxDmaChReserved=FALSE;
+	}
+
+	Platform_FreeIRQ(&(privateData->PlatformData));
+	release_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT);
+
+	{
+		const DWORD dwLanBase=privateData->dwLanBase;
+		const DWORD dwIdRev=privateData->dwIdRev;
+		const DWORD dwFpgaRev=privateData->dwFpgaRev;
+		struct net_device * const tempDev=privateData->dev;
+		char ifName[SMSC_IF_NAME_SIZE];
+		PLATFORM_DATA platformDataBackup;
+		memcpy(ifName,privateData->ifName,SMSC_IF_NAME_SIZE);
+		memcpy(&platformDataBackup,&(privateData->PlatformData),sizeof(PLATFORM_DATA));
+
+		memset(privateData,0,sizeof(PRIVATE_DATA));
+
+		privateData->dwLanBase=dwLanBase;
+		privateData->dwIdRev=dwIdRev;
+		privateData->dwFpgaRev=dwFpgaRev;
+		privateData->dev=tempDev;
+		memcpy(privateData->ifName,ifName,SMSC_IF_NAME_SIZE);
+		memcpy(&(privateData->PlatformData),&platformDataBackup,sizeof(PLATFORM_DATA));
+	}
+
+DONE:
+	SMSC_TRACE("<--Smsc9118_stop, result=%d",result);
+	return result;
+}
+
+int Smsc9118_hard_start_xmit(
+	struct sk_buff *skb, struct net_device * const dev)
+{
+	int result=0;
+	PPRIVATE_DATA privateData=NULL;
+//	SMSC_TRACE("-->Smsc9118_hard_start_xmit(skb=0x%08lX,dev=0x%08lX)",(DWORD)skb,(DWORD)dev);
+	if(skb==NULL) {
+		SMSC_WARNING("Smsc9118_hard_start_xmit(skb==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc9118_hard_start_xmit(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	if(dev->priv==NULL) {
+		SMSC_WARNING("Smsc9118_hard_start_xmit(dev->priv==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+//	SET_GPIO(GP_TX);
+
+	Tx_SendSkb(privateData,skb);
+
+//	CLEAR_GPIO(GP_TX);
+DONE:
+//	SMSC_TRACE("<--Smsc9118_hard_start_xmit, result=%d",result);
+	return result;
+}
+
+struct net_device_stats * Smsc9118_get_stats(struct net_device * const dev)
+{
+	PPRIVATE_DATA privateData=NULL;
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc9118_get_stats(dev==NULL)");
+		return NULL;
+	}
+	if(dev->priv==NULL) {
+	//	SMSC_WARNING("Smsc9118_get_stats(dev->priv==NULL)");
+		return NULL;
+	}
+
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData->Running) {
+		privateData->stats.rx_dropped+=Lan_GetRegDW(RX_DROP);
+		Tx_UpdateTxCounters(privateData);
+	}
+	return &(privateData->stats);
+}
+
+void Smsc9118_set_multicast_list(struct net_device *dev)
+{
+	SMSC_ASSERT(dev!=NULL);
+	Rx_SetMulticastList(dev);
+}
+
+int Smsc9118_do_ioctl(
+	struct net_device *dev,
+	struct ifreq *ifr,
+	int cmd)
+{
+	PPRIVATE_DATA privateData=NULL;
+	PSMSC9118_IOCTL_DATA ioctlData=NULL;
+	BOOLEAN success=FALSE;
+//	SMSC_TRACE("-->Smsc9118_do_ioctl");
+//	SMSC_TRACE("cmd=%d,SIOCGMIIPHY=%d,SIOCDEVPRIVATE=%d",
+//		cmd,SIOCGMIIPHY,SIOCDEVPRIVATE);
+	SMSC_ASSERT(dev!=NULL);
+	SMSC_ASSERT(dev->priv!=NULL);
+	privateData=((PPRIVATE_DATA)dev->priv);
+	if(ifr==NULL) {
+//		SMSC_WARNING("Smsc9118_do_ioctl(ifr==NULL)");
+		goto DONE;
+	}
+
+	if(privateData->LanInitialized) {
+		// standard MII IOC's
+		struct mii_ioctl_data * const data=
+			(struct mii_ioctl_data *) & ifr->ifr_data;
+		switch(cmd) {
+		case SIOCGMIIPHY:
+
+		case SIOCDEVPRIVATE:
+			data->phy_id=1;
+//			SMSC_TRACE("SIOCGMIIPHY: phy_id set to 0x%04X",data->phy_id);
+			return 0;
+		case SIOCGMIIREG:
+		case SIOCDEVPRIVATE+1:
+			{
+				DWORD dwIntFlags=0;
+				VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+				data->val_out=Phy_GetRegW(
+					privateData,data->reg_num,keyCode);
+				Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			}
+//			SMSC_TRACE("SIOCGMIIREG: phy_id=0x%04X, reg_num=0x%04X, val_out set to 0x%04X",
+//				data->phy_id,data->reg_num,data->val_out);
+			return 0;
+		case SIOCSMIIREG:
+		case SIOCDEVPRIVATE+2:
+//			SMSC_TRACE("SIOCSMIIREG: phy_id=0x%04X, reg_num=0x%04X, val_in=0x%04X",
+//				data->phy_id,data->reg_num,data->val_in);
+			{
+				DWORD dwIntFlags=0;
+				VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+				Phy_SetRegW(
+					privateData,data->reg_num,((WORD)(data->val_in)),keyCode);
+				Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			}
+			return 0;
+		default:break;//make lint happy
+		}
+	}
+	if(ifr->ifr_data==NULL) {
+//		SMSC_WARNING("Smsc9118_do_ioctl(ifr->ifr_data==NULL)");
+		goto DONE;
+	}
+	if(cmd!=((int)SMSC9118_IOCTL)) goto DONE;
+	ioctlData=(PSMSC9118_IOCTL_DATA)(ifr->ifr_data);
+	if(ioctlData->dwSignature!=SMSC9118_APP_SIGNATURE) {
+		goto DONE;
+	}
+
+	switch(ioctlData->dwCommand) {
+	case COMMAND_GET_SIGNATURE:
+		success=TRUE;
+		break;
+	case COMMAND_GET_FLOW_PARAMS:
+		ioctlData->Data[0]=privateData->RxFlowMeasuredMaxThroughput;
+		ioctlData->Data[1]=privateData->RxFlowMeasuredMaxPacketCount;
+		ioctlData->Data[2]=privateData->RxFlowParameters.MaxThroughput;
+		ioctlData->Data[3]=privateData->RxFlowParameters.MaxPacketCount;
+		ioctlData->Data[4]=privateData->RxFlowParameters.PacketCost;
+		ioctlData->Data[5]=privateData->RxFlowParameters.BurstPeriod;
+		ioctlData->Data[6]=privateData->RxFlowMaxWorkLoad;
+		ioctlData->Data[7]=Lan_GetRegDW(INT_CFG)>>24;
+		privateData->RxFlowMeasuredMaxThroughput=0;
+		privateData->RxFlowMeasuredMaxPacketCount=0;
+		success=TRUE;
+		break;
+	case COMMAND_SET_FLOW_PARAMS:
+		if(!(privateData->RxFlowControlActive)) {
+			privateData->RxFlowParameters.MaxThroughput=ioctlData->Data[2];
+			privateData->RxFlowParameters.MaxPacketCount=ioctlData->Data[3];
+			privateData->RxFlowParameters.PacketCost=ioctlData->Data[4];
+			privateData->RxFlowParameters.BurstPeriod=ioctlData->Data[5];
+			if(ioctlData->Data[6]==0xFFFFFFFFUL) {
+				privateData->RxFlowMaxWorkLoad=
+					privateData->RxFlowParameters.MaxThroughput+
+					(privateData->RxFlowParameters.MaxPacketCount*
+					privateData->RxFlowParameters.PacketCost);
+			} else {
+				privateData->RxFlowMaxWorkLoad=ioctlData->Data[6];
+			}
+			Lan_SetIntDeas(privateData,ioctlData->Data[7]);
+			privateData->RxFlowBurstMaxWorkLoad=
+				(privateData->RxFlowMaxWorkLoad*
+				privateData->RxFlowParameters.BurstPeriod)/1000;
+			success=TRUE;
+		};break;
+	case COMMAND_GET_CONFIGURATION:
+		ioctlData->Data[0]=DRIVER_VERSION;
+		ioctlData->Data[1]=lan_base;
+		ioctlData->Data[2]=bus_width;
+		ioctlData->Data[3]=link_mode;
+		ioctlData->Data[4]=irq;
+		ioctlData->Data[5]=int_deas;
+		ioctlData->Data[6]=irq_pol;
+		ioctlData->Data[7]=irq_type;
+		ioctlData->Data[8]=rx_dma;
+		ioctlData->Data[9]=tx_dma;
+		ioctlData->Data[10]=dma_threshold;
+		ioctlData->Data[11]=mac_addr_hi16;
+		ioctlData->Data[12]=mac_addr_lo32;
+		ioctlData->Data[13]=debug_mode;
+		ioctlData->Data[14]=tx_fif_sz;
+		ioctlData->Data[15]=afc_cfg;
+		ioctlData->Data[16]=tasklets;
+		ioctlData->Data[17]=max_throughput;
+		ioctlData->Data[18]=max_packet_count;
+		ioctlData->Data[19]=packet_cost;
+		ioctlData->Data[20]=burst_period;
+		ioctlData->Data[21]=max_work_load;
+		ioctlData->Data[22]=privateData->dwIdRev;
+		ioctlData->Data[23]=privateData->dwFpgaRev;
+		ioctlData->Data[24]=1;
+		ioctlData->Data[25]=privateData->dwPhyId;
+		ioctlData->Data[26]=privateData->bPhyModel;
+		ioctlData->Data[27]=privateData->bPhyRev;
+		ioctlData->Data[28]=privateData->dwLinkSpeed;
+		ioctlData->Data[29]=privateData->RxFlowMeasuredMaxThroughput;
+		ioctlData->Data[30]=privateData->RxFlowMeasuredMaxPacketCount;
+		ioctlData->Data[31]=privateData->RxFlowParameters.MaxThroughput;
+		ioctlData->Data[32]=privateData->RxFlowParameters.MaxPacketCount;
+		ioctlData->Data[33]=privateData->RxFlowParameters.PacketCost;
+		ioctlData->Data[34]=privateData->RxFlowParameters.BurstPeriod;
+		ioctlData->Data[35]=privateData->RxFlowMaxWorkLoad;
+		sprintf(ioctlData->Strng1,"%s, %s",__DATE__,__TIME__);
+		sprintf(ioctlData->Strng2,"%s",privateData->ifName);
+		privateData->RxFlowMeasuredMaxThroughput=0;
+		privateData->RxFlowMeasuredMaxPacketCount=0;
+		success=TRUE;
+		break;
+	case COMMAND_LAN_GET_REG:
+		if((ioctlData->Data[0]<LAN_REGISTER_EXTENT)&&
+			((ioctlData->Data[0]&0x3UL)==0))
+		{
+			ioctlData->Data[1]=
+				(*((volatile DWORD *)(privateData->dwLanBase+
+						ioctlData->Data[0])));
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading LAN9118 Mem Map Failed");
+			goto MEM_MAP_ACCESS_FAILED;
+		}
+		break;
+	case COMMAND_LAN_SET_REG:
+		if((ioctlData->Data[0]<LAN_REGISTER_EXTENT)&&
+			((ioctlData->Data[0]&0x3UL)==0))
+		{
+			(*((volatile DWORD *)(privateData->dwLanBase+
+						ioctlData->Data[0])))=ioctlData->Data[1];
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading LAN9118 Mem Map Failed");
+MEM_MAP_ACCESS_FAILED:
+			SMSC_WARNING("  Invalid offset == 0x%08lX",ioctlData->Data[0]);
+			if(ioctlData->Data[0]>=LAN_REGISTER_EXTENT) {
+				SMSC_WARNING("    Out of range");
+			}
+			if(ioctlData->Data[0]&0x3UL) {
+				SMSC_WARNING("    Not DWORD aligned");
+			}
+		}
+		break;
+	case COMMAND_MAC_GET_REG:
+		if((ioctlData->Data[0]<=0xC)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[1]=
+				Mac_GetRegDW(privateData,ioctlData->Data[0],keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading Mac Register Failed");
+			goto MAC_ACCESS_FAILURE;
+		}
+		break;
+	case COMMAND_MAC_SET_REG:
+		if((ioctlData->Data[0]<=0xC)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Mac_SetRegDW(
+				privateData,
+				ioctlData->Data[0],
+				ioctlData->Data[1],
+				keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Writing Mac Register Failed");
+MAC_ACCESS_FAILURE:
+			if(!(privateData->LanInitialized)) {
+
+				SMSC_WARNING("  LAN Not Initialized,");
+				SMSC_WARNING("    Use ifconfig to bring interface UP");
+			}
+			if(!(ioctlData->Data[0]<=0xC)) {
+				SMSC_WARNING("  Invalid index == 0x%08lX",ioctlData->Data[0]);
+			}
+		}
+		break;
+	case COMMAND_PHY_GET_REG:
+		if((ioctlData->Data[0]<32)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[1]=((DWORD)
+				Phy_GetRegW(privateData,ioctlData->Data[0],keyCode));
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading Phy Register Failed");
+			goto PHY_ACCESS_FAILURE;
+		}
+		break;
+	case COMMAND_PHY_SET_REG:
+		if((ioctlData->Data[0]<32)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Phy_SetRegW(
+				privateData,
+				ioctlData->Data[0],
+				((WORD)(ioctlData->Data[1])),
+				keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Writing Phy Register Failed");
+PHY_ACCESS_FAILURE:
+			if(!(privateData->LanInitialized)) {
+				SMSC_WARNING("  Lan Not Initialized,");
+				SMSC_WARNING("    Use ifconfig to bring interface UP");
+			}
+			if(!(ioctlData->Data[0]<32)) {
+				SMSC_WARNING("  Invalid index == 0x%ld",ioctlData->Data[0]);
+			}
+		}
+		break;
+//	case COMMAND_DUMP_TEMP:
+//		{
+//			DWORD c=0;
+//			for(c=0;c<0x40;c++)
+//				ioctlData->Data[c]=privateData->temp[c];
+//		}
+//		success=TRUE;
+//		break;
+	case COMMAND_DUMP_LAN_REGS:
+		ioctlData->Data[LAN_REG_ID_REV]=Lan_GetRegDW(ID_REV);
+		ioctlData->Data[LAN_REG_INT_CFG]=Lan_GetRegDW(INT_CFG);
+		ioctlData->Data[LAN_REG_INT_STS]=Lan_GetRegDW(INT_STS);
+		ioctlData->Data[LAN_REG_INT_EN]=Lan_GetRegDW(INT_EN);
+		ioctlData->Data[LAN_REG_BYTE_TEST]=Lan_GetRegDW(BYTE_TEST);
+		ioctlData->Data[LAN_REG_FIFO_INT]=Lan_GetRegDW(FIFO_INT);
+		ioctlData->Data[LAN_REG_RX_CFG]=Lan_GetRegDW(RX_CFG);
+		ioctlData->Data[LAN_REG_TX_CFG]=Lan_GetRegDW(TX_CFG);
+		ioctlData->Data[LAN_REG_HW_CFG]=Lan_GetRegDW(HW_CFG);
+		ioctlData->Data[LAN_REG_RX_DP_CTRL]=Lan_GetRegDW(RX_DP_CTRL);
+		ioctlData->Data[LAN_REG_RX_FIFO_INF]=Lan_GetRegDW(RX_FIFO_INF);
+		ioctlData->Data[LAN_REG_TX_FIFO_INF]=Lan_GetRegDW(TX_FIFO_INF);
+		ioctlData->Data[LAN_REG_PMT_CTRL]=Lan_GetRegDW(PMT_CTRL);
+		ioctlData->Data[LAN_REG_GPIO_CFG]=Lan_GetRegDW(GPIO_CFG);
+		ioctlData->Data[LAN_REG_GPT_CFG]=Lan_GetRegDW(GPT_CFG);
+		ioctlData->Data[LAN_REG_GPT_CNT]=Lan_GetRegDW(GPT_CNT);
+		ioctlData->Data[LAN_REG_FPGA_REV]=Lan_GetRegDW(FPGA_REV);
+		ioctlData->Data[LAN_REG_ENDIAN]=Lan_GetRegDW(ENDIAN);
+		ioctlData->Data[LAN_REG_FREE_RUN]=Lan_GetRegDW(FREE_RUN);
+		ioctlData->Data[LAN_REG_RX_DROP]=Lan_GetRegDW(RX_DROP);
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[LAN_REG_MAC_CSR_CMD]=Lan_GetRegDW(MAC_CSR_CMD);
+			ioctlData->Data[LAN_REG_MAC_CSR_DATA]=Lan_GetRegDW(MAC_CSR_DATA);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+		} else {
+			ioctlData->Data[LAN_REG_MAC_CSR_CMD]=Lan_GetRegDW(MAC_CSR_CMD);
+			ioctlData->Data[LAN_REG_MAC_CSR_DATA]=Lan_GetRegDW(MAC_CSR_DATA);
+		}
+		ioctlData->Data[LAN_REG_AFC_CFG]=Lan_GetRegDW(AFC_CFG);
+		ioctlData->Data[LAN_REG_E2P_CMD]=Lan_GetRegDW(E2P_CMD);
+		ioctlData->Data[LAN_REG_E2P_DATA]=Lan_GetRegDW(E2P_DATA);
+		success=TRUE;
+		break;
+	case COMMAND_DUMP_MAC_REGS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[MAC_REG_MAC_CR]=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			ioctlData->Data[MAC_REG_ADDRH]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			ioctlData->Data[MAC_REG_ADDRL]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			ioctlData->Data[MAC_REG_HASHH]=Mac_GetRegDW(privateData,HASHH,keyCode);
+			ioctlData->Data[MAC_REG_HASHL]=Mac_GetRegDW(privateData,HASHL,keyCode);
+			ioctlData->Data[MAC_REG_MII_ACC]=Mac_GetRegDW(privateData,MII_ACC,keyCode);
+			ioctlData->Data[MAC_REG_MII_DATA]=Mac_GetRegDW(privateData,MII_DATA,keyCode);
+			ioctlData->Data[MAC_REG_FLOW]=Mac_GetRegDW(privateData,FLOW,keyCode);
+			ioctlData->Data[MAC_REG_VLAN1]=Mac_GetRegDW(privateData,VLAN1,keyCode);
+			ioctlData->Data[MAC_REG_VLAN2]=Mac_GetRegDW(privateData,VLAN2,keyCode);
+			ioctlData->Data[MAC_REG_WUFF]=Mac_GetRegDW(privateData,WUFF,keyCode);
+			ioctlData->Data[MAC_REG_WUCSR]=Mac_GetRegDW(privateData,WUCSR,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Mac Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+	case COMMAND_DUMP_PHY_REGS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[PHY_REG_0]=Phy_GetRegW(privateData,0,keyCode);
+			ioctlData->Data[PHY_REG_1]=Phy_GetRegW(privateData,1,keyCode);
+			ioctlData->Data[PHY_REG_2]=Phy_GetRegW(privateData,2,keyCode);
+			ioctlData->Data[PHY_REG_3]=Phy_GetRegW(privateData,3,keyCode);
+			ioctlData->Data[PHY_REG_4]=Phy_GetRegW(privateData,4,keyCode);
+			ioctlData->Data[PHY_REG_5]=Phy_GetRegW(privateData,5,keyCode);
+			ioctlData->Data[PHY_REG_6]=Phy_GetRegW(privateData,6,keyCode);
+			ioctlData->Data[PHY_REG_16]=Phy_GetRegW(privateData,16,keyCode);
+			ioctlData->Data[PHY_REG_17]=Phy_GetRegW(privateData,17,keyCode);
+			ioctlData->Data[PHY_REG_18]=Phy_GetRegW(privateData,18,keyCode);
+			ioctlData->Data[PHY_REG_20]=Phy_GetRegW(privateData,20,keyCode);
+			ioctlData->Data[PHY_REG_21]=Phy_GetRegW(privateData,21,keyCode);
+			ioctlData->Data[PHY_REG_22]=Phy_GetRegW(privateData,22,keyCode);
+			ioctlData->Data[PHY_REG_23]=Phy_GetRegW(privateData,23,keyCode);
+			ioctlData->Data[PHY_REG_27]=Phy_GetRegW(privateData,27,keyCode);
+			ioctlData->Data[PHY_REG_28]=Phy_GetRegW(privateData,28,keyCode);
+			ioctlData->Data[PHY_REG_29]=Phy_GetRegW(privateData,29,keyCode);
+			ioctlData->Data[PHY_REG_30]=Phy_GetRegW(privateData,30,keyCode);
+			ioctlData->Data[PHY_REG_31]=Phy_GetRegW(privateData,31,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Phy Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+	case COMMAND_DUMP_EEPROM:
+		{
+			BYTE data=0;
+			BYTE index=0;
+			Eeprom_EnableAccess(privateData);
+			success=TRUE;
+			for(index=0;index<8;index++) {
+				if(Eeprom_ReadLocation(privateData,index,&data)) {
+					ioctlData->Data[index]=(DWORD)data;
+				} else {
+					success=FALSE;
+					break;
+				}
+			}
+			Eeprom_DisableAccess(privateData);
+		};break;
+	case COMMAND_GET_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[0]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			ioctlData->Data[1]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+
+	case COMMAND_SET_MAC_ADDRESS:
+		if(privateData->LanInitialized)
+		{
+			DWORD dwLow32=ioctlData->Data[1];
+			DWORD dwHigh16=ioctlData->Data[0];
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+			Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_LOAD_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			Eeprom_EnableAccess(privateData);
+			if(Eeprom_Reload(privateData)) {
+				if(Eeprom_IsMacAddressLoaded(privateData)) {
+					DWORD dwIntFlags=0;
+					VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+					ioctlData->Data[0]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+					ioctlData->Data[1]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+					Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+					success=TRUE;
+				} else {
+					SMSC_WARNING("Failed to Load Mac Address(1)");
+				}
+			} else {
+				SMSC_WARNING("Failed to Load Mac Address(2)");
+			}
+			Eeprom_DisableAccess(privateData);
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_SAVE_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			if(Eeprom_SaveMacAddress(privateData,
+				ioctlData->Data[0],ioctlData->Data[1])) {
+				success=TRUE;
+			}
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_SET_DEBUG_MODE:
+		debug_mode=ioctlData->Data[0];
+		if(debug_mode&0x04UL) {
+			if(OLD_REGISTERS(privateData))
+			{
+				g_GpioSetting=0x00270700UL;
+			} else {
+				g_GpioSetting=0x00670700UL;
+			}
+			Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+		} else {
+			Lan_SetRegDW(GPIO_CFG,0x70070000);
+		}
+		success=TRUE;
+		break;
+	case COMMAND_SET_LINK_MODE:
+		link_mode=(ioctlData->Data[0]&0x7FUL);
+		if(privateData->LanInitialized) {
+			Phy_SetLink(privateData,link_mode);
+		}
+		success=TRUE;
+		break;
+	case COMMAND_GET_LINK_MODE:
+		ioctlData->Data[0]=link_mode;
+		success=TRUE;
+		break;
+	case COMMAND_CHECK_LINK:
+		Phy_UpdateLinkMode(privateData);
+		success=TRUE;
+		break;
+	case COMMAND_READ_BYTE:
+		ioctlData->Data[1]=(*((volatile BYTE *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_READ_WORD:
+		ioctlData->Data[1]=(*((volatile WORD *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_READ_DWORD:
+		ioctlData->Data[1]=(*((volatile DWORD *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_BYTE:
+		(*((volatile BYTE *)(ioctlData->Data[0])))=
+			((BYTE)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_WORD:
+		(*((volatile WORD *)(ioctlData->Data[0])))=
+			((WORD)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_DWORD:
+		(*((volatile DWORD *)(ioctlData->Data[0])))=
+			((DWORD)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	default:break;//make lint happy
+	}
+
+DONE:
+	if((success)&&(ioctlData!=NULL)) {
+		ioctlData->dwSignature=SMSC9118_DRIVER_SIGNATURE;
+		return 0;
+	}
+//	SMSC_TRACE("<--Smsc9118_do_ioctl");
+	return -1;
+}
+
+//returns time1-time2;
+TIME_SPAN Gpt_FreeRunCompare(DWORD time1,DWORD time2)
+{
+	return ((TIME_SPAN)(time1-time2));
+}
+void Gpt_ScheduleInterrupt(PPRIVATE_DATA privateData,TIME_SPAN timeSpan)
+{
+	DWORD timerValue=0;
+	if(timeSpan<0) timeSpan=0;
+	timerValue=(DWORD)timeSpan;
+	if((timerValue%2500)>=1250) {
+		timerValue=(timerValue/2500)+1;
+	} else {
+		timerValue=(timerValue/2500);
+	}
+	if(timerValue>0x0000FFFFUL) {
+		timerValue=0x0000FFFF;
+	}
+	Lan_SetRegDW(GPT_CFG,(timerValue|GPT_CFG_TIMER_EN_));
+	Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+}
+
+void Gpt_CancelInterrupt(PPRIVATE_DATA privateData)
+{
+	Lan_SetRegDW(GPT_CFG,0UL);
+	Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+}
+
+void Gpt_ScheduleCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData),
+	DWORD callBackTime)
+{
+	DWORD slot_index=GPT_SCHEDULE_DEPTH;
+	BOOLEAN result=FALSE;
+	if((callBackFunction!=NULL)&&(callBackTime!=0)) {
+		DWORD dwIntFlags=0;
+		SMSC_ASSERT(privateData!=NULL);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]==NULL) {
+					if(!result) {
+						result=TRUE;
+						//lint -save
+						//lint -e611 //suspicious cast
+						privateData->GptFunction[index]=(void *)callBackFunction;
+						//lint -restore_
+						privateData->GptCallTime[index]=currentTime+(2500*callBackTime);
+						timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+						if(nextCallTime>timeSpan) {
+							nextCallTime=timeSpan;
+							rescheduleRequired=TRUE;
+							slot_index = index;
+						}
+					}
+				} else {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(nextCallTime>=timeSpan) {
+						nextCallTime=timeSpan;
+						rescheduleRequired=FALSE;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				privateData->Gpt_scheduled_slot_index = slot_index;
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+	}
+	if(!result) {
+		SMSC_WARNING("Gpt_ScheduleCallBack: Failed");
+	}
+}
+
+void Gpt_CancelCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData))
+{
+	BOOLEAN result=FALSE;
+	if(callBackFunction!=NULL) {
+		DWORD dwIntFlags=0;
+		SMSC_ASSERT(privateData!=NULL);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]==callBackFunction) {
+					result=TRUE;
+					//lint -save
+					//lint -e611 //suspicious cast
+					privateData->GptFunction[index]=(void *)NULL;
+					// cancelled time will not need a
+					// re-scheduled
+
+					// re-scheduled is done at other
+					// non-null slots
+				}
+				else if(privateData->GptFunction[index]!=NULL) {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					// if this scheduled time is earlier
+					// than current scheduled time
+					// AND not a duplicated one
+					if(nextCallTime>=timeSpan && privateData->Gpt_scheduled_slot_index != index) {
+						nextCallTime=timeSpan;
+						rescheduleRequired=TRUE;
+						privateData->Gpt_scheduled_slot_index = index;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+			else if (privateData->Gpt_scheduled_slot_index==GPT_SCHEDULE_DEPTH) {
+				Gpt_CancelInterrupt(privateData);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+	}
+	if(!result) {
+		SMSC_WARNING("Gpt_CancelCallBack: Failed");
+	}
+}
+
+BOOLEAN Gpt_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(dwIntSts&INT_STS_GPT_INT_)
+	{
+		DWORD dwIntFlags=0;
+		Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]!=NULL) {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(timeSpan<1250) {
+						void (*callBackFunction)(PPRIVATE_DATA privateData);
+						callBackFunction=privateData->GptFunction[index];
+						privateData->GptFunction[index]=NULL;
+						spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+						privateData->Gpt_scheduled_slot_index = GPT_SCHEDULE_DEPTH;
+						callBackFunction(privateData);
+						spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+					}
+				}
+			}
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]!=NULL) {
+					rescheduleRequired=TRUE;
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(nextCallTime>timeSpan) {
+						nextCallTime=timeSpan;
+						privateData->Gpt_scheduled_slot_index = index;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+void GptCB_RxCompleteMulticast(PPRIVATE_DATA privateData)
+{
+	Rx_CompleteMulticastUpdate (privateData);
+}
+
+void GptCB_RestartBurst(PPRIVATE_DATA privateData)
+{
+	if(privateData->RxFlowControlActive) {
+		privateData->RxFlowBurstActive=TRUE;
+		if(privateData->RxFlowBurstWorkLoad>privateData->RxFlowBurstMaxWorkLoad) {
+			privateData->RxFlowBurstWorkLoad-=privateData->RxFlowBurstMaxWorkLoad;
+		} else {
+			privateData->RxFlowBurstWorkLoad=0;
+		}
+		Gpt_ScheduleCallBack(privateData,GptCB_RestartBurst,
+				privateData->RxFlowParameters.BurstPeriod);
+	}
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+void GptCB_MeasureRxThroughput(PPRIVATE_DATA privateData)
+{
+	if(privateData->RxFlowMeasuredMaxThroughput<privateData->RxFlowCurrentThroughput) {
+		privateData->RxFlowMeasuredMaxThroughput=privateData->RxFlowCurrentThroughput;
+	}
+	if(privateData->RxFlowMeasuredMaxPacketCount<privateData->RxFlowCurrentPacketCount) {
+		privateData->RxFlowMeasuredMaxPacketCount=privateData->RxFlowCurrentPacketCount;
+	}
+	if(privateData->RxFlowCurrentThroughput!=0) {
+		if(privateData->RxFlowMaxWorkLoad!=0) {
+			if(!(privateData->RxFlowControlActive)) {
+				DWORD activationLevel=
+					(privateData->RxFlowMaxWorkLoad*(100+RX_FLOW_ACTIVATION))/100;
+				if(privateData->RxFlowCurrentWorkLoad>=activationLevel) {
+					privateData->RxFlowControlActive=TRUE;
+					privateData->RxFlowBurstActive=TRUE;
+					privateData->RxFlowBurstWorkLoad=0;
+					Gpt_ScheduleCallBack(privateData,GptCB_RestartBurst,
+							privateData->RxFlowParameters.BurstPeriod);
+					//SET_GPIO(GP_TX);
+				}
+			} else {
+				DWORD deactivationLevel=
+					(privateData->RxFlowMaxWorkLoad*(100-RX_FLOW_DEACTIVATION))/100;
+				if(privateData->RxFlowCurrentWorkLoad<=deactivationLevel) {
+					privateData->RxFlowControlActive=FALSE;
+					//CLEAR_GPIO(GP_TX);
+				}
+			}
+		}
+		privateData->RxFlowCurrentThroughput=0;
+		privateData->RxFlowCurrentPacketCount=0;
+		privateData->RxFlowCurrentWorkLoad=0;
+		Gpt_ScheduleCallBack(privateData,GptCB_MeasureRxThroughput,1000);
+	} else {
+		if(privateData->RxFlowMaxWorkLoad!=0) {
+			if(privateData->RxFlowControlActive) {
+				privateData->RxFlowControlActive=FALSE;
+				//CLEAR_GPIO(GP_TX);
+			}
+		}
+		privateData->MeasuringRxThroughput=FALSE;
+	}
+}
+
+irqreturn_t Smsc9118_ISR(int Irq, void *dev_id)
+{
+	DWORD dwIntCfg=0;
+	DWORD dwIntSts=0;
+	DWORD dwIntEn=0;
+	DWORD dwIntBits=0;
+	PPRIVATE_DATA privateData=(PPRIVATE_DATA)dev_id;
+	BOOLEAN serviced=FALSE;
+
+	Irq=Irq;//make lint happy
+
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc9118_ISR(privateData==NULL)");
+		goto DONE;
+	}
+	if(privateData->dwLanBase==0) {
+		SMSC_WARNING("Smsc9118_ISR(dwLanBase==0)");
+		goto DONE;
+	}
+	SET_GPIO(GP_ISR);
+	dwIntCfg=Lan_GetRegDW(INT_CFG);
+	if((dwIntCfg&0x00001100)!=0x00001100) {
+		SMSC_TRACE("In ISR, not my interrupt, dwIntCfg=0x%08lX",
+			dwIntCfg);
+		goto ALMOST_DONE;
+	}
+
+	{
+		DWORD reservedBits;
+		if(OLD_REGISTERS(privateData)) {
+			reservedBits=0x00FFEEEEUL;
+		} else {
+			reservedBits=0x00FFCEEEUL;
+		}
+		if(dwIntCfg&reservedBits) {
+			SMSC_WARNING("In ISR, reserved bits are high.");
+			//this could mean surprise removal
+			goto ALMOST_DONE;
+		}
+	}
+
+	dwIntSts=Lan_GetRegDW(INT_STS);
+	dwIntEn=Lan_GetRegDW(INT_EN);
+	dwIntBits=dwIntSts&dwIntEn;
+	privateData->LastIntStatus3=privateData->LastIntStatus2;
+	privateData->LastIntStatus2=privateData->LastIntStatus1;
+	privateData->LastIntStatus1=dwIntBits;
+	if(Lan_HandleSoftwareInterrupt(privateData,dwIntBits)) {
+		serviced=TRUE;
+	}
+	if(Gpt_HandleInterrupt(privateData,dwIntBits)) {
+		serviced=TRUE;
+	}
+	if(Tx_HandleInterrupt(privateData,dwIntBits)) {
+		serviced=TRUE;
+	}
+	if(RxStop_HandleInterrupt(privateData,dwIntBits)) {
+		serviced=TRUE;
+	}
+	if(Rx_HandleInterrupt(privateData,dwIntBits)) {
+		serviced=TRUE;
+	}
+
+	if(!serviced) {
+		SMSC_WARNING("unserviced interrupt dwIntCfg=0x%08lX,dwIntSts=0x%08lX,dwIntEn=0x%08lX,dwIntBits=0x%08lX",
+			dwIntCfg,dwIntSts,dwIntEn,dwIntBits);
+	}
+
+ALMOST_DONE:
+	CLEAR_GPIO(GP_ISR);
+DONE:
+	return IRQ_RETVAL(serviced);
+}
+
+#ifdef USE_PHY_WORK_AROUND
+BOOLEAN Phy_Reset(PPRIVATE_DATA privateData,VL_KEY keyCode)
+{
+	BOOLEAN result=FALSE;
+	WORD wTemp=0;
+	DWORD dwLoopCount=100000;
+	SMSC_TRACE("Performing PHY BCR Reset");
+	Phy_SetRegW(privateData,PHY_BCR,PHY_BCR_RESET_,keyCode);
+	do {
+		udelay(10);
+		wTemp=Phy_GetRegW(privateData,PHY_BCR,keyCode);
+		dwLoopCount--;
+	} while((dwLoopCount>0)&&(wTemp&PHY_BCR_RESET_));
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("Phy Reset failed to complete.");
+		goto DONE;
+	}
+	//extra delay required because the phy may not be completed with its reset
+	//  when PHY_BCR_RESET_ is cleared.
+	//  They say 256 uS is enough delay but I'm using 500 here to be safe
+	udelay(500);
+	result=TRUE;
+DONE:
+	return result;
+}
+
+DWORD Phy_LBT_GetTxStatus(PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		if(result!=0x00800000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		if(result!=0x00000000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	}
+	return result;
+}
+
+DWORD Phy_LBT_GetRxStatus(PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(RX_FIFO_INF);
+	if(result&0x00FF0000UL) {
+		//Rx status is available, read it
+		result=Lan_GetRegDW(RX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+	return result;
+}
+
+BOOLEAN Phy_TransmitTestPacket(PPRIVATE_DATA privateData)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwLoopCount=0;
+	DWORD dwTxCmdA=0;
+	DWORD dwTxCmdB=0;
+	DWORD dwStatus=0;
+
+	//write Tx Packet to 118
+	dwTxCmdA=
+		((((DWORD)(privateData->LoopBackTxPacket))&0x03UL)<<16) | //DWORD alignment adjustment
+		TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+		((DWORD)(MIN_PACKET_SIZE));
+	dwTxCmdB=
+		(((DWORD)(MIN_PACKET_SIZE))<<16) |
+		((DWORD)(MIN_PACKET_SIZE));
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+	Platform_WriteFifo(
+		privateData->dwLanBase,
+		(DWORD *)(((DWORD)(privateData->LoopBackTxPacket))&0xFFFFFFFCUL),
+		(((DWORD)(MIN_PACKET_SIZE))+3+
+		(((DWORD)(privateData->LoopBackTxPacket))&0x03UL))>>2);
+
+	//wait till transmit is done
+	dwLoopCount=60;
+	while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetTxStatus(privateData))==0)) {
+		udelay(5);
+		dwLoopCount--;
+	}
+	if(dwStatus==0) {
+		SMSC_WARNING("Failed to Transmit during Packet Test");
+		goto DONE;
+	}
+	if(dwStatus&0x00008000UL) {
+		SMSC_WARNING("Transmit encountered errors during Packet Test");
+		goto DONE;
+	}
+DONE:
+	return result;
+}
+
+BOOLEAN Phy_CheckLoopBackPacket(PPRIVATE_DATA privateData)
+
+{
+	BOOLEAN result=FALSE;
+	DWORD tryCount=0;
+	DWORD dwLoopCount=0;
+	for(tryCount=0;tryCount<10;tryCount++)
+	{
+		DWORD dwTxCmdA=0;
+		DWORD dwTxCmdB=0;
+		DWORD dwStatus=0;
+		DWORD dwPacketLength=0;
+
+		//zero-out Rx Packet memory
+		memset(privateData->LoopBackRxPacket,0,MIN_PACKET_SIZE);
+
+		//write Tx Packet to 118
+		dwTxCmdA=
+			((((DWORD)(privateData->LoopBackTxPacket))&0x03UL)<<16) | //DWORD alignment adjustment
+			TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+			((DWORD)(MIN_PACKET_SIZE));
+		dwTxCmdB=
+			(((DWORD)(MIN_PACKET_SIZE))<<16) |
+			((DWORD)(MIN_PACKET_SIZE));
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+		Platform_WriteFifo(
+			privateData->dwLanBase,
+			(DWORD *)(((DWORD)(privateData->LoopBackTxPacket))&0xFFFFFFFCUL),
+			(((DWORD)(MIN_PACKET_SIZE))+3+
+			(((DWORD)(privateData->LoopBackTxPacket))&0x03UL))>>2);
+
+		//wait till transmit is done
+		dwLoopCount=60;
+		while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetTxStatus(privateData))==0)) {
+			udelay(5);
+			dwLoopCount--;
+		}
+		if(dwStatus==0) {
+			SMSC_WARNING("Failed to Transmit during Loop Back Test");
+			continue;
+		}
+		if(dwStatus&0x00008000UL) {
+			SMSC_WARNING("Transmit encountered errors during Loop Back Test");
+			continue;
+		}
+
+		//wait till receive is done
+		dwLoopCount=60;
+		while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetRxStatus(privateData))==0))
+		{
+	         udelay(5);
+	         dwLoopCount--;
+		}
+		if(dwStatus==0) {
+			SMSC_WARNING("Failed to Receive during Loop Back Test");
+			continue;
+		}
+		if(dwStatus&RX_STS_ES_)
+		{
+			SMSC_WARNING("Receive encountered errors during Loop Back Test");
+			continue;
+		}
+
+		dwPacketLength=((dwStatus&0x3FFF0000UL)>>16);
+
+		Platform_ReadFifo(
+			privateData->dwLanBase,
+			((DWORD *)(privateData->LoopBackRxPacket)),
+			(dwPacketLength+3+(((DWORD)(privateData->LoopBackRxPacket))&0x03UL))>>2);
+
+		if(dwPacketLength!=(MIN_PACKET_SIZE+4)) {
+			SMSC_WARNING("Unexpected packet size during loop back test, size=%ld, will retry",dwPacketLength);
+		} else {
+			DWORD byteIndex=0;
+			BOOLEAN foundMissMatch=FALSE;
+			for(byteIndex=0;byteIndex<MIN_PACKET_SIZE;byteIndex++) {
+				if(privateData->LoopBackTxPacket[byteIndex]!=privateData->LoopBackRxPacket[byteIndex])
+				{
+					foundMissMatch=TRUE;
+					break;
+				}
+			}
+			if(!foundMissMatch) {
+				SMSC_TRACE("Successfully Verified Loop Back Packet");
+				result=TRUE;
+				goto DONE;
+			} else {
+				SMSC_WARNING("Data miss match during loop back test, will retry.");
+			}
+		}
+	}
+DONE:
+	return result;
+}
+
+BOOLEAN Phy_LoopBackTest(PPRIVATE_DATA privateData)
+{
+	BOOLEAN result=FALSE;
+	DWORD byteIndex=0;
+	DWORD tryCount=0;
+//	DWORD failed=0;
+	//Initialize Tx Packet
+	for(byteIndex=0;byteIndex<6;byteIndex++) {
+		//use broadcast destination address
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)0xFF;
+	}
+	for(byteIndex=6;byteIndex<12;byteIndex++) {
+		//use incrementing source address
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)byteIndex;
+	}
+	//Set length type field
+	privateData->LoopBackTxPacket[12]=0x00;
+	privateData->LoopBackTxPacket[13]=0x00;
+	for(byteIndex=14;byteIndex<MIN_PACKET_SIZE;byteIndex++)
+	{
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)byteIndex;
+	}
+//TRY_AGAIN:
+	{
+		DWORD dwRegVal=Lan_GetRegDW(HW_CFG);
+		dwRegVal&=(HW_CFG_TX_FIF_SZ_|0x00000FFFUL);
+		dwRegVal|=HW_CFG_SF_;
+		Lan_SetRegDW(HW_CFG,dwRegVal);
+	}
+	Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+
+	Lan_SetRegDW(RX_CFG,(((DWORD)(privateData->LoopBackRxPacket))&0x03)<<8);
+
+	{
+
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	//Set Phy to 10/FD, no ANEG,
+	Phy_SetRegW(privateData,PHY_BCR,0x0100,keyCode);
+
+	//enable MAC Tx/Rx, FD
+	Mac_SetRegDW(privateData,MAC_CR,MAC_CR_FDPX_|MAC_CR_TXEN_|MAC_CR_RXEN_,keyCode);
+
+//	Phy_TransmitTestPacket(privateData);
+
+	//set Phy to loopback mode
+	Phy_SetRegW(privateData,PHY_BCR,0x4100,keyCode);
+
+	for(tryCount=0;tryCount<10;tryCount++) {
+		if(Phy_CheckLoopBackPacket(privateData))
+		{
+			result=TRUE;
+			goto DONE;
+		}
+		privateData->dwResetCount++;
+		//disable MAC rx
+		Mac_SetRegDW(privateData,MAC_CR,0UL,keyCode);
+		Phy_Reset(privateData,keyCode);
+
+		//Set Phy to 10/FD, no ANEG, and Loopbackmode
+		Phy_SetRegW(privateData,PHY_BCR,0x4100,keyCode);
+
+		//enable MAC Tx/Rx, FD
+		Mac_SetRegDW(privateData,MAC_CR,MAC_CR_FDPX_|MAC_CR_TXEN_|MAC_CR_RXEN_,keyCode);
+	}
+//	if(failed<2) {
+//		if(tryCount>=10) {
+//			DWORD timeOut=10000;
+//			Lan_ShowRegs(privateData);
+//			SMSC_TRACE("Performing full reset");
+//			privateData->Lan9118->HW_CFG=HW_CFG_SRST_;
+//			while((timeOut>0)&&(privateData->Lan9118->HW_CFG&HW_CFG_SRST_)) {
+//				udelay(1);
+//				timeOut--;
+//			}
+//			failed++;
+//			goto TRY_AGAIN;
+//		}
+//	}
+DONE:
+	//disable MAC
+	Mac_SetRegDW(privateData,MAC_CR,0UL,keyCode);
+	//Cancel Phy loopback mode
+	Phy_SetRegW(privateData,PHY_BCR,0U,keyCode);
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	Lan_SetRegDW(TX_CFG,0UL);
+	Lan_SetRegDW(RX_CFG,0UL);
+
+	return result;
+}
+
+#endif //USE_PHY_WORK_AROUND
+void Phy_SetLink(PPRIVATE_DATA privateData,
+				 DWORD dwLinkRequest)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if(dwLinkRequest&LINK_AUTO_NEGOTIATE) {
+		WORD wTemp;
+		wTemp=Phy_GetRegW(privateData,
+			PHY_ANEG_ADV,keyCode);
+		wTemp&=~PHY_ANEG_ADV_PAUSE_;
+		if(dwLinkRequest&LINK_ASYMMETRIC_PAUSE) {
+			wTemp|=PHY_ANEG_ADV_ASYMP_;
+		}
+		if(dwLinkRequest&LINK_SYMMETRIC_PAUSE) {
+			wTemp|=PHY_ANEG_ADV_SYMP_;
+		}
+		wTemp&=~PHY_ANEG_ADV_SPEED_;
+		if(dwLinkRequest&LINK_SPEED_10HD) {
+			wTemp|=PHY_ANEG_ADV_10H_;
+		}
+		if(dwLinkRequest&LINK_SPEED_10FD) {
+			wTemp|=PHY_ANEG_ADV_10F_;
+		}
+		if(dwLinkRequest&LINK_SPEED_100HD) {
+			wTemp|=PHY_ANEG_ADV_100H_;
+		}
+		if(dwLinkRequest&LINK_SPEED_100FD) {
+			wTemp|=PHY_ANEG_ADV_100F_;
+		}
+		Phy_SetRegW(privateData,PHY_ANEG_ADV,wTemp,keyCode);
+
+		// begin to establish link
+		privateData->dwRemoteFaultCount=0;
+		Phy_SetRegW(privateData,
+			PHY_BCR,
+			PHY_BCR_AUTO_NEG_ENABLE_|
+			PHY_BCR_RESTART_AUTO_NEG_,
+			keyCode);
+	} else {
+		WORD wTemp=0;
+		if(dwLinkRequest&(LINK_SPEED_100FD)) {
+			dwLinkRequest=LINK_SPEED_100FD;
+		} else if(dwLinkRequest&(LINK_SPEED_100HD)) {
+			dwLinkRequest=LINK_SPEED_100HD;
+		} else if(dwLinkRequest&(LINK_SPEED_10FD)) {
+			dwLinkRequest=LINK_SPEED_10FD;
+		} else if(dwLinkRequest&(LINK_SPEED_10HD)) {
+			dwLinkRequest=LINK_SPEED_10HD;
+		}
+		if(dwLinkRequest&(LINK_SPEED_10FD|LINK_SPEED_100FD)) {
+			wTemp|=PHY_BCR_DUPLEX_MODE_;
+		}
+		if(dwLinkRequest&(LINK_SPEED_100HD|LINK_SPEED_100FD)) {
+			wTemp|=PHY_BCR_SPEED_SELECT_;
+		}
+		Phy_SetRegW(privateData,PHY_BCR,wTemp,keyCode);
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+BOOLEAN Phy_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwPhyAddr,
+	DWORD dwLinkRequest)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwTemp=0;
+	WORD wTemp=0;
+	DWORD dwLoopCount=0;
+
+	SMSC_TRACE("-->Phy_Initialize");
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	SMSC_ASSERT(dwLinkRequest<=0x7FUL);
+
+	if(dwPhyAddr!=0xFFFFFFFFUL) {
+		switch(privateData->dwIdRev&0xFFFF0000) {
+		case 0x117A0000UL:
+		case 0x115A0000UL:
+			goto EXTERNAL_PHY_SUPPORTED;
+		case 0x01170000UL:
+		case 0x01150000UL:
+			if(privateData->dwIdRev&0x0000FFFF) {
+				DWORD dwHwCfg=0;
+EXTERNAL_PHY_SUPPORTED:
+				dwHwCfg=Lan_GetRegDW(HW_CFG);
+				if(dwHwCfg&HW_CFG_EXT_PHY_DET_) {
+                    //External phy is requested, supported, and detected
+					//Attempt to switch
+					//NOTE: Assuming Rx and Tx are stopped
+					//  because Phy_Initialize is called before
+					//  Rx_Initialize and Tx_Initialize
+					WORD wPhyId1=0;
+					WORD wPhyId2=0;
+
+					//Disable phy clocks to the mac
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);//wait for clocks to acutally stop
+
+					dwHwCfg|=HW_CFG_EXT_PHY_EN_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_EXT_PHY_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);//wait for clocks to actually start
+
+					dwHwCfg|=HW_CFG_SMI_SEL_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					{
+						DWORD dwIntFlags=0;
+						VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+						if(dwPhyAddr<=31) {
+							//only check the phy address specified
+							privateData->dwPhyAddress=dwPhyAddr;
+							wPhyId1=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+							wPhyId2=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+						} else {
+							//auto detect phy
+							DWORD address=0;
+							for(address=0;address<=31;address++) {
+								privateData->dwPhyAddress=address;
+								wPhyId1=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+								wPhyId2=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+								if((wPhyId1!=0xFFFFU)||(wPhyId2!=0xFFFFU)) {
+									SMSC_TRACE("Detected Phy at address = 0x%02lX = %ld",
+										address,address);
+									break;
+								}
+							}
+							if(address>=32) {
+								SMSC_WARNING("Failed to auto detect external phy");
+							}
+						}
+						Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+					}
+					if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+						SMSC_WARNING("External Phy is not accessable");
+						SMSC_WARNING("  using internal phy instead");
+						//revert back to interal phy settings.
+
+						//Disable phy clocks to the mac
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);//wait for clocks to actually stop
+
+						dwHwCfg&=(~HW_CFG_EXT_PHY_EN_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_INT_PHY_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);//wait for clocks to actually start
+
+						dwHwCfg&=(~HW_CFG_SMI_SEL_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						goto USE_INTERNAL_PHY;
+					} else {
+						SMSC_TRACE("Successfully switched to external phy");
+#ifdef USE_LED1_WORK_AROUND
+						privateData->NotUsingExtPhy=0;
+#endif
+					}
+				} else {
+					SMSC_WARNING("No External Phy Detected");
+					SMSC_WARNING("  using internal phy instead");
+					goto USE_INTERNAL_PHY;
+				}
+			} else {
+				SMSC_WARNING("External Phy is not supported");
+				SMSC_WARNING("  using internal phy instead");
+				goto USE_INTERNAL_PHY;
+			};break;
+		default:
+			SMSC_WARNING("External Phy is not supported");
+			SMSC_WARNING("  using internal phy instead");
+			goto USE_INTERNAL_PHY;
+		}
+	} else {
+USE_INTERNAL_PHY:
+		privateData->dwPhyAddress=1;
+#ifdef USE_LED1_WORK_AROUND
+		if(privateData->dwGeneration<=2) {
+			privateData->NotUsingExtPhy=1;
+		} else {
+			//Generation 3 or higher has the LED problem fixed
+			//  to disable the workaround pretend the phy is external
+			privateData->NotUsingExtPhy=0;
+		}
+#endif
+	}
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		dwTemp=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+		privateData->bPhyRev=((BYTE)(dwTemp&(0x0FUL)));
+		privateData->bPhyModel=((BYTE)((dwTemp>>4)&(0x3FUL)));
+		privateData->dwPhyId=((dwTemp&(0xFC00UL))<<8);
+		dwTemp=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+		privateData->dwPhyId|=((dwTemp&(0x0000FFFFUL))<<2);
+
+		SMSC_TRACE("dwPhyId==0x%08lX,bPhyModel==0x%02X,bPhyRev==0x%02X",
+			privateData->dwPhyId,
+			privateData->bPhyModel,
+			privateData->bPhyRev);
+
+		privateData->dwLinkSpeed=LINK_OFF;
+		privateData->dwLinkSettings=LINK_OFF;
+		//reset the PHY
+		Phy_SetRegW(privateData,PHY_BCR,PHY_BCR_RESET_,keyCode);
+	    dwLoopCount=100000;
+		do {
+
+			udelay(10);
+			wTemp=Phy_GetRegW(privateData,PHY_BCR,keyCode);
+			dwLoopCount--;
+		} while((dwLoopCount>0) && (wTemp&PHY_BCR_RESET_));
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("PHY reset failed to complete.");
+		goto DONE;
+	}
+
+#ifdef USE_PHY_WORK_AROUND
+	if(privateData->dwGeneration<=2) {
+		if(!Phy_LoopBackTest(privateData)) {
+			SMSC_WARNING("Failed Loop back test");
+			goto DONE;
+		} else {
+			SMSC_TRACE("Passed Loop Back Test");
+		}
+	}
+#endif
+	Phy_SetLink(privateData,dwLinkRequest);
+
+	init_timer(&(privateData->LinkPollingTimer));
+	privateData->LinkPollingTimer.function=Phy_CheckLink;
+	privateData->LinkPollingTimer.data=(unsigned long)privateData;
+	privateData->LinkPollingTimer.expires=jiffies+HZ;
+	add_timer(&(privateData->LinkPollingTimer));
+
+	result=TRUE;
+DONE:
+	SMSC_TRACE("<--Phy_Initialize, result=%s",result?"TRUE":"FALSE");
+	return result;
+}
+
+WORD Phy_GetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	VL_KEY keyCode)
+{
+	DWORD dwAddr=0;
+	int i=0;
+	WORD result=0xFFFFU;
+
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+
+	// confirm MII not busy
+	if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_GetRegW???");
+		result=0;
+		goto DONE;
+	}
+
+	// set the address, index & direction (read from PHY)
+	dwAddr = ((privateData->dwPhyAddress&0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6);
+	Mac_SetRegDW(privateData, MII_ACC, dwAddr,keyCode);
+
+	// wait for read to complete w/ timeout
+	for(i=0;i<100;i++) {
+		// see if MII is finished yet
+		if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			// get the read data from the MAC & return i
+			result=((WORD)Mac_GetRegDW(privateData, MII_DATA,keyCode));
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+
+DONE:
+	return result;
+}
+
+void Phy_SetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,WORD wVal,
+	VL_KEY keyCode)
+{
+	DWORD dwAddr=0;
+	int i=0;
+
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+
+	if(dwRegIndex==0) {
+		if((wVal&0x1200)==0x1200) {
+			privateData->wLastADVatRestart=privateData->wLastADV;
+		}
+	}
+	if(dwRegIndex==4) {
+		privateData->wLastADV=wVal;
+	}
+
+	// confirm MII not busy
+	if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_SetRegW???");
+		goto DONE;
+	}
+
+	// put the data to write in the MAC
+	Mac_SetRegDW(privateData, MII_DATA, (DWORD)wVal,keyCode);
+
+	// set the address, index & direction (write to PHY)
+	dwAddr = ((privateData->dwPhyAddress&0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6) | MII_ACC_MII_WRITE_;
+	Mac_SetRegDW(privateData, MII_ACC, dwAddr,keyCode);
+
+	// wait for write to complete w/ timeout
+	for(i=0;i<100;i++) {
+		// see if MII is finished yet
+		if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+DONE:
+	return;
+}
+
+void Phy_UpdateLinkMode(PPRIVATE_DATA privateData)
+{
+	DWORD dwOldLinkSpeed=privateData->dwLinkSpeed;
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+
+	Phy_GetLinkMode(privateData,keyCode);
+
+	if(dwOldLinkSpeed!=(privateData->dwLinkSpeed)) {
+		if(privateData->dwLinkSpeed!=LINK_OFF) {
+			DWORD dwRegVal=0;
+			switch(privateData->dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+				SMSC_TRACE("Link is now UP at 10Mbps HD");
+				break;
+			case LINK_SPEED_10FD:
+				SMSC_TRACE("Link is now UP at 10Mbps FD");
+				break;
+			case LINK_SPEED_100HD:
+				SMSC_TRACE("Link is now UP at 100Mbps HD");
+				break;
+			case LINK_SPEED_100FD:
+				SMSC_TRACE("Link is now UP at 100Mbps FD");
+				break;
+			default:
+				SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					privateData->dwLinkSpeed);
+				break;
+			}
+
+			dwRegVal=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			dwRegVal&=~(MAC_CR_FDPX_|MAC_CR_RCVOWN_);
+			switch(privateData->dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+			case LINK_SPEED_100HD:
+				dwRegVal|=MAC_CR_RCVOWN_;
+				break;
+			case LINK_SPEED_10FD:
+			case LINK_SPEED_100FD:
+				dwRegVal|=MAC_CR_FDPX_;
+				break;
+			default:break;//make lint happy
+			}
+
+			Mac_SetRegDW(privateData,
+				MAC_CR,dwRegVal,keyCode);
+
+			if(privateData->dwLinkSettings&LINK_AUTO_NEGOTIATE) {
+				WORD linkPartner=0;
+				WORD localLink=0;
+				localLink=Phy_GetRegW(privateData,4,keyCode);
+				linkPartner=Phy_GetRegW(privateData,5,keyCode);
+				switch(privateData->dwLinkSpeed) {
+				case LINK_SPEED_10FD:
+				case LINK_SPEED_100FD:
+					if(((localLink&linkPartner)&((WORD)0x0400U)) != ((WORD)0U)) {
+						//Enable PAUSE receive and transmit
+						Mac_SetRegDW(privateData,FLOW,0xFFFF0002UL,keyCode);
+						Lan_SetBitsDW(AFC_CFG,(afc_cfg&0x0000000FUL));
+					} else if(((localLink&((WORD)0x0C00U))==((WORD)0x0C00U)) &&
+							((linkPartner&((WORD)0x0C00U))==((WORD)0x0800U)))
+					{
+						//Enable PAUSE receive, disable PAUSE transmit
+						Mac_SetRegDW(privateData,FLOW,0xFFFF0002UL,keyCode);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					} else {
+						//Disable PAUSE receive and transmit
+						Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					};break;
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:break;//make lint happy
+				}
+				SMSC_TRACE("LAN9118: %s,%s,%s,%s,%s,%s",
+					(localLink&PHY_ANEG_ADV_ASYMP_)?"ASYMP":"     ",
+					(localLink&PHY_ANEG_ADV_SYMP_)?"SYMP ":"     ",
+					(localLink&PHY_ANEG_ADV_100F_)?"100FD":"     ",
+					(localLink&PHY_ANEG_ADV_100H_)?"100HD":"     ",
+					(localLink&PHY_ANEG_ADV_10F_)?"10FD ":"     ",
+					(localLink&PHY_ANEG_ADV_10H_)?"10HD ":"     ");
+
+				SMSC_TRACE("Partner: %s,%s,%s,%s,%s,%s",
+					(linkPartner&PHY_ANEG_LPA_ASYMP_)?"ASYMP":"     ",
+					(linkPartner&PHY_ANEG_LPA_SYMP_)?"SYMP ":"     ",
+					(linkPartner&PHY_ANEG_LPA_100FDX_)?"100FD":"     ",
+					(linkPartner&PHY_ANEG_LPA_100HDX_)?"100HD":"     ",
+					(linkPartner&PHY_ANEG_LPA_10FDX_)?"10FD ":"     ",
+					(linkPartner&PHY_ANEG_LPA_10HDX_)?"10HD ":"     ");
+			} else {
+				switch(privateData->dwLinkSpeed) {
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(privateData,FLOW,0x0UL,keyCode);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					Mac_SetRegDW(privateData,FLOW,0x0UL,keyCode);
+					Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				}
+			}
+			netif_carrier_on(privateData->dev);
+			Tx_WakeQueue(privateData,0x01);
+#ifdef USE_LED1_WORK_AROUND
+			if ((g_GpioSettingOriginal & GPIO_CFG_LED1_EN_) &&
+				privateData->NotUsingExtPhy)
+			{
+				// Restore orginal GPIO configuration
+				g_GpioSetting = g_GpioSettingOriginal;
+				Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+			}
+#endif // USE_LED1_WORK_AROUND
+		} else {
+			SMSC_TRACE("Link is now DOWN");
+			Tx_StopQueue(privateData,0x01);
+			netif_carrier_off(privateData->dev);
+			Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+			Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+#ifdef USE_LED1_WORK_AROUND
+			// Check global setting that LED1 usage is 10/100 indicator
+//			g_GpioSetting = Lan_GetRegDW(GPIO_CFG);
+			if ((g_GpioSetting & GPIO_CFG_LED1_EN_) &&
+				privateData->NotUsingExtPhy)
+			{
+				//Force 10/100 LED off, after saving orginal GPIO configuration
+				g_GpioSettingOriginal = g_GpioSetting;
+
+				g_GpioSetting &= ~GPIO_CFG_LED1_EN_;
+				g_GpioSetting |=
+					(GPIO_CFG_GPIOBUF0_|GPIO_CFG_GPIODIR0_|GPIO_CFG_GPIOD0_);
+				Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+			}
+#endif // USE_LED1_WORK_AROUND
+		}
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+void Phy_CheckLink(unsigned long ptr)
+{
+	PPRIVATE_DATA privateData=(PPRIVATE_DATA)ptr;
+	if(privateData==NULL) {
+		SMSC_WARNING("Phy_CheckLink(ptr==0)");
+		return;
+	}
+
+	//must call this twice
+	Phy_UpdateLinkMode(privateData);
+	Phy_UpdateLinkMode(privateData);
+
+	if(!(privateData->StopLinkPolling)) {
+		privateData->LinkPollingTimer.expires=jiffies+HZ;
+		add_timer(&(privateData->LinkPollingTimer));
+	}
+}
+
+void Phy_GetLinkMode(
+	PPRIVATE_DATA privateData,
+	VL_KEY keyCode)
+{
+	DWORD result=LINK_OFF;
+	WORD wRegVal=0;
+	WORD wRegBSR=Phy_GetRegW(
+		privateData,
+		PHY_BSR,keyCode);
+	privateData->dwLinkSettings=LINK_OFF;
+	if(wRegBSR&PHY_BSR_LINK_STATUS_) {
+		wRegVal=Phy_GetRegW(
+			privateData,
+			PHY_BCR,keyCode);
+		if(wRegVal&PHY_BCR_AUTO_NEG_ENABLE_) {
+			DWORD linkSettings=LINK_AUTO_NEGOTIATE;
+			WORD wRegADV=privateData->wLastADVatRestart;
+//					Phy_GetRegW(
+//						privateData,
+//						PHY_ANEG_ADV,keyCode);
+			WORD wRegLPA=Phy_GetRegW(
+				privateData,
+				PHY_ANEG_LPA,keyCode);
+			if(wRegADV&PHY_ANEG_ADV_ASYMP_) {
+				linkSettings|=LINK_ASYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_ADV_SYMP_) {
+				linkSettings|=LINK_SYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100FDX_) {
+				linkSettings|=LINK_SPEED_100FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100HDX_) {
+				linkSettings|=LINK_SPEED_100HD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10FDX_) {
+				linkSettings|=LINK_SPEED_10FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10HDX_) {
+				linkSettings|=LINK_SPEED_10HD;
+			}
+			privateData->dwLinkSettings=linkSettings;
+			wRegLPA&=wRegADV;
+			if(wRegLPA&PHY_ANEG_LPA_100FDX_) {
+				result=LINK_SPEED_100FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_100HDX_) {
+				result=LINK_SPEED_100HD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10FDX_) {
+				result=LINK_SPEED_10FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10HDX_) {
+				result=LINK_SPEED_10HD;
+			}
+		} else {
+			if(wRegVal&PHY_BCR_SPEED_SELECT_) {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					privateData->dwLinkSettings=result=LINK_SPEED_100FD;
+				} else {
+					privateData->dwLinkSettings=result=LINK_SPEED_100HD;
+				}
+			} else {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					privateData->dwLinkSettings=result=LINK_SPEED_10FD;
+				} else {
+					privateData->dwLinkSettings=result=LINK_SPEED_10HD;
+				}
+			}
+		}
+	}
+	privateData->dwLinkSpeed=result;
+}
+
+BOOLEAN Mac_Initialize(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	//This function is kept only as a place holder
+
+	return TRUE;
+}
+
+static BOOLEAN MacNotBusy(PPRIVATE_DATA privateData, VL_KEY keyCode)
+{
+	int i=0;
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	// wait for MAC not busy, w/ timeout
+	for(i=0;i<40;i++)
+	{
+		if((Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)==(0UL)) {
+			return TRUE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MAC not BUSY. MAC_CSR_CMD = 0x%08lX",
+		Lan_GetRegDW(MAC_CSR_CMD));
+	return FALSE;
+}
+
+DWORD Mac_GetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,VL_KEY keyCode)
+{
+	DWORD result=0xFFFFFFFFUL;
+	DWORD dwTemp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	// wait until not busy
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	// send the MAC Cmd w/ offset
+	Lan_SetRegDW(MAC_CSR_CMD,
+		((dwRegOffset & 0x000000FFUL) |
+		MAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);//to flush previous write
+	dwTemp=dwTemp;
+
+	// wait for the read to happen, w/ timeout
+	if (!MacNotBusy(privateData,keyCode))
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, waiting for MAC not busy after read");
+		goto DONE;
+	} else {
+		// finally, return the read data
+		result=Lan_GetRegDW(MAC_CSR_DATA);
+	}
+DONE:
+	return result;
+}
+
+void Mac_SetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,DWORD dwVal,VL_KEY keyCode)
+{
+	DWORD dwTemp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	// send the data to write
+	Lan_SetRegDW(MAC_CSR_DATA,dwVal);
+
+	// do the actual write
+	Lan_SetRegDW(MAC_CSR_CMD,((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);//force flush of previous write
+	dwTemp=dwTemp;
+
+	// wait for the write to complete, w/ timeout
+	if (!MacNotBusy(privateData,keyCode))
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, waiting for MAC not busy after write");
+	}
+DONE:
+	return;
+}
+
+#define TX_FIFO_LOW_THRESHOLD	(1600)
+
+void Tx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwTxDmaCh,
+	DWORD dwDmaThreshold)
+{
+	DWORD dwRegVal=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	dwRegVal=Lan_GetRegDW(HW_CFG);
+	dwRegVal&=(HW_CFG_TX_FIF_SZ_|0x00000FFFUL);
+	dwRegVal|=HW_CFG_SF_;
+	Lan_SetRegDW(HW_CFG,dwRegVal);
+
+	Lan_SetTDFL(privateData,0xFF);
+	Lan_EnableInterrupt(privateData,INT_EN_TDFA_EN_);
+
+	privateData->dwTxDmaThreshold=dwDmaThreshold;
+	privateData->dwTxDmaCh=dwTxDmaCh;
+	if(dwTxDmaCh>=TRANSFER_PIO) {
+		SMSC_TRACE("Tx will use PIO");
+	} else {
+		SMSC_TRACE("Tx will use DMA channel %ld",dwTxDmaCh);
+		SMSC_ASSERT(Platform_IsValidDmaChannel(dwTxDmaCh));
+		if(!Platform_DmaInitialize(
+			&(privateData->PlatformData),
+			dwTxDmaCh))
+		{
+			SMSC_WARNING("Failed Platform_DmaInitialize, dwTxDmaCh=%lu",dwTxDmaCh);
+		}
+		privateData->TxDmaXfer.dwLanReg=privateData->dwLanBase+TX_DATA_FIFO;
+		privateData->TxDmaXfer.pdwBuf=NULL;//this will be reset per dma request
+		privateData->TxDmaXfer.dwDmaCh=privateData->dwTxDmaCh;
+		privateData->TxDmaXfer.dwDwCnt=0;//this will be reset per dma request
+		privateData->TxDmaXfer.fMemWr=FALSE;
+	}
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		dwMacCr|=(MAC_CR_TXEN_|MAC_CR_HBDIS_);
+		Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+		Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	privateData->TxSkb=NULL;
+	spin_lock_init(&(privateData->TxSkbLock));
+	privateData->dwTxQueueDisableMask=0;
+	spin_lock_init(&(privateData->TxQueueLock));
+	spin_lock_init(&(privateData->TxCounterLock));
+	privateData->TxInitialized=TRUE;
+}
+
+BOOLEAN Tx_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(dwIntSts&INT_STS_TDFA_)
+	{
+		Lan_SetTDFL(privateData,0xFF);
+		Lan_SetRegDW(INT_STS,INT_STS_TDFA_);
+		Tx_WakeQueue(privateData,0x02UL);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+void Tx_StopQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource)
+{
+	DWORD intFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dev!=NULL);
+	SMSC_ASSERT(privateData->TxInitialized);
+	spin_lock_irqsave(&(privateData->TxQueueLock),intFlags);
+	if(privateData->dwTxQueueDisableMask==0) {
+		netif_stop_queue(privateData->dev);
+	}
+	privateData->dwTxQueueDisableMask|=dwSource;
+	spin_unlock_irqrestore(&(privateData->TxQueueLock),intFlags);
+}
+
+void Tx_WakeQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource)
+{
+	DWORD intFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dev!=NULL);
+	SMSC_ASSERT(privateData->TxInitialized);
+	spin_lock_irqsave(&(privateData->TxQueueLock),intFlags);
+	privateData->dwTxQueueDisableMask&=(~dwSource);
+	if(privateData->dwTxQueueDisableMask==0) {
+		netif_wake_queue(privateData->dev);
+	}
+	spin_unlock_irqrestore(&(privateData->TxQueueLock),intFlags);
+}
+
+static DWORD Tx_GetTxStatusCount(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		result>>=16;
+		if(result>0x80) {
+			SMSC_WARNING("TX_FIFO_INF_TSFREE_>0x80");
+			result=0x80;
+		}
+		result=0x80-result;
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		result>>=16;
+	}
+	return result;
+}
+
+void Tx_SendSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb)
+{
+	DWORD dwFreeSpace=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	if(privateData->dwTxDmaCh>=TRANSFER_PIO)
+	{
+		//Use PIO only
+		DWORD dwTxCmdA=0;
+		DWORD dwTxCmdB=0;
+		dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+		dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+		if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+			SMSC_WARNING("Tx Data Fifo Low, space available = %ld",dwFreeSpace);
+		}
+		dwTxCmdA=
+			((((DWORD)(skb->data))&0x03UL)<<16) | //DWORD alignment adjustment
+			TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+			((DWORD)(skb->len));
+		dwTxCmdB=
+			(((DWORD)(skb->len))<<16) |
+			((DWORD)(skb->len));
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+		Platform_WriteFifo(
+			privateData->dwLanBase,
+			(DWORD *)(((DWORD)(skb->data))&0xFFFFFFFCUL),
+			(((DWORD)(skb->len))+3+
+			(((DWORD)(skb->data))&0x03UL))>>2);
+		dwFreeSpace-=(skb->len+32);
+		dev_kfree_skb(skb);
+	}
+	else
+	{
+		//Use DMA and PIO
+		PPLATFORM_DATA platformData=&(privateData->PlatformData);
+		SMSC_ASSERT(TX_FIFO_LOW_THRESHOLD>(skb->len+32));
+
+		BUG_ON((privateData->dwTxQueueDisableMask & 0x04UL) != 0);
+		BUG_ON(privateData->TxSkb != NULL);
+
+		if(skb->len>=privateData->dwTxDmaThreshold)
+		{
+			//use DMA
+			DWORD dwTxCmdA;
+			DWORD dwTxCmdB;
+
+			//prepare for 16 byte alignment
+			dwTxCmdA=
+#if (PLATFORM_CACHE_LINE_BYTES == 16)
+				(0x01UL<<24)|//16 byte end alignment
+#endif
+#if (PLATFORM_CACHE_LINE_BYTES == 32)
+				(0x02UL<<24)|//32 byte end alignment
+#endif
+				((((DWORD)(skb->data))&(PLATFORM_CACHE_LINE_BYTES-1))<<16) |//16 Byte start alignment
+				TX_CMD_A_INT_FIRST_SEG_ |
+				TX_CMD_A_INT_LAST_SEG_ |
+				((DWORD)(skb->len));//buffer length
+			dwTxCmdB=
+				(((DWORD)(skb->len))<<16)|
+				((DWORD)(skb->len)&0x7FFUL);
+			privateData->TxDmaXfer.pdwBuf=
+				(DWORD *)(((DWORD)(skb->data))&
+					(~(PLATFORM_CACHE_LINE_BYTES-1)));
+			privateData->TxDmaXfer.dwDwCnt=
+				((((DWORD)(skb->len))+
+				(PLATFORM_CACHE_LINE_BYTES-1)+
+				(((DWORD)(skb->data))&
+					(PLATFORM_CACHE_LINE_BYTES-1)))&
+					(~(PLATFORM_CACHE_LINE_BYTES-1)))>>2;
+			Platform_CachePurge(
+				platformData,
+				privateData->TxDmaXfer.pdwBuf,
+				(privateData->TxDmaXfer.dwDwCnt)<<2);
+
+			spin_lock(&(privateData->TxSkbLock));
+			{
+				dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+				dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+				if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+					SMSC_WARNING("Tx DATA FIFO LOW, space available = %ld",dwFreeSpace);
+				}
+
+				Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+				Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+				if(!Platform_DmaStartXfer(platformData,&(privateData->TxDmaXfer), Tx_DmaCompletionCallback, privateData))
+				{
+					SMSC_WARNING("Failed Platform_DmaStartXfer");
+				}
+
+				dwFreeSpace-=(skb->len+32);
+				privateData->TxSkb=skb;
+			}
+			spin_unlock(&(privateData->TxSkbLock));
+
+			Tx_StopQueue(privateData,0x04UL);
+		}
+		else
+		{
+			//use PIO
+			DWORD dwTxCmdA=0;
+			DWORD dwTxCmdB=0;
+			dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+			dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+			if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+				SMSC_WARNING("Tx DATA FIFO LOW, space available = %ld",dwFreeSpace);
+			}
+			dwTxCmdA=
+				((((DWORD)(skb->data))&0x03UL)<<16) | //DWORD alignment adjustment
+				TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+				((DWORD)(skb->len));
+			dwTxCmdB=
+				(((DWORD)(skb->len))<<16) |
+				((DWORD)(skb->len));
+			Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+			Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+			Platform_WriteFifo(
+				privateData->dwLanBase,
+				(DWORD *)(((DWORD)(skb->data))&0xFFFFFFFCUL),
+				(((DWORD)(skb->len))+3+
+				(((DWORD)(skb->data))&0x03UL))>>2);
+
+			dwFreeSpace-=(skb->len+32);
+			dev_kfree_skb(skb);
+		}
+	}
+	if(Tx_GetTxStatusCount(privateData)>=30)
+	{
+		Tx_UpdateTxCounters(privateData);
+	}
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		Tx_StopQueue(privateData,0x02UL);
+		Lan_SetTDFL(privateData,0x32);
+	}
+}
+
+static void Tx_DmaCompletionCallback(void* param)
+{
+	PPRIVATE_DATA privateData = param;
+
+	BUG_ON(privateData->TxSkb == NULL);
+	dev_kfree_skb(privateData->TxSkb);
+	privateData->TxSkb = NULL;
+	Tx_WakeQueue(privateData,0x04UL);
+}
+
+static DWORD Tx_CompleteTx(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	SMSC_ASSERT(privateData->TxInitialized==TRUE);
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		if(result!=0x00800000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		if(result!=0x00000000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	}
+	return result;
+}
+
+void Tx_UpdateTxCounters(
+	PPRIVATE_DATA privateData)
+{
+
+	DWORD dwTxStatus=0;
+	SMSC_ASSERT(privateData!=NULL);
+	spin_lock(&(privateData->TxCounterLock));
+	while((dwTxStatus=Tx_CompleteTx(privateData))!=0)
+	{
+		if(dwTxStatus&0x80000000UL) {
+			SMSC_WARNING("Packet tag reserved bit is high");
+			privateData->stats.tx_errors++;
+		} else if(dwTxStatus&0x00007080UL) {
+			SMSC_WARNING("Tx Status reserved bits are high");
+			privateData->stats.tx_errors++;
+		} else {
+			if(dwTxStatus&0x00008000UL) {
+				privateData->stats.tx_errors++;
+			} else {
+				privateData->stats.tx_packets++;
+				privateData->stats.tx_bytes+=(dwTxStatus>>16);
+			}
+			if(dwTxStatus&0x00000100UL) {
+				privateData->stats.collisions+=16;
+				privateData->stats.tx_aborted_errors+=1;
+			} else {
+				privateData->stats.collisions+=
+					((dwTxStatus>>3)&0xFUL);
+			}
+			if(dwTxStatus&0x00000800UL) {
+				privateData->stats.tx_carrier_errors+=1;
+			}
+			if(dwTxStatus&0x00000200UL) {
+				privateData->stats.collisions++;
+				privateData->stats.tx_aborted_errors++;
+			}
+		}
+	}
+	spin_unlock(&(privateData->TxCounterLock));
+}
+
+void Tx_CompleteDma(
+	PPRIVATE_DATA privateData)
+{
+	DWORD dwTimeOut=100000;
+
+	SMSC_ASSERT(privateData!=NULL);
+
+	while ((privateData->TxSkb) && (dwTimeOut)) {
+		udelay(10);
+		dwTimeOut--;
+	}
+	if (dwTimeOut == 0)
+		SMSC_WARNING("Timed out waiting for Tx DMA complete");
+}
+
+void Rx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwRxDmaCh,
+	DWORD dwDmaThreshold)
+{
+	SMSC_ASSERT(privateData!=NULL);
+
+	privateData->dwRxDmaCh=dwRxDmaCh;
+	if(dwRxDmaCh>=TRANSFER_PIO) {
+		SMSC_TRACE("Rx will use PIO");
+		Platform_GetFlowControlParameters(
+			&(privateData->PlatformData),
+			&(privateData->RxFlowParameters),
+			FALSE);
+	} else {
+		SMSC_TRACE("Rx will use DMA Channel %ld",dwRxDmaCh);
+		SMSC_ASSERT(Platform_IsValidDmaChannel(dwRxDmaCh));
+		if(!Platform_DmaInitialize(
+			&(privateData->PlatformData),
+			dwRxDmaCh))
+		{
+			SMSC_WARNING("Failed Platform_DmaInitialize, dwRxDmaCh=%lu",dwRxDmaCh);
+		}
+		Platform_GetFlowControlParameters(
+			&(privateData->PlatformData),
+			&(privateData->RxFlowParameters),
+			TRUE);
+	}
+	if(max_throughput!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.MaxThroughput=max_throughput;
+	}
+	if(max_packet_count!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.MaxPacketCount=max_packet_count;
+	}
+	if(packet_cost!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.PacketCost=packet_cost;
+	}
+	if(burst_period!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.BurstPeriod=burst_period;
+	}
+	if(privateData->RxFlowParameters.BurstPeriod==0) {
+		SMSC_WARNING("burst_period of 0 is not allowed");
+		SMSC_WARNING(" resetting burst_period to 100");
+		privateData->RxFlowParameters.BurstPeriod=100;
+	}
+	if(max_work_load!=0xFFFFFFFFUL) {
+		privateData->RxFlowMaxWorkLoad=max_work_load;
+	} else {
+		privateData->RxFlowMaxWorkLoad=
+			privateData->RxFlowParameters.MaxThroughput+
+			(privateData->RxFlowParameters.MaxPacketCount*
+			privateData->RxFlowParameters.PacketCost);
+	}
+	privateData->RxFlowBurstMaxWorkLoad=
+			(privateData->RxFlowMaxWorkLoad*
+			privateData->RxFlowParameters.BurstPeriod)/1000;
+	if(int_deas!=0xFFFFFFFFUL) {
+		Lan_SetIntDeas(privateData,int_deas);
+	} else {
+		Lan_SetIntDeas(privateData,privateData->RxFlowParameters.IntDeas);
+	}
+
+	//initially the receiver is off
+	//  a following link up detection will turn the receiver on
+	privateData->dwRxOffCount=1;
+	Lan_SetRegDW(RX_CFG,0x00000200UL);
+	Rx_ReceiverOn(privateData, 0);
+
+	privateData->dwRxDmaThreshold=dwDmaThreshold;
+	Lan_SetRDFL(privateData,0x01);
+	Lan_SetRSFL(privateData,0x00);
+	privateData->RxInterrupts=INT_EN_RSFL_EN_;
+	privateData->RxInterrupts|=INT_EN_RXE_EN_;
+	if(privateData->dwGeneration==0) {
+		privateData->RxInterrupts|=INT_EN_RDFL_EN_;
+		privateData->RxSkbsMax = 1;
+	} else {
+		privateData->RxInterrupts|=INT_EN_RDFO_EN_;
+		privateData->RxSkbsMax = MAX_RX_SKBS;
+	}
+	privateData->RxInterrupts|=INT_EN_RXDFH_INT_EN_;
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+static void Rx_HandleOverrun(PPRIVATE_DATA privateData)
+{
+	if(privateData->dwGeneration==0) {
+		if(privateData->RxOverrun==FALSE) {
+			Rx_ReceiverOff(privateData);
+			privateData->RxUnloadProgress=
+					(((((privateData->LastRxStatus1)&0x3FFF0000UL)>>16)+2+3)&0xFFFFFFFCUL);
+			if(privateData->dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->RxUnloadProgress+=
+					(((((privateData->LastRxStatus2)&0x3FFF0000UL)>>16)+2+3)&0xFFFFFFFCUL);
+			}
+			privateData->RxUnloadPacketProgress=0;
+			privateData->RxOverrun=TRUE;
+			privateData->RxOverrunCount++;
+		}
+	} else {
+		privateData->RxOverrunCount++;
+	}
+}
+
+static void Rx_HandOffSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb)
+{
+	int result=0;
+
+	skb->dev=privateData->dev;
+	skb->protocol= eth_type_trans(skb,privateData->dev);
+	skb->ip_summed = CHECKSUM_NONE;
+
+	result=netif_rx(skb);
+
+	switch(result)
+	{
+	case NET_RX_SUCCESS:
+		break;
+	case NET_RX_CN_LOW:
+	case NET_RX_CN_MOD:
+	case NET_RX_CN_HIGH:
+	case NET_RX_DROP:
+		privateData->RxCongested=TRUE;
+		privateData->RxCongestedCount++;
+		break;
+	default:
+		privateData->RxCongested=TRUE;
+		privateData->RxCongestedCount++;
+		SMSC_WARNING("Unknown return value from netif_rx, result=%d",result);
+		break;
+	}
+}
+
+void Rx_CompleteMulticastUpdate (PPRIVATE_DATA privateData)
+{
+	DWORD local_MACCR;
+	VL_KEY keyCode=0;
+	DWORD dwIntFlags=0;
+
+	keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if (privateData->MulticastUpdatePending) {
+		SET_GPIO(GP_COMPLETE_MULTICAST_UPDATE);
+		Mac_SetRegDW(privateData,HASHH,privateData->HashHi,keyCode);
+		Mac_SetRegDW(privateData,HASHL,privateData->HashLo,keyCode);
+		local_MACCR = Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		local_MACCR |= privateData->set_bits_mask;
+		local_MACCR &= ~(privateData->clear_bits_mask);
+		Mac_SetRegDW(privateData,MAC_CR,local_MACCR,keyCode);
+		Rx_ReceiverOn(privateData, keyCode);
+		privateData->MulticastUpdatePending = FALSE;
+		CLEAR_GPIO(GP_COMPLETE_MULTICAST_UPDATE);
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+void Rx_BeginMulticastUpdate (PPRIVATE_DATA privateData)
+{
+	DWORD startTime, currentTime;
+	DWORD timeout;
+	DWORD flags;
+
+	SET_GPIO(GP_BEGIN_MULTICAST_UPDATE);
+
+	//NOTE: we can't rely on privateData->dwLinkSpeed because
+	// it updates only once per second and may be out dated.
+
+	local_irq_save(flags);
+	Rx_ReceiverOff(privateData);
+	if(privateData->dwGeneration>0) {
+		//since this is concord or later there is no
+		// overrun processing that might turn off the receiver.
+		// there for we can rely on RxStop Int.
+
+		//if the speed is 100Mb then lets poll rx stop to get the
+		//  quickest response.
+		timeout = 200UL;
+		while ((timeout)&&(!(Lan_GetRegDW(INT_STS)&(INT_STS_RXSTOP_INT_)))) {
+			// wait 1 uSec
+			startTime=Lan_GetRegDW(FREE_RUN);
+			while (1) {
+				currentTime=Lan_GetRegDW(FREE_RUN);
+				if (currentTime-startTime >= 25UL)
+					break;
+			}
+			timeout--;
+		}
+		if(timeout==0) {
+			//this is probably a 10Mb link, therefore prepare
+			// interrupt for update later.
+			Lan_EnableInterrupt(privateData,INT_EN_RXSTOP_INT_EN_);
+
+			// if this is a 10Mbps half duplex connection
+			//  then Rx stop is only 99.6%  reliable
+			//  Therefor we must schedule Gpt callback as
+			//  back up
+
+			// using 18*(100uS) because we already waited 200uS
+			Gpt_ScheduleCallBack(privateData,GptCB_RxCompleteMulticast, 18UL);
+		} else {
+			//Rx is stopped
+			Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);//clear interrupt signal
+			Rx_CompleteMulticastUpdate(privateData);
+		}
+	} else {
+		// for generation 0 we can't rely on Rx stop because
+		// the receiver may have already been stopped due to
+		// overflow processing
+
+		// for the same reason we can't just wait 200uS and
+		// check stopped status there for we must rely on GP timer
+		// and we must assume a worse case of 10Mb speed
+
+		Gpt_ScheduleCallBack(privateData,GptCB_RxCompleteMulticast, 20UL);
+	}
+	local_irq_restore (flags);
+	CLEAR_GPIO(GP_BEGIN_MULTICAST_UPDATE);
+}
+
+static DWORD Rx_PopRxStatus(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(RX_FIFO_INF);
+	if((privateData->RxCongested==FALSE)||
+		((privateData->RxCongested==TRUE)&&((result&0x00FF0000UL)==0UL)))
+	{
+		if(result&0x00FF0000UL) {
+			DWORD dwIntSts=Lan_GetRegDW(INT_STS);
+			if(privateData->dwGeneration==0) {
+				if(dwIntSts&INT_STS_RDFL_) {
+					Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+					Rx_HandleOverrun(privateData);
+				}
+			} else {
+				if(dwIntSts&INT_STS_RDFO_) {
+					Lan_SetRegDW(INT_STS,INT_STS_RDFO_);
+					Rx_HandleOverrun(privateData);
+				}
+			}
+			if((privateData->RxFlowControlActive==FALSE)||
+				((privateData->RxFlowControlActive==TRUE)&&
+				 (privateData->RxFlowBurstActive==TRUE)))
+			{
+				//Rx status is available, read it
+				result=Lan_GetRegDW(RX_STATUS_FIFO);
+				privateData->RxStatusDWReadCount++;
+				privateData->LastRxStatus3=
+					privateData->LastRxStatus2;
+				privateData->LastRxStatus2=
+					privateData->LastRxStatus1;
+				privateData->LastRxStatus1=result;
+
+				if(privateData->RxOverrun) {
+					DWORD dwPacketLength=((result&0x3FFF0000UL)>>16);
+					DWORD dwByteCount=((dwPacketLength+2+3)&0xFFFFFFFCUL);
+					if((privateData->RxUnloadProgress+dwByteCount)>=
+						((privateData->RxMaxDataFifoSize)-16))
+					{
+						//This is the packet that crosses the corruption point
+						//  so just ignore it and complete the overrun processing.
+						result=0;
+						goto FINISH_OVERRUN_PROCESSING;
+					}
+					privateData->RxUnloadProgress+=dwByteCount;
+					privateData->RxUnloadPacketProgress++;
+				}
+
+				privateData->RxFlowCurrentThroughput+=
+						((((result&0x3FFF0000UL)>>16)-4UL));
+				privateData->RxFlowCurrentPacketCount++;
+				privateData->RxFlowCurrentWorkLoad+=
+						((((result&0x3FFF0000UL)>>16)-4UL)+privateData->RxFlowParameters.PacketCost);
+				if(privateData->RxFlowControlActive) {
+					privateData->RxFlowBurstWorkLoad+=
+						((((result&0x3FFF0000UL)>>16)-4UL)+privateData->RxFlowParameters.PacketCost);
+					if(privateData->RxFlowBurstWorkLoad>=
+						privateData->RxFlowBurstMaxWorkLoad)
+					{
+						privateData->RxFlowBurstActive=FALSE;
+						Lan_DisableInterrupt(privateData,privateData->RxInterrupts);
+					}
+				}
+			} else {
+				result=0;
+			}
+		}
+		else
+		{
+			if(privateData->RxOverrun) {
+				DWORD timeOut;
+				DWORD temp;
+FINISH_OVERRUN_PROCESSING:
+				temp=0;
+				{
+					timeOut=2000;
+					while((timeOut>0)&&(!(Lan_GetRegDW(INT_STS)&(INT_STS_RXSTOP_INT_)))) {
+						udelay(1);
+						timeOut--;
+					}
+					if(timeOut==0) {
+//						privateData->RxStopTimeOutCount++;
+//						PULSE_GPIO(GP_TX,1);
+						SMSC_WARNING("Timed out waiting for Rx to Stop\n");
+					}
+					Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);
+				}
+
+				if(privateData->dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+					//make sure DMA has stopped before doing RX Dump
+					DWORD dwTimeOut=100000;
+
+					while ((privateData->RxSkbsCount != 0) && (dwTimeOut)) {
+						udelay(10);
+						timeOut--;
+					}
+					if (dwTimeOut == 0)
+						SMSC_WARNING("Timed out waiting for Rx DMA complete");
+				}
+
+				temp=Lan_GetRegDW(RX_CFG);
+				Lan_SetRegDW(RX_CFG,(temp&0x3FFFFFFFUL));
+				timeOut=10000000;
+				Lan_SetBitsDW(RX_CFG,RX_CFG_RX_DUMP_);
+				while((timeOut>0)&&(Lan_GetRegDW(RX_CFG)&(RX_CFG_RX_DUMP_))) {
+					udelay(1);
+					timeOut--;
+				}
+				if(timeOut==0) {
+					SMSC_WARNING("Timed out waiting for Rx Dump to complete\n");
+				}
+				Lan_SetRegDW(RX_CFG,temp);
+
+				privateData->RxDumpCount++;
+				Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+				Rx_ReceiverOn(privateData, 0);
+				privateData->RxOverrun=FALSE;
+			}
+			result=0;
+			privateData->LastReasonForReleasingCPU=1;//Status FIFO Empty
+		}
+	} else {
+		//disable and reenable the INT_EN
+		//  This will allow the deassertion interval to begin
+		DWORD temp=Lan_GetRegDW(INT_EN);
+		Lan_SetRegDW(INT_EN,0);
+		Lan_SetRegDW(INT_EN,temp);
+		result=0;
+		privateData->LastReasonForReleasingCPU=2;//High Congestion
+	}
+	return result;
+}
+
+void Rx_CountErrors(PPRIVATE_DATA privateData,DWORD dwRxStatus)
+{
+	BOOLEAN crcError=FALSE;
+	if(dwRxStatus&0x00008000UL) {
+		privateData->stats.rx_errors++;
+		if(dwRxStatus&0x00000002UL) {
+			privateData->stats.rx_crc_errors++;
+			crcError=TRUE;
+		}
+	}
+	if(!crcError) {
+		if((dwRxStatus&0x00001020UL)==0x00001020UL) {
+			//Frame type indicates length, and length error is set
+			privateData->stats.rx_length_errors++;
+		}
+		if(dwRxStatus&RX_STS_MCAST_) {
+			privateData->stats.multicast++;
+		}
+	}
+}
+
+void Rx_FastForward(PPRIVATE_DATA privateData,DWORD dwDwordCount)
+{
+	privateData->RxFastForwardCount++;
+	if((dwDwordCount>=4)
+		&& (
+			(((privateData->dwIdRev&0x0000FFFFUL)==0x00000000UL)
+				&& (privateData->dwFpgaRev>=0x36))
+			||
+			((privateData->dwIdRev&0x0000FFFFUL)!=0UL)
+			)
+		)
+	{
+		DWORD dwTimeOut=500;
+		Lan_SetRegDW(RX_DP_CTRL,(dwDwordCount|RX_DP_CTRL_FFWD_BUSY_));
+		while((dwTimeOut)&&(Lan_GetRegDW(RX_DP_CTRL)&
+				RX_DP_CTRL_FFWD_BUSY_))
+		{
+			udelay(1);
+			dwTimeOut--;
+		}
+		if(dwTimeOut==0) {
+
+			SMSC_WARNING("timed out waiting for RX FFWD to finish, RX_DP_CTRL=0x%08lX",
+				Lan_GetRegDW(RX_DP_CTRL));
+		}
+	} else {
+		while(dwDwordCount) {
+			DWORD dwTemp=Lan_GetRegDW(RX_DATA_FIFO);
+			dwTemp=dwTemp;
+			dwDwordCount--;
+		}
+	}
+}
+
+//Rx_ReceiverOff, and Rx_ReceiverOn use a reference counter
+//  because they are used in both the Rx code and the link management count
+void Rx_ReceiverOff(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if(privateData->dwRxOffCount==0) {
+		DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		if(!(dwMacCr&MAC_CR_RXEN_)) {
+			SMSC_WARNING("Rx_ReceiverOff: Receiver is already Off");
+		}
+		dwMacCr&=(~MAC_CR_RXEN_);
+		Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+		//CLEAR_GPIO(GP_RX);
+	}
+	privateData->dwRxOffCount++;
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+//Rx_ReceiverOff, and Rx_ReceiverOn use a reference counter
+//  because they are used in both the Rx code and the link management count
+void Rx_ReceiverOn(PPRIVATE_DATA privateData, VL_KEY callerKeyCode)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=0;
+
+	if (callerKeyCode == 0) {
+		keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	}
+	else {
+		SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),callerKeyCode));
+		keyCode = callerKeyCode;
+	}
+	if(privateData->dwRxOffCount>0) {
+		privateData->dwRxOffCount--;
+		if(privateData->dwRxOffCount==0) {
+			DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			if(dwMacCr&MAC_CR_RXEN_) {
+				SMSC_WARNING("Rx_ReceiverOn: Receiver is already on");
+			}
+			dwMacCr|=MAC_CR_RXEN_;
+			Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+			//SET_GPIO(GP_RX);
+		}
+	} else {
+		SMSC_ASSERT(FALSE);
+	}
+	if (callerKeyCode == 0) {
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+}
+
+unsigned int RxPacketDepth[MAX_RX_SKBS+1];
+
+/* This function is called from the interrupt handler or from a tasklet triggered by the
+ * interrupt handler when the status register has INT_STS_RSFL_ set, or RxOverrun is set.
+ */
+void Rx_ProcessPackets(PPRIVATE_DATA privateData)
+{
+	DWORD dwRxStatus=0;
+	PPLATFORM_DATA platformData=NULL;
+//	SET_GPIO(GP_RX);
+	privateData->RxCongested=FALSE;
+	platformData=&(privateData->PlatformData);
+	if(privateData->dwRxDmaCh>=TRANSFER_PIO) {
+		//Use PIO only
+		Lan_SetRegDW(RX_CFG,0x00000200UL);
+		while((dwRxStatus=Rx_PopRxStatus(privateData))!=0)
+		{
+			DWORD dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+			Rx_CountErrors(privateData,dwRxStatus);
+			if((dwRxStatus&RX_STS_ES_)==0) {
+				struct sk_buff *skb=NULL;
+				skb=dev_alloc_skb(dwPacketLength+2);
+				if(skb!=NULL) {
+					skb->data=skb->head;
+					skb->tail=skb->head;
+					skb_reserve(skb,2); // align IP on 16B boundary
+					skb_put(skb,dwPacketLength-4UL);
+
+					//update counters
+					privateData->stats.rx_packets++;
+					privateData->stats.rx_bytes+=(dwPacketLength-4);
+
+					privateData->RxPacketReadCount++;
+					privateData->RxPioReadCount++;
+					privateData->RxDataDWReadCount+=
+						(dwPacketLength+2+3)>>2;
+
+					Platform_ReadFifo(
+						privateData->dwLanBase,
+						((DWORD *)(skb->head)),
+						(dwPacketLength+2+3)>>2);
+
+					Rx_HandOffSkb(privateData,skb);
+					continue;
+				} else {
+					SMSC_WARNING("Unable to allocate sk_buff for RX Packet, in PIO path");
+					privateData->stats.rx_dropped++;
+				}
+			}
+			//if we get here then the packet is to be read
+			//  out of the fifo and discarded
+			dwPacketLength+=(2+3);
+			dwPacketLength>>=2;
+			Rx_FastForward(privateData,dwPacketLength);
+		}
+	} else {
+		//Use DMA and PIO
+		DWORD dwDmaCh=privateData->dwRxDmaCh;
+		//struct sk_buff *dmaSkb=NULL;//use privateData->RxDmaSkb
+		DMA_XFER dmaXfer;
+		DWORD packets;
+
+		BUG_ON(privateData->RxSkbsCount != 0);
+
+		//set end alignment and offset
+		switch(PLATFORM_CACHE_LINE_BYTES)
+		{
+		case 16:Lan_SetRegDW(RX_CFG,0x40000200UL);break;
+		case 32:Lan_SetRegDW(RX_CFG,0x80001200UL);break;
+		default:SMSC_ASSERT(FALSE);
+		}
+
+		privateData->RxDropOnCallback = 0;
+
+		for (packets=0;
+		     (packets < MAX_RX_SKBS) &&
+			     ((dwRxStatus=Rx_PopRxStatus(privateData))!=0);
+		     packets++) {
+			DWORD dwDwordCount;
+			DWORD dwPacketLength;
+			struct sk_buff *skb;
+			struct scatterlist* sg;
+
+			dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+			dwDwordCount =
+				(dwPacketLength+
+				  (PLATFORM_CACHE_LINE_BYTES-14)+
+				  PLATFORM_CACHE_LINE_BYTES-1)&
+				(~(PLATFORM_CACHE_LINE_BYTES-1));
+
+			Rx_CountErrors(privateData,dwRxStatus);
+			if((dwRxStatus&RX_STS_ES_)!=0) {
+				privateData->stats.rx_dropped++;
+				privateData->RxDropOnCallback = dwPacketLength;
+				break;
+			}
+
+			skb=alloc_skb(dwPacketLength+2*PLATFORM_CACHE_LINE_BYTES, GFP_ATOMIC);
+			if (skb == NULL) {
+				privateData->stats.rx_dropped++;
+				privateData->RxDropOnCallback = dwPacketLength;
+				break;
+			}
+
+			privateData->RxSkbs[packets] = skb;
+			skb_reserve(skb,PLATFORM_CACHE_LINE_BYTES-14);
+			skb_put(skb,dwPacketLength-4UL);
+
+			privateData->stats.rx_packets++;
+			privateData->stats.rx_bytes+=dwPacketLength;
+
+			sg=&privateData->RxSgs[packets];
+			sg->page = virt_to_page(skb->head);
+			sg->offset = (long)skb->head & ~PAGE_MASK;
+			sg->length = dwDwordCount;
+
+			privateData->RxDataDWReadCount+=dwDwordCount;
+			privateData->RxPacketReadCount++;
+			privateData->RxDmaReadCount++;
+		}
+
+		if (packets != 0) {
+			dmaXfer.dwLanReg=privateData->dwLanBase+RX_DATA_FIFO;
+			dmaXfer.pdwBuf=(DWORD*)privateData->RxSgs;
+			dmaXfer.dwDmaCh=dwDmaCh;
+			dmaXfer.dwDwCnt=packets;
+			dmaXfer.fMemWr=TRUE;
+
+			Lan_DisableInterrupt(privateData,privateData->RxInterrupts);
+
+			RxPacketDepth[packets]++;
+			privateData->RxSkbsCount = packets;
+			if(!Platform_DmaStartSgXfer(platformData,&dmaXfer, Rx_DmaCompletionCallback, privateData)) {
+				SMSC_WARNING("Failed Platform_DmaStartXfer");
+			}
+		} else if (privateData->RxDropOnCallback != 0) {
+			DWORD dwPacketLength;
+			Lan_SetRegDW(RX_CFG,0x00000200UL);
+			dwPacketLength = privateData->RxDropOnCallback+2+3;
+			dwPacketLength>>=2;
+			Rx_FastForward(privateData,dwPacketLength);
+		}
+	}
+	Lan_SetRegDW(INT_STS,INT_STS_RSFL_);
+//	CLEAR_GPIO(GP_RX);
+}
+
+void Rx_ProcessPacketsTasklet(unsigned long data)
+{
+    PPRIVATE_DATA privateData=(PPRIVATE_DATA)Rx_TaskletParameter;
+	data=data;//make lint happy
+	if(privateData==NULL) {
+		SMSC_WARNING("Rx_ProcessPacketsTasklet(privateData==NULL)");
+		return;
+	}
+	Rx_ProcessPackets(privateData);
+	Lan_EnableIRQ(privateData);
+}
+
+static void Rx_DmaCompletionCallback(void* param)
+{
+	PPRIVATE_DATA privateData = param;
+	int i;
+
+	BUG_ON(privateData->RxSkbsCount == 0);
+	for (i=0; i<privateData->RxSkbsCount; i++) {
+		Rx_HandOffSkb(privateData,privateData->RxSkbs[i]);
+	}
+
+	if (privateData->RxDropOnCallback != 0) {
+		DWORD dwPacketLength;
+		Lan_SetRegDW(RX_CFG,0x00000200UL);
+		dwPacketLength = privateData->RxDropOnCallback+2+3;
+		dwPacketLength>>=2;
+		Rx_FastForward(privateData,dwPacketLength);
+	}
+
+	privateData->RxSkbsCount = 0;
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+BOOLEAN Rx_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+
+	privateData->LastReasonForReleasingCPU=0;
+
+	if(dwIntSts&INT_STS_RXE_) {
+		SMSC_TRACE("Rx_HandleInterrupt: RXE signalled");
+		privateData->stats.rx_errors++;
+		Lan_SetRegDW(INT_STS,INT_STS_RXE_);
+		result=TRUE;
+	}
+
+	if(dwIntSts&INT_STS_RXDFH_INT_) {
+		privateData->stats.rx_dropped+=Lan_GetRegDW(RX_DROP);
+		Lan_SetRegDW(INT_STS,INT_STS_RXDFH_INT_);
+		result=TRUE;
+	}
+
+	if(privateData->dwGeneration==0) {
+		if(dwIntSts&(INT_STS_RDFL_)) {
+			Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+			Rx_HandleOverrun(privateData);
+			result=TRUE;
+		}
+	} else {
+		if(dwIntSts&(INT_STS_RDFO_)) {
+			Lan_SetRegDW(INT_STS,INT_STS_RDFO_);
+			Rx_HandleOverrun(privateData);
+			result=TRUE;
+		}
+	}
+
+	if((!(dwIntSts&INT_STS_RSFL_))&&(privateData->RxOverrun==FALSE)) {
+		return result;
+	}
+	if (privateData->RxSkbsCount != 0) {
+		/* We are still DMAing the previous packet from the RX
+		 * FIFO, and waiting for the DMA completion callback.
+		 * We got here because another interrupt was active,
+		 * even though Rx interrupts are disabled.
+		 */
+		return result;
+	}
+
+	result=TRUE;
+
+	if(privateData->MeasuringRxThroughput==FALSE) {
+		privateData->MeasuringRxThroughput=TRUE;
+		Gpt_ScheduleCallBack(privateData,GptCB_MeasureRxThroughput,1000);
+		privateData->RxFlowCurrentThroughput=0;
+		privateData->RxFlowCurrentPacketCount=0;
+		privateData->RxFlowCurrentWorkLoad=0;
+	}
+	if(tasklets) {
+		Lan_DisableIRQ(privateData);
+		Rx_TaskletParameter=(unsigned long)privateData;
+		tasklet_schedule(&Rx_Tasklet);
+	} else {
+		Rx_ProcessPackets(privateData);
+	}
+	return result;
+}
+
+BOOLEAN RxStop_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+
+	if(dwIntSts&INT_STS_RXSTOP_INT_) {
+		result=TRUE;
+		Gpt_CancelCallBack (privateData, GptCB_RxCompleteMulticast);
+		Rx_CompleteMulticastUpdate (privateData);
+		Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);
+		Lan_DisableInterrupt(privateData,INT_EN_RXSTOP_INT_EN_);
+	}
+	return result;
+}
+
+//returns hash bit number for given MAC address
+//example:
+//   01 00 5E 00 00 01 -> returns bit number 31
+static DWORD Rx_Hash(BYTE addr[6])
+{
+	int i;
+	DWORD crc=0xFFFFFFFFUL;
+	DWORD poly=0xEDB88320UL;
+	DWORD result=0;
+	for(i=0;i<6;i++)
+	{
+		int bit;
+		DWORD data=((DWORD)addr[i]);
+		for(bit=0;bit<8;bit++)
+		{
+			DWORD p = (crc^((DWORD)data))&1UL;
+			crc >>= 1;
+			if(p!=0) crc ^= poly;
+			data >>=1;
+		}
+	}
+	result=((crc&0x01UL)<<5)|
+		((crc&0x02UL)<<3)|
+		((crc&0x04UL)<<1)|
+		((crc&0x08UL)>>1)|
+		((crc&0x10UL)>>3)|
+		((crc&0x20UL)>>5);
+	return result;
+}
+
+void Rx_SetMulticastList(
+	struct net_device *dev)
+{
+	PPRIVATE_DATA privateData=NULL;
+	VL_KEY keyCode=0;
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(dev!=NULL);
+
+	privateData=((PPRIVATE_DATA)(dev->priv));
+    	SMSC_ASSERT(privateData!=NULL);
+	keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+
+	if(dev->flags & IFF_PROMISC) {
+//		SMSC_TRACE("Promiscuous Mode Enabled");
+		privateData->set_bits_mask = MAC_CR_PRMS_;
+		privateData->clear_bits_mask = (MAC_CR_MCPAS_ | MAC_CR_HPFILT_);
+
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+		goto PREPARE;
+	}
+
+	if(dev->flags & IFF_ALLMULTI) {
+//		SMSC_TRACE("Receive all Multicast Enabled");
+		privateData->set_bits_mask = MAC_CR_MCPAS_;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_HPFILT_);
+
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+		goto PREPARE;
+	}
+
+
+	if(dev->mc_count>0) {
+		DWORD dwHashH=0;
+		DWORD dwHashL=0;
+		DWORD dwCount=0;
+		struct dev_mc_list *mc_list=dev->mc_list;
+
+		privateData->set_bits_mask = MAC_CR_HPFILT_;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_);
+
+		while(mc_list!=NULL) {
+			dwCount++;
+			if((mc_list->dmi_addrlen)==6) {
+				DWORD dwMask=0x01UL;
+				DWORD dwBitNum=Rx_Hash(mc_list->dmi_addr);
+			//	SMSC_TRACE("Multicast: enable dwBitNum=%ld,addr=%02X %02X %02X %02X %02X %02X",
+			//		dwBitNum,
+			//		((BYTE *)(mc_list->dmi_addr))[0],
+			//		((BYTE *)(mc_list->dmi_addr))[1],
+			//		((BYTE *)(mc_list->dmi_addr))[2],
+			//		((BYTE *)(mc_list->dmi_addr))[3],
+			//		((BYTE *)(mc_list->dmi_addr))[4],
+			//		((BYTE *)(mc_list->dmi_addr))[5]);
+				dwMask<<=(dwBitNum&0x1FUL);
+				if(dwBitNum&0x20UL) {
+					dwHashH|=dwMask;
+				} else {
+					dwHashL|=dwMask;
+				}
+			} else {
+				SMSC_WARNING("dmi_addrlen!=6");
+			}
+			mc_list=mc_list->next;
+		}
+		if(dwCount!=((DWORD)(dev->mc_count))) {
+			SMSC_WARNING("dwCount!=dev->mc_count");
+		}
+		// SMSC_TRACE("Multicast: HASHH=0x%08lX,HASHL=0x%08lX",dwHashH,dwHashL);
+		privateData->HashHi = dwHashH;
+		privateData->HashLo = dwHashL;
+	}
+	else
+	{
+		privateData->set_bits_mask = 0L;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);
+
+		// SMSC_TRACE("Receive own packets only.");
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+	}
+
+PREPARE:
+	if(privateData->dwGeneration<=1) {
+		if (privateData->MulticastUpdatePending == FALSE) {
+			privateData->MulticastUpdatePending = TRUE;
+			// prepare to signal software interrupt
+			Lan_SignalSoftwareInterrupt(privateData);
+		}
+		else {
+			// Rx_CompleteMulticastUpdate has not yet been called
+			// therefore these latest settings will be used instead
+		}
+	} else {
+		DWORD local_MACCR;
+		Mac_SetRegDW(privateData,HASHH,privateData->HashHi,keyCode);
+		Mac_SetRegDW(privateData,HASHL,privateData->HashLo,keyCode);
+		local_MACCR = Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		local_MACCR |= privateData->set_bits_mask;
+		local_MACCR &= ~(privateData->clear_bits_mask);
+		Mac_SetRegDW(privateData,MAC_CR,local_MACCR,keyCode);
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	return;
+}
+
+void Eeprom_EnableAccess(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(debug_mode&0x04UL) {
+		Lan_SetRegDW(GPIO_CFG,(g_GpioSetting&0xFF0FFFFFUL));
+	} else {
+		Lan_ClrBitsDW(GPIO_CFG,0x00F00000UL);
+	}
+	udelay(100);
+}
+
+void Eeprom_DisableAccess(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(debug_mode&0x04UL) {
+		Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+	}
+}
+
+BOOLEAN Eeprom_IsMacAddressLoaded(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_MAC_ADDR_LOADED_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_IsBusy(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_EPC_BUSY_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_Timeout(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_EPC_TIMEOUT_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_ReadLocation(
+	PPRIVATE_DATA privateData,
+	BYTE address, BYTE * data)
+{
+	DWORD timeout=100000;
+	DWORD temp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(data!=NULL);
+	if((temp=Lan_GetRegDW(E2P_CMD))&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_ReadLocation: Busy at start, E2P_CMD=0x%08lX",temp);
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_READ_|((DWORD)address)));
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	(*data)=(BYTE)(Lan_GetRegDW(E2P_DATA));
+	return TRUE;
+}
+
+BOOLEAN Eeprom_EnableEraseAndWrite(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_EnableEraseAndWrite: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_EWEN_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_DisableEraseAndWrite(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_DisableEraseAndWrite: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_EWDS_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_WriteLocation(
+	PPRIVATE_DATA privateData,BYTE address,BYTE data)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_WriteLocation: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_DATA,((DWORD)data));
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_WRITE_|((DWORD)address)));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_EraseAll(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_EraseAll: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_ERAL_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_Reload(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_Reload: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_RELOAD_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_SaveMacAddress(
+	PPRIVATE_DATA privateData,
+	DWORD dwHi16,DWORD dwLo32)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+	Eeprom_EnableAccess(privateData);
+	if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+	if(!Eeprom_EraseAll(privateData)) goto DONE;
+	if(privateData->dwGeneration==0) {
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,0,0xA5)) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,1,LOBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,2,HIBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,3,LOBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,4,HIBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,5,LOBYTE(LOWORD(dwHi16)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,6,HIBYTE(LOWORD(dwHi16)))) goto DONE;
+	} else {
+		if(!Eeprom_WriteLocation(privateData,0,0xA5)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,1,LOBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,2,HIBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,3,LOBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,4,HIBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,5,LOBYTE(LOWORD(dwHi16)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,6,HIBYTE(LOWORD(dwHi16)))) goto DONE;
+	}
+	if(!Eeprom_DisableEraseAndWrite(privateData)) goto DONE;
+
+	if(!Eeprom_Reload(privateData)) goto DONE;
+	if(!Eeprom_IsMacAddressLoaded(privateData)) goto DONE;
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		if(dwHi16!=Mac_GetRegDW(privateData,ADDRH,keyCode)) goto DONE;
+		if(dwLo32!=Mac_GetRegDW(privateData,ADDRL,keyCode)) goto DONE;
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+	result=TRUE;
+DONE:
+	Eeprom_DisableAccess(privateData);
+	return result;
+}
+
+volatile DWORD g_GpioSetting=0x00000000UL;
+#ifdef USE_LED1_WORK_AROUND
+volatile DWORD g_GpioSettingOriginal=0x00000000UL;
+#endif
+
+BOOLEAN Lan_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntCfg,
+	DWORD dwTxFifSz,
+	DWORD dwAfcCfg)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwTimeOut=0;
+	DWORD dwTemp=0;
+	DWORD dwResetCount=3;
+
+    SMSC_TRACE("-->Lan_Initialize(dwIntCfg=0x%08lX)",dwIntCfg);
+	SMSC_ASSERT(privateData!=NULL);
+
+	//Reset the LAN9118
+	if(privateData->dwGeneration>0) {
+		dwResetCount=1;
+	}
+	while(dwResetCount>0) {
+		Lan_SetRegDW(HW_CFG,HW_CFG_SRST_);
+		dwTimeOut=1000000;
+		do {
+			udelay(10);
+			dwTemp=Lan_GetRegDW(HW_CFG);
+			dwTimeOut--;
+		} while((dwTimeOut>0)&&(dwTemp&HW_CFG_SRST_));
+		if(dwTemp&HW_CFG_SRST_) {
+			SMSC_WARNING("  Failed to complete reset.");
+			goto DONE;
+		}
+		dwResetCount--;
+	}
+
+	SMSC_ASSERT(dwTxFifSz>=0x00020000UL);
+	SMSC_ASSERT(dwTxFifSz<=0x000E0000UL);
+	SMSC_ASSERT((dwTxFifSz&(~HW_CFG_TX_FIF_SZ_))==0);
+	Lan_SetRegDW(HW_CFG,dwTxFifSz);
+	privateData->RxMaxDataFifoSize=0;
+	switch(dwTxFifSz>>16) {
+	case 2:privateData->RxMaxDataFifoSize=13440;break;
+	case 3:privateData->RxMaxDataFifoSize=12480;break;
+	case 4:privateData->RxMaxDataFifoSize=11520;break;
+	case 5:privateData->RxMaxDataFifoSize=10560;break;
+	case 6:privateData->RxMaxDataFifoSize=9600;break;
+	case 7:privateData->RxMaxDataFifoSize=8640;break;
+	case 8:privateData->RxMaxDataFifoSize=7680;break;
+	case 9:privateData->RxMaxDataFifoSize=6720;break;
+	case 10:privateData->RxMaxDataFifoSize=5760;break;
+	case 11:privateData->RxMaxDataFifoSize=4800;break;
+	case 12:privateData->RxMaxDataFifoSize=3840;break;
+	case 13:privateData->RxMaxDataFifoSize=2880;break;
+	case 14:privateData->RxMaxDataFifoSize=1920;break;
+	default:SMSC_ASSERT(FALSE);break;
+	}
+
+	if(dwAfcCfg==0xFFFFFFFF) {
+		switch(dwTxFifSz) {
+
+		//AFC_HI is about ((Rx Data Fifo Size)*2/3)/64
+		//AFC_LO is AFC_HI/2
+		//BACK_DUR is about 5uS*(AFC_LO) rounded down
+		case 0x00020000UL://13440 Rx Data Fifo Size
+			dwAfcCfg=0x008C46AF;break;
+		case 0x00030000UL://12480 Rx Data Fifo Size
+			dwAfcCfg=0x0082419F;break;
+		case 0x00040000UL://11520 Rx Data Fifo Size
+
+			dwAfcCfg=0x00783C9F;break;
+		case 0x00050000UL://10560 Rx Data Fifo Size
+//			dwAfcCfg=0x006E378F;break;
+			dwAfcCfg=0x006E374F;break;
+		case 0x00060000UL:// 9600 Rx Data Fifo Size
+			dwAfcCfg=0x0064328F;break;
+		case 0x00070000UL:// 8640 Rx Data Fifo Size
+			dwAfcCfg=0x005A2D7F;break;
+		case 0x00080000UL:// 7680 Rx Data Fifo Size
+			dwAfcCfg=0x0050287F;break;
+		case 0x00090000UL:// 6720 Rx Data Fifo Size
+			dwAfcCfg=0x0046236F;break;
+		case 0x000A0000UL:// 5760 Rx Data Fifo Size
+			dwAfcCfg=0x003C1E6F;break;
+		case 0x000B0000UL:// 4800 Rx Data Fifo Size
+			dwAfcCfg=0x0032195F;break;
+
+		//AFC_HI is ~1520 bytes less than RX Data Fifo Size
+		//AFC_LO is AFC_HI/2
+		//BACK_DUR is about 5uS*(AFC_LO) rounded down
+		case 0x000C0000UL:// 3840 Rx Data Fifo Size
+			dwAfcCfg=0x0024124F;break;
+		case 0x000D0000UL:// 2880 Rx Data Fifo Size
+			dwAfcCfg=0x0015073F;break;
+		case 0x000E0000UL:// 1920 Rx Data Fifo Size
+			dwAfcCfg=0x0006032F;break;
+		default:SMSC_ASSERT(FALSE);break;
+		}
+	}
+	Lan_SetRegDW(AFC_CFG,(dwAfcCfg&0xFFFFFFF0UL));
+
+	//make sure EEPROM has finished loading before setting GPIO_CFG
+	dwTimeOut=1000;
+	while((dwTimeOut>0)&&(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_)) {
+		udelay(5);
+		dwTimeOut--;
+	}
+	if(dwTimeOut==0) {
+		SMSC_WARNING("Lan_Initialize: Timed out waiting for EEPROM busy bit to clear\n");
+	}
+
+	if(debug_mode&0x04UL) {
+		if(OLD_REGISTERS(privateData))
+		{
+			g_GpioSetting=0x00270700UL;
+		} else {
+			g_GpioSetting=0x00670700UL;
+		}
+	} else {
+		g_GpioSetting = 0x70070000UL;
+	}
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+
+	//initialize interrupts
+	Lan_SetRegDW(INT_EN,0);
+	Lan_SetRegDW(INT_STS,0xFFFFFFFFUL);
+	dwIntCfg|=INT_CFG_IRQ_EN_;
+	Lan_SetRegDW(INT_CFG,dwIntCfg);
+
+	Vl_InitLock(&(privateData->MacPhyLock));
+	spin_lock_init(&(privateData->IntEnableLock));
+	privateData->LanInitialized=TRUE;
+
+	result=TRUE;
+
+DONE:
+	SMSC_TRACE("<--Lan_Initialize");
+	return result;
+}
+
+void Lan_EnableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask)
+{
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	Lan_SetBitsDW(INT_EN,dwIntEnMask);
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_DisableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask)
+{
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	Lan_ClrBitsDW(INT_EN,dwIntEnMask);
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+//Spin locks for the following functions have been commented out
+//  because at this time they are not necessary.
+//These function are
+//  Lan_SetTDFL
+//  Lan_SetTSFL
+//  Lan_SetRDFL
+//  Lan_SetRSFL
+//Both the Rx and Tx side of the driver use the FIFO_INT,
+//  but the Rx side only touches is during initialization,
+//  so it is sufficient that Tx side simple preserve the Rx setting
+
+void Lan_SetTDFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0x00FFFFFFUL;
+		temp|=((DWORD)level)<<24;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetTSFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFF00FFFFUL;
+		temp|=((DWORD)level)<<16;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetRDFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFFFF00FFUL;
+		temp|=((DWORD)level)<<8;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetRSFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFFFFFF00UL;
+		temp|=((DWORD)level);
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_EnableIRQ(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_SetBitsDW(INT_CFG,INT_CFG_IRQ_EN_);
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_DisableIRQ(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_ClrBitsDW(INT_CFG,INT_CFG_IRQ_EN_);
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetIntDeas(PPRIVATE_DATA privateData, DWORD dwIntDeas)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_ClrBitsDW(INT_CFG,INT_CFG_INT_DEAS_);
+		Lan_SetBitsDW(INT_CFG,(dwIntDeas<<24));
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SignalSoftwareInterrupt(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	privateData->SoftwareInterruptSignal=FALSE;
+	Lan_EnableInterrupt(privateData,INT_EN_SW_INT_EN_);
+}
+
+BOOLEAN Lan_HandleSoftwareInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	if(dwIntSts&INT_STS_SW_INT_) {
+		SMSC_ASSERT(privateData!=NULL);
+		Lan_DisableInterrupt(privateData,INT_EN_SW_INT_EN_);
+		Lan_SetRegDW(INT_STS,INT_STS_SW_INT_);
+		privateData->SoftwareInterruptSignal=TRUE;
+		if (privateData->MulticastUpdatePending) {
+			Rx_BeginMulticastUpdate (privateData);
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+typedef struct _SHOW_REG
+{
+	char  szName[20];
+	DWORD dwOffset;
+} SHOW_REG;
+/*
+FUNCTION: Lan_ShowRegs
+    This function is used to display the registers.
+	Except the phy.
+*/
+void Lan_ShowRegs(PPRIVATE_DATA privateData)
+{
+	//	Make these const struct's static to keep them off the stack.
+	//	Otherwise, gcc will try to use _memcpy() to initialize them,
+	//	which will *NOT* work in our RunTime environment.
+	static const SHOW_REG sysCsr[] = {
+		{ "ID_REV",			0x50UL		},
+		{ "INT_CFG",		0x54UL		},
+		{ "INT_STS",		0x58UL		},
+		{ "INT_EN",			0x5CUL		},
+		{ "DMA_CFG",		0x60UL		},
+		{ "BYTE_TEST",		0x64UL		},
+		{ "FIFO_INT",		0x68UL		},
+		{ "RX_CFG",			0x6CUL		},
+		{ "TX_CFG",			0x70UL		},
+		{ "HW_CFG",			0x74UL		},
+		{ "RX_DP_CTRL",		0x78UL		},
+		{ "RX_FIFO_INF",	0x7CUL		},
+		{ "TX_FIFO_INF",	0x80UL		},
+		{ "PMT_CTRL",		0x84UL		},
+		{ "GPIO_CFG",		0x88UL		},
+		{ "GPT_CFG",		0x8CUL		},
+		{ "GPT_CNT",		0x90UL		},
+		{ "FPGA_REV",		0x94UL		},
+		{ "ENDIAN",			0x98UL		},
+		{ "FREE_RUN",		0x9CUL		},
+		{ "RX_DROP",		0xA0UL		},
+		{ "MAC_CSR_CMD",	0xA4UL		},
+		{ "MAC_CSR_DATA",	0xA8UL		},
+		{ "AFC_CFG",		0xACUL		},
+		{ "E2P_CMD",		0xB0UL		},
+		{ "E2P_DATA",		0xB4UL		},
+		{ "TEST_REG_A",		0xC0UL		}};
+
+	static const SHOW_REG macCsr[] = {
+		{ "MAC_CR",		MAC_CR		},
+		{ "ADDRH",		ADDRH		},
+		{ "ADDRL",		ADDRL		},
+		{ "HASHH",		HASHH		},
+		{ "HASHL",		HASHL		},
+		{ "MII_ACC",	MII_ACC		},
+		{ "MII_DATA",	MII_DATA	},
+		{ "FLOW",		FLOW		},
+		{ "VLAN1",		VLAN1		},
+		{ "VLAN2",		VLAN2		},
+		{ "WUFF",		WUFF		},
+		{ "WUCSR",		WUCSR		}};
+
+	int i, iNumSysRegs, iNumMacRegs;
+	DWORD dwOldMacCmdReg, dwOldMacDataReg;
+
+	iNumSysRegs = (int)(sizeof(sysCsr) / sizeof(SHOW_REG));
+	iNumMacRegs = (int)(sizeof(macCsr) / sizeof(SHOW_REG));
+
+	// preserve MAC cmd/data reg's
+	dwOldMacCmdReg = Lan_GetRegDW(MAC_CSR_CMD);
+	dwOldMacDataReg = Lan_GetRegDW(MAC_CSR_DATA);
+
+	SMSC_TRACE("");
+	SMSC_TRACE("               LAN91C118 CSR's");
+	SMSC_TRACE("                     SYS CSR's                     MAC CSR's");
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		for (i=0; i<iNumMacRegs; i++)
+		{
+			SMSC_TRACE(
+				"%16s (0x%02lX) = 0x%08lX, %8s (0x%02lX) + 0x%08lX",
+				sysCsr[i].szName,
+				sysCsr[i].dwOffset,
+				*((volatile DWORD *)(privateData->dwLanBase+sysCsr[i].dwOffset)),
+				macCsr[i].szName,
+				macCsr[i].dwOffset,
+				Mac_GetRegDW(privateData,macCsr[i].dwOffset,keyCode));
+
+			// restore original mac cmd/data reg's after each usage
+			Lan_SetRegDW(MAC_CSR_CMD,dwOldMacCmdReg);
+			Lan_SetRegDW(MAC_CSR_DATA,dwOldMacDataReg);
+		}
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+	for (i=iNumMacRegs; i<iNumSysRegs; i++)
+	{
+		SMSC_TRACE("%16s (0x%02lX) = 0x%08lX",
+			sysCsr[i].szName,
+			sysCsr[i].dwOffset,
+			*((volatile DWORD *)(privateData->dwLanBase+sysCsr[i].dwOffset)));
+	}
+}
+
+void Vl_InitLock(PVERIFIABLE_LOCK pVl)
+{
+	SMSC_ASSERT(pVl!=NULL);
+	spin_lock_init(&(pVl->Lock));
+	pVl->KeyCode=0;
+}
+
+BOOLEAN Vl_CheckLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(pVl!=NULL);
+	if(keyCode==pVl->KeyCode)
+		result=TRUE;
+	return result;
+}
+
+VL_KEY Vl_WaitForLock(PVERIFIABLE_LOCK pVl,DWORD *pdwIntFlags)
+{
+	VL_KEY result=0;
+	SMSC_ASSERT(pVl!=NULL);
+	spin_lock_irqsave(
+		&(pVl->Lock),
+		(*pdwIntFlags));
+	pVl->KeyCode++;
+	if(pVl->KeyCode>0x80000000UL) {
+		pVl->KeyCode=1;
+	}
+	result=pVl->KeyCode;
+	return result;
+}
+
+void Vl_ReleaseLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode,DWORD *pdwIntFlags)
+{
+	SMSC_ASSERT(pVl!=NULL);
+	SMSC_ASSERT(pVl->KeyCode==keyCode);
+	spin_unlock_irqrestore(&(pVl->Lock),(*pdwIntFlags));
+}
+
+#ifndef USING_LINT
+module_init(Smsc9118_init_module);
+module_exit(Smsc9118_cleanup_module);
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/st40-gpdma.c linux-2.6.23.1-stm/drivers/net/smsc_911x/st40-gpdma.c
--- linux-2.6.23.1/drivers/net/smsc_911x/st40-gpdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/st40-gpdma.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,252 @@
+/*********/
+/* GPDMA */
+/*********/
+#define DMA_BASE_ADDR		0xB9161000UL
+#define DMA_CHAN_BASE_ADDR(n)	(DMA_BASE_ADDR + ((n + 1) * 0x100UL))
+#define DMA_VCR_STATUS		(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x00UL))
+#define DMA_VCR_VERSION		(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x08UL))
+#define DMA_GLOBAL_ENABLE	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x10UL))
+#define DMA_GLOBAL_DISABLE	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x18UL))
+#define DMA_GLOBAL_STATUS	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x20UL))
+#define DMA_GLOBAL_INTERRUPT	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x28UL))
+#define DMA_GLOBAL_ERROR	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x30UL))
+#define DMA_CHAN_ID(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n)))
+#define DMA_CHAN_ENABLE(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x08UL))
+#define DMA_CHAN_DISABLE(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x10UL))
+#define DMA_CHAN_STATUS(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x18UL))
+#define DMA_CHAN_ACTION(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x20UL))
+#define DMA_CHAN_POINTER(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x28UL))
+#define DMA_CHAN_REQUEST(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x30UL))
+#define DMA_CHAN_CONTROL(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x80UL))
+#define DMA_CHAN_COUNT(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x88UL))
+#define DMA_CHAN_SAR(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x90UL))
+#define DMA_CHAN_DAR(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x98UL))
+
+/* DMAC bitmasks */
+#define DMA_GLOBAL_ENABLE_CHAN_(n)		(0x00000001UL << n)
+#define DMA_GLOBAL_DISABLE_CHAN_(n)		(0x00000001UL << n)
+#define DMA_CHAN_ENABLE_CHAN_			0x00000001UL
+#define DMA_CHAN_DISABLE_ALL_			0x0000003FUL
+#define DMA_CHAN_CONTROL_FREE_RUNNING_		0x00000000UL
+#define DMA_CHAN_CONTROL_TRIGGER_		0x00000001UL
+#define DMA_CHAN_CONTROL_PACED_SOURCE_		0x00000002UL
+#define DMA_CHAN_CONTROL_PACED_DESTINATION_	0x00000003UL
+#define DMA_CHAN_CONTROL_NO_LINK_LIST_		0x00000000UL
+#define DMA_CHAN_CONTROL_FINAL_LINK_ELEM_	0x00000000UL
+#define DMA_CHAN_CONTROL_LINK_ELEM_		0x00000080UL
+#define DMA_CHAN_CONTROL_SRC_TYPE_CONST_	0x00000000UL
+#define DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_	0x00010000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_2BYTES_	0x00080000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_4BYTES_	0x00100000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_	0x00280000UL
+#define DMA_CHAN_CONTROL_DST_TYPE_CONST_	0x00000000UL
+#define DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_	0x01000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_2BYTES_	0x08000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_4BYTES_	0x10000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_32BYTES_	0x28000000UL
+#define DMA_CHAN_ACTION_COMPLETE_ACK_		0x00000002UL
+#define DMA_CHAN_STATUS_COMPLETE_		0x00000002UL
+#define DMA_CHAN_REQUEST0			0x0
+#define DMA_CHAN_REQUEST1			0x1
+#define DMA_CHAN_REQUEST2			0x2
+#define DMA_CHAN_REQUEST3			0x3
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{
+	/* for sh4/st40 only use channels 1-4, do not use channel 0 */
+	if((dwDmaCh >= 1) && (dwDmaCh <= 4)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	DMA_CHAN_ACTION(dwDmaCh) = DMA_CHAN_ACTION_COMPLETE_ACK_;
+
+	// Disable DMA controller
+	DMA_CHAN_DISABLE(dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+	return TRUE;
+}
+
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData)
+{
+	return TRANSFER_PIO;
+}
+
+DWORD Platform_RequestDmaChannelSg(
+	PPLATFORM_DATA platformData)
+{
+	return TRANSFER_PIO;
+}
+
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel)
+{
+	//since Platform_RequestDmaChannel
+	//  never returns a dma channel
+	//  then this function should never be called
+	SMSC_ASSERT(FALSE);
+}
+
+BOOLEAN Platform_IsDmaComplete(
+	const DWORD dwDmaCh)
+{
+	// channel is disable
+	if ((DMA_CHAN_ENABLE(dwDmaCh) &  DMA_CHAN_ENABLE_CHAN_) == 0UL)
+		return TRUE;
+	if ((DMA_CHAN_STATUS(dwDmaCh) & DMA_CHAN_STATUS_COMPLETE_) != 0UL) {
+		Platform_DmaDisable ((PPLATFORM_DATA) 0, dwDmaCh);
+		return TRUE;
+	}
+	else
+		return FALSE;
+}
+
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	DWORD dwTimeOut = 1000000;
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	// channel is disable
+	if ((DMA_CHAN_ENABLE(dwDmaCh) &  DMA_CHAN_ENABLE_CHAN_) == 0UL)
+		return;
+
+	while((dwTimeOut) && ((DMA_CHAN_STATUS(dwDmaCh) & DMA_CHAN_STATUS_COMPLETE_) == 0UL))
+	{
+		udelay(1);
+		dwTimeOut--;
+	}
+	Platform_DmaDisable(platformData, dwDmaCh);
+	if(dwTimeOut == 0)
+	{
+		SMSC_WARNING("Platform_DmaComplete: Timed out");
+	}
+}
+
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	DWORD dwCount;
+
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh));
+	if (Platform_IsDmaComplete(dwDmaCh) == TRUE)
+		return 0UL;
+	else {
+		dwCount = DMA_CHAN_COUNT(dwDmaCh);
+		if (dwCount)
+			return dwCount;
+		else
+			return 1UL;
+	}
+}
+
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh)
+{
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	DMA_CHAN_DISABLE(dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+	DMA_CHAN_COUNT(dwDmaCh) = 0;
+	DMA_GLOBAL_ENABLE = DMA_GLOBAL_ENABLE_CHAN_(dwDmaCh);
+	DMA_CHAN_STATUS(dwDmaCh) = 0UL;		/* no request outstanding */
+	DMA_CHAN_ACTION(dwDmaCh) = DMA_CHAN_ACTION_COMPLETE_ACK_;
+	DMA_CHAN_REQUEST(dwDmaCh) = (dwDmaCh & 3);	/* req# == chan# */
+
+	SMSC_TRACE("Platform_DmaInitialize -- initialising channel %ld", dwDmaCh);
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_CHANn_ENABLE=0x%08lX", DMA_CHAN_ENABLE(dwDmaCh));
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_CHANn_COUNT=0x%08lX", DMA_CHAN_COUNT(dwDmaCh));
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_GLOBAL_ENABLE=0x%08lX", DMA_GLOBAL_ENABLE);
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_ERROR=0x%08lX", DMA_GLOBAL_ERROR);
+
+	return TRUE;
+}
+
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwSrcAddr, dwDestAddr;
+	DWORD dwAlignMask, dwControlRegister;
+	DWORD dwLanPhysAddr, dwMemPhysAddr;
+
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// 2. make sure the channel's not already running
+	if (DMA_CHAN_COUNT(pDmaXfer->dwDmaCh) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg);
+	dwMemPhysAddr = 0x1fffffffUL & CpuToPhysicalAddr((void *)pDmaXfer->pdwBuf);
+
+	// 4. validate the address alignments
+	// need CL alignment for CL bursts
+	dwAlignMask = (PLATFORM_CACHE_LINE_BYTES - 1UL);
+
+	if ((dwLanPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwLanPhysAddr (0x%08lX) alignment", dwLanPhysAddr);
+		return FALSE;
+	}
+
+	if ((dwMemPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwMemPhysAddr (0x%08lX) alignment", dwMemPhysAddr);
+		return FALSE;
+	}
+
+	// 6. Config Control reg
+	// Disable the selected channel first
+	DMA_CHAN_DISABLE(pDmaXfer->dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+
+	// Select correct ch and set SRC, DST and counter
+	dwControlRegister = DMA_CHAN_CONTROL_FREE_RUNNING_ |
+		DMA_CHAN_CONTROL_NO_LINK_LIST_ |
+		DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_ |
+		DMA_CHAN_CONTROL_DST_UNIT_32BYTES_;
+
+	if (pDmaXfer->fMemWr == TRUE)
+	{
+		dwSrcAddr = dwLanPhysAddr;
+		dwDestAddr = dwMemPhysAddr;
+		dwControlRegister |= (DMA_CHAN_CONTROL_SRC_TYPE_CONST_ | DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_);
+	}
+	else
+	{
+		dwSrcAddr = dwMemPhysAddr;
+		dwDestAddr = dwLanPhysAddr;
+		dwControlRegister |= (DMA_CHAN_CONTROL_DST_TYPE_CONST_ | DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_);
+	}
+
+	// Set Source and destination addresses
+	DMA_CHAN_SAR(pDmaXfer->dwDmaCh) = dwSrcAddr;
+	DMA_CHAN_DAR(pDmaXfer->dwDmaCh) = dwDestAddr;
+
+	// Set the transmit size in terms of the xfer mode
+	DMA_CHAN_CONTROL(pDmaXfer->dwDmaCh) = dwControlRegister;
+	DMA_CHAN_COUNT(pDmaXfer->dwDmaCh) = (pDmaXfer->dwDwCnt << 2);
+
+	// Enable DMA controller ch x
+	DMA_CHAN_ENABLE(pDmaXfer->dwDmaCh) = DMA_CHAN_ENABLE_CHAN_;
+
+	// DMA Transfering....
+	return TRUE;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/st40-shdma.c linux-2.6.23.1-stm/drivers/net/smsc_911x/st40-shdma.c
--- linux-2.6.23.1/drivers/net/smsc_911x/st40-shdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/st40-shdma.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,394 @@
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+#include <linux/stm/stm-dma.h>
+#include <linux/stm/fdma-reqs.h>
+
+static struct stm_dma_params tx_transfer;
+
+static void err_cb(unsigned long);
+static DWORD smsc911x_request_dma(const char* chan);
+
+#if defined (CONFIG_SMSC911x_DMA_PACED)
+/* Ideally whould be: pDmaXfer->dwDwCnt*2
+ * Next best would be: MAX_RX_SKBS*2
+ * but for now use: */
+#define MAX_NODELIST_LEN 20
+static struct stm_dma_params rx_transfer_paced[MAX_NODELIST_LEN];
+
+#define SYSCONF_DEVID 0xb9001000
+
+#define SMSC_SHORT_PTK_CHAN 1
+#define SMSC_LONG_PTK_CHAN 0
+
+static struct stm_dma_req_config dma_req_configs[2] = {
+{
+	/* Long packet: 4*read32 */
+	.rw		= REQ_CONFIG_READ,
+	.opcode		= REQ_CONFIG_OPCODE_32,
+	.count		= 4,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 1,
+}, {
+	/* Short packet: 1*read32 */
+	.rw		= REQ_CONFIG_READ,
+	.opcode		= REQ_CONFIG_OPCODE_32,
+	.count		= 1,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 1,
+}};
+
+static struct stm_dma_req *dma_reqs[2];
+
+DWORD Platform_RequestDmaChannelSg(
+	PPLATFORM_DATA platformData)
+{
+	DWORD chan;
+	int devid = ctrl_inl(SYSCONF_DEVID);
+	int chip_7109 = (((devid >> 12) & 0x3ff) == 0x02c);
+	int dma_req_lines[2];
+
+	chan = smsc911x_request_dma(STM_DMA_CAP_ETH_BUF);
+	if (chan < 0)
+		return chan;
+
+	if(chip_7109){
+		dma_req_lines[SMSC_LONG_PTK_CHAN] = STB7109_FDMA_REQ_SSC_1_TX;
+		dma_req_lines[SMSC_SHORT_PTK_CHAN] = STB7109_FDMA_REQ_SSC_2_TX;
+	}
+	else {
+		dma_req_lines[SMSC_LONG_PTK_CHAN] = STB7100_FDMA_REQ_SSC_1_TX;
+		dma_req_lines[SMSC_SHORT_PTK_CHAN] = STB7100_FDMA_REQ_SSC_2_TX;
+	}
+
+	dma_reqs[0] = dma_req_config(chan, dma_req_lines[0], &dma_req_configs[0]);
+	dma_reqs[1] = dma_req_config(chan, dma_req_lines[1], &dma_req_configs[1]);
+
+printk("%s: req %x and %x\n", __FUNCTION__, dma_reqs[0], dma_reqs[1]);
+	return chan;
+}
+
+static void Platform_ReleaseDmaChannel_sg(void)
+{
+	int i;
+
+	for(i=0;i<MAX_NODELIST_LEN;i++)
+		dma_params_free(&rx_transfer_paced[i]);
+}
+
+static void Platform_DmaInitialize_sg(void)
+{
+	int i;
+
+	SMSC_TRACE("DMA Rx using paced transfers to main register bank");
+
+	for(i=0;i<MAX_NODELIST_LEN;i++){
+		dma_params_init(&rx_transfer_paced[i],
+			       MODE_PACED,
+			       STM_DMA_LIST_OPEN);
+	}
+	dma_params_err_cb(&rx_transfer_paced[0], err_cb, 0, STM_DMA_CB_CONTEXT_TASKLET);
+}
+#else
+static struct stm_dma_params rx_transfer_sg;
+
+DWORD Platform_RequestDmaChannelSg(
+	PPLATFORM_DATA platformData)
+{
+	return smsc911x_request_dma(STM_DMA_CAP_LOW_BW);
+}
+
+static void Platform_ReleaseDmaChannel_sg(void)
+{
+	dma_params_free(&rx_transfer_sg);
+}
+
+static void Platform_DmaInitialize_sg(void)
+{
+	dma_params_init(&rx_transfer_sg,
+		       MODE_DST_SCATTER,
+		       STM_DMA_LIST_OPEN);
+	dma_params_err_cb(&rx_transfer_sg, err_cb, 0, STM_DMA_CB_CONTEXT_TASKLET);
+#if defined(CONFIG_SMSC911x_DMA_2D)
+	SMSC_TRACE("DMA Rx using freefrunning 2D transfers");
+	dma_params_DIM_2_x_1(&rx_transfer_sg,0x20,0);
+#elif defined(CONFIG_SMSC911x_DMA_FIFOSEL)
+	SMSC_TRACE("DMA Rx using freefrunning 1D transfers and FIFOSEL");
+	dma_params_DIM_1_x_1(&rx_transfer_sg);
+#else
+#error Unknown DMA mode
+#endif
+}
+#endif
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{
+	if ((dwDmaCh >= 0) && (dwDmaCh < TRANSFER_PIO))
+		return TRUE;
+	return FALSE;
+}
+
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData)
+{
+	return smsc911x_request_dma(STM_DMA_CAP_LOW_BW);
+}
+
+static DWORD smsc911x_request_dma(const char* cap)
+{
+	int chan;
+	const char * dmac_id[] = { STM_DMAC_ID, NULL };
+	const char * cap_channel[] = { cap, NULL };
+
+	chan = request_dma_bycap(dmac_id, cap_channel, "smsc911x");
+	if (chan < 0)
+		return TRANSFER_PIO;
+	return chan;
+}
+
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel)
+{
+	free_dma(dwDmaChannel);
+	dma_params_free(&tx_transfer);
+	Platform_ReleaseDmaChannel_sg();
+}
+
+static void err_cb(unsigned long dummy)
+{
+	printk("DMA err callback");
+}
+
+/* This gets called twice, once each for for Rx and Tx channels */
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh)
+{
+	/* From memory to LAN */
+	dma_params_init(  	&tx_transfer,
+				MODE_FREERUNNING,
+			       	STM_DMA_LIST_OPEN);
+	dma_params_err_cb(&tx_transfer, err_cb, 0, STM_DMA_CB_CONTEXT_TASKLET);
+	dma_params_DIM_1_x_2(&tx_transfer,0x20,0);
+
+	Platform_DmaInitialize_sg();
+
+	return TRUE;
+}
+
+
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwAlignMask;
+	DWORD dwLanPhysAddr, dwMemPhysAddr;
+	struct stm_dma_params *dmap;
+	unsigned long src, dst;
+	unsigned long res=0;
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// 2. make sure the channel's not already running
+	if (dma_get_status(pDmaXfer->dwDmaCh) != DMA_CHANNEL_STATUS_IDLE)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg);
+	dwMemPhysAddr = PHYSADDR(CpuToPhysicalAddr((void *)pDmaXfer->pdwBuf));
+
+	// 4. validate the address alignments
+	// need CL alignment for CL bursts
+	dwAlignMask = (PLATFORM_CACHE_LINE_BYTES - 1UL);
+
+	if ((dwLanPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwLanPhysAddr (0x%08lX) alignment", dwLanPhysAddr);
+		return FALSE;
+	}
+
+	if ((dwMemPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwMemPhysAddr (0x%08lX) alignment", dwMemPhysAddr);
+		return FALSE;
+	}
+
+	// 5. Prepare the DMA channel structure
+	BUG_ON(pDmaXfer->fMemWr);
+	src = PHYSADDR(dwMemPhysAddr);
+	dst = PHYSADDR(dwLanPhysAddr);
+	dmap = &tx_transfer;
+
+	dma_params_comp_cb(dmap,
+			   (void (*)(unsigned long))pCallback,
+			   (unsigned long)pCallbackData,
+			   STM_DMA_CB_CONTEXT_TASKLET);
+	dma_params_addrs(dmap,src,dst, pDmaXfer->dwDwCnt << 2);
+	res=dma_compile_list(pDmaXfer->dwDmaCh, dmap, GFP_ATOMIC);
+	if(res != 0)
+		goto err_exit;
+	// 6. Start the transfer
+	res=dma_xfer_list(pDmaXfer->dwDmaCh,dmap);
+	if(res != 0)
+		goto err_exit;
+
+	// DMA Transfering....
+	return TRUE;
+err_exit:
+	SMSC_WARNING("%s cant initialise DMA engine err_code %ld\n",__FUNCTION__, res);
+	return FALSE;
+}
+
+#if defined (CONFIG_SMSC911x_DMA_PACED)
+
+BOOLEAN Platform_DmaStartSgXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwLanPhysAddr;
+	int res=0;
+	int sg_count;
+	struct scatterlist *sg;
+
+	struct stm_dma_params *param;
+
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// Validate this is a LAN to memory transfer
+	SMSC_ASSERT(pDmaXfer->fMemWr)
+
+	// 2. make sure the channel's not already running
+	if (dma_get_status(pDmaXfer->dwDmaCh) != DMA_CHANNEL_STATUS_IDLE)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = PHYSADDR(CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg));
+
+	// 4. Map (flush) the buffer
+	sg = (struct scatterlist*)pDmaXfer->pdwBuf;
+	sg_count = dma_map_sg(NULL, sg,
+			      pDmaXfer->dwDwCnt,
+			      pDmaXfer->fMemWr ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+
+	// 5. Prepare the DMA channel structure
+	param = rx_transfer_paced;
+	for ( ; sg_count; sg_count--) {
+		int long_len = sg_dma_len(sg) & (~127);
+		int short_len = sg_dma_len(sg) & 127;
+
+		if (long_len) {
+			dma_params_DIM_0_x_1(param);
+			dma_params_addrs(param,
+					dwLanPhysAddr,
+					sg_dma_address(sg),
+					long_len);
+			dma_params_req(param, dma_reqs[SMSC_LONG_PTK_CHAN]);
+			dma_params_link(param, param+1);
+			param++;
+		}
+
+		if (short_len) {
+			dma_params_DIM_0_x_1(param);
+			dma_params_addrs(param,
+					dwLanPhysAddr,
+					sg_dma_address(sg) + long_len,
+					short_len);
+			dma_params_req(param, dma_reqs[SMSC_SHORT_PTK_CHAN]);
+			dma_params_link(param, param+1);
+			param++;
+		}
+
+		sg++;
+	}
+
+	param--;
+	dma_params_link(param, NULL);
+
+	dma_params_comp_cb(rx_transfer_paced,
+			   (void (*)(unsigned long))pCallback,
+			   (unsigned long)pCallbackData,
+			   STM_DMA_CB_CONTEXT_TASKLET);
+	res=dma_compile_list(pDmaXfer->dwDmaCh, rx_transfer_paced, GFP_ATOMIC);
+	if(res != 0)
+		goto err_exit;
+	// 6. Start the transfer
+	dma_xfer_list(pDmaXfer->dwDmaCh,rx_transfer_paced);
+
+	// DMA Transfering....
+	return TRUE;
+err_exit:
+	SMSC_WARNING("%s cant initialise DMA engine err_code %d\n",__FUNCTION__,(int)res);
+	return FALSE;
+}
+
+#else
+
+BOOLEAN Platform_DmaStartSgXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwLanPhysAddr;
+	int res;
+	int sg_count;
+
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// Validate this is a LAN to memory transfer
+	SMSC_ASSERT(pDmaXfer->fMemWr)
+
+	// 2. make sure the channel's not already running
+	if (dma_get_status(pDmaXfer->dwDmaCh) != DMA_CHANNEL_STATUS_IDLE)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = PHYSADDR(CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg));
+#ifdef CONFIG_SMSC911x_DMA_FIFOSEL
+	dwLanPhysAddr += (1<<16);
+#endif
+
+	// 4. Map (flush) the buffer
+	sg_count = dma_map_sg(NULL, (struct scatterlist*)pDmaXfer->pdwBuf,
+			      pDmaXfer->dwDwCnt,
+			      pDmaXfer->fMemWr ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+
+	// 5. Prepare the DMA channel structure
+	dma_params_comp_cb(&rx_transfer_sg,
+			   (void (*)(unsigned long))pCallback,
+			   (unsigned long)pCallbackData,
+			   STM_DMA_CB_CONTEXT_TASKLET);
+	dma_params_addrs(&rx_transfer_sg, dwLanPhysAddr, 0, 0);
+	dma_params_sg(&rx_transfer_sg, (struct scatterlist*)pDmaXfer->pdwBuf, sg_count);
+	res=dma_compile_list(pDmaXfer->dwDmaCh, &rx_transfer_sg, GFP_ATOMIC);
+	if(res != 0)
+		goto err_exit;
+
+	// 6. Start the transfer
+	dma_xfer_list(pDmaXfer->dwDmaCh, &rx_transfer_sg);
+
+	// DMA Transfering....
+	return TRUE;
+err_exit:
+	SMSC_WARNING("%s cant initialise DMA engine err_code %d\n",__FUNCTION__,(int)res);
+	return FALSE;
+}
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/st40.c linux-2.6.23.1-stm/drivers/net/smsc_911x/st40.c
--- linux-2.6.23.1/drivers/net/smsc_911x/st40.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/st40.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,500 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: st40.c
+ *
+ * 03/18/2005 Phong Le, rev 1
+ * Make this driver to work with Lan911x driver Version 1.13
+ *
+ * 03/22/2005 Bryan Whitehead, rev 2
+ * Added support for 16/32 bit autodetect
+ *
+ * 04/11/2005 Bryan Whitehead, rev 3
+ *    updated platform code to support version 1.14 platform changes
+ *
+ * 05/02/2005 Phong Le, rev 4
+ * Make this driver to work with Lan911x driver Version 1.15
+ *
+ ***************************************************************************
+ * NOTE: When making changes to platform specific code please remember to
+ *   update the revision number in the PLATFORM_NAME macro. This is a
+ *   platform specific version number and independent of the
+ *   common code version number. The PLATFORM_NAME macro should be found in
+ *   your platforms ".h" file.
+ */
+
+#ifndef ST40_H
+#define ST40_H
+
+#include <asm-sh/irl.h>
+
+//for a description of these MACROs see readme.txt
+
+#define PLATFORM_IRQ_POL	(0UL)
+#define PLATFORM_IRQ_TYPE	(0UL)
+
+#define DB641_USE_PORT0
+#if defined(CONFIG_SH_STI5528_EVAL)
+/* db641 STEM card plugged into mb376 */
+#ifdef DB641_USE_PORT0
+/* STEM CS0 = BANK3 */
+#define PLATFORM_CSBASE		(0xA3000000UL)
+#define PLATFORM_IRQ		(10UL)
+#else
+/* STEM CS1 = BANK4 */
+#define PLATFORM_CSBASE		(0xA3400000UL)
+#define PLATFORM_IRQ		(9UL)
+#endif
+#elif defined(CONFIG_SH_ST_MB411)
+/* db641 STEM card plugged into mb376 */
+#ifdef DB641_USE_PORT0
+/* STEM CS0 = BankB, A23=0 */
+#define PLATFORM_CSBASE		(0xA1000000UL)
+#define PLATFORM_IRQ		(12UL)
+#else
+/* STEM CS1 = BankB, A23=1 */
+#define PLATFORM_CSBASE		(0xA1800000UL)
+#define PLATFORM_IRQ		(11UL)
+#endif
+#elif defined(CONFIG_SH_ST_MB519)
+/* db641 STEM card plugged into mb519 */
+#ifdef DB641_USE_PORT0
+/* STEM CS0 = BANK1 and A23=0 */
+/* Make sure you read the comment about bodges in mb519/stx7200mboard_init_irq */
+#define PLATFORM_CSBASE		(0xA2000000UL)
+#define PLATFORM_IRQ		(MUXED_IRQ_BASE+4)
+#else
+/* STEM CS1 = BANK4 */
+#define PLATFORM_CSBASE		(0xA2800000UL)
+#define PLATFORM_IRQ		(MUXED_IRQ_BASE+4)
+#endif
+#elif defined(CONFIG_SH_HMS1)
+/* SD HMS1 with in-built SMSC 911x */
+#undef PLATFORM_IRQ_POL
+#undef PLATFORM_IRQ_TYPE
+
+#define PLATFORM_CSBASE		(0x01000000UL)
+#define PLATFORM_IRQ		IRL0_IRQ
+#define PLATFORM_IRQ_POL	(1UL)
+#define PLATFORM_IRQ_TYPE	(1UL)
+#else
+#error Unknown board
+#endif
+
+#define PLATFORM_CACHE_LINE_BYTES (32UL)
+#ifndef CONFIG_SMSC911x_DMA_NONE
+#define PLATFORM_RX_DMA	(TRANSFER_REQUEST_DMA)
+#define PLATFORM_TX_DMA	(TRANSFER_REQUEST_DMA)
+#else
+#define PLATFORM_RX_DMA	(TRANSFER_PIO)
+#define PLATFORM_TX_DMA	(TRANSFER_PIO)
+#endif
+#define PLATFORM_NAME		"ST40 STMICRO r3"
+
+//the dma threshold has not been thoroughly tuned but it is
+//  slightly better than using zero
+#define PLATFORM_DMA_THRESHOLD (200)
+
+typedef struct _PLATFORM_DATA {
+	DWORD dwBitWidth;
+	DWORD dwIdRev;
+	DWORD dwIrq;
+	void * dev_id;
+} PLATFORM_DATA, *PPLATFORM_DATA;
+
+inline void Platform_SetRegDW(
+		DWORD dwLanBase,
+		DWORD dwOffset,
+		DWORD dwVal)
+{
+	(*(volatile DWORD *)(dwLanBase+dwOffset))=dwVal;
+}
+
+inline DWORD Platform_GetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset)
+{
+	return (*(volatile DWORD *)(dwLanBase+dwOffset));
+}
+
+//See readme.txt for a description of how these
+//functions must be implemented
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,
+	DWORD dwBusWidth);
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int irq,void *dev_id),
+	void *dev_id);
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData);
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh);
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh);
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData);
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel);
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*), void* pCallbackData);
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma);
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+
+
+#endif
+
+static const char date_code[] = "072605";
+
+/* SMSC LAN9118 Byte ordering test register offset */
+#define BYTE_TEST_OFFSET	(0x64UL)
+#define ID_REV_OFFSET		(0x50UL)
+
+#define CpuToPhysicalAddr(cpuAddr) ((DWORD)cpuAddr)
+
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase, DWORD dwBusWidth)
+{
+	DWORD dwIdRev=0;
+	SMSC_TRACE("--> Platform_Initialize");
+	SMSC_ASSERT(platformData!=NULL);
+	platformData->dwBitWidth=0;
+
+	if(dwLanBase==0x0UL) {
+		dwLanBase=PLATFORM_CSBASE;
+	}
+
+	dwLanBase = ioremap(dwLanBase, 0x100);
+
+	SMSC_TRACE("Lan Base at 0x%08lX",dwLanBase);
+
+	platformData->dwBitWidth=16;
+
+	dwIdRev=(*(volatile unsigned long *)(dwLanBase+ID_REV_OFFSET));
+	platformData->dwIdRev = dwIdRev;
+
+	SMSC_TRACE("<-- Platform_Initialize");
+	return dwLanBase;
+}
+
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData)
+{
+}
+
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	if (platformData->dwBitWidth == 16) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int,void *),
+	void * dev_id)
+{
+	SMSC_ASSERT(platformData != NULL);
+	SMSC_ASSERT(platformData->dev_id == NULL);
+	if (request_irq(
+		dwIrq,
+		pIsr,
+		0,
+		"SMSC_LAN9118_ISR",
+		dev_id) != 0)
+	{
+		SMSC_WARNING("Unable to use IRQ = %ld", dwIrq);
+		return FALSE;
+	}
+	platformData->dwIrq = dwIrq;
+	platformData->dev_id = dev_id;
+	return TRUE;
+}
+
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	return platformData->dwIrq;
+}
+
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	SMSC_ASSERT(platformData->dev_id != NULL);
+
+	free_irq(platformData->dwIrq, platformData->dev_id);
+
+	platformData->dwIrq = 0;
+	platformData->dev_id = NULL;
+}
+
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes)
+{
+	__flush_invalidate_region((void *)pStartAddress, (dwLengthInBytes));
+}
+
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes)
+{
+	__flush_purge_region((void *)pStartAddress, (dwLengthInBytes));
+}
+
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma)
+{
+	memset(flowControlParameters,0,sizeof(FLOW_CONTROL_PARAMETERS));
+	flowControlParameters->BurstPeriod=100;
+	flowControlParameters->IntDeas=0;
+	if(useDma) {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,16 bit,DMA
+				flowControlParameters->MaxThroughput=(0xEAF0CUL);
+				flowControlParameters->MaxPacketCount=(0x282UL);
+				flowControlParameters->PacketCost=(0xC2UL);
+				flowControlParameters->BurstPeriod=(0x66UL);
+				flowControlParameters->IntDeas=(40UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,16 bit,DMA
+				flowControlParameters->MaxThroughput=0xB3A3CUL;
+				flowControlParameters->MaxPacketCount=0x1E6UL;
+				flowControlParameters->PacketCost=0xF4UL;
+				flowControlParameters->BurstPeriod=0x26UL;
+				flowControlParameters->IntDeas=40UL;
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			/* st40 DMA now only support 16-bit, not 32-bit */
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,32 bit,DMA
+				flowControlParameters->MaxThroughput=(0xC7F82UL);
+				flowControlParameters->MaxPacketCount=(0x21DUL);
+				flowControlParameters->PacketCost=(0x17UL);
+				flowControlParameters->BurstPeriod=(0x1EUL);
+				flowControlParameters->IntDeas=(0x17UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,32 bit,DMA
+				flowControlParameters->MaxThroughput=0xABE0AUL;
+				flowControlParameters->MaxPacketCount=0x1D1UL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x30UL;
+				flowControlParameters->IntDeas=0x0A;
+				break;
+			default:break;//make lint happy
+			}
+		}
+	} else {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,16 bit,PIO
+				flowControlParameters->MaxThroughput=(0xA0C9EUL);
+				flowControlParameters->MaxPacketCount=(0x1B3UL);
+				flowControlParameters->PacketCost=(0x1C4UL);
+				flowControlParameters->BurstPeriod=(0x5CUL);
+				flowControlParameters->IntDeas=(60UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,16 bit,PIO
+				flowControlParameters->MaxThroughput=(0x76A6AUL);
+				flowControlParameters->MaxPacketCount=(0x141UL);
+				flowControlParameters->PacketCost=(0x11AUL);
+				flowControlParameters->BurstPeriod=(0x77UL);
+				flowControlParameters->IntDeas=(70UL);
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			/* st40 PIO now only support 16-bit, not 32-bit */
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,32 bit,PIO
+				flowControlParameters->MaxThroughput=(0xAE5C8UL);
+				flowControlParameters->MaxPacketCount=(0x1D8UL);
+				flowControlParameters->PacketCost=(0UL);
+				flowControlParameters->BurstPeriod=(0x57UL);
+				flowControlParameters->IntDeas=(0x14UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,32 bit,PIO
+				flowControlParameters->MaxThroughput=(0x9E338UL);
+				flowControlParameters->MaxPacketCount=(0x1ACUL);
+				flowControlParameters->PacketCost=(0xD2UL);
+				flowControlParameters->BurstPeriod=(0x60UL);
+				flowControlParameters->IntDeas=(0x0EUL);
+				break;
+			default:break;//make lint happy
+			}
+		}
+	}
+}
+
+#if 0
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	volatile DWORD *pdwReg;
+	pdwReg = (volatile DWORD *)(dwLanBase+TX_DATA_FIFO);
+	while(dwDwordCount)
+	{
+		*pdwReg = *pdwBuf++;
+		dwDwordCount--;
+	}
+}
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	const volatile DWORD * const pdwReg =
+		(const volatile DWORD * const)(dwLanBase+RX_DATA_FIFO);
+
+	while (dwDwordCount)
+	{
+		*pdwBuf++ = *pdwReg;
+		dwDwordCount--;
+	}
+}
+#else
+#include <asm/io.h>
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	writesl(dwLanBase+TX_DATA_FIFO, pdwBuf, dwDwordCount);
+}
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	readsl(dwLanBase+RX_DATA_FIFO, pdwBuf, dwDwordCount);
+}
+#endif
+
+#ifdef CONFIG_SMSC911x_DMA_NONE
+DWORD Platform_RequestDmaChannel(PPLATFORM_DATA platformData)
+{ return TRANSFER_REQUEST_DMA; }
+
+DWORD Platform_RequestDmaChannelSg(PPLATFORM_DATA platformData)
+{ return TRANSFER_REQUEST_DMA; }
+
+void Platform_ReleaseDmaChannel(PPLATFORM_DATA platformData, DWORD dwDmaChannel)
+{ }
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{ return FALSE; }
+
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh)
+{ return FALSE; }
+
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{ return FALSE; }
+
+BOOLEAN Platform_DmaStartSgXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{ return FALSE; }
+#else
+#ifdef CONFIG_STM_DMA
+#include "st40-shdma.c"
+#else
+#include "st40-gpdma.c"
+#endif
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/xscale_linux_2.4.c linux-2.6.23.1-stm/drivers/net/smsc_911x/xscale_linux_2.4.c
--- linux-2.6.23.1/drivers/net/smsc_911x/xscale_linux_2.4.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/xscale_linux_2.4.c	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,762 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: xscale.c
+ ***************************************************************************
+ * 04/11/2005 Bryan Whitehead, rev 2
+ *    updated platform code to support version 1.14 platform changes
+ * 04/15/2005 Bryan Whitehead, rev 3
+ *    migrated to perforce
+ * 06/14/2005 Bryan Whitehead, rev 4
+ *    merged .h file into .c file
+ * 11/07/2005 Phong Le, rev 5
+ *    Update to version 1.21
+ ***************************************************************************
+ * NOTE: When making changes to platform specific code please remember to
+ *   update the revision number in the PLATFORM_NAME macro. This is a
+ *   platform specific version number and independent of the
+ *   common code version number. The PLATFORM_NAME macro should be found in
+ *   your platforms ".h" file.
+ */
+
+static const char date_code[] = "032306";
+
+#ifndef USING_LINT
+#include <asm/hardware.h>
+#include <asm/arch/mainstone.h>
+#include <asm/arch/pxa-regs.h>
+#endif //not USING_LINT
+
+typedef struct _PLATFORM_DATA {
+	DWORD		dwIdRev;
+	DWORD 		dwIrq;
+	void 		*dev_id;
+} PLATFORM_DATA, *PPLATFORM_DATA;
+
+/* for register access */
+typedef volatile unsigned char  Reg8;
+typedef volatile unsigned short Reg16;
+typedef volatile DWORD  Reg32;
+typedef volatile unsigned char  * pReg8;
+typedef volatile unsigned short * pReg16;
+typedef volatile unsigned long *  pReg32;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+#ifndef MST_EXP_BASE
+#define MST_EXP_BASE (0xF5000000)
+#endif
+#ifndef MST_EXP_PHYS
+#define MST_EXP_PHYS (PXA_CS5_PHYS)
+#endif
+//#ifndef MAINSTONE_nExBRD_IRQ
+//#define MAINSTONE_nExBRD_IRQ MAINSTONE_IRQ(7)
+//#endif
+#endif
+
+// Base address (Virtual Address)
+#define LAN_CSBASE 			MST_EXP_BASE
+
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#define LAN_IRQ				MAINSTONE_nExBRD_IRQ
+#else
+//#define LAN_IRQ				MAINSTONE_EXBRD_IRQ
+#define LAN_IRQ				(167)
+#endif
+
+#define LAN_DMACH			(0UL)
+
+// cache organization parameters
+#define CACHE_SIZE_KB		32UL
+#define CACHE_WAYS			32UL
+#define CACHE_LINE_BYTES	32UL
+#define CACHE_ALIGN_MASK		(~(CACHE_LINE_BYTES - 1UL))
+#define CACHE_BYTES_PER_WAY		((CACHE_SIZE_KB * 1024UL) / CACHE_WAYS)
+
+#define PLATFORM_CACHE_LINE_BYTES (CACHE_LINE_BYTES)
+
+#define PLATFORM_IRQ_POL	(0UL)
+#define PLATFORM_IRQ_TYPE	(0UL)
+#define PLATFORM_DMA_THRESHOLD (200)
+
+#define PLATFORM_RX_DMA		(1)
+#define PLATFORM_TX_DMA		(2)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+#define PLATFORM_NAME		"XScale with Linux 2.6 r5"
+#define	PLATFORM_IRQ		(167)
+#else
+#define PLATFORM_NAME		"XScale with Linux 2.4 r5"
+#define	PLATFORM_IRQ		(198)
+#endif
+
+#ifdef USING_LINT
+void CleanCacheLine(DWORD addr);
+void DrainWriteBuffers(void);
+#else //not USING_LINT
+static inline void CleanCacheLine(DWORD addr)
+{
+	addr = addr;		// let lint be happy :-)
+	__asm("mov r0, %0" : : "r" (addr): "r0");
+	__asm("mcr p15, 0, r0, c7, c10, 1");
+	__asm("mcr p15, 0, r0, c7, c6, 1");
+}
+
+static inline void DrainWriteBuffers(void)
+{
+	__asm("mcr p15, 0, r0, c7, c10, 4");
+}
+
+inline void Platform_SetRegDW(
+		DWORD dwLanBase,
+		DWORD dwOffset,
+		DWORD dwVal)
+{
+	(*(volatile DWORD *)(dwLanBase+dwOffset))=dwVal;
+}
+
+inline DWORD Platform_GetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset)
+{
+	return (*(volatile DWORD *)(dwLanBase+dwOffset));
+}
+
+//See readme.txt for a description of how these
+//functions must be implemented
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,
+	DWORD dwBusWidth);
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int irq,void *dev_id,struct pt_regs *regs),
+	void *dev_id);
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData);
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh);
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh);
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData);
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel);
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer);
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma);
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+
+#endif //not USING_LINT
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{
+	if(dwDmaCh<=16) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,DWORD dwBusWidth)
+{
+	DWORD mode=0;
+	DWORD test=0;
+	SMSC_TRACE("--> Platform_Initialize()");
+
+	if(dwLanBase==0x0UL) {
+		dwLanBase=LAN_CSBASE;
+//		SMSC_TRACE("Using dwLanBase==0x%08lX",dwLanBase);
+	}
+
+	if(dwLanBase!=LAN_CSBASE) {
+		SMSC_WARNING("PlatformInitialize: resetting dwLanBase from 0x%08lX to 0x%08X", dwLanBase, LAN_CSBASE);
+		dwLanBase=LAN_CSBASE;
+	}
+
+#define BYTE_TEST_OFFSET	(0x64)
+#define ID_REV_OFFSET		(0x50)
+	switch(dwBusWidth) {
+	case 16:
+		mode=2;
+		MSC2&=0x0000FFFFUL;
+		MSC2|=0x8CD90000UL;
+		test=(*(volatile unsigned long *)(dwLanBase+BYTE_TEST_OFFSET));
+		if(test==0x87654321) {
+			SMSC_TRACE(" 16 bit mode assigned and verified");
+		} else {
+			SMSC_WARNING(" failed to verify assigned 16 bit mode");
+			dwLanBase=0;
+		};break;
+	case 32:
+		mode=1;
+		MSC2&=0x0000FFFFUL;
+		MSC2|=0x8CD10000UL;
+		test=(*(volatile unsigned long *)(dwLanBase+BYTE_TEST_OFFSET));
+		if(test==0x87654321) {
+			SMSC_TRACE(" 32 bit mode assigned and verified");
+		} else {
+			SMSC_WARNING(" failed to verify assigned 32 bit mode");
+			dwLanBase=0;
+		};break;
+	default:
+		mode=1;
+		MSC2&=0x0000FFFFUL;
+		MSC2|=0x8CD10000UL;
+		{
+			WORD dummy=0;
+			test=(*(volatile unsigned long *)(dwLanBase+BYTE_TEST_OFFSET));
+			dummy=(*(volatile unsigned short *)(dwLanBase+BYTE_TEST_OFFSET+2));
+			if(test==0x87654321UL) {
+				SMSC_TRACE(" 32 bit mode detected");
+			} else {
+			//	SMSC_TRACE(" 32 bit mode not detected, test=0x%08lX",test);
+				MSC2|=0x00080000UL;
+				test=(*(volatile unsigned long *)(dwLanBase+BYTE_TEST_OFFSET));
+				if(test==0x87654321UL) {
+					SMSC_TRACE(" 16 bit mode detected");
+					mode=2;
+				} else {
+//					SMSC_WARNING(" test=0x%08lX",test);
+					SMSC_WARNING(" neither 16 nor 32 bit mode detected.");
+					dwLanBase=0;
+				}
+			}
+			dummy=dummy;//make lint happy
+		};break;
+	}
+
+	if(dwLanBase!=0) {
+		DWORD idRev=(*(volatile unsigned long *)(dwLanBase+ID_REV_OFFSET));
+		platformData->dwIdRev=idRev;
+		switch(idRev&0xFFFF0000) {
+		case 0x01180000UL:
+		case 0x01170000UL:
+		case 0x01120000UL:
+		case 0x118A0000UL:
+		case 0x117A0000UL:
+			switch(mode) {
+			case 1://32 bit mode
+				MSC2 &= 0x0000FFFFUL;
+				MSC2 |= 0x83710000UL;
+				break;
+			case 2://16 bit mode
+				MSC2 &= 0x0000FFFFUL;
+				MSC2 |= 0x83790000UL;
+				break;
+			default:break;//make lint happy
+			};break;
+		default:break;//make lint happy
+		}
+	}
+
+	SMSC_TRACE(" MSC2=0x%08X", MSC2);
+	SMSC_TRACE("<-- Platform_Initialize()");
+	return dwLanBase;
+}
+
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData)
+{
+}
+
+BOOLEAN Platform_Is16BitMode(PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData!=NULL);
+
+	if (MSC2 & 0x00080000)
+		return TRUE;
+	else
+		return FALSE;
+}
+
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma)
+{
+	memset(flowControlParameters,0,sizeof(FLOW_CONTROL_PARAMETERS));
+	flowControlParameters->BurstPeriod=100;
+	flowControlParameters->IntDeas=0;
+	if(useDma) {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+			case 0x118A0000UL:
+			case 0x117A0000UL:
+				//117/118,16 bit,DMA
+				flowControlParameters->MaxThroughput=0x10C210UL;
+				flowControlParameters->MaxPacketCount=0x2DCUL;
+				flowControlParameters->PacketCost=0x82UL;
+				flowControlParameters->BurstPeriod=0x75UL;
+				flowControlParameters->IntDeas=0x1CUL;
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+			case 0x116A0000UL:
+			case 0x115A0000UL:
+				//115/116,16 bit,DMA
+				flowControlParameters->MaxThroughput=0x96CF0UL;
+				flowControlParameters->MaxPacketCount=0x198UL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x73UL;
+				flowControlParameters->IntDeas=0x31UL;
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+			case 0x118A0000UL:
+			case 0x117A0000UL:
+				//117/118,32 bit,DMA
+				flowControlParameters->MaxThroughput=0x12D75AUL;
+				flowControlParameters->MaxPacketCount=0x332UL;
+				flowControlParameters->PacketCost=0xDBUL;
+				flowControlParameters->BurstPeriod=0x15UL;
+				flowControlParameters->IntDeas=0x0BUL;
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+			case 0x116A0000UL:
+			case 0x115A0000UL:
+				//115/116,32 bit,DMA
+				flowControlParameters->MaxThroughput=0xF3EB6UL;
+				flowControlParameters->MaxPacketCount=0x29BUL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x41UL;
+				flowControlParameters->IntDeas=0x21UL;
+				break;
+			default:break;//make lint happy
+			}
+		}
+	} else {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+			case 0x118A0000UL:
+			case 0x117A0000UL:
+				//117/118,16 bit,PIO
+				flowControlParameters->MaxThroughput=0xAC3F4UL;
+				flowControlParameters->MaxPacketCount=0x1D2UL;
+				flowControlParameters->PacketCost=0x5FUL;
+				flowControlParameters->BurstPeriod=0x72UL;
+				flowControlParameters->IntDeas=0x02UL;
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+			case 0x116A0000UL:
+			case 0x115A0000UL:
+				//115/116,16 bit,PIO
+				flowControlParameters->MaxThroughput=0x7295CUL;
+				flowControlParameters->MaxPacketCount=0x136UL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x6FUL;
+				flowControlParameters->IntDeas=0x38UL;
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+			case 0x118A0000UL:
+			case 0x117A0000UL:
+				//117/118,32 bit,PIO
+				flowControlParameters->MaxThroughput=0xCB4BCUL;
+				flowControlParameters->MaxPacketCount=0x226;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x77UL;
+				flowControlParameters->IntDeas=0x36UL;
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+			case 0x116A0000UL:
+			case 0x115A0000UL:
+				//115/116,32 bit,PIO
+				flowControlParameters->MaxThroughput=0x9E338UL;
+				flowControlParameters->MaxPacketCount=0x1ACUL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x73UL;
+				flowControlParameters->IntDeas=0x31UL;
+				break;
+			default:break;//make lint happy
+			}
+		}
+	}
+}
+
+void PlatformDisplayInfo(void);
+void PlatformDisplayInfo(void)
+{
+}
+
+BOOLEAN PlatformPossibleIRQ(int Irq);
+BOOLEAN PlatformPossibleIRQ(int Irq)
+{
+	Irq=Irq;//make lint happy
+	return TRUE;
+}
+
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int a,void *b,struct pt_regs *c),
+	void * dev_id)
+{
+	SMSC_ASSERT(platformData!=NULL);
+
+	if(dwIrq==0xFFFFFFFFUL) {
+		dwIrq=LAN_IRQ;
+	}
+
+	if(request_irq(dwIrq, pIsr, SA_INTERRUPT, "SMSC_LAN9118_ISR", dev_id)!=0)
+	{
+		SMSC_WARNING("Unable to use IRQ = %ld",dwIrq);
+		return FALSE;
+	}
+
+	platformData->dwIrq = dwIrq;
+	platformData->dev_id = dev_id;
+	return TRUE;
+}
+
+DWORD Platform_CurrentIRQ(PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData!=NULL);
+	return platformData->dwIrq;
+}
+void Platform_FreeIRQ(PPLATFORM_DATA platformData)
+{
+	if(platformData!=NULL) {
+		free_irq(platformData->dwIrq,platformData->dev_id);
+		platformData->dwIrq=0;
+	} else {
+		SMSC_ASSERT(FALSE);
+	}
+}
+
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData, const DWORD dwDmaCh)
+{
+	// To avoid Lint error
+	DWORD	temp;
+	temp = dwDmaCh;
+	temp = temp;
+
+	platformData=platformData;//make lint happy
+
+	DCSR(dwDmaCh) &= ~DCSR_RUN;
+	while (!(DCSR(dwDmaCh) & DCSR_STOPSTATE)) {};
+
+	return TRUE;
+}
+
+BOOLEAN Platform_DmaInitialize(PPLATFORM_DATA platformData, DWORD dwDmaCh)
+{
+	if(dwDmaCh<256)
+		if(!Platform_DmaDisable(platformData, dwDmaCh)) {
+			return FALSE;
+		}
+
+	return TRUE;
+}
+
+void PurgeCache(
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+void PurgeCache(
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes)
+{
+	DWORD dwCurrAddr, dwEndAddr, dwLinesToGo;
+
+	dwCurrAddr = (DWORD)pStartAddress & CACHE_ALIGN_MASK;
+	dwEndAddr = (((DWORD)pStartAddress) + dwLengthInBytes + (CACHE_LINE_BYTES - 1UL)) & CACHE_ALIGN_MASK;
+
+	dwLinesToGo = (dwEndAddr - dwCurrAddr) / CACHE_LINE_BYTES;
+	while (dwLinesToGo)
+	{
+		CleanCacheLine(dwCurrAddr);
+		dwCurrAddr += CACHE_LINE_BYTES;
+		dwLinesToGo--;
+	}
+	DrainWriteBuffers();
+
+	return;
+}
+
+void Platform_CacheInvalidate(PPLATFORM_DATA platformData, const void * const pStartAddress, const DWORD dwLengthInBytes)
+{
+	platformData=platformData;//make lint happy
+	PurgeCache(pStartAddress, dwLengthInBytes);
+}
+
+void Platform_CachePurge(PPLATFORM_DATA platformData, const void * const pStartAddress, const DWORD dwLengthInBytes)
+{
+	platformData=platformData;//make lint happy
+	PurgeCache(pStartAddress, dwLengthInBytes);
+}
+
+/*
+ * SRAM Mapping on Linux:
+ *		Physical Address = 0xA000_0000 - 0xA3FF_FFFF (Size = 64MB)
+ *		Virtual Address  = 0xC000_0000 - 0xC3FF_FFFF (Size = 64MB)
+ *
+ * Expansion Card (LAN9118) Mapping on Linux 2.4:
+ *		Physical Address = 0x1400_0000 - 0x140F_FFFF (Size = 1MB)
+ *      Virtual Address  = 0xF200_0000 - 0xF20F_FFFF (Size = 1MB)
+
+ * Expansion Card (LAN9118) Mapping on Linux 2.6:
+ *		Physical Address = 0x1400_0000 - 0x140F_FFFF (Size = 1MB)
+ *      Virtual Address  = 0xF500_0000 - 0xF50F_FFFF (Size = 1MB)
+ *
+ */
+DWORD CpuToPhysicalAddr(const void * const pvCpuAddr);
+DWORD CpuToPhysicalAddr(const void * const pvCpuAddr)
+{
+	const DWORD dwVirtAddr = (DWORD) pvCpuAddr;
+	if ((dwVirtAddr >= MST_EXP_BASE) && (dwVirtAddr <= (MST_EXP_BASE+0xFFFFFUL)))
+//	if ((dwVirtAddr >= 0xF2000000UL) && (dwVirtAddr <= 0xF20FFFFFUL))
+	{
+		//Expansion card memory
+		return ((dwVirtAddr - MST_EXP_BASE) + MST_EXP_PHYS);
+	}
+	if ((dwVirtAddr >= 0xC0000000UL) && (dwVirtAddr <= 0xC3FFFFFFUL))
+	{
+		// Linux SDRAM
+		return virt_to_bus(((void *)dwVirtAddr));
+	}
+
+	SMSC_WARNING("Wrong virtual address : 0x%08lx", dwVirtAddr);
+	return (0xFFFFFFFFUL); //invalid/unrecognized address
+}
+
+BOOLEAN Platform_DmaStartXfer(PPLATFORM_DATA platformData, const DMA_XFER * const pDmaXfer)
+{
+
+	DWORD dwDmaCmd;
+	DWORD dwLanPhysAddr, dwMemPhysAddr;
+	DWORD dwAlignMask;
+
+	platformData=platformData;//make lint happy
+
+	//Validate the channel#
+	/*
+	if (pDmaXfer->dwDmaCh != 0UL) //always use channel 0 on XScale
+	{
+		printf("DMAStartXfer -- bad dwDmaCh=%ld\n", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+	*/
+
+	//Check if the channel is currently running
+	if (!(DCSR(pDmaXfer->dwDmaCh) & DCSR_STOPSTATE))
+	{
+		if (DCSR(pDmaXfer->dwDmaCh) & DCSR_RUN)
+		{
+			SMSC_TRACE("DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+			return FALSE;
+		}
+		else
+		{
+			// DMA is not running yet.
+			// Keep going..
+			SMSC_WARNING("DmaStartXfer -- requested channel (%ld) is weird status", pDmaXfer->dwDmaCh);
+		}
+	}
+
+	// calculate the physical transfer addresses
+	dwLanPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg);
+	dwMemPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->pdwBuf);
+
+	dwLanPhysAddr += 0x800;
+
+	// need CL alignment for CL bursts
+	dwAlignMask = (CACHE_LINE_BYTES - 1UL);
+
+	if ((dwLanPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("DmaStartXfer -- bad dwLanPhysAddr (0x%08lX) alignment",
+			dwLanPhysAddr);
+		return FALSE;
+	}
+
+	//if ((dwMemPhysAddr & dwAlignMask) != 0UL)
+	if ((dwMemPhysAddr & 0x03UL) != 0UL)
+	{
+		SMSC_WARNING("DmaStartXfer -- bad dwMemPhysAddr (0x%08lX) alignment",
+			dwMemPhysAddr);
+			return FALSE;
+	}
+
+	//validate the transfer size, On XScale Max size is 8k-1
+	if (pDmaXfer->dwDwCnt >= 8192UL)
+	{
+		SMSC_WARNING("DmaStartXfer -- dwDwCnt =%ld is too big (1^20 bytes max on panax)", pDmaXfer->dwDwCnt);
+		return FALSE;
+	}
+
+	//Note: The DCSR should be cleared, before writing the Target and Source addresses
+	DCSR(pDmaXfer->dwDmaCh) = DCSR_NODESC; //get ready for the DMA
+
+	//Set the Source and Target addresses
+	dwDmaCmd = 0UL;
+	if (pDmaXfer->fMemWr)
+	{
+		//RX
+		DTADR(pDmaXfer->dwDmaCh) = dwMemPhysAddr;
+		DSADR(pDmaXfer->dwDmaCh) = dwLanPhysAddr;
+		dwDmaCmd |= DCMD_INCTRGADDR; //always increment the memory address
+		dwDmaCmd |= DCMD_INCSRCADDR;
+	}
+	else
+	{
+		//TX
+		DTADR(pDmaXfer->dwDmaCh) = dwLanPhysAddr;
+		DSADR(pDmaXfer->dwDmaCh) = dwMemPhysAddr;
+		dwDmaCmd |= DCMD_INCSRCADDR; //always increment the memory address
+		dwDmaCmd |= DCMD_INCTRGADDR;
+	}
+
+	//Set the burst size, if cache line burst set to 32Bytes else set to the smallest
+	dwDmaCmd |= DCMD_BURST32;
+
+	dwDmaCmd |= (DCMD_LENGTH & (pDmaXfer->dwDwCnt << 2));
+	DCMD(pDmaXfer->dwDmaCh) = dwDmaCmd ;
+	DCSR(pDmaXfer->dwDmaCh) |= DCSR_RUN;
+
+	return TRUE;
+}
+
+DWORD Platform_DmaGetDwCnt( PPLATFORM_DATA platformData, const DWORD dwDmaCh)
+{
+	platformData=platformData;//make lint happy
+	return (((DCMD_LENGTH & DCMD(dwDmaCh)) >> 2));
+}
+
+void Platform_DmaComplete(PPLATFORM_DATA platformData, const DWORD dwDmaCh)
+{
+	DWORD dwTimeOut=1000000;
+
+	platformData=platformData;//make lint happy
+
+	while((Platform_DmaGetDwCnt(platformData,dwDmaCh))&&(dwTimeOut))
+	{
+		udelay(1);
+		dwTimeOut--;
+	}
+	if(!Platform_DmaDisable(platformData,dwDmaCh)) {
+		SMSC_WARNING("Failed Platform_DmaDisable");
+	}
+	if(dwTimeOut==0) {
+		SMSC_WARNING("Platform_DmaComplete: Timed out");
+	}
+}
+
+DWORD Platform_RequestDmaChannel(PPLATFORM_DATA platformData)
+{
+	platformData=platformData;//make lint happy
+	return TRANSFER_PIO;
+}
+
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel)
+{
+	platformData=platformData;//make lint happy
+	dwDmaChannel=dwDmaChannel;//make lint happy
+	//since Platform_RequestDmaChannel
+	//  never returns a dma channel
+	//  then this function should never be called
+	SMSC_ASSERT(FALSE);
+}
+
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	volatile DWORD *pdwReg;
+	pdwReg = (volatile DWORD *)(dwLanBase+TX_DATA_FIFO);
+	while(dwDwordCount)
+	{
+		*pdwReg = *pdwBuf++;
+		dwDwordCount--;
+	}
+
+}
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	const volatile DWORD * const pdwReg =
+		(const volatile DWORD * const)(dwLanBase+RX_DATA_FIFO);
+
+	while (dwDwordCount)
+	{
+		*pdwBuf++ = *pdwReg;
+		dwDwordCount--;
+	}
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/smsc_911x/xscale_release_note.txt linux-2.6.23.1-stm/drivers/net/smsc_911x/xscale_release_note.txt
--- linux-2.6.23.1/drivers/net/smsc_911x/xscale_release_note.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/smsc_911x/xscale_release_note.txt	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,32 @@
+Aug-18-04 WH
+
+SMSC9118 beta driver 0.56 for Xscale on Linux 2.4.21-rmk1-pxa1-intc2
+
+This driver is built and tested on Intel Mainstone II board (Rev.B, PXA270 B0/C0).
+
+Linux Kernel is from ARM Linux Site (http://www.arm.linux.org.uk) and
+SMSC modified some of kernel files to be able to support SMSC9118 100/10 Ethernet chip
+connected to Expansion slot of Intel Mainstone Board.
+*NOTE*
+Original Mainstone Board has issue in CPLD code to access Expansion slot.
+To use expansion slot on Mainstone, CPLD should be reprogrammed.
+Unfortunately, there is no official release for that.
+SMSC got help from Intel and resolved the issue in house.
+
+The issues to port to another platform.
+- Current beta driver is built to run on Mainstone II board.
+   To make it run on the other systems, some part of driver need to be changed.
+
+- Physical Address of SMSC9118
+   CS5 is used for Expansion slot on Mainstone II board, SMSC9118 is mapped to CS5 area of PXA270 processor
+   CS5 is mapped to 0xF2000000~0xF20FFFFF (virtual address)
+
+- Interrupt
+   It uses irq number of 198.
+   User can modifiy PLATFORM_IRQ in xscale.h for different value.
+
+- DMA channels
+   This driver uses DMA channel 1 as Rx DMA and 2 as Tx DMA.
+   (See PLATFORM_RX_DMA and PLATFORM_TX_DMA in xscale.h)
+   If those channels are assigned to other devices, these should be changed not to be conflict to other systems.
+   *NOTE* This part will be updated.
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/Makefile linux-2.6.23.1-stm/drivers/net/stmmac/Makefile
--- linux-2.6.23.1/drivers/net/stmmac/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,3 @@
+obj-$(CONFIG_STMMAC_ETH) += mac100.o stmmac.o 
+obj-$(CONFIG_STMGMAC_ETH) += gmac.o stmmac.o 
+stmmac-objs:= stmmac_mdio.o stmmac_ethtool.o stmmac_main.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/gmac.c linux-2.6.23.1-stm/drivers/net/stmmac/gmac.c
--- linux-2.6.23.1/drivers/net/stmmac/gmac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/gmac.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,248 @@
+/* 
+ * drivers/net/stmmac/gmac.c
+ *
+ * Giga Ethernet driver
+ *
+ * Copyright (C) 2007 by STMicroelectronics
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/ethtool.h>
+#include <asm/io.h>
+
+#include "mac_hw.h"
+
+#undef GMAC_DEBUG
+#ifdef GMAC_DEBUG
+#define DBG(klevel, fmt, args...) \
+                printk(KERN_##klevel fmt, ## args)
+#else
+#define DBG(klevel, fmt, args...)  do { } while(0)
+#endif
+
+#define HASH_TABLE_SIZE 64
+
+static void gmac_mac_registers(unsigned long ioaddr)
+{
+	int i;
+	printk("\t----------------------------------------------\n"
+	       "\t  GMAC registers (base addr = 0x%8x)\n"
+	       "\t----------------------------------------------\n",
+	       (unsigned int)ioaddr);
+
+	for (i = 0; i < 55; i++) {
+		if ((i < 12) || (i > 15)) {
+			int offset = i * 4;
+			printk("\tReg No. %d (offset 0x%x): 0x%08x\n", i,
+			       offset, readl(ioaddr + offset));
+		}
+	}
+	return;
+}
+
+static void gmac_dma_registers(unsigned long ioaddr)
+{
+	int i;
+	printk("\t--------------------\n"
+	       "\t   DMA registers\n" "\t--------------------\n");
+	for (i = 0; i < 9; i++) {
+		if ((i < 9) || (i > 17)) {
+			int offset = i * 4;
+			printk("\t Reg No. %d (offset 0x%x): 0x%08x\n", i,
+			       (DMA_BUS_MODE + offset),
+			       readl(ioaddr + DMA_BUS_MODE + offset));
+		}
+	}
+	return;
+}
+
+static int gmac_tx_summary(void *p, unsigned int status)
+{
+	int ret = 0;
+	struct net_device_stats *stats = (struct net_device_stats *)p;
+
+	if (unlikely(status & TDES0_STATUS_DF)) {
+		DBG(WARNING, "gmac: DMA tx: deferred error\n");
+		ret = -1;
+	}
+	if (unlikely(status & TDES0_STATUS_VLAN)) {
+		DBG(WARNING, "gmac: DMA tx: VLAN frame Fails\n");
+		ret = -1;
+	}
+	if (unlikely(status & TDES0_STATUS_ES)) {
+		DBG(ERR, "gmac: DMA tx ERROR: ");
+		if (unlikely(status & TDES0_STATUS_JT))
+			DBG(WARNING, "jabber timeout\n");
+		if (unlikely(status & TDES0_STATUS_FF))
+			DBG(WARNING, "frame flushed\n");
+		if (unlikely(status & TDES0_STATUS_LOSS_CARRIER))
+			DBG(WARNING, "Loss of Carrier\n");
+		if (status & TDES0_STATUS_NO_CARRIER)
+			DBG(ERR, "No Carrier\n");
+		if (status & TDES0_STATUS_LATE_COL) {
+			DBG(ERR, "Late Collision\n");
+			stats->collisions +=
+			    ((status & TDES0_STATUS_COLCNT_MASK) >>
+			     TDES0_STATUS_COLCNT_SHIFT);
+		}
+		if (status & TDES0_STATUS_EX_COL) {
+			DBG(ERR, "Ex Collisions\n");
+			stats->collisions +=
+			    ((status & TDES0_STATUS_COLCNT_MASK) >>
+			     TDES0_STATUS_COLCNT_SHIFT);
+		}
+		if (status & TDES0_STATUS_EX_DEF)
+			DBG(ERR, "Ex Deferrals\n");
+		if (status & TDES0_STATUS_UF)
+			DBG(ERR, "Underflow\n");
+		ret = -1;
+	}
+
+	return (ret);
+}
+
+static int gmac_rx_summary(void *p, unsigned int status)
+{
+	int ret = 0;
+	struct net_device_stats *stats = (struct net_device_stats *)p;
+
+	if (unlikely((status & RDES0_STATUS_ES))) {
+		DBG(ERR, "gmac: DMA rx ERROR: ");
+		if (unlikely(status & RDES0_STATUS_DE))
+			DBG(ERR, "descriptor\n");
+		if (unlikely(status & RDES0_STATUS_OE))
+			DBG(ERR, "Overflow\n");
+		if (unlikely(status & RDES0_STATUS_LC)) {
+			DBG(ERR, "late collision\n");
+			stats->collisions++;
+		}
+		if (unlikely(status & RDES0_STATUS_RWT))
+			DBG(ERR, "watchdog timeout\n");
+		if (unlikely(status & RDES0_STATUS_RE))
+			DBG(ERR, "Receive Error (MII)\n");
+		if (unlikely(status & RDES0_STATUS_CE)) {
+			DBG(ERR, "CRC Error\n");
+			stats->rx_crc_errors++;
+		}
+		ret = -1;
+	}
+	if (unlikely(status & RDES0_STATUS_FILTER_FAIL)) {
+		DBG(ERR, "DMA rx: DA Filtering Fails\n");
+		ret = -1;
+	}
+	if (unlikely(status & RDES0_STATUS_LENGTH_ERROR)) {
+		DBG(ERR, "DMA rx: Lenght error\n");
+		ret = -1;
+	}
+	return (ret);
+}
+
+static void gmac_tx_checksum(struct sk_buff *skb)
+{
+	return;
+}
+
+static void gmac_rx_checksum(struct sk_buff *skb, int status)
+{
+	/* IPC verification */
+	if (unlikely(status & RDES0_STATUS_IPC)) {
+		/* Packet with erroneous checksum, so let the
+		 * upper layers deal with it.  */
+		skb->ip_summed = CHECKSUM_NONE;
+	} else {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+	return;
+}
+
+static void gmac_core_init(struct net_device *dev)
+{
+	unsigned int value = 0;
+	unsigned long ioaddr = dev->base_addr;
+
+	/* Set the MAC control register with our default value */
+	value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+	value |= MAC_CORE_INIT;
+	writel(value, ioaddr + MAC_CONTROL);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	writel(ETH_P_8021Q, dev->base_addr + MAC_VLAN);
+#endif
+	return;
+}
+
+static void gmac_set_filter(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_FRAME_FILTER);
+
+	if (dev->flags & IFF_PROMISC) {
+		value |= MAC_FRAME_FILTER_PR;
+		value &= ~(MAC_FRAME_FILTER_PM);
+	} else if ((dev->mc_count > HASH_TABLE_SIZE)
+		   || (dev->flags & IFF_ALLMULTI)) {
+		value |= MAC_FRAME_FILTER_PM;
+		value &= ~(MAC_FRAME_FILTER_PR | MAC_FRAME_FILTER_DAIF);
+		writel(0xffffffff, ioaddr + MAC_HASH_HIGH);
+		writel(0xffffffff, ioaddr + MAC_HASH_LOW);
+	} else if (dev->mc_count == 0) {
+		value |= MAC_FRAME_FILTER_HUC;
+		value &= ~(MAC_FRAME_FILTER_PM | MAC_FRAME_FILTER_PR |
+			   MAC_FRAME_FILTER_DAIF | MAC_FRAME_FILTER_HMC);
+	} else {		/* Store the addresses in the multicast HW filter */
+		int i;
+		u32 mc_filter[2];
+		struct dev_mc_list *mclist;
+
+		/* Perfect filter mode for physical address and Hash
+		   filter for multicast */
+		value |= MAC_FRAME_FILTER_HMC;
+		value &= ~(MAC_FRAME_FILTER_PR | MAC_FRAME_FILTER_DAIF
+			   | MAC_FRAME_FILTER_PM | MAC_FRAME_FILTER_HUC);
+
+		memset(mc_filter, 0, sizeof(mc_filter));
+		for (i = 0, mclist = dev->mc_list;
+		     mclist && i < dev->mc_count; i++, mclist = mclist->next) {
+			/* The upper 6 bits of the calculated CRC are used to index
+			   the contens of the hash table */
+			int bit_nr =
+			    ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			/* The most significant bit determines the register to use
+			   (H/L) while the other 5 bits determine the bit within
+			   the register. */
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		}
+		writel(mc_filter[0], ioaddr + MAC_HASH_HIGH);
+		writel(mc_filter[1], ioaddr + MAC_HASH_LOW);
+	}
+
+	writel(value, ioaddr + MAC_CONTROL);
+
+	DBG(DEBUG, "%s: CTRL reg: 0x%08x - Hash regs: HI 0x%08x, LO 0x%08x\n",
+	    __FUNCTION__, readl(ioaddr + MAC_CONTROL),
+	    readl(ioaddr + MAC_HASH_HIGH), readl(ioaddr + MAC_HASH_LOW));
+	return;
+}
+
+struct stmmmac_driver mac_driver = {
+	.name = "gmac",
+	.have_hw_fix = 0,
+	.core_init = gmac_core_init,
+	.mac_registers = gmac_mac_registers,
+	.dma_registers = gmac_dma_registers,
+	.check_tx_summary = gmac_tx_summary,
+	.check_rx_summary = gmac_rx_summary,
+	.tx_checksum = gmac_tx_checksum,
+	.rx_checksum = gmac_rx_checksum,
+	.set_filter = gmac_set_filter,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/gmac.h linux-2.6.23.1-stm/drivers/net/stmmac/gmac.h
--- linux-2.6.23.1/drivers/net/stmmac/gmac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/gmac.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,205 @@
+/* 
+ * GMAC header file
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ */
+
+/* --- GMAC BLOCK defines --- */
+#define MAC_CONTROL               0x00000000	/* Configuration */
+#define MAC_FRAME_FILTER          0x00000004	/* Frame Filter */
+#define MAC_HASH_HIGH             0x00000008	/* Multicast Hash Table High */
+#define MAC_HASH_LOW              0x0000000c	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR             0x00000010	/* MII Address */
+#define MAC_MII_DATA             0x00000014	/* MII Data */
+#define MAC_FLOW_CONTROL          0x00000018	/* Flow Control */
+#define MAC_VLAN                  0x0000001c	/* VLAN Tag */
+#define MAC_VERSION               0x00000020	/* GMAC CORE Version */
+#define MAC_WAKEUP_FILTER         0x00000028	/* Wake-up Frame Filter */
+#define MAC_PMT 		   0x0000002c	/* PMT Control and Status */
+/* To be verified */
+/*#define MAC_ADDR_HIGH(reg)	  (0x00000040+(reg*8))
+#define MAC_ADDR_LOW(reg)	  (0x00000044+(reg*8))*/
+#define MAC_ADDR_HIGH   	   0x00000040	/* Mac Address 0 higher 16 bits */
+#define MAC_ADDR_LOW		   0x00000044	/* Mac Address 0 lower 32 bits */
+#define MAC_AN_CTRL		   0x000000c0	/* AN control */
+#define MAC_AN_STATUS  	   0x000000c4	/* AN status */
+#define MAC_ANE_ADV		   0x000000c8	/* Auto-Neg. Advertisement */
+#define MAC_ANE_LINK		   0x000000cc	/* Auto-Neg. link partener ability */
+#define MAC_ANE_EXP		   0x000000d0	/* ANE expansion */
+#define MAC_TBI		   0x000000d4	/* TBI extend status */
+#define MAC_GMII_STATUS 	   0x000000d8	/* S/R-GMII status */
+/* GMAC Configuration defines */
+#define MAC_CONTROL_WD            0x00800000	/* Disable Watchdog */
+#define MAC_CONTROL_JD		   0x00400000	/* Jabber disable */
+#define MAC_CONTROL_BE		   0x00200000	/* Frame Burst Enable */
+#define MAC_CONTROL_JE		   0x00100000	/* Jumbo frame */
+#define MAC_CONTROL_IFG_88	   0x00040000
+#define MAC_CONTROL_IFG_80	   0x00020000
+#define MAC_CONTROL_IFG_40	   0x000e0000
+#define MAC_CONTROL_PS		   0x00008000	/* Port Select 0:GMI 1:MII */
+#define MAC_CONTROL_FES	   0x00004000	/* Speed 0:10 1:100 */
+#define MAC_CONTROL_DO		   0x00002000	/* Disable Rx Own */
+#define MAC_CONTROL_LM		   0x00001000	/* Loop-back mode */
+#define MAC_CONTROL_DM            0x00000800	/* Duplex Mode */
+#define MAC_CONTROL_IPC	   0x00000400	/* Checksum Offload */
+#define MAC_CONTROL_DR            0x00000200	/* Disable Retry */
+#define MAC_CONTROL_LUD           0x00000100	/* Link up/down */
+#define MAC_CONTROL_ACS          0x00000080	/* Automatic Pad Stripping */
+#define MAC_CONTROL_DC            0x00000010	/* Deferral Check */
+#define MAC_CONTROL_TE            0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE            0x00000004	/* Receiver Enable */
+
+#define MAC_CORE_INIT (MAC_CONTROL_JE | MAC_CONTROL_ACS | MAC_CONTROL_IPC)
+
+/* GMAC Frame Filter defines */
+#define MAC_FRAME_FILTER_PR	0x00000001	/* Promiscuous Mode */
+#define MAC_FRAME_FILTER_HUC	0x00000002	/*Hash Unicast */
+#define MAC_FRAME_FILTER_HMC	0x00000004	/*Hash Multicast */
+#define MAC_FRAME_FILTER_DAIF	0x00000008	/*DA Inverse Filtering */
+#define MAC_FRAME_FILTER_PM	0x00000010	/*Pass all multicast */
+#define MAC_FRAME_FILTER_DBF	0x00000020	/*Disable Broadcast frames */
+#define MAC_FRAME_FILTER_RA	0x80000000	/*Receive all mode */
+/* GMII ADDR  defines */
+#define MAC_MII_ADDR_WRITE        0x00000002	/* MII Write */
+#define MAC_MII_ADDR_BUSY         0x00000001	/* MII Busy */
+/* GMAC FLOW CTRL defines */
+#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000	/* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT 16
+#define MAC_FLOW_CONTROL_RFE      0x00000004	/* Rx Flow Control Enable */
+#define MAC_FLOW_CONTROL_TFE      0x00000002	/* Tx Flow Control Enable */
+#define MAC_FLOW_CONTROL_PAUSE    0x00000001	/* Flow Control Busy ... */
+
+/*--- DMA BLOCK defines ---*/
+/* DMA CRS Control and Status Register Mapping */
+#define DMA_BUS_MODE              0x00001000	/* Bus Mode */
+#define DMA_XMT_POLL_DEMAND       0x00001004	/* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND       0x00001008	/* Received Poll Demand */
+#define DMA_RCV_BASE_ADDR         0x0000100c	/* Receive List Base */
+#define DMA_TX_BASE_ADDR          0x00001010	/* Transmit List Base */
+#define DMA_STATUS                0x00001014	/* Status Register */
+#define DMA_CONTROL               0x00001018	/* Operation Mode */
+#define DMA_INTR_ENA              0x0000101c	/* Interrupt Enable */
+#define DMA_MISSED_FRAME_CTR      0x00001020	/* Missed Frame Counter and Buffer Overflow Counter */
+#define DMA_HOST_TX_DESC	  0x00001048	/* Current Host Tx descriptor */
+#define DMA_HOST_RX_DESC	  0x0000104c	/* Current Host Rx descriptor */
+#define DMA_CUR_TX_BUF_ADDR       0x00001050	/* Current Host Transmit Buffer */
+#define DMA_CUR_RX_BUF_ADDR       0x00001054	/* Current Host Receive Buffer */
+/*  DMA Bus Mode register defines */
+#define DMA_BUS_MODE_SFT_RESET    0x00000001	/* Software Reset */
+#define DMA_BUS_MODE_BAR_BUS      0x00000002	/* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_DSL_MASK     0x0000007c	/* Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT    2
+#define DMA_BUS_MODE_PBL_MASK     0x00003f00	/* Programmable Burst Length */
+#define DMA_BUS_MODE_PBL_SHIFT    8
+#define DMA_BUS_PR_RATIO_MASK	  0x0000c000	/* Rx/Tx priority ratio */
+#define DMA_BUS_PR_RATIO_SHIFT	  14
+#define DMA_BUS_FB	  	  0x00010000	/* Fixed Burst */
+#define DMA_BUS_MODE_DEFAULT      0x00000000
+/* DMA Status register defines */
+#define DMA_STATUS_GPI		0x10000000	/* PMT interrupt */
+#define DMA_STATUS_GMI		0x08000000	/* MMC interrupt */
+#define DMA_STATUS_GLI		0x04000000	/* GMAC Line interface interrupt */
+#define DMA_STATUS_EB_MASK        0x00380000	/* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT    0x00080000	/* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT    0x00100000	/* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK        0x00700000	/* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT       20
+#define DMA_STATUS_RS_MASK        0x000e0000	/* Receive Process State */
+#define DMA_STATUS_RS_SHIFT       17
+#define DMA_STATUS_NIS            0x00010000	/* Normal Interrupt Summary */
+#define DMA_STATUS_AIS            0x00008000	/* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI            0x00004000	/* Early Receive Interrupt */
+#define DMA_STATUS_FBI            0x00002000	/* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI            0x00000400	/* Early Transmit Interrupt */
+#define DMA_STATUS_RWT            0x00000200	/* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS            0x00000100	/* Receive Process Stopped */
+#define DMA_STATUS_RU             0x00000080	/* Receive Buffer Unavailable */
+#define DMA_STATUS_RI             0x00000040	/* Receive Interrupt */
+#define DMA_STATUS_UNF            0x00000020	/* Transmit Underflow */
+#define DMA_STATUS_OVF            0x00000010	/* Receive Overflow */
+#define DMA_STATUS_TJT            0x00000008	/* Transmit Jabber Timeout */
+#define DMA_STATUS_TU             0x00000004	/* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS            0x00000002	/* Transmit Process Stopped */
+#define DMA_STATUS_TI             0x00000001	/* Transmit Interrupt */
+/* DMA operation mode defines */
+#define DMA_CONTROL_SF            0x00200000	/* Store And Forward */
+#define DMA_CONTROL_FTF		  0x00100000	/* Flush transmit FIFO */
+#define DMA_CONTROL_TTC_MASK      0x0001c000	/* Transmit Threshold Control */
+#define DMA_CONTROL_ST            0x00002000	/* Start/Stop Transmission */
+#define DMA_CONTROL_SR            0x00000002	/* Start/Stop Receive */
+/* DMA Interrupt Enable register defines */
+#define DMA_INTR_ENA_NIE          0x00010000	/* Normal Interrupt Summary */
+#define DMA_INTR_ENA_AIE          0x00008000	/* Abnormal Interrupt Summary */
+#define DMA_INTR_ENA_ERE          0x00004000	/* Early Receive */
+#define DMA_INTR_ENA_FBE          0x00002000	/* Fatal Bus Error */
+#define DMA_INTR_ENA_ETE          0x00000400	/* Early Transmit */
+#define DMA_INTR_ENA_RWE          0x00000200	/* Receive Watchdog */
+#define DMA_INTR_ENA_RSE          0x00000100	/* Receive Stopped */
+#define DMA_INTR_ENA_RUE          0x00000080	/* Receive Buffer Unavailable */
+#define DMA_INTR_ENA_RIE          0x00000040	/* Receive Interrupt */
+#define DMA_INTR_ENA_UNE          0x00000020	/* Underflow */
+#define DMA_INTR_ENA_OVE          0x00000010	/* Receive Overflow */
+#define DMA_INTR_ENA_TJE          0x00000008	/* Transmit Jabber */
+#define DMA_INTR_ENA_TUE          0x00000004	/* Transmit Buffer Unavailable */
+#define DMA_INTR_ENA_TSE          0x00000002	/* Transmit Stopped */
+#define DMA_INTR_ENA_TIE          0x00000001	/* Transmit Interrupt */
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_RIE | \
+				DMA_INTR_ENA_TIE)
+#define DMA_INTR_NO_RX		(DMA_INTR_ENA_NIE | DMA_INTR_ENA_TIE)
+
+/* --- Descriptor defines --- */
+/* Common fields */
+#define OWN_BIT			0x80000000	/* Own Bit (owned by hardware) */
+#define DES1_CONTROL_CH		0x01000000	/* Second Address Chained */
+#define DES1_CONTROL_TER	0x02000000	/* End of Ring */
+#define DES1_RBS2_SIZE_MASK	0x003ff800	/* Buffer 2 Size Mask */
+#define DES1_RBS2_SIZE_SHIFT	11	/* Buffer 2 Size Shift */
+#define DES1_RBS1_SIZE_MASK	0x000007ff	/* Buffer 1 Size Mask */
+#define DES1_RBS1_SIZE_SHIFT	0	/* Buffer 1 Size Shift */
+
+/* Receive Descriptor 1*/
+#define RDES1_CONTROL_DIOC        0x80000000	/* Disable Intr On Completion */
+/* Receive Descriptor 0*/
+#define RDES0_STATUS_FILTER_FAIL  0x40000000	/* DA Filtering Fails */
+#define RDES0_STATUS_FL_MASK      0x3fff0000	/* Frame Length Mask */
+#define RDES0_STATUS_FL_SHIFT     16	/* Frame Length Shift */
+#define RDES0_STATUS_ES           0x00008000	/* Error Summary */
+#define RDES0_STATUS_DE           0x00004000	/* Descriptor Error */
+#define RDES0_STATUS_SAF          0x00002000	/* Source Address filter Fail */
+#define RDES0_STATUS_LENGTH_ERROR 0x00001000	/* Length Error */
+#define RDES0_STATUS_OE     0x00000800	/* Overflow Error */
+#define RDES0_STATUS_VLAN 0x00000400	/* VLAN tag */
+#define RDES0_STATUS_FS           0x00000200	/* First Descriptor */
+#define RDES0_STATUS_LS           0x00000100	/* Last Descriptor */
+#define RDES0_STATUS_IPC           0x00000080	/* Checksum Error */
+#define RDES0_STATUS_LC     0x00000040	/* Collision Seen */
+#define RDES0_STATUS_FT     0x00000020	/* Frame Type */
+#define RDES0_STATUS_RWT  0x00000010	/* Receive Watchdog */
+#define RDES0_STATUS_RE      0x00000008	/* Receive Error  */
+#define RDES0_STATUS_DRIBBLE      0x00000004	/* Dribbling Bit */
+#define RDES0_STATUS_CE           0x00000002	/* CRC Error */
+#define RDES0_STATUS_RX_MAC_ADDR            0x00000001	/* RX MAC ADDR. */
+
+/* Transmit Descriptor */
+#define TDES0_STATUS_ES		  0x00008000	/* Error Summary */
+#define TDES0_STATUS_JT		  0x00004000	/* jabber timeout */
+#define TDES0_STATUS_FF		  0x00002000	/* frame flushed */
+#define TDES0_STATUS_LOSS_CARRIER 0x00000800	/* Loss of Carrier */
+#define TDES0_STATUS_NO_CARRIER   0x00000400	/* No Carrier */
+#define TDES0_STATUS_LATE_COL     0x00000200	/* Late Collision */
+#define TDES0_STATUS_EX_COL       0x00000100	/* Excessive Collisions */
+#define TDES0_STATUS_VLAN   0x00000080	/* VLAN FRAME */
+#define TDES0_STATUS_COLCNT_MASK  0x00000078	/* Collision Count Mask */
+#define TDES0_STATUS_COLCNT_SHIFT 3	/* Collision Count Shift */
+#define TDES0_STATUS_EX_DEF       0x00000004	/* Excessive Deferrals */
+#define TDES0_STATUS_UF           0x00000002	/* Underflow Error */
+#define TDES0_STATUS_DF           0x00000001	/* Deferred */
+#define TDES1_CONTROL_IC          0x80000000	/* Interrupt on Completion */
+#define TDES1_CONTROL_LS          0x40000000	/* Last Segment */
+#define TDES1_CONTROL_FS          0x20000000	/* First Segment */
+#define TDES1_CONTROL_AC          0x04000000	/* Add CRC Disable */
+#define TDES1_CONTROL_DPD         0x00800000	/* Disable Padding */
+
+#define STMMAC_FULL_DUPLEX MAC_CONTROL_DM
+#define STMMAC_PORT	   MAC_CONTROL_PS
+#define STMMAC_SPEED_100   MAC_CONTROL_FES
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/mac100.c linux-2.6.23.1-stm/drivers/net/stmmac/mac100.c
--- linux-2.6.23.1/drivers/net/stmmac/mac100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/mac100.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,280 @@
+/* 
+ * drivers/net/stmmac/mac100.c
+ *
+ * This is a driver for the MAC 10/100 on-chip
+ * Ethernet controller currently present on STb7109.
+ *
+ * Copyright (C) 2007 by STMicroelectronics
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ *
+*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <asm/io.h>
+
+#include "mac_hw.h"
+
+#define HASH_TABLE_SIZE 64
+
+#undef MAC100_DEBUG
+#ifdef MAC100_DEBUG
+#define DBG(klevel, fmt, args...) \
+                printk(KERN_##klevel fmt, ## args)
+#else
+#define DBG(klevel, fmt, args...)  do { } while(0)
+#endif
+
+static void mac100_mac_registers(unsigned long ioaddr)
+{
+	printk("\t----------------------------------------------\n"
+	       "\t  MAC100 CSR (base addr = 0x%8x)\n"
+	       "\t----------------------------------------------\n",
+	       (unsigned int)ioaddr);
+	printk("\tcontrol reg (offset 0x%x): 0x%08x\n", MAC_CONTROL,
+	       readl(ioaddr + MAC_CONTROL));
+	printk("\taddr HI (offset 0x%x): 0x%08x\n ", MAC_ADDR_HIGH,
+	       readl(ioaddr + MAC_ADDR_HIGH));
+	printk("\taddr LO (offset 0x%x): 0x%08x\n", MAC_ADDR_LOW,
+	       readl(ioaddr + MAC_ADDR_LOW));
+	printk("\tmulticast hash HI (offset 0x%x): 0x%08x\n", MAC_HASH_HIGH,
+	       readl(ioaddr + MAC_HASH_HIGH));
+	printk("\tmulticast hash LO (offset 0x%x): 0x%08x\n", MAC_HASH_LOW,
+	       readl(ioaddr + MAC_HASH_LOW));
+	printk("\tflow control (offset 0x%x): 0x%08x\n", MAC_FLOW_CONTROL,
+	       readl(ioaddr + MAC_FLOW_CONTROL));
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	printk("\tVLAN1 tag (offset 0x%x): 0x%08x\n", MAC_VLAN1,
+	       readl(ioaddr + MAC_VLAN1));
+	printk("\tVLAN2 tag (offset 0x%x): 0x%08x\n", MAC_VLAN2,
+	       readl(ioaddr + MAC_VLAN2));
+#endif
+	printk("\tmac wakeup frame (offset 0x%x): 0x%08x\n", MAC_WAKEUP_FILTER,
+	       readl(ioaddr + MAC_WAKEUP_FILTER));
+	printk("\tmac wakeup crtl (offset 0x%x): 0x%08x\n",
+	       MAC_WAKEUP_CONTROL_STATUS,
+	       readl(ioaddr + MAC_WAKEUP_CONTROL_STATUS));
+
+	printk("\n\tMAC management counter registers\n");
+	printk("\t MMC crtl (offset 0x%x): 0x%08x\n",
+	       MMC_CONTROL, readl(ioaddr + MMC_CONTROL));
+	printk("\t MMC High Interrupt (offset 0x%x): 0x%08x\n",
+	       MMC_HIGH_INTR, readl(ioaddr + MMC_HIGH_INTR));
+	printk("\t MMC Low Interrupt (offset 0x%x): 0x%08x\n",
+	       MMC_LOW_INTR, readl(ioaddr + MMC_LOW_INTR));
+	printk("\t MMC High Interrupt Mask (offset 0x%x): 0x%08x\n",
+	       MMC_HIGH_INTR_MASK, readl(ioaddr + MMC_HIGH_INTR_MASK));
+	printk("\t MMC Low Interrupt Mask (offset 0x%x): 0x%08x\n",
+	       MMC_LOW_INTR_MASK, readl(ioaddr + MMC_LOW_INTR_MASK));
+	return;
+}
+
+static void mac100_dma_registers(unsigned long ioaddr)
+{
+	int i;
+	printk("\t--------------------\n"
+	       "\t   MAC100 DMA CSR \n" "\t--------------------\n");
+	for (i = 0; i < 9; i++) {
+		printk("\t CSR%d (offset 0x%x): 0x%08x\n", i,
+		       (DMA_BUS_MODE + i * 4),
+		       readl(ioaddr + DMA_BUS_MODE + i * 4));
+	}
+	printk("\t CSR20 (offset 0x%x): 0x%08x\n",
+	       DMA_CUR_TX_BUF_ADDR, readl(ioaddr + DMA_CUR_TX_BUF_ADDR));
+	printk("\t CSR21 (offset 0x%x): 0x%08x\n",
+	       DMA_CUR_RX_BUF_ADDR, readl(ioaddr + DMA_CUR_RX_BUF_ADDR));
+	return;
+}
+
+static int mac100_tx_summary(void *p, unsigned int status)
+{
+	int ret = 0;
+	struct net_device_stats *stats = (struct net_device_stats *)p;
+
+	if (unlikely(status & TDES0_STATUS_ES)) {
+		DBG(ERR, "mac100: DMA tx ERROR: ");
+		if (status & TDES0_STATUS_UF) {
+			DBG(ERR, "Underflow Error\n");
+			stats->tx_fifo_errors++;
+		}
+		if (status & TDES0_STATUS_NO_CARRIER) {
+			DBG(ERR, "No Carrier detected\n");
+			stats->tx_carrier_errors++;
+		}
+		if (status & TDES0_STATUS_LOSS_CARRIER) {
+			DBG(ERR, "Loss of Carrier\n");
+		}
+		if ((status & TDES0_STATUS_EX_DEF) ||
+		    (status & TDES0_STATUS_EX_COL) ||
+		    (status & TDES0_STATUS_LATE_COL)) {
+			stats->collisions +=
+			    ((status & TDES0_STATUS_COLCNT_MASK) >>
+			     TDES0_STATUS_COLCNT_SHIFT);
+		}
+		ret = -1;
+	}
+
+	if (unlikely(status & TDES0_STATUS_HRTBT_FAIL)) {
+		DBG(ERR, "mac100: Heartbeat Fail\n");
+		stats->tx_heartbeat_errors++;
+		ret = -1;
+	}
+	if (unlikely(status & TDES0_STATUS_DF)) {
+		DBG(WARNING, "mac100: tx deferred\n");
+		/*ret = -1; */
+	}
+
+	return (ret);
+}
+
+/* This function verifies if the incoming frame has some errors 
+ * and, if required, updates the multicast statistics. */
+static int mac100_rx_summary(void *p, unsigned int status)
+{
+	int ret = 0;
+	struct net_device_stats *stats = (struct net_device_stats *)p;
+
+	if ((status & RDES0_STATUS_ERROR)) {
+		DBG(ERR, "stmmaceth RX:\n");
+		if (status & RDES0_STATUS_DE)
+			DBG(ERR, "\tdescriptor error\n");
+		if (status & RDES0_STATUS_PFE)
+			DBG(ERR, "\tpartial frame error\n");
+		if (status & RDES0_STATUS_RUNT_FRM)
+			DBG(ERR, "\trunt Frame\n");
+		if (status & RDES0_STATUS_TL)
+			DBG(ERR, "\tframe too long\n");
+		if (status & RDES0_STATUS_COL_SEEN) {
+			DBG(ERR, "\tcollision seen\n");
+			stats->collisions++;
+		}
+		if (status & RDES0_STATUS_CE) {
+			DBG(ERR, "\tCRC Error\n");
+			stats->rx_crc_errors++;
+		}
+
+		if (status & RDES0_STATUS_LENGTH_ERROR)
+			DBG(ERR, "\tLenght error\n");
+		if (status & RDES0_STATUS_MII_ERR)
+			DBG(ERR, "\tMII error\n");
+
+		ret = -1;
+	}
+
+	/* update multicast stats */
+	if (status & RDES0_STATUS_MULTICST_FRM)
+		stats->multicast++;
+
+	return (ret);
+}
+
+static void mac100_tx_checksum(struct sk_buff *skb)
+{
+	/* Verify the csum via software... it' necessary, because the
+	 * hardware doesn't support a complete csum calculation. */
+	if (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {
+		const int offset = skb_transport_offset(skb);
+		unsigned int csum =
+		    skb_checksum(skb, offset, skb->len - offset, 0);
+		*(u16 *) (skb->data + offset + skb->csum_offset) =
+		    csum_fold(csum);
+	}
+	return;
+}
+
+static void mac100_rx_checksum(struct sk_buff *skb, int status)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+	return;
+}
+
+static void mac100_core_init(struct net_device *dev)
+{
+	unsigned int value = 0;
+	unsigned long ioaddr = dev->base_addr;
+
+	DBG(DEBUG, "mac100_core_init");
+
+	/* Set the MAC control register with our default value */
+	value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+	writel((value | MAC_CORE_INIT), ioaddr + MAC_CONTROL);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	writel(ETH_P_8021Q, dev->base_addr + MAC_VLAN1);
+#endif
+	return;
+}
+
+static void mac100_set_filter(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+	if (dev->flags & IFF_PROMISC) {
+		value |= MAC_CONTROL_PR;
+		value &= ~(MAC_CONTROL_PM | MAC_CONTROL_IF | MAC_CONTROL_HO |
+			   MAC_CONTROL_HP);
+	} else if ((dev->mc_count > HASH_TABLE_SIZE)
+		   || (dev->flags & IFF_ALLMULTI)) {
+		value |= MAC_CONTROL_PM;
+		value &= ~(MAC_CONTROL_PR | MAC_CONTROL_IF | MAC_CONTROL_HO);
+		writel(0xffffffff, ioaddr + MAC_HASH_HIGH);
+		writel(0xffffffff, ioaddr + MAC_HASH_LOW);
+	} else if (dev->mc_count == 0) {	/* Just get our own stuff .. no multicast?? */
+		value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |
+			   MAC_CONTROL_HO | MAC_CONTROL_HP);
+	} else {		/* Store the addresses in the multicast HW filter */
+		int i;
+		u32 mc_filter[2];
+		struct dev_mc_list *mclist;
+
+		/* Perfect filter mode for physical address and Hash
+		   filter for multicast */
+		value |= MAC_CONTROL_HP;
+		value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF
+			   | MAC_CONTROL_HO);
+
+		memset(mc_filter, 0, sizeof(mc_filter));
+		for (i = 0, mclist = dev->mc_list;
+		     mclist && i < dev->mc_count; i++, mclist = mclist->next) {
+			/* The upper 6 bits of the calculated CRC are used to 
+			 * index the contens of the hash table */
+			int bit_nr =
+			    ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			/* The most significant bit determines the register to 
+			 * use (H/L) while the other 5 bits determine the bit 
+			 * within the register. */
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		}
+		writel(mc_filter[0], ioaddr + MAC_HASH_LOW);
+		writel(mc_filter[1], ioaddr + MAC_HASH_HIGH);
+	}
+
+	writel(value, ioaddr + MAC_CONTROL);
+
+	DBG(DEBUG, "%s: CTRL reg: 0x%08x - Hash regs: HI 0x%08x, LO 0x%08x\n",
+	    __FUNCTION__, readl(ioaddr + MAC_CONTROL),
+	    readl(ioaddr + MAC_HASH_HIGH), readl(ioaddr + MAC_HASH_LOW));
+	return;
+}
+
+struct stmmmac_driver mac_driver = {
+	.name = "mac100",
+	.have_hw_fix = 1,
+	.core_init = mac100_core_init,
+	.mac_registers = mac100_mac_registers,
+	.dma_registers = mac100_dma_registers,
+	.check_tx_summary = mac100_tx_summary,
+	.check_rx_summary = mac100_rx_summary,
+	.tx_checksum = mac100_tx_checksum,
+	.rx_checksum = mac100_rx_checksum,
+	.set_filter = mac100_set_filter,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/mac100.h linux-2.6.23.1-stm/drivers/net/stmmac/mac100.h
--- linux-2.6.23.1/drivers/net/stmmac/mac100.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/mac100.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,224 @@
+/* 
+ * MAC 10/100 header file
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ */
+
+/*----------------------------------------------------------------------------
+ *	 			MAC BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* MAC CSR offset */
+#define MAC_CONTROL               0x00000000	/* MAC Control */
+#define MAC_ADDR_HIGH             0x00000004	/* MAC Address High */
+#define MAC_ADDR_LOW              0x00000008	/* MAC Address Low */
+#define MAC_HASH_HIGH             0x0000000c	/* Multicast Hash Table High */
+#define MAC_HASH_LOW              0x00000010	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR              0x00000014	/* MII Address */
+#define MAC_MII_DATA              0x00000018	/* MII Data */
+#define MAC_FLOW_CONTROL          0x0000001c	/* Flow Control */
+#define MAC_VLAN1                 0x00000020	/* VLAN1 Tag */
+#define MAC_VLAN2                 0x00000024	/* VLAN2 Tag */
+#define MAC_WAKEUP_FILTER         0x00000028	/* Wake-up Frame Filter */
+#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c	/* Wake-up Control And Status */
+
+/* MAC CTRL defines */
+#define MAC_CONTROL_RA            0x80000000	/* Receive All Mode */
+#define MAC_CONTROL_BLE           0x40000000	/* Endian Mode */
+#define MAC_CONTROL_HBD           0x10000000	/* Heartbeat Disable */
+#define MAC_CONTROL_PS            0x08000000	/* Port Select */
+#define MAC_CONTROL_DRO           0x00800000	/* Disable Receive Own */
+#define MAC_CONTROL_EXT_LOOPBACK  0x00400000	/* Reserved (ext loopback?) */
+#define MAC_CONTROL_OM            0x00200000	/* Loopback Operating Mode */
+#define MAC_CONTROL_F             0x00100000	/* Full Duplex Mode */
+#define MAC_CONTROL_PM            0x00080000	/* Pass All Multicast */
+#define MAC_CONTROL_PR            0x00040000	/* Promiscuous Mode */
+#define MAC_CONTROL_IF            0x00020000	/* Inverse Filtering */
+#define MAC_CONTROL_PB            0x00010000	/* Pass Bad Frames */
+#define MAC_CONTROL_HO            0x00008000	/* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP            0x00002000	/* Hash/Perfect Filtering Mode */
+#define MAC_CONTROL_LCC           0x00001000	/* Late Collision Control */
+#define MAC_CONTROL_DBF           0x00000800	/* Disable Broadcast Frames */
+#define MAC_CONTROL_DRTY          0x00000400	/* Disable Retry */
+#define MAC_CONTROL_ASTP          0x00000100	/* Automatic Pad Stripping */
+#define MAC_CONTROL_BOLMT_10      0x00000000	/* Back Off Limit 10 */
+#define MAC_CONTROL_BOLMT_8       0x00000040	/* Back Off Limit 8 */
+#define MAC_CONTROL_BOLMT_4       0x00000080	/* Back Off Limit 4 */
+#define MAC_CONTROL_BOLMT_1       0x000000c0	/* Back Off Limit 1 */
+#define MAC_CONTROL_DC            0x00000020	/* Deferral Check */
+#define MAC_CONTROL_TE            0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE            0x00000004	/* Receiver Enable */
+
+#define MAC_CORE_INIT (MAC_CONTROL_HBD | MAC_CONTROL_ASTP)
+
+/* MAC FLOW CTRL defines */
+#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000	/* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT 16
+#define MAC_FLOW_CONTROL_PCF      0x00000004	/* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE      0x00000002	/* Flow Control Enable */
+#define MAC_FLOW_CONTROL_PAUSE    0x00000001	/* Flow Control Busy ... */
+
+/* MII ADDR  defines */
+#define MAC_MII_ADDR_WRITE        0x00000002	/* MII Write */
+#define MAC_MII_ADDR_BUSY         0x00000001	/* MII Busy */
+
+/* MAC Management Counters register */
+#define MMC_CONTROL               0x00000100	/* MMC Control */
+#define MMC_HIGH_INTR             0x00000104	/* MMC High Interrupt */
+#define MMC_LOW_INTR              0x00000108	/* MMC Low Interrupt */
+#define MMC_HIGH_INTR_MASK        0x0000010c	/* MMC High Interrupt Mask */
+#define MMC_LOW_INTR_MASK         0x00000110	/* MMC Low Interrupt Mask */
+
+#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8	/* Maximum Frame Size */
+#define MMC_CONTROL_MAX_FRM_SHIFT 3
+#define MMC_CONTROL_MAX_FRAME 	  0x7FF
+
+/*----------------------------------------------------------------------------
+ * 				DMA BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* DMA CRS Control and Status Register Mapping */
+#define DMA_BUS_MODE              0x00001000	/* Bus Mode */
+#define DMA_XMT_POLL_DEMAND       0x00001004	/* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND       0x00001008	/* Received Poll Demand */
+#define DMA_RCV_BASE_ADDR         0x0000100c	/* Receive List Base */
+#define DMA_TX_BASE_ADDR          0x00001010	/* Transmit List Base */
+#define DMA_STATUS                0x00001014	/* Status Register */
+#define DMA_CONTROL               0x00001018	/* Control (Operational Mode) */
+#define DMA_INTR_ENA              0x0000101c	/* Interrupt Enable */
+#define DMA_MISSED_FRAME_CTR      0x00001020	/* Missed Frame Counter */
+#define DMA_CUR_TX_BUF_ADDR       0x00001050	/* Current Host Transmit Buffer */
+#define DMA_CUR_RX_BUF_ADDR       0x00001054	/* Current Host Receive Buffer */
+
+/*  DMA Bus Mode register defines */
+#define DMA_BUS_MODE_DBO          0x00100000	/* Descriptor Byte Ordering */
+#define DMA_BUS_MODE_PBL_MASK     0x00003f00	/* Programmable Burst Length */
+#define DMA_BUS_MODE_PBL_SHIFT    8
+#define DMA_BUS_MODE_BLE          0x00000080	/* Big Endian/Little Endian */
+#define DMA_BUS_MODE_DSL_MASK     0x0000007c	/* Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT    2	/*       (in DWORDS)      */
+#define DMA_BUS_MODE_BAR_BUS      0x00000002	/* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET    0x00000001	/* Software Reset */
+#define DMA_BUS_MODE_DEFAULT      0x00000000
+
+/* DMA Status register defines */
+#define DMA_STATUS_EB_MASK        0x00380000	/* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT    0x00080000	/* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT    0x00100000	/* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK        0x00700000	/* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT       20
+#define DMA_STATUS_RS_MASK        0x000e0000	/* Receive Process State */
+#define DMA_STATUS_RS_SHIFT       17
+#define DMA_STATUS_NIS            0x00010000	/* Normal Interrupt Summary */
+#define DMA_STATUS_AIS            0x00008000	/* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI            0x00004000	/* Early Receive Interrupt */
+#define DMA_STATUS_FBI            0x00002000	/* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI            0x00000400	/* Early Transmit Interrupt */
+#define DMA_STATUS_RWT            0x00000200	/* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS            0x00000100	/* Receive Process Stopped */
+#define DMA_STATUS_RU             0x00000080	/* Receive Buffer Unavailable */
+#define DMA_STATUS_RI             0x00000040	/* Receive Interrupt */
+#define DMA_STATUS_UNF            0x00000020	/* Transmit Underflow */
+#define DMA_STATUS_OVF            0x00000010	/* Receive Overflow */
+#define DMA_STATUS_TJT            0x00000008	/* Transmit Jabber Timeout */
+#define DMA_STATUS_TU             0x00000004	/* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS            0x00000002	/* Transmit Process Stopped */
+#define DMA_STATUS_TI             0x00000001	/* Transmit Interrupt */
+
+/* DMA Control register defines */
+#define DMA_CONTROL_SF            0x00200000	/* Store And Forward */
+/* Transmit Threshold Control */
+#define DMA_CONTROL_TTC_DEFAULT   0x00000000	/* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_64        0x00004000	/* Threshold is 64 DWORDS */
+#define DMA_CONTROL_TTC_128       0x00008000	/* Threshold is 128 DWORDS */
+#define DMA_CONTROL_TTC_256       0x0000c000	/* Threshold is 256 DWORDS */
+#define DMA_CONTROL_TTC_18        0x00400000	/* Threshold is 18 DWORDS [22:1] */
+#define DMA_CONTROL_TTC_24        0x00404000	/* Threshold is 24 DWORDS [22:1] */
+#define DMA_CONTROL_TTC_32	  0x00408000	/* Threshold is 32 DWORDS [22:1] */
+#define DMA_CONTROL_TTC_40        0x0040c000	/* Threshold is 40 DWORDS [22:1] */
+#define DMA_CONTROL_ST            0x00002000	/* Start/Stop Transmission */
+#define DMA_CONTROL_SE            0x00000008	/* Stop On Empty */
+#define DMA_CONTROL_OSF           0x00000004	/* Operate On 2nd Frame */
+#define DMA_CONTROL_SR            0x00000002	/* Start/Stop Receive */
+
+/* DMA Interrupt Enable register defines */
+#define DMA_INTR_ENA_NIE          0x00010000	/* Normal Interrupt Summary */
+#define DMA_INTR_ENA_AIE          0x00008000	/* Abnormal Interrupt Summary */
+#define DMA_INTR_ENA_ERE          0x00004000	/* Early Receive */
+#define DMA_INTR_ENA_FBE          0x00002000	/* Fatal Bus Error */
+#define DMA_INTR_ENA_ETE          0x00000400	/* Early Transmit */
+#define DMA_INTR_ENA_RWE          0x00000200	/* Receive Watchdog */
+#define DMA_INTR_ENA_RSE          0x00000100	/* Receive Stopped */
+#define DMA_INTR_ENA_RUE          0x00000080	/* Receive Buffer Unavailable */
+#define DMA_INTR_ENA_RIE          0x00000040	/* Receive Interrupt */
+#define DMA_INTR_ENA_UNE          0x00000020	/* Underflow */
+#define DMA_INTR_ENA_OVE          0x00000010	/* Receive Overflow */
+#define DMA_INTR_ENA_TJE          0x00000008	/* Transmit Jabber */
+#define DMA_INTR_ENA_TUE          0x00000004	/* Transmit Buffer Unavailable */
+#define DMA_INTR_ENA_TSE          0x00000002	/* Transmit Stopped */
+#define DMA_INTR_ENA_TIE          0x00000001	/* Transmit Interrupt */
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_RIE | \
+				DMA_INTR_ENA_TIE)
+#define DMA_INTR_NO_RX		(DMA_INTR_ENA_NIE | DMA_INTR_ENA_TIE)
+/* STMAC110 DMA Missed Frame Counter register defines */
+#define DMA_MISSED_FRAME_OVE      0x10000000	/* FIFO Overflow Overflow */
+#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000	/* Overflow Frame Counter */
+#define DMA_MISSED_FRAME_OVE_M    0x00010000	/* Missed Frame Overflow */
+#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff	/* Missed Frame Couinter */
+
+/*----------------------------------------------------------------------------
+ * 		    	    Descriptor defines
+ *---------------------------------------------------------------------------*/
+/* Common fields */
+#define OWN_BIT			0x80000000	/* Own Bit (owned by hardware) */
+#define DES1_CONTROL_CH		0x01000000	/* Second Address Chained */
+#define DES1_CONTROL_TER	0x02000000	/* End of Ring */
+#define DES1_RBS2_SIZE_MASK	0x003ff800	/* Buffer 2 Size Mask */
+#define DES1_RBS2_SIZE_SHIFT	11	/* Buffer 2 Size Shift */
+#define DES1_RBS1_SIZE_MASK	0x000007ff	/* Buffer 1 Size Mask */
+#define DES1_RBS1_SIZE_SHIFT	0	/* Buffer 1 Size Shift */
+
+/* Receive Descriptor */
+#define RDES0_STATUS_FILTER_FAIL  0x40000000	/* Filtering Fail */
+#define RDES0_STATUS_FL_MASK      0x3fff0000	/* Frame Length Mask */
+#define RDES0_STATUS_FL_SHIFT     16	/* Frame Length Shift */
+#define RDES0_STATUS_ES           0x00008000	/* Error Summary */
+#define RDES0_STATUS_DE           0x00004000	/* Descriptor Error */
+#define RDES0_STATUS_PFE          0x00002000	/* Partial Frame Error */
+#define RDES0_STATUS_LENGTH_ERROR 0x00001000	/* Length Error */
+#define RDES0_STATUS_RUNT_FRM     0x00000800	/* Runt Frame */
+#define RDES0_STATUS_MULTICST_FRM 0x00000400	/* Multicast Frame */
+#define RDES0_STATUS_FS           0x00000200	/* First Descriptor */
+#define RDES0_STATUS_LS           0x00000100	/* Last Descriptor */
+#define RDES0_STATUS_TL           0x00000080	/* Frame Too Long */
+#define RDES0_STATUS_COL_SEEN     0x00000040	/* Collision Seen */
+#define RDES0_STATUS_FRM_TYPE     0x00000020	/* Frame Type */
+#define RDES0_STATUS_RX_WATCHDOG  0x00000010	/* Receive Watchdog */
+#define RDES0_STATUS_MII_ERR      0x00000008	/* Report on MII Error */
+#define RDES0_STATUS_DRIBBLE      0x00000004	/* Dribbling Bit */
+#define RDES0_STATUS_CE           0x00000002	/* CRC Error */
+#define RDES0_STATUS_0            0x00000000	/* Always tied to zero */
+
+#define RDES1_CONTROL_DIOC        0x80000000	/* Disable Intr On Completion */
+#define RDES0_STATUS_ERROR  (RDES0_STATUS_ES|RDES0_STATUS_LENGTH_ERROR|RDES0_STATUS_MII_ERR)
+
+/* Transmit Descriptor */
+#define TDES0_STATUS_ES		  0x00008000	/* Error Summary */
+#define TDES0_STATUS_LOSS_CARRIER 0x00000800	/* Loss of Carrier */
+#define TDES0_STATUS_NO_CARRIER   0x00000400	/* No Carrier */
+#define TDES0_STATUS_LATE_COL     0x00000200	/* Late Collision */
+#define TDES0_STATUS_EX_COL       0x00000100	/* Excessive Collisions */
+#define TDES0_STATUS_HRTBT_FAIL   0x00000080	/* Heartbeat Fail */
+#define TDES0_STATUS_COLCNT_MASK  0x00000078	/* Collision Count Mask */
+#define TDES0_STATUS_COLCNT_SHIFT 3	/* Collision Count Shift */
+#define TDES0_STATUS_EX_DEF       0x00000004	/* Excessive Deferrals */
+#define TDES0_STATUS_UF           0x00000002	/* Underflow Error */
+#define TDES0_STATUS_DF           0x00000001	/* Deferred */
+
+#define TDES1_CONTROL_IC          0x80000000	/* Interrupt on Completion */
+#define TDES1_CONTROL_LS          0x40000000	/* Last Segment */
+#define TDES1_CONTROL_FS          0x20000000	/* First Segment */
+#define TDES1_CONTROL_AC          0x04000000	/* Add CRC Disable */
+#define TDES1_CONTROL_DPD         0x00800000	/* Disable Padding */
+
+#define STMMAC_FULL_DUPLEX MAC_CONTROL_F
+#define STMMAC_PORT 	   MAC_CONTROL_PS
+#define STMMAC_SPEED_100   0xdeadbeef
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/mac_hw.h linux-2.6.23.1-stm/drivers/net/stmmac/mac_hw.h
--- linux-2.6.23.1/drivers/net/stmmac/mac_hw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/mac_hw.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,29 @@
+#ifdef CONFIG_STMMAC_ETH
+#include "mac100.h"
+#elif CONFIG_STMGMAC_ETH
+#include "gmac.h"
+#endif
+
+/* MAC HW structure */
+struct stmmmac_driver {
+	char *name;
+	/* It has been added to cover some issues about the HW setup
+	 * especially in the stb7109 Ethernet. */
+	int have_hw_fix;
+	/* Initial setup of the MAC controller */
+	void (*core_init) (struct net_device * dev);
+	/* Dump MAC CORE registers */
+	void (*mac_registers) (unsigned long ioaddr);
+	/* Dump DMA registers */
+	void (*dma_registers) (unsigned long ioaddr);
+	/* Return zero if no error is happened during the transmission */
+	int (*check_tx_summary) (void *p, unsigned int status);
+	/* Check if the frame was not successfully received */
+	int (*check_rx_summary) (void *p, unsigned int status);
+	/* Verify the TX checksum */
+	void (*tx_checksum) (struct sk_buff * skb);
+	/* Verifies the RX checksum */
+	void (*rx_checksum) (struct sk_buff * skb, int status);
+	/* Enable/Disable Multicast filtering */
+	void (*set_filter) (struct net_device * dev);
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/stmmac.h linux-2.6.23.1-stm/drivers/net/stmmac/stmmac.h
--- linux-2.6.23.1/drivers/net/stmmac/stmmac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/stmmac.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,65 @@
+/*
+ * stmmac main header file
+ */
+#define ETH_RESOURCE_NAME         "stmmaceth"
+#define PHY_RESOURCE_NAME	"stmmacphy"
+#define DRV_MODULE_VERSION     "1.0"
+#include "mac_hw.h"
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame. */
+struct dma_desc_t {
+	unsigned int des0;	/* Status */
+	unsigned int des1;	/* Ctrl bits, Buffer 2 length, Buffer 1 length */
+	unsigned int des2;	/* Buffer 1 */
+	unsigned int des3;	/* Buffer 2 */
+};
+typedef struct dma_desc_t dma_desc;
+
+/* Struct private for the STMMAC driver */
+struct eth_driver_local {
+	int bus_id;
+	int phy_addr;
+	int phy_irq;
+	int phy_mask;
+	phy_interface_t phy_interface;
+	int (*phy_reset) (void *priv);
+	void (*fix_mac_speed) (void *priv, unsigned int speed);
+	void *bsp_priv;
+	int oldlink;
+	int speed;
+	int oldduplex;
+	struct phy_device *phydev;
+	int pbl;
+	unsigned int ip_header_len;
+	struct mii_bus *mii;
+	struct net_device_stats stats;
+	u32 msg_enable;
+	spinlock_t lock;
+	spinlock_t tx_lock;
+
+	dma_desc *dma_tx;	/* virtual DMA TX addr */
+	dma_addr_t dma_tx_phy;	/* bus DMA TX addr */
+	unsigned int cur_tx, dirty_tx;	/* Producer/consumer ring indices */
+	struct sk_buff **tx_skbuff;
+
+	dma_desc *dma_rx;	/* virtual DMA RX addr */
+	dma_addr_t dma_rx_phy;	/* bus DMA RX addr */
+	int dma_buf_sz;
+	unsigned int rx_buff;	/* it contains the last rx buf owned by
+				   the DMA */
+	int rx_csum;
+	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indices */
+	/* The addresses of receive-in-place skbuffs. */
+	struct sk_buff **rx_skbuff;
+	dma_addr_t *rx_skbuff_dma;
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	struct vlan_group *vlgrp;
+#endif
+	struct device *device;
+	struct stmmmac_driver *mac;
+	int pause_time;
+	unsigned int dma_tx_size;
+	unsigned int dma_rx_size;
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/stmmac_ethtool.c linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_ethtool.c
--- linux-2.6.23.1/drivers/net/stmmac/stmmac_ethtool.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_ethtool.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,174 @@
+/*
+ * drivers/net/stmmac/stmmac_ethtool.c
+ *
+ * STMMAC Ethernet Driver
+ * Ethtool support for STMMAC Ethernet Driver
+ *
+ * Author: Giuseppe Cavallaro
+ *
+ * Copyright (c) 2006-2007 STMicroelectronics
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/etherdevice.h>
+#include <linux/mm.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <asm/io.h>
+
+#include "stmmac.h"
+
+#define REGDUMP_LEN         (32 * 1024)
+
+void stmmac_ethtool_getdrvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, ETH_RESOURCE_NAME);
+	strcpy(info->version, DRV_MODULE_VERSION);
+	info->fw_version[0] = '\0';
+	return;
+}
+
+int stmmac_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phy = lp->phydev;
+	int rc;
+	if (phy == NULL) {
+		printk(KERN_ERR "%s: %s: PHY is not registered\n",
+		       __FUNCTION__, dev->name);
+		return -ENODEV;
+	}
+
+	if (!netif_running(dev)) {
+		printk(KERN_ERR "%s: interface is disabled: we cannot track "
+		       "link speed / duplex setting\n", dev->name);
+		return -EBUSY;
+	}
+
+	cmd->transceiver = XCVR_INTERNAL;
+	spin_lock_irq(&lp->lock);
+	rc = phy_ethtool_gset(phy, cmd);
+	spin_unlock_irq(&lp->lock);
+	return rc;
+}
+
+int stmmac_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct eth_driver_local *lp = dev->priv;
+	struct phy_device *phy = lp->phydev;
+	int rc;
+
+	spin_lock_irq(&lp->lock);
+	rc = phy_ethtool_sset(phy, cmd);
+	spin_unlock_irq(&lp->lock);
+
+	return rc;
+}
+
+u32 stmmac_ethtool_getmsglevel(struct net_device * dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	return lp->msg_enable;
+}
+
+void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	lp->msg_enable = level;
+
+}
+
+int stmmac_check_if_running(struct net_device *dev)
+{
+	if (!netif_running(dev))
+		return -EBUSY;
+	return (0);
+}
+
+int stmmac_ethtool_get_regs_len(struct net_device *dev)
+{
+	return (REGDUMP_LEN);
+}
+
+void stmmac_ethtool_gregs(struct net_device *dev,
+			  struct ethtool_regs *regs, void *space)
+{
+	int i;
+	u32 reg;
+	u32 *reg_space = (u32 *) space;
+
+	memset(reg_space, 0x0, REGDUMP_LEN);
+
+	/* MAC registers */
+	for (i = 0; i < 11; i++) {
+		reg = readl(dev->base_addr + i * 4);
+		memcpy((reg_space + i * 4), &reg, sizeof(u32));
+	}
+
+	/* DMA registers */
+	for (i = 0; i < 9; i++) {
+		reg = readl(dev->base_addr + (DMA_BUS_MODE + i * 4));
+		memcpy((reg_space + (DMA_BUS_MODE + i * 4)), &reg, sizeof(u32));
+	}
+	reg = readl(dev->base_addr + DMA_CUR_TX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_TX_BUF_ADDR), &reg, sizeof(u32));
+	reg = readl(dev->base_addr + DMA_CUR_RX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_RX_BUF_ADDR), &reg, sizeof(u32));
+
+	return;
+}
+
+int stmmac_ethtool_set_tx_csum(struct net_device *dev, u32 data)
+{
+	if (data)
+		dev->features |= NETIF_F_HW_CSUM;
+	else
+		dev->features &= ~NETIF_F_HW_CSUM;
+
+	return 0;
+}
+
+u32 stmmac_ethtool_get_rx_csum(struct net_device * dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	return (lp->rx_csum);
+}
+
+int stmmac_ethtool_set_rx_csum(struct net_device *dev, u32 data)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	if (data)
+		lp->rx_csum = 1;
+	else
+		lp->rx_csum = 0;
+
+	return 0;
+}
+
+struct ethtool_ops stmmac_ethtool_ops = {
+	.begin = stmmac_check_if_running,
+	.get_drvinfo = stmmac_ethtool_getdrvinfo,
+	.get_settings = stmmac_ethtool_getsettings,
+	.set_settings = stmmac_ethtool_setsettings,
+	.get_msglevel = stmmac_ethtool_getmsglevel,
+	.set_msglevel = stmmac_ethtool_setmsglevel,
+	.get_regs = stmmac_ethtool_gregs,
+	.get_regs_len = stmmac_ethtool_get_regs_len,
+	.get_link = ethtool_op_get_link,
+	.get_rx_csum = stmmac_ethtool_get_rx_csum,
+	.set_rx_csum = stmmac_ethtool_set_rx_csum,
+	.get_tx_csum = ethtool_op_get_tx_csum,
+	.set_tx_csum = stmmac_ethtool_set_tx_csum,
+	.get_sg = ethtool_op_get_sg,
+	.set_sg = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+	.get_tso = ethtool_op_get_tso,
+	.set_tso = ethtool_op_set_tso,
+#endif
+	.get_ufo = ethtool_op_get_ufo,
+	.set_ufo = ethtool_op_set_ufo,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/stmmac_main.c linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_main.c
--- linux-2.6.23.1/drivers/net/stmmac/stmmac_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_main.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,2042 @@
+/* ============================================================================
+ *
+ * drivers/net/stmmac/stmmac_main.c
+ *
+ * This is the driver for the MAC 10/100/1000 on-chip Ethernet controllers.
+ *
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * Copyright (C) 2007 by STMicroelectronics
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * Changelog:
+ *
+ *  Sep 2007:
+ *	- first version of this driver
+ * ===========================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/stm/soc.h>
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+#include <linux/dma-mapping.h>
+#include "stmmac.h"
+
+#define DMA_MAX_BUFFER_SIZE 0x7ff	/* maximum value in according to the TBS1/2 RBS1/2 bits */
+#define DMA_BUFFER_SIZE DMA_MAX_BUFFER_SIZE	//0x600
+#define TDES1_MAX_BUF1_SIZE ((DMA_BUFFER_SIZE << DES1_RBS1_SIZE_SHIFT) & \
+			DES1_RBS1_SIZE_MASK);
+#define TDES1_MAX_BUF2_SIZE ((DMA_BUFFER_SIZE << DES1_RBS2_SIZE_SHIFT) & \
+			DES1_RBS2_SIZE_MASK);
+#define MIN_MTU 46
+#define MAX_MTU ETH_DATA_LEN
+
+#undef STMMAC_DEBUG
+/*#define STMMAC_DEBUG*/
+#ifdef STMMAC_DEBUG
+#define DBG(nlevel, klevel, fmt, args...) \
+                (void)(netif_msg_##nlevel(lp) && \
+                printk(KERN_##klevel fmt, ## args))
+#else
+#define DBG(nlevel, klevel, fmt, args...)  do { } while(0)
+#endif
+
+#undef STMMAC_TX_DEBUG
+/*#define STMMAC_TX_DEBUG*/
+#ifdef STMMAC_TX_DEBUG
+#define TX_DBG(mss, klevel, fmt, args...) \
+                if (mss!=0)     \
+                printk(KERN_##klevel fmt, ## args)
+#else
+#define TX_DBG(mss, klevel, fmt, args...)  do { } while(0)
+#endif
+
+#undef STMMAC_RX_DEBUG
+/*#define STMMAC_RX_DEBUG*/
+#ifdef STMMAC_RX_DEBUG
+#define RX_DBG(fmt,args...)  printk(fmt, ## args)
+#else
+#define RX_DBG(fmt, args...)  do { } while(0)
+#endif
+
+/* Module Arguments */
+#define TX_TIMEO (5*HZ)
+static int watchdog = TX_TIMEO;
+module_param(watchdog, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(watchdog, "Transmit Timeout (in milliseconds)");
+
+static int debug = -1;		/* -1: default, 0: no output, 16:  all */
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
+
+static int rx_copybreak = ETH_FRAME_LEN + 22;
+module_param(rx_copybreak, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(rx_copybreak, "Copy only tiny-frames");
+
+static int phy_n = -1;
+module_param(phy_n, int, S_IRUGO);
+MODULE_PARM_DESC(phy_n, "Physical device address");
+
+static int dma_buffer_size = DMA_BUFFER_SIZE;
+module_param(dma_buffer_size, int, S_IRUGO);
+MODULE_PARM_DESC(dma_buffer_size, "DMA buffer size");
+
+#define DMA_TX_SIZE 16
+static int dma_tx_size_param = DMA_TX_SIZE;
+module_param(dma_tx_size_param, int, S_IRUGO);
+MODULE_PARM_DESC(dma_buffer_size, "Number of descriptors in the TX list");
+
+#define DMA_RX_SIZE 32
+static int dma_rx_size_param = DMA_RX_SIZE;
+module_param(dma_rx_size_param, int, S_IRUGO);
+MODULE_PARM_DESC(dma_buffer_size, "Number of descriptors in the RX list");
+
+#define TX_BUFFS_AVAIL(lp) \
+        (lp->dirty_tx + lp->dma_tx_size - lp->cur_tx - 1)
+
+static const char version[] = "stmmac - (C) 2006-2007 STMicroelectronics\n";
+
+static const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
+				      NETIF_MSG_LINK | NETIF_MSG_IFUP |
+				      NETIF_MSG_IFDOWN | NETIF_MSG_TIMER);
+
+extern int stmmac_mdio_unregister(struct net_device *ndev);
+extern int stmmac_mdio_register(struct net_device *ndev);
+extern struct ethtool_ops stmmac_ethtool_ops;
+extern struct stmmmac_driver mac_driver;
+static irqreturn_t stmmac_interrupt(int irq, void *dev_id);
+static int stmmac_poll(struct net_device *dev, int *budget);
+static void stmmac_check_mod_params(struct net_device *dev);
+
+static inline void print_mac_addr(u8 addr[6])
+{
+	int i;
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", addr[i]);
+	printk("%2.2x\n", addr[5]);
+	return;
+}
+
+#ifdef STMMAC_DEBUG
+static void print_pkt(unsigned char *buf, int len)
+{
+	int j;
+	printk("len = %d byte, buf addr: 0x%p", len, buf);
+	for (j = 0; j < len; j++) {
+		if ((j % 16) == 0)
+			printk("\n %03x:", j);
+		printk(" %02x", buf[j]);
+	}
+	printk("\n");
+	return;
+}
+#endif
+
+/**
+ * stmmac_adjust_link
+ * @dev: net device structure
+ * Description: it adjusts the link parameters.
+ */
+static void stmmac_adjust_link(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phydev = lp->phydev;
+	unsigned long ioaddr = dev->base_addr;
+	unsigned long flags;
+	int new_state = 0;
+
+	DBG(probe, DEBUG, "stmmac_adjust_link: called.  address %d link %d\n",
+	    phydev->addr, phydev->link);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	if (phydev->link) {
+		unsigned int ctrl = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+		/* Now we make sure that we can be in full duplex mode.
+		 * If not, we operate in half-duplex mode. */
+		if (phydev->duplex != lp->oldduplex) {
+			new_state = 1;
+			if (!(phydev->duplex))
+				ctrl &= ~STMMAC_FULL_DUPLEX;
+			else
+				ctrl |= STMMAC_FULL_DUPLEX;
+			lp->oldduplex = phydev->duplex;
+		}
+
+		if (phydev->speed != lp->speed) {
+			new_state = 1;
+			switch (phydev->speed) {
+			case 1000:
+				ctrl |= STMMAC_PORT;	/* GMII...if supported */
+			case 100:
+			case 10:
+				ctrl &= ~STMMAC_PORT;	/* MII */
+				/* In RMII mode, the 7109 MAC 10/100 needs 
+				 * to change the MAC speed field in
+				 * system configuration register. */
+				if (lp->mac->have_hw_fix) {
+					lp->fix_mac_speed(lp->bsp_priv,
+							  phydev->speed);
+				} else {
+					/* GMAC needs no special hack...
+					 * just reduces mode distinguishes
+					 * between 10 and 100 */
+					if (phydev->speed == SPEED_100) {
+						ctrl |= STMMAC_SPEED_100;
+					} else {
+						ctrl &= ~(STMMAC_SPEED_100);
+					}
+				}
+				break;
+			default:
+				if (netif_msg_link(lp))
+					printk(KERN_WARNING
+					       "%s: Ack!  Speed (%d) is not 10 or 100!\n",
+					       dev->name, phydev->speed);
+				break;
+			}
+
+			lp->speed = phydev->speed;
+		}
+
+		writel(ctrl, ioaddr + MAC_CONTROL);
+
+		if (!lp->oldlink) {
+			new_state = 1;
+			lp->oldlink = 1;
+			netif_schedule(dev);
+		}
+	} else if (lp->oldlink) {
+		new_state = 1;
+		lp->oldlink = 0;
+		lp->speed = 0;
+		lp->oldduplex = -1;
+	}
+
+	if (new_state && netif_msg_link(lp))
+		phy_print_status(phydev);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	DBG(probe, DEBUG, "stmmac_adjust_link: exiting\n");
+}
+
+/**
+ * stmmac_init_phy - PHY initialization
+ * @dev: net device structure
+ * Description: it initializes driver's PHY state, and attaches to the PHY.
+ *  Return value:
+ *  0 on success
+ */
+static int stmmac_init_phy(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phydev;
+	char phy_id[BUS_ID_SIZE];
+
+	lp->oldlink = 0;
+	lp->speed = 0;
+	lp->oldduplex = -1;
+
+	snprintf(phy_id, BUS_ID_SIZE, PHY_ID_FMT, lp->bus_id, lp->phy_addr);
+	DBG(probe, DEBUG, "stmmac_init_phy:  trying to attach to %s\n", phy_id);
+
+	phydev =
+	    phy_connect(dev, phy_id, &stmmac_adjust_link, 0, lp->phy_interface);
+
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);
+		return PTR_ERR(phydev);
+	}
+
+	DBG(probe, DEBUG,
+	    "stmmac_init_phy:  %s: attached to PHY. Link = %d\n",
+	    dev->name, phydev->link);
+
+	lp->phydev = phydev;
+
+	return 0;
+}
+
+/**
+ * set_mac_addr
+ * @ioaddr: device I/O address
+ * @Addr: new MAC address
+ * Description: the function sets the hardware MAC address
+ */
+static void set_mac_addr(unsigned long ioaddr, u8 Addr[6])
+{
+	unsigned long data;
+
+	data = (Addr[5] << 8) | Addr[4];
+	writel(data, ioaddr + MAC_ADDR_HIGH);
+	data = (Addr[3] << 24) | (Addr[2] << 16) | (Addr[1] << 8) | Addr[0];
+	writel(data, ioaddr + MAC_ADDR_LOW);
+
+	return;
+}
+
+/**
+ * get_mac_addr
+ * @ioaddr: device I/O address
+ * @addr: mac address
+ * Description: the function gets the hardware MAC address
+ */
+static void get_mac_address(unsigned long ioaddr, unsigned char *addr)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = (unsigned int)readl(ioaddr + MAC_ADDR_HIGH);
+	lo_addr = (unsigned int)readl(ioaddr + MAC_ADDR_LOW);
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xff;
+	addr[1] = (lo_addr >> 8) & 0xff;
+	addr[2] = (lo_addr >> 16) & 0xff;
+	addr[3] = (lo_addr >> 24) & 0xff;
+	addr[4] = hi_addr & 0xff;
+	addr[5] = (hi_addr >> 8) & 0xff;
+
+	return;
+}
+
+/**
+ * stmmac_mac_enable_rx
+ * @dev: net device structure
+ * Description: the function enables the RX MAC process
+ */
+static void stmmac_mac_enable_rx(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+	/* set the RE (receive enable, bit 2) */
+	value |= (MAC_CONTROL_RE);
+	writel(value, ioaddr + MAC_CONTROL);
+	return;
+}
+
+/**
+ * stmmac_mac_enable_rx
+ * @dev: net device structure
+ * Description: the function enables the TX MAC process
+ */
+static void stmmac_mac_enable_tx(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+	/* set: TE (transmitter enable, bit 3) */
+	value |= (MAC_CONTROL_TE);
+	writel(value, ioaddr + MAC_CONTROL);
+	return;
+}
+
+/**
+ * stmmac_mac_disable_rx
+ * @dev: net device structure
+ * Description: the function disables the RX MAC process
+ */
+static void stmmac_mac_disable_rx(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+	value &= ~MAC_CONTROL_RE;
+	writel(value, ioaddr + MAC_CONTROL);
+	return;
+}
+
+/**
+ * stmmac_mac_disable_tx
+ * @dev: net device structure
+ * Description: the function disables the TX MAC process
+ */
+static void stmmac_mac_disable_tx(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+
+	value &= ~(MAC_CONTROL_TE);
+	writel(value, ioaddr + MAC_CONTROL);
+	return;
+}
+
+static void display_dma_desc_ring(dma_desc * p, int size)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		printk("\t%d [0x%x]: "
+		       "desc0=0x%x desc1=0x%x buffer1=0x%x", i,
+		       (unsigned int)virt_to_phys(&p[i].des0), p[i].des0,
+		       p[i].des1, (unsigned int)p[i].des2);
+		if (p[i].des3 != 0)
+			printk(" buffer2=0x%x", (unsigned int)p[i].des3);
+		printk("\n");
+	}
+}
+
+/**
+ * clear_dma_descs - reset the DMA descriptors
+ * @p: it starts pointing to the first element in the ring.
+ * @ring_size: it is the size of the ring.
+ * @own_bit: it is the owner bit (RX: OWN_BIT - TX: 0).
+ * Description: this function clears both RX and TX descriptors.
+ * Note that the driver uses the 'implicit' scheme for implementing
+ * the TX/RX DMA linked lists. So the second buffer doesn't point
+ * to the next descriptor.
+ */
+static void clear_dma_descs(dma_desc * p, unsigned int ring_size,
+			    unsigned int own_bit)
+{
+	int i;
+	for (i = 0; i < ring_size; i++) {
+		p->des0 = own_bit;
+		if (!(own_bit))
+			p->des1 = 0;
+		else
+			p->des1 = (dma_buffer_size << DES1_RBS1_SIZE_SHIFT);
+		if (i == ring_size - 1) {
+			p->des1 |= DES1_CONTROL_TER;
+		}
+		p->des3 = 0;
+		p++;
+	}
+	return;
+}
+
+/**
+ * init_dma_desc_rings - init the RX/TX descriptor rings
+ * @dev: net device structure
+ * Description:  this function initializes the DMA RX/TX descriptors
+ */
+static void init_dma_desc_rings(struct net_device *dev)
+{
+	int i;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int txsize = lp->dma_tx_size;
+	unsigned int rxsize = lp->dma_rx_size;
+	lp->dma_buf_sz = dma_buffer_size;
+
+	DBG(probe, DEBUG, "%s: allocate and init the DMA RX/TX\n",
+	    ETH_RESOURCE_NAME);
+
+	lp->rx_skbuff_dma =
+	    (dma_addr_t *) kmalloc(lp->dma_rx_size * sizeof(dma_addr_t),
+				   GFP_KERNEL);
+	lp->rx_skbuff =
+	    (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) * rxsize,
+				       GFP_KERNEL);
+	lp->dma_rx = (dma_desc *) dma_alloc_coherent(lp->device,
+						     rxsize *
+						     sizeof(struct dma_desc_t),
+						     &lp->dma_rx_phy,
+						     GFP_KERNEL);
+	lp->tx_skbuff =
+	    (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) * txsize,
+				       GFP_KERNEL);
+	lp->dma_tx = (dma_desc *) dma_alloc_coherent(lp->device,
+						     txsize *
+						     sizeof(struct dma_desc_t),
+						     &lp->dma_tx_phy,
+						     GFP_KERNEL);
+
+	if ((lp->dma_rx == NULL) || (lp->dma_tx == NULL)) {
+		printk(KERN_ERR "%s:ERROR allocating the DMA Tx/Rx desc\n",
+		       __FUNCTION__);
+		return;
+	}
+	DBG(probe, DEBUG, "%s: DMA desc rings: virt addr (Rx 0x%08x, "
+	    "Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
+	    dev->name, (unsigned int)lp->dma_rx, (unsigned int)lp->dma_tx,
+	    (unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
+
+	/* ---- RX INITIALIZATION */
+	DBG(probe, DEBUG, "[RX skb data]   [DMA RX skb data] "
+	    "(buff size: %d)\n", lp->dma_buf_sz);
+	for (i = 0; i < rxsize; i++) {
+		dma_desc *p = lp->dma_rx + i;
+		struct sk_buff *skb = dev_alloc_skb(lp->dma_buf_sz);
+		skb->dev = dev;
+		skb_reserve(skb, NET_IP_ALIGN);
+		lp->rx_skbuff[i] = skb;
+		if (unlikely(skb == NULL)) {
+			printk(KERN_ERR "%s: Rx init fails; skb is NULL\n",
+			       __FUNCTION__);
+			break;
+		}
+		lp->rx_skbuff_dma[i] = dma_map_single(lp->device, skb->data,
+						      lp->dma_buf_sz,
+						      DMA_FROM_DEVICE);
+		p->des2 = lp->rx_skbuff_dma[i];
+		DBG(probe, DEBUG, "[0x%08x]\t[0x%08x]\n",
+		    (unsigned int)lp->rx_skbuff[i]->data,
+		    (unsigned int)lp->rx_skbuff_dma[i]);
+	}
+	lp->cur_rx = 0;
+	lp->dirty_rx = (unsigned int)(i - rxsize);
+
+	/* ---- TX INITIALIZATION */
+	for (i = 0; i < txsize; i++) {
+		lp->tx_skbuff[i] = NULL;
+		lp->dma_tx[i].des2 = 0;
+		lp->dma_tx[i].des3 = 0;
+	}
+	lp->dirty_tx = lp->cur_tx = 0;
+
+	/* Clear the Rx/Tx descriptors */
+	clear_dma_descs(lp->dma_rx, rxsize, OWN_BIT);
+	clear_dma_descs(lp->dma_tx, txsize, 0);
+
+	if (netif_msg_hw(lp)) {
+		printk("RX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_rx, rxsize);
+		printk("TX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_tx, txsize);
+	}
+	return;
+}
+
+/**
+ * dma_free_rx_skbufs
+ * @dev: net device structure
+ * Description:  this function frees all the skbuffs in the Rx queue
+ */
+static void dma_free_rx_skbufs(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < lp->dma_rx_size; i++) {
+		if (lp->rx_skbuff[i]) {
+			dma_unmap_single(lp->device, lp->rx_skbuff_dma[i],
+					 lp->dma_buf_sz, DMA_FROM_DEVICE);
+			dev_kfree_skb(lp->rx_skbuff[i]);
+		}
+		lp->rx_skbuff[i] = NULL;
+	}
+	return;
+}
+
+/**
+ * dma_free_tx_skbufs
+ * @dev: net device structure
+ * Description:  this function frees all the skbuffs in the Tx queue
+ */
+static void dma_free_tx_skbufs(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < lp->dma_tx_size; i++) {
+		if (lp->tx_skbuff[i] != NULL) {
+			if ((lp->dma_tx + i)->des2) {
+				dma_unmap_single(lp->device, p->des2,
+						 (p->
+						  des1 & DES1_RBS1_SIZE_MASK) >>
+						 DES1_RBS1_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
+			}
+			if ((lp->dma_tx + i)->des3) {
+				dma_unmap_single(lp->device, p->des3,
+						 (p->
+						  des1 & DES1_RBS2_SIZE_MASK) >>
+						 DES1_RBS2_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
+			}
+			dev_kfree_skb_any(lp->tx_skbuff[i]);
+			lp->tx_skbuff[i] = NULL;
+		}
+	}
+	return;
+}
+
+/**
+ * free_dma_desc_resources
+ * @dev: net device structure
+ * Description:  this function releases and free ALL the DMA resources
+ */
+static void free_dma_desc_resources(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Release the DMA TX/RX socket buffers */
+	dma_free_rx_skbufs(dev);
+	dma_free_tx_skbufs(dev);
+
+	/* Free the region of consistent memory previously allocated for 
+	 * the DMA */
+	dma_free_coherent(lp->device,
+			  lp->dma_tx_size * sizeof(struct dma_desc_t),
+			  lp->dma_tx, lp->dma_tx_phy);
+	dma_free_coherent(lp->device,
+			  lp->dma_rx_size * sizeof(struct dma_desc_t),
+			  lp->dma_rx, lp->dma_rx_phy);
+	kfree(lp->rx_skbuff_dma);
+	kfree(lp->rx_skbuff);
+	kfree(lp->tx_skbuff);
+
+	return;
+}
+
+/**
+ * stmmac_dma_reset - STMAC DMA SW reset
+ * @ioaddr: device I/O address
+ * Description:  this function performs the DMA SW reset.
+ *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
+ *	   SW reset otherwise the MAC core won't exit the reset state.
+ *  NOTE2: after a SW reset all interrupts are disabled
+ */
+static void stmmac_dma_reset(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr + DMA_BUS_MODE);
+	value |= DMA_BUS_MODE_SFT_RESET;
+	writel(value, ioaddr + DMA_BUS_MODE);
+	while ((readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {
+	}
+	return;
+}
+
+/**
+ * stmmac_dma_start_tx
+ * @ioaddr: device I/O address
+ * Description:  this function starts the DMA tx process
+ */
+static void stmmac_dma_start_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value |= DMA_CONTROL_ST;
+	writel(value, ioaddr + DMA_CONTROL);
+	return;
+}
+
+static void stmmac_dma_stop_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value &= ~DMA_CONTROL_ST;
+	writel(value, ioaddr + DMA_CONTROL);
+	return;
+}
+
+/**
+ * stmmac_dma_start_rx
+ * @ioaddr: device I/O address
+ * Description:  this function starts the DMA rx process
+ */
+static void stmmac_dma_start_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value |= DMA_CONTROL_SR;
+	writel(value, ioaddr + DMA_CONTROL);
+
+	return;
+}
+
+static void stmmac_dma_stop_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value &= ~DMA_CONTROL_SR;
+	writel(value, ioaddr + DMA_CONTROL);
+
+	return;
+}
+
+static __inline__ void stmmac_dma_enable_irq_rx(unsigned long ioaddr)
+{
+	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
+	return;
+}
+
+static __inline__ void stmmac_dma_disable_irq_rx(unsigned long ioaddr)
+{
+	writel(DMA_INTR_NO_RX, ioaddr + DMA_INTR_ENA);
+	return;
+}
+
+/**
+ * stmmac_dma_init - DMA init function
+ * @dev: net device structure
+ * Description: the DMA init function performs:
+ * - the DMA RX/TX SW descriptors initialization
+ * - the DMA HW controller initialization
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method.
+ */
+static int stmmac_dma_init(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	DBG(probe, DEBUG, "STMMAC: DMA Core setup\n");
+
+	/* DMA SW reset */
+	stmmac_dma_reset(ioaddr);
+
+	/* Enable Application Access by writing to DMA CSR0 */
+	DBG(probe, DEBUG, "\t(PBL: %d)\n", lp->pbl);
+	writel(DMA_BUS_MODE_DEFAULT | ((lp->pbl) << DMA_BUS_MODE_PBL_SHIFT),
+	       ioaddr + DMA_BUS_MODE);
+
+	/* Mask interrupts by writing to CSR7 */
+	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
+
+	/* The base address of the RX/TX descriptor lists must be written into
+	 * DMA CSR3 and CSR4, respectively. */
+	writel((unsigned long)lp->dma_tx_phy, ioaddr + DMA_TX_BASE_ADDR);
+	writel((unsigned long)lp->dma_rx_phy, ioaddr + DMA_RCV_BASE_ADDR);
+
+	if (netif_msg_hw(lp))
+		lp->mac->dma_registers(ioaddr);
+
+	return 0;
+}
+
+#ifdef STMMAC_DEBUG
+/**
+ * show_tx_process_state
+ * @status: tx descriptor status field
+ * Description: it shows the Transmit Process State for CSR5[22:20]
+ */
+static void show_tx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
+
+	switch (state) {
+	case 0:
+		printk("- TX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		printk("- TX (Running):Fetching the Tx desc\n");
+		break;
+	case 2:
+		printk("- TX (Running): Waiting for end of tx\n");
+		break;
+	case 3:
+		printk("- TX (Running): Reading the data "
+		       "and queuing the data into the Tx buf\n");
+		break;
+	case 6:
+		printk("- TX (Suspended): Tx Buff Underflow "
+		       "or an unavailable Transmit descriptor\n");
+		break;
+	case 7:
+		printk("- TX (Running): Closing Tx descriptor\n");
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+/**
+ * show_rx_process_state
+ * @status: rx descriptor status field
+ * Description: it shows the  Receive Process State for CSR5[19:17]
+ */
+static void show_rx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
+
+	switch (state) {
+	case 0:
+		printk("- RX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		printk("- RX (Running): Fetching the Rx desc\n");
+		break;
+	case 2:
+		printk("- RX (Running):Checking for end of pkt\n");
+		break;
+	case 3:
+		printk("- RX (Running): Waiting for Rx pkt\n");
+		break;
+	case 4:
+		printk("- RX (Suspended): Unavailable Rx buf\n");
+		break;
+	case 5:
+		printk("- RX (Running): Closing Rx descriptor\n");
+		break;
+	case 6:
+		printk("- RX(Running): Flushing the current frame"
+		       " from the Rx buf\n");
+		break;
+	case 7:
+		printk("- RX (Running): Queuing the Rx frame"
+		       " from the Rx buf into memory\n");
+		break;
+	default:
+		break;
+	}
+	return;
+}
+#endif
+
+/**
+ * stmmac_clean_tx_irq1
+ * @data:  address of the private member of the device structure
+ * Description: it is used for freeing the TX resources.  
+ */
+static void stmmac_clean_tx_irq1(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int txsize = lp->dma_tx_size;
+	int entry = lp->dirty_tx % txsize;
+
+	spin_lock(&lp->tx_lock);
+
+	while (lp->dirty_tx != lp->cur_tx) {
+		dma_desc *p = lp->dma_tx + entry;
+		int status = p->des0;
+		if (!(status & OWN_BIT)) {
+			/* When the transmission is completed the frame status
+			 * is written into TDESC0 of the descriptor having the 
+			 * LS bit set. */
+			if (likely(p->des1 & TDES1_CONTROL_LS)) {
+				if (unlikely(lp->mac->check_tx_summary(&lp->stats, status)<0)) {
+					lp->stats.tx_errors++;
+				} else {
+					lp->stats.tx_packets++;
+				}
+			}
+#ifdef STMMAC_TX_DEBUG
+			if (netif_queue_stopped(dev))
+				if (netif_msg_tx_done(lp))
+					printk("tx done free entry %d\n",
+					       entry);
+#endif
+			if (p->des2) {
+				dma_unmap_single(lp->device, p->des2,
+					 (p->des1 & DES1_RBS1_SIZE_MASK)>>DES1_RBS1_SIZE_SHIFT,
+					 DMA_TO_DEVICE);
+				p->des2 = 0;
+			}
+			if (unlikely(p->des3)) {
+				dma_unmap_single(lp->device, p->des3,
+					 (p->des1 & DES1_RBS2_SIZE_MASK)>>DES1_RBS2_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
+				p->des3 = 0;
+			}
+			if (lp->tx_skbuff[entry] != NULL) {
+				dev_kfree_skb_irq(lp->tx_skbuff[entry]);
+				lp->tx_skbuff[entry] = NULL;
+			}
+		}
+		entry = (++lp->dirty_tx) % txsize;
+	}
+	if (netif_queue_stopped(dev)) {
+		/*printk ("TX queue started.\n"); */
+		netif_wake_queue(dev);
+	}
+
+	spin_unlock(&lp->tx_lock);
+	return;
+}
+
+/**
+ * stmmac_dma_interrupt - Interrupt handler for the STMMAC DMA
+ * @dev: net device structure
+ * Description: It determines if we have to call either the Rx or the Tx
+ * interrupt handler.
+ */
+static void stmmac_dma_interrupt(struct net_device *dev)
+{
+	unsigned int status;
+	unsigned int ioaddr = dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	lp->rx_buff = readl(ioaddr + DMA_CUR_RX_BUF_ADDR);
+	/* read the status register (CSR5) */
+	status = (unsigned int)readl(ioaddr + DMA_STATUS);
+
+	DBG(intr, INFO, "%s: [CSR5: 0x%08x]\n", __FUNCTION__, status);
+
+#ifdef STMMAC_DEBUG
+	/* It displays the DMA transmit process state (CSR5 register) */
+	if (netif_msg_tx_done(lp))
+		show_tx_process_state(status);
+	if (netif_msg_rx_status(lp))
+		show_rx_process_state(status);
+#endif
+	/* Process the NORMAL interrupts */
+	if (status & DMA_STATUS_NIS) {
+		DBG(intr, INFO, " CSR5[16]: DMA NORMAL IRQ: ");
+		if (status & DMA_STATUS_RI) {
+
+			RX_DBG("Receive irq [buf: 0x%08x]\n", lp->rx_buff);
+			/*display_dma_desc_ring(lp->dma_rx, lp->dma_rx_size); */
+			stmmac_dma_disable_irq_rx(ioaddr);
+			if (likely(netif_rx_schedule_prep(dev))) {
+				__netif_rx_schedule(dev);
+			} else {
+				RX_DBG("IRQ: bug!interrupt while in poll\n");
+			}
+
+		}
+		if (status & DMA_STATUS_TI) {
+			DBG(intr, INFO, " Transmit irq [buf: 0x%lx]\n",
+			    readl(ioaddr + DMA_CUR_TX_BUF_ADDR));
+			stmmac_clean_tx_irq1(dev);
+		}
+	}
+	DBG(intr, INFO, "\n\n");
+
+	/* Clear the interrupt by writing a logic 1 to the CSR5[15-0] */
+	writel(status, ioaddr + DMA_STATUS);
+	return;
+}
+
+/**
+ *  stmmac_open - open entry point of the driver
+ *  @dev : pointer to the device structure.
+ *  Description:
+ *  This function is the open entry point of the driver.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
+int stmmac_open(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int ret;
+
+	/* Check that the MAC address is valid.  If its not, refuse
+	 * to bring the device up. The user must specify an
+	 * address using the following linux command:
+	 *      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		DBG(probe, ERR, "%s: no valid eth hw addr\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Request the IRQ lines */
+	ret = request_irq(dev->irq, &stmmac_interrupt,
+			  IRQF_SHARED, dev->name, dev);
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "%s: ERROR: allocating the IRQ %d (error: %d)\n",
+		       __FUNCTION__, dev->irq, ret);
+		return ret;
+	}
+
+	/* Attach the PHY */
+	ret = stmmac_init_phy(dev);
+	if (ret) {
+		printk(KERN_ERR "%s: Cannot attach to PHY (error: %d)\n",
+		       __FUNCTION__, ret);
+		return -ENODEV;
+	}
+
+	/* Create and initialize the TX/RX descriptors rings */
+	init_dma_desc_rings(dev);
+
+	/* Intialize the DMA controller and send the SW reset
+	 * This must be after we have successfully initialised the PHY
+	 * (see comment in stmmac_dma_reset). */
+	if (stmmac_dma_init(dev) < 0) {
+		DBG(probe, ERR, "%s: DMA initialization failed\n",
+		    __FUNCTION__);
+		return -1;
+	}
+
+	/* Copy the MAC addr into the HW in case we have set it with nwhw */
+	printk(KERN_DEBUG "stmmac_open (%s) ", lp->mac->name);
+	print_mac_addr(dev->dev_addr);
+	set_mac_addr(dev->base_addr, dev->dev_addr);
+
+	/* Initialize the MAC110 Core */
+	lp->mac->core_init(dev);
+
+	/* Enable the MAC/DMA */
+	stmmac_mac_enable_rx(dev);
+	stmmac_mac_enable_tx(dev);
+
+	if (netif_msg_hw(lp))
+		lp->mac->mac_registers((unsigned int)dev->base_addr);
+
+	phy_start(lp->phydev);
+
+	/* Start the ball rolling... */
+	DBG(probe, DEBUG, "%s: DMA RX/TX processes started...\n",
+	    ETH_RESOURCE_NAME);
+
+	stmmac_dma_start_rx(dev->base_addr);
+	stmmac_dma_start_tx(dev->base_addr);
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+/**
+ *  stmmac_release - close entry point of the driver
+ *  @dev : device pointer.
+ *  Description:
+ *  This is the stop entry point of the driver.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
+int stmmac_release(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Stop the PHY */
+	phy_stop(lp->phydev);
+	phy_disconnect(lp->phydev);
+	lp->phydev = NULL;
+
+	/* Free the IRQ lines */
+	free_irq(dev->irq, dev);
+
+	/* Stop TX/RX DMA and clear the descriptors */
+	stmmac_dma_stop_tx(dev->base_addr);
+	stmmac_dma_stop_rx(dev->base_addr);
+
+	free_dma_desc_resources(dev);
+
+	/* Disable the MAC core */
+	stmmac_mac_disable_tx(dev);
+	stmmac_mac_disable_rx(dev);
+
+	/* Change the link status */
+	netif_carrier_off(dev);
+
+	return 0;
+}
+
+/**
+ *  stmmac_fill_tx_buffer
+ *  @data : data buffer
+ *  @size : fragment size
+ *  @mss : Maximum  Segment Size
+ *  @lp : driver local structure
+ *  @first : first element in the ring
+ *  Description: it is used for filling the DMA tx ring with the frame to be
+ *  transmitted.
+ *  Note that the algorithm works both for the non-paged data and for the paged
+ *  fragment (SG).
+ *  Return value:
+ *    current entry point in the tx ring
+ */
+static int stmmac_fill_tx_buffer(void *data, unsigned int size,
+				 unsigned int mss,
+				 struct eth_driver_local *lp, int first)
+{
+	int new_des = 0;
+	void *addr = data;
+	dma_desc *p = lp->dma_tx;
+	unsigned int entry;
+	int bsize = lp->dma_buf_sz;
+	unsigned int txsize = lp->dma_tx_size;
+
+	TX_DBG(mss, INFO, "  %s (size=%d, addr=0x%x)\n", __FUNCTION__,
+	       size, (unsigned int)addr);
+	do {
+		if (new_des) {
+			lp->cur_tx++;
+			new_des = 0;
+		}
+		entry = lp->cur_tx % txsize;
+		/* Set the owner field */
+		p[entry].des0 = OWN_BIT;
+		/* Reset the descriptor number 1 */
+		p[entry].des1 = (p[entry].des1 & DES1_CONTROL_TER);
+		if (first)
+			p[entry].des1 |= TDES1_CONTROL_FS;
+		else
+			lp->tx_skbuff[entry] = NULL;
+
+		TX_DBG(mss, INFO, "\t[entry =%d] buf1 len=%d\n",
+		       entry, min((int)size, bsize));
+		/* If the data size is too big we need to use the buffer 2
+		 * (in the same descriptor) or, if necessary, another descriptor
+		 * in the ring. */
+		if (likely(size < bsize)) {
+			p[entry].des1 |= ((size << DES1_RBS1_SIZE_SHIFT) &
+					  DES1_RBS1_SIZE_MASK);
+			p[entry].des2 = dma_map_single(lp->device, addr,
+						       size, DMA_TO_DEVICE);
+		} else {
+			int b2_size = (size - bsize);
+
+			p[entry].des1 |= TDES1_MAX_BUF1_SIZE;
+			p[entry].des2 = dma_map_single(lp->device, addr, bsize,
+						       DMA_TO_DEVICE);
+
+			/* Check if we need to use the buffer 2 */
+			if (b2_size > 0) {
+				void *buffer2 = addr;
+
+				TX_DBG(mss, INFO, "\t[entry=%d] buf2 len=%d\n",
+				       entry, min(b2_size, bsize));
+
+				/* Check if we need another descriptor. */
+				if (b2_size > bsize) {
+					b2_size = bsize;
+					size -= (2 * bsize);
+					addr += ((2 * bsize) + 1);
+					new_des = 1;
+					TX_DBG(mss, INFO,
+					       "\tnew descriptor - "
+					       "%s (len = %d)\n",
+					       (first) ? "skb->data" :
+					       "Frag", size);
+				}
+				p[entry].des3 = dma_map_single(lp->device,
+							       (buffer2 +
+								bsize + 1),
+							       b2_size,
+							       DMA_TO_DEVICE);
+				if (b2_size == bsize) {
+					p[entry].des1 |= TDES1_MAX_BUF2_SIZE;
+				} else {
+					p[entry].des1 |=
+					    ((b2_size << DES1_RBS2_SIZE_SHIFT)
+					     & DES1_RBS2_SIZE_MASK);
+				}
+			}
+		}
+	} while (new_des);
+	return entry;
+}
+
+/**
+ *  stmmac_xmit - Tx entry point of the driver
+ *  @skb : the socket buffer
+ *  @dev : device pointer
+ *  Description :
+ *  This function is the Tx entry point of the driver.
+ */
+int stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	dma_desc *p = lp->dma_tx;
+	unsigned int txsize = lp->dma_tx_size;
+	unsigned int nfrags = skb_shinfo(skb)->nr_frags,
+	    entry = lp->cur_tx % txsize, i, mss = 0, nopaged_len;
+	unsigned long flags;
+
+	if (skb_padto(skb, ETH_ZLEN)) {
+		printk("stmmac: xmit padto returned 0\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&lp->tx_lock, flags);
+	/* This is a hard error log it. */
+	if (unlikely(TX_BUFFS_AVAIL(lp) < nfrags + 1)) {
+		if (netif_msg_drv(lp)) {
+			printk(KERN_ERR
+			       "%s: bug! Tx Ring full when queue awake!\n",
+			       dev->name);
+		}
+		return 1;
+	}
+
+	/* Verify the checksum */
+	lp->mac->tx_checksum(skb);
+
+	/* Get the amount of non-paged data (skb->data). */
+	nopaged_len = skb_headlen(skb);
+	lp->tx_skbuff[entry] = skb;
+	TX_DBG(mss, INFO, "\n%s:\n(skb->len=%d, nfrags=%d, "
+	       "nopaged_len=%d, mss=%d)\n", __FUNCTION__, skb->len,
+	       nfrags, nopaged_len, mss);
+	/* Handle the non-paged data (skb->data) */
+	stmmac_fill_tx_buffer(skb->data, nopaged_len, mss, lp, 1);
+
+	/* Handle the paged fragments */
+	for (i = 0; i < nfrags; i++) {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+		void *addr =
+		    ((void *)page_address(frag->page) + frag->page_offset);
+		int len = frag->size;
+
+		lp->cur_tx++;
+		entry = stmmac_fill_tx_buffer(addr, len, mss, lp, 0);
+	}
+	p[entry].des1 |= TDES1_CONTROL_LS | TDES1_CONTROL_IC;
+	lp->cur_tx++;
+	lp->stats.tx_bytes += skb->len;
+
+#ifdef STMMAC_DEBUG
+	if (netif_msg_pktdata(lp)) {
+		printk(">>> (current=%d, dirty=%d; entry=%d)\n",
+		       (lp->cur_tx % txsize), (lp->dirty_tx % txsize), entry);
+		display_dma_desc_ring(lp->dma_tx, txsize);
+		printk(">>> frame to be transmitted: ");
+		print_pkt(skb->data, skb->len);
+	}
+#endif
+	/* CSR1 enables the transmit DMA to check for new descriptor */
+	writel(1, dev->base_addr + DMA_XMT_POLL_DEMAND);
+
+	if (TX_BUFFS_AVAIL(lp) <= (MAX_SKB_FRAGS + 1)) {
+#if 0
+		printk("XMIT (current=%d, dirty=%d; entry=%d, "
+		       "nfrags=%d,skb->data=0x%p\n",
+		       (lp->cur_tx % txsize), (lp->dirty_tx % txsize),
+		       entry, nfrags, skb->data);
+		display_dma_desc_ring(lp->dma_tx, txsize);
+		printk("\tstop Queue: buffs_avail %d)\n", TX_BUFFS_AVAIL(lp));
+#endif
+		netif_stop_queue(dev);
+	}
+
+	dev->trans_start = jiffies;
+
+	spin_unlock_irqrestore(&lp->tx_lock, flags);
+	return 0;
+}
+
+static __inline__ void stmmac_rx_refill(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int rxsize = lp->dma_rx_size;
+
+	for (; lp->cur_rx - lp->dirty_rx > 0; lp->dirty_rx++) {
+		struct sk_buff *skb;
+		int entry = lp->dirty_rx % rxsize;
+		if (lp->rx_skbuff[entry] == NULL) {
+			skb = dev_alloc_skb(lp->dma_buf_sz);
+			lp->rx_skbuff[entry] = skb;
+			if (unlikely(skb == NULL)) {
+				printk(KERN_ERR "%s: skb is NULL\n",
+				       __FUNCTION__);
+				break;
+			}
+			skb->dev = dev;
+			lp->rx_skbuff_dma[entry] = dma_map_single(lp->device,
+							  skb->data, lp->dma_buf_sz,
+							  DMA_FROM_DEVICE);
+			(lp->dma_rx + entry)->des2 = lp->rx_skbuff_dma[entry];
+			RX_DBG(rx_status, INFO, "\trefill entry #%d\n", entry);
+		}
+	}
+	return;
+}
+
+/**
+ *  stmmac_poll - stmmac poll method (NAPI)
+ *  @dev : device pointer
+ *  @budget : maximum number of packets that the current CPU can receive from
+ *	      all interfaces.
+ *  Description :
+ *   This function implements the the reception process.
+ *   It is based on NAPI which provides a "inherent mitigation" in order
+ *   to improve network performance.
+ *   Note: when the RIE bit, in the INT_EN register (CSR7), is turned off 
+ *   (in order to disable the dma rx interrupt in the irq handler), 
+ *   the corresponding bit in the status register (CSR5 ) continues to be 
+ *   turned on with new packet arrivals. In poll method, we loop until the 
+ *   descriptor 0 is not owned by the DMA. If quota is exceeded and there are
+ *   pending work we do not touch the irq status and the method is not removed
+ *   from the poll list. Otherwise we can call the netif_rx_complete function
+ *   and normal exit. To debug that enable the STMMAC_RX_DEBUG macro.
+ *   In the end, stmmac_poll also supports the zero-copy mechanism by 
+ *   tuning the rx_copybreak parameter.
+ */
+static int stmmac_poll(struct net_device *dev, int *budget)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int rxsize = lp->dma_rx_size;
+	int frame_len = 0, entry = lp->cur_rx % rxsize, nframe = 0,
+	    rx_work_limit = *budget;
+	unsigned int ioaddr = dev->base_addr;
+	dma_desc *drx = lp->dma_rx + entry;
+
+#ifdef STMMAC_RX_DEBUG
+	printk(">>> stmmac_poll: RX descriptor ring:\n");
+	display_dma_desc_ring(lp->dma_rx, rxsize);
+#endif
+
+	if (rx_work_limit > dev->quota)
+		rx_work_limit = dev->quota;
+
+	while (!(drx->des0 & OWN_BIT)) {
+		unsigned int status = drx->des0;
+
+		if (--rx_work_limit < 0) {
+			RX_DBG("\twork limit!!!\n");
+			goto not_done;
+		}
+
+		if (unlikely(lp->mac->check_rx_summary(&lp->stats, status) < 0)) {
+			lp->stats.rx_errors++;
+		} else {
+			struct sk_buff *skb;
+
+			/* frame_len is the length in bytes (omitting the FCS) */
+			frame_len = (((status & RDES0_STATUS_FL_MASK) >>
+				      RDES0_STATUS_FL_SHIFT) - 4);
+
+			RX_DBG
+			    ("\tquota %d, desc addr: 0x%0x [entry: %d] buff=0x%x\n",
+			     rx_work_limit, (unsigned int)drx, entry,
+			     drx->des2);
+
+			/* Check if the packet is long enough to accept without
+			   copying to a minimally-sized skbuff. */
+			if ((frame_len < rx_copybreak) &&
+			    (skb = dev_alloc_skb(frame_len + 2)) != NULL) {
+				skb->dev = dev;
+				skb_reserve(skb, NET_IP_ALIGN);
+				dma_sync_single_for_cpu(lp->device,
+						lp->rx_skbuff_dma[entry], frame_len,
+						DMA_FROM_DEVICE);
+				skb_copy_to_linear_data(skb, lp->rx_skbuff[entry]->data, 
+							frame_len);
+
+				skb_put(skb, frame_len);
+				dma_sync_single_for_device(lp->device,
+						   lp->rx_skbuff_dma[entry], frame_len,
+						   DMA_FROM_DEVICE);
+			} else {	/* zero-copy */
+				skb = lp->rx_skbuff[entry];
+				if (unlikely(!skb)) {
+					printk(KERN_ERR "%s: Inconsistent Rx "
+					       "descriptor chain.\n",
+					       dev->name);
+					lp->stats.rx_dropped++;
+					goto next_frame;
+				}
+				lp->rx_skbuff[entry] = NULL;
+				skb_put(skb, frame_len);
+				dma_unmap_single(lp->device,
+						 lp->rx_skbuff_dma[entry],
+						 frame_len, DMA_FROM_DEVICE);
+			}
+#ifdef STMMAC_DEBUG
+			if (netif_msg_pktdata(lp)) {
+				printk(KERN_DEBUG " - frame received: ");
+				print_pkt(skb->data, frame_len);
+			}
+#endif
+			skb->protocol = eth_type_trans(skb, dev);
+			lp->mac->rx_checksum(skb, status);
+			netif_receive_skb(skb);
+			lp->stats.rx_packets++;
+			lp->stats.rx_bytes += frame_len;
+			dev->last_rx = jiffies;
+			nframe++;
+		}
+	      next_frame:
+		drx->des0 = OWN_BIT;
+		entry = (++lp->cur_rx) % rxsize;
+		drx = lp->dma_rx + entry;
+	}
+
+	dev->quota -= nframe;
+	*budget -= nframe;
+	stmmac_rx_refill(dev);
+	__netif_rx_complete(dev);
+	RX_DBG("<<< stmmmac_poll: poll stopped and exits...\n");
+	stmmac_dma_enable_irq_rx(ioaddr);
+
+	return 0;
+
+      not_done:
+	RX_DBG("<<< stmmmac_poll: not done... \n");
+	dev->quota -= nframe;
+	*budget -= nframe;
+	stmmac_rx_refill(dev);
+	return 1;
+}
+
+/**
+ *  stmmac_tx_timeout
+ *  @dev : Pointer to net device structure
+ *  Description: this function is called when a packet transmission fails to
+ *   complete within a reasonable period. The driver will mark the error in the
+ *   netdev structure and arrange for the device to be reset to a sane state
+ *   in order to transmit a new packet.
+ */
+void stmmac_tx_timeout(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	printk(KERN_WARNING "%s: Tx timeout at %ld, latency %ld\n",
+	       dev->name, jiffies, (jiffies - dev->trans_start));
+
+#ifdef STMMAC_DEBUG
+	printk("(current=%d, dirty=%d)\n", (lp->cur_tx % lp->dma_tx_size),
+	       (lp->dirty_tx % lp->dma_tx_size));
+	printk("DMA tx ring status: \n");
+	display_dma_desc_ring(lp->dma_tx, lp->dma_tx_size);
+#endif
+	netif_stop_queue(dev);
+	spin_lock(&lp->tx_lock);
+	stmmac_dma_stop_tx(dev->base_addr);
+	clear_dma_descs(lp->dma_tx, lp->dma_tx_size, 0);
+	stmmac_dma_start_tx(dev->base_addr);
+	spin_unlock(&lp->tx_lock);
+
+	lp->stats.tx_errors++;
+	dev->trans_start = jiffies;
+	netif_wake_queue(dev);
+
+	return;
+}
+
+/**
+ *  stmmac_stats
+ *  @dev : Pointer to net device structure
+ *  Description: this function returns statistics to the caller application
+ */
+struct net_device_stats *stmmac_stats(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	return &lp->stats;
+}
+
+/* Configuration changes (passed on by ifconfig) */
+int stmmac_config(struct net_device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP)	/* can't act on a running interface */
+		return -EBUSY;
+
+	/* Don't allow changing the I/O address */
+	if (map->base_addr != dev->base_addr) {
+		printk(KERN_WARNING "%s: can't change I/O address\n",
+		       dev->name);
+		return -EOPNOTSUPP;
+	}
+
+	/* Don't allow changing the IRQ */
+	if (map->irq != dev->irq) {
+		printk(KERN_WARNING "%s: can't change IRQ number %d\n",
+		       dev->name, dev->irq);
+		return -EOPNOTSUPP;
+	}
+
+	/* ignore other fields */
+	return 0;
+}
+
+/**
+ *  stmmac_multicast_list - entry point for multicast addressing
+ *  @dev : pointer to the device structure
+ *  Description:
+ *  This function is a driver entry point which gets called by the kernel
+ *  whenever multicast addresses must be enabled/disabled.
+ *  Return value:
+ *  void.
+ */
+static void stmmac_multicast_list(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Calling the hw function. */
+	lp->mac->set_filter(dev);
+
+	return;
+}
+
+/**
+ *  stmmac_change_mtu - entry point to change MTU size for the device.
+ *   @dev : device pointer.
+ *   @new_mtu : the new MTU size for the device.
+ *   Description: the Maximum Transfer Unit (MTU) is used by the network layer
+ *     to drive packet transmission. Ethernet has an MTU of 1500 octets 
+ *     (ETH_DATA_LEN). This value can be changed with ifconfig.
+ *  Return value:
+ *   0 on success and an appropriate (-)ve integer as defined in errno.h
+ *   file on failure.
+ */
+static int stmmac_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (netif_running(dev)) {
+		printk(KERN_ERR "%s: must be stopped to change its MTU\n",
+		       dev->name);
+		return -EBUSY;
+	}
+
+	if ((new_mtu < MIN_MTU) || (new_mtu > MAX_MTU))
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static irqreturn_t stmmac_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+
+	if (unlikely(!dev)) {
+		printk(KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
+		return IRQ_NONE;
+	}
+
+	stmmac_dma_interrupt(dev);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling receive - used by NETCONSOLE and other diagnostic tools
+ * to allow network I/O with interrupts disabled. */
+static void stmmac_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	stmmac_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+/**
+ *  stmmac_ioctl - Entry point for the Ioctl
+ *  @dev :  Device pointer.
+ *  @rq :  An IOCTL specefic structure, that can contain a pointer to
+ *  a proprietary structure used to pass information to the driver.
+ *  @cmd :  IOCTL command
+ *  Description:
+ *  Currently there are no special functionality supported in IOCTL, just the
+ *  phy_mii_ioctl(...) can be invoked.
+ */
+static int stmmac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int ret = -EOPNOTSUPP;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (!lp->phydev)
+			return -EINVAL;
+
+		spin_lock(&lp->lock);
+		ret = phy_mii_ioctl(lp->phydev, if_mii(rq), cmd);
+		spin_unlock(&lp->lock);
+	default:
+		break;
+	}
+	return ret;
+}
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+static void stmmac_vlan_rx_register(struct net_device *dev,
+				    struct vlan_group *grp)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	lp->vlgrp = grp;
+	stmmac_multicast_list(dev);
+	spin_unlock(&lp->lock);
+}
+
+static void stmmac_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	stmmac_multicast_list(dev);
+	spin_unlock(&lp->lock);
+}
+
+static void stmmac_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	if (lp->vlgrp)
+		lp->vlgrp->vlan_devices[vid] = NULL;
+	stmmac_multicast_list(dev);
+	spin_unlock(&lp->lock);
+}
+#endif
+
+/**
+ *  stmmac_probe - Initialization of the adapter .
+ *  @dev : device pointer
+ *  @ioaddr: device I/O address
+ *  Description: The function initializes the network device structure for
+ *	         the STMMAC driver. It also calls the low level routines 
+ *		 in order to init the HW (i.e. the DMA engine)
+ */
+static int stmmac_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	int ret = 0;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ether_setup(dev);
+
+	dev->open = stmmac_open;
+	dev->stop = stmmac_release;
+	dev->set_config = stmmac_config;
+
+	dev->hard_start_xmit = stmmac_xmit;
+	dev->features |= (NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA);
+
+	dev->get_stats = stmmac_stats;
+	dev->tx_timeout = stmmac_tx_timeout;
+	dev->watchdog_timeo = msecs_to_jiffies(watchdog);
+	dev->set_multicast_list = stmmac_multicast_list;
+	dev->change_mtu = stmmac_change_mtu;
+	dev->ethtool_ops = &stmmac_ethtool_ops;
+	dev->do_ioctl = &stmmac_ioctl;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = stmmac_poll_controller;
+#endif
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
+	dev->vlan_rx_register = stmmac_vlan_rx_register;
+	dev->vlan_rx_add_vid = stmmac_vlan_rx_add_vid;
+	dev->vlan_rx_kill_vid = stmmac_vlan_rx_kill_vid;
+#endif
+
+	lp->msg_enable = netif_msg_init(debug, default_msg_level);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	lp->ip_header_len = VLAN_ETH_HLEN;
+#else
+	lp->ip_header_len = ETH_HLEN;
+#endif
+	lp->rx_csum = 0;
+
+	lp->dma_tx_size = dma_tx_size_param;
+	lp->dma_rx_size = dma_rx_size_param;
+
+	dev->poll = stmmac_poll;
+	dev->weight = lp->dma_rx_size;
+
+	/* Check the module arguments */
+	stmmac_check_mod_params(dev);
+
+	/* Set the I/O base addr */
+	dev->base_addr = ioaddr;
+
+	/* Get the MAC address */
+	get_mac_address(ioaddr, dev->dev_addr);
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_WARNING "\tno valid MAC address; "
+		       "please, set using ifconfig or nwhwconfig!\n");
+	}
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR "%s: ERROR %i registering the device\n",
+		       __FUNCTION__, ret);
+		return -ENODEV;
+	}
+
+	spin_lock_init(&lp->lock);
+	spin_lock_init(&lp->tx_lock);
+
+	return ret;
+}
+
+/**
+ * stmmac_hw_dev_register
+ * @lp : driver local structure
+ * Description: it inits the hw mac device function pointers 
+ *		within the local network driver structure.
+ */
+static int stmmac_hw_dev_register(struct eth_driver_local *lp)
+{
+	struct stmmmac_driver *mac = &mac_driver;
+
+	printk(KERN_DEBUG "stmmmac: %s device\n", mac->name);
+
+	lp->mac = kmalloc(sizeof(struct stmmmac_driver), GFP_KERNEL);
+	lp->mac->name = mac->name;
+	lp->mac->have_hw_fix = mac->have_hw_fix;
+	lp->mac->core_init = mac->core_init;
+	lp->mac->mac_registers = mac->mac_registers;
+	lp->mac->dma_registers = mac->dma_registers;
+	lp->mac->check_tx_summary = mac->check_tx_summary;
+	lp->mac->check_rx_summary = mac->check_rx_summary;
+	lp->mac->tx_checksum = mac->tx_checksum;
+	lp->mac->rx_checksum = mac->rx_checksum;
+	lp->mac->set_filter = mac->set_filter;
+
+	return 0;
+}
+
+ /**
+ * stmmacphy_dvr_probe
+ * @pdev: platform device pointer
+ * Description: The driver is initialized through the platform_device
+ * 		structures which define the configuration needed by the SoC.
+ *		These are defined in arch/sh/kernel/cpu/sh4
+ */
+static int stmmacphy_dvr_probe(struct platform_device *pdev)
+{
+	struct plat_stmmacphy_data *plat_dat;
+	plat_dat = (struct plat_stmmacphy_data *)((pdev->dev).platform_data);
+
+	printk(KERN_DEBUG "stmmacphy_dvr_probe: added phy for bus %d\n",
+	       plat_dat->bus_id);
+
+	return 0;
+}
+
+static int stmmacphy_dvr_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver stmmacphy_driver = {
+	.driver = {
+		   .name = PHY_RESOURCE_NAME,
+		   },
+	.probe = stmmacphy_dvr_probe,
+	.remove = stmmacphy_dvr_remove,
+};
+
+/**
+ * stmmac_associate_phy
+ * @lp: pointer to local context
+ * Description: Scans through all the PHYs we have registered and checks if
+ *              any are associated with our MAC.  If so, then just fill in
+ *              the blanks in our local context structure
+ */
+static int stmmac_associate_phy(struct device *dev, void *data)
+{
+	struct eth_driver_local *lp = (struct eth_driver_local *)data;
+	struct plat_stmmacphy_data *plat_dat;
+
+	plat_dat = (struct plat_stmmacphy_data *)(dev->platform_data);
+
+	DBG(probe, DEBUG,
+	    "stmmacphy_dvr_probe: checking phy for bus %d\n", plat_dat->bus_id);
+
+	/* Check that this phy is for the MAC being initialised */
+	if (lp->bus_id != plat_dat->bus_id)
+		return 0;
+
+	/* OK, this PHY is connected to the MAC.  Go ahead and get the parameters */
+	DBG(probe, DEBUG, "stmmacphy_dvr_probe: OK. Found PHY config\n");
+	lp->phy_irq =
+	    platform_get_irq_byname(to_platform_device(dev), "phyirq");
+	DBG(probe, DEBUG,
+	    "stmmacphy_dvr_probe: PHY irq on bus %d is %d\n",
+	    plat_dat->bus_id, lp->phy_irq);
+
+	/* override with kernel parameters if supplied XXX CRS XXX this needs to have multiple instances */
+	if ((phy_n >= 0) && (phy_n <= 31)) {
+		plat_dat->phy_addr = phy_n;
+	}
+
+	lp->phy_addr = plat_dat->phy_addr;
+	lp->phy_mask = plat_dat->phy_mask;
+	lp->phy_interface = plat_dat->interface;
+	lp->phy_reset = plat_dat->phy_reset;
+
+	DBG(probe, DEBUG, "stmmacphy_dvr_probe: exiting\n");
+	return 1;		/* forces exit of driver_for_each_device() */
+}
+
+/**
+ * stmmac_dvr_probe
+ * @pdev: platform device pointer
+ * Description: The driver is initialized through platform_device.  
+ * 		Structures which define the configuration needed by the board 
+ *		are defined in a board structure in arch/sh/boards/st/ .
+ */
+static int stmmac_dvr_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	unsigned int *addr = NULL;
+	struct net_device *ndev = NULL;
+	struct eth_driver_local *lp;
+	struct plat_stmmacenet_data *plat_dat;
+
+	printk(KERN_INFO "STMMAC driver:\n\tplatform registration... ");
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto out;
+	}
+	printk(KERN_INFO "done!\n");
+
+	if (!request_mem_region(res->start, (res->end - res->start),
+				ETH_RESOURCE_NAME)) {
+		printk(KERN_ERR "%s: ERROR: memory allocation failed"
+		       "cannot get the I/O addr 0x%x\n",
+		       __FUNCTION__, (unsigned int)res->start);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	addr = ioremap(res->start, (res->end - res->start));
+	if (!addr) {
+		printk(KERN_ERR "%s: ERROR: memory mapping failed \n",
+		       __FUNCTION__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct eth_driver_local));
+	if (!ndev) {
+		printk(KERN_ERR "%s: ERROR: allocating the device\n",
+		       __FUNCTION__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* Get the MAC information */
+	if ((ndev->irq = platform_get_irq_byname(pdev, "macirq")) == 0) {
+		printk(KERN_ERR "%s: ERROR: MAC IRQ configuration "
+		       "information not found\n", __FUNCTION__);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	lp = netdev_priv(ndev);
+	lp->device = &(pdev->dev);
+	plat_dat = (struct plat_stmmacenet_data *)((pdev->dev).platform_data);
+	lp->bus_id = plat_dat->bus_id;
+	lp->pbl = plat_dat->pbl;
+
+	platform_set_drvdata(pdev, ndev);
+
+	/* Network Device Registration */
+	ret = stmmac_probe(ndev, (unsigned long)addr);
+	if (ret < 0) {
+		goto out;
+	}
+
+	stmmac_hw_dev_register(lp);
+
+	/* associate a PHY - it is provided by another platform bus */
+	if (!driver_for_each_device
+	    (&(stmmacphy_driver.driver), NULL, (void *)lp,
+	     stmmac_associate_phy)) {
+		printk(KERN_ERR "No PHY device is associated with this MAC!\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	lp->fix_mac_speed = plat_dat->fix_mac_speed;
+	lp->bsp_priv = plat_dat->bsp_priv;
+
+	/* MDIO bus Registration */
+	printk(KERN_DEBUG "registering MDIO bus...\n");
+	ret = stmmac_mdio_register(ndev);
+	printk(KERN_DEBUG "registering MDIO bus done\n");
+	ndev = __dev_get_by_name("eth0");
+
+      out:
+	if (ret < 0) {
+		platform_set_drvdata(pdev, NULL);
+		release_mem_region(res->start, (res->end - res->start));
+		if (addr != NULL)
+			iounmap(addr);
+	}
+
+	return ret;
+}
+
+/**
+ * stmmac_dvr_remove
+ * @pdev: platform device pointer
+ * Description: This function resets the TX/RX processes, disables the MAC RX/TX
+ *   changes the link status, releases the DMA descriptor rings,
+ *   unregisters the MDIO busm and unmaps allocated memory.
+ */
+static int stmmac_dvr_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	printk(KERN_INFO "%s:\n\tremoving driver", __FUNCTION__);
+
+	stmmac_dma_stop_rx(ndev->base_addr);
+	stmmac_dma_stop_tx(ndev->base_addr);
+
+	stmmac_mac_disable_rx(ndev);
+	stmmac_mac_disable_tx(ndev);
+
+	netif_carrier_off(ndev);
+
+	stmmac_mdio_unregister(ndev);
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(ndev);
+
+	iounmap((void *)ndev->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, (res->end - res->start));
+
+	free_netdev(ndev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int stmmac_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	unsigned long flags;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	if (!dev || !netif_running(dev))
+		return 0;
+
+	netif_device_detach(dev);
+	netif_stop_queue(dev);
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	/* Disable Rx and Tx */
+	stmmac_dma_stop_tx(dev->base_addr);
+	stmmac_dma_stop_rx(dev->base_addr);
+
+	clear_dma_descs(lp->dma_tx, lp->dma_tx_size, 0);
+	clear_dma_descs(lp->dma_rx, lp->dma_rx_size, OWN_BIT);
+
+	/* Disable the MAC core */
+	stmmac_mac_disable_tx(dev);
+	stmmac_mac_disable_rx(dev);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return 0;
+}
+
+static int stmmac_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	unsigned long flags;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return 0;
+
+	netif_device_attach(dev);
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	/* Enable the MAC/DMA */
+	stmmac_mac_enable_rx(dev);
+	stmmac_mac_enable_tx(dev);
+
+	stmmac_dma_start_rx(dev->base_addr);
+	stmmac_dma_start_tx(dev->base_addr);
+
+	netif_start_queue(dev);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return 0;
+}
+#endif
+
+static struct platform_driver stmmac_driver = {
+	.driver = {
+		   .name = ETH_RESOURCE_NAME,
+		   },
+	.probe = stmmac_dvr_probe,
+	.remove = stmmac_dvr_remove,
+#ifdef CONFIG_PM
+	.suspend = stmmac_suspend,
+	.resume = stmmac_resume,
+#endif
+
+};
+
+/**
+ * stmmac_init_module - Entry point for the driver
+ * Description: This function is the entry point for the driver.
+ */
+static int __init stmmac_init_module(void)
+{
+	if (platform_driver_register(&stmmacphy_driver)) {
+		printk(KERN_ERR "No PHY devices registered!\n");
+		return -ENODEV;
+	}
+
+	return platform_driver_register(&stmmac_driver);
+}
+
+/**
+ * stmmac_cleanup_module - Cleanup routine for the driver
+ * Description: This function is the cleanup routine for the driver.
+ */
+static void __exit stmmac_cleanup_module(void)
+{
+	platform_driver_unregister(&stmmac_driver);
+}
+
+static void stmmac_check_mod_params(struct net_device *dev)
+{
+	/* Wrong parameters are replaced with the default values */
+	if (watchdog < 0)
+		watchdog = TX_TIMEO;
+	if (dma_buffer_size > DMA_MAX_BUFFER_SIZE)
+		dma_buffer_size = DMA_MAX_BUFFER_SIZE;
+	if (rx_copybreak < 0)
+		rx_copybreak = ETH_FRAME_LEN;
+	if (dma_rx_size_param < 0)
+		dma_rx_size_param = DMA_RX_SIZE;
+	if (dma_tx_size_param < 0)
+		dma_tx_size_param = DMA_TX_SIZE;
+	return;
+}
+
+static int __init stmmac_cmdline_opt(char *str)
+{
+	char *opt;
+
+	if (!str || !*str)
+		return -EINVAL;
+
+	while ((opt = strsep(&str, ",")) != NULL) {
+		if (!strncmp(opt, "msglvl:", 7)) {
+			debug = simple_strtoul(opt + 7, NULL, 0);
+		} else if (!strncmp(opt, "phyaddr:", 8)) {
+			phy_n = simple_strtoul(opt + 8, NULL, 0);
+		} else if (!strncmp(opt, "watchdog:", 9)) {
+			watchdog = simple_strtoul(opt + 9, NULL, 0);
+		} else if (!strncmp(opt, "minrx:", 6)) {
+			rx_copybreak = simple_strtoul(opt + 6, NULL, 0);
+		} else if (!strncmp(opt, "bfsize:", 7)) {
+			dma_buffer_size = simple_strtoul(opt + 7, NULL, 0);
+		} else if (!strncmp(opt, "txsize:", 7)) {
+			dma_tx_size_param = simple_strtoul(opt + 7, NULL, 0);
+		} else if (!strncmp(opt, "rxsize:", 7)) {
+			dma_rx_size_param = simple_strtoul(opt + 7, NULL, 0);
+		}
+	}
+	return 0;
+}
+
+__setup("stmmaceth=", stmmac_cmdline_opt);
+
+module_init(stmmac_init_module);
+module_exit(stmmac_cleanup_module);
+
+MODULE_DESCRIPTION("STMMAC 10/100/1000 Ethernet driver");
+MODULE_AUTHOR("Giuseppe Cavallaro");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/stmmac/stmmac_mdio.c linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_mdio.c
--- linux-2.6.23.1/drivers/net/stmmac/stmmac_mdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/stmmac/stmmac_mdio.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,170 @@
+/*
+ * drivers/net/stmmac/stmmac_mdio.c
+ *
+ * STMMAC Ethernet Driver -- MDIO bus implementation
+ * Provides Bus interface for MII registers
+ *
+ * Author: Carl Shaw <carl.shaw@st.com>
+ * Maintainer: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * Copyright (c) 2006-2007 STMicroelectronics
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include "stmmac.h"
+
+/**
+ * stmmac_mdio_read
+ * @bus: points to the mii_bus structure
+ * @phyaddr: MII addr reg bits 15-11
+ * @phyreg: MII addr reg bits 10-6
+ * Description: it reads data from the MII register from within the phy device.
+ */
+int stmmac_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)
+{
+	struct net_device *ndev = bus->priv;
+	unsigned long ioaddr = ndev->base_addr;
+
+	int data;
+	u16 regValue = (((phyaddr << 11) & (0x0000F800)) |
+			((phyreg << 6) & (0x000007C0)));
+
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
+
+	writel(regValue, ioaddr + MAC_MII_ADDR);
+
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
+
+	/* Read the data from the MII data register */
+	data = (int)readl(ioaddr + MAC_MII_DATA);
+	return data;
+}
+
+/**
+ * stmmac_mdio_write
+ * @bus: points to the mii_bus structure
+ * @phyaddr: MII addr reg bits 15-11
+ * @phyreg: MII addr reg bits 10-6
+ * @phydata: phy data
+ * Description: it writes the data intto the MII register from within the device.
+ */
+int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg, u16 phydata)
+{
+	struct net_device *ndev = bus->priv;
+	unsigned long ioaddr = ndev->base_addr;
+
+	u16 value =
+	    (((phyaddr << 11) & (0x0000F800)) | ((phyreg << 6) & (0x000007C0)))
+	    | MAC_MII_ADDR_WRITE;
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
+
+	/* Set the MII address register to write */
+	writel(phydata, ioaddr + MAC_MII_DATA);
+	writel(value, ioaddr + MAC_MII_ADDR);
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
+
+	/* NOTE: we need to perform this "extra" read in order to fix an error
+	 * during the write operation */
+	stmmac_mdio_read(bus, phyaddr, phyreg);
+	return 0;
+}
+
+/* Resets the MII bus */
+int stmmac_mdio_reset(struct mii_bus *bus)
+{
+	struct net_device *ndev = bus->priv;
+	struct eth_driver_local *lp = netdev_priv(ndev);
+	unsigned long ioaddr = ndev->base_addr;
+
+	printk(KERN_DEBUG "stmmac_mdio_reset: called!\n");
+
+	if (lp->phy_reset) {
+		printk("stmmac_mdio_reset: calling phy_reset\n");
+		return lp->phy_reset(lp->bsp_priv);
+	}
+
+	/* This is a workaround for problems with the STE101P PHY.
+	 * It doesn't complete its reset until at least one clock cycle
+	 * on MDC, so perform a dummy mdio read.
+	 */
+	writel(0, ioaddr + MAC_MII_ADDR);
+
+	return 0;
+}
+
+/**
+ * stmmac_mdio_register
+ * @ndev: net device structure
+ * Description: it registers the MII bus
+ */
+int stmmac_mdio_register(struct net_device *ndev)
+{
+	int err = 0;
+	struct mii_bus *new_bus = kzalloc(sizeof(struct mii_bus), GFP_KERNEL);
+	int *irqlist = kzalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	struct eth_driver_local *lp = netdev_priv(ndev);
+
+	if (new_bus == NULL)
+		return -ENOMEM;
+
+	/* Assign IRQ to phy at address phy_addr */
+	irqlist[lp->phy_addr] = lp->phy_irq;
+
+	new_bus->name = "STMMAC MII Bus",
+	    new_bus->read = &stmmac_mdio_read,
+	    new_bus->write = &stmmac_mdio_write,
+	    new_bus->reset = &stmmac_mdio_reset, new_bus->id = (int)lp->bus_id;
+	new_bus->priv = ndev;
+	new_bus->irq = irqlist;
+	new_bus->phy_mask = lp->phy_mask;
+	new_bus->dev = 0;	/* FIXME */
+	printk(KERN_DEBUG "calling mdiobus_register\n");
+	err = mdiobus_register(new_bus);
+	printk(KERN_DEBUG "calling mdiobus_register done\n");
+	if (err != 0) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+		       new_bus->name);
+		goto bus_register_fail;
+	}
+
+	lp->mii = new_bus;
+	return 0;
+
+      bus_register_fail:
+	kfree(new_bus);
+	return err;
+}
+
+/**
+ * stmmac_mdio_unregister
+ * @ndev: net device structure
+ * Description: it unregisters the MII bus
+ */
+int stmmac_mdio_unregister(struct net_device *ndev)
+{
+	struct eth_driver_local *lp = netdev_priv(ndev);
+
+	mdiobus_unregister(lp->mii);
+	lp->mii->priv = NULL;
+	kfree(lp->mii);
+
+	return 0;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/usb/asix.c linux-2.6.23.1-stm/drivers/net/usb/asix.c
--- linux-2.6.23.1/drivers/net/usb/asix.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/usb/asix.c	2007-11-01 12:00:40.000000000 +0000
@@ -569,16 +569,18 @@
 {
 	struct usbnet *dev = netdev_priv(netdev);
 	u16 res;
+	u16* buf = kmalloc(sizeof(u16),GFP_KERNEL);
 
 	mutex_lock(&dev->phy_mutex);
 	asix_set_sw_mii(dev);
-	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
-				(__u16)loc, 2, (u16 *)&res);
+	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, buf);
+	res = *buf;
 	asix_set_hw_mii(dev);
 	mutex_unlock(&dev->phy_mutex);
 
 	devdbg(dev, "asix_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x", phy_id, loc, le16_to_cpu(res & 0xffff));
 
+	kfree(buf);
 	return le16_to_cpu(res & 0xffff);
 }
 
@@ -587,14 +589,16 @@
 {
 	struct usbnet *dev = netdev_priv(netdev);
 	u16 res = cpu_to_le16(val);
+	u16 *buf = kmalloc(sizeof(u16),GFP_KERNEL);
 
 	devdbg(dev, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x", phy_id, loc, val);
 	mutex_lock(&dev->phy_mutex);
 	asix_set_sw_mii(dev);
-	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
-				(__u16)loc, 2, (u16 *)&res);
+	*buf = res;
+	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, buf);
 	asix_set_hw_mii(dev);
 	mutex_unlock(&dev->phy_mutex);
+	kfree(buf);
 }
 
 /* Get the PHY Identifier from the PHYSID1 & PHYSID2 MII registers */
@@ -644,7 +648,7 @@
 {
 	struct usbnet *dev = netdev_priv(net);
 	u8 opt = 0;
-	u8 buf[1];
+	u8 *buf = kmalloc(sizeof(u8),GFP_KERNEL);
 
 	if (wolinfo->wolopts & WAKE_PHY)
 		opt |= AX_MONITOR_LINK;
@@ -654,9 +658,11 @@
 		opt |= AX_MONITOR_MODE;
 
 	if (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,
-			      opt, 0, 0, &buf) < 0)
+			      opt, 0, 0, &buf[0]) < 0){
+		kfree(&buf[0]);
 		return -EINVAL;
-
+	}
+	kfree(&buf[0]);
 	return 0;
 }
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/usb/pegasus.c linux-2.6.23.1-stm/drivers/net/usb/pegasus.c
--- linux-2.6.23.1/drivers/net/usb/pegasus.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/usb/pegasus.c	2007-11-01 12:00:42.000000000 +0000
@@ -51,7 +51,7 @@
 
 static const char driver_name[] = "pegasus";
 
-#undef	PEGASUS_WRITE_EEPROM
+#define	PEGASUS_WRITE_EEPROM
 #define	BMSR_MEDIA	(BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | \
 			BMSR_100FULL | BMSR_ANEGCAPABLE)
 
@@ -146,16 +146,16 @@
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.bRequestType = PEGASUS_REQT_READ;
-	pegasus->dr.bRequest = PEGASUS_REQ_GET_REGS;
-	pegasus->dr.wValue = cpu_to_le16(0);
-	pegasus->dr.wIndex = cpu_to_le16p(&indx);
-	pegasus->dr.wLength = cpu_to_le16p(&size);
+	pegasus->dr->bRequestType = PEGASUS_REQT_READ;
+	pegasus->dr->bRequest = PEGASUS_REQ_GET_REGS;
+	pegasus->dr->wValue = cpu_to_le16(0);
+	pegasus->dr->wIndex = cpu_to_le16p(&indx);
+	pegasus->dr->wLength = cpu_to_le16p(&size);
 	pegasus->ctrl_urb->transfer_buffer_length = size;
 
 	usb_fill_control_urb(pegasus->ctrl_urb, pegasus->usb,
 			     usb_rcvctrlpipe(pegasus->usb, 0),
-			     (char *) &pegasus->dr,
+			     (char *) pegasus->dr,
 			     buffer, size, ctrl_callback, pegasus);
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
@@ -204,16 +204,16 @@
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
-	pegasus->dr.bRequest = PEGASUS_REQ_SET_REGS;
-	pegasus->dr.wValue = cpu_to_le16(0);
-	pegasus->dr.wIndex = cpu_to_le16p(&indx);
-	pegasus->dr.wLength = cpu_to_le16p(&size);
+	pegasus->dr->bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr->bRequest = PEGASUS_REQ_SET_REGS;
+	pegasus->dr->wValue = cpu_to_le16(0);
+	pegasus->dr->wIndex = cpu_to_le16p(&indx);
+	pegasus->dr->wLength = cpu_to_le16p(&size);
 	pegasus->ctrl_urb->transfer_buffer_length = size;
 
 	usb_fill_control_urb(pegasus->ctrl_urb, pegasus->usb,
 			     usb_sndctrlpipe(pegasus->usb, 0),
-			     (char *) &pegasus->dr,
+			     (char *) pegasus->dr,
 			     buffer, size, ctrl_callback, pegasus);
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
@@ -257,16 +257,16 @@
 	remove_wait_queue(&pegasus->ctrl_wait, &wait);
 	set_current_state(TASK_RUNNING);
 
-	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
-	pegasus->dr.bRequest = PEGASUS_REQ_SET_REG;
-	pegasus->dr.wValue = cpu_to_le16(data);
-	pegasus->dr.wIndex = cpu_to_le16p(&indx);
-	pegasus->dr.wLength = cpu_to_le16(1);
+	pegasus->dr->bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr->bRequest = PEGASUS_REQ_SET_REG;
+	pegasus->dr->wValue = cpu_to_le16(data);
+	pegasus->dr->wIndex = cpu_to_le16p(&indx);
+	pegasus->dr->wLength = cpu_to_le16(1);
 	pegasus->ctrl_urb->transfer_buffer_length = 1;
 
 	usb_fill_control_urb(pegasus->ctrl_urb, pegasus->usb,
 			     usb_sndctrlpipe(pegasus->usb, 0),
-			     (char *) &pegasus->dr,
+			     (char *) pegasus->dr,
 			     tmp, 1, ctrl_callback, pegasus);
 
 	add_wait_queue(&pegasus->ctrl_wait, &wait);
@@ -293,16 +293,16 @@
 {
 	int ret;
 
-	pegasus->dr.bRequestType = PEGASUS_REQT_WRITE;
-	pegasus->dr.bRequest = PEGASUS_REQ_SET_REGS;
-	pegasus->dr.wValue = 0;
-	pegasus->dr.wIndex = cpu_to_le16(EthCtrl0);
-	pegasus->dr.wLength = cpu_to_le16(3);
+	pegasus->dr->bRequestType = PEGASUS_REQT_WRITE;
+	pegasus->dr->bRequest = PEGASUS_REQ_SET_REGS;
+	pegasus->dr->wValue = 0;
+	pegasus->dr->wIndex = cpu_to_le16(EthCtrl0);
+	pegasus->dr->wLength = cpu_to_le16(3);
 	pegasus->ctrl_urb->transfer_buffer_length = 3;
 
 	usb_fill_control_urb(pegasus->ctrl_urb, pegasus->usb,
 			     usb_sndctrlpipe(pegasus->usb, 0),
-			     (char *) &pegasus->dr,
+			     (char *) pegasus->dr,
 			     pegasus->eth_regs, 3, ctrl_callback, pegasus);
 
 	if ((ret = usb_submit_urb(pegasus->ctrl_urb, GFP_ATOMIC))) {
@@ -1001,6 +1001,45 @@
 	return 1;
 }
 
+static int alloc_dma_structs(pegasus_t * pegasus)
+{
+	pegasus->dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
+	if (!pegasus->dr) {
+		return 0;
+	}
+
+	pegasus->intr_buff = kmalloc(PEGASUS_INTR_SIZE, GFP_KERNEL);
+	if (! pegasus->intr_buff) {
+		kfree(pegasus->dr);
+		return 0;
+	}
+
+	pegasus->tx_buff = kmalloc(PEGASUS_MTU, GFP_KERNEL);
+	if (! pegasus->tx_buff) {
+		kfree(pegasus->intr_buff);
+		kfree(pegasus->dr);
+		return 0;
+	}
+
+	pegasus->eth_regs = kmalloc(4, GFP_KERNEL);
+	if (! pegasus->eth_regs) {
+		kfree(pegasus->tx_buff);
+		kfree(pegasus->intr_buff);
+		kfree(pegasus->dr);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void free_dma_structs(pegasus_t * pegasus)
+{
+	kfree(pegasus->eth_regs);
+	kfree(pegasus->tx_buff);
+	kfree(pegasus->intr_buff);
+	kfree(pegasus->dr);
+}
+
 static int pegasus_open(struct net_device *net)
 {
 	pegasus_t *pegasus = netdev_priv(net);
@@ -1030,7 +1069,7 @@
 
 	usb_fill_int_urb(pegasus->intr_urb, pegasus->usb,
 			 usb_rcvintpipe(pegasus->usb, 3),
-			 pegasus->intr_buff, sizeof (pegasus->intr_buff),
+			 pegasus->intr_buff, PEGASUS_INTR_SIZE,
 			 intr_callback, pegasus, pegasus->intr_interval);
 	if ((res = usb_submit_urb(pegasus->intr_urb, GFP_KERNEL))) {
 		if (res == -ENODEV)
@@ -1168,6 +1207,98 @@
 	pegasus->msg_enable = v;
 }
 
+#ifdef	PEGASUS_WRITE_EEPROM
+#define EEPROM_SIZE 0x80
+static int pegasus_get_eeprom_len(struct net_device *dev)
+{
+        return EEPROM_SIZE;
+}
+
+static int pegasus_geteeprom(struct net_device *dev,
+	struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	pegasus_t *pegasus = netdev_priv(dev);
+        int res = 0;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset+len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = read_eprom_word(pegasus, offset>>1, &tmp);
+		if (res) return res;
+		*bytes = cpu_to_le16(tmp) >> 8;
+		offset++;
+		len--;
+		bytes++;
+	}
+
+	while (len > 1) {
+		res = read_eprom_word(pegasus, offset>>1, &tmp);
+		if (res) break;
+		memcpy(bytes, &tmp, 2);
+		bytes += 2;
+		offset += 2;
+		len -= 2;
+	}
+
+	if (len) {
+		res = read_eprom_word(pegasus, offset>>1, &tmp);
+		if (res) return res;
+		*bytes = cpu_to_le16(tmp) & 0xff;
+	}
+
+	return res;
+}
+
+static int pegasus_seteeprom(struct net_device *dev,
+	struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	pegasus_t *pegasus = netdev_priv(dev);
+        int res;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset+len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = read_eprom_word(pegasus, offset>>1, &tmp);
+		if (res) return res;
+		tmp = le16_to_cpu((*bytes << 8) | (cpu_to_le16(tmp) & 0xff));
+		res = write_eprom_word(pegasus, offset>>1, tmp);
+		if (res) return res;
+		offset++;
+		len--;
+		bytes++;
+	}
+
+	while (len > 1) {
+		memcpy(&tmp, bytes, 2);
+		res = write_eprom_word(pegasus, offset>>1, tmp);
+		if (res) break;
+		bytes += 2;
+		offset += 2;
+		len -= 2;
+	}
+
+	if (len) {
+		res = read_eprom_word(pegasus, offset>>1, &tmp);
+		if (res) return res;
+		tmp = le16_to_cpu((cpu_to_le16(tmp) & 0xff00) | *bytes);
+		res = write_eprom_word(pegasus, offset>>1, tmp);
+		if (res) return res;
+	}
+
+	return res;
+}
+#endif
+
 static struct ethtool_ops ops = {
 	.get_drvinfo = pegasus_get_drvinfo,
 	.get_settings = pegasus_get_settings,
@@ -1178,6 +1309,11 @@
 	.set_msglevel = pegasus_set_msglevel,
 	.get_wol = pegasus_get_wol,
 	.set_wol = pegasus_set_wol,
+#ifdef	PEGASUS_WRITE_EEPROM
+	.get_eeprom_len = pegasus_get_eeprom_len,
+	.get_eeprom = pegasus_geteeprom,
+	.set_eeprom = pegasus_seteeprom,
+#endif
 };
 
 static int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
@@ -1315,6 +1451,11 @@
 		goto out1;
 	}
 
+	if (!alloc_dma_structs(pegasus)) {
+		dev_err(&intf->dev, "can't allocate %s\n", "DMA structs");
+		goto out1_5;
+	}
+
 	tasklet_init(&pegasus->rx_tl, rx_fixup, (unsigned long) pegasus);
 
 	INIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);
@@ -1381,6 +1522,8 @@
 	usb_set_intfdata(intf, NULL);
 	free_skb_pool(pegasus);
 out2:
+	free_dma_structs(pegasus);
+out1_5:
 	free_all_urbs(pegasus);
 out1:
 	free_netdev(net);
@@ -1404,6 +1547,7 @@
 	unregister_netdev(pegasus->net);
 	usb_put_dev(interface_to_usbdev(intf));
 	unlink_all_urbs(pegasus);
+	free_dma_structs(pegasus);
 	free_all_urbs(pegasus);
 	free_skb_pool(pegasus);
 	if (pegasus->rx_skb != NULL) {
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/usb/pegasus.h linux-2.6.23.1-stm/drivers/net/usb/pegasus.h
--- linux-2.6.23.1/drivers/net/usb/pegasus.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/usb/pegasus.h	2007-11-01 12:00:42.000000000 +0000
@@ -14,6 +14,7 @@
 
 #define	PEGASUS_MTU		1536
 #define	RX_SKBS			4
+#define	PEGASUS_INTR_SIZE	8
 
 #define	EPROM_WRITE		0x01
 #define	EPROM_READ		0x02
@@ -99,13 +100,13 @@
 	struct urb		*ctrl_urb, *rx_urb, *tx_urb, *intr_urb;
 	struct sk_buff		*rx_pool[RX_SKBS];
 	struct sk_buff		*rx_skb;
-	struct usb_ctrlrequest	dr;
+	struct usb_ctrlrequest	*dr;
 	wait_queue_head_t	ctrl_wait;
 	spinlock_t		rx_pool_lock;
 	int			chip;
-	unsigned char		intr_buff[8];
-	__u8			tx_buff[PEGASUS_MTU];
-	__u8			eth_regs[4];
+	unsigned char		*intr_buff;
+	__u8			*tx_buff;
+	__u8			*eth_regs;
 	__u8			phy;
 	__u8			gpio_res;
 } pegasus_t;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/usb/rtl8150.c linux-2.6.23.1-stm/drivers/net/usb/rtl8150.c
--- linux-2.6.23.1/drivers/net/usb/rtl8150.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/usb/rtl8150.c	2007-11-01 12:00:42.000000000 +0000
@@ -161,7 +161,7 @@
 	struct sk_buff *tx_skb, *rx_skb;
 	struct sk_buff *rx_skb_pool[RX_SKB_POOL_SIZE];
 	spinlock_t rx_pool_lock;
-	struct usb_ctrlrequest dr;
+	struct usb_ctrlrequest *dr;
 	int intr_interval;
 	__le16 rx_creg;
 	u8 *intr_buff;
@@ -197,16 +197,30 @@
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
+	char* local_data = kmalloc(size, GFP_KERNEL);
+	int result;
+	if (!local_data)
+		return -ENOMEM;
+	result = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
 			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
-			       indx, 0, data, size, 500);
+			       indx, 0, local_data, size, 500);
+	memcpy(data, local_data, size);
+	kfree(local_data);
+	return result;
 }
 
 static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
+	char* local_data = kmalloc(size, GFP_KERNEL);
+	int result;
+	if (!local_data)
+		return -ENOMEM;
+	memcpy(local_data, data, size);
+	result = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
 			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
-			       indx, 0, data, size, 500);
+			       indx, 0, local_data, size, 500);
+	kfree(local_data);
+	return result;
 }
 
 static void ctrl_callback(struct urb *urb)
@@ -234,14 +248,14 @@
 	if (test_bit(RX_REG_SET, &dev->flags))
 		return -EAGAIN;
 
-	dev->dr.bRequestType = RTL8150_REQT_WRITE;
-	dev->dr.bRequest = RTL8150_REQ_SET_REGS;
-	dev->dr.wValue = cpu_to_le16(indx);
-	dev->dr.wIndex = 0;
-	dev->dr.wLength = cpu_to_le16(size);
+	dev->dr->bRequestType = RTL8150_REQT_WRITE;
+	dev->dr->bRequest = RTL8150_REQ_SET_REGS;
+	dev->dr->wValue = cpu_to_le16(indx);
+	dev->dr->wIndex = 0;
+	dev->dr->wLength = cpu_to_le16(size);
 	dev->ctrl_urb->transfer_buffer_length = size;
 	usb_fill_control_urb(dev->ctrl_urb, dev->udev,
-			 usb_sndctrlpipe(dev->udev, 0), (char *) &dev->dr,
+			 usb_sndctrlpipe(dev->udev, 0), (char *) dev->dr,
 			 &dev->rx_creg, size, ctrl_callback, dev);
 	if ((ret = usb_submit_urb(dev->ctrl_urb, GFP_ATOMIC))) {
 		if (ret == -ENODEV)
@@ -913,6 +927,13 @@
 		return -ENOMEM;
 	}
 
+	dev->dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
+	if (!dev->dr) {
+		kfree(dev->intr_buff);
+		free_netdev(netdev);
+		return -ENOMEM;
+	}
+
 	tasklet_init(&dev->tl, rx_fixup, (unsigned long)dev);
 	spin_lock_init(&dev->rx_pool_lock);
 	
@@ -960,6 +981,7 @@
 out1:
 	free_all_urbs(dev);
 out:
+	kfree(dev->dr);
 	kfree(dev->intr_buff);
 	free_netdev(netdev);
 	return -EIO;
@@ -980,6 +1002,7 @@
 		free_skb_pool(dev);
 		if (dev->rx_skb)
 			dev_kfree_skb(dev->rx_skb);
+		kfree(dev->dr);
 		kfree(dev->intr_buff);
 		free_netdev(dev->netdev);
 	}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/Kconfig linux-2.6.23.1-stm/drivers/net/wireless/Kconfig
--- linux-2.6.23.1/drivers/net/wireless/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -561,5 +561,6 @@
 source "drivers/net/wireless/hostap/Kconfig"
 source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
+source "drivers/net/wireless/rt73/Kconfig"
 
 endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/Makefile linux-2.6.23.1-stm/drivers/net/wireless/Makefile
--- linux-2.6.23.1/drivers/net/wireless/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -37,6 +37,7 @@
 obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
+obj-$(CONFIG_STM_RT73_WIRELESS) += rt73/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/Kconfig linux-2.6.23.1-stm/drivers/net/wireless/rt73/Kconfig
--- linux-2.6.23.1/drivers/net/wireless/rt73/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,39 @@
+config STM_RT73_WIRELESS
+  tristate "STMicroelectronics rt73 wireless usb device"
+  depends on USB && (CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200) && MAC80211 && WLAN_80211
+	select FW_LOADER
+  default n
+ 	---help---
+	Say Y if you want to use one of the following Wirelles USB Ethernet
+	devices based on the rt2571w, rt2573 and rt2671 chips. Supported devices are:
+	* Asus WL-167G
+	* Belkin F5D7050EF
+	* Belkin F5D7050ES
+	* Conceptronic C54RU Ver2
+	* D-Link DWL-G122 H/W Ver.:C1
+	* Edimax EW7318UG
+	* Linksys WUSB54GC
+	* Sitecom WL-113
+	* Sitecom WL-172
+	* Surecom EP-9001-g
+	* PLanex GW-US54HP
+	* Digitus DN-7003GR VPR 1.0
+
+	This driver makes the adapter appear as a normal Ethernet interface,
+	typically on wlan0.
+
+	rt73 device requires external firmware to be loaded (rt73.bin).
+	This can be found as rpm starting from STLinux-2.3 release.
+
+	To enable debug, please, add the following in command line:
+	--------------
+	rt73wlan=debug:<level>, with level=1,2,4,8 to enable respectively ERROR, WARN,
+	TRACE and INFO debug.
+	--------------
+	Take care to have copied rt73.bin firmware file under /lib/firmware of your
+	filesystem before plugging dongle in usb port.
+	Please, plug dongles after kernel has booted, to avoid problems due to the
+	firmware lack at startup.
+	
+	To compile this driver as a module, choose M here: the module will be called 
+	rt73.ko.
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/Makefile linux-2.6.23.1-stm/drivers/net/wireless/rt73/Makefile
--- linux-2.6.23.1/drivers/net/wireless/rt73/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,8 @@
+obj-$(CONFIG_STM_RT73_WIRELESS) += rt73.o
+
+EXTRA_CFLAGS += -DAGGREGATION_SUPPORT -DWMM_SUPPORT -DDBG
+
+rt73-objs := rtmp_main.o mlme.o connect.o rtusb_bulk.o rtusb_io.o \
+      sync.o assoc.o auth.o auth_rsp.o rtusb_data.o \
+      rtmp_init.o  sanity.o rtmp_wep.o rtmp_info.o \
+      rtmp_tkip.o wpa.o md5.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/TESTING linux-2.6.23.1-stm/drivers/net/wireless/rt73/TESTING
--- linux-2.6.23.1/drivers/net/wireless/rt73/TESTING	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/TESTING	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,68 @@
+Below are the steps you need to follow to help out the team with
+testing/debugging of the rt73 kernel module:
+
+
+1. Get the latest source from the CVS tree.
+    Easiest way to do this is to download the hourly tarball from our
+    website: http://rt2x00.serialmonkey.com/rt73-cvs-daily.tar.gz
+    Alternatively, you can anonymously check out the current CVS code:
+
+cvs -d:pserver:anonymous@rt2400.cvs.sourceforge.net:/cvsroot/rt2400 login
+cvs -z3 -d:pserver:anonymous@rt2400.cvs.sourceforge.net:/cvsroot/rt2400 \
+co -P source/rt73
+
+2. Compile the module with debug logging:
+    $ make clean
+    $ make debug
+
+3. Ensure there are no copies of the module left in memory:
+    # ifconfig wlan0 down
+    # rmmod rt73
+
+4. Load the module with full debug enabled:
+    # insmod rt73.ko debug=31
+    Then proceed as usual (config, ifup, etc)...
+
+5. Check the debug output.
+    It is located in your system log file (most likely /var/log/debug
+    or /var/log/syslog). If you don't see any debug you probably need
+    to add the following line to your /etc/syslog.conf and reboot:
+
+       kern.=debug       /var/log/debug
+
+    If you system hard-locks before it's able to log anything
+    interesting in these files, you'll have to rely on the netconsole
+    module to remotely log your kernel messages to another box (see
+    netconsole.txt in your kernel sources Documentation folder).
+
+6. Report the following to the rt2400-devel mailing list (or rt73
+   forum):
+    * Steps to reproduce the bug
+    * The _whole_content_ of your debugging output
+    * Your module details, i.e. the output of:
+      # modinfo rt73.ko
+    * Your kernel details, i.e. the output of:
+      $ uname -a
+    * Your rt73 hardware manufacturer, model and revision
+    * Anything else you think may help us resolve the issue (even a
+      patch if you are so inclined)
+
+7. Monitor the mailing list (or forum thread) for replies/further
+   queries.  :-)
+
+Whenever we do major changes to the source - and always just before a
+release - we will call for testing to be done before we make the
+general release. You're very much welcome to help us with this testing
+and report any success/issue you experience with this code.
+
+
+!!!! NOTE !!!!
+
+AS PER STEP 6 ABOVE: Please provide the *whole* debug output! The last
+few lines are hardly any good.
+If it's large (which it will be) then GZip it. Either attach it to
+your forum post or, if you're going to report via the mailing list,
+upload it somewhere and give a link to it (or email it directly to the
+developer you are working with).
+
+!!!! END NOTE !!!!
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/assoc.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/assoc.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/assoc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/assoc.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1208 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	assoc.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *	John		2004-9-3	porting from RT2500
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+#include <net/iw_handler.h>
+
+
+
+UCHAR	CipherWpaTemplate[] = {
+		0xdd, 					// WPA IE
+		0x16,					// Length
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x02,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x01	// authentication
+		};
+UCHAR	CipherWpa2Template[] = {
+		0x30,					// RSN IE
+		0x14,					// Length
+		0x01, 0x00,				// Version
+		0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
+		0x01, 0x00,				// number of pairwise
+		0x00, 0x0f, 0xac, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x0f, 0xac, 0x02,	// authentication
+		0x00, 0x00,				// RSN capability
+		};
+UCHAR   CipherWpa2TemplateLen = (sizeof(CipherWpa2Template) / sizeof(UCHAR));
+
+/*
+    ==========================================================================
+    Description:
+        association state machine init, including state transition and timer init
+    Parameters:
+        S - pointer to the association state machine
+    Note:
+        The state machine looks like the following
+
+                               ASSOC_IDLE               ASSOC_WAIT_RSP             REASSOC_WAIT_RSP             DISASSOC_WAIT_RSP
+    MT2_MLME_ASSOC_REQ       mlme_assoc_req_action    invalid_state_when_assoc   invalid_state_when_assoc       invalid_state_when_assoc
+    MT2_MLME_REASSOC_REQ     mlme_reassoc_req_action  invalid_state_when_reassoc invalid_state_when_reassoc     invalid_state_when_reassoc
+    MT2_MLME_DISASSOC_REQ    mlme_disassoc_req_action mlme_disassoc_req_action   mlme_disassoc_req_action       mlme_disassoc_req_action
+    MT2_PEER_DISASSOC_REQ    peer_disassoc_action     peer_disassoc_action       peer_disassoc_action           peer_disassoc_action
+    MT2_PEER_ASSOC_REQ       drop                     drop                       drop                           drop
+    MT2_PEER_ASSOC_RSP       drop                     peer_assoc_rsp_action      drop                           drop
+    MT2_PEER_REASSOC_REQ     drop                     drop                       drop                           drop
+    MT2_PEER_REASSOC_RSP     drop                     drop                       peer_reassoc_rsp_action        drop
+    MT2_CLS3ERR              cls3err_action           cls3err_action             cls3err_action                 cls3err_action
+    MT2_ASSOC_TIMEOUT        timer_nop                assoc_timeout_action       timer_nop                      timer_nop
+    MT2_REASSOC_TIMEOUT      timer_nop                timer_nop                  reassoc_timeout_action         timer_nop
+    MT2_DISASSOC_TIMEOUT     timer_nop                timer_nop                  timer_nop                      disassoc_timeout_action
+    ==========================================================================
+ */
+VOID AssocStateMachineInit(
+    IN	PRTMP_ADAPTER	pAd,
+    IN  STATE_MACHINE *S,
+    OUT STATE_MACHINE_FUNC Trans[])
+{
+    StateMachineInit(S, (STATE_MACHINE_FUNC*)Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG, (STATE_MACHINE_FUNC)Drop, ASSOC_IDLE, ASSOC_MACHINE_BASE);
+
+    // first column
+    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)MlmeAssocReqAction);
+    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)MlmeReassocReqAction);
+    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)MlmeDisassocReqAction);
+    StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+
+    // second column
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
+    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT, (STATE_MACHINE_FUNC)AssocTimeoutAction);
+
+    // third column
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
+    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT, (STATE_MACHINE_FUNC)ReassocTimeoutAction);
+
+    // fourth column
+    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT, (STATE_MACHINE_FUNC)DisassocTimeoutAction);
+
+    // timer init
+    RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer, &AssocTimeout);
+    RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer, &ReassocTimeout);
+    RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer, &DisassocTimeout);
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        Association timeout procedure. After association timeout, this function
+        will be called and it will put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+    ==========================================================================
+ */
+VOID AssocTimeout(
+    IN	unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_ASSOC_TIMEOUT \n");
+    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Reassociation timeout procedure. After reassociation timeout, this
+        function will be called and put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+    ==========================================================================
+ */
+VOID ReassocTimeout(
+    IN	unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_REASSOC_TIMEOUT \n");
+    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Disassociation timeout procedure. After disassociation timeout, this
+        function will be called and put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+    ==========================================================================
+ */
+VOID DisassocTimeout(
+    IN	unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_DISASSOC_TIMEOUT \n");
+    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+	==========================================================================
+	Description:
+		mlme assoc req handling procedure
+	Parameters:
+		Adapter - Adapter pointer
+		Elem - MLME Queue Element
+	Pre:
+		the station has been authenticated and the following information is stored in the config
+			-# SSID
+			-# supported rates and their length
+			-# listen interval (Adapter->PortCfg.default_listen_count)
+			-# Transmit power  (Adapter->PortCfg.tx_power)
+	Post  :
+		-# An association request frame is generated and sent to the air
+		-# Association timer starts
+		-# Association state -> ASSOC_WAIT_RSP
+
+	==========================================================================
+ */
+VOID MlmeAssocReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	UCHAR			 ApAddr[6];
+	HEADER_802_11	 AssocHdr;
+	UCHAR			 WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
+	UCHAR			 CipherTmp[64];
+	UCHAR			 CipherTmpLen;
+	USHORT			 ListenIntv;
+	ULONG			 Timeout;
+	USHORT			 CapabilityInfo;
+	PUCHAR			 pOutBuffer = NULL;
+	ULONG			 FrameLen = 0;
+	ULONG			 tmp;
+	UCHAR			 VarIesOffset;
+	USHORT			 Status;
+	ULONG			 idx;
+	BOOLEAN			 FoundPMK = FALSE;
+	USHORT			 NStatus;
+
+	// Block all authentication request durning WPA block period
+	if (pAd->PortCfg.bBlockAssoc == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block Assoc request durning WPA block period!\n");
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		Status = MLME_STATE_MACHINE_REJECT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+	}
+	// check sanity first
+	else if (MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
+	{
+		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
+		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+
+		// allocate and send out AssocRsp frame
+		NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() allocate memory failed \n");
+			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+			Status = MLME_FAIL_NO_RESOURCE;
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+			return;
+		}
+
+		// Add by James 03/06/27
+		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+		// Association don't need to report MAC address
+		pAd->PortCfg.AssocInfo.AvailableRequestFixedIEs =
+			NDIS_802_11_AI_REQFI_CAPABILITIES | NDIS_802_11_AI_REQFI_LISTENINTERVAL;
+		pAd->PortCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
+		pAd->PortCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;
+		// Only reassociate need this
+		//COPY_MAC_ADDR(pAd->PortCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr);
+		pAd->PortCfg.AssocInfo.OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+
+		// First add SSID
+		VarIesOffset = 0;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SsidLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+		VarIesOffset += pAd->MlmeAux.SsidLen;
+
+		// Second add Supported rates
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SupRateIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SupRateLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
+		VarIesOffset += pAd->MlmeAux.SupRateLen;
+		// End Add by James
+
+		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send ASSOC request...\n");
+		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr, ApAddr);
+
+		// Build basic frame first
+		MakeOutgoingFrame(pOutBuffer,				&FrameLen,
+						  sizeof(HEADER_802_11),	&AssocHdr,
+						  2,						&CapabilityInfo,
+						  2,						&ListenIntv,
+						  1,						&SsidIe,
+						  1,						&pAd->MlmeAux.SsidLen,
+						  pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid,
+						  1,						&SupRateIe,
+						  1,						&pAd->MlmeAux.SupRateLen,
+						  pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
+						  END_OF_ARGS);
+
+		if (pAd->MlmeAux.ExtRateLen != 0)
+		{
+			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+							  1,						&ExtRateIe,
+							  1,						&pAd->MlmeAux.ExtRateLen,
+							  pAd->MlmeAux.ExtRateLen,	pAd->MlmeAux.ExtRate,
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+
+		if (pAd->MlmeAux.APEdcaParm.bValid)
+		{
+			WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+							  9,						&WmeIe[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+
+
+		// For WPA / WPA-PSK
+		if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+			(pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+		{
+			// Copy WPA template to buffer
+			CipherTmpLen = sizeof(CipherWpaTemplate);
+			memcpy(CipherTmp, CipherWpaTemplate, CipherTmpLen);
+			// Modify Group cipher
+			CipherTmp[11] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify Pairwise cipher
+			CipherTmp[17] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify AKM
+			CipherTmp[23] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
+			// Make outgoing frame
+			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+							  CipherTmpLen,				&CipherTmp[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+
+			// Append Variable IE
+			memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+			VarIesOffset += CipherTmpLen;
+
+			// Set Variable IEs Length
+			pAd->PortCfg.ReqVarIELen = VarIesOffset;
+			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+			// OffsetResponseIEs follow ReqVarIE
+			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;
+		}
+		// For WPA2 / WPA2-PSK
+		else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+				 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+		{
+			// Copy WPA2 template to buffer
+			CipherTmpLen = sizeof(CipherWpa2Template);
+			memcpy(CipherTmp, CipherWpa2Template, CipherTmpLen);
+			// Modify Group cipher
+			CipherTmp[7] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify Pairwise cipher
+			CipherTmp[13] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify AKM
+			CipherTmp[19] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
+			// Check for WPA PMK cache list
+			if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)
+			{
+				// Search chched PMKID, append it if existed
+				for (idx = 0; idx < PMKID_NO; idx++)
+				{
+					if (NdisEqualMemory(ApAddr, &pAd->PortCfg.SavedPMK[idx].BSSID, 6))
+					{
+						FoundPMK = TRUE;
+						break;
+					}
+				}
+
+				if (FoundPMK)
+				{
+					// Update length within RSN IE
+					CipherTmp[1] += 18;
+					// Set PMK number
+					*(PUSHORT) &CipherTmp[CipherTmpLen] = 1;
+					memcpy(&CipherTmp[CipherTmpLen + 2], &pAd->PortCfg.SavedPMK[idx].PMKID, 16);
+					CipherTmpLen += 18;
+				}
+			}
+
+			// Make outgoing frame
+			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+							  CipherTmpLen,				&CipherTmp[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+
+			// Append Variable IE
+			memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+			VarIesOffset += CipherTmpLen;
+
+			// Set Variable IEs Length
+			pAd->PortCfg.ReqVarIELen = VarIesOffset;
+			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+			// OffsetResponseIEs follow ReqVarIE
+			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;
+		}
+		else
+		{
+			// Do nothing
+			;
+		}
+#if 0 //AGGREGATION_SUPPORT
+		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
+		// 1. user enable aggregation, AND
+		// 2. AP annouces it's AGGREGATION-capable in BEACON
+		if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
+		{
+			ULONG TmpLen;
+			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00};
+			MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
+							  9,							 RalinkIe,
+							  END_OF_ARGS);
+			FrameLen += TmpLen;
+		}
+#endif
+
+		MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+		RTMPSetTimer(pAd, &pAd->MlmeAux.AssocTimer, Timeout);
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n");
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		Status = MLME_INVALID_FORMAT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+	}
+
+}
+
+/*
+	==========================================================================
+	Description:
+		mlme reassoc req handling procedure
+	Parameters:
+		Elem -
+	Pre:
+		-# SSID  (Adapter->PortCfg.ssid[])
+		-# BSSID (AP address, Adapter->PortCfg.bssid)
+		-# Supported rates (Adapter->PortCfg.supported_rates[])
+		-# Supported rates length (Adapter->PortCfg.supported_rates_len)
+		-# Tx power (Adapter->PortCfg.tx_power)
+
+	==========================================================================
+ */
+VOID MlmeReassocReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	UCHAR			ApAddr[6];
+	HEADER_802_11	ReassocHdr;
+	UCHAR			WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
+	USHORT			CapabilityInfo, ListenIntv;
+	ULONG			Timeout;
+	ULONG			FrameLen = 0;
+	ULONG			tmp;
+	PUCHAR			pOutBuffer = NULL;
+	USHORT			Status;
+	USHORT			NStatus;
+
+	// Block all authentication request durning WPA block period
+	if (pAd->PortCfg.bBlockAssoc == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block ReAssoc request durning WPA block period!\n");
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		Status = MLME_STATE_MACHINE_REJECT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+	}
+	// the parameters are the same as the association
+	else if(MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
+	{
+		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
+
+		// allocate and send out ReassocReq frame
+		NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() allocate memory failed \n");
+			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+			Status = MLME_FAIL_NO_RESOURCE;
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+			return;
+		}
+
+		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+
+		// make frame, use bssid as the AP address??
+		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send RE-ASSOC request...\n");
+		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0, ApAddr, ApAddr);
+		MakeOutgoingFrame(pOutBuffer,				&FrameLen,
+						  sizeof(HEADER_802_11),	&ReassocHdr,
+						  2,						&CapabilityInfo,
+						  2,						&ListenIntv,
+						  MAC_ADDR_LEN, 			ApAddr,
+						  1,						&SsidIe,
+						  1,						&pAd->MlmeAux.SsidLen,
+						  pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid,
+						  1,						&SupRateIe,
+						  1,						&pAd->MlmeAux.SupRateLen,
+						  pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
+						  END_OF_ARGS);
+
+		if (pAd->MlmeAux.ExtRateLen != 0)
+		{
+			MakeOutgoingFrame(pOutBuffer + FrameLen,		&tmp,
+							  1,							&ExtRateIe,
+							  1,							&pAd->MlmeAux.ExtRateLen,
+							  pAd->MlmeAux.ExtRateLen,		pAd->MlmeAux.ExtRate,
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+
+		if (pAd->MlmeAux.APEdcaParm.bValid)
+		{
+			WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+							  9,						&WmeIe[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+#if 0 //AGGREGATION_SUPPORT
+		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
+		// 1. user enable aggregation, AND
+		// 2. AP annouces it's AGGREGATION-capable in BEACON
+		if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
+		{
+			ULONG TmpLen;
+			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00};
+			MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
+							  9,							 RalinkIe,
+							  END_OF_ARGS);
+			FrameLen += TmpLen;
+		}
+#endif
+		MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+		RTMPSetTimer(pAd, &pAd->MlmeAux.ReassocTimer, Timeout);
+		pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n");
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		Status = MLME_INVALID_FORMAT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        Upper layer issues disassoc request
+    Parameters:
+        Elem -
+    ==========================================================================
+ */
+VOID MlmeDisassocReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    PMLME_DISASSOC_REQ_STRUCT pDisassocReq;
+    HEADER_802_11         DisassocHdr;
+    PCHAR                 pOutBuffer = NULL;
+    ULONG                 FrameLen = 0;
+    ULONG                 Timeout = 0;
+    USHORT                Status;
+    USHORT                NStatus;
+#if WPA_SUPPLICANT_SUPPORT
+    union iwreq_data      wrqu;
+#endif
+
+    // skip sanity check
+    pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT)(Elem->Msg);
+
+    // allocate and send out DeassocReq frame
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - MlmeDisassocReqAction() allocate memory failed\n");
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+        Status = MLME_FAIL_NO_RESOURCE;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+        return;
+    }
+
+    RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
+
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send DISASSOC request\n");
+    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);
+    MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+                      sizeof(HEADER_802_11),&DisassocHdr,
+                      2,                    &pDisassocReq->Reason,
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+	// Set the control aux SSID to prevent it reconnect to old SSID
+	// Since calling this indicate user don't want to connect to that SSID anymore.
+	// 2004-11-10 can't reset this info, cause it may be the new SSID that user requests for
+	// pAd->MlmeAux.SsidLen = MAX_LEN_OF_SSID;
+	// NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+    // NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+
+#if WPA_SUPPLICANT_SUPPORT
+    if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+        //send disassociate event to wpa_supplicant
+        memset(&wrqu, 0, sizeof(wrqu));
+        wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
+        wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+    }
+#endif
+
+    pAd->PortCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
+    COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pDisassocReq->Addr);
+
+    RTMPSetTimer(pAd, &pAd->MlmeAux.DisassocTimer, Timeout);
+
+    pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
+}
+
+#if WPA_SUPPLICANT_SUPPORT
+#ifdef DBG
+static void _rtmp_hexdump(int level, const char *title, const u8 *buf,
+			 size_t len, int show)
+{
+	size_t i;
+	if (level & RTDebugLevel) {
+		printk("%s - hexdump(len=%lu):", title, (unsigned long) len);
+		if (show) {
+			for (i = 0; i < len; i++)
+				printk(" %02x", buf[i]);
+		} else {
+			printk(" [REMOVED]");
+		}
+		printk("\n");
+	}
+}
+
+void rtmp_hexdump(int level, const char *title, const u8 *buf, size_t len)
+{
+	_rtmp_hexdump(level, title, buf, len, 1);
+}
+#endif
+
+NDIS_STATUS miniport_query_info(
+     IN PRTMP_ADAPTER pAd,
+     IN USHORT oid,
+     OUT void *buf,
+     OUT ULONG bufsize)
+{
+    // First add AssocInfo
+	memcpy(buf, &pAd->PortCfg.AssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	// Second add ReqVarIEs
+	memcpy(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION), pAd->PortCfg.ReqVarIEs, pAd->PortCfg.ReqVarIELen);
+	// Third add ResVarIEs
+	memcpy(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen, pAd->PortCfg.ResVarIEs, pAd->PortCfg.ResVarIELen);
+
+	return 0;
+}
+
+VOID link_status_handler(
+    IN PRTMP_ADAPTER pAd)
+{
+	NDIS_802_11_ASSOCIATION_INFORMATION *ndis_assoc_info;
+
+	unsigned char *wpa_assoc_info_req, *wpa_assoc_info_resp, *ies;
+	unsigned char *p;
+	int i;
+	unsigned char *assoc_info;
+	union iwreq_data wrqu;
+	NDIS_STATUS res;
+
+	const int assoc_size = sizeof(*ndis_assoc_info) + IW_CUSTOM_MAX;
+	assoc_info = kmalloc(assoc_size, MEM_ALLOC_FLAG);
+	if (!assoc_info) {
+              DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+		return;
+	}
+	memset(assoc_info, 0, assoc_size);
+	ndis_assoc_info = (NDIS_802_11_ASSOCIATION_INFORMATION *)assoc_info;
+
+	res = miniport_query_info(pAd, OID_802_11_ASSOCIATION_INFORMATION,
+				  assoc_info, assoc_size);
+	if (res) {
+		DBGPRINT(RT_DEBUG_TRACE, "query assoc_info failed\n");
+		if(assoc_info != NULL){
+			kfree(assoc_info);
+		}
+		return;
+	}
+
+	/*
+	 * TODO: backwards compatibility would require that IWEVCUSTOM
+	 * is sent even if WIRELESS_EXT > 17. This version does not do
+	 * this in order to allow wpa_supplicant to be tested with
+	 * WE-18.
+	 */
+
+#ifdef DBG
+	rtmp_hexdump(RT_DEBUG_TRACE, "ASSOCINFO", (const u8 *) ndis_assoc_info,
+		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+#endif
+
+    wpa_assoc_info_req = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+	if (!wpa_assoc_info_req) {
+		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+		//kfree(wpa_assoc_info_req);//Thomas
+		return;
+	}
+
+    //send ReqIEs
+    memset(wpa_assoc_info_req, 0, IW_CUSTOM_MAX);
+	p = wpa_assoc_info_req;
+	p += sprintf(p, "ASSOCINFO(ReqIEs=");
+	ies = ((char *)ndis_assoc_info) +
+		ndis_assoc_info->OffsetRequestIEs;
+	for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
+		p += sprintf(p, "%02x", ies[i]);
+
+	memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = p - wpa_assoc_info_req;
+	wrqu.data.flags = RT_REQIE_EVENT_FLAG;
+	DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);
+	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_req);
+
+    wpa_assoc_info_resp = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+	if (!wpa_assoc_info_resp) {
+		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+		//kfree(wpa_assoc_info_resp); //Thomas
+		return;
+	}
+
+    //send RespIEs
+	memset(wpa_assoc_info_resp, 0, IW_CUSTOM_MAX);
+	p = wpa_assoc_info_resp;
+	p += sprintf(p, " RespIEs=");
+	ies = ((char *)ndis_assoc_info) +
+		ndis_assoc_info->OffsetResponseIEs;
+	for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
+		p += sprintf(p, "%02x", ies[i]);
+	p += sprintf(p, ")");
+
+    memset(&wrqu, 0, sizeof(wrqu));
+	wrqu.data.length = p - wpa_assoc_info_resp;
+	wrqu.data.flags = RT_RESPIE_EVENT_FLAG;
+	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_resp);
+
+        memset(&wrqu, 0, sizeof(wrqu));
+        wrqu.data.flags = RT_ASSOCINFO_EVENT_FLAG;
+        wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+
+#if 0
+	/* we need 28 extra bytes for the format strings */
+	if ((ndis_assoc_info->RequestIELength +
+	     ndis_assoc_info->ResponseIELength + 28) > IW_CUSTOM_MAX) {
+		//WARNING("information element is too long! (%u,%u),"
+		//	"association information dropped",
+		//	ndis_assoc_info->RequestIELength,
+		//	ndis_assoc_info->ResponseIELength);
+		DBGPRINT(RT_DEBUG_TRACE, "information element is too long! "
+			"association information dropped\n");
+		kfree(assoc_info);
+		return;
+	}
+
+	wpa_assoc_info = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+	if (!wpa_assoc_info) {
+		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+		kfree(assoc_info);
+		return;
+	}
+	p = wpa_assoc_info;
+	p += sprintf(p, "ASSOCINFO(ReqIEs=");
+	ies = ((char *)ndis_assoc_info) +
+		ndis_assoc_info->OffsetRequestIEs;
+	for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
+		p += sprintf(p, "%02x", ies[i]);
+
+
+	p += sprintf(p, " RespIEs=");
+	ies = ((char *)ndis_assoc_info) +
+		ndis_assoc_info->OffsetResponseIEs;
+	for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
+		p += sprintf(p, "%02x", ies[i]);
+
+	p += sprintf(p, ")");
+
+	memset(&wrqu, 0, sizeof(wrqu));
+	wrqu.data.length = p - wpa_assoc_info;
+	//DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);
+	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info);
+
+	kfree(wpa_assoc_info);
+#endif
+	if(wpa_assoc_info_req != NULL){
+		kfree(wpa_assoc_info_req);
+	}
+	if(wpa_assoc_info_resp != NULL){
+		kfree(wpa_assoc_info_resp);
+	}
+	if(assoc_info != NULL){
+		kfree(assoc_info);
+	}
+
+
+	return;
+}
+#endif
+
+/*
+    ==========================================================================
+    Description:
+        peer sends assoc rsp back
+    Parameters:
+        Elme - MLME message containing the received frame
+    ==========================================================================
+ */
+VOID PeerAssocRspAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT        CapabilityInfo, Status, Aid;
+    UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+    UCHAR         ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+    UCHAR         Addr2[MAC_ADDR_LEN];
+	EDCA_PARM     EdcaParm;
+
+#if WPA_SUPPLICANT_SUPPORT
+    union iwreq_data wrqu;
+#endif
+
+    if (PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm))
+    {
+        // The frame is for me ?
+        if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status);
+            RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
+            if(Status == MLME_SUCCESS)
+            {
+                //
+				// There may some packets will be drop, if we haven't set the BSS type!
+				// For example: EAPOL packet and the case of WHQL lost Packets.
+				// Since this may some delays to set those variables at LinkUp(..) on this (Mlme) thread.
+				//
+				// This is a trick, set the BSS type here.
+				//
+				if (pAd->PortCfg.BssType == BSS_INFRA)
+				{
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+				}
+
+
+                // go to procedure listed on page 376
+                AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);
+
+#if WPA_SUPPLICANT_SUPPORT
+                if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+                    // collect associate info
+                    link_status_handler(pAd);
+                    //send associnfo event to wpa_supplicant
+                    memset(&wrqu, 0, sizeof(wrqu));
+                    wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
+                    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+                }
+#endif
+
+            }
+
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerAssocRspAction() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        peer sends reassoc rsp
+    Parametrs:
+        Elem - MLME message cntaining the received frame
+    ==========================================================================
+ */
+VOID PeerReassocRspAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT      CapabilityInfo;
+    USHORT      Status;
+    USHORT      Aid;
+    UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+    UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+    UCHAR       Addr2[MAC_ADDR_LEN];
+    EDCA_PARM   EdcaParm;
+
+#if WPA_SUPPLICANT_SUPPORT
+    union iwreq_data wrqu;
+#endif
+
+    if(PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm))
+    {
+        if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) // The frame is for me ?
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
+            RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
+
+            if(Status == MLME_SUCCESS)
+            {
+                // go to procedure listed on page 376
+                AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);
+
+#if WPA_SUPPLICANT_SUPPORT
+                if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+                    //collect associate info
+                    link_status_handler(pAd);
+                    //send associnfo event to wpa_supplicant
+                    memset(&wrqu, 0, sizeof(wrqu));
+                    wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
+                    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+                }
+		        DBGPRINT(RT_DEBUG_OFF, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
+#endif
+
+            }
+
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerReassocRspAction() sanity check fail\n");
+    }
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        procedures on IEEE 802.11/1999 p.376
+    Parametrs:
+    ==========================================================================
+ */
+VOID AssocPostProc(
+    IN PRTMP_ADAPTER pAd,
+    IN PUCHAR pAddr2,
+    IN USHORT CapabilityInfo,
+    IN USHORT Aid,
+    IN UCHAR SupRate[],
+    IN UCHAR SupRateLen,
+    IN UCHAR ExtRate[],
+    IN UCHAR ExtRateLen,
+    IN PEDCA_PARM pEdcaParm)
+{
+	ULONG Idx;
+	UCHAR VarIesOffset;
+
+    pAd->MlmeAux.BssType = BSS_INFRA;
+    COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
+    pAd->MlmeAux.Aid = Aid;
+    pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+    memcpy(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+
+    // filter out un-supported rates
+    pAd->MlmeAux.SupRateLen = SupRateLen;
+    memcpy(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
+    RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+
+    // filter out un-supported rates
+    pAd->MlmeAux.ExtRateLen = ExtRateLen;
+    memcpy(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
+    RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+
+	// Set New WPA information
+	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
+	if (Idx == BSS_NOT_FOUND)
+	{
+		DBGPRINT_ERR("ASSOC - Can't find BSS after receiving Assoc response\n");
+	}
+	else
+	{
+		// Mod by James to fix OID_802_11_ASSOCIATION_INFORMATION
+		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); //+ sizeof(NDIS_802_11_FIXED_IEs); 	// Filled in assoc request
+		pAd->PortCfg.AssocInfo.AvailableResponseFixedIEs =
+			NDIS_802_11_AI_RESFI_CAPABILITIES | NDIS_802_11_AI_RESFI_STATUSCODE | NDIS_802_11_AI_RESFI_ASSOCIATIONID;
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.Capabilities  = CapabilityInfo;
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.StatusCode    = MLME_SUCCESS;		// Should be success, add failed later
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.AssociationId = Aid;
+
+		// Copy BSS VarIEs to PortCfg associnfo structure.
+		// First add Supported rates
+		VarIesOffset = 0;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, SupRate, SupRateLen);
+		VarIesOffset += SupRateLen;
+//		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateIe, 1);
+//		VarIesOffset += 1;
+//		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateLen, 1);
+//		VarIesOffset += 1;
+//		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, ExtRate, ExtRateLen);
+//		VarIesOffset += ExtRateLen;
+
+		// Second add RSN
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, pAd->ScanTab.BssEntry[Idx].VarIEs, pAd->ScanTab.BssEntry[Idx].VarIELen);
+		VarIesOffset += pAd->ScanTab.BssEntry[Idx].VarIELen;
+
+		// Set Variable IEs Length
+		pAd->PortCfg.ResVarIELen = VarIesOffset;
+		pAd->PortCfg.AssocInfo.ResponseIELength = VarIesOffset;
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        left part of IEEE 802.11/1999 p.374
+    Parameters:
+        Elem - MLME message containing the received frame
+    ==========================================================================
+ */
+VOID PeerDisassocAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR         Addr2[MAC_ADDR_LEN];
+    USHORT        Reason;
+
+#if WPA_SUPPLICANT_SUPPORT
+    union iwreq_data wrqu;
+#endif
+
+    if(PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
+    {
+        if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(pAd->PortCfg.Bssid, Addr2))
+        {
+            LinkDown(pAd, TRUE);
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+
+#if WPA_SUPPLICANT_SUPPORT
+            if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+                // send disassoc event to wpa_supplicant
+                memset(&wrqu, 0, sizeof(wrqu));
+                wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
+                wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+            }
+#endif
+
+#if 0
+            // 2004-09-11 john: can't remember why AP will DISASSOCIATE us.
+            //   But since it says for 2430 only, we temporaily remove the patch.
+            // 2002/11/21 -
+            //   patch RT2430/RT2420 hangup issue. We suspect this AP DIS-ASSOCIATE frame
+            //   is caused by PHY hangup, so we reset PHY, then auto recover the connection.
+            //   if this attempt fails, then remains in LinkDown and leaves the problem
+            //   to MlmePeriodicExec()
+            // NICPatchRT2430Bug(pAd);
+            pAd->RalinkCounters.BeenDisassociatedCount ++;
+			// Remove auto recover effort when disassociate by AP, re-enable for patch 2430 only
+            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Disassociated by AP, Auto Recovery attempt #%d\n", pAd->RalinkCounters.BeenDisassociatedCount);
+            MlmeAutoReconnectLastSSID(pAd);
+#endif
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerDisassocAction() sanity check fail\n");
+    }
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after assoc timeout
+    ==========================================================================
+ */
+VOID AssocTimeoutAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - AssocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_REJ_TIMEOUT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after reassoc timeout
+    ==========================================================================
+ */
+VOID ReassocTimeoutAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - ReassocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_REJ_TIMEOUT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after disassoc timeout
+    ==========================================================================
+ */
+VOID DisassocTimeoutAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - DisassocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_SUCCESS;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+}
+
+VOID InvalidStateWhenAssoc(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenAssoc(state=%d), reset ASSOC state machine\n",
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+}
+
+VOID InvalidStateWhenReassoc(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenReassoc(state=%d), reset ASSOC state machine\n",
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+}
+
+VOID InvalidStateWhenDisassociate(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenDisassoc(state=%d), reset ASSOC state machine\n",
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+        right part of IEEE 802.11/1999 page 374
+    Note:
+        This event should never cause ASSOC state machine perform state
+        transition, and has no relationship with CNTL machine. So we separate
+        this routine as a service outside of ASSOC state transition table.
+    ==========================================================================
+ */
+VOID Cls3errAction(
+    IN PRTMP_ADAPTER pAd,
+    IN PUCHAR      pAddr)
+{
+    HEADER_802_11       DisassocHdr;
+    PCHAR               pOutBuffer = NULL;
+    ULONG               FrameLen = 0;
+    USHORT              Reason = REASON_CLS3ERR;
+    USHORT              NStatus;
+
+    // allocate memory
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;
+
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Class 3 Error, Send DISASSOC frame\n");
+
+    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->PortCfg.Bssid);
+    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                      sizeof(HEADER_802_11),    &DisassocHdr,
+                      2,                        &Reason,
+                      END_OF_ARGS);
+
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+    pAd->PortCfg.DisassocReason = REASON_CLS3ERR;
+    COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pAddr);
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/auth.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/auth.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/auth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/auth.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,420 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	auth.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *	John		2004-9-3	porting from RT2500
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/*
+    ==========================================================================
+    Description:
+        authenticate state machine init, including state transition and timer init
+    Parameters:
+        Sm - pointer to the auth state machine
+    Note:
+        The state machine looks like this
+
+                        AUTH_REQ_IDLE           AUTH_WAIT_SEQ2                   AUTH_WAIT_SEQ4
+    MT2_MLME_AUTH_REQ   mlme_auth_req_action    invalid_state_when_auth          invalid_state_when_auth
+    MT2_MLME_DEAUTH_REQ mlme_deauth_req_action  mlme_deauth_req_action           mlme_deauth_req_action
+    MT2_CLS2ERR         cls2err_action          cls2err_action                   cls2err_action
+    MT2_PEER_AUTH_EVEN  drop                    peer_auth_even_at_seq2_action    peer_auth_even_at_seq4_action
+    MT2_AUTH_TIMEOUT    Drop                    auth_timeout_action              auth_timeout_action
+    ==========================================================================
+ */
+
+VOID AuthStateMachineInit(
+    IN PRTMP_ADAPTER pAd,
+    IN PSTATE_MACHINE Sm,
+    OUT STATE_MACHINE_FUNC Trans[])
+{
+    StateMachineInit(Sm, (STATE_MACHINE_FUNC*)Trans, MAX_AUTH_STATE, MAX_AUTH_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_REQ_IDLE, AUTH_MACHINE_BASE);
+
+    // the first column
+    StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)MlmeAuthReqAction);
+
+    // the second column
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq2Action);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
+
+    // the third column
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq4Action);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
+
+    // timer init
+    RTMPInitTimer(pAd, &pAd->MlmeAux.AuthTimer, &AuthTimeout);
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        function to be executed at timer thread when auth timer expires
+    ==========================================================================
+ */
+VOID AuthTimeout(
+    IN	unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+
+    DBGPRINT(RT_DEBUG_TRACE,"AUTH - AuthTimeout\n");
+    MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_AUTH_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID MlmeAuthReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR               Addr[MAC_ADDR_LEN];
+    USHORT              Alg, Seq, Status;
+    ULONG               Timeout;
+    HEADER_802_11       AuthHdr;
+    PUCHAR              pOutBuffer = NULL;
+    ULONG               FrameLen = 0;
+    USHORT              NStatus;
+
+    // Block all authentication request durning WPA block period
+    if (pAd->PortCfg.bBlockAssoc == TRUE)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - Block Auth request durning WPA block period!\n");
+        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+        Status = MLME_STATE_MACHINE_REJECT;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+    }
+    else if(MlmeAuthReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr, &Timeout, &Alg))
+    {
+	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+
+        COPY_MAC_ADDR(pAd->MlmeAux.Bssid, Addr);
+        pAd->MlmeAux.Alg  = Alg;
+
+        Seq = 1;
+        Status = MLME_SUCCESS;
+
+        // allocate and send out AuthReq frame
+        NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+        if (NStatus != NDIS_STATUS_SUCCESS)
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "AUTH - MlmeAuthReqAction() allocate memory failed\n");
+            pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+            Status = MLME_FAIL_NO_RESOURCE;
+            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+	        return;
+        }
+
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - Send AUTH request seq#1 (Alg=%d)  %d...\n", Alg, pAd->LatchRfRegs.Channel);
+        MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr, pAd->MlmeAux.Bssid);
+
+        MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+                          sizeof(HEADER_802_11),&AuthHdr,
+                          2,                    &Alg,
+                          2,                    &Seq,
+                          2,                    &Status,
+                          END_OF_ARGS);
+
+        MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+        RTMPSetTimer(pAd, &pAd->MlmeAux.AuthTimer, AUTH_TIMEOUT);
+
+        pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "AUTH - MlmeAuthReqAction() sanity check failed. BUG!!!!!\n");
+        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+        Status = MLME_INVALID_FORMAT;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID PeerAuthRspAtSeq2Action(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR           Addr2[MAC_ADDR_LEN];
+    USHORT          Seq, Status, RemoteStatus, Alg;
+    UCHAR           ChlgText[CIPHER_TEXT_LEN];
+    UCHAR           CyperChlgText[CIPHER_TEXT_LEN + 8 + 8];
+    UCHAR           Element[2];
+    HEADER_802_11   AuthHdr;
+    PUCHAR          pOutBuffer = NULL;
+    ULONG           FrameLen = 0;
+    USHORT          Status2;
+    USHORT          NStatus;
+
+    if (PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status, ChlgText))
+    {
+        if (MAC_ADDR_EQUAL(&pAd->MlmeAux.Bssid, Addr2) && Seq == 2)
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "AUTH - Receive AUTH_RSP seq#2 to me (Alg=%d, Status=%d)\n", Alg, Status);
+		    RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+
+            if (Status == MLME_SUCCESS)
+            {
+                if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen)
+                {
+                    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+                }
+                else
+                {
+                    // 2. shared key, need to be challenged
+                    Seq++;
+                    RemoteStatus = MLME_SUCCESS;
+                    // allocate and send out AuthRsp frame
+                    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+                    if (NStatus != NDIS_STATUS_SUCCESS)
+                    {
+                        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthRspAtSeq2Action() allocate memory fail\n");
+                        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                        Status2 = MLME_FAIL_NO_RESOURCE;
+                        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status2);
+                        return;
+                    }
+
+                    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Send AUTH request seq#3...\n");
+                    MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr2, pAd->MlmeAux.Bssid);
+                    AuthHdr.FC.Wep = 1;
+                    // Encrypt challenge text & auth information
+                    RTMPInitWepEngine(
+                    	pAd,
+                    	pAd->SharedKey[pAd->PortCfg.DefaultKeyId].Key,
+                    	pAd->PortCfg.DefaultKeyId,
+                    	pAd->SharedKey[pAd->PortCfg.DefaultKeyId].KeyLen,
+                    	CyperChlgText);
+#ifdef BIG_ENDIAN
+                    Alg = SWAP16(*(USHORT *)&Alg);
+                    Seq = SWAP16(*(USHORT *)&Seq);
+                    RemoteStatus= SWAP16(*(USHORT *)&RemoteStatus);
+#endif
+                    RTMPEncryptData(pAd, (PUCHAR) &Alg, CyperChlgText + 4, 2);
+                    RTMPEncryptData(pAd, (PUCHAR) &Seq, CyperChlgText + 6, 2);
+                    RTMPEncryptData(pAd, (PUCHAR) &RemoteStatus, CyperChlgText + 8, 2);
+
+                    Element[0] = 16;
+                    Element[1] = 128;
+                    RTMPEncryptData(pAd, Element, CyperChlgText + 10, 2);
+                    RTMPEncryptData(pAd, ChlgText, CyperChlgText + 12, 128);
+                    RTMPSetICV(pAd, CyperChlgText + 140);
+
+                    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                                      sizeof(HEADER_802_11),    &AuthHdr,
+                                      CIPHER_TEXT_LEN + 16,     CyperChlgText,
+                                      END_OF_ARGS);
+
+                    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+                    RTMPSetTimer(pAd, &pAd->MlmeAux.AuthTimer, AUTH_TIMEOUT);
+                    pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ4;
+                }
+            }
+            else
+            {
+                pAd->PortCfg.AuthFailReason = Status;
+                COPY_MAC_ADDR(pAd->PortCfg.AuthFailSta, Addr2);
+                pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+            }
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthSanity() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID PeerAuthRspAtSeq4Action(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR       Addr2[MAC_ADDR_LEN];
+    USHORT      Alg, Seq, Status;
+    CHAR        ChlgText[CIPHER_TEXT_LEN];
+
+    if(PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status, ChlgText))
+    {
+        if(MAC_ADDR_EQUAL(&(pAd->MlmeAux.Bssid), Addr2) && Seq == 4)
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "AUTH - Receive AUTH_RSP seq#4 to me\n");
+            RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+
+            if(Status != MLME_SUCCESS)
+            {
+                pAd->PortCfg.AuthFailReason = Status;
+                COPY_MAC_ADDR(pAd->PortCfg.AuthFailSta, Addr2);
+            }
+
+            pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthRspAtSeq4Action() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID MlmeDeauthReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    MLME_DEAUTH_REQ_STRUCT      *pInfo;
+    HEADER_802_11               DeauthHdr;
+    PUCHAR                      pOutBuffer = NULL;
+    ULONG                       FrameLen = 0;
+    USHORT                      Status;
+    USHORT                      NStatus;
+
+    pInfo = (MLME_DEAUTH_REQ_STRUCT *)Elem->Msg;
+
+    // allocate and send out DeauthReq frame
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - MlmeDeauthReqAction() allocate memory fail\n");
+        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+        Status = MLME_FAIL_NO_RESOURCE;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
+        return;
+    }
+
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Send DE-AUTH request (Reason=%d)...\n", pInfo->Reason);
+    MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pInfo->Addr, pAd->MlmeAux.Bssid);
+
+    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                      sizeof(HEADER_802_11),    &DeauthHdr,
+                      2,                        &pInfo->Reason,
+                      END_OF_ARGS);
+
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+    pAd->PortCfg.DeauthReason = pInfo->Reason;
+    COPY_MAC_ADDR(pAd->PortCfg.DeauthSta, pInfo->Addr);
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    Status = MLME_SUCCESS;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID AuthTimeoutAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT Status;
+
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - AuthTimeoutAction\n");
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    Status = MLME_REJ_TIMEOUT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenAuth(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT  Status;
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - InvalidStateWhenAuth (state=%d), reset AUTH state machine\n", pAd->Mlme.AuthMachine.CurrState);
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Some STA/AP
+    Note:
+        This action should never trigger AUTH state transition, therefore we
+        separate it from AUTH state machine, and make it as a standalone service
+    ==========================================================================
+ */
+VOID Cls2errAction(
+    IN PRTMP_ADAPTER pAd,
+    IN PUCHAR pAddr)
+{
+    HEADER_802_11   DeauthHdr;
+    PUCHAR          pOutBuffer = NULL;
+    ULONG           FrameLen = 0;
+    USHORT          Reason = REASON_CLS2ERR;
+    USHORT          NStatus;
+
+    // allocate memory
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;
+
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Class 2 error, Send DEAUTH frame...\n");
+    MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pAddr, pAd->MlmeAux.Bssid);
+    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                      sizeof(HEADER_802_11),    &DeauthHdr,
+                      2,                        &Reason,
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+    pAd->PortCfg.DeauthReason = Reason;
+    COPY_MAC_ADDR(pAd->PortCfg.DeauthSta, pAddr);
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/auth_rsp.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/auth_rsp.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/auth_rsp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/auth_rsp.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,140 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	auth_rsp.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/*
+    ==========================================================================
+    Description:
+        authentication state machine init procedure
+    Parameters:
+        Sm - the state machine
+    Note:
+        the state machine looks like the following
+
+                                    AUTH_RSP_IDLE                       AUTH_RSP_WAIT_CHAL
+    MT2_AUTH_CHALLENGE_TIMEOUT      auth_rsp_challenge_timeout_action   auth_rsp_challenge_timeout_action
+    MT2_PEER_AUTH_ODD               peer_auth_at_auth_rsp_idle_action   peer_auth_at_auth_rsp_wait_action
+    MT2_PEER_DEAUTH                 peer_deauth_action                  peer_deauth_action
+    ==========================================================================
+ */
+VOID AuthRspStateMachineInit(
+    IN PRTMP_ADAPTER pAd,
+    IN PSTATE_MACHINE Sm,
+    IN STATE_MACHINE_FUNC Trans[])
+{
+    ULONG        Now;
+
+    StateMachineInit(Sm, (STATE_MACHINE_FUNC*)Trans, MAX_AUTH_RSP_STATE, MAX_AUTH_RSP_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_RSP_IDLE, AUTH_RSP_MACHINE_BASE);
+
+    // column 1
+    StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+
+    // column 2
+    StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+
+
+    // initialize the random number generator
+    Now = jiffies;
+    LfsrInit(pAd, Now);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+*/
+VOID PeerAuthSimpleRspGenAndSend(
+    IN PRTMP_ADAPTER pAd,
+    IN PHEADER_802_11 pHdr80211,
+    IN USHORT Alg,
+    IN USHORT Seq,
+    IN USHORT Reason,
+    IN USHORT Status)
+{
+    HEADER_802_11   AuthHdr;
+    UINT            FrameLen = 0;
+    PUCHAR          pOutBuffer = NULL;
+    USHORT          NStatus;
+
+    // allocate and send out Auth_Rsp frame
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;
+
+    if (Reason == MLME_SUCCESS)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "Send AUTH response (seq#2)...\n");
+        MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, pHdr80211->Addr2, pAd->MlmeAux.Bssid);
+        MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                          sizeof(HEADER_802_11),    &AuthHdr,
+                          2,                        &Alg,
+                          2,                        &Seq,
+                          2,                        &Reason,
+                          END_OF_ARGS);
+        MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "Peer AUTH fail...\n");
+        return;
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+*/
+VOID PeerDeauthAction(
+    IN PRTMP_ADAPTER pAd,
+    IN PMLME_QUEUE_ELEM Elem)
+{
+    UCHAR       Addr2[MAC_ADDR_LEN];
+    USHORT      Reason;
+
+    if (PeerDeauthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
+    {
+        if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(Addr2, &pAd->PortCfg.Bssid))
+        {
+            DBGPRINT(RT_DEBUG_TRACE,"AUTH_RSP - receive DE-AUTH from our AP\n");
+            LinkDown(pAd, TRUE);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE,"AUTH_RSP - PeerDeauthAction() sanity check fail\n");
+    }
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/connect.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/connect.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/connect.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/connect.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1617 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	connect.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *	John		2004-08-08	Major modification from RT2560
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+
+UCHAR	CipherSuiteWpaNoneTkip[] = {
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x02,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x00	// authentication
+		};
+UCHAR	CipherSuiteWpaNoneTkipLen = (sizeof(CipherSuiteWpaNoneTkip) / sizeof(UCHAR));
+
+UCHAR	CipherSuiteWpaNoneAes[] = {
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x04,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x04,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x00	// authentication
+		};
+UCHAR	CipherSuiteWpaNoneAesLen = (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR));
+
+
+// The following MACRO is called after 1. starting an new IBSS, 2. succesfully JOIN an IBSS,
+// or 3. succesfully ASSOCIATE to a BSS, 4. successfully RE_ASSOCIATE to a BSS
+// All settings successfuly negotiated furing MLME state machines become final settings
+// and are copied to pAd->ActiveCfg
+#define COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd) 								\
+{																						\
+	_pAd->PortCfg.SsidLen = _pAd->MlmeAux.SsidLen;									  \
+	memcpy(_pAd->PortCfg.Ssid, _pAd->MlmeAux.Ssid, _pAd->MlmeAux.SsidLen);	  \
+	COPY_MAC_ADDR(_pAd->PortCfg.Bssid, _pAd->MlmeAux.Bssid);						  \
+	_pAd->PortCfg.Channel = _pAd->MlmeAux.Channel;									  \
+	_pAd->ActiveCfg.Aid = _pAd->MlmeAux.Aid;											\
+	_pAd->ActiveCfg.AtimWin = _pAd->MlmeAux.AtimWin;									\
+	_pAd->ActiveCfg.CapabilityInfo = _pAd->MlmeAux.CapabilityInfo;						\
+	_pAd->PortCfg.BeaconPeriod = _pAd->MlmeAux.BeaconPeriod;						  \
+	_pAd->ActiveCfg.CfpMaxDuration = _pAd->MlmeAux.CfpMaxDuration;						\
+	_pAd->ActiveCfg.CfpPeriod = _pAd->MlmeAux.CfpPeriod;								\
+	_pAd->ActiveCfg.SupRateLen = _pAd->MlmeAux.SupRateLen;								\
+	memcpy(_pAd->ActiveCfg.SupRate, _pAd->MlmeAux.SupRate, _pAd->MlmeAux.SupRateLen);	\
+	_pAd->ActiveCfg.ExtRateLen = _pAd->MlmeAux.ExtRateLen;										\
+	memcpy(_pAd->ActiveCfg.ExtRate, _pAd->MlmeAux.ExtRate, _pAd->MlmeAux.ExtRateLen);	\
+	memcpy(&_pAd->PortCfg.APEdcaParm, &_pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));  \
+	memcpy(&_pAd->PortCfg.APQosCapability, &_pAd->MlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));  \
+	memcpy(&_pAd->PortCfg.APQbssLoad, &_pAd->MlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM)); \
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID MlmeCntlInit(
+	IN PRTMP_ADAPTER pAd,
+	IN STATE_MACHINE *S,
+	OUT STATE_MACHINE_FUNC Trans[])
+{
+	// Control state machine differs from other state machines, the interface
+	// follows the standard interface
+	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID MlmeCntlMachinePerformAction(
+	IN PRTMP_ADAPTER pAd,
+	IN STATE_MACHINE *S,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	switch(pAd->Mlme.CntlMachine.CurrState)
+	{
+		case CNTL_IDLE:
+			CntlIdleProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_DISASSOC:
+			CntlWaitDisassocProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_JOIN:
+			CntlWaitJoinProc(pAd, Elem);
+			break;
+
+		// CNTL_WAIT_REASSOC is the only state in CNTL machine that does
+		// not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)".
+		// Therefore not protected by NDIS's "only one outstanding OID request"
+		// rule. Which means NDIS may SET OID in the middle of ROAMing attempts.
+		// Current approach is to block new SET request at RTMPSetInformation()
+		// when CntlMachine.CurrState is not CNTL_IDLE
+		case CNTL_WAIT_REASSOC:
+			CntlWaitReassocProc(pAd, Elem);
+			break;
+
+		case CNTL_WAIT_START:
+			CntlWaitStartProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_AUTH:
+			CntlWaitAuthProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_AUTH2:
+			CntlWaitAuthProc2(pAd, Elem);
+			break;
+		case CNTL_WAIT_ASSOC:
+			CntlWaitAssocProc(pAd, Elem);
+			break;
+
+		case CNTL_WAIT_OID_LIST_SCAN:
+			if(Elem->MsgType == MT2_SCAN_CONF)
+			{
+				// Resume TxRing after SCANING complete. We hope the out-of-service time
+				// won't be too long to let upper layer time-out the waiting frames
+				RTUSBResumeMsduTransmission(pAd);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			}
+			break;
+
+		case CNTL_WAIT_OID_DISASSOC:
+			if (Elem->MsgType == MT2_DISASSOC_CONF)
+			{
+				LinkDown(pAd, FALSE);
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			}
+			break;
+
+		default:
+			DBGPRINT_ERR("!ERROR! CNTL - Illegal message type(=%d)", Elem->MsgType);
+			break;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlIdleProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+	{
+		if (pAd->MlmeAux.CurrReqIsFromNdis)
+			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+		return;
+	}
+
+	switch(Elem->MsgType)
+	{
+		case OID_802_11_SSID:
+			CntlOidSsidProc(pAd, Elem);
+			break;
+
+		case OID_802_11_BSSID:
+			CntlOidRTBssidProc(pAd,Elem);
+			break;
+
+		case OID_802_11_BSSID_LIST_SCAN:
+			CntlOidScanProc(pAd,Elem);
+			break;
+
+		case OID_802_11_DISASSOCIATE:
+			DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+			// Set the AutoReconnectSsid to prevent it reconnect to old SSID
+			// Since calling this indicate user don't want to connect to that SSID anymore.
+			pAd->MlmeAux.AutoReconnectSsidLen= 32;
+			memset(pAd->MlmeAux.AutoReconnectSsid, 0, pAd->MlmeAux.AutoReconnectSsidLen);
+			break;
+
+		case MT2_MLME_ROAMING_REQ:
+			CntlMlmeRoamingProc(pAd, Elem);
+			break;
+
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Illegal message in CntlIdleProc(MsgType=%d)\n",Elem->MsgType);
+			break;
+	}
+}
+
+VOID CntlOidScanProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	MLME_SCAN_REQ_STRUCT	   ScanReq;
+	ULONG					   BssIdx = BSS_NOT_FOUND;
+	BSS_ENTRY				   CurrBss;
+
+	DBGPRINT(RT_DEBUG_INFO, "CNTL - SCAN starts\n");
+
+	// record current BSS if network is connected.
+	// 2003-2-13 do not include current IBSS if this is the only STA in this IBSS.
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+		BssIdx = BssSsidTableSearch(&pAd->ScanTab, pAd->PortCfg.Bssid, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen, pAd->PortCfg.Channel);
+		if (BssIdx != BSS_NOT_FOUND)
+		{
+			memcpy(&CurrBss, &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+
+			// 2003-2-20 reset this RSSI to a low value but not zero. In normal case, the coming SCAN
+			//	   should return a correct RSSI to overwrite this. If no BEEACON received after SCAN,
+			//	   at least we still report a "greater than 0" RSSI since we claim it's CONNECTED.
+			//CurrBss.Rssi = pAd->BbpRssiToDbmDelta - 85; // assume -85 dB
+		}
+	}
+
+	// clean up previous SCAN result, add current BSS back to table if any
+	BssTableInit(&pAd->ScanTab);
+	if (BssIdx != BSS_NOT_FOUND)
+	{
+		// DDK Note: If the NIC is associated with a particular BSSID and SSID
+		//	  that are not contained in the list of BSSIDs generated by this scan, the
+		//	  BSSID description of the currently associated BSSID and SSID should be
+		//	  appended to the list of BSSIDs in the NIC's database.
+		// To ensure this, we append this BSS as the first entry in SCAN result
+		memcpy(&pAd->ScanTab.BssEntry[0], &CurrBss, sizeof(BSS_ENTRY));
+		pAd->ScanTab.BssNr = 1;
+	}
+
+	ScanParmFill(pAd, &ScanReq, "", 0, BSS_ANY, SCAN_PASSIVE);
+	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+				sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+}
+
+/*
+	==========================================================================
+	Description:
+		Before calling this routine, user desired SSID should already been
+		recorded in PortCfg.Ssid[]
+	==========================================================================
+*/
+VOID CntlOidSsidProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM * Elem)
+{
+    PNDIS_802_11_SSID		   pOidSsid = (NDIS_802_11_SSID *)Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+	ULONG					   Now;
+
+
+	// Step 1. record the desired user settings to MlmeAux
+	memcpy(pAd->MlmeAux.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
+	pAd->MlmeAux.SsidLen = (UCHAR)pOidSsid->SsidLength;
+	memset(pAd->MlmeAux.Bssid, 0, MAC_ADDR_LEN);
+	pAd->MlmeAux.BssType = pAd->PortCfg.BssType;
+
+	//
+	// Update Reconnect Ssid, that user desired to connect.
+	//
+	memcpy(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+	pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
+
+
+	// step 2. find all matching BSS in the lastest SCAN result (inBssTab)
+	//	  & log them into MlmeAux.SsidBssTab for later-on iteration. Sort by RSSI order
+	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+
+	DBGPRINT(RT_DEBUG_TRACE, "CNTL - %d BSS match the desire SSID - %s\n",pAd->MlmeAux.SsidBssTab.BssNr, pAd->MlmeAux.Ssid);
+
+	Now = jiffies;
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
+		(pAd->PortCfg.SsidLen == pAd->MlmeAux.SsidBssTab.BssEntry[0].SsidLen) &&
+		NdisEqualMemory(pAd->PortCfg.Ssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Ssid, pAd->PortCfg.SsidLen) &&
+		MAC_ADDR_EQUAL(pAd->PortCfg.Bssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid))
+	{
+		// Case 1. already connected with an AP who has the desired SSID
+		//		   with highest RSSI
+
+		if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)	 ||
+			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)	 ||
+			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+#if WPA_SUPPLICANT_SUPPORT
+			  || (pAd->PortCfg.IEEE8021X == TRUE)
+#endif
+			 )  &&
+			 (pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+		{
+			// case 1.1 For WPA, WPA-PSK, if the 1x port is not secured, we have to redo
+			//			connection process
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP...\n");
+			DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else if (pAd->bConfigChanged == TRUE)
+		{
+			// case 1.2 Important Config has changed, we have to reconnect to the same AP
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP Because config changed...\n");
+			DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else
+		{
+			// case 1.3. already connected to the SSID with highest RSSI.
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - already with this BSSID. ignore this SET_SSID request\n");
+
+
+			// We only check if same to the BSSID with highest RSSI.
+			// If roaming of same SSID required, we still do the reconnection.
+			// same BSSID, go back to idle state directly
+			if (pAd->MlmeAux.CurrReqIsFromNdis)
+			{
+			}
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		}
+	}
+	else if (INFRA_ON(pAd))
+	{
+		// case 2. active INFRA association existent
+		//	  roaming is done within miniport driver, nothing to do with configuration
+		//	  utility. so upon a new SET(OID_802_11_SSID) is received, we just
+		//	  disassociate with the current associated AP,
+		//	  then perform a new association with this new SSID, no matter the
+		//	  new/old SSID are the same or not.
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP...\n");
+		DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+	}
+	else
+	{
+		if (ADHOC_ON(pAd))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - drop current ADHOC\n");
+			LinkDown(pAd, FALSE);
+			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event C!\n");
+		}
+
+		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0) &&
+			(pAd->PortCfg.bAutoReconnect == TRUE) &&
+			(pAd->MlmeAux.BssType == BSS_INFRA) &&
+			(MlmeValidateSSID(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen) == TRUE))
+		{
+			MLME_SCAN_REQ_STRUCT	   ScanReq;
+
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new scan\n");
+
+
+			ScanParmFill(pAd, &ScanReq, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+						sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+
+			// Reset Missed scan number
+			pAd->PortCfg.LastScanTime = Now;
+		}
+		else
+		{
+			pAd->MlmeAux.BssIdx = 0;
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlOidRTBssidProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM * Elem)
+{
+	ULONG						BssIdx;
+	PUCHAR						pOidBssid = (PUCHAR)Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+	MLME_JOIN_REQ_STRUCT		JoinReq;
+
+	DBGPRINT(RT_DEBUG_TRACE, "CNTL - CntlOidRTBssidProc ...\n");
+	// record user desired settings
+	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pOidBssid);
+	pAd->MlmeAux.BssType = pAd->PortCfg.BssType;
+
+	// find the desired BSS in the latest SCAN result table
+	BssIdx = BssTableSearch(&pAd->ScanTab, pOidBssid, pAd->MlmeAux.Channel);
+	if (BssIdx == BSS_NOT_FOUND)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n");
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		return;
+	}
+
+	// copy the matched BSS entry from ScanTab to MlmeAux.SsidBssTab. Why?
+	// Because we need this entry to become the JOIN target in later on SYNC state machine
+	pAd->MlmeAux.BssIdx = 0;
+	pAd->MlmeAux.SsidBssTab.BssNr = 1;
+	memcpy(&pAd->MlmeAux.SsidBssTab.BssEntry[0], &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+
+	//
+	// Update Reconnect Ssid, that user desired to connect.
+	//
+	pAd->MlmeAux.AutoReconnectSsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
+	memcpy(pAd->MlmeAux.AutoReconnectSsid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->ScanTab.BssEntry[BssIdx].SsidLen);
+
+	// Add SSID into MlmeAux for site surey joining hidden SSID
+	pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
+	memcpy(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->MlmeAux.SsidLen);
+
+	// 2002-11-26 skip the following checking. i.e. if user wants to re-connect to same AP
+	//	 we just follow normal procedure. The reason of user doing this may because he/she changed
+	//	 AP to another channel, but we still received BEACON from it thus don't claim Link Down.
+	//	 Since user knows he's changed AP channel, he'll re-connect again. By skipping the following
+	//	 checking, we'll disassociate then re-do normal association with this AP at the new channel.
+	// 2003-1-6 Re-enable this feature based on microsoft requirement which prefer not to re-do
+	//	 connection when setting the same BSSID.
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
+		MAC_ADDR_EQUAL(pAd->PortCfg.Bssid, pOidBssid))
+	{
+		// already connected to the same BSSID, go back to idle state directly
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - already in this BSSID. ignore this SET_BSSID request\n");
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+	}
+	else
+	{
+		if (INFRA_ON(pAd))
+		{
+			// disassoc from current AP first
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP ...\n");
+			DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else
+		{
+			if (ADHOC_ON(pAd))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - drop current ADHOC\n");
+				LinkDown(pAd, FALSE);
+				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+				DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event C!\n");
+			}
+
+#if 0  // set  OrigWepStatus in OID_802_11_WEP_STATUS
+			// Change the wepstatus to original wepstatus
+			pAd->PortCfg.WepStatus	 = pAd->PortCfg.OrigWepStatus;
+			pAd->PortCfg.PairCipher  = pAd->PortCfg.OrigWepStatus;
+			pAd->PortCfg.GroupCipher = pAd->PortCfg.OrigWepStatus;
+#endif
+			// Check cipher suite, AP must have more secured cipher than station setting
+			// Set the Pairwise and Group cipher to match the intended AP setting
+			// We can only connect to AP with less secured cipher setting
+			if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+			{
+				pAd->PortCfg.GroupCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.GroupCipher;
+
+				if (pAd->PortCfg.WepStatus == pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipher)
+					pAd->PortCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipher;
+				else if (pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipherAux != Ndis802_11WEPDisabled)
+					pAd->PortCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipherAux;
+				else	// There is no PairCipher Aux, downgrade our capability to TKIP
+					pAd->PortCfg.PairCipher = Ndis802_11Encryption2Enabled;
+			}
+			else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+			{
+				pAd->PortCfg.GroupCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.GroupCipher;
+
+				if (pAd->PortCfg.WepStatus == pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipher)
+					pAd->PortCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipher;
+				else if (pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipherAux != Ndis802_11WEPDisabled)
+					pAd->PortCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipherAux;
+				else	// There is no PairCipher Aux, downgrade our capability to TKIP
+					pAd->PortCfg.PairCipher = Ndis802_11Encryption2Enabled;
+
+				// RSN capability
+				pAd->PortCfg.RsnCapability = pAd->ScanTab.BssEntry[BssIdx].WPA2.RsnCapability;
+			}
+			// Set Mix cipher flag
+			if (pAd->PortCfg.PairCipher != pAd->PortCfg.GroupCipher)
+				pAd->PortCfg.bMixCipher = TRUE;
+
+
+			// No active association, join the BSS immediately
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - joining %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+				pOidBssid[0],pOidBssid[1],pOidBssid[2],pOidBssid[3],pOidBssid[4],pOidBssid[5]);
+
+			JoinParmFill(pAd, &JoinReq, pAd->MlmeAux.BssIdx);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ,
+						sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+		}
+	}
+}
+
+// Roaming is the only external request triggering CNTL state machine
+// despite of other "SET OID" operation. All "SET OID" related oerations
+// happen in sequence, because no other SET OID will be sent to this device
+// until the the previous SET operation is complete (successful o failed).
+// So, how do we quarantee this ROAMING request won't corrupt other "SET OID"?
+// or been corrupted by other "SET OID"?
+VOID CntlMlmeRoamingProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	// TODO:
+	// AP in different channel may show lower RSSI than actual value??
+	// should we add a weighting factor to compensate it?
+	DBGPRINT(RT_DEBUG_TRACE,"CNTL - Roaming in MlmeAux.RoamTab...\n");
+
+	memcpy(&pAd->MlmeAux.SsidBssTab, &pAd->MlmeAux.RoamTab, sizeof(pAd->MlmeAux.RoamTab));
+	pAd->MlmeAux.SsidBssTab.BssNr = pAd->MlmeAux.RoamTab.BssNr;
+
+	BssTableSortByRssi(&pAd->MlmeAux.SsidBssTab);
+	pAd->MlmeAux.BssIdx = 0;
+	IterateOnBssTab(pAd);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitDisassocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	MLME_START_REQ_STRUCT	  StartReq;
+
+	if (Elem->MsgType == MT2_DISASSOC_CONF)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - Dis-associate successful\n");
+		LinkDown(pAd, FALSE);
+
+		// case 1. no matching BSS, and user wants ADHOC, so we just start a new one
+		if ((pAd->MlmeAux.SsidBssTab.BssNr==0) && (pAd->PortCfg.BssType == BSS_ADHOC))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new ADHOC (Ssid=%s)...\n",pAd->MlmeAux.Ssid);
+			StartParmFill(pAd, &StartReq, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
+						sizeof(MLME_START_REQ_STRUCT), &StartReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+		}
+		// case 2. try each matched BSS
+		else
+		{
+			pAd->MlmeAux.BssIdx = 0;
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitJoinProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT						Reason;
+	MLME_AUTH_REQ_STRUCT		AuthReq;
+
+	if (Elem->MsgType == MT2_JOIN_CONF)
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS)
+		{
+			// 1. joined an IBSS, we are pretty much done here
+			if (pAd->MlmeAux.BssType == BSS_ADHOC)
+			{
+				LinkUp(pAd, BSS_ADHOC);
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - join the IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+					pAd->PortCfg.Bssid[0],pAd->PortCfg.Bssid[1],pAd->PortCfg.Bssid[2],
+					pAd->PortCfg.Bssid[3],pAd->PortCfg.Bssid[4],pAd->PortCfg.Bssid[5]);
+			}
+			// 2. joined a new INFRA network, start from authentication
+			else
+			{
+				// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeShared) ||
+					(pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+				{
+					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeShared);
+				}
+				else
+				{
+					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeOpen);
+				}
+
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
+							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH;
+			}
+		}
+		else
+		{
+			// 3. failed, try next BSS
+			pAd->MlmeAux.BssIdx++;
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitStartProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT		Result;
+
+	if (Elem->MsgType == MT2_START_CONF)
+	{
+		memcpy(&Result, Elem->Msg, sizeof(USHORT));
+		if (Result == MLME_SUCCESS)
+		{
+			LinkUp(pAd, BSS_ADHOC);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+
+            // Before send beacon, driver need do radar detection
+			if (((pAd->PortCfg.PhyMode == PHY_11A) || (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED))&& (pAd->PortCfg.bIEEE80211H == 1) && RadarChannelCheck(pAd, pAd->PortCfg.Channel))
+			{
+				pAd->PortCfg.RadarDetect.RDMode = RD_SILENCE_MODE;
+				pAd->PortCfg.RadarDetect.RDCount = 0;
+				RadarDetectionStart(pAd);
+			}
+
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - start a new IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+				pAd->PortCfg.Bssid[0],pAd->PortCfg.Bssid[1],pAd->PortCfg.Bssid[2],
+				pAd->PortCfg.Bssid[3],pAd->PortCfg.Bssid[4],pAd->PortCfg.Bssid[5]);
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Start IBSS fail. BUG!!!!!\n");
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAuthProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT						 Reason;
+	MLME_ASSOC_REQ_STRUCT		 AssocReq;
+	MLME_AUTH_REQ_STRUCT		 AuthReq;
+
+	if (Elem->MsgType == MT2_AUTH_CONF)
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH OK\n");
+			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid, pAd->MlmeAux.CapabilityInfo,
+						  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ,
+						sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+
+		}
+		else
+		{
+			// This fail may because of the AP already keep us in its MAC table without
+			// ageing-out. The previous authentication attempt must have let it remove us.
+			// so try Authentication again may help. For D-Link DWL-900AP+ compatibility.
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, try again...\n");
+
+			if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeShared) ||
+				(pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+			{
+				// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeShared);
+			}
+			else
+			{
+				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeOpen);
+			}
+
+			MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
+						sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAuthProc2(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT						 Reason;
+	MLME_ASSOC_REQ_STRUCT		 AssocReq;
+	MLME_AUTH_REQ_STRUCT		 AuthReq;
+
+	if (Elem->MsgType == MT2_AUTH_CONF)
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH OK\n");
+			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid, pAd->MlmeAux.CapabilityInfo,
+						  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ,
+						sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+		}
+		else
+		{
+
+			if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch) &&
+				 (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, try OPEN system...\n");
+				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeOpen);
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
+							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+			}
+			else
+			{
+				// not success, try next BSS
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, give up; try next BSS\n");
+// 2004-09-11 john -  why change state?
+//			   pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE; //???????
+				pAd->MlmeAux.BssIdx++;
+				IterateOnBssTab(pAd);
+			}
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAssocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT		Reason;
+
+	if (Elem->MsgType == MT2_ASSOC_CONF)
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS)
+		{
+			LinkUp(pAd, BSS_INFRA);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Association successful on BSS #%d\n",pAd->MlmeAux.BssIdx);
+		}
+		else
+		{
+			// not success, try next BSS
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Association fails on BSS #%d\n",pAd->MlmeAux.BssIdx);
+			pAd->MlmeAux.BssIdx++;
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitReassocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	USHORT		Result;
+
+	if (Elem->MsgType == MT2_REASSOC_CONF)
+	{
+		memcpy(&Result, Elem->Msg, sizeof(USHORT));
+		if (Result == MLME_SUCCESS)
+		{
+			//
+			// NDIS requires a new Link UP indication but no Link Down for RE-ASSOC
+			//
+			LinkUp(pAd, BSS_INFRA);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Re-assocition successful on BSS #%d\n", pAd->MlmeAux.RoamIdx);
+		}
+		else
+		{
+			// reassoc failed, try to pick next BSS in the BSS Table
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Re-assocition fails on BSS #%d\n", pAd->MlmeAux.RoamIdx);
+			pAd->MlmeAux.RoamIdx++;
+			IterateOnBssTab2(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID LinkUp(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR BssType)
+{
+	ULONG	Now;
+	TXRX_CSR4_STRUC *NewTxRxCsr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
+	TXRX_CSR4_STRUC *CurTxRxCsr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
+
+	if (!NewTxRxCsr4 || !CurTxRxCsr4) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+	//
+	// ASSOC - DisassocTimeoutAction
+	// CNTL - Dis-associate successful
+	// !!! LINK DOWN !!!
+	// [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: )
+	//
+	// To prevent DisassocTimeoutAction to call Link down after we link up,
+	// cancel the DisassocTimer no matter what it start or not.
+	//
+	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
+
+	COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
+	DBGPRINT(RT_DEBUG_TRACE, "!!! LINK UP !!! (Infra=%d, AID=%d, ssid=%s)\n",
+		BssType, pAd->ActiveCfg.Aid, pAd->PortCfg.Ssid);
+
+
+	if (BssType == BSS_ADHOC)
+	{
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_ADHOC_ON);
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
+	}
+	else
+	{
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_INFRA_ON);
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
+	}
+
+
+	AsicSetBssid(pAd, pAd->PortCfg.Bssid);
+	AsicSetSlotTime(pAd, (BOOLEAN)pAd->PortCfg.UseShortSlotTime);
+	AsicSetEdcaParm(pAd, &pAd->PortCfg.APEdcaParm);
+
+	MlmeUpdateTxRates(pAd, TRUE);
+	memset(&pAd->DrsCounters, 0, sizeof(COUNTER_DRS));
+
+	Now = jiffies;
+	pAd->PortCfg.LastBeaconRxTime = Now;   // last RX timestamp
+
+	if ((pAd->PortCfg.TxPreamble != Rt802_11PreambleLong) &&
+		CAP_IS_SHORT_PREAMBLE_ON(pAd->ActiveCfg.CapabilityInfo))
+	{
+
+		DBGPRINT(RT_DEBUG_INFO, "CNTL - !!! Set to short preamble!!!\n");
+		MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
+	}
+
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+
+ 	if (pAd->PortCfg.RadarDetect.RDMode == RD_SILENCE_MODE)
+    {
+		RadarDetectionStop(pAd);
+    }
+	pAd->PortCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
+
+	if (BssType == BSS_ADHOC)
+	{
+		//
+		// We also need to cancel the LinkDownTimer, no matter it was been set or not.
+		// It may be set when we start an Infrastructure mode.
+		// And not be canceled yet then we switch to Adohc at meanwhile.
+		//
+		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer);
+
+		MakeIbssBeacon(pAd);
+
+        if (((pAd->PortCfg.PhyMode == PHY_11A) || (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED))&& (pAd->PortCfg.bIEEE80211H == 1) && RadarChannelCheck(pAd, pAd->PortCfg.Channel))
+        {
+			;; //Do nothing
+        }
+		else
+        {
+            AsicEnableIbssSync(pAd);
+        }
+
+
+#ifdef	SINGLE_ADHOC_LINKUP
+		// Although this did not follow microsoft's recommendation.
+		//Change based on customer's request
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+#endif
+
+	}
+	else // BSS_INFRA
+	{
+		int t;
+
+		// First cancel linkdown timer
+		t = RTMPCancelTimer(&pAd->Mlme.LinkDownTimer);
+
+		// Check the new SSID with last SSID
+		if (t)
+		{
+			if ((pAd->PortCfg.LastSsidLen != pAd->PortCfg.SsidLen) ||
+				((pAd->PortCfg.LastSsidLen == pAd->PortCfg.SsidLen) &&
+				 (RTMPCompareMemory(pAd->PortCfg.LastSsid, pAd->PortCfg.Ssid, pAd->PortCfg.LastSsidLen) != 0)))
+			{
+				// Send link down event before set to link up
+				DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event AA!\n");
+			}
+		}
+
+		//
+		// On WPA mode, Remove All Keys if not connect to the last BSSID
+		// Key will be set after 4-way handshake.
+		//
+		if ((pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA) &&
+			(!RTMPEqualMemory(pAd->PortCfg.LastBssid, pAd->PortCfg.Bssid, MAC_ADDR_LEN)))
+		{
+			// Remove all WPA keys
+			RTMPWPARemoveAllKeys(pAd);
+		}
+
+		// NOTE:
+		// the decision of using "short slot time" or not may change dynamically due to
+		// new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+
+		// NOTE:
+		// the decision to use "RTC/CTS" or "CTS-to-self" protection or not may change dynamically
+		// due to new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+
+		ComposePsPoll(pAd);
+		ComposeNullFrame(pAd);
+		AsicEnableBssSync(pAd);
+
+		// only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode
+		// should wait until at least 2 active nodes in this BSSID.
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+
+		if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
+			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_CONNECT Event B!\n");
+
+	// Set LED
+	RTMPSetLED(pAd, LED_LINK_UP);
+
+	//
+	// Enable OFDM TX rate auto fallback to CCK, if need.
+	//
+	RTUSBReadMACRegister(pAd, TXRX_CSR4, &CurTxRxCsr4->word);
+	NewTxRxCsr4->word = CurTxRxCsr4->word;
+	if ((pAd->PortCfg.Channel <= 14) &&
+		((pAd->PortCfg.PhyMode == PHY_11B) ||
+		 (pAd->PortCfg.PhyMode == PHY_11BG_MIXED) ||
+		 (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED)))
+	{
+		NewTxRxCsr4->field.OfdmTxFallbacktoCCK = 1;	 //Enable OFDM TX rate auto fallback to CCK 1M, 2M
+	}
+	else
+	{
+		NewTxRxCsr4->field.OfdmTxFallbacktoCCK = 0;	 //Disable OFDM TX rate auto fallback to CCK 1M, 2M
+	}
+
+	if (NewTxRxCsr4->word!= CurTxRxCsr4->word)
+		RTUSBWriteMACRegister(pAd, TXRX_CSR4, NewTxRxCsr4->word);
+
+
+	pAd->Mlme.PeriodicRound = 0;		// re-schedule MlmePeriodicExec()
+	pAd->bConfigChanged = FALSE;		// Reset config flag
+	pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
+
+	kfree(NewTxRxCsr4);
+	kfree(CurTxRxCsr4);
+}
+
+/*
+	==========================================================================
+
+	Routine	Description:
+		Disconnect current BSSID
+
+	Arguments:
+		pAd				- Pointer to our adapter
+		IsReqFromAP		- Request from AP
+
+	Return Value:
+		None
+
+	Note:
+		We need more information to know it's this requst from AP.
+		If yes! we need to do extra handling, for example, remove the WPA key.
+		Otherwise on 4-way handshaking will faied, since the WPA key didn't be
+		remove while auto reconnect.
+		Disconnect request from AP, it means we will start afresh 4-way handshaking
+		on WPA mode.
+
+	==========================================================================
+*/
+VOID LinkDown(
+	IN PRTMP_ADAPTER pAd,
+	IN	BOOLEAN 	 IsReqFromAP)
+{
+	TXRX_CSR4_STRUC *CurTxRxCsr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
+
+	DBGPRINT(RT_DEBUG_TRACE, "!!! LINK DOWN !!!\n");
+
+	if (!CurTxRxCsr4) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	} 	
+
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+
+	if (ADHOC_ON(pAd))		// Adhoc mode link down
+	{
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
+
+#ifdef	SINGLE_ADHOC_LINKUP
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+		// clean up previous SCAN result, add current BSS back to table if any
+		BssTableDeleteEntry(&pAd->PortCfg.ScanTab, &(pAd->PortCfg.Bssid), pAd->PortCfg.Channel);
+#else
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+		{
+			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+			BssTableDeleteEntry(&pAd->ScanTab, pAd->PortCfg.Bssid, pAd->PortCfg.Channel);
+		}
+#endif
+	}
+	else					// Infra structure mode
+	{
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+		// Saved last SSID for linkup comparison
+		pAd->PortCfg.LastSsidLen = pAd->PortCfg.SsidLen;
+		memcpy(pAd->PortCfg.LastSsid, pAd->PortCfg.Ssid, pAd->PortCfg.LastSsidLen);
+		COPY_MAC_ADDR(pAd->PortCfg.LastBssid, pAd->PortCfg.Bssid);
+		if (pAd->MlmeAux.CurrReqIsFromNdis == TRUE)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event A!\n");
+			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+		}
+		else
+		{
+			// Set linkdown timer
+			RTMPSetTimer(pAd, &pAd->Mlme.LinkDownTimer, 10000);
+		}
+
+		BssTableDeleteEntry(&pAd->ScanTab, pAd->PortCfg.Bssid, pAd->PortCfg.Channel);
+
+		// restore back to -
+		//		1. long slot (20 us) or short slot (9 us) time
+		//		2. turn on/off RTS/CTS and/or CTS-to-self protection
+		//		3. short preamble
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
+
+	}
+
+	//
+	// Reset CWMin & CWMax to default value
+	// Since we reset the slot time to 0x14(long slot time), so we also need to
+	// Reset the flag fOP_STATUS_SHORT_SLOT_INUSED at the same time.
+	//
+	RTUSBWriteMACRegister(pAd, MAC_CSR9, 0x0704a414);
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
+
+	AsicSetSlotTime(pAd, (BOOLEAN)pAd->PortCfg.UseShortSlotTime);
+	AsicSetEdcaParm(pAd, NULL);
+
+	// Set LED
+	RTMPSetLED(pAd, LED_LINK_DOWN);
+
+	AsicDisableSync(pAd);
+	pAd->Mlme.PeriodicRound = 0;
+
+	// Remove PortCfg Information after link down
+	memset(pAd->PortCfg.Bssid, 0, MAC_ADDR_LEN);
+	memset(pAd->PortCfg.Ssid, 0, MAX_LEN_OF_SSID);
+	pAd->PortCfg.SsidLen = 0;
+
+	// Reset WPA-PSK state. Only reset when supplicant enabled
+	if (pAd->PortCfg.WpaState != SS_NOTUSE)
+	{
+		pAd->PortCfg.WpaState = SS_START;
+		// Clear Replay counter
+		memset(pAd->PortCfg.ReplayCounter, 0, 8);
+	}
+
+	//
+	// if link down come from AP, we need to remove all WPA keys on WPA mode.
+	// otherwise will cause 4-way handshaking failed, since the WPA key not empty.
+	//
+	if ((IsReqFromAP) && (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA))
+	{
+		// Remove all WPA keys
+		RTMPWPARemoveAllKeys(pAd);
+	}
+
+	// 802.1x port control
+	pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+	pAd->PortCfg.MicErrCnt = 0;
+
+	// Update extra information to link is up
+	pAd->ExtraInfo = GENERAL_LINK_DOWN;
+
+	// Clean association information
+	memset(&pAd->PortCfg.AssocInfo, 0, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+	pAd->PortCfg.ReqVarIELen = 0;
+	pAd->PortCfg.ResVarIELen = 0;
+
+
+    // Restore MlmeRate
+	pAd->PortCfg.MlmeRate = pAd->PortCfg.BasicMlmeRate;
+	pAd->PortCfg.RtsRate = pAd->PortCfg.BasicMlmeRate;
+
+	//
+	// After link down, reset R17 to LowerBound.
+	//
+	if (pAd->MlmeAux.Channel <= 14)
+	{
+		RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17LowerBoundG);
+	}
+	else
+	{
+		RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17LowerBoundA);
+	}
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MAX_RETRY_ENABLED))
+	{
+		RTUSBReadMACRegister(pAd, TXRX_CSR4, &CurTxRxCsr4->word);
+		CurTxRxCsr4->field.ShortRetryLimit = 0x07;
+		CurTxRxCsr4->field.LongRetryLimit = 0x04;
+		RTUSBWriteMACRegister(pAd, TXRX_CSR4, CurTxRxCsr4->word);
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MAX_RETRY_ENABLED);
+	}
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE);
+	kfree(CurTxRxCsr4);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID IterateOnBssTab(
+	IN PRTMP_ADAPTER pAd)
+{
+	MLME_START_REQ_STRUCT	StartReq;
+	MLME_JOIN_REQ_STRUCT	JoinReq;
+	ULONG					BssIdx;
+
+#if 0	// set OrigWepStatus in OID_802_11_WEP_STATUS
+	// Change the wepstatus to original wepstatus
+	pAd->PortCfg.WepStatus	 = pAd->PortCfg.OrigWepStatus;
+	pAd->PortCfg.PairCipher  = pAd->PortCfg.OrigWepStatus;
+	pAd->PortCfg.GroupCipher = pAd->PortCfg.OrigWepStatus;
+#endif
+
+
+	BssIdx = pAd->MlmeAux.BssIdx;
+	if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr)
+	{
+		// Check cipher suite, AP must have more secured cipher than station setting
+		// Set the Pairwise and Group cipher to match the intended AP setting
+		// We can only connect to AP with less secured cipher setting
+		if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+		{
+			pAd->PortCfg.GroupCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.GroupCipher;
+
+			if (pAd->PortCfg.WepStatus == pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipher)
+				pAd->PortCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipher;
+			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipherAux != Ndis802_11WEPDisabled)
+				pAd->PortCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipherAux;
+			else	// There is no PairCipher Aux, downgrade our capability to TKIP
+				pAd->PortCfg.PairCipher = Ndis802_11Encryption2Enabled;
+		}
+		else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+		{
+			pAd->PortCfg.GroupCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.GroupCipher;
+
+			if (pAd->PortCfg.WepStatus == pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipher)
+				pAd->PortCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipher;
+			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipherAux != Ndis802_11WEPDisabled)
+				pAd->PortCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipherAux;
+			else	// There is no PairCipher Aux, downgrade our capability to TKIP
+				pAd->PortCfg.PairCipher = Ndis802_11Encryption2Enabled;
+
+			// RSN capability
+			pAd->PortCfg.RsnCapability = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.RsnCapability;
+		}
+		// Set Mix cipher flag
+		if (pAd->PortCfg.PairCipher != pAd->PortCfg.GroupCipher)
+			pAd->PortCfg.bMixCipher = TRUE;
+
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - iterate BSS %d of %d\n", BssIdx, pAd->MlmeAux.SsidBssTab.BssNr);
+		JoinParmFill(pAd, &JoinReq, BssIdx);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ, sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+	}
+	else if (pAd->PortCfg.BssType == BSS_ADHOC)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",pAd->MlmeAux.Ssid);
+		StartParmFill(pAd, &StartReq, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+	}
+	else // no more BSS
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - All roaming failed, stay @ ch #%d\n", pAd->PortCfg.Channel);
+		AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+		AsicLockChannel(pAd, pAd->PortCfg.Channel);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+	}
+}
+
+// for re-association only
+VOID IterateOnBssTab2(
+	IN PRTMP_ADAPTER pAd)
+{
+	MLME_REASSOC_REQ_STRUCT ReassocReq;
+	ULONG					BssIdx;
+	BSS_ENTRY				*pBss;
+
+	BssIdx = pAd->MlmeAux.RoamIdx;
+	pBss = &pAd->MlmeAux.RoamTab.BssEntry[BssIdx];
+
+	if (BssIdx < pAd->MlmeAux.RoamTab.BssNr)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - iterate BSS %d of %d\n", BssIdx, pAd->MlmeAux.RoamTab.BssNr);
+
+		AsicSwitchChannel(pAd, pBss->Channel);
+		AsicLockChannel(pAd, pBss->Channel);
+
+		// reassociate message has the same structure as associate message
+		AssocParmFill(pAd, &ReassocReq, pBss->Bssid, pBss->CapabilityInfo,
+					  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_REASSOC_REQ,
+					sizeof(MLME_REASSOC_REQ_STRUCT), &ReassocReq);
+
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
+	}
+	else // no more BSS
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - All fast roaming failed, back to ch #%d\n",pAd->PortCfg.Channel);
+		AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+		AsicLockChannel(pAd, pAd->PortCfg.Channel);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID JoinParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_JOIN_REQ_STRUCT *JoinReq,
+	IN ULONG BssIdx)
+{
+	JoinReq->BssIdx = BssIdx;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID AssocParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq,
+	IN PUCHAR					  pAddr,
+	IN USHORT					  CapabilityInfo,
+	IN ULONG					  Timeout,
+	IN USHORT					  ListenIntv)
+{
+	COPY_MAC_ADDR(AssocReq->Addr, pAddr);
+	// Add mask to support 802.11b mode only
+	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO; // not cf-pollable, not cf-poll-request
+	AssocReq->Timeout = Timeout;
+	AssocReq->ListenIntv = ListenIntv;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID ScanParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_SCAN_REQ_STRUCT *ScanReq,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN UCHAR ScanType)
+{
+	ScanReq->SsidLen = SsidLen;
+	memcpy(ScanReq->Ssid, Ssid, SsidLen);
+	ScanReq->BssType = BssType;
+	ScanReq->ScanType = ScanType;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID DisassocParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq,
+	IN PUCHAR pAddr,
+	IN USHORT Reason)
+{
+	COPY_MAC_ADDR(DisassocReq->Addr, pAddr);
+	DisassocReq->Reason = Reason;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID StartParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_START_REQ_STRUCT *StartReq,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen)
+{
+	memcpy(StartReq->Ssid, Ssid, SsidLen);
+	StartReq->SsidLen = SsidLen;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID AuthParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_AUTH_REQ_STRUCT *AuthReq,
+	IN PUCHAR pAddr,
+	IN USHORT Alg)
+{
+	COPY_MAC_ADDR(AuthReq->Addr, pAddr);
+	AuthReq->Alg = Alg;
+	AuthReq->Timeout = AUTH_TIMEOUT;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID ComposePsPoll(
+	IN PRTMP_ADAPTER pAd)
+{
+	memset(&pAd->PsPollFrame, 0, sizeof(PSPOLL_FRAME));
+	pAd->PsPollFrame.FC.Type = BTYPE_CNTL;
+	pAd->PsPollFrame.FC.SubType = SUBTYPE_PS_POLL;
+	pAd->PsPollFrame.Aid = pAd->ActiveCfg.Aid | 0xC000;
+	COPY_MAC_ADDR(pAd->PsPollFrame.Bssid, pAd->PortCfg.Bssid);
+	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
+}
+
+VOID ComposeNullFrame(
+	IN PRTMP_ADAPTER pAd)
+{
+	memset(&pAd->NullFrame, 0, sizeof(HEADER_802_11));
+	pAd->NullFrame.FC.Type = BTYPE_DATA;
+	pAd->NullFrame.FC.SubType = SUBTYPE_NULL_FUNC;
+	pAd->NullFrame.FC.ToDs = 1;
+	COPY_MAC_ADDR(pAd->NullFrame.Addr1, pAd->PortCfg.Bssid);
+	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
+	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->PortCfg.Bssid);
+}
+
+/*
+	==========================================================================
+	Description:
+		Pre-build a BEACON frame in the shared memory
+	==========================================================================
+*/
+ULONG MakeIbssBeacon(
+	IN PRTMP_ADAPTER pAd)
+{
+	UCHAR		  DsLen = 1, IbssLen = 2;
+	UCHAR		  LocalErpIe[3] = {IE_ERP, 1, 0x04};
+	HEADER_802_11 BcnHdr;
+	USHORT		  CapabilityInfo;
+	LARGE_INTEGER FakeTimestamp;
+	ULONG		  FrameLen=0;
+	PTXD_STRUC	  pTxD = &pAd->BeaconTxD;
+	CHAR		 *pBeaconFrame = pAd->BeaconBuf;
+	BOOLEAN 	  Privacy;
+	UCHAR		  SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		  SupRateLen = 0;
+	UCHAR		  ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		  ExtRateLen = 0;
+
+
+	// 2003-12-10 802.11g WIFI spec disallow OFDM rates in 802.11g ADHOC mode
+	//			  make sure 1,2,5.5,11 are the firt 4 rates in PortCfg.SupportedRates[] array
+	if (((pAd->PortCfg.PhyMode == PHY_11BG_MIXED) ||
+		(pAd->PortCfg.PhyMode == PHY_11ABG_MIXED)) &&
+		(pAd->PortCfg.AdhocMode == ADHOC_11B))
+	{
+		SupRate[0] = 0x82; // 1 mbps
+		SupRate[1] = 0x84; // 2 mbps
+		SupRate[2] = 0x8b; // 5.5 mbps
+		SupRate[3] = 0x96; // 11 mbps
+		SupRateLen = 4;
+		ExtRateLen = 0;
+	}
+	else if (pAd->PortCfg.AdhocMode == ADHOC_11BG_MIXED)  //Adhoc Mode 1: B/G mixed.
+	{
+		SupRate[0] = 0x82; // 1 mbps
+		SupRate[1] = 0x84; // 2 mbps
+		SupRate[2] = 0x8b; // 5.5 mbps
+		SupRate[3] = 0x96; // 11 mbps
+		SupRateLen = 4;
+
+		ExtRate[0]	= 0x0C;    // 6 mbps, in units of 0.5 Mbps
+		ExtRate[1]	= 0x12;    // 9 mbps, in units of 0.5 Mbps
+		ExtRate[2]	= 0x18;    // 12 mbps, in units of 0.5 Mbps
+		ExtRate[3]	= 0x24;    // 18 mbps, in units of 0.5 Mbps
+		ExtRate[4]	= 0x30;    // 24 mbps, in units of 0.5 Mbps
+		ExtRate[5]	= 0x48;    // 36 mbps, in units of 0.5 Mbps
+		ExtRate[6]	= 0x60;    // 48 mbps, in units of 0.5 Mbps
+		ExtRate[7]	= 0x6c;    // 54 mbps, in units of 0.5 Mbps
+		ExtRateLen	= 8;
+	}
+	else if ((pAd->PortCfg.AdhocMode == ADHOC_11G) || (pAd->PortCfg.AdhocMode == ADHOC_11A) ||	//Adhoc Mode 2: 11g only 3: 11a only
+			((pAd->PortCfg.PhyMode == PHY_11ABG_MIXED) && (pAd->PortCfg.Channel > 14)))
+	{
+		SupRate[0]	= 0x8C;    // 6 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[1]	= 0x12;    // 9 mbps, in units of 0.5 Mbps
+		SupRate[2]	= 0x98;    // 12 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[3]	= 0x24;    // 18 mbps, in units of 0.5 Mbps
+		SupRate[4]	= 0xb0;    // 24 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[5]	= 0x48;    // 36 mbps, in units of 0.5 Mbps
+		SupRate[6]	= 0x60;    // 48 mbps, in units of 0.5 Mbps
+		SupRate[7]	= 0x6c;    // 54 mbps, in units of 0.5 Mbps
+		SupRateLen	= 8;
+		ExtRateLen	= 0;
+
+		//
+		// Also Update MlmeRate & RtsRate for G only & A only
+		//
+		pAd->PortCfg.MlmeRate = RATE_6;
+		pAd->PortCfg.RtsRate = RATE_6;
+	}
+	else
+	{
+		SupRateLen = pAd->PortCfg.SupRateLen;
+		memcpy(SupRate, pAd->PortCfg.SupRate, SupRateLen);
+		ExtRateLen = pAd->PortCfg.ExtRateLen;
+		memcpy(ExtRate, pAd->PortCfg.ExtRate, ExtRateLen);
+	}
+
+	pAd->ActiveCfg.SupRateLen = SupRateLen;
+	memcpy(pAd->ActiveCfg.SupRate, SupRate, SupRateLen);
+	pAd->ActiveCfg.ExtRateLen = ExtRateLen;
+	memcpy(pAd->ActiveCfg.ExtRate, ExtRate, ExtRateLen);
+
+	// compose IBSS beacon frame
+	MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, BROADCAST_ADDR, pAd->PortCfg.Bssid);
+	Privacy = (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
+			  (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+			  (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled);
+	CapabilityInfo = CAP_GENERATE(0, 1, Privacy, (pAd->PortCfg.TxPreamble == Rt802_11PreambleShort), 0);
+
+	MakeOutgoingFrame(pBeaconFrame, 				&FrameLen,
+					  sizeof(HEADER_802_11),		&BcnHdr,
+					  TIMESTAMP_LEN,				&FakeTimestamp,
+					  2,							&pAd->PortCfg.BeaconPeriod,
+					  2,							&CapabilityInfo,
+					  1,							&SsidIe,
+					  1,							&pAd->PortCfg.SsidLen,
+					  pAd->PortCfg.SsidLen, 		pAd->PortCfg.Ssid,
+					  1,							&SupRateIe,
+					  1,							&SupRateLen,
+					  SupRateLen,					SupRate,
+					  1,							&DsIe,
+					  1,							&DsLen,
+					  1,							&pAd->PortCfg.Channel,
+					  1,							&IbssIe,
+					  1,							&IbssLen,
+					  2,							&pAd->ActiveCfg.AtimWin,
+					  END_OF_ARGS);
+
+	// add ERP_IE and EXT_RAE IE of in 802.11g
+	if (ExtRateLen)
+	{
+		ULONG	tmp;
+
+		MakeOutgoingFrame(pBeaconFrame + FrameLen,		   &tmp,
+						  3,							   LocalErpIe,
+						  1,							   &ExtRateIe,
+						  1,							   &ExtRateLen,
+						  ExtRateLen,					   ExtRate,
+						  END_OF_ARGS);
+		FrameLen += tmp;
+	}
+
+	// If adhoc secruity is set for WPA-None, append the cipher suite IE
+	if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+	{
+		ULONG	tmp;
+
+		if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)		// Tkip
+		{
+			MakeOutgoingFrame(pBeaconFrame + FrameLen,		&tmp,
+							  1,							&WpaIe,
+							  1,							&CipherSuiteWpaNoneTkipLen,
+							  CipherSuiteWpaNoneTkipLen,	&CipherSuiteWpaNoneTkip[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+		else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)	// Aes
+		{
+			MakeOutgoingFrame(pBeaconFrame + FrameLen,	  &tmp,
+							  1,						  &WpaIe,
+							  1,						  &CipherSuiteWpaNoneAesLen,
+							  CipherSuiteWpaNoneAesLen,   &CipherSuiteWpaNoneAes[0],
+							  END_OF_ARGS);
+			FrameLen += tmp;
+		}
+	}
+
+#ifdef BIG_ENDIAN
+	RTMPFrameEndianChange(pAd, pBeaconFrame, DIR_WRITE, FALSE);
+#endif
+
+	RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, TRUE, SHORT_RETRY,
+		IFS_BACKOFF, pAd->PortCfg.MlmeRate, FrameLen, QID_MGMT, PID_MGMT_FRAME, FALSE);
+
+	//
+	// For WiFi four stations beacon fair generation issue.
+	// Modify Beacon's TxD cwmin. Recommend by Jerry.
+	// 1.) Modify MAC register TXRX_CSR10 Bit 7:0
+	// or
+	// 2.) Modify cwmin.
+	//
+	pTxD->Cwmin = 2;
+
+	DBGPRINT(RT_DEBUG_TRACE, "MakeIbssBeacon (len=%d)\n", FrameLen);
+	return FrameLen;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/iwpriv_usage.txt linux-2.6.23.1-stm/drivers/net/wireless/rt73/iwpriv_usage.txt
--- linux-2.6.23.1/drivers/net/wireless/rt73/iwpriv_usage.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/iwpriv_usage.txt	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,274 @@
+iwpriv
+=================
+This is detailed explanation of each parameters for iwpriv.
+Before reading this document, make sure you already read README.
+
+-------------------------------------------------------------------------------------------------------
+USAGE_1:
+	iwpriv wlan0 set [parameters]=[val]
+
+NOTE:
+	Execute one iwpriv/set command simultaneously.
+
+
+DESCRIPTION
+[parameters]        	[val] /{range}
+-----------------   	-------------------------------------------------
+CountryRegion       	{0~7}
+						::Set country region
+						0: 1 ~ 11 ch
+						1: 1 ~ 13 ch
+						2: 10, 11 ch
+						3: 10 ~ 13 ch
+						4: 14 ch
+						5: 1 ~ 14 ch
+						6: 3 ~ 9 ch
+						7: 5 ~ 13 ch
+
+CountryRegionABand		{0~10}
+						::Set country region for A band
+						0: 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165 ch
+						1: 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 ch
+						2: 36, 40, 44, 48, 52, 56, 60, 64 ch
+						3: 52, 56, 60, 64, 149, 153, 157, 161 ch
+						4: 149, 153, 157, 161, 165 ch
+						5: 149, 153, 157, 161 ch
+						6: 36, 40, 44, 48 ch
+						7: 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165 ch
+						8: 52, 56, 60, 64 ch
+						9: 34, 38, 42, 46 ch
+						10: 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64 ch
+
+SSID                	{0~z, 1~32 ascii characters}
+                    	::Set AP SSID
+
+WirelessMode        	{0~4}
+						::Set Wireless Mode
+                    	0:11b/g mixed,
+                    	1:11B only,
+                    	2:11A only
+                    	3:11a/b/g mixed,
+                    	4:11G only
+
+TxRate              	{0~12}
+						::Set TxRate of Infrastructure mode
+                    	0:Auto, 	1:1Mbps,
+                    	2:2Mbps, 	3:5.5Mbps,
+                    	4:11Mbps, 	5:6Mbps,
+                    	6:9Mbps, 	7:12Mbps,
+                    	8:18Mbps, 	9:24Mbps,
+                    	10:36Mbps, 	11:48Mbps,
+                    	12:54Mbps
+
+Channel             	depends on CountryRegion or CountryRegionABand
+                        ::Set Channel
+
+BGProtection        	{0~2}
+						::Set 11B/11G Protection
+                   		0:Auto,
+                   		1:Always on,
+                   		2:Always off
+
+TxPreamble          	{0~2}
+						::Set TxPreamble
+                    	0:Preamble Long,
+                    	1:Preamble Short,
+                    	2:Auto
+
+RTSThreshold        	{1~2347}
+                    	::Set RTS Threshold
+
+FragThreshold       	{256~2346}
+						::Set Fragment Threshold
+
+TxBurst             	{0,1}
+						::Set TxBurst Enable or Disable
+                  		0:Disable,
+                  		1:Enable
+
+NetworkType	    		{Infra,Adhoc}
+    					::Set Network type
+
+AdhocOfdm				{0~3}
+                        ::Set Adhoc Wireless Mode
+    				    0: WIFI mode(11b rates only),
+        				1: b/g mixed,
+        				2: 11g only,
+        				3: 11a only
+
+AuthMode            	{OPEN,SHARED,WEPAUTO,WPAPSK,WPA2PSK,WPANONE}
+                        ::Set Authentication Mode
+
+EncrypType          	{NONE,WEP,TKIP,AES}
+						::Set Encryption Type
+
+DefaultKeyID        	{1~4}
+						::Set Default Key ID
+
+
+Key1                 	{5 ascii characters or 10 hex number or
+                     	13 ascii characters or 26 hex numbers}
+                     	::Set Key1 String
+
+Key2                 	{5 ascii characters or 10 hex number or
+                     	13 ascii characters or 26 hex numbers}
+                      	::Set Key2 String
+
+Key3                 	{5 ascii characters or 10 hex number or
+                     	13 ascii characters or 26 hex numbers}
+						::Set Key3 String
+
+Key4                 	{5 ascii characters or 10 hex number or
+                     	13 ascii characters or 26 hex numbers}
+                        ::Set Key4 String
+
+WPAPSK              	{8~63 ascii or 64 hex characters}
+						::WPA Pre-Shared Key
+
+PSMode					{CAM, MAX_PSP, FAST_PSP}
+                        ::Set Power Saving Mode
+
+IEEE80211H              {0,1}
+                        ::Set IEEE80211H  Enable or Disable
+                        0:	Disable
+                        1:	Enable spectrum management
+                        (This field can be enable only in A band)
+
+
+-------------------------------------------------------------------------------------------------------
+USAGE_2:
+	iwpriv wlan0 [parameters] [val]
+
+
+DESCRIPTION
+[parameters]        	[val] range                             explaination
+-----------------   	-----------------------              ------------------------------------------
+auth                    {1~5}   1:OPEN                          Authentication Mode
+                                2:SHARED
+                                3:WPAPSK
+                                4:WPA2PSK
+                                5:WPANONE
+
+enc                     {1~4}   1:NONE                          Encryption Type
+                                2:WEP
+                                3:TKIP
+                                4:AES
+
+wpapsk                  {8~64 chars}                            WPAPSK/WPA2PSK Password
+
+psm                     {0~2}   0:constantly awake mode (CAM)   Power Saving Mode
+                                1:MAX_PSP
+                                2:FAST_PSP
+
+
+-------------------------------------------------------------------------------------------------------
+
+
+Examples
+=================
+-------------------------------------------------------------------------------------------------------
+a> Config STA to link with AP which is OPEN/NONE(Authentication/Encryption)
+	1. iwpriv wlan0 set NetworkType=Infra
+	2. iwpriv wlan0 set AuthMode=OPEN
+	3. iwpriv wlan0 set EncrypType=NONE
+	4. iwpriv wlan0 set SSID="AP's SSID"
+
+b> Config STA to link with AP and OPEN/WEP(Authentication/Encryption).
+    Default Key ID = 3
+	1. iwconfig wlan0 key [3]
+	2. iwconfig wlan0 key s:abcde
+	3. iwconfig wlan0 essid "AP's SSID"
+
+c> Config STA to link with AP which is SHARED/WEP(Authentication/Encryption).
+	1. iwpriv wlan0 set NetworkType=Infra
+	2. iwpriv wlan0 set AuthMode=SHARED
+	3. iwpriv wlan0 set EncrypType=WEP
+	4. iwpriv wlan0 set Key1="AP's wep key"
+	5. iwpriv wlan0 set DefaultKeyID=1
+	6. iwpriv wlan0 set SSID="AP's SSID"
+
+
+d> Config STA to link with AP which is WPAPSK/TKIP(Authentication/Encryption)
+	1. iwpriv wlan0 set NetworkType=Infra
+	2. iwpriv wlan0 set AuthMode=WPAPSK
+	3. iwpriv wlan0 set EncrypType=TKIP
+	4. iwpriv wlan0 set SSID="AP's SSID"
+	5. iwpriv wlan0 set WPAPSK="12345678"
+	6. iwpriv wlan0 set SSID="AP's SSID"
+
+    p.s Step 4 is part of generating wpapsk password and is necessary.
+
+e> Config STA to link with AP which is WPAPSK/AES(Authentication/Encryption)
+    1. iwconfig wlan0 mode managed
+	2. iwpriv wlan0 auth 3
+	3. iwpriv wlan0 enc  4
+	4. iwconfig wlan0 essid "AP's SSID"
+	5. iwpriv wlan0 wpapsk 12345678
+	6. iwconfig wlan0 essid "AP's SSID"
+
+f> Config STA to link with AP which is WPA2PSK/TKIP(Authentication/Encryption)
+	1. iwpriv wlan0 set NetworkType=Infra
+	2. iwpriv wlan0 set AuthMode=WPA2PSK
+	3. iwpriv wlan0 set EncrypType=TKIP
+	4. iwpriv wlan0 set SSID="AP's SSID"
+	5. iwpriv wlan0 set WPAPSK="12345678"
+	6. iwpriv wlan0 set SSID="AP's SSID"
+
+g> Config STA to create/link as adhoc mode, which is OPEN/NONE(Authentication/Encryption)
+	1. iwpriv wlan0 set NetworkType=Adhoc
+	2. iwpriv wlan0 set AuthMode=OPEN
+	3. iwpriv wlan0 set EncrypType=NONE
+	4. iwpriv wlan0 set SSID="Adhoc's SSID"
+
+h>  Config STA to create/link as adhoc mode, which is WPANONE/TKIP(Authentication/Encryption)
+    1. iwpriv wlan0 set NetworkType=Adhoc
+	2. iwpriv wlan0 set AuthMode=WPANONE
+	3. iwpriv wlan0 set EncrypType=TKIP
+	4. iwpriv wlan0 set SSID="AP's SSID"
+	5. iwpriv wlan0 set WPAPSK=12345678
+	6. iwpriv wlan0 set SSID="AP's SSID"
+
+i> Get site survey
+    iwpriv wlan0 get_site_survey
+
+j> Get Statistics
+    iwpriv wlan0 stat						; read statistic counter
+    iwpriv wlan0 set ResetCounter=0		; reset statistic counter
+
+k> Link with any AP without security        ; set ANY SSID (ssidLen=0)
+   usage: iwconfig ra0 essid ""
+   or
+   usage: iwpriv ra0 set SSID=""
+
+===================================================================
+
+iwlist
+=================
+This is detailed explanation of each parameters for iwlist.
+
+-------------------------------------------------------------------------------------------------------
+iwlist wlan0 scanning		; list the results after scanning(manual rescan)
+
+
+=======================================================================================================
+
+iwconfig
+=================
+The following are our support in standard configuration - iwconfig
+
+-------------------------------------------------------------------------------------------------------
+iwconfig wlan0 essid {NN|on|off}		        ; set ssid
+iwconfig wlan0 mode {managed|ad-hoc|...}       ; set wireless mode
+iwconfig wlan0 freq N.NNNN[k|M|G]]		        ; set frequency
+iwconfig wlan0 channel N					    ; set channel
+iwconfig wlan0 ap {N|off|auto}			        ; set ap address
+iwconfig wlan0 nick N						    ; set nickname
+iwconfig wlan0 rate {N|auto|fixed}     	    ; set rate
+iwconfig wlan0 rts {N|auto|fixed|off}		    ; set rts threshold
+iwconfig wlan0 frag {N|auto|fixed|off}	        ; set fragment threshold
+iwconfig wlan0 enc {NNNN-NNNN|off}		        ; set encryption type
+iwconfig wlan0 power {period N|timeout N}	    ; set power management modes
+iwconfig wlan0 key {[id]|s:pswd|pswd}          ; set wep key
+
+*** Please refer to man page of 'iwconfig', 'iwlist' and 'iwpriv'. ***
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/md5.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/md5.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/md5.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/md5.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1199 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	md5.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	jan		10-28-03	Initial
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/**
+ * md5_mac:
+ * @key: pointer to the key used for MAC generation
+ * @key_len: length of the key in bytes
+ * @data: pointer to the data area for which the MAC is generated
+ * @data_len: length of the data in bytes
+ * @mac: pointer to the buffer holding space for the MAC; the buffer should
+ * have space for 128-bit (16 bytes) MD5 hash value
+ *
+ * md5_mac() determines the message authentication code by using secure hash
+ * MD5(key | data | key).
+ */
+void md5_mac(u8 *key, size_t key_len, u8 *data, size_t data_len, u8 *mac)
+{
+    MD5_CTX context;
+
+    MD5Init(&context);
+    MD5Update(&context, key, key_len);
+    MD5Update(&context, data, data_len);
+    MD5Update(&context, key, key_len);
+    MD5Final(mac, &context);
+}
+
+/**
+ * hmac_md5:
+ * @key: pointer to the key used for MAC generation
+ * @key_len: length of the key in bytes
+ * @data: pointer to the data area for which the MAC is generated
+ * @data_len: length of the data in bytes
+ * @mac: pointer to the buffer holding space for the MAC; the buffer should
+ * have space for 128-bit (16 bytes) MD5 hash value
+ *
+ * hmac_md5() determines the message authentication code using HMAC-MD5.
+ * This implementation is based on the sample code presented in RFC 2104.
+ */
+void hmac_md5(u8 *key, size_t key_len, u8 *data, size_t data_len, u8 *mac)
+{
+    MD5_CTX context;
+    u8 k_ipad[65]; /* inner padding - key XORd with ipad */
+    u8 k_opad[65]; /* outer padding - key XORd with opad */
+    u8 tk[16];
+    int i;
+
+    //assert(key != NULL && data != NULL && mac != NULL);
+
+    /* if key is longer than 64 bytes reset it to key = MD5(key) */
+    if (key_len > 64) {
+        MD5_CTX ttcontext;
+
+        MD5Init(&ttcontext);
+        MD5Update(&ttcontext, key, key_len);
+        MD5Final(tk, &ttcontext);
+        //key=(PUCHAR)ttcontext.buf;
+        key = tk;
+        key_len = 16;
+    }
+
+    /* the HMAC_MD5 transform looks like:
+     *
+     * MD5(K XOR opad, MD5(K XOR ipad, text))
+     *
+     * where K is an n byte key
+     * ipad is the byte 0x36 repeated 64 times
+     * opad is the byte 0x5c repeated 64 times
+     * and text is the data being protected */
+
+    /* start out by storing key in pads */
+    memset(k_ipad, 0, sizeof(k_ipad));
+    memset(k_opad, 0, sizeof(k_opad));
+    //assert(key_len < sizeof(k_ipad));
+    memcpy(k_ipad, key, key_len);
+    memcpy(k_opad, key, key_len);
+
+    /* XOR key with ipad and opad values */
+    for (i = 0; i < 64; i++) {
+        k_ipad[i] ^= 0x36;
+        k_opad[i] ^= 0x5c;
+    }
+
+    /* perform inner MD5 */
+    MD5Init(&context);                   /* init context for 1st pass */
+    MD5Update(&context, k_ipad, 64);     /* start with inner pad */
+    MD5Update(&context, data, data_len); /* then text of datagram */
+    MD5Final(mac, &context);             /* finish up 1st pass */
+
+    /* perform outer MD5 */
+    MD5Init(&context);                   /* init context for 2nd pass */
+    MD5Update(&context, k_opad, 64);     /* start with outer pad */
+    MD5Update(&context, mac, 16);        /* then results of 1st hash */
+    MD5Final(mac, &context);             /* finish up 2nd pass */
+}
+
+
+/* ===== start - public domain MD5 implementation ===== */
+/*
+ * This code implements the MD5 message-digest algorithm.
+ * The algorithm is due to Ron Rivest.  This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+
+#ifndef BIG_ENDIAN
+#define byteReverse(buf, len)   /* Nothing */
+#else
+void byteReverse(unsigned char *buf, unsigned longs);
+void byteReverse(unsigned char *buf, unsigned longs)
+{
+    do {
+        *(ULONG *)buf = SWAP32(*(ULONG *)buf);
+        buf += 4;
+    } while (--longs);
+}
+#endif
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+void MD5Init(struct MD5Context *ctx)
+{
+    ctx->buf[0] = 0x67452301;
+    ctx->buf[1] = 0xefcdab89;
+    ctx->buf[2] = 0x98badcfe;
+    ctx->buf[3] = 0x10325476;
+
+    ctx->bits[0] = 0;
+    ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len)
+{
+    u32 t;
+
+    /* Update bitcount */
+
+    t = ctx->bits[0];
+    if ((ctx->bits[0] = t + ((u32) len << 3)) < t)
+        ctx->bits[1]++;     /* Carry from low to high */
+    ctx->bits[1] += len >> 29;
+
+    t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */
+
+    /* Handle any leading odd-sized chunks */
+
+    if (t) {
+        unsigned char *p = (unsigned char *) ctx->in + t;
+
+        t = 64 - t;
+        if (len < t) {
+            memcpy(p, buf, len);
+            return;
+        }
+        memcpy(p, buf, t);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (u32 *) ctx->in);
+        buf += t;
+        len -= t;
+    }
+    /* Process data in 64-byte chunks */
+
+    while (len >= 64) {
+        memcpy(ctx->in, buf, 64);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (u32 *) ctx->in);
+        buf += 64;
+        len -= 64;
+    }
+
+    /* Handle any remaining bytes of data. */
+
+    memcpy(ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
+{
+    unsigned count;
+    unsigned char *p;
+
+    /* Compute number of bytes mod 64 */
+    count = (ctx->bits[0] >> 3) & 0x3F;
+
+    /* Set the first char of padding to 0x80.  This is safe since there is
+       always at least one byte free */
+    p = ctx->in + count;
+    *p++ = 0x80;
+
+    /* Bytes of padding needed to make 64 bytes */
+    count = 64 - 1 - count;
+
+    /* Pad out to 56 mod 64 */
+    if (count < 8) {
+        /* Two lots of padding:  Pad the first block to 64 bytes */
+        memset(p, 0, count);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (u32 *) ctx->in);
+
+        /* Now fill the next block with 56 bytes */
+        memset(ctx->in, 0, 56);
+    } else {
+        /* Pad block to 56 bytes */
+        memset(p, 0, count - 8);
+    }
+    byteReverse(ctx->in, 14);
+
+    /* Append length in bits and transform */
+    ((u32 *) ctx->in)[14] = ctx->bits[0];
+    ((u32 *) ctx->in)[15] = ctx->bits[1];
+
+    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    byteReverse((unsigned char *) ctx->buf, 4);
+    memcpy(digest, ctx->buf, 16);
+    memset(ctx, 0, sizeof(ctx));  /* In case it's sensitive */
+}
+
+//#ifndef ASM_MD5
+#if 1
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+    ( w += f(x, y, z) + data,  w =( w<<s | w>>(32-s))&0xffffffff,  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+void MD5Transform(u32 buf[4], u32 in[16])
+{
+    register u32 a, b, c, d;
+
+    a = buf[0];
+    b = buf[1];
+    c = buf[2];
+    d = buf[3];
+
+    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+    buf[0] += a;
+    buf[1] += b;
+    buf[2] += c;
+    buf[3] += d;
+}
+#endif
+
+void SHAInit(SHA_CTX *ctx) {
+    int i;
+
+    ctx->lenW = 0;
+    ctx->sizeHi = ctx->sizeLo = 0;
+
+    /* Initialize H with the magic constants (see FIPS180 for constants)
+     */
+    ctx->H[0] = 0x67452301L;
+    ctx->H[1] = 0xefcdab89L;
+    ctx->H[2] = 0x98badcfeL;
+    ctx->H[3] = 0x10325476L;
+    ctx->H[4] = 0xc3d2e1f0L;
+
+    for (i = 0; i < 80; i++)
+        ctx->W[i] = 0;
+ }
+
+#define SHA_ROTL(X,n) ((((X) << (n)) | ((X) >> (32-(n)))) & 0xffffffffL)
+
+void SHAHashBlock(SHA_CTX *ctx) {
+    int t;
+    ULONG A,B,C,D,E,TEMP;
+
+    for (t = 16; t <= 79; t++)
+        ctx->W[t] = SHA_ROTL(ctx->W[t-3] ^ ctx->W[t-8] ^ ctx->W[t-14] ^ ctx->W[t-16], 1);
+
+    A = ctx->H[0];
+    B = ctx->H[1];
+    C = ctx->H[2];
+    D = ctx->H[3];
+    E = ctx->H[4];
+
+    for (t = 0; t <= 19; t++) {
+        TEMP = (SHA_ROTL(A,5) + (((C^D)&B)^D)     + E + ctx->W[t] + 0x5a827999L) & 0xffffffffL;
+        E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+    }
+    for (t = 20; t <= 39; t++) {
+        TEMP = (SHA_ROTL(A,5) + (B^C^D)           + E + ctx->W[t] + 0x6ed9eba1L) & 0xffffffffL;
+        E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+    }
+    for (t = 40; t <= 59; t++) {
+        TEMP = (SHA_ROTL(A,5) + ((B&C)|(D&(B|C))) + E + ctx->W[t] + 0x8f1bbcdcL) & 0xffffffffL;
+        E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+    }
+    for (t = 60; t <= 79; t++) {
+        TEMP = (SHA_ROTL(A,5) + (B^C^D)           + E + ctx->W[t] + 0xca62c1d6L) & 0xffffffffL;
+        E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+    }
+
+    ctx->H[0] += A;
+    ctx->H[1] += B;
+    ctx->H[2] += C;
+    ctx->H[3] += D;
+    ctx->H[4] += E;
+}
+
+void SHAUpdate(SHA_CTX *ctx, unsigned char *dataIn, int len)
+{
+    int i;
+
+    /* Read the data into W and process blocks as they get full
+     */
+    for (i = 0; i < len; i++) {
+        ctx->W[ctx->lenW / 4] <<= 8;
+        ctx->W[ctx->lenW / 4] |= (ULONG)dataIn[i];
+        if ((++ctx->lenW) % 64 == 0) {
+            SHAHashBlock(ctx);
+            ctx->lenW = 0;
+        }
+        ctx->sizeLo += 8;
+        ctx->sizeHi += (ctx->sizeLo < 8);
+    }
+}
+
+
+void SHAFinal(SHA_CTX *ctx, unsigned char hashout[20]) {
+    unsigned char pad0x80 = 0x80;
+    unsigned char pad0x00 = 0x00;
+    unsigned char padlen[8];
+    int i;
+
+    /* Pad with a binary 1 (e.g. 0x80), then zeroes, then length
+     */
+    padlen[0] = (unsigned char)((ctx->sizeHi >> 24) & 255);
+    padlen[1] = (unsigned char)((ctx->sizeHi >> 16) & 255);
+    padlen[2] = (unsigned char)((ctx->sizeHi >> 8) & 255);
+    padlen[3] = (unsigned char)((ctx->sizeHi >> 0) & 255);
+    padlen[4] = (unsigned char)((ctx->sizeLo >> 24) & 255);
+    padlen[5] = (unsigned char)((ctx->sizeLo >> 16) & 255);
+    padlen[6] = (unsigned char)((ctx->sizeLo >> 8) & 255);
+    padlen[7] = (unsigned char)((ctx->sizeLo >> 0) & 255);
+    SHAUpdate(ctx, &pad0x80, 1);
+    while (ctx->lenW != 56)
+        SHAUpdate(ctx, &pad0x00, 1);
+    SHAUpdate(ctx, padlen, 8);
+
+    /* Output hash
+     */
+    for (i = 0; i < 20; i++) {
+        hashout[i] = (unsigned char)(ctx->H[i / 4] >> 24);
+        ctx->H[i / 4] <<= 8;
+    }
+
+    /*
+     *  Re-initialize the context (also zeroizes contents)
+     */
+    SHAInit(ctx);
+}
+
+/* forward S-box */
+
+static uint32 FSb[256] =
+{
+    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/* forward table */
+
+#define FT \
+\
+    V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \
+    V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \
+    V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \
+    V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \
+    V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \
+    V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \
+    V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \
+    V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \
+    V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \
+    V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \
+    V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \
+    V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \
+    V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \
+    V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \
+    V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \
+    V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \
+    V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \
+    V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \
+    V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \
+    V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \
+    V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \
+    V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \
+    V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \
+    V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \
+    V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \
+    V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \
+    V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \
+    V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \
+    V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \
+    V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \
+    V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \
+    V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \
+    V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \
+    V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \
+    V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \
+    V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \
+    V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \
+    V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \
+    V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \
+    V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \
+    V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \
+    V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \
+    V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \
+    V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \
+    V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \
+    V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \
+    V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \
+    V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \
+    V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \
+    V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \
+    V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \
+    V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \
+    V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \
+    V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \
+    V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \
+    V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \
+    V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \
+    V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \
+    V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \
+    V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \
+    V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \
+    V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \
+    V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \
+    V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static uint32 FT0[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static uint32 FT1[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static uint32 FT2[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static uint32 FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static uint32 RSb[256] =
+{
+    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/* reverse table */
+
+#define RT \
+\
+    V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \
+    V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \
+    V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \
+    V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \
+    V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \
+    V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \
+    V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \
+    V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \
+    V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \
+    V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \
+    V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \
+    V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \
+    V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \
+    V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \
+    V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \
+    V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \
+    V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \
+    V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \
+    V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \
+    V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \
+    V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \
+    V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \
+    V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \
+    V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \
+    V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \
+    V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \
+    V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \
+    V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \
+    V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \
+    V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \
+    V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \
+    V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \
+    V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \
+    V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \
+    V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \
+    V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \
+    V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \
+    V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \
+    V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \
+    V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \
+    V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \
+    V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \
+    V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \
+    V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \
+    V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \
+    V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \
+    V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \
+    V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \
+    V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \
+    V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \
+    V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \
+    V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \
+    V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \
+    V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \
+    V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \
+    V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \
+    V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \
+    V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \
+    V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \
+    V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \
+    V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \
+    V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \
+    V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \
+    V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static uint32 RT0[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static uint32 RT1[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static uint32 RT2[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static uint32 RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static uint32 RCON[10] =
+{
+    0x01000000, 0x02000000, 0x04000000, 0x08000000,
+    0x10000000, 0x20000000, 0x40000000, 0x80000000,
+    0x1B000000, 0x36000000
+};
+
+/* key schedule tables */
+
+static int KT_init = 1;
+
+static uint32 KT0[256];
+static uint32 KT1[256];
+static uint32 KT2[256];
+static uint32 KT3[256];
+
+/* platform-independant 32-bit integer manipulation macros */
+
+#define GET_UINT32(n,b,i)                       \
+{                                               \
+    (n) = ( (uint32) (b)[(i)    ] << 24 )       \
+        | ( (uint32) (b)[(i) + 1] << 16 )       \
+        | ( (uint32) (b)[(i) + 2] <<  8 )       \
+        | ( (uint32) (b)[(i) + 3]       );      \
+}
+
+#define PUT_UINT32(n,b,i)                       \
+{                                               \
+    (b)[(i)    ] = (uint8) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (uint8) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (uint8) ( (n)       );       \
+}
+
+/* AES key scheduling routine */
+
+int aes_set_key( aes_context *ctx, uint8 *key, int nbits )
+{
+    int i;
+    uint32 *RK, *SK;
+
+    switch( nbits )
+    {
+        case 128: ctx->nr = 10; break;
+        case 192: ctx->nr = 12; break;
+        case 256: ctx->nr = 14; break;
+        default : return( 1 );
+    }
+
+    RK = ctx->erk;
+
+    for( i = 0; i < (nbits >> 5); i++ )
+    {
+        GET_UINT32( RK[i], key, i * 4 );
+    }
+
+    /* setup encryption round keys */
+
+    switch( nbits )
+    {
+    case 128:
+
+        for( i = 0; i < 10; i++, RK += 4 )
+        {
+            RK[4]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[3] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[3] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[3]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[3] >> 24 ) ]       );
+
+            RK[5]  = RK[1] ^ RK[4];
+            RK[6]  = RK[2] ^ RK[5];
+            RK[7]  = RK[3] ^ RK[6];
+        }
+        break;
+
+    case 192:
+
+        for( i = 0; i < 8; i++, RK += 6 )
+        {
+            RK[6]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[5] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[5] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[5]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[5] >> 24 ) ]       );
+
+            RK[7]  = RK[1] ^ RK[6];
+            RK[8]  = RK[2] ^ RK[7];
+            RK[9]  = RK[3] ^ RK[8];
+            RK[10] = RK[4] ^ RK[9];
+            RK[11] = RK[5] ^ RK[10];
+        }
+        break;
+
+    case 256:
+
+        for( i = 0; i < 7; i++, RK += 8 )
+        {
+            RK[8]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[7] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[7] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[7]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[7] >> 24 ) ]       );
+
+            RK[9]  = RK[1] ^ RK[8];
+            RK[10] = RK[2] ^ RK[9];
+            RK[11] = RK[3] ^ RK[10];
+
+            RK[12] = RK[4] ^
+                        ( FSb[ (uint8) ( RK[11] >> 24 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[11] >> 16 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[11] >>  8 ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[11]       ) ]       );
+
+            RK[13] = RK[5] ^ RK[12];
+            RK[14] = RK[6] ^ RK[13];
+            RK[15] = RK[7] ^ RK[14];
+        }
+        break;
+    }
+
+    /* setup decryption round keys */
+
+    if( KT_init )
+    {
+        for( i = 0; i < 256; i++ )
+        {
+            KT0[i] = RT0[ FSb[i] ];
+            KT1[i] = RT1[ FSb[i] ];
+            KT2[i] = RT2[ FSb[i] ];
+            KT3[i] = RT3[ FSb[i] ];
+        }
+
+        KT_init = 0;
+    }
+
+    SK = ctx->drk;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    for( i = 1; i < ctx->nr; i++ )
+    {
+        RK -= 8;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+    }
+
+    RK -= 8;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    return( 0 );
+}
+
+/* AES 128-bit block encryption routine */
+
+void aes_encrypt(aes_context *ctx, uint8 input[16], uint8 output[16] )
+{
+    uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    RK = ctx->erk;
+    GET_UINT32( X0, input,  0 ); X0 ^= RK[0];
+    GET_UINT32( X1, input,  4 ); X1 ^= RK[1];
+    GET_UINT32( X2, input,  8 ); X2 ^= RK[2];
+    GET_UINT32( X3, input, 12 ); X3 ^= RK[3];
+
+#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    RK += 4;                                    \
+                                                \
+    X0 = RK[0] ^ FT0[ (uint8) ( Y0 >> 24 ) ] ^  \
+                 FT1[ (uint8) ( Y1 >> 16 ) ] ^  \
+                 FT2[ (uint8) ( Y2 >>  8 ) ] ^  \
+                 FT3[ (uint8) ( Y3       ) ];   \
+                                                \
+    X1 = RK[1] ^ FT0[ (uint8) ( Y1 >> 24 ) ] ^  \
+                 FT1[ (uint8) ( Y2 >> 16 ) ] ^  \
+                 FT2[ (uint8) ( Y3 >>  8 ) ] ^  \
+                 FT3[ (uint8) ( Y0       ) ];   \
+                                                \
+    X2 = RK[2] ^ FT0[ (uint8) ( Y2 >> 24 ) ] ^  \
+                 FT1[ (uint8) ( Y3 >> 16 ) ] ^  \
+                 FT2[ (uint8) ( Y0 >>  8 ) ] ^  \
+                 FT3[ (uint8) ( Y1       ) ];   \
+                                                \
+    X3 = RK[3] ^ FT0[ (uint8) ( Y3 >> 24 ) ] ^  \
+                 FT1[ (uint8) ( Y0 >> 16 ) ] ^  \
+                 FT2[ (uint8) ( Y1 >>  8 ) ] ^  \
+                 FT3[ (uint8) ( Y2       ) ];   \
+}
+
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 1 */
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 2 */
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 3 */
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 4 */
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 5 */
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 6 */
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 7 */
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 8 */
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 9 */
+
+    if( ctx->nr > 10 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );   /* round 10 */
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );   /* round 11 */
+    }
+
+    if( ctx->nr > 12 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );   /* round 12 */
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );   /* round 13 */
+    }
+
+    /* last round */
+
+    RK += 4;
+
+    X0 = RK[0] ^ ( FSb[ (uint8) ( Y0 >> 24 ) ] << 24 ) ^
+                 ( FSb[ (uint8) ( Y1 >> 16 ) ] << 16 ) ^
+                 ( FSb[ (uint8) ( Y2 >>  8 ) ] <<  8 ) ^
+                 ( FSb[ (uint8) ( Y3       ) ]       );
+
+    X1 = RK[1] ^ ( FSb[ (uint8) ( Y1 >> 24 ) ] << 24 ) ^
+                 ( FSb[ (uint8) ( Y2 >> 16 ) ] << 16 ) ^
+                 ( FSb[ (uint8) ( Y3 >>  8 ) ] <<  8 ) ^
+                 ( FSb[ (uint8) ( Y0       ) ]       );
+
+    X2 = RK[2] ^ ( FSb[ (uint8) ( Y2 >> 24 ) ] << 24 ) ^
+                 ( FSb[ (uint8) ( Y3 >> 16 ) ] << 16 ) ^
+                 ( FSb[ (uint8) ( Y0 >>  8 ) ] <<  8 ) ^
+                 ( FSb[ (uint8) ( Y1       ) ]       );
+
+    X3 = RK[3] ^ ( FSb[ (uint8) ( Y3 >> 24 ) ] << 24 ) ^
+                 ( FSb[ (uint8) ( Y0 >> 16 ) ] << 16 ) ^
+                 ( FSb[ (uint8) ( Y1 >>  8 ) ] <<  8 ) ^
+                 ( FSb[ (uint8) ( Y2       ) ]       );
+
+    PUT_UINT32( X0, output,  0 );
+    PUT_UINT32( X1, output,  4 );
+    PUT_UINT32( X2, output,  8 );
+    PUT_UINT32( X3, output, 12 );
+}
+
+/* AES 128-bit block decryption routine */
+
+void aes_decrypt( aes_context *ctx, uint8 input[16], uint8 output[16] )
+{
+    uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    RK = ctx->drk;
+
+    GET_UINT32( X0, input,  0 ); X0 ^= RK[0];
+    GET_UINT32( X1, input,  4 ); X1 ^= RK[1];
+    GET_UINT32( X2, input,  8 ); X2 ^= RK[2];
+    GET_UINT32( X3, input, 12 ); X3 ^= RK[3];
+
+#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    RK += 4;                                    \
+                                                \
+    X0 = RK[0] ^ RT0[ (uint8) ( Y0 >> 24 ) ] ^  \
+                 RT1[ (uint8) ( Y3 >> 16 ) ] ^  \
+                 RT2[ (uint8) ( Y2 >>  8 ) ] ^  \
+                 RT3[ (uint8) ( Y1       ) ];   \
+                                                \
+    X1 = RK[1] ^ RT0[ (uint8) ( Y1 >> 24 ) ] ^  \
+                 RT1[ (uint8) ( Y0 >> 16 ) ] ^  \
+                 RT2[ (uint8) ( Y3 >>  8 ) ] ^  \
+                 RT3[ (uint8) ( Y2       ) ];   \
+                                                \
+    X2 = RK[2] ^ RT0[ (uint8) ( Y2 >> 24 ) ] ^  \
+                 RT1[ (uint8) ( Y1 >> 16 ) ] ^  \
+                 RT2[ (uint8) ( Y0 >>  8 ) ] ^  \
+                 RT3[ (uint8) ( Y3       ) ];   \
+                                                \
+    X3 = RK[3] ^ RT0[ (uint8) ( Y3 >> 24 ) ] ^  \
+                 RT1[ (uint8) ( Y2 >> 16 ) ] ^  \
+                 RT2[ (uint8) ( Y1 >>  8 ) ] ^  \
+                 RT3[ (uint8) ( Y0       ) ];   \
+}
+
+    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 1 */
+    AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 2 */
+    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 3 */
+    AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 4 */
+    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 5 */
+    AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 6 */
+    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 7 */
+    AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );       /* round 8 */
+    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );       /* round 9 */
+
+    if( ctx->nr > 10 )
+    {
+        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );   /* round 10 */
+        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );   /* round 11 */
+    }
+
+    if( ctx->nr > 12 )
+    {
+        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );   /* round 12 */
+        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );   /* round 13 */
+    }
+
+    /* last round */
+
+    RK += 4;
+
+    X0 = RK[0] ^ ( RSb[ (uint8) ( Y0 >> 24 ) ] << 24 ) ^
+                 ( RSb[ (uint8) ( Y3 >> 16 ) ] << 16 ) ^
+                 ( RSb[ (uint8) ( Y2 >>  8 ) ] <<  8 ) ^
+                 ( RSb[ (uint8) ( Y1       ) ]       );
+
+    X1 = RK[1] ^ ( RSb[ (uint8) ( Y1 >> 24 ) ] << 24 ) ^
+                 ( RSb[ (uint8) ( Y0 >> 16 ) ] << 16 ) ^
+                 ( RSb[ (uint8) ( Y3 >>  8 ) ] <<  8 ) ^
+                 ( RSb[ (uint8) ( Y2       ) ]       );
+
+    X2 = RK[2] ^ ( RSb[ (uint8) ( Y2 >> 24 ) ] << 24 ) ^
+                 ( RSb[ (uint8) ( Y1 >> 16 ) ] << 16 ) ^
+                 ( RSb[ (uint8) ( Y0 >>  8 ) ] <<  8 ) ^
+                 ( RSb[ (uint8) ( Y3       ) ]       );
+
+    X3 = RK[3] ^ ( RSb[ (uint8) ( Y3 >> 24 ) ] << 24 ) ^
+                 ( RSb[ (uint8) ( Y2 >> 16 ) ] << 16 ) ^
+                 ( RSb[ (uint8) ( Y1 >>  8 ) ] <<  8 ) ^
+                 ( RSb[ (uint8) ( Y0       ) ]       );
+
+    PUT_UINT32( X0, output,  0 );
+    PUT_UINT32( X1, output,  4 );
+    PUT_UINT32( X2, output,  8 );
+    PUT_UINT32( X3, output, 12 );
+}
+
+void hmac_sha1(unsigned char *text, int text_len, unsigned char *key, int key_len, unsigned char *digest)
+{
+    SHA_CTX context;
+    unsigned char k_ipad[65]; /* inner padding - key XORd with ipad */
+    unsigned char k_opad[65]; /* outer padding - key XORd with opad */
+    int i;
+
+    /* if key is longer than 64 bytes reset it to key=SHA1(key) */
+    if (key_len > 64)
+    {
+        SHA_CTX tctx;
+
+        SHAInit(&tctx);
+        SHAUpdate(&tctx, key, key_len);
+        SHAFinal(&tctx, key);
+
+        key_len = 20;
+    }
+
+    /*
+    * the HMAC_SHA1 transform looks like:
+    *
+    * SHA1(K XOR opad, SHA1(K XOR ipad, text))
+    *
+    * where K is an n byte key
+    * ipad is the byte 0x36 repeated 64 times
+    * opad is the byte 0x5c repeated 64 times
+    * and text is the data being protected
+    */
+
+    /* start out by storing key in pads */
+    memset(k_ipad, 0, sizeof k_ipad);
+    memset(k_opad, 0, sizeof k_opad);
+    memcpy(k_ipad, key, key_len);
+    memcpy(k_opad, key, key_len);
+
+    /* XOR key with ipad and opad values */
+    for (i = 0; i < 64; i++)
+    {
+        k_ipad[i] ^= 0x36;
+        k_opad[i] ^= 0x5c;
+    }
+
+    /* perform inner SHA1*/
+    SHAInit(&context); /* init context for 1st pass */
+    SHAUpdate(&context, k_ipad, 64); /* start with inner pad */
+    SHAUpdate(&context, text, text_len); /* then text of datagram */
+    SHAFinal(&context, digest); /* finish up 1st pass */
+
+    /* perform outer SHA1 */
+    SHAInit(&context); /* init context for 2nd pass */
+    SHAUpdate(&context, k_opad, 64); /* start with outer pad */
+    SHAUpdate(&context, digest, 20); /* then results of 1st hash */
+    SHAFinal(&context, digest); /* finish up 2nd pass */
+}
+
+/*
+* F(P, S, c, i) = U1 xor U2 xor ... Uc
+* U1 = PRF(P, S || Int(i))
+* U2 = PRF(P, U1)
+* Uc = PRF(P, Uc-1)
+*/
+
+void F(char *password, unsigned char *ssid, int ssidlength, int iterations, int count, unsigned char *output)
+{
+    unsigned char digest[36], digest1[SHA_DIGEST_LEN];
+    int i, j;
+
+    /* U1 = PRF(P, S || int(i)) */
+    memcpy(digest, ssid, ssidlength);
+    digest[ssidlength] = (unsigned char)((count>>24) & 0xff);
+    digest[ssidlength+1] = (unsigned char)((count>>16) & 0xff);
+    digest[ssidlength+2] = (unsigned char)((count>>8) & 0xff);
+    digest[ssidlength+3] = (unsigned char)(count & 0xff);
+    hmac_sha1(digest, ssidlength+4, (unsigned char*) password, (int) strlen(password), digest1); // for WPA update
+
+    /* output = U1 */
+    memcpy(output, digest1, SHA_DIGEST_LEN);
+
+    for (i = 1; i < iterations; i++)
+    {
+        /* Un = PRF(P, Un-1) */
+        hmac_sha1(digest1, SHA_DIGEST_LEN, (unsigned char*) password, (int) strlen(password), digest); // for WPA update
+        memcpy(digest1, digest, SHA_DIGEST_LEN);
+
+        /* output = output xor Un */
+        for (j = 0; j < SHA_DIGEST_LEN; j++)
+        {
+            output[j] ^= digest[j];
+        }
+    }
+}
+/*
+* password - ascii string up to 63 characters in length
+* ssid - octet string up to 32 octets
+* ssidlength - length of ssid in octets
+* output must be 40 octets in length and outputs 256 bits of key
+*/
+int PasswordHash(char *password, unsigned char *ssid, int ssidlength, unsigned char *output)
+{
+    if ((strlen(password) > 63) || (ssidlength > 32))
+        return 0;
+
+    F(password, ssid, ssidlength, 4096, 1, output);
+    F(password, ssid, ssidlength, 4096, 2, &output[SHA_DIGEST_LEN]);
+    return 1;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/md5.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/md5.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/md5.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,97 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	md5.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *
+ ***************************************************************************/
+
+#ifndef MD5_H
+#define MD5_H
+
+#define MD5_MAC_LEN 16
+#define SHA_DIGEST_LEN 20
+
+struct MD5Context {
+    u32 buf[4];
+    u32 bits[2];
+    u8 in[64];
+};
+
+void MD5Init(struct MD5Context *context);
+void MD5Update(struct MD5Context *context, unsigned char *buf, unsigned len);
+void MD5Final(unsigned char digest[16], struct MD5Context *context);
+void MD5Transform(u32 buf[4], u32 in[16]);
+
+typedef struct MD5Context MD5_CTX;
+
+
+void md5_mac(u8 *key, size_t key_len, u8 *data, size_t data_len, u8 *mac);
+void hmac_md5(u8 *key,  size_t key_len, u8 *data, size_t data_len, u8 *mac);
+
+//
+// SHA context
+//
+typedef struct
+{
+	ULONG		H[5];
+	ULONG		W[80];
+	INT 		lenW;
+	ULONG		sizeHi, sizeLo;
+}	SHA_CTX;
+
+VOID 	SHAInit(SHA_CTX *ctx);
+VOID 	SHAHashBlock(SHA_CTX *ctx);
+VOID	SHAUpdate(SHA_CTX *ctx, unsigned char *dataIn, int len);
+VOID	SHAFinal(SHA_CTX *ctx, unsigned char hashout[20]);
+
+#endif // MD5_H
+
+
+
+#ifndef _AES_H
+#define _AES_H
+
+typedef struct
+{
+    uint32 erk[64];     // encryption round keys
+    uint32 drk[64];     // decryption round keys
+    int nr;             // number of rounds
+}aes_context;
+
+int  aes_set_key( aes_context *ctx, uint8 *key, int nbits );
+void aes_encrypt( aes_context *ctx, uint8 input[16], uint8 output[16] );
+void aes_decrypt( aes_context *ctx, uint8 input[16], uint8 output[16] );
+
+void hmac_sha1(unsigned char *text, int text_len, unsigned char *key, int key_len, unsigned char *digest);
+void F(char *password, unsigned char *ssid, int ssidlength, int iterations, int count, unsigned char *output);
+int PasswordHash(char *password, unsigned char *ssid, int ssidlength, unsigned char *output);
+
+#endif // aes.h
+
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/mlme.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/mlme.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/mlme.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/mlme.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,6200 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	mlme.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	John Chang	2004-08-25	Modify from RT2500 code base
+ *	John Chang	2004-09-06	modified for RT2600
+ *	idamlaj	05-10-2006	Import rfmon implementation
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+#include <stdarg.h>
+#include <net/iw_handler.h>
+
+
+// since RT61 has better RX sensibility, we have to limit TX ACK rate not to exceed our normal data TX rate.
+// otherwise the WLAN peer may not be able to receive the ACK thus downgrade its data TX rate
+ULONG BasicRateMask[12] 		   = {0xfffff001 /* 1-Mbps */, 0xfffff003 /* 2 Mbps */, 0xfffff007 /* 5.5 */, 0xfffff00f /* 11 */,
+									  0xfffff01f /* 6 */	 , 0xfffff03f /* 9 */	  , 0xfffff07f /* 12 */ , 0xfffff0ff /* 18 */,
+									  0xfffff1ff /* 24 */	 , 0xfffff3ff /* 36 */	  , 0xfffff7ff /* 48 */ , 0xffffffff /* 54 */};
+
+UCHAR BROADCAST_ADDR[MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN]  = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+// e.g. RssiSafeLevelForTxRate[RATE_36]" means if the current RSSI is greater than
+//		this value, then it's quaranteed capable of operating in 36 mbps TX rate in
+//		clean environment.
+//								  TxRate: 1   2   5.5	11	 6	  9    12	18	 24   36   48	54	 72  100
+CHAR RssiSafeLevelForTxRate[] ={  -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
+
+								  //  1 	 2		 5.5	  11
+UCHAR Phy11BNextRateDownward[] = {RATE_1, RATE_1,	RATE_2,  RATE_5_5};
+UCHAR Phy11BNextRateUpward[]   = {RATE_2, RATE_5_5, RATE_11, RATE_11};
+
+								  //  1 	 2		 5.5	  11		6		 9		  12	  18	   24		36		 48 	  54
+UCHAR Phy11BGNextRateDownward[]= {RATE_1, RATE_1,	RATE_2,  RATE_5_5,RATE_11,	RATE_6,  RATE_11, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48};
+UCHAR Phy11BGNextRateUpward[]  = {RATE_2, RATE_5_5, RATE_11, RATE_12, RATE_9,	RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54, RATE_54};
+
+								  //  1 	 2		 5.5	  11		6		 9		  12	  18	   24		36		 48 	  54
+UCHAR Phy11ANextRateDownward[] = {RATE_6, RATE_6,	RATE_6,  RATE_6,  RATE_6,	RATE_6,  RATE_9,  RATE_12, RATE_18, RATE_24, RATE_36, RATE_48};
+UCHAR Phy11ANextRateUpward[]   = {RATE_9, RATE_9,	RATE_9,  RATE_9,  RATE_9,	RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54, RATE_54};
+
+//								RATE_1,  2, 5.5, 11,  6,  9, 12, 18, 24, 36, 48, 54
+static USHORT RateUpPER[]	= {    40,	40,  35, 20, 20, 20, 20, 16, 10, 16, 10,  6 }; // in percentage
+static USHORT RateDownPER[] = {    50,	50,  45, 45, 35, 35, 35, 35, 25, 25, 25, 13 }; // in percentage
+
+UCHAR  RateIdToMbps[]	 = { 1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54, 72, 100};
+USHORT RateIdTo500Kbps[] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 144, 200};
+
+UCHAR	ZeroSsid[32] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+
+UCHAR  SsidIe	 = IE_SSID;
+UCHAR  SupRateIe = IE_SUPP_RATES;
+UCHAR  ExtRateIe = IE_EXT_SUPP_RATES;
+UCHAR  ErpIe	 = IE_ERP;
+UCHAR  DsIe 	 = IE_DS_PARM;
+UCHAR  TimIe	 = IE_TIM;
+UCHAR  WpaIe	 = IE_WPA;
+UCHAR  Wpa2Ie	 = IE_WPA2;
+UCHAR  IbssIe	 = IE_IBSS_PARM;
+
+extern UCHAR	WPA_OUI[];
+extern UCHAR	RSN_OUI[];
+
+RTMP_RF_REGS RF2528RegTable[] = {
+//		ch	 R1 		 R2 		 R3(TX0~4=0) R4
+		{1,  0x94002c0c, 0x94000786, 0x94068255, 0x940fea0b},
+		{2,  0x94002c0c, 0x94000786, 0x94068255, 0x940fea1f},
+		{3,  0x94002c0c, 0x9400078a, 0x94068255, 0x940fea0b},
+		{4,  0x94002c0c, 0x9400078a, 0x94068255, 0x940fea1f},
+		{5,  0x94002c0c, 0x9400078e, 0x94068255, 0x940fea0b},
+		{6,  0x94002c0c, 0x9400078e, 0x94068255, 0x940fea1f},
+		{7,  0x94002c0c, 0x94000792, 0x94068255, 0x940fea0b},
+		{8,  0x94002c0c, 0x94000792, 0x94068255, 0x940fea1f},
+		{9,  0x94002c0c, 0x94000796, 0x94068255, 0x940fea0b},
+		{10, 0x94002c0c, 0x94000796, 0x94068255, 0x940fea1f},
+		{11, 0x94002c0c, 0x9400079a, 0x94068255, 0x940fea0b},
+		{12, 0x94002c0c, 0x9400079a, 0x94068255, 0x940fea1f},
+		{13, 0x94002c0c, 0x9400079e, 0x94068255, 0x940fea0b},
+		{14, 0x94002c0c, 0x940007a2, 0x94068255, 0x940fea13}
+};
+UCHAR	NUM_OF_2528_CHNL = (sizeof(RF2528RegTable) / sizeof(RTMP_RF_REGS));
+
+RTMP_RF_REGS RF5226RegTable[] = {
+//		ch	 R1 		 R2 		 R3(TX0~4=0) R4
+		{1,  0x94002c0c, 0x94000786, 0x94068255, 0x940fea0b},
+		{2,  0x94002c0c, 0x94000786, 0x94068255, 0x940fea1f},
+		{3,  0x94002c0c, 0x9400078a, 0x94068255, 0x940fea0b},
+		{4,  0x94002c0c, 0x9400078a, 0x94068255, 0x940fea1f},
+		{5,  0x94002c0c, 0x9400078e, 0x94068255, 0x940fea0b},
+		{6,  0x94002c0c, 0x9400078e, 0x94068255, 0x940fea1f},
+		{7,  0x94002c0c, 0x94000792, 0x94068255, 0x940fea0b},
+		{8,  0x94002c0c, 0x94000792, 0x94068255, 0x940fea1f},
+		{9,  0x94002c0c, 0x94000796, 0x94068255, 0x940fea0b},
+		{10, 0x94002c0c, 0x94000796, 0x94068255, 0x940fea1f},
+		{11, 0x94002c0c, 0x9400079a, 0x94068255, 0x940fea0b},
+		{12, 0x94002c0c, 0x9400079a, 0x94068255, 0x940fea1f},
+		{13, 0x94002c0c, 0x9400079e, 0x94068255, 0x940fea0b},
+		{14, 0x94002c0c, 0x940007a2, 0x94068255, 0x940fea13},
+
+		{36, 0x94002c0c, 0x9400099a, 0x94098255, 0x940fea23},
+		{40, 0x94002c0c, 0x940009a2, 0x94098255, 0x940fea03},
+		{44, 0x94002c0c, 0x940009a6, 0x94098255, 0x940fea0b},
+		{48, 0x94002c0c, 0x940009aa, 0x94098255, 0x940fea13},
+		{52, 0x94002c0c, 0x940009ae, 0x94098255, 0x940fea1b},
+		{56, 0x94002c0c, 0x940009b2, 0x94098255, 0x940fea23},
+		{60, 0x94002c0c, 0x940009ba, 0x94098255, 0x940fea03},
+		{64, 0x94002c0c, 0x940009be, 0x94098255, 0x940fea0b},
+
+		{100, 0x94002c0c, 0x94000a2a, 0x940b8255, 0x940fea03},
+		{104, 0x94002c0c, 0x94000a2e, 0x940b8255, 0x940fea0b},
+		{108, 0x94002c0c, 0x94000a32, 0x940b8255, 0x940fea13},
+		{112, 0x94002c0c, 0x94000a36, 0x940b8255, 0x940fea1b},
+		{116, 0x94002c0c, 0x94000a3a, 0x940b8255, 0x940fea23},
+		{120, 0x94002c0c, 0x94000a82, 0x940b8255, 0x940fea03},
+		{124, 0x94002c0c, 0x94000a86, 0x940b8255, 0x940fea0b},
+		{128, 0x94002c0c, 0x94000a8a, 0x940b8255, 0x940fea13},
+		{132, 0x94002c0c, 0x94000a8e, 0x940b8255, 0x940fea1b},
+		{136, 0x94002c0c, 0x94000a92, 0x940b8255, 0x940fea23},
+		{140, 0x94002c0c, 0x94000a9a, 0x940b8255, 0x940fea03},
+
+		{149, 0x94002c0c, 0x94000aa2, 0x940b8255, 0x940fea1f},
+		{153, 0x94002c0c, 0x94000aa6, 0x940b8255, 0x940fea27},
+		{157, 0x94002c0c, 0x94000aae, 0x940b8255, 0x940fea07},
+		{161, 0x94002c0c, 0x94000ab2, 0x940b8255, 0x940fea0f},
+		{165, 0x94002c0c, 0x94000ab6, 0x940b8255, 0x940fea17},
+
+		//MMAC(Japan)J52 ch 34,38,42,46
+		{34, 0x94002c0c, 0x9408099a, 0x940da255, 0x940d3a0b},
+		{38, 0x94002c0c, 0x9408099e, 0x940da255, 0x940d3a13},
+		{42, 0x94002c0c, 0x940809a2, 0x940da255, 0x940d3a1b},
+		{46, 0x94002c0c, 0x940809a6, 0x940da255, 0x940d3a23},
+
+};
+UCHAR	NUM_OF_5226_CHNL = (sizeof(RF5226RegTable) / sizeof(RTMP_RF_REGS));
+
+// Reset the RFIC setting to new series
+static RTMP_RF_REGS RF5225RegTable[] = {
+//		ch	 R1 		 R2 		 R3(TX0~4=0) R4
+		{1,  0x95002ccc, 0x95004786, 0x95068455, 0x950ffa0b},
+		{2,  0x95002ccc, 0x95004786, 0x95068455, 0x950ffa1f},
+		{3,  0x95002ccc, 0x9500478a, 0x95068455, 0x950ffa0b},
+		{4,  0x95002ccc, 0x9500478a, 0x95068455, 0x950ffa1f},
+		{5,  0x95002ccc, 0x9500478e, 0x95068455, 0x950ffa0b},
+		{6,  0x95002ccc, 0x9500478e, 0x95068455, 0x950ffa1f},
+		{7,  0x95002ccc, 0x95004792, 0x95068455, 0x950ffa0b},
+		{8,  0x95002ccc, 0x95004792, 0x95068455, 0x950ffa1f},
+		{9,  0x95002ccc, 0x95004796, 0x95068455, 0x950ffa0b},
+		{10, 0x95002ccc, 0x95004796, 0x95068455, 0x950ffa1f},
+		{11, 0x95002ccc, 0x9500479a, 0x95068455, 0x950ffa0b},
+		{12, 0x95002ccc, 0x9500479a, 0x95068455, 0x950ffa1f},
+		{13, 0x95002ccc, 0x9500479e, 0x95068455, 0x950ffa0b},
+		{14, 0x95002ccc, 0x950047a2, 0x95068455, 0x950ffa13},
+
+		// 802.11 UNI / HyperLan 2
+		{36, 0x95002ccc, 0x9500499a, 0x9509be55, 0x950ffa23},
+		{40, 0x95002ccc, 0x950049a2, 0x9509be55, 0x950ffa03},
+		{44, 0x95002ccc, 0x950049a6, 0x9509be55, 0x950ffa0b},
+		{48, 0x95002ccc, 0x950049aa, 0x9509be55, 0x950ffa13},
+		{52, 0x95002ccc, 0x950049ae, 0x9509ae55, 0x950ffa1b},
+		{56, 0x95002ccc, 0x950049b2, 0x9509ae55, 0x950ffa23},
+		{60, 0x95002ccc, 0x950049ba, 0x9509ae55, 0x950ffa03},
+		{64, 0x95002ccc, 0x950049be, 0x9509ae55, 0x950ffa0b},
+
+		// 802.11 HyperLan 2
+		{100, 0x95002ccc, 0x95004a2a, 0x950bae55, 0x950ffa03},
+		{104, 0x95002ccc, 0x95004a2e, 0x950bae55, 0x950ffa0b},
+		{108, 0x95002ccc, 0x95004a32, 0x950bae55, 0x950ffa13},
+		{112, 0x95002ccc, 0x95004a36, 0x950bae55, 0x950ffa1b},
+		{116, 0x95002ccc, 0x95004a3a, 0x950bbe55, 0x950ffa23},
+		{120, 0x95002ccc, 0x95004a82, 0x950bbe55, 0x950ffa03},
+		{124, 0x95002ccc, 0x95004a86, 0x950bbe55, 0x950ffa0b},
+		{128, 0x95002ccc, 0x95004a8a, 0x950bbe55, 0x950ffa13},
+		{132, 0x95002ccc, 0x95004a8e, 0x950bbe55, 0x950ffa1b},
+		{136, 0x95002ccc, 0x95004a92, 0x950bbe55, 0x950ffa23},
+
+		// 802.11 UNII
+		{140, 0x95002ccc, 0x95004a9a, 0x950bbe55, 0x950ffa03},
+		{149, 0x95002ccc, 0x95004aa2, 0x950bbe55, 0x950ffa1f},
+		{153, 0x95002ccc, 0x95004aa6, 0x950bbe55, 0x950ffa27},
+		{157, 0x95002ccc, 0x95004aae, 0x950bbe55, 0x950ffa07},
+		{161, 0x95002ccc, 0x95004ab2, 0x950bbe55, 0x950ffa0f},
+		{165, 0x95002ccc, 0x95004ab6, 0x950bbe55, 0x950ffa17},
+
+		//MMAC(Japan)J52 ch 34,38,42,46
+		{34, 0x95002ccc, 0x9500499a, 0x9509be55, 0x950ffa0b},
+		{38, 0x95002ccc, 0x9500499e, 0x9509be55, 0x950ffa13},
+		{42, 0x95002ccc, 0x950049a2, 0x9509be55, 0x950ffa1b},
+		{46, 0x95002ccc, 0x950049a6, 0x9509be55, 0x950ffa23},
+
+};
+UCHAR	NUM_OF_5225_CHNL = (sizeof(RF5225RegTable) / sizeof(RTMP_RF_REGS));
+
+
+/*
+	==========================================================================
+	Description:
+		initialize the MLME task and its data structure (queue, spinlock,
+		timer, state machines).
+
+	Return:
+		always return NDIS_STATUS_SUCCESS
+
+	==========================================================================
+*/
+NDIS_STATUS MlmeInit(
+	IN PRTMP_ADAPTER pAd)
+{
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> MLME Initialize\n");
+
+	do
+	{
+		Status = MlmeQueueInit(&pAd->Mlme.Queue);
+		if(Status != NDIS_STATUS_SUCCESS)
+			break;
+
+		// Initialize Mlme Memory Handler
+		// Allocate 20 nonpaged memory pool which size are MAX_LEN_OF_MLME_BUFFER for use
+		Status = MlmeInitMemoryHandler(pAd, 20, MAX_LEN_OF_MLME_BUFFER);
+		if(Status != NDIS_STATUS_SUCCESS)
+		{
+			MlmeQueueDestroy(&pAd->Mlme.Queue);
+			break;
+		}
+
+		pAd->Mlme.bRunning = FALSE;
+		NdisAllocateSpinLock(&pAd->Mlme.TaskLock);
+
+		// initialize table
+		BssTableInit(&pAd->ScanTab);
+
+		// init state machines
+		ASSERT(ASSOC_FUNC_SIZE == MAX_ASSOC_MSG * MAX_ASSOC_STATE);
+		AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine, pAd->Mlme.AssocFunc);
+
+		ASSERT(AUTH_FUNC_SIZE == MAX_AUTH_MSG * MAX_AUTH_STATE);
+		AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine, pAd->Mlme.AuthFunc);
+
+		ASSERT(AUTH_RSP_FUNC_SIZE == MAX_AUTH_RSP_MSG * MAX_AUTH_RSP_STATE);
+		AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine, pAd->Mlme.AuthRspFunc);
+
+		ASSERT(SYNC_FUNC_SIZE == MAX_SYNC_MSG * MAX_SYNC_STATE);
+		SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine, pAd->Mlme.SyncFunc);
+
+		ASSERT(WPA_PSK_FUNC_SIZE == MAX_WPA_PSK_MSG * MAX_WPA_PSK_STATE);
+		WpaPskStateMachineInit(pAd, &pAd->Mlme.WpaPskMachine, pAd->Mlme.WpaPskFunc);
+
+		// Since we are using switch/case to implement it, the init is different from the above
+		// state machine init
+		MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
+
+		// Init mlme periodic timer
+		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, &MlmePeriodicExec);
+
+		// Set mlme periodic timer
+		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+
+		// software-based RX Antenna diversity
+		RTMPInitTimer(pAd, &pAd->RxAnt.RxAntDiversityTimer, &AsicRxAntEvalTimeout);
+
+		// Init timer to report link down event
+		RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer, &LinkDownExec);
+
+	} while (FALSE);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- MLME Initialize\n");
+
+	return Status;
+}
+
+/*
+	==========================================================================
+	Description:
+		main loop of the MLME
+	Pre:
+		Mlme has to be initialized, and there are something inside the queue
+	Note:
+		This function is invoked from MPSetInformation and MPReceive;
+		This task guarantee only one MlmeHandler will run.
+
+	==========================================================================
+ */
+VOID MlmeHandler(
+	IN PRTMP_ADAPTER pAd)
+{
+	MLME_QUEUE_ELEM	*Elem = NULL;
+	unsigned long			IrqFlags;
+
+	// Only accept MLME and Frame from peer side, no other (control/data) frame should
+	// get into this state machine
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+
+
+	if(pAd->Mlme.bRunning)
+	{
+		NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+		return;
+	}
+	else
+	{
+		pAd->Mlme.bRunning = TRUE;
+	}
+
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+
+
+	while (TRUE) {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS) ||
+			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
+			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %d)\n", pAd->Mlme.Queue.Num);
+			break;
+		}
+
+		NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+		if (!MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
+			NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+			break;
+		}
+		NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+
+		//From message type, determine which state machine I should drive
+		if (pAd->PortCfg.BssType == BSS_MONITOR)
+			continue;
+
+		if (Elem->MsgType == RT_CMD_RESET_MLME)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! reset MLME state machine !!!\n");
+			MlmeRestartStateMachine(pAd);
+			MlmePostRestartStateMachine(pAd);
+			Elem->Occupied = FALSE;
+			Elem->MsgLen = 0;
+			continue;
+		}
+
+
+		// if dequeue success
+		switch (Elem->Machine)
+		{
+			case ASSOC_STATE_MACHINE:
+				StateMachinePerformAction(pAd, &pAd->Mlme.AssocMachine, Elem);
+				break;
+			case AUTH_STATE_MACHINE:
+				StateMachinePerformAction(pAd, &pAd->Mlme.AuthMachine, Elem);
+				break;
+			case AUTH_RSP_STATE_MACHINE:
+				StateMachinePerformAction(pAd, &pAd->Mlme.AuthRspMachine, Elem);
+				break;
+			case SYNC_STATE_MACHINE:
+				StateMachinePerformAction(pAd, &pAd->Mlme.SyncMachine, Elem);
+				break;
+			case MLME_CNTL_STATE_MACHINE:
+				MlmeCntlMachinePerformAction(pAd, &pAd->Mlme.CntlMachine, Elem);
+				break;
+			case WPA_PSK_STATE_MACHINE:
+				StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine, Elem);
+				break;
+			default:
+				DBGPRINT(RT_DEBUG_TRACE, "ERROR: Illegal machine in MlmeHandler()\n");
+				break;
+		} // end of switch
+
+		// free MLME element
+		Elem->Occupied = FALSE;
+		Elem->MsgLen = 0;
+	}
+
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+	pAd->Mlme.bRunning = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+
+}
+
+/*
+	==========================================================================
+	Description:
+		Destructor of MLME (Destroy queue, state machine, spin lock and timer)
+	Parameters:
+		Adapter - NIC Adapter pointer
+	Post:
+		The MLME task will no longer work properly
+
+	==========================================================================
+ */
+VOID MlmeHalt(
+	IN PRTMP_ADAPTER pAd)
+{
+
+	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeHalt\n");
+
+	// Cancel pending timers
+	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer);
+	RTMPCancelTimer(&pAd->Mlme.LinkDownTimer);
+
+
+	RTMPusecDelay(500000);	  // 0.5 sec to guarantee timer canceled
+
+	MlmeQueueDestroy(&pAd->Mlme.Queue);
+	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
+
+	MlmeFreeMemoryHandler(pAd); //Free MLME memory handler
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeHalt\n");
+}
+
+VOID MlmeSuspend(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN linkdown)
+{
+	MLME_QUEUE_ELEM		*Elem = NULL;
+	unsigned long				IrqFlags;
+
+	DBGPRINT(RT_DEBUG_TRACE, "==>MlmeSuspend\n");
+
+	// Cancel pending timers
+	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+
+	while (TRUE)
+	{
+		NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+		if(pAd->Mlme.bRunning)
+		{
+			NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+			if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+				return;
+
+			RTMPusecDelay(100);
+		}
+		else
+		{
+			pAd->Mlme.bRunning = TRUE;
+			NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+			break;
+		}
+	}
+
+	// Remove all Mlme queues elements
+	NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+	while (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
+		// free MLME element
+		Elem->Occupied = FALSE;
+		Elem->MsgLen = 0;
+	}
+	NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+
+	// Remove running state
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+	pAd->Mlme.bRunning = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+
+	RTUSBCleanUpMLMEWaitQueue(pAd);
+	RTUSBCleanUpMLMEBulkOutQueue(pAd);
+
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==MlmeSuspend\n");
+}
+
+VOID MlmeResume(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "==>MlmeResume\n");
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==MlmeResume\n");
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine is executed periodically to -
+        1. Decide if it's a right time to turn on PwrMgmt bit of all
+           outgoiing frames
+        2. Calculate ChannelQuality based on statistics of the last
+           period, so that TX rate won't toggling very frequently between a
+           successful TX and a failed TX.
+        3. If the calculated ChannelQuality indicated current connection not
+           healthy, then a ROAMing attempt is tried here.
+
+    ==========================================================================
+ */
+
+#define ADHOC_BEACON_LOST_TIME		(10*HZ)  // 4 sec
+VOID MlmePeriodicExec(
+	IN	unsigned long data)
+{
+	RTMP_ADAPTER	*pAd = (RTMP_ADAPTER *)data;
+	unsigned long			IrqFlags;
+
+	// Timer need to reset every time, so using do-while loop
+	do
+	{
+		if (pAd->PortCfg.BssType == BSS_MONITOR)
+		{
+			RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+			return;
+		}
+
+		if ((pAd->PortCfg.bHardwareRadio == TRUE) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+		{
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_CHECK_GPIO);
+		}
+
+		// Do nothing if the driver is starting halt state.
+		// This might happen when timer already been fired before cancel timer with mlmehalt
+		if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_MEASUREMENT)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)))
+			break;
+
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING))
+		{
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING);
+			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event B!\n");
+		}
+
+		//
+		// hardware failure?
+		//
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+		{
+			RTUSBRejectPendingPackets(pAd);
+			break;
+		}
+
+		pAd->Mlme.Now = jiffies;
+
+		// if MGMT RING is full more than twice within 1 second, we consider there's
+		// a hardware problem stucking the TX path. In this case, try a hardware reset
+		// to recover the system
+		if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
+		{
+			PCmdQElmt	cmdqelmt;
+
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+			NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+			while (pAd->CmdQ.size > 0)
+			{
+				RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
+				if(cmdqelmt == NULL)//Thomas
+					break;
+				if (cmdqelmt->CmdFromNdis == TRUE)
+				{
+					if ((cmdqelmt->command != RT_OID_MULTI_READ_MAC) &&
+						(cmdqelmt->command != RT_OID_VENDOR_READ_BBP) &&
+						(cmdqelmt->command != RT_OID_USB_VENDOR_EEPROM_READ))
+					{
+						if (cmdqelmt->buffer != NULL){
+							kfree(cmdqelmt->buffer);
+						}
+					}
+					if(cmdqelmt != NULL){
+						kfree(cmdqelmt);
+					}
+				}
+				else
+					cmdqelmt->InUse = FALSE;
+			}
+			NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_RESET_FROM_ERROR);
+
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "<---MlmePeriodicExec (Mgmt Ring Full)\n");
+			break;
+		}
+		pAd->RalinkCounters.MgmtRingFullCount = 0;
+
+		RTUSBEnqueueInternalCmd(pAd, RT_OID_PERIODIC_EXECUT); //STAMlmePeriodicExec(pAd);
+
+		RTUSBMlmeUp(pAd);
+
+	}	while (0);
+
+
+	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+	}
+
+}
+
+VOID STAMlmePeriodicExec(
+	IN	PRTMP_ADAPTER pAd)
+{
+	TXRX_CSR4_STRUC *CurTxRxCsr4 = kzalloc(sizeof(CurTxRxCsr4), GFP_KERNEL);
+	SHORT	dbm;
+#if WPA_SUPPLICANT_SUPPORT
+    union iwreq_data wrqu;
+#endif
+
+	if(!CurTxRxCsr4) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+
+	// WPA MIC error should block association attempt for 60 seconds
+	if (pAd->PortCfg.bBlockAssoc && (time_after(pAd->Mlme.Now, pAd->PortCfg.LastMicErrorTime + (60 * HZ))))
+		pAd->PortCfg.bBlockAssoc = FALSE;
+
+	DBGPRINT(RT_DEBUG_INFO,"MMCHK - PortCfg.Ssid[%d]=%c%c%c%c... MlmeAux.Ssid[%d]=%c%c%c%c...\n",
+			pAd->PortCfg.SsidLen, pAd->PortCfg.Ssid[0], pAd->PortCfg.Ssid[1], pAd->PortCfg.Ssid[2], pAd->PortCfg.Ssid[3],
+			pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid[0], pAd->MlmeAux.Ssid[1], pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]);
+
+
+	// add the most up-to-date h/w raw counters into software variable, so that
+	// the dynamic tuning mechanism below are based on most up-to-date information
+	NICUpdateRawCounters(pAd);
+
+	// danamic tune BBP R17 to find a balance between sensibility and noise isolation
+	AsicBbpTuning(pAd);
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+		// update channel quality for Roaming and UI LinkQuality display
+		MlmeCalculateChannelQuality(pAd, pAd->Mlme.Now);
+
+		// perform dynamic tx rate switching based on past TX history
+		MlmeDynamicTxRateSwitching(pAd);
+	}
+
+	// must be AFTER MlmeDynamicTxRateSwitching() because it needs to know if
+	// Radio is currently in noisy environment
+	AsicAdjustTxPower(pAd);
+
+	// if Rx Antenna is DIVERSITY ON, then perform Software-based diversity evaluation
+	if (((pAd->Antenna.field.NumOfAntenna == 2) && (pAd->Antenna.field.TxDefaultAntenna == 0) && (pAd->Antenna.field.RxDefaultAntenna == 0))
+		&& (pAd->Mlme.PeriodicRound % 2 == 1))
+	{
+		// check every 2 second. If rcv-beacon less than 5 in the past 2 second, then AvgRSSI is no longer a
+		// valid indication of the distance between this AP and its clients.
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		{
+			SHORT	realavgrssi1;
+			BOOLEAN	evaluate = FALSE;
+
+			if (pAd->PortCfg.NumOfAvgRssiSample < 5)
+			{
+				pAd->RxAnt.Pair1LastAvgRssi = (-115);
+				pAd->RxAnt.Pair2LastAvgRssi = (-115);
+				DBGPRINT(RT_DEBUG_TRACE, "MlmePeriodicExec: no traffic/beacon, reset RSSI\n");
+			}
+			else
+				pAd->PortCfg.NumOfAvgRssiSample = 0;
+
+			realavgrssi1 = (pAd->RxAnt.Pair1AvgRssi[pAd->RxAnt.Pair1PrimaryRxAnt] >> 3);
+
+			DBGPRINT(RT_DEBUG_INFO,"Ant-realrssi0(%d),Lastrssi0(%d)\n",realavgrssi1, pAd->RxAnt.Pair1LastAvgRssi);
+
+			if ((realavgrssi1 > (pAd->RxAnt.Pair1LastAvgRssi + 5)) || (realavgrssi1 < (pAd->RxAnt.Pair1LastAvgRssi - 5)))
+			{
+				evaluate = TRUE;
+				pAd->RxAnt.Pair1LastAvgRssi = realavgrssi1;
+			}
+
+			if (evaluate == TRUE)
+			{
+				AsicEvaluateSecondaryRxAnt(pAd);
+			}
+		}
+		else
+		{
+			UCHAR	temp;
+
+			temp = pAd->RxAnt.Pair1PrimaryRxAnt;
+			pAd->RxAnt.Pair1PrimaryRxAnt = pAd->RxAnt.Pair1SecondaryRxAnt;
+			pAd->RxAnt.Pair1SecondaryRxAnt = temp;
+			AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, 0xFF);	//0xFF means not used.
+		}
+	}
+
+	// G band - set BBP_R62 to 0x02 when site survey or rssi<-82
+	// A band - always set BBP_R62 to 0x04
+	if ((pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE) && (pAd->PortCfg.Channel <= 14))
+	{
+		if (pAd->PortCfg.LastRssi >= (-82 + pAd->BbpRssiToDbmDelta))
+		{
+			RTUSBWriteBBPRegister(pAd, BBP_R62, 0x04);
+		}
+		else
+		{
+			RTUSBWriteBBPRegister(pAd, BBP_R62, 0x02);
+		}
+		DBGPRINT(RT_DEBUG_INFO, "STAMlmePeriodicExec - LastRssi=%d, BbpRssiToDbmDelta=%d\n", pAd->PortCfg.LastRssi, pAd->BbpRssiToDbmDelta);
+	}
+
+	if (INFRA_ON(pAd))
+	{
+		// Is PSM bit consistent with user power management policy?
+		// This is the only place that will set PSM bit ON.
+		MlmeCheckPsmChange(pAd, pAd->Mlme.Now);
+
+		//
+		// Lost Beacon for almost one sec && no data traffic then set R17 to lowbound.
+		//
+		if (INFRA_ON(pAd) &&
+			time_after(pAd->Mlme.Now, pAd->PortCfg.LastBeaconRxTime + 1 * HZ) &&
+			((pAd->BulkInDataOneSecCount + pAd->BulkOutDataOneSecCount) < 600))
+		{
+			if (pAd->PortCfg.Channel <= 14)
+			{
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17LowerBoundG);
+			}
+			else
+			{
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17LowerBoundA);
+			}
+		}
+
+#if 0
+		//Move the flowing code to RTUSBHardTransmit, after prepare EAPOL frame that idicated MIC error
+		//To meet the WiFi Test Plan "The STAUT must deauthenticate itself from the AP".
+		//Also need to bloc association frame.
+
+		//The flowing code on here can't send disassociation frame to the AP, since AP may send deauthentication
+		//	frame, on the meanwhile, station will call link down and then this code can't be performed.
+
+		// Check for EAPOL frame sent after MIC countermeasures
+		if (pAd->PortCfg.MicErrCnt >= 3)
+		{
+
+			MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+
+			// disassoc from current AP first
+			DBGPRINT(RT_DEBUG_TRACE, ("MLME - disassociate with current AP after sending second continuous EAPOL frame\n"));
+			DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+			pAd->PortCfg.bBlockAssoc = TRUE;
+		}
+#endif
+        // send out a NULL frame every 10 sec. for what??? inform "PwrMgmt" bit?
+        if ((pAd->Mlme.PeriodicRound % 10) == 8)
+            RTMPSendNullFrame(pAd, pAd->PortCfg.TxRate);
+
+        if (CQI_IS_DEAD(pAd->Mlme.ChannelQuality))
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%d\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount);
+
+#if WPA_SUPPLICANT_SUPPORT
+            if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+                // send disassoc event to wpa_supplicant
+               memset(&wrqu, 0, sizeof(wrqu));
+               wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
+               wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+            }
+#endif
+
+            // Lost AP, send disconnect & link down event
+            RTUSBEnqueueInternalCmd(pAd, RT_OID_LINK_DOWN);
+
+            // RTMPPatchMacBbpBug(pAd);
+            MlmeAutoReconnectLastSSID(pAd);
+        }
+        else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
+        {
+            pAd->RalinkCounters.BadCQIAutoRecoveryCount ++;
+            DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Bad CQI. Auto Recovery attempt #%d\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount);
+            MlmeAutoReconnectLastSSID(pAd);
+        }
+// TODO: temp removed
+#if 0
+        else if (CQI_IS_POOR(pAd->Mlme.ChannelQuality))
+        {
+            // perform aggresive roaming only when SECURITY OFF or WEP64/128;
+            // WPA and WPA-PSK has no aggresive roaming because re-negotiation
+            // between 802.1x supplicant and authenticator/AAA server is required
+            // but can't be guaranteed.
+            if (pAd->PortCfg.AuthMode < Ndis802_11AuthModeWPA)
+                MlmeCheckForRoaming(pAd, pAd->Mlme.Now);
+        }
+#endif
+        // fast roaming
+        if (pAd->PortCfg.bFastRoaming)
+        {
+            // Check the RSSI value, we should begin the roaming attempt
+            DBGPRINT(RT_DEBUG_TRACE, "RxSignal %d\n", pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta);
+            // Only perform action when signal is less than or equal to setting from the UI or registry
+            if (pAd->PortCfg.LastRssi <= (pAd->BbpRssiToDbmDelta - pAd->PortCfg.dBmToRoam))
+            {
+                MlmeCheckForFastRoaming(pAd, pAd->Mlme.Now);
+            }
+        }
+    }
+
+	// !!! Regard the IBSS network as established one while both ADHOC_ON and fOP_STATUS_MEDIA_STATE_CONNECTED are TRUE !!!
+#ifndef SINGLE_ADHOC_LINKUP
+    else if (ADHOC_ON(pAd) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+    {
+		// If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState
+		// to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can
+		// join later.
+		if (time_after(pAd->Mlme.Now,pAd->PortCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME))
+		{
+            DBGPRINT(RT_DEBUG_TRACE, "MMCHK - excessive BEACON lost, last STA in this IBSS, MediaState=Disconnected\n");
+
+			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+			// clean up previous SCAN result, add current BSS back to table if any
+			BssTableDeleteEntry(&pAd->ScanTab, pAd->PortCfg.Bssid, pAd->PortCfg.Channel);
+
+			pAd->PortCfg.LastScanTime = pAd->Mlme.Now;
+        }
+    }
+#endif
+	else // no INFRA nor ADHOC connection
+	{
+		if (!ADHOC_ON(pAd) && !INFRA_ON(pAd))
+		{
+			DBGPRINT(RT_DEBUG_INFO, "MLME periodic exec, no association so far\n");
+
+			if ((pAd->PortCfg.bAutoReconnect == TRUE) &&
+				(MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
+			{
+				if ((pAd->ScanTab.BssNr==0) && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
+				{
+					MLME_SCAN_REQ_STRUCT	   ScanReq;
+
+					//if (time_after(pAd->Mlme.Now, pAd->PortCfg.LastScanTime + 10 * HZ))
+					if (time_after(pAd->Mlme.Now - INITIAL_JIFFIES, pAd->PortCfg.LastScanTime + 10 * HZ))
+					{
+						DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new ACTIVE scan SSID[%s]\n", pAd->MlmeAux.AutoReconnectSsid);
+						ScanParmFill(pAd, &ScanReq, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen, BSS_ANY, SCAN_ACTIVE);
+						MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+						pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+						// Reset Missed scan number
+						pAd->PortCfg.LastScanTime = pAd->Mlme.Now;
+					}
+					else if (pAd->PortCfg.BssType == BSS_ADHOC)  // Quit the forever scan when in a very clean room
+					{
+						MlmeAutoReconnectLastSSID(pAd);
+					}
+				}
+				else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+				{
+					if ((pAd->Mlme.PeriodicRound % 20) == 8)
+					{
+						MlmeAutoScan(pAd);
+						pAd->PortCfg.LastScanTime = pAd->Mlme.Now;
+					}
+					else if ((pAd->Mlme.PeriodicRound % 2) == 0)
+					{
+						MlmeAutoReconnectLastSSID(pAd);
+					}
+					DBGPRINT(RT_DEBUG_INFO, "pAd->PortCfg.bAutoReconnect is TRUE\n");
+				}
+
+				// after once scanning, set wpanone-psk key in the case of using configuration file
+				//if (pAd->Mlme.PeriodicRound >= 4)
+				//{
+					if ((pAd->PortCfg.BssType == BSS_ADHOC) &&
+						(pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)&&
+						((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+						(pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)) &&
+						(pAd->PortCfg.WpaState == SS_START))
+					{
+						RTMPWPANoneAddKeyProc(pAd, pAd->PortCfg.PskKey.Key);
+						// turn on the flag of PortCfg.WpaState as reading profile
+						// and reset after adding key
+						pAd->PortCfg.WpaState = SS_NOTUSE;
+					}
+				//}
+			}
+		}
+	}
+
+	// if all 11b peers leave this BSS more than 5 seconds, update Tx rate,
+	// restore outgoing BEACON to support B/G-mixed mode
+	if (ADHOC_ON(pAd))
+	{
+		// 1.	2003-04-17 john. this is a patch that driver forces a BEACON out if ASIC fails
+		//		the "TX BEACON competition" for the entire past 1 sec.
+		//		So that even when ASIC's BEACONgen engine been blocked
+		//		by peer's BEACON due to slower system clock, this STA still can send out
+		//		minimum BEACON to tell the peer I'm alive.
+		//		drawback is that this BEACON won't be well aligned at TBTT boundary.
+		// 2.	avoid mlme-queue full while doing radar detection
+		if ((pAd->PortCfg.bIEEE80211H == 0) || (pAd->PortCfg.RadarDetect.RDMode == RD_NORMAL_MODE))
+			EnqueueBeaconFrame(pAd);			  // software send BEACON
+
+		if ((pAd->PortCfg.Channel <= 14)			 &&
+			(pAd->PortCfg.MaxTxRate <= RATE_11) 	 &&
+			(pAd->PortCfg.MaxDesiredRate > RATE_11)  &&
+			(time_after(pAd->Mlme.Now, pAd->PortCfg.Last11bBeaconRxTime + 5 * HZ)))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "MMCHK - last 11B peer left, update Tx rates\n");
+
+			memcpy(pAd->ActiveCfg.SupRate, pAd->PortCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+			pAd->ActiveCfg.SupRateLen = pAd->PortCfg.SupRateLen;
+
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_UPDATE_TX_RATE);	//MlmeUpdateTxRates(pAd, FALSE);
+			AsicEnableIbssSync(pAd);	// copy to on-chip memory
+		}
+
+
+		//radar detect
+		if (((pAd->PortCfg.PhyMode == PHY_11A) || (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED)) && (pAd->PortCfg.bIEEE80211H == 1) && RadarChannelCheck(pAd, pAd->PortCfg.Channel))
+		{
+			// need to check channel availability, after switch channel
+			if (pAd->PortCfg.RadarDetect.RDMode == RD_SILENCE_MODE)
+			{
+				pAd->PortCfg.RadarDetect.RDCount++;
+
+				// channel availability check time is 60sec
+				if (pAd->PortCfg.RadarDetect.RDCount > 65)
+				{
+					if (RadarDetectionStop(pAd))
+					{
+						pAd->ExtraInfo = DETECT_RADAR_SIGNAL;
+						pAd->PortCfg.RadarDetect.RDCount = 0;		// stat at silence mode and detect radar signal
+						DBGPRINT(RT_DEBUG_TRACE, "Found radar signal!!!\n\n");
+					}
+					else
+					{
+						DBGPRINT(RT_DEBUG_TRACE, "Not found radar signal, start send beacon\n");
+						AsicEnableIbssSync(pAd);
+						pAd->PortCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
+					}
+				}
+			}
+		}
+
+	}
+
+
+	if (((pAd->Mlme.PeriodicRound % 2) == 0) &&
+		(INFRA_ON(pAd) || ADHOC_ON(pAd)))
+	{
+		RTMPSetSignalLED(pAd, pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta);
+	}
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+		//
+		// Modify retry times (maximum 15) on low data traffic.
+		// Should fix ping lost.
+		//
+		dbm = pAd->PortCfg.AvgRssi - pAd->BbpRssiToDbmDelta;
+
+		//
+		// Only on infrastructure mode will change the RetryLimit.
+		//
+		if (INFRA_ON(pAd))
+		{
+			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MAX_RETRY_ENABLED))
+			{
+				if (pAd->RalinkCounters.OneSecTxNoRetryOkCount > 15)
+				{
+					RTUSBReadMACRegister(pAd, TXRX_CSR4, &CurTxRxCsr4->word);
+					CurTxRxCsr4->field.ShortRetryLimit = 0x07;
+					CurTxRxCsr4->field.LongRetryLimit = 0x04;
+					RTUSBWriteMACRegister(pAd, TXRX_CSR4, CurTxRxCsr4->word);
+					OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MAX_RETRY_ENABLED);
+				}
+			}
+			else
+			{
+				if (pAd->RalinkCounters.OneSecTxNoRetryOkCount <= 15)
+				{
+					RTUSBReadMACRegister(pAd, TXRX_CSR4, &CurTxRxCsr4->word);
+					CurTxRxCsr4->field.ShortRetryLimit = 0x0f;
+					CurTxRxCsr4->field.LongRetryLimit = 0x0f;
+					RTUSBWriteMACRegister(pAd, TXRX_CSR4, CurTxRxCsr4->word);
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MAX_RETRY_ENABLED);
+				}
+			}
+		}
+
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE))
+		{
+			if ((dbm > -60) || (pAd->RalinkCounters.OneSecTxNoRetryOkCount > 15))
+				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE);
+		}
+		else
+		{
+			//
+			// for long distance case, turn on RTS to protect data frame.
+			//
+			if ((dbm <= -60) && (pAd->RalinkCounters.OneSecTxNoRetryOkCount <= 15))
+			{
+				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE);
+			}
+		}
+	}
+
+	//
+	// Clear Tx/Rx Traffic one second count.
+	//
+	pAd->BulkLastOneSecCount = pAd->BulkOutDataOneSecCount + pAd->BulkInDataOneSecCount;
+	pAd->BulkOutDataOneSecCount = 0;
+	pAd->BulkInDataOneSecCount = 0;
+
+	// clear all OneSecxxx counters.
+	pAd->RalinkCounters.OneSecBeaconSentCnt = 0;
+	pAd->RalinkCounters.OneSecFalseCCACnt = 0;
+	pAd->RalinkCounters.OneSecRxFcsErrCnt = 0;
+	pAd->RalinkCounters.OneSecRxOkCnt = 0;
+	pAd->RalinkCounters.OneSecTxFailCount = 0;
+	pAd->RalinkCounters.OneSecTxNoRetryOkCount = 0;
+	pAd->RalinkCounters.OneSecTxRetryOkCount = 0;
+
+	// TODO: for debug only. to be removed
+	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] = 0;
+	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] = 0;
+	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] = 0;
+	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] = 0;
+	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BE] = 0;
+	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BK] = 0;
+	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VI] = 0;
+	pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VO] = 0;
+	pAd->RalinkCounters.OneSecTxDoneCount = 0;
+	pAd->RalinkCounters.OneSecTxAggregationCount = 0;
+	pAd->RalinkCounters.OneSecRxAggregationCount = 0;
+
+	pAd->Mlme.PeriodicRound ++;
+	kfree(CurTxRxCsr4);
+}
+
+VOID LinkDownExec(
+	IN	unsigned long data)
+{
+	//RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+}
+
+VOID MlmeAutoScan(
+	IN PRTMP_ADAPTER pAd)
+{
+	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+
+	// tell CNTL state machine NOT to call NdisMSetInformationComplete() after completing
+	// this request, because this request is initiated by driver itself.
+	pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Driver auto scan\n");
+		MlmeEnqueue(pAd,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_BSSID_LIST_SCAN,
+					0,
+					NULL);
+		RTUSBMlmeUp(pAd);
+	}
+}
+
+VOID MlmeAutoRecoverNetwork(
+	IN PRTMP_ADAPTER pAd)
+{
+	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+	{
+		NDIS_802_11_SSID OidSsid;
+		OidSsid.SsidLength = pAd->PortCfg.SsidLen;
+		memcpy(OidSsid.Ssid, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen);
+
+		DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Driver auto recovering network - %s\n", pAd->PortCfg.Ssid);
+
+		// tell CNTL state machine NOT to call NdisMSetInformationComplete() after completing
+		// this request, because this request is initiated by driver itself.
+		pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+		MlmeEnqueue(pAd,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_SSID,
+					sizeof(NDIS_802_11_SSID),
+					&OidSsid);
+	   RTUSBMlmeUp(pAd);
+	}
+
+}
+
+VOID MlmeAutoReconnectLastSSID(
+	IN PRTMP_ADAPTER pAd)
+{
+	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE &&
+		(MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
+	{
+		NDIS_802_11_SSID OidSsid;
+		OidSsid.SsidLength = pAd->MlmeAux.AutoReconnectSsidLen;
+		memcpy(OidSsid.Ssid, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+
+		DBGPRINT(RT_DEBUG_TRACE, "Driver auto reconnect to last OID_802_11_SSID setting - %s\n", pAd->MlmeAux.AutoReconnectSsid);
+
+		// We will only try this attemp once, therefore change the AutoReconnect flag afterwards.
+		pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+		MlmeEnqueue(pAd,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_SSID,
+					sizeof(NDIS_802_11_SSID),
+					&OidSsid);
+		RTUSBMlmeUp(pAd);
+	}
+}
+
+/*
+	==========================================================================
+	Validate SSID for connection try and rescan purpose
+	Valid SSID will have visible chars only.
+	The valid length is from 0 to 32.
+	==========================================================================
+ */
+BOOLEAN	MlmeValidateSSID(
+	IN PUCHAR	pSsid,
+	IN UCHAR	SsidLen)
+{
+	int	index;
+
+	if (SsidLen > MAX_LEN_OF_SSID)
+		return (FALSE);
+
+	// Check each character value
+	for (index = 0; index < SsidLen; index++)
+	{
+		if (pSsid[index] < 0x20)
+			return (FALSE);
+	}
+
+	// All checked
+	return (TRUE);
+}
+
+/*
+	==========================================================================
+	Description:
+		This routine checks if there're other APs out there capable for
+		roaming. Caller should call this routine only when Link up in INFRA mode
+		and channel quality is below CQI_GOOD_THRESHOLD.
+
+	Output:
+	==========================================================================
+ */
+VOID MlmeCheckForRoaming(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now)
+{
+	USHORT	   i;
+	BSS_TABLE  *pRoamTab = &pAd->MlmeAux.RoamTab;
+	BSS_ENTRY  *pBss;
+
+	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeCheckForRoaming::pAd->ScanTab.BssNr = %d\n", pAd->ScanTab.BssNr);
+	// put all roaming candidates into RoamTab, and sort in RSSI order
+	BssTableInit(pRoamTab);
+	for (i = 0; i < pAd->ScanTab.BssNr; i++)
+	{
+		pBss = &pAd->ScanTab.BssEntry[i];
+
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeCheckForRoaming::pBss->LastBeaconRxTime = %lu\n", pBss->LastBeaconRxTime);
+		if (time_after(Now, pBss->LastBeaconRxTime + BEACON_LOST_TIME))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "1: AP disappear::Now = %lu\n", Now);
+			continue;	 // AP disappear
+		}
+		if (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "2: RSSI too weak::Rssi[%d] - RSSI_THRESHOLD_FOR_ROAMING[%d]\n", pBss->Rssi, RSSI_THRESHOLD_FOR_ROAMING);
+			continue;	 // RSSI too weak. forget it.
+		}
+		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->PortCfg.Bssid))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "3: skip current AP\n");
+			continue;	 // skip current AP
+		}
+		if (!SSID_EQUAL(pBss->Ssid, pBss->SsidLen, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "4: skip different SSID\n");
+			continue;	 // skip different SSID
+		}
+		if (pBss->Rssi < (pAd->PortCfg.LastRssi + RSSI_DELTA))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "5: only AP with stronger RSSI is eligible for roaming\n");
+			continue;	 // only AP with stronger RSSI is eligible for roaming
+		}
+		// AP passing all above rules is put into roaming candidate table
+		memcpy(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));
+		pRoamTab->BssNr += 1;
+	}
+
+	if (pRoamTab->BssNr > 0)
+	{
+		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+		{
+			pAd->RalinkCounters.PoorCQIRoamingCount ++;
+			DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Roaming attempt #%d\n", pAd->RalinkCounters.PoorCQIRoamingCount);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);
+			RTUSBMlmeUp(pAd);
+		}
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeCheckForRoaming(# of candidate= %d)\n",pRoamTab->BssNr);
+}
+
+/*
+	==========================================================================
+	Description:
+		This routine checks if there're other APs out there capable for
+		roaming. Caller should call this routine only when link up in INFRA mode
+		and channel quality is below CQI_GOOD_THRESHOLD.
+
+	Output:
+	==========================================================================
+ */
+VOID MlmeCheckForFastRoaming(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	unsigned long	Now)
+{
+	USHORT     i;
+	BSS_TABLE  *pRoamTab = &pAd->MlmeAux.RoamTab;
+	BSS_ENTRY  *pBss;
+
+	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeCheckForFastRoaming\n");
+	// put all roaming candidates into RoamTab, and sort in RSSI order
+	BssTableInit(pRoamTab);
+	for (i = 0; i < pAd->ScanTab.BssNr; i++)
+	{
+		pBss = &pAd->ScanTab.BssEntry[i];
+
+		if ((pBss->Rssi <= 45) && (pBss->Channel == pAd->PortCfg.Channel))
+			continue;    // RSSI too weak. forget it.
+		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->PortCfg.Bssid))
+			continue;    // skip current AP
+		if (!SSID_EQUAL(pBss->Ssid, pBss->SsidLen, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen))
+			continue;    // skip different SSID
+		if (pBss->Rssi < (pAd->PortCfg.LastRssi + RSSI_DELTA))
+			continue;    // skip AP without better RSSI
+
+		DBGPRINT(RT_DEBUG_TRACE, "LastRssi = %d, pBss->Rssi = %d\n", pAd->PortCfg.LastRssi, pBss->Rssi);
+		// AP passing all above rules is put into roaming candidate table
+		memcpy(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));
+		pRoamTab->BssNr += 1;
+	}
+
+	if (pRoamTab->BssNr > 0)
+	{
+		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+		{
+			pAd->RalinkCounters.PoorCQIRoamingCount ++;
+			DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Roaming attempt #%d\n", pAd->RalinkCounters.PoorCQIRoamingCount);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);
+			RTUSBMlmeUp(pAd);
+		}
+	}
+	// Maybe site survey required
+	else
+	{
+		if ((pAd->PortCfg.LastScanTime + 10 * 1000) < Now)
+		{
+		    MLME_SCAN_REQ_STRUCT	   ScanReq;
+
+			// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+			DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Roaming, No eligable entry, try a new ACTIVE scan SSID[%s]\n", pAd->MlmeAux.AutoReconnectSsid);
+
+            ScanParmFill(pAd, &ScanReq, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen, BSS_ANY, SCAN_ACTIVE);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+						sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+			RTUSBMlmeUp(pAd);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeCheckForFastRoaming\n");
+}
+
+/*
+	==========================================================================
+	Description:
+		This routine calculates TxPER, RxPER of the past N-sec period. And
+		according to the calculation result, ChannelQuality is calculated here
+		to decide if current AP is still doing the job.
+
+		If ChannelQuality is not good, a ROAMing attempt may be tried later.
+	Output:
+		PortCfg.ChannelQuality - 0..100
+
+
+	NOTE: This routine decide channle quality based on RX CRC error ratio.
+		Caller should make sure a function call to NICUpdateRawCounters(pAd)
+		is performed right before this routine, so that this routine can decide
+		channel quality based on the most up-to-date information
+	==========================================================================
+ */
+VOID MlmeCalculateChannelQuality(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now)
+{
+	ULONG TxOkCnt, TxCnt, TxPER, TxPRR;
+	ULONG RxCnt, RxPER;
+	UCHAR NorRssi;
+
+	//
+	// calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics
+	//
+	TxOkCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + pAd->RalinkCounters.OneSecTxRetryOkCount;
+	TxCnt = TxOkCnt + pAd->RalinkCounters.OneSecTxFailCount;
+	if (TxCnt < 5)
+	{
+		TxPER = 0;
+		TxPRR = 0;
+	}
+	else
+	{
+		TxPER = (pAd->RalinkCounters.OneSecTxFailCount * 100) / TxCnt;
+		TxPRR = ((TxCnt - pAd->RalinkCounters.OneSecTxNoRetryOkCount) * 100) / TxCnt;
+	}
+
+	//
+	// calculate RX PER - don't take RxPER into consideration if too few sample
+	//
+	RxCnt = pAd->RalinkCounters.OneSecRxOkCnt + pAd->RalinkCounters.OneSecRxFcsErrCnt;
+	if (RxCnt < 5)
+		RxPER = 0;
+	else
+		RxPER = (pAd->RalinkCounters.OneSecRxFcsErrCnt * 100) / RxCnt;
+
+	//
+	// decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER
+	//
+	if (INFRA_ON(pAd) &&
+		(TxOkCnt < 2) && // no heavy traffic
+		(time_after(Now, pAd->PortCfg.LastBeaconRxTime + BEACON_LOST_TIME)))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "BEACON lost > %d msec with TxOkCnt=%d -> CQI=0\n", BEACON_LOST_TIME, TxOkCnt);
+		pAd->Mlme.ChannelQuality = 0;
+	}
+	else
+	{
+		// Normalize Rssi
+		if (pAd->PortCfg.LastRssi > 0x50)
+			NorRssi = 100;
+		else if (pAd->PortCfg.LastRssi < 0x20)
+			NorRssi = 0;
+		else
+			NorRssi = (pAd->PortCfg.LastRssi - 0x20) * 2;
+
+		// ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER	 (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
+		pAd->Mlme.ChannelQuality = (RSSI_WEIGHTING * NorRssi +
+									TX_WEIGHTING * (100 - TxPRR) +
+									RX_WEIGHTING* (100 - RxPER)) / 100;
+		if (pAd->Mlme.ChannelQuality >= 100)
+			pAd->Mlme.ChannelQuality = 100;
+	}
+
+	DBGPRINT(RT_DEBUG_INFO, "MMCHK - CQI= %d (Tx Fail=%d/Retry=%d/Total=%d, Rx Fail=%d/Total=%d, RSSI=%d dbm)\n",
+		pAd->Mlme.ChannelQuality,
+		pAd->RalinkCounters.OneSecTxFailCount,
+		pAd->RalinkCounters.OneSecTxRetryOkCount,
+		TxCnt,
+		pAd->RalinkCounters.OneSecRxFcsErrCnt,
+		RxCnt, pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta);
+
+}
+
+/*
+	==========================================================================
+	Description:
+		This routine calculates the acumulated TxPER of eaxh TxRate. And
+		according to the calculation result, change PortCfg.TxRate which
+		is the stable TX Rate we expect the Radio situation could sustained.
+
+		PortCfg.TxRate will change dynamically within {RATE_1/RATE_6, MaxTxRate}
+	Output:
+		PortCfg.TxRate -
+
+
+	NOTE:
+		call this routine every second
+	==========================================================================
+ */
+VOID MlmeDynamicTxRateSwitching(
+	IN PRTMP_ADAPTER pAd)
+{
+	UCHAR	UpRate, DownRate, CurrRate;
+	ULONG	TxTotalCnt, NewBasicRateBitmap;
+	ULONG	TxErrorRatio = 0;
+	BOOLEAN fUpgradeQuality = FALSE;
+	SHORT	dbm = pAd->PortCfg.AvgRssi - pAd->BbpRssiToDbmDelta;
+
+	CurrRate = pAd->PortCfg.TxRate;
+
+	// do not reply ACK using TX rate higher than normal DATA TX rate
+	NewBasicRateBitmap = pAd->PortCfg.BasicRateBitmap & BasicRateMask[CurrRate];
+	RTUSBWriteMACRegister(pAd, TXRX_CSR5, NewBasicRateBitmap);
+
+	// if no traffic in the past 1-sec period, don't change TX rate,
+	// but clear all bad history. because the bad history may affect the next
+	// Chariot throughput test
+	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
+				 pAd->RalinkCounters.OneSecTxRetryOkCount +
+				 pAd->RalinkCounters.OneSecTxFailCount;
+
+	if (TxTotalCnt)
+		TxErrorRatio = ((pAd->RalinkCounters.OneSecTxRetryOkCount + pAd->RalinkCounters.OneSecTxFailCount) *100) / TxTotalCnt;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"%d: NDIS push BE=%d, BK=%d, VI=%d, VO=%d, TX/RX AGGR=<%d,%d>, p-NDIS=%d, RSSI=%d, ACKbmap=%03x, PER=%d%%\n",
+		RateIdToMbps[CurrRate],
+		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE],
+		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK],
+		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI],
+		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO],
+		pAd->RalinkCounters.OneSecTxAggregationCount,
+		pAd->RalinkCounters.OneSecRxAggregationCount,
+		pAd->RalinkCounters.PendingNdisPacketCount,
+		dbm,
+		NewBasicRateBitmap & 0xfff,
+		TxErrorRatio);
+
+	if (! OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
+		return;
+
+	//
+	// CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI
+	//		   (criteria copied from RT2500 for Netopia case)
+	//
+	if (TxTotalCnt <= 15)
+	{
+		TxErrorRatio = 0;
+		pAd->DrsCounters.TxRateUpPenalty = 0;
+		memset(pAd->DrsCounters.TxQuality, 0, MAX_LEN_OF_SUPPORTED_RATES);
+		memset(pAd->DrsCounters.PER, 0, MAX_LEN_OF_SUPPORTED_RATES);
+
+		if (dbm >= -65)
+			pAd->PortCfg.TxRate = RATE_54;
+		else if (dbm >= -66)
+			pAd->PortCfg.TxRate = RATE_48;
+		else if (dbm >= -70)
+			pAd->PortCfg.TxRate = RATE_36;
+		else if (dbm >= -74)
+			pAd->PortCfg.TxRate = RATE_24;
+		else if (dbm >= -77)
+			pAd->PortCfg.TxRate = RATE_18;
+		else if (dbm >= -79)
+			pAd->PortCfg.TxRate = RATE_12;
+		else if (dbm >= -81)
+		{
+			// in 11A or 11G-only mode, no CCK rates available
+			if ((pAd->PortCfg.Channel > 14) || (pAd->PortCfg.PhyMode == PHY_11G))
+				pAd->PortCfg.TxRate = RATE_9;
+			else
+				pAd->PortCfg.TxRate = RATE_11;
+		}
+		else
+		{
+			// in 11A or 11G-only mode, no CCK rates available
+			if ((pAd->PortCfg.Channel > 14) || (pAd->PortCfg.PhyMode == PHY_11G))
+				pAd->PortCfg.TxRate = RATE_6;
+			else
+			{
+				if (dbm >= -82)
+					pAd->PortCfg.TxRate = RATE_11;
+				else if (dbm >= -84)
+					pAd->PortCfg.TxRate = RATE_5_5;
+				else if (dbm >= -85)
+					pAd->PortCfg.TxRate = RATE_2;
+				else
+					pAd->PortCfg.TxRate = RATE_1;
+			}
+		}
+
+		if (pAd->PortCfg.TxRate > pAd->PortCfg.MaxTxRate)
+			pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+
+		return;
+	}
+
+	//
+	// CASE2. enough TX samples, tune TX rate based on TxPER
+	//
+	do
+	{
+		pAd->DrsCounters.CurrTxRateStableTime ++;
+
+		// decide the next upgrade rate and downgrade rate, if any
+		if ((pAd->PortCfg.Channel > 14) ||		// must be in 802.11A band
+			(pAd->PortCfg.PhyMode == PHY_11G))	// G-only mode, no CCK rates available
+		{
+			UpRate = Phy11ANextRateUpward[CurrRate];
+			DownRate = Phy11ANextRateDownward[CurrRate];
+		}
+		else
+		{
+			UpRate = Phy11BGNextRateUpward[CurrRate];
+			DownRate = Phy11BGNextRateDownward[CurrRate];
+		}
+
+		if (UpRate > pAd->PortCfg.MaxTxRate)
+			UpRate = pAd->PortCfg.MaxTxRate;
+
+		TxErrorRatio = ((pAd->RalinkCounters.OneSecTxRetryOkCount + pAd->RalinkCounters.OneSecTxFailCount) *100) / TxTotalCnt;
+
+		// downgrade TX quality if PER >= Rate-Down threshold
+		if (TxErrorRatio >= RateDownPER[CurrRate])
+		{
+			pAd->DrsCounters.TxQuality[CurrRate] = DRS_TX_QUALITY_WORST_BOUND;
+		}
+		// upgrade TX quality if PER <= Rate-Up threshold
+		else if (TxErrorRatio <= RateUpPER[CurrRate])
+		{
+			fUpgradeQuality = TRUE;
+			if (pAd->DrsCounters.TxQuality[CurrRate])
+				pAd->DrsCounters.TxQuality[CurrRate] --;  // quality very good in CurrRate
+
+			if (pAd->DrsCounters.TxRateUpPenalty)
+				pAd->DrsCounters.TxRateUpPenalty --;
+			else if (pAd->DrsCounters.TxQuality[UpRate])
+				pAd->DrsCounters.TxQuality[UpRate] --;	  // may improve next UP rate's quality
+		}
+
+		pAd->DrsCounters.PER[CurrRate] = (UCHAR)TxErrorRatio;
+
+#if 1
+		// 2004-3-13 special case: Claim noisy environment
+		//	 decide if there was a false "rate down" in the past 2 sec due to noisy
+		//	 environment. if so, we would rather switch back to the higher TX rate.
+		//	 criteria -
+		//	   1. there's a higher rate available, AND
+		//	   2. there was a rate-down happened, AND
+		//	   3. current rate has 75% > PER > 20%, AND
+		//	   4. comparing to UpRate, current rate didn't improve PER more than 5 %
+		if ((UpRate != CurrRate)							  &&
+			(pAd->DrsCounters.LastSecTxRateChangeAction == 2) &&
+			(pAd->DrsCounters.PER[CurrRate] < 75) &&
+			((pAd->DrsCounters.PER[CurrRate] > 20) || (pAd->DrsCounters.fNoisyEnvironment)) &&
+			((pAd->DrsCounters.PER[CurrRate]+5) > pAd->DrsCounters.PER[UpRate]))
+		{
+			// we believe this is a noisy environment. better stay at UpRate
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: #### enter Noisy environment ####\n");
+			pAd->DrsCounters.fNoisyEnvironment = TRUE;
+
+			// 2004-3-14 when claiming noisy environment, we're not only switch back
+			//	 to UpRate, but can be more aggressive to use one more rate up
+			UpRate++;
+			if ((UpRate==RATE_6) || (UpRate==RATE_9)) UpRate=RATE_12;
+			if (UpRate > pAd->PortCfg.MaxTxRate)
+				UpRate = pAd->PortCfg.MaxTxRate;
+			pAd->PortCfg.TxRate = UpRate;
+			break;
+		}
+
+		// 2004-3-12 special case: Leave noisy environment
+		//	 The interference has gone suddenly. reset TX rate to
+		//	 the theoritical value according to RSSI. Criteria -
+		//	   1. it's currently in noisy environment
+		//	   2. PER drops to be below 12%
+		if ((pAd->DrsCounters.fNoisyEnvironment == TRUE) &&
+			(pAd->DrsCounters.PER[CurrRate] <= 12))
+		{
+			UCHAR JumpUpRate;
+
+			pAd->DrsCounters.fNoisyEnvironment = FALSE;
+			for (JumpUpRate = RATE_54; JumpUpRate > RATE_1; JumpUpRate--)
+			{
+				if (dbm > RssiSafeLevelForTxRate[JumpUpRate])
+					break;
+			}
+
+			if (JumpUpRate > pAd->PortCfg.MaxTxRate)
+				JumpUpRate = pAd->PortCfg.MaxTxRate;
+
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: #### leave Noisy environment ####, RSSI=%d, JumpUpRate=%d\n",
+				dbm, RateIdToMbps[JumpUpRate]);
+
+			if (JumpUpRate > CurrRate)
+			{
+				pAd->PortCfg.TxRate = JumpUpRate;
+				break;
+			}
+		}
+#endif
+		// we're going to upgrade CurrRate to UpRate at next few seconds,
+		// but before that, we'd better try a NULL frame @ UpRate and
+		// see if UpRate is stable or not. If this NULL frame fails, it will
+		// downgrade TxQuality[CurrRate], so that STA won't switch to
+		// to UpRate in the next second
+		// 2004-04-07 requested by David Tung - sent test frames only in OFDM rates
+		if (fUpgradeQuality 	 &&
+			INFRA_ON(pAd)		 &&
+			(UpRate != CurrRate) &&
+			(UpRate > RATE_11)	 &&
+			(pAd->DrsCounters.TxQuality[CurrRate] <= 1) &&
+			(pAd->DrsCounters.TxQuality[UpRate] <= 1))
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: 2 NULL frames at UpRate = %d Mbps\n",RateIdToMbps[UpRate]);
+			RTMPSendNullFrame(pAd, UpRate);
+		}
+
+		// perform DRS - consider TxRate Down first, then rate up.
+		//	   1. rate down, if current TX rate's quality is not good
+		//	   2. rate up, if UPRate's quality is very good
+		if ((pAd->DrsCounters.TxQuality[CurrRate] >= DRS_TX_QUALITY_WORST_BOUND) &&
+			(CurrRate != DownRate))
+		{
+#if 1
+			// guarantee a minimum TX rate for each RSSI segments
+			if ((dbm >= -45) && (DownRate < RATE_48))
+				pAd->PortCfg.TxRate = RATE_48;
+			else if ((dbm >= -50) && (DownRate < RATE_36))
+				pAd->PortCfg.TxRate = RATE_36;
+			else if ((dbm >= -55) && (DownRate < RATE_24))
+				pAd->PortCfg.TxRate = RATE_24;
+			else if ((dbm >= -60) && (DownRate < RATE_18))
+				pAd->PortCfg.TxRate = RATE_18;
+			else if ((dbm >= -65) && (DownRate < RATE_12))
+				pAd->PortCfg.TxRate = RATE_12;
+			else if ((dbm >= -70) && (DownRate < RATE_9))
+			{
+				// in 11A or 11G-only mode, no CCK rates available
+				if ((pAd->PortCfg.Channel > 14) || (pAd->PortCfg.PhyMode == PHY_11G))
+					pAd->PortCfg.TxRate = RATE_9;
+				else
+					pAd->PortCfg.TxRate = RATE_11;
+			}
+			else
+#endif
+			{
+				if ((dbm >= -75) && (DownRate < RATE_11))
+					pAd->PortCfg.TxRate = RATE_11;
+				else
+				{
+#ifdef WIFI_TEST
+					if (DownRate <= RATE_2) break; // never goes lower than 5.5 Mbps TX rate
+#endif
+					// otherwise, if DownRate still better than the low bound that current RSSI can support,
+					// go straight to DownRate
+					pAd->PortCfg.TxRate = DownRate;
+				}
+			}
+		}
+		else if ((pAd->DrsCounters.TxQuality[CurrRate] <= 0) &&
+			(pAd->DrsCounters.TxQuality[UpRate] <=0)		 &&
+			(CurrRate != UpRate))
+		{
+			pAd->PortCfg.TxRate = UpRate;
+		}
+
+		//
+		// To make sure TxRate didn't over MaxTxRate
+		//
+		if (pAd->PortCfg.TxRate > pAd->PortCfg.MaxTxRate)
+			pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+
+	}while (FALSE);
+
+
+	// if rate-up happen, clear all bad history of all TX rates
+	if (pAd->PortCfg.TxRate > CurrRate)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"DRS: ++TX rate from %d to %d Mbps\n", RateIdToMbps[CurrRate],RateIdToMbps[pAd->PortCfg.TxRate]);
+		pAd->DrsCounters.CurrTxRateStableTime = 0;
+		pAd->DrsCounters.TxRateUpPenalty = 0;
+		pAd->DrsCounters.LastSecTxRateChangeAction = 1; // rate UP
+		memset(pAd->DrsCounters.TxQuality, 0, MAX_LEN_OF_SUPPORTED_RATES);
+		memset(pAd->DrsCounters.PER, 0, MAX_LEN_OF_SUPPORTED_RATES);
+#if 0
+//This mechanism should be changed on USB device.
+		//
+		// For TxRate fast train up, issued by David 2005/05/12
+		//
+		if (!pAd->PortCfg.QuickResponeForRateUpTimerRunning)
+		{
+			if (pAd->PortCfg.TxRate <= RATE_12)
+				RTMPSetTimer(pAd, &pAd->PortCfg.QuickResponeForRateUpTimer, 200);
+			else
+			  RTMPSetTimer(pAd, &pAd->PortCfg.QuickResponeForRateUpTimer, 100);
+
+			pAd->PortCfg.QuickResponeForRateUpTimerRunning = TRUE;
+		}
+#endif
+	}
+	// if rate-down happen, only clear DownRate's bad history
+	else if (pAd->PortCfg.TxRate < CurrRate)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"DRS: --TX rate from %d to %d Mbps\n", RateIdToMbps[CurrRate],RateIdToMbps[pAd->PortCfg.TxRate]);
+#if 0
+//Remove this code for TxRate fast train up. issued by David 2005/05/12
+		// shorter stable time require more penalty in next rate UP criteria
+		//if (pAd->DrsCounters.CurrTxRateStableTime < 4)	  // less then 4 sec
+		//	  pAd->DrsCounters.TxRateUpPenalty = DRS_PENALTY; // add 8 sec penalty
+		//else if (pAd->DrsCounters.CurrTxRateStableTime < 8) // less then 8 sec
+		//	  pAd->DrsCounters.TxRateUpPenalty = 2; 		  // add 2 sec penalty
+		//else												  // >= 8 sec
+#endif
+		pAd->DrsCounters.TxRateUpPenalty = 0;			// no penalty
+
+		pAd->DrsCounters.CurrTxRateStableTime = 0;
+		pAd->DrsCounters.LastSecTxRateChangeAction = 2; // rate DOWN
+		pAd->DrsCounters.TxQuality[pAd->PortCfg.TxRate] = 0;
+		pAd->DrsCounters.PER[pAd->PortCfg.TxRate] = 0;
+	}
+	else
+		pAd->DrsCounters.LastSecTxRateChangeAction = 0; // rate no change
+
+}
+
+/*
+	==========================================================================
+	Description:
+		This routine is executed periodically inside MlmePeriodicExec() after
+		association with an AP.
+		It checks if PortCfg.Psm is consistent with user policy (recorded in
+		PortCfg.WindowsPowerMode). If not, enforce user policy. However,
+		there're some conditions to consider:
+		1. we don't support power-saving in ADHOC mode, so Psm=PWR_ACTIVE all
+		   the time when Mibss==TRUE
+		2. When link up in INFRA mode, Psm should not be switch to PWR_SAVE
+		   if outgoing traffic available in TxRing or MgmtRing.
+	Output:
+		1. change pAd->PortCfg.Psm to PWR_SAVE or leave it untouched
+
+
+	==========================================================================
+ */
+VOID MlmeCheckPsmChange(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now)
+{
+	ULONG	PowerMode;
+	// condition -
+	// 1. Psm maybe ON only happen in INFRASTRUCTURE mode
+	// 2. user wants either MAX_PSP or FAST_PSP
+	// 3. but current psm is not in PWR_SAVE
+	// 4. CNTL state machine is not doing SCANning
+	// 5. no TX SUCCESS event for the past 1-sec period
+		PowerMode = pAd->PortCfg.WindowsPowerMode;
+
+	if (INFRA_ON(pAd) &&
+		(PowerMode != Ndis802_11PowerModeCAM) &&
+		(pAd->PortCfg.Psm == PWR_ACTIVE) &&
+//		(! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
+		(pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
+		(pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
+	{
+		RTUSBEnqueueInternalCmd(pAd, RT_OID_SET_PSM_BIT_SAVE);
+	}
+
+}
+
+VOID MlmeSetPsmBit(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT psm)
+{
+	TXRX_CSR4_STRUC *csr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
+
+	if(!csr4) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+
+	pAd->PortCfg.Psm = psm;
+	RTUSBReadMACRegister(pAd, TXRX_CSR4, &csr4->word);
+	csr4->field.AckCtsPsmBit = (psm == PWR_SAVE)? 1:0;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR4, csr4->word);
+	DBGPRINT(RT_DEBUG_TRACE, "MlmeSetPsmBit = %d\n", psm);
+	kfree(csr4);
+}
+
+VOID MlmeSetTxPreamble(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT TxPreamble)
+{
+	TXRX_CSR4_STRUC *csr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
+
+	if(!csr4) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+
+	RTUSBReadMACRegister(pAd, TXRX_CSR4, &csr4->word);
+	if (TxPreamble == Rt802_11PreambleShort)
+	{
+		// NOTE: 1Mbps should always use long preamble
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeSetTxPreamble (= SHORT PREAMBLE)\n");
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
+		csr4->field.AutoResponderPreamble = 0;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeSetTxPreamble (= LONG PREAMBLE)\n");
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
+		csr4->field.AutoResponderPreamble = 1;
+	}
+	RTUSBWriteMACRegister(pAd, TXRX_CSR4, csr4->word);
+	kfree(csr4);
+}
+
+// bLinkUp is to identify the inital link speed.
+// TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps.
+VOID MlmeUpdateTxRates(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN		 bLinkUp)
+{
+	int i, num;
+	UCHAR Rate, MaxDesire = RATE_1, MaxSupport = RATE_1;
+	ULONG BasicRateBitmap = 0;
+	UCHAR CurrBasicRate = RATE_1;
+	UCHAR *pSupRate, *pExtRate, SupRateLen, ExtRateLen;
+
+	// find max desired rate
+	num = 0;
+	for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
+	{
+		switch (pAd->PortCfg.DesireRate[i] & 0x7f)
+		{
+			case 2:  Rate = RATE_1;   num++;   break;
+			case 4:  Rate = RATE_2;   num++;   break;
+			case 11: Rate = RATE_5_5; num++;   break;
+			case 22: Rate = RATE_11;  num++;   break;
+			case 12: Rate = RATE_6;   num++;   break;
+			case 18: Rate = RATE_9;   num++;   break;
+			case 24: Rate = RATE_12;  num++;   break;
+			case 36: Rate = RATE_18;  num++;   break;
+			case 48: Rate = RATE_24;  num++;   break;
+			case 72: Rate = RATE_36;  num++;   break;
+			case 96: Rate = RATE_48;  num++;   break;
+			case 108: Rate = RATE_54; num++;   break;
+			default: Rate = RATE_1;   break;
+		}
+		if (MaxDesire < Rate)  MaxDesire = Rate;
+	}
+
+	// 2003-12-10 802.11g WIFI spec disallow OFDM rates in 802.11g ADHOC mode
+	if ((pAd->PortCfg.BssType == BSS_ADHOC) 	   &&
+		(pAd->PortCfg.PhyMode == PHY_11BG_MIXED)   &&
+		(pAd->PortCfg.AdhocMode == 0) &&
+		(MaxDesire > RATE_11))
+		MaxDesire = RATE_11;
+
+	pAd->PortCfg.MaxDesiredRate = MaxDesire;
+
+	// Auto rate switching is enabled only if more than one DESIRED RATES are
+	// specified; otherwise disabled
+	if (num <= 1)
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
+	else
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
+
+
+	if (ADHOC_ON(pAd) || INFRA_ON(pAd))
+	{
+		pSupRate = &pAd->ActiveCfg.SupRate[0];
+		pExtRate = &pAd->ActiveCfg.ExtRate[0];
+		SupRateLen = pAd->ActiveCfg.SupRateLen;
+		ExtRateLen = pAd->ActiveCfg.ExtRateLen;
+	}
+	else
+	{
+		pSupRate = &pAd->PortCfg.SupRate[0];
+		pExtRate = &pAd->PortCfg.ExtRate[0];
+		SupRateLen = pAd->PortCfg.SupRateLen;
+		ExtRateLen = pAd->PortCfg.ExtRateLen;
+	}
+
+	// find max supported rate
+	for (i=0; i<SupRateLen; i++)
+	{
+		switch (pSupRate[i] & 0x7f)
+		{
+			case 2:   Rate = RATE_1;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0001;	 break;
+			case 4:   Rate = RATE_2;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0002;	 break;
+			case 11:  Rate = RATE_5_5;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0004;	 break;
+			case 22:  Rate = RATE_11;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0008;	 break;
+			case 12:  Rate = RATE_6;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;
+			case 18:  Rate = RATE_9;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0020;	 break;
+			case 24:  Rate = RATE_12;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;
+			case 36:  Rate = RATE_18;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0080;	 break;
+			case 48:  Rate = RATE_24;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;
+			case 72:  Rate = RATE_36;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0200;	 break;
+			case 96:  Rate = RATE_48;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0400;	 break;
+			case 108: Rate = RATE_54;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0800;	 break;
+			default:  Rate = RATE_1;	break;
+		}
+		if (MaxSupport < Rate)	MaxSupport = Rate;
+	}
+	for (i=0; i<ExtRateLen; i++)
+	{
+		switch (pExtRate[i] & 0x7f)
+		{
+			case 2:   Rate = RATE_1;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0001;	 break;
+			case 4:   Rate = RATE_2;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0002;	 break;
+			case 11:  Rate = RATE_5_5;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0004;	 break;
+			case 22:  Rate = RATE_11;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0008;	 break;
+			case 12:  Rate = RATE_6;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;
+			case 18:  Rate = RATE_9;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0020;	 break;
+			case 24:  Rate = RATE_12;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;
+			case 36:  Rate = RATE_18;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0080;	 break;
+			case 48:  Rate = RATE_24;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;
+			case 72:  Rate = RATE_36;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0200;	 break;
+			case 96:  Rate = RATE_48;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0400;	 break;
+			case 108: Rate = RATE_54;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0800;	 break;
+			default:  Rate = RATE_1;	break;
+		}
+		if (MaxSupport < Rate)	MaxSupport = Rate;
+	}
+	RTUSBWriteMACRegister(pAd, TXRX_CSR5, BasicRateBitmap);
+	pAd->PortCfg.BasicRateBitmap = BasicRateBitmap;
+
+	// calculate the exptected ACK rate for each TX rate. This info is used to caculate
+	// the DURATION field of outgoing uniicast DATA/MGMT frame
+	for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
+	{
+		if (BasicRateBitmap & (0x01 << i))
+			CurrBasicRate = (UCHAR)i;
+		pAd->PortCfg.ExpectedACKRate[i] = CurrBasicRate;
+		DBGPRINT(RT_DEBUG_INFO, "Exptected ACK rate[%d] = %d Mbps\n", RateIdToMbps[i], RateIdToMbps[CurrBasicRate]);
+	}
+
+	// max tx rate = min {max desire rate, max supported rate}
+	if (MaxSupport < MaxDesire)
+		pAd->PortCfg.MaxTxRate = MaxSupport;
+	else
+		pAd->PortCfg.MaxTxRate = MaxDesire;
+
+	// 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
+	// ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending
+	// on average RSSI
+	//	 1. RSSI >= -70db, start at 54 Mbps (short distance)
+	//	 2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
+	//	 3. -75 > RSSI, start at 11 Mbps (long distance)
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) &&
+		OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+		short dbm = pAd->PortCfg.AvgRssi - pAd->BbpRssiToDbmDelta;
+		if (bLinkUp == TRUE)
+			pAd->PortCfg.TxRate = RATE_24;
+		else
+			pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+
+		if (dbm < -75)
+			pAd->PortCfg.TxRate = RATE_11;
+		else if (dbm < -70)
+			pAd->PortCfg.TxRate = RATE_24;
+
+		// should never exceed MaxTxRate (consider 11B-only mode)
+		if (pAd->PortCfg.TxRate > pAd->PortCfg.MaxTxRate)
+			pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+	   DBGPRINT(RT_DEBUG_TRACE, " MlmeUpdateTxRates (Rssi=%d, init TX rate = %d Mbps)\n", dbm, RateIdToMbps[pAd->PortCfg.TxRate]);
+	}
+	else
+		pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+
+
+	if (bLinkUp)
+	{
+		;;//Do nothing
+	}
+	else
+	{
+	    switch (pAd->PortCfg.PhyMode)
+	    {
+		    case PHY_11BG_MIXED:
+		    case PHY_11B:
+			    pAd->PortCfg.MlmeRate = RATE_2;
+#ifdef	WIFI_TEST
+			    pAd->PortCfg.RtsRate = RATE_11;
+#else
+			    pAd->PortCfg.RtsRate = RATE_2;
+#endif
+			    break;
+		    case PHY_11A:
+			    pAd->PortCfg.MlmeRate = RATE_6;
+			    pAd->PortCfg.RtsRate = RATE_6;
+			    break;
+		    case PHY_11ABG_MIXED:
+			    if (pAd->PortCfg.Channel <= 14)
+			    {
+				    pAd->PortCfg.MlmeRate = RATE_2;
+				    pAd->PortCfg.RtsRate = RATE_2;
+			    }
+			    else
+			    {
+				    pAd->PortCfg.MlmeRate = RATE_6;
+				    pAd->PortCfg.RtsRate = RATE_6;
+			    }
+			    break;
+		    default: // error
+			    pAd->PortCfg.MlmeRate = RATE_2;
+			    pAd->PortCfg.RtsRate = RATE_2;
+			    break;
+        }
+
+        //
+        // Keep Basic Mlme Rate.
+        //
+        pAd->PortCfg.BasicMlmeRate = pAd->PortCfg.MlmeRate;
+	}
+
+
+	//
+	//	Update MlmeRate & RtsRate for G only & A only on Adhoc mode.
+	//
+	if (ADHOC_ON(pAd))
+	{
+		if ((pAd->PortCfg.AdhocMode == ADHOC_11G) || (pAd->PortCfg.AdhocMode == ADHOC_11A))
+		{
+			pAd->PortCfg.MlmeRate = RATE_6;
+			pAd->PortCfg.RtsRate = RATE_6;
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, " MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, Rate Switching =%d)\n",
+			 RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport], RateIdToMbps[pAd->PortCfg.MaxTxRate], OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED));
+	DBGPRINT(RT_DEBUG_TRACE, " MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04x)\n",
+			 RateIdToMbps[pAd->PortCfg.TxRate], RateIdToMbps[pAd->PortCfg.RtsRate], BasicRateBitmap);
+}
+
+VOID MlmeRadioOff(
+	IN PRTMP_ADAPTER pAd)
+{
+	MLME_DISASSOC_REQ_STRUCT	DisReq;
+	MLME_QUEUE_ELEM 			MsgElem;
+	ULONG						i = 0;
+
+	DBGPRINT(RT_DEBUG_TRACE, "===>MlmeRadioOff()\n");
+
+	// Set LED Status first.
+	RTMPSetLED(pAd, LED_RADIO_OFF);
+
+	//
+	// Since set flag fRTMP_ADAPTER_RADIO_OFF will diable RTUSBKickBulkOut function.
+	// So before set flag fRTMP_ADAPTER_RADIO_OFF,
+	// we should send a disassoc frame to our AP if neend.
+	//
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+	{
+		if (INFRA_ON(pAd))
+		{
+			COPY_MAC_ADDR(&DisReq.Addr, pAd->PortCfg.Bssid);
+			DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+
+			MsgElem.Machine = ASSOC_STATE_MACHINE;
+			MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
+			MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
+			memcpy(MsgElem.Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+
+			MlmeDisassocReqAction(pAd, &MsgElem);
+			RTMPusecDelay(1000);
+		}
+
+		// Set Radio off flag will turn off RTUSBKickBulkOut function
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+
+		// Link down first if any association exists
+		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
+			LinkDown(pAd, FALSE);
+
+	}
+	else
+	{
+		// Set Radio off flag will turn off RTUSBKickBulkOut function
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+	}
+
+	RTUSBRejectPendingPackets(pAd); //reject all NDIS packets waiting in TX queue
+	RTUSBCleanUpDataBulkOutQueue(pAd);
+	MlmeSuspend(pAd, TRUE);
+
+	// Disable Rx
+	RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+	RTUSBWriteMACRegister(pAd, MAC_CSR10, 0x00001818); // Turn off radio
+
+
+	//Ask our device to complete any pending bulk in IRP.
+	while ((atomic_read(&pAd->PendingRx ) > 0) ||
+			(pAd->BulkOutPending[0] == TRUE) ||
+			(pAd->BulkOutPending[1] == TRUE) ||
+			(pAd->BulkOutPending[2] == TRUE) ||
+			(pAd->BulkOutPending[3] == TRUE))
+	{
+		if (atomic_read(&pAd->PendingRx) > 0)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+			RTUSB_VendorRequest(pAd,
+				0,
+				DEVICE_VENDOR_REQUEST_OUT,
+				0x0C,
+				0x0,
+				0x0,
+				NULL,
+				0);
+		}
+
+		if ((pAd->BulkOutPending[0] == TRUE) ||
+			(pAd->BulkOutPending[1] == TRUE) ||
+			(pAd->BulkOutPending[2] == TRUE) ||
+			(pAd->BulkOutPending[3] == TRUE))
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+			if (i == 0)
+			{
+				RTUSBCancelPendingBulkOutIRP(pAd);
+				i++;
+			}
+		}
+
+		RTMPusecDelay(500000);
+	}
+
+	// Clean up old bss table
+	BssTableInit(&pAd->ScanTab);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeRadioOff\n");
+}
+
+VOID MlmeRadioOn(
+	IN PRTMP_ADAPTER pAd)
+{
+	DBGPRINT(RT_DEBUG_TRACE,"MlmeRadioOn()\n");
+
+	NICResetFromError(pAd);
+
+	// Turn on radio, Abort TX, Disable RX
+	RTUSBWriteMACRegister(pAd, MAC_CSR10, 0x00000718);
+	RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+
+	// Clear Radio off flag
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+
+	MlmeResume(pAd);
+	RTUSBBulkReceive(pAd);
+
+	// enable RX of MAC block
+	RT73WriteTXRXCSR0(pAd, FALSE, TRUE);	// Staion not drop control frame will fail WiFi Certification.
+
+	// Set LED
+	RTMPSetLED(pAd, LED_RADIO_ON);
+
+	// Switch to current channel, since during reset process, the connection should remains on.
+	AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+	AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+	//
+	// After Radio On, we should enqueue Reset MLME,
+	// To make sure during Radio Off any MLME message enqueued will be reset.
+	// After MLME Reset the routine RTUSBResumeMsduTransmission will also be call
+	// To
+	//
+	MlmeEnqueue(pAd,
+				MLME_CNTL_STATE_MACHINE,
+				RT_CMD_RESET_MLME,
+				0,
+				NULL);
+
+}
+
+// ===========================================================================================
+// bss_table.c
+// ===========================================================================================
+
+
+/*! \brief initialize BSS table
+ *	\param p_tab pointer to the table
+ *	\return none
+ *	\pre
+ *	\post
+ */
+VOID BssTableInit(
+	IN BSS_TABLE *Tab)
+{
+	int i;
+
+	Tab->BssNr = 0;
+	Tab->BssOverlapNr = 0;
+	for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++)
+	{
+		memset(&Tab->BssEntry[i], 0, sizeof(BSS_ENTRY));
+	}
+}
+
+/*! \brief search the BSS table by SSID
+ *	\param p_tab pointer to the bss table
+ *	\param ssid SSID string
+ *	\return index of the table, BSS_NOT_FOUND if not in the table
+ *	\pre
+ *	\post
+ *	\note search by sequential search
+ */
+ULONG BssTableSearch(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 pBssid,
+	IN UCHAR	 Channel)
+{
+	UCHAR i;
+
+	for (i = 0; i < Tab->BssNr; i++)
+	{
+		//
+		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
+		// We should distinguish this case.
+		//
+		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
+			 ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+			MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid))
+		{
+			return i;
+		}
+	}
+	return (ULONG)BSS_NOT_FOUND;
+}
+
+ULONG BssSsidTableSearch(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 pBssid,
+	IN PUCHAR	 pSsid,
+	IN UCHAR	 SsidLen,
+	IN UCHAR	 Channel)
+{
+	UCHAR i;
+
+	for (i = 0; i < Tab->BssNr; i++)
+	{
+		//
+		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
+		// We should distinguish this case.
+		//
+		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
+			 ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+			MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid) &&
+			SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid, Tab->BssEntry[i].SsidLen))
+		{
+			return i;
+		}
+	}
+	return (ULONG)BSS_NOT_FOUND;
+}
+
+ULONG BssTableSearchWithSSID(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 Bssid,
+	IN PUCHAR	 pSsid,
+	IN UCHAR	 SsidLen,
+	IN UCHAR	 Channel)
+{
+	UCHAR i;
+
+	for (i = 0; i < Tab->BssNr; i++)
+	{
+		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
+			((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+			MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid) &&
+			(SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid, Tab->BssEntry[i].SsidLen) ||
+			(NdisEqualMemory(pSsid, ZeroSsid, SsidLen)) ||
+			(NdisEqualMemory(Tab->BssEntry[i].Ssid, ZeroSsid, Tab->BssEntry[i].SsidLen))))
+		{
+			return i;
+		}
+	}
+	return (ULONG)BSS_NOT_FOUND;
+}
+
+VOID BssTableDeleteEntry(
+	IN OUT	BSS_TABLE *Tab,
+	IN		PUCHAR	  pBssid,
+	IN		UCHAR	  Channel)
+{
+	UCHAR i, j;
+
+	for (i = 0; i < Tab->BssNr; i++)
+	{
+		//printf("comparing %s and %s\n", p_tab->bss[i].ssid, ssid);
+		if ((Tab->BssEntry[i].Channel == Channel) &&
+			(MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid)))
+		{
+			for (j = i; j < Tab->BssNr - 1; j++)
+			{
+				memcpy(&(Tab->BssEntry[j]), &(Tab->BssEntry[j + 1]), sizeof(BSS_ENTRY));
+			}
+			Tab->BssNr -= 1;
+			return;
+		}
+	}
+}
+
+/*! \brief
+ *	\param
+ *	\return
+ *	\pre
+ *	\post
+ */
+VOID BssEntrySet(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_ENTRY *pBss,
+	IN PUCHAR pBssid,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN USHORT BeaconPeriod,
+	IN PCF_PARM pCfParm,
+	IN USHORT AtimWin,
+	IN USHORT CapabilityInfo,
+	IN UCHAR SupRate[],
+	IN UCHAR SupRateLen,
+	IN UCHAR ExtRate[],
+	IN UCHAR ExtRateLen,
+	IN UCHAR Channel,
+	IN UCHAR Rssi,
+	IN LARGE_INTEGER TimeStamp,
+	IN UCHAR CkipFlag,
+	IN PEDCA_PARM pEdcaParm,
+	IN PQOS_CAPABILITY_PARM pQosCapability,
+	IN PQBSS_LOAD_PARM pQbssLoad,
+	IN UCHAR LengthVIE,
+	IN PNDIS_802_11_VARIABLE_IEs pVIE)
+{
+	//pBss->LastBeaconRxTime = jiffies;     // MlmeCheckForRoaming related
+
+	COPY_MAC_ADDR(pBss->Bssid, pBssid);
+	// Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID
+	pBss->Hidden = 1;
+	if (SsidLen > 0)
+	{
+		// For hidden SSID AP, it might send beacon with SSID len equal to 0
+		// Or send beacon /probe response with SSID len matching real SSID length,
+		// but SSID is all zero. such as "00-00-00-00" with length 4.
+		// We have to prevent this case overwrite correct table
+		if (NdisEqualMemory(Ssid, ZeroSsid, SsidLen) == 0)
+		{
+			memcpy(pBss->Ssid, Ssid, SsidLen);
+			pBss->SsidLen = SsidLen;
+			pBss->Hidden = 0;
+		}
+	}
+	pBss->BssType = BssType;
+	pBss->BeaconPeriod = BeaconPeriod;
+	if (BssType == BSS_INFRA)
+	{
+		if (pCfParm->bValid)
+		{
+			pBss->CfpCount = pCfParm->CfpCount;
+			pBss->CfpPeriod = pCfParm->CfpPeriod;
+			pBss->CfpMaxDuration = pCfParm->CfpMaxDuration;
+			pBss->CfpDurRemaining = pCfParm->CfpDurRemaining;
+		}
+	}
+	else
+	{
+		pBss->AtimWin = AtimWin;
+	}
+
+	pBss->CapabilityInfo = CapabilityInfo;
+	// The privacy bit indicate security is ON, it maight be WEP, TKIP or AES
+	// Combine with AuthMode, they will decide the connection methods.
+	pBss->Privacy = CAP_IS_PRIVACY_ON(pBss->CapabilityInfo);
+	memcpy(pBss->SupRate, SupRate, SupRateLen);
+	pBss->SupRateLen = SupRateLen;
+	memcpy(pBss->ExtRate, ExtRate, ExtRateLen);
+	pBss->ExtRateLen = ExtRateLen;
+	pBss->Channel = Channel;
+	pBss->Rssi = Rssi;
+	// Update CkipFlag. if not exists, the value is 0x0
+	pBss->CkipFlag = CkipFlag;
+
+	// New for microsoft Fixed IEs
+	memcpy(pBss->FixIEs.Timestamp, &TimeStamp, 8);
+	pBss->FixIEs.BeaconInterval = BeaconPeriod;
+	pBss->FixIEs.Capabilities = CapabilityInfo;
+
+	if (LengthVIE != 0)
+	{
+		pBss->VarIELen = LengthVIE;
+		memcpy(pBss->VarIEs, pVIE, pBss->VarIELen);
+	}
+	else
+	{
+		pBss->VarIELen = 0;
+	}
+
+	BssCipherParse(pBss);
+
+	// new for QOS
+	if (pEdcaParm)
+		memcpy(&pBss->EdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+	else
+		pBss->EdcaParm.bValid = FALSE;
+	if (pQosCapability)
+		memcpy(&pBss->QosCapability, pQosCapability, sizeof(QOS_CAPABILITY_PARM));
+	else
+		pBss->QosCapability.bValid = FALSE;
+	if (pQbssLoad)
+		memcpy(&pBss->QbssLoad, pQbssLoad, sizeof(QBSS_LOAD_PARM));
+	else
+		pBss->QbssLoad.bValid = FALSE;
+}
+
+/*!
+ *	\brief insert an entry into the bss table
+ *	\param p_tab The BSS table
+ *	\param Bssid BSSID
+ *	\param ssid SSID
+ *	\param ssid_len Length of SSID
+ *	\param bss_type
+ *	\param beacon_period
+ *	\param timestamp
+ *	\param p_cf
+ *	\param atim_win
+ *	\param cap
+ *	\param rates
+ *	\param rates_len
+ *	\param channel_idx
+ *	\return none
+ *	\pre
+ *	\post
+ *	\note If SSID is identical, the old entry will be replaced by the new one
+ */
+ULONG BssTableSetEntry(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_TABLE *Tab,
+	IN PUCHAR pBssid,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN USHORT BeaconPeriod,
+	IN CF_PARM *CfParm,
+	IN USHORT AtimWin,
+	IN USHORT CapabilityInfo,
+	IN UCHAR SupRate[],
+	IN UCHAR SupRateLen,
+	IN UCHAR ExtRate[],
+	IN UCHAR ExtRateLen,
+	IN UCHAR ChannelNo,
+	IN UCHAR Rssi,
+	IN LARGE_INTEGER TimeStamp,
+	IN UCHAR CkipFlag,
+	IN PEDCA_PARM pEdcaParm,
+	IN PQOS_CAPABILITY_PARM pQosCapability,
+	IN PQBSS_LOAD_PARM pQbssLoad,
+	IN UCHAR LengthVIE,
+	IN PNDIS_802_11_VARIABLE_IEs pVIE)
+{
+	ULONG	Idx;
+
+	Idx = BssTableSearchWithSSID(Tab, pBssid,  Ssid, SsidLen, ChannelNo);
+	if (Idx == BSS_NOT_FOUND)
+	{
+		if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE)
+	    {
+			//
+			// It may happen when BSS Table was full.
+			// The desired AP will not be added into BSS Table
+			// In this case, if we found the desired AP then overwrite BSS Table.
+			//
+            if(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			{
+				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, pBssid) ||
+					SSID_EQUAL(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, Ssid, SsidLen))
+				{
+					Idx = Tab->BssOverlapNr;
+					BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod,
+								CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,
+								ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
+					Tab->BssOverlapNr = (Tab->BssOverlapNr++) % MAX_LEN_OF_BSS_TABLE;
+				}
+				return Idx;
+			}
+			else
+				return BSS_NOT_FOUND;
+		}
+
+		Idx = Tab->BssNr;
+		BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod,
+					CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,
+					ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
+		Tab->BssNr++;
+	}
+	else
+	{
+		BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod,
+					CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,
+					ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
+	}
+
+	return Idx;
+}
+
+BOOLEAN RTMPCheckAKM(
+    IN NDIS_802_11_AUTHENTICATION_MODE auth,
+    IN BSS_ENTRY *pBss)
+{
+    switch (auth)
+    {
+        case Ndis802_11AuthModeWPA:
+    	    if(pBss->AuthBitMode & WPA1AKMBIT)
+	            return TRUE;
+	        else
+	            return FALSE;
+        case Ndis802_11AuthModeWPAPSK:
+    	    if(pBss->AuthBitMode & WPA1PSKAKMBIT)
+	            return TRUE;
+	        else
+	            return FALSE;
+        case Ndis802_11AuthModeWPA2:
+       	    if(pBss->AuthBitMode & WPA2AKMBIT)
+	            return TRUE;
+	        else
+	            return FALSE;
+        case Ndis802_11AuthModeWPA2PSK:
+            if(pBss->AuthBitMode & WPA2PSKAKMBIT)
+	            return TRUE;
+	        else
+	            return FALSE;
+        default:
+            return FALSE;
+    }
+}
+
+VOID BssTableSsidSort(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_TABLE *OutTab,
+	IN	CHAR Ssid[],
+	IN	UCHAR SsidLen)
+{
+	INT i;
+	BssTableInit(OutTab);
+
+	for (i = 0; i < pAd->ScanTab.BssNr; i++)
+	{
+		BSS_ENTRY *pInBss = &pAd->ScanTab.BssEntry[i];
+
+		if ((pInBss->BssType == pAd->PortCfg.BssType) &&
+			SSID_EQUAL(Ssid, SsidLen, pInBss->Ssid, pInBss->SsidLen))
+		{
+			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
+
+			// New for WPA2
+			// Check the Authmode first
+			if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+			{
+				if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+				{
+					if (pAd->PortCfg.AuthMode != pInBss->AuthMode)
+						continue;// None matched
+				}
+				else
+				{
+					// Check AuthMode and AuthBitMode for matching, in case AP support dual-mode
+					if(!RTMPCheckAKM(pAd->PortCfg.AuthMode,pInBss))
+						continue;// None matched
+				}
+
+				// Check cipher suite, AP must have more secured cipher than station setting
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA.GroupCipher)
+							continue;
+
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipher) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipherAux))
+						continue;
+				}
+				else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA2.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA2.GroupCipher)
+							continue;
+
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA2.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipher) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+						continue;
+				}
+			}
+			// Bss Type matched, SSID matched.
+			// We will check wepstatus for qualification Bss
+			else if (pAd->PortCfg.WepStatus != pInBss->WepStatus)
+			{
+				DBGPRINT(RT_DEBUG_TRACE,"PortCfg.WepStatus=%d, while pInBss->WepStatus=%d\n", pAd->PortCfg.WepStatus, pInBss->WepStatus);
+				continue;
+			}
+
+			// Since the AP is using hidden SSID, and we are trying to connect to ANY
+			// It definitely will fail. So, skip it.
+			// CCX also require not even try to connect it!!
+			if (SsidLen == 0)
+				continue;
+
+			// copy matching BSS from InTab to OutTab
+			memcpy(pOutBss, pInBss, sizeof(BSS_ENTRY));
+
+			OutTab->BssNr++;
+		}
+		else if ((pInBss->BssType == pAd->PortCfg.BssType) && (SsidLen == 0))
+		{
+			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
+
+			// New for WPA2
+			// Check the Authmode first
+			if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+			{
+				// Check AuthMode and AuthBitMode for matching, in case AP support dual-mode
+				if(!RTMPCheckAKM(pAd->PortCfg.AuthMode,pInBss))
+					continue;   // None matched
+
+				// Check cipher suite, AP must have more secured cipher than station setting
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA.GroupCipher)
+							continue;
+
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipher) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipherAux))
+						continue;
+				}
+				else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA2.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA2.GroupCipher)
+							continue;
+
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA2.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipher) &&
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+						continue;
+				}
+			}
+			// Bss Type matched, SSID matched.
+			// We will check wepstatus for qualification Bss
+			else if (pAd->PortCfg.WepStatus != pInBss->WepStatus)
+					continue;
+
+			// copy matching BSS from InTab to OutTab
+			memcpy(pOutBss, pInBss, sizeof(BSS_ENTRY));
+
+			OutTab->BssNr++;
+		}
+
+		if (OutTab->BssNr >= MAX_LEN_OF_BSS_TABLE)
+			break;
+
+	}
+
+	BssTableSortByRssi(OutTab);
+
+	if (OutTab->BssNr > 0)
+	{
+		if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+			RTMPMakeRSNIE(pAd, OutTab->BssEntry[0].WPA2.GroupCipher);
+		else if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+			RTMPMakeRSNIE(pAd, OutTab->BssEntry[0].WPA.GroupCipher);
+	}
+
+}
+
+VOID BssTableSortByRssi(
+	IN OUT BSS_TABLE *OutTab)
+{
+	INT 	  i, j;
+	BSS_ENTRY TmpBss;
+
+	for (i = 0; i < OutTab->BssNr - 1; i++)
+	{
+		for (j = i+1; j < OutTab->BssNr; j++)
+		{
+			if (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi)
+			{
+				memcpy(&TmpBss, &OutTab->BssEntry[j], sizeof(BSS_ENTRY));
+				memcpy(&OutTab->BssEntry[j], &OutTab->BssEntry[i], sizeof(BSS_ENTRY));
+				memcpy(&OutTab->BssEntry[i], &TmpBss, sizeof(BSS_ENTRY));
+			}
+		}
+	}
+}
+
+VOID BssCipherParse(
+	IN OUT	PBSS_ENTRY	pBss)
+{
+	PEID_STRUCT 		 pEid;
+	PUCHAR				pTmp;
+	PRSN_IE_HEADER_STRUCT			pRsnHeader;
+	PCIPHER_SUITE_STRUCT			pCipher;
+	PAKM_SUITE_STRUCT				pAKM;
+	USHORT							Count;
+	INT								Length;
+	NDIS_802_11_ENCRYPTION_STATUS	TmpCipher;
+
+	//
+	// WepStatus will be reset later, if AP announce TKIP or AES on the beacon frame.
+	//
+	if (pBss->Privacy)
+	{
+		pBss->WepStatus 	= Ndis802_11WEPEnabled;
+	}
+	else
+	{
+		pBss->WepStatus 	= Ndis802_11WEPDisabled;
+	}
+	// Set default to disable & open authentication before parsing variable IE
+	pBss->AuthMode		= Ndis802_11AuthModeOpen;
+//	pBss->AuthModeAux	= Ndis802_11AuthModeOpen;
+	pBss->AuthBitMode   = 0;
+
+	// Init WPA setting
+	pBss->WPA.PairCipher	= Ndis802_11WEPDisabled;
+	pBss->WPA.PairCipherAux = Ndis802_11WEPDisabled;
+	pBss->WPA.GroupCipher	= Ndis802_11WEPDisabled;
+	pBss->WPA.RsnCapability = 0;
+	pBss->WPA.bMixMode		= FALSE;
+
+	// Init WPA2 setting
+	pBss->WPA2.PairCipher	 = Ndis802_11WEPDisabled;
+	pBss->WPA2.PairCipherAux = Ndis802_11WEPDisabled;
+	pBss->WPA2.GroupCipher	 = Ndis802_11WEPDisabled;
+	pBss->WPA2.RsnCapability = 0;
+	pBss->WPA2.bMixMode 	 = FALSE;
+	Length = (INT) pBss->VarIELen;
+
+	while (Length > 0)
+	{
+		// Parse cipher suite base on WPA1 & WPA2, they should be parsed differently
+		pTmp = ((PUCHAR) pBss->VarIEs) + pBss->VarIELen - Length;
+		pEid = (PEID_STRUCT) pTmp;
+		switch (pEid->Eid)
+		{
+			case IE_WPA:
+				if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4) != 1)
+				{
+					// if unsupported vendor specific IE
+					break;
+				}
+				// Skip OUI, version, and multicast suite
+				// This part should be improved in the future when AP supported multiple cipher suite.
+				// For now, it's OK since almost all APs have fixed cipher suite supported.
+				// pTmp = (PUCHAR) pEid->Octet;
+				pTmp   += 11;
+
+				// Cipher Suite Selectors from Spec P802.11i/D3.2 P26.
+				//	Value	   Meaning
+				//	0			None
+				//	1			WEP-40
+				//	2			Tkip
+				//	3			WRAP
+				//	4			AES
+				//	5			WEP-104
+				// Parse group cipher
+				switch (*pTmp)
+				{
+					case 1:
+					case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+						pBss->WPA.GroupCipher = Ndis802_11Encryption1Enabled;
+						break;
+					case 2:
+						pBss->WPA.GroupCipher = Ndis802_11Encryption2Enabled;
+						break;
+					case 4:
+						pBss->WPA.GroupCipher = Ndis802_11Encryption3Enabled;
+						break;
+					default:
+						break;
+				}
+				// number of unicast suite
+				pTmp   += 1;
+
+				// skip all unicast cipher suites
+				//Count = *(PUSHORT) pTmp;
+				memcpy(&Count, pTmp, sizeof(USHORT));
+#ifdef BIG_ENDIAN
+				Count = SWAP16(Count);
+#endif
+				pTmp   += sizeof(USHORT);
+
+				// Parsing all unicast cipher suite
+				while (Count > 0)
+				{
+					// Skip OUI
+					pTmp += 3;
+					TmpCipher = Ndis802_11WEPDisabled;
+					switch (*pTmp)
+					{
+						case 1:
+						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
+							TmpCipher = Ndis802_11Encryption1Enabled;
+							break;
+						case 2:
+							TmpCipher = Ndis802_11Encryption2Enabled;
+							break;
+						case 4:
+							TmpCipher = Ndis802_11Encryption3Enabled;
+							break;
+						default:
+							break;
+					}
+					if (TmpCipher > pBss->WPA.PairCipher)
+					{
+						// Move the lower cipher suite to PairCipherAux
+						pBss->WPA.PairCipherAux = pBss->WPA.PairCipher;
+						pBss->WPA.PairCipher	= TmpCipher;
+					}
+					else
+					{
+						pBss->WPA.PairCipherAux = TmpCipher;
+					}
+					pTmp++;
+					Count--;
+				}
+
+				// 4. get AKM suite counts
+				//Count   = *(PUSHORT) pTmp;
+				memcpy(&Count, pTmp, sizeof(USHORT));
+#ifdef BIG_ENDIAN
+				Count = SWAP16(Count);
+#endif
+				pTmp   += sizeof(USHORT);
+
+				while(Count >0)
+				{
+					pTmp   += 3;
+
+					switch (*pTmp)
+					{
+						case 1:
+							// Set AP support WPA1 mode
+							pBss->AuthBitMode|=WPA1AKMBIT;
+							pBss->AuthMode	  = Ndis802_11AuthModeWPA;
+							break;
+						case 2:
+							// Set AP support WPA1PSK
+							pBss->AuthBitMode|=WPA1PSKAKMBIT;
+							pBss->AuthMode	  = Ndis802_11AuthModeWPAPSK;
+							break;
+						default:
+							break;
+					}
+					pTmp++;
+					Count--;
+				}
+
+
+				// Fixed for WPA-None
+				if (pBss->BssType == BSS_ADHOC)
+				{
+					pBss->AuthMode	  = Ndis802_11AuthModeWPANone;
+//					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+					pBss->WepStatus   = pBss->WPA.GroupCipher;
+					// Patched bugs for old driver
+					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
+						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
+				}
+				else
+					pBss->WepStatus   = pBss->WPA.PairCipher;
+
+				// Check the Pair & Group, if different, turn on mixed mode flag
+				if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
+					pBss->WPA.bMixMode = TRUE;
+
+				break;
+
+			case IE_RSN:
+				pRsnHeader = (PRSN_IE_HEADER_STRUCT) pTmp;
+
+				// 0. Version must be 1
+#ifdef BIG_ENDIAN
+				pRsnHeader->Version = SWAP16(pRsnHeader->Version);
+#endif
+				if (pRsnHeader->Version != 1)
+					break;
+				pTmp   += sizeof(RSN_IE_HEADER_STRUCT);
+
+				// 1. Check group cipher
+				pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
+				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
+					break;
+
+				// Parse group cipher
+				switch (pCipher->Type)
+				{
+					case 1:
+					case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption1Enabled;
+						break;
+					case 2:
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption2Enabled;
+						break;
+					case 4:
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption3Enabled;
+						break;
+					default:
+						break;
+				}
+				// set to correct offset for next parsing
+				pTmp   += sizeof(CIPHER_SUITE_STRUCT);
+
+				// 2. Get pairwise cipher counts
+				//Count = *(PUSHORT) pTmp;
+				memcpy(&Count, pTmp, sizeof(USHORT));
+#ifdef BIG_ENDIAN
+				Count = SWAP16(Count);
+#endif
+				pTmp   += sizeof(USHORT);
+
+				// 3. Get pairwise cipher
+				// Parsing all unicast cipher suite
+				while (Count > 0)
+				{
+					// Skip OUI
+					pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
+					TmpCipher = Ndis802_11WEPDisabled;
+					switch (pCipher->Type)
+					{
+						case 1:
+						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
+							TmpCipher = Ndis802_11Encryption1Enabled;
+							break;
+						case 2:
+							TmpCipher = Ndis802_11Encryption2Enabled;
+							break;
+						case 4:
+							TmpCipher = Ndis802_11Encryption3Enabled;
+							break;
+						default:
+							break;
+					}
+					if (TmpCipher > pBss->WPA2.PairCipher)
+					{
+						// Move the lower cipher suite to PairCipherAux
+						pBss->WPA2.PairCipherAux = pBss->WPA2.PairCipher;
+						pBss->WPA2.PairCipher	 = TmpCipher;
+					}
+					else
+					{
+						pBss->WPA2.PairCipherAux = TmpCipher;
+					}
+					pTmp += sizeof(CIPHER_SUITE_STRUCT);
+					Count--;
+				}
+
+				// 4. get AKM suite counts
+				//Count   = *(PUSHORT) pTmp;
+				memcpy(&Count, pTmp, sizeof(USHORT));
+#ifdef BIG_ENDIAN
+				Count = SWAP16(Count);
+#endif
+				pTmp   += sizeof(USHORT);
+
+				// 5. Get AKM ciphers
+				pAKM = (PAKM_SUITE_STRUCT) pTmp;
+				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
+					break;
+
+				while(Count >0)
+				{
+					pTmp   += 3;
+
+					switch (*pTmp)
+					{
+						case 1:
+							// Set AP support WPA2 mode
+							pBss->AuthBitMode|=WPA2AKMBIT;
+							pBss->AuthMode	  = Ndis802_11AuthModeWPA2;
+							break;
+						case 2:
+							// Set AP support WPA2PSK
+							pBss->AuthBitMode|=WPA2PSKAKMBIT;
+							pBss->AuthMode	  = Ndis802_11AuthModeWPA2PSK;
+							break;
+						default:
+							break;
+					}
+					pTmp++;
+					Count--;
+				}
+
+
+				// Fixed for WPA-None
+				if (pBss->BssType == BSS_ADHOC)
+				{
+					pBss->AuthMode = Ndis802_11AuthModeWPANone;
+//					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+					pBss->WPA.PairCipherAux = pBss->WPA2.PairCipherAux;
+					pBss->WPA.GroupCipher	= pBss->WPA2.GroupCipher;
+					pBss->WepStatus 		= pBss->WPA.GroupCipher;
+					// Patched bugs for old driver
+					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
+						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
+				}
+				pBss->WepStatus   = pBss->WPA2.PairCipher;
+
+				// 6. Get RSN capability
+				//pBss->WPA2.RsnCapability = *(PUSHORT) pTmp;
+				memcpy(&pBss->WPA2.RsnCapability, pTmp, sizeof(USHORT));
+#ifdef BIG_ENDIAN
+				pBss->WPA2.RsnCapability = SWAP16(pBss->WPA2.RsnCapability);
+#endif
+				pTmp += sizeof(USHORT);
+
+				// Check the Pair & Group, if different, turn on mixed mode flag
+				if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
+					pBss->WPA2.bMixMode = TRUE;
+
+				break;
+
+			default:
+				break;
+		}
+		Length -= (pEid->Len + 2);
+	}
+}
+
+
+// ===========================================================================================
+// mac_table.c
+// ===========================================================================================
+
+/*! \brief generates a random mac address value for IBSS BSSID
+ *	\param Addr the bssid location
+ *	\return none
+ *	\pre
+ *	\post
+ */
+VOID MacAddrRandomBssid(
+	IN PRTMP_ADAPTER pAd,
+	OUT PUCHAR pAddr)
+{
+	INT i;
+
+	for (i = 0; i < MAC_ADDR_LEN; i++)
+	{
+		pAddr[i] = RandomByte(pAd);
+	}
+
+	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;  // the first 2 bits must be 01xxxxxxxx
+}
+
+/*! \brief init the management mac frame header
+ *	\param p_hdr mac header
+ *	\param subtype subtype of the frame
+ *	\param p_ds destination address, don't care if it is a broadcast address
+ *	\return none
+ *	\pre the station has the following information in the pAd->UserCfg
+ *	 - bssid
+ *	 - station address
+ *	\post
+ *	\note this function initializes the following field
+ */
+VOID MgtMacHeaderInit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN OUT PHEADER_802_11 pHdr80211,
+	IN UCHAR SubType,
+	IN UCHAR ToDs,
+	IN PUCHAR pDA,
+	IN PUCHAR pBssid)
+{
+	memset(pHdr80211, 0, sizeof(HEADER_802_11));
+	pHdr80211->FC.Type = BTYPE_MGMT;
+	pHdr80211->FC.SubType = SubType;
+	pHdr80211->FC.ToDs = ToDs;
+	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
+	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
+	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
+}
+
+// ===========================================================================================
+// mem_mgmt.c
+// ===========================================================================================
+
+/*!***************************************************************************
+ * This routine build an outgoing frame, and fill all information specified
+ * in argument list to the frame body. The actual frame size is the summation
+ * of all arguments.
+ * input params:
+ *		Buffer - pointer to a pre-allocated memory segment
+ *		args - a list of <int arg_size, arg> pairs.
+ *		NOTE NOTE NOTE!!!! the last argument must be NULL, otherwise this
+ *						   function will FAIL!!!
+ * return:
+ *		Size of the buffer
+ * usage:
+ *		MakeOutgoingFrame(Buffer, output_length, 2, &fc, 2, &dur, 6, p_addr1, 6,p_addr2, END_OF_ARGS);
+ ****************************************************************************/
+ULONG MakeOutgoingFrame(
+	OUT CHAR *Buffer,
+	OUT ULONG *FrameLen, ...)
+{
+	CHAR   *p;
+	int 	leng;
+	ULONG	TotLeng;
+	va_list Args;
+
+	// calculates the total length
+	TotLeng = 0;
+	va_start(Args, FrameLen);
+	do
+	{
+		leng = va_arg(Args, int);
+		if (leng == END_OF_ARGS)
+		{
+			break;
+		}
+		p = va_arg(Args, PVOID);
+		memcpy(&Buffer[TotLeng], p, leng);
+		TotLeng = TotLeng + leng;
+	} while(TRUE);
+
+	va_end(Args); /* clean up */
+	*FrameLen = TotLeng;
+	return TotLeng;
+}
+
+// ===========================================================================================
+// mlme_queue.c
+// ===========================================================================================
+
+/*! \brief	Initialize The MLME Queue, used by MLME Functions
+ *	\param	*Queue	   The MLME Queue
+ *	\return Always	   Return NDIS_STATE_SUCCESS in this implementation
+ *	\pre
+ *	\post
+ *	\note	Because this is done only once (at the init stage), no need to be locked
+ */
+NDIS_STATUS MlmeQueueInit(
+	IN MLME_QUEUE *Queue)
+{
+	INT i;
+
+	NdisAllocateSpinLock(&Queue->Lock);
+
+	Queue->Num	= 0;
+	Queue->Head = 0;
+	Queue->Tail = 0;
+
+	for (i = 0; i < MAX_LEN_OF_MLME_QUEUE; i++)
+	{
+		Queue->Entry[i].Occupied = FALSE;
+		Queue->Entry[i].MsgLen = 0;
+		memset(Queue->Entry[i].Msg, 0, MAX_LEN_OF_MLME_BUFFER);
+	}
+
+	return NDIS_STATUS_SUCCESS;
+}
+
+/*! \brief	 Enqueue a message for other threads, if they want to send messages to MLME thread
+ *	\param	*Queue	  The MLME Queue
+ *	\param	 Machine  The State Machine Id
+ *	\param	 MsgType  The Message Type
+ *	\param	 MsgLen   The Message length
+ *	\param	*Msg	  The message pointer
+ *	\return  TRUE if enqueue is successful, FALSE if the queue is full
+ *	\pre
+ *	\post
+ *	\note	 The message has to be initialized
+ */
+BOOLEAN MlmeEnqueue(
+	IN	PRTMP_ADAPTER	pAd,
+	IN ULONG Machine,
+	IN ULONG MsgType,
+	IN ULONG MsgLen,
+	IN VOID *Msg)
+{
+	INT Tail;
+	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+	unsigned long		IrqFlags;
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return FALSE;
+
+	// First check the size, it MUST not exceed the mlme queue size
+	if (MsgLen > MAX_LEN_OF_MLME_BUFFER)
+	{
+		DBGPRINT_ERR("MlmeEnqueue: msg too large, size = %d \n", MsgLen);
+		return FALSE;
+	}
+
+	if (pAd->MLMEThr_pid > 0)
+	{
+		NdisAcquireSpinLock(&Queue->Lock, IrqFlags);
+		if (Queue->Num == MAX_LEN_OF_MLME_QUEUE) {
+			NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+			DBGPRINT_ERR("MlmeEnqueue: full, msg dropped and may corrupt MLME\n");
+			return FALSE;
+		}
+		Tail = Queue->Tail++;
+		Queue->Tail %= MAX_LEN_OF_MLME_QUEUE;
+		Queue->Num++;
+		NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+
+		Queue->Entry[Tail].Occupied = TRUE;
+		Queue->Entry[Tail].Machine = Machine;
+		Queue->Entry[Tail].MsgType = MsgType;
+		Queue->Entry[Tail].MsgLen  = MsgLen;
+		memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
+
+		DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueue, num=%d\n",Queue->Num);
+	}
+
+	return TRUE;
+}
+
+/*! \brief	 This function is used when Recv gets a MLME message
+ *	\param	*Queue			 The MLME Queue
+ *	\param	 Rssi			 The receiving RSSI strength
+ *	\param	 MsgLen 		 The length of the message
+ *	\param	*Msg			 The message pointer
+ *	\return  TRUE if everything ok, FALSE otherwise (like Queue Full)
+ *	\pre
+ *	\post
+ */
+BOOLEAN MlmeEnqueueForRecv(
+	IN	PRTMP_ADAPTER	pAd,
+	IN UCHAR Rssi,
+	IN ULONG MsgLen,
+	IN VOID *Msg,
+	IN UCHAR Signal)
+{
+	INT 			Tail, Machine;
+	PFRAME_802_11	pFrame = (PFRAME_802_11)Msg;
+	ULONG			MsgType;
+	MLME_QUEUE		*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+	unsigned long			IrqFlags;
+
+	if((pAd->MLMEThr_pid <= 0))
+		return FALSE;
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return FALSE;
+
+	// First check the size, it MUST not exceed the mlme queue size
+	if (MsgLen > MAX_LEN_OF_MLME_BUFFER)
+	{
+		DBGPRINT_ERR("MlmeEnqueueForRecv: frame too large, size = %d \n", MsgLen);
+		return FALSE;
+	}
+
+	if (!MsgTypeSubst(pAd, pFrame, &Machine, &MsgType))
+	{
+		DBGPRINT_ERR("MlmeEnqueueForRecv: un-recongnized mgmt->subtype=%d\n",pFrame->Hdr.FC.SubType);
+		return FALSE;
+	}
+
+	if ((Machine == SYNC_STATE_MACHINE)&&(MsgType == MT2_PEER_PROBE_RSP)&&(pAd->PortCfg.bGetAPConfig))
+	{
+		if (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
+		{
+			CHAR CfgData[MAX_CFG_BUFFER_LEN+1] = {0};
+			if (BackDoorProbeRspSanity(pAd, Msg, MsgLen, CfgData))
+			{
+				printk("MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n", (int)strlen(CfgData), CfgData);
+				pAd->PortCfg.bGetAPConfig = FALSE;
+			}
+		}
+	}
+
+
+	NdisAcquireSpinLock(&Queue->Lock, IrqFlags);
+	if (Queue->Num == MAX_LEN_OF_MLME_QUEUE) {
+		NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+		DBGPRINT_ERR("MlmeEnqueueForRecv: full and dropped\n");
+		return FALSE;
+	}
+	Tail = Queue->Tail++;
+	Queue->Tail %= MAX_LEN_OF_MLME_QUEUE;
+	Queue->Num++;
+	NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+	DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueueForRecv, num=%d\n",Queue->Num);
+
+	// OK, we got all the informations, it is time to put things into queue
+	Queue->Entry[Tail].Occupied = TRUE;
+	Queue->Entry[Tail].Machine = Machine;
+	Queue->Entry[Tail].MsgType = MsgType;
+	Queue->Entry[Tail].MsgLen  = MsgLen;
+	Queue->Entry[Tail].Rssi = Rssi;
+	Queue->Entry[Tail].Signal = Signal;
+	Queue->Entry[Tail].bReqIsFromNdis = FALSE;
+	Queue->Entry[Tail].Channel = pAd->LatchRfRegs.Channel;
+	memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
+
+	RTUSBMlmeUp(pAd);
+
+	return TRUE;
+}
+
+/*! \brief	 Dequeue a message from the MLME Queue
+ * 			WARNING: Must be call with Mlme.Queue.Lock held
+ *	\param	*Queue	  The MLME Queue
+ *	\param	*Elem	  The message dequeued from MLME Queue
+ *	\return  TRUE if the Elem contains something, FALSE otherwise
+ *	\pre
+ *	\post
+ */
+BOOLEAN MlmeDequeue(
+	IN MLME_QUEUE *Queue,
+	OUT MLME_QUEUE_ELEM **Elem)
+{
+
+	if (Queue->Num == 0)
+		return FALSE;
+
+	*Elem = &Queue->Entry[Queue->Head++];
+	Queue->Head %= MAX_LEN_OF_MLME_QUEUE;
+	Queue->Num--;
+	DBGPRINT(RT_DEBUG_INFO, "MlmeDequeue, num=%d\n",Queue->Num);
+
+	return TRUE;
+}
+
+VOID MlmeRestartStateMachine(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MlmeRestartStateMachine !!!\n");
+
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);
+
+	// Cancel all timer events
+	// Be careful to cancel new added timer
+	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+
+
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);
+
+}
+
+VOID MlmePostRestartStateMachine(
+	IN	PRTMP_ADAPTER	pAd)
+{
+
+	//
+	// Flag fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS will be clear at MlmeHandler
+	// when required to do MLME Reset!
+	// Since MlmeRestartStateMachine will do nothing when Mlme is running.
+	//
+	while (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS))
+		RTMPusecDelay(100000);
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MlmePostRestartStateMachine !!!\n");
+
+	// Change back to original channel in case of doing scan
+	AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+	AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+	// Resume MSDU which is turned off durning scan
+	RTUSBResumeMsduTransmission(pAd);
+}
+
+/*! \brief	 The destructor of MLME Queue
+ *	\param
+ *	\return
+ *	\pre
+ *	\post
+ *	\note	Clear Mlme Queue, Set Queue->Num to Zero.
+ */
+VOID MlmeQueueDestroy(
+	IN MLME_QUEUE *pQueue)
+{
+	unsigned long			IrqFlags;
+
+	NdisAcquireSpinLock(&(pQueue->Lock), IrqFlags);
+
+	pQueue->Num  = 0;
+	pQueue->Head = 0;
+	pQueue->Tail = 0;
+
+	NdisReleaseSpinLock(&(pQueue->Lock), IrqFlags);
+	NdisFreeSpinLock(&(pQueue->Lock));
+}
+
+/*! \brief	 To substitute the message type if the message is coming from external
+ *	\param	pFrame		   The frame received
+ *	\param	*Machine	   The state machine
+ *	\param	*MsgType	   the message type for the state machine
+ *	\return TRUE if the substitution is successful, FALSE otherwise
+ *	\pre
+ *	\post
+ */
+BOOLEAN MsgTypeSubst(
+	IN PRTMP_ADAPTER  pAd,
+	IN PFRAME_802_11 pFrame,
+	OUT INT *Machine,
+	OUT INT *MsgType)
+{
+	USHORT Seq;
+	UCHAR	EAPType;
+	BOOLEAN 	Return;
+
+// only PROBE_REQ can be broadcast, all others must be unicast-to-me && is_mybssid; otherwise,
+// ignore this frame
+
+	// wpa EAPOL PACKET
+	if (pFrame->Hdr.FC.Type == BTYPE_DATA)
+	{
+		*Machine = WPA_PSK_STATE_MACHINE;
+		EAPType = *((UCHAR*)pFrame+LENGTH_802_11+LENGTH_802_1_H+1);
+		Return = WpaMsgTypeSubst(EAPType, MsgType);
+		return Return;
+
+	}
+	else if (pFrame->Hdr.FC.Type == BTYPE_MGMT)
+	{
+		switch (pFrame->Hdr.FC.SubType)
+		{
+			case SUBTYPE_ASSOC_REQ:
+				*Machine = ASSOC_STATE_MACHINE;
+				*MsgType = MT2_PEER_ASSOC_REQ;
+				break;
+			case SUBTYPE_ASSOC_RSP:
+				*Machine = ASSOC_STATE_MACHINE;
+				*MsgType = MT2_PEER_ASSOC_RSP;
+			break;
+			case SUBTYPE_REASSOC_REQ:
+				*Machine = ASSOC_STATE_MACHINE;
+				*MsgType = MT2_PEER_REASSOC_REQ;
+				break;
+			case SUBTYPE_REASSOC_RSP:
+				*Machine = ASSOC_STATE_MACHINE;
+				*MsgType = MT2_PEER_REASSOC_RSP;
+			break;
+			case SUBTYPE_PROBE_REQ:
+				*Machine = SYNC_STATE_MACHINE;
+				*MsgType = MT2_PEER_PROBE_REQ;
+			break;
+			case SUBTYPE_PROBE_RSP:
+				*Machine = SYNC_STATE_MACHINE;
+				*MsgType = MT2_PEER_PROBE_RSP;
+			break;
+			case SUBTYPE_BEACON:
+				*Machine = SYNC_STATE_MACHINE;
+				*MsgType = MT2_PEER_BEACON;
+				break;
+			case SUBTYPE_ATIM:
+				*Machine = SYNC_STATE_MACHINE;
+				*MsgType = MT2_PEER_ATIM;
+			break;
+			case SUBTYPE_DISASSOC:
+				*Machine = ASSOC_STATE_MACHINE;
+				*MsgType = MT2_PEER_DISASSOC_REQ;
+				break;
+			case SUBTYPE_AUTH:
+				// get the sequence number from payload 24 Mac Header + 2 bytes algorithm
+				memcpy(&Seq, &pFrame->Octet[2], sizeof(USHORT));
+				if (Seq == 1 || Seq == 3)
+				{
+					*Machine = AUTH_RSP_STATE_MACHINE;
+					*MsgType = MT2_PEER_AUTH_ODD;
+				}
+				else if (Seq == 2 || Seq == 4)
+				{
+					*Machine = AUTH_STATE_MACHINE;
+					*MsgType = MT2_PEER_AUTH_EVEN;
+				}
+				else
+				{
+					return FALSE;
+				}
+				break;
+			case SUBTYPE_DEAUTH:
+				*Machine = AUTH_RSP_STATE_MACHINE;
+				*MsgType = MT2_PEER_DEAUTH;
+				break;
+			default:
+				return FALSE;
+		}
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+// ===========================================================================================
+// state_machine.c
+// ===========================================================================================
+
+/*! \brief Initialize the state machine.
+ *	\param *S			pointer to the state machine
+ *	\param	Trans		State machine transition function
+ *	\param	StNr		number of states
+ *	\param	MsgNr		number of messages
+ *	\param	DefFunc 	default function, when there is invalid state/message combination
+ *	\param	InitState	initial state of the state machine
+ *	\param	Base		StateMachine base, internal use only
+ *	\pre p_sm should be a legal pointer
+ *	\post
+ */
+VOID StateMachineInit(
+	IN STATE_MACHINE *S,
+	IN STATE_MACHINE_FUNC Trans[],
+	IN ULONG StNr,
+	IN ULONG MsgNr,
+	IN STATE_MACHINE_FUNC DefFunc,
+	IN ULONG InitState,
+	IN ULONG Base)
+{
+	ULONG i, j;
+
+	// set number of states and messages
+	S->NrState = StNr;
+	S->NrMsg   = MsgNr;
+	S->Base    = Base;
+
+	S->TransFunc  = Trans;
+
+	// init all state transition to default function
+	for (i = 0; i < StNr; i++)
+	{
+		for (j = 0; j < MsgNr; j++)
+		{
+			S->TransFunc[i * MsgNr + j] = DefFunc;
+		}
+	}
+
+	// set the starting state
+	S->CurrState = InitState;
+
+}
+
+/*! \brief This function fills in the function pointer into the cell in the state machine
+ *	\param *S	pointer to the state machine
+ *	\param St	state
+ *	\param Msg	incoming message
+ *	\param f	the function to be executed when (state, message) combination occurs at the state machine
+ *	\pre *S should be a legal pointer to the state machine, st, msg, should be all within the range, Base should be set in the initial state
+ *	\post
+ */
+VOID StateMachineSetAction(
+	IN STATE_MACHINE *S,
+	IN ULONG St,
+	IN ULONG Msg,
+	IN STATE_MACHINE_FUNC Func)
+{
+	ULONG MsgIdx;
+
+	MsgIdx = Msg - S->Base;
+
+	if (St < S->NrState && MsgIdx < S->NrMsg)
+	{
+		// boundary checking before setting the action
+		S->TransFunc[St * S->NrMsg + MsgIdx] = Func;
+	}
+}
+
+/*! \brief	 This function does the state transition
+ *	\param	 *Adapter the NIC adapter pointer
+ *	\param	 *S 	  the state machine
+ *	\param	 *Elem	  the message to be executed
+ *	\return   None
+ */
+VOID StateMachinePerformAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN STATE_MACHINE *S,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	(*(S->TransFunc[S->CurrState * S->NrMsg + Elem->MsgType - S->Base]))(pAd, Elem);
+}
+
+/*
+	==========================================================================
+	Description:
+		The drop function, when machine executes this, the message is simply
+		ignored. This function does nothing, the message is freed in
+		StateMachinePerformAction()
+	==========================================================================
+ */
+VOID Drop(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+}
+
+// ===========================================================================================
+// lfsr.c
+// ===========================================================================================
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID LfsrInit(
+	IN PRTMP_ADAPTER pAd,
+	IN ULONG Seed)
+{
+	if (Seed == 0)
+		pAd->Mlme.ShiftReg = 1;
+	else
+		pAd->Mlme.ShiftReg = Seed;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+UCHAR RandomByte(
+	IN PRTMP_ADAPTER pAd)
+{
+	ULONG i;
+	UCHAR R, Result;
+
+	R = 0;
+
+	for (i = 0; i < 8; i++)
+	{
+		if (pAd->Mlme.ShiftReg & 0x00000001)
+		{
+			pAd->Mlme.ShiftReg = ((pAd->Mlme.ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
+			Result = 1;
+		}
+		else
+		{
+			pAd->Mlme.ShiftReg = pAd->Mlme.ShiftReg >> 1;
+			Result = 0;
+		}
+		R = (R << 1) | Result;
+	}
+
+	return R;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSwitchChannel(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR Channel)
+{
+	ULONG	R3 = DEFAULT_RF_TX_POWER, R4;
+	CHAR	TxPwer = 0, Bbp94 = BBPR94_DEFAULT;
+	UCHAR	index, BbpReg;
+
+	// Select antenna
+	AsicAntennaSelect(pAd, Channel);
+
+	// Search Tx power value
+	for (index = 0; index < pAd->ChannelListNum; index++)
+	{
+		if (Channel == pAd->ChannelList[index].Channel)
+		{
+			TxPwer = pAd->ChannelList[index].Power;
+			break;
+		}
+	}
+
+	if (TxPwer > 31)
+	{
+		//
+		// R3 can't large than 36 (0x24), 31 ~ 36 used by BBP 94
+		//
+		R3 = 31;
+		if (TxPwer <= 36)
+			Bbp94 = BBPR94_DEFAULT + (UCHAR) (TxPwer - 31);
+	}
+	else if (TxPwer < 0)
+	{
+		//
+		// R3 can't less than 0, -1 ~ -6 used by BBP 94
+		//
+		R3 = 0;
+		if (TxPwer >= -6)
+			Bbp94 = BBPR94_DEFAULT + TxPwer;
+	}
+	else
+	{
+		// 0 ~ 31
+		R3 = (ULONG) TxPwer;
+	}
+
+
+	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
+	// We lower TX power here according to the percentage specified from UI
+	if (pAd->PortCfg.TxPowerPercentage > 90)	   // 91 ~ 100%, treat as 100% in terms of mW
+		;
+	else if (pAd->PortCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW
+	{
+		if (R3 > 2)
+			R3 -= 2;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW
+	{
+		if (R3 > 6)
+			R3 -= 6;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW
+	{
+		if (R3 > 12)
+			R3 -= 12;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW
+	{
+		if (R3 > 18)
+			R3 -= 18;
+		else
+			R3 = 0;
+	}
+	else											 // 0 ~ 9 %, treat as 6.25% in terms of mW
+	{
+		if (R3 > 24)
+			R3 -= 24;
+		else
+			R3 = 0;
+	}
+
+	if (R3 > 31)  R3 = 31;	// Maximum value 31
+
+	if (Bbp94 < 0) Bbp94 = 0;
+
+	R3 = R3 << 9; // shift TX power control to correct RF R3 bit position
+
+	switch (pAd->RfIcType)
+	{
+		case RFIC_2528:
+
+			for (index = 0; index < NUM_OF_2528_CHNL; index++)
+			{
+				if (Channel == RF2528RegTable[index].Channel)
+				{
+					R3 = R3 | (RF2528RegTable[index].R3 & 0xffffc1ff); // set TX power
+					R4 = (RF2528RegTable[index].R4 & (~0x0003f000)) | (pAd->RfFreqOffset << 12);
+
+					// Update variables
+					pAd->LatchRfRegs.Channel = Channel;
+					pAd->LatchRfRegs.R1 = RF2528RegTable[index].R1;
+					pAd->LatchRfRegs.R2 = RF2528RegTable[index].R2;
+					pAd->LatchRfRegs.R3 = R3;
+					pAd->LatchRfRegs.R4 = R4;
+
+					break;
+				}
+			}
+			break;
+
+		case RFIC_5226:
+			for (index = 0; index < NUM_OF_5226_CHNL; index++)
+			{
+				if (Channel == RF5226RegTable[index].Channel)
+				{
+					R3 = R3 | (RF5226RegTable[index].R3 & 0xffffc1ff); // set TX power
+					R4 = (RF5226RegTable[index].R4 & (~0x0003f000)) | (pAd->RfFreqOffset << 12);
+
+					// Update variables
+					pAd->LatchRfRegs.Channel = Channel;
+					pAd->LatchRfRegs.R1 = RF5226RegTable[index].R1;
+					pAd->LatchRfRegs.R2 = RF5226RegTable[index].R2;
+					pAd->LatchRfRegs.R3 = R3;
+					pAd->LatchRfRegs.R4 = R4;
+
+					break;
+				}
+			}
+			break;
+
+		case RFIC_5225:
+		case RFIC_2527:
+			for (index = 0; index < NUM_OF_5225_CHNL; index++)
+			{
+				if (Channel == RF5225RegTable[index].Channel)
+				{
+					R3 = R3 | (RF5225RegTable[index].R3 & 0xffffc1ff); // set TX power
+					R4 = (RF5225RegTable[index].R4 & (~0x0003f000)) | (pAd->RfFreqOffset << 12);
+
+					// Update variables
+					pAd->LatchRfRegs.Channel = Channel;
+					pAd->LatchRfRegs.R1 = RF5225RegTable[index].R1;
+					pAd->LatchRfRegs.R2 = RF5225RegTable[index].R2;
+					pAd->LatchRfRegs.R3 = R3;
+					pAd->LatchRfRegs.R4 = R4;
+
+					break;
+				}
+			}
+
+			RTUSBReadBBPRegister(pAd, BBP_R3, &BbpReg);
+			if ((pAd->RfIcType == RFIC_5225) || (pAd->RfIcType == RFIC_2527))
+				BbpReg &= 0xFE;    // b0=0 for none Smart mode
+			else
+				BbpReg |= 0x01;    // b0=1 for Smart mode
+			RTUSBWriteBBPRegister(pAd, BBP_R3, BbpReg);
+			break;
+
+		default:
+			break;
+	}
+
+	if (Bbp94 != BBPR94_DEFAULT)
+	{
+		RTUSBWriteBBPRegister(pAd, BBP_R94, Bbp94);
+		pAd->Bbp94 = Bbp94;
+	}
+
+	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+		if (Channel <= 14)
+		{
+			if (pAd->BbpTuning.R17LowerUpperSelect == 0)
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17LowerBoundG);
+			else
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17UpperBoundG);
+		}
+		else
+		{
+			if (pAd->BbpTuning.R17LowerUpperSelect == 0)
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17LowerBoundA);
+			else
+				RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->BbpTuning.R17UpperBoundA);
+		}
+	}
+
+	// Set RF value 1's set R3[bit2] = [0]
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+	RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+	// Set RF value 2's set R3[bit2] = [1]
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+	RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 | 0x04));
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+	// Set RF value 3's set R3[bit2] = [0]
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+	RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+	RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+	//
+	// On 11A/11G, We should delay and wait RF/BBP to be stable
+	// and the appropriate time should be 10 micro seconds
+	// It's not recommend to use NdisStallExecution on PASSIVE_LEVEL
+	// use NdisMSleep to dealy 10 microsecond instead.
+	//
+	RTMPusecDelay(10);
+
+	DBGPRINT(RT_DEBUG_TRACE, "AsicSwitchChannel(RF=%d) to #%d, TXPwr=%d%%, R1=0x%08x, R2=0x%08x, R3=0x%08x, R4=0x%08x\n",
+		pAd->RfIcType,
+		pAd->LatchRfRegs.Channel,
+		(R3 & 0x00003e00) >> 9,
+		pAd->LatchRfRegs.R1,
+		pAd->LatchRfRegs.R2,
+		pAd->LatchRfRegs.R3,
+		pAd->LatchRfRegs.R4);
+}
+
+/*
+	==========================================================================
+	Description:
+		This function is required for 2421 only, and should not be used during
+		site survey. It's only required after NIC decided to stay at a channel
+		for a longer period.
+		When this function is called, it's always after AsicSwitchChannel().
+	==========================================================================
+ */
+VOID AsicLockChannel(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR Channel)
+{
+	// Not used.
+}
+
+
+char *AntStr[3] = {"DIVERSITY","Ant-A","Ant-B"};
+
+#define SOFTWARE_DIVERSITY	0
+#define ANTENNA_A			1
+#define ANTENNA_B			2
+#define HARDWARE_DIVERSITY	3
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicAntennaSelect(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Channel)
+{
+	ULONG	*value = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	ABGBAND_STATE	BandState;
+
+
+	DBGPRINT(RT_DEBUG_INFO,"AsicAntennaSelect(ch=%d) - Tx=%s, Rx=%s\n",
+		Channel, AntStr[pAd->Antenna.field.TxDefaultAntenna], AntStr[pAd->Antenna.field.RxDefaultAntenna]);
+
+	if(!value) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+	if (Channel <= 14)
+		BandState = BG_BAND;
+	else
+		BandState = A_BAND;
+
+	//
+	//	Only the first time switch from g to a or a to g
+	//	and then will be reset the BBP, otherwise do nothing.
+	//
+	if (BandState == pAd->PortCfg.BandState)
+		return;
+
+	// Change BBP setting during siwtch from a->g, g->a
+	if (Channel <= 14)
+	{
+		if (pAd->NicConfig2.field.ExternalLNA)
+		{
+			// TRUE
+			RTUSBWriteBBPRegister(pAd, 17, 0x30); // if external LNA enable, this value need to be offset 0x10
+			RTUSBWriteBBPRegister(pAd, 96, 0x68); // if external LNA enable, R96 need to shit 0x20 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 104, 0x3C);// if external LNA enable, R104 need to shit 0x10 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 75, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 86, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 88, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+		}
+		else
+		{
+			RTUSBWriteBBPRegister(pAd, 17, 0x20);
+			RTUSBWriteBBPRegister(pAd, 96, 0x48);
+			RTUSBWriteBBPRegister(pAd, 104, 0x2C);
+			RTUSBWriteBBPRegister(pAd, 75, 0xFE);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 86, 0xFE);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 88, 0xFE);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+		}
+		RTUSBWriteBBPRegister(pAd, 35, 0x50);
+		RTUSBWriteBBPRegister(pAd, 97, 0x48);
+		RTUSBWriteBBPRegister(pAd, 98, 0x48);
+	}
+	else
+	{
+		if (pAd->NicConfig2.field.ExternalLNA)
+		{
+			RTUSBWriteBBPRegister(pAd, 17, 0x38); // if external LNA enable, this value need to be offset 0x10
+			RTUSBWriteBBPRegister(pAd, 96, 0x78); // if external LNA enable, R96 need to shit 0x20 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 104, 0x48);// if external LNA enable, R104 need to shit 0x10 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 75, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 86, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+			RTUSBWriteBBPRegister(pAd, 88, 0x80);// if external LNA enable, set this to 0x80 on B/G mode, Request by David 2005/05/12
+		}
+		else
+		{
+			RTUSBWriteBBPRegister(pAd, 17, 0x28);
+			RTUSBWriteBBPRegister(pAd, 96, 0x58);
+			RTUSBWriteBBPRegister(pAd, 104, 0x38);
+		}
+		RTUSBWriteBBPRegister(pAd, 35, 0x60);
+		RTUSBWriteBBPRegister(pAd, 97, 0x58);
+		RTUSBWriteBBPRegister(pAd, 98, 0x58);
+	}
+
+	RTUSBReadMACRegister(pAd, PHY_CSR0, value);
+	*value = *value & 0xfffcffff;   // Mask off bit 16, bit 17
+	if (Channel <= 14)
+		*value = *value | BIT32[16]; // b16 to enable G band PA_PE
+	else
+		*value = *value | BIT32[17]; // b17 to enable A band PA_PE
+	RTUSBWriteMACRegister(pAd, PHY_CSR0, *value);
+
+	pAd->PortCfg.BandState = BandState;
+
+	AsicAntennaSetting(pAd, BandState);
+	kfree(value);
+}
+
+VOID AsicAntennaSetting(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ABGBAND_STATE	BandState)
+{
+	UCHAR		R3 = 0, R4 = 0, R77 = 0;
+	UCHAR		FrameTypeMaskBit5 = 0;
+
+	// driver must disable Rx when switching antenna, otherwise ASIC will keep default state
+	// after switching, driver needs to re-enable Rx later
+	RT73WriteTXRXCSR0(pAd, TRUE,FALSE);
+	// Update antenna registers
+	RTUSBReadBBPRegister(pAd, BBP_R3, &R3);
+	RTUSBReadBBPRegister(pAd, BBP_R4, &R4);
+	RTUSBReadBBPRegister(pAd, BBP_R77, &R77);
+
+	R3	&= 0xfe;		// clear Bit 0
+	R4	&= ~0x23;		// clear Bit 0,1,5
+
+	FrameTypeMaskBit5 = ~(pAd->Antenna.field.FrameType << 5);
+
+	//
+	// For Smart a/b/g need to set R3 bit[0] to 1
+	//
+	// R3 |= 0x01;	//RFIC_5325, RFIC_2529, <Bit0> = <1>
+	//
+
+	//Select RF_Type
+	switch (pAd->Antenna.field.RfIcType)
+	{
+		case RFIC_5226:
+			//Support 11B/G/A
+			if (BandState == BG_BAND)
+			{
+				//Check Rx Anttena
+				if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					R77 = R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+				{
+					R4	= R4 | 0x22;		// <Bit5:Bit1:Bit0> = <1:1:0>
+					R4	= R4 & FrameTypeMaskBit5;
+				}
+				else
+				{
+					; //SOFTWARE_DIVERSITY
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+					pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+
+					AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+				}
+			}
+			else //A_BAND
+			{
+				//Check Rx Anttena
+				if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+				{
+					R4	= R4 | 0x02;		// <Bit5:Bit1:Bit0> = <0:1:0>
+					R4	= R4 & FrameTypeMaskBit5;
+				}
+				else
+				{
+					; //SOFTWARE_DIVERSITY
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R4	= R4 & FrameTypeMaskBit5;
+
+					pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+					pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+					AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+				}
+			}
+			break;
+
+		case RFIC_2528:
+			//Support 11B/G
+			//Check Rx Anttena
+			//Check Rx Anttena
+			if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+			{
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+				RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+			}
+			else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+			{
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+				RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+			}
+			else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+			{
+				R4	= R4 | 0x22;		// <Bit5:Bit1:Bit0> = <1:1:0>
+				R4	= R4 & FrameTypeMaskBit5;
+			}
+			else
+			{
+				; //SOFTWARE_DIVERSITY
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+				pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+				AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+			}
+			break;
+
+		case RFIC_5225:
+			//Support 11B/G/A
+			if (BandState == BG_BAND)
+			{
+				//Check Rx Anttena
+				if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R77 = R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+				{
+					R4	= R4 | 0x22;		// <Bit5:Bit1:Bit0> = <1:1:0>
+				}
+				else
+				{
+					; //SOFTWARE_DIVERSITY
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+					pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+
+					AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+				}
+			}
+			else //A_BAND
+			{
+				//Check Rx Anttena
+				if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+				{
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+					RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+				}
+				else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+				{
+					R4	= R4 | 0x02;		// <Bit5:Bit1:Bit0> = <0:1:0>
+				}
+				else
+				{
+					; //SOFTWARE_DIVERSITY
+					R4	= R4 | 0x01;		// <Bit5:Bit1:Bit0> = <0:0:1>
+					pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+					pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+					AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+				}
+			}
+			break;
+
+		case RFIC_2527:
+			//Support 11B/G
+			//Check Rx Anttena
+			//Check Rx Anttena
+			if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_A)
+			{
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+
+				RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+			}
+			else if (pAd->Antenna.field.RxDefaultAntenna == ANTENNA_B)
+			{
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				R77 = R77 & 0xfc;		// <Bit1:Bit0> = <0:0>
+
+				RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+			}
+			else if (pAd->Antenna.field.RxDefaultAntenna == HARDWARE_DIVERSITY)
+			{
+				R4	= R4 | 0x22;		// <Bit5:Bit1:Bit0> = <1:1:0>
+				R4	= R4 & FrameTypeMaskBit5;
+			}
+			else
+			{
+				; //SOFTWARE_DIVERSITY
+				R4	= R4 | 0x21;		// <Bit5:Bit1:Bit0> = <1:0:1>
+				R4	= R4 & FrameTypeMaskBit5;
+
+				pAd->RxAnt.Pair1PrimaryRxAnt   = 1;  // assume ant-B
+				pAd->RxAnt.Pair1SecondaryRxAnt = 0;  // assume ant-A
+				AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair2PrimaryRxAnt);
+			}
+			break;
+
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "Unkown RFIC Type\n");
+			break;
+	}
+
+	RTUSBWriteBBPRegister(pAd, BBP_R3, R3);
+	RTUSBWriteBBPRegister(pAd, BBP_R4, R4);
+
+	RT73WriteTXRXCSR0(pAd, FALSE, TRUE);		 // Staion not drop control frame will fail WiFi Certification.
+}
+
+/*
+	==========================================================================
+	Description:
+		Gives CCK TX rate 2 more dB TX power.
+		This routine works only in LINK UP in INFRASTRUCTURE mode.
+
+		calculate desired Tx power in RF R3.Tx0~5,	should consider -
+		0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)
+		1. TxPowerPercentage
+		2. auto calibration based on TSSI feedback
+		3. extra 2 db for CCK
+		4. -10 db upon very-short distance (AvgRSSI >= -40db) to AP
+
+	NOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),
+		it should be called AFTER MlmeDynamicTxRatSwitching()
+	==========================================================================
+ */
+VOID AsicAdjustTxPower(
+	IN PRTMP_ADAPTER pAd)
+{
+	ULONG	R3, CurrTxPwr;
+	SHORT	dbm;
+	UCHAR	TxRate, Channel, index;
+	BOOLEAN bAutoTxAgc = FALSE;
+	UCHAR	TssiRef, *pTssiMinusBoundary, *pTssiPlusBoundary, TxAgcStep;
+	UCHAR	BbpR1, idx;
+	PCHAR	pTxAgcCompensate;
+	CHAR	TxPwer=0;
+
+	TxRate	= pAd->PortCfg.TxRate;
+	Channel = pAd->PortCfg.Channel;
+
+	dbm = pAd->PortCfg.AvgRssi - pAd->BbpRssiToDbmDelta;
+
+	// get TX Power base from E2PROM
+	R3 = DEFAULT_RF_TX_POWER;
+	for (index= 0 ; index < pAd->ChannelListNum; index++)
+	{
+		if (pAd->ChannelList[index].Channel == pAd->PortCfg.Channel)
+		{
+			TxPwer = pAd->ChannelList[index].Power;
+			break;
+		}
+	}
+
+	if ((TxPwer > 31) || (TxPwer < 0))
+		R3 = 0;
+	else
+		R3 = (ULONG) TxPwer;
+
+	if (R3 > 31) R3 = 31;
+
+	// error handling just in case
+	if (index >= pAd->ChannelListNum)
+	{
+		DBGPRINT_ERR("AsicAdjustTxPower(can find pAd->PortCfg.Channel=%d in ChannelList[%d]\n", pAd->PortCfg.Channel, pAd->ChannelListNum);
+		return;
+	}
+
+	// TX power compensation for temperature variation based on TSSI. try every 4 second
+	if (pAd->Mlme.PeriodicRound % 4 == 0)
+	{
+		if (pAd->PortCfg.Channel <= 14)
+		{
+			bAutoTxAgc		   = pAd->bAutoTxAgcG;
+			TssiRef 		   = pAd->TssiRefG;
+			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
+			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryG[0];
+			TxAgcStep		   = pAd->TxAgcStepG;
+			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+		}
+		else
+		{
+			bAutoTxAgc		   = pAd->bAutoTxAgcA;
+			TssiRef 		   = pAd->TssiRefA;
+			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
+			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryA[0];
+			TxAgcStep		   = pAd->TxAgcStepA;
+			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+		}
+
+		if (bAutoTxAgc)
+		{
+			RTUSBReadBBPRegister(pAd, BBP_R1,  &BbpR1);
+			if (BbpR1 > pTssiMinusBoundary[1])
+			{
+				// Reading is larger than the reference value
+				// check for how large we need to decrease the Tx power
+				for (idx = 1; idx < 5; idx++)
+				{
+					if (BbpR1 <= pAd->TssiMinusBoundaryG[idx])	// Found the range
+						break;
+				}
+				// The index is the step we should decrease, idx = 0 means there is nothing to compensate
+				if (R3 > (ULONG) (TxAgcStep * (idx-1)))
+					*pTxAgcCompensate = -(TxAgcStep * (idx-1));
+				else
+					*pTxAgcCompensate = -((UCHAR)R3);
+
+				R3 += (*pTxAgcCompensate);
+				DBGPRINT(RT_DEBUG_TRACE, "-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
+					BbpR1, TssiRef, TxAgcStep, idx-1);
+			}
+			else if (BbpR1 < pTssiPlusBoundary[1])
+			{
+				// Reading is smaller than the reference value
+				// check for how large we need to increase the Tx power
+				for (idx = 1; idx < 5; idx++)
+				{
+					if (BbpR1 >= pTssiPlusBoundary[idx])   // Found the range
+						break;
+				}
+				// The index is the step we should increase, idx = 0 means there is nothing to compensate
+				*pTxAgcCompensate = TxAgcStep * (idx-1);
+				R3 += (*pTxAgcCompensate);
+				DBGPRINT(RT_DEBUG_TRACE, "++ Tx Power, BBP R1=%x, Tssi0=%x, TxAgcStep=%x, step = +%d\n",
+					BbpR1, TssiRef, TxAgcStep, idx-1);
+			}
+		}
+	}
+	else
+	{
+		if (pAd->PortCfg.Channel <= 14)
+		{
+			bAutoTxAgc		   = pAd->bAutoTxAgcG;
+			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+		}
+		else
+		{
+			bAutoTxAgc		   = pAd->bAutoTxAgcA;
+			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+		}
+
+		if (bAutoTxAgc)
+			R3 += (*pTxAgcCompensate);
+	}
+
+
+	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
+	// We lower TX power here according to the percentage specified from UI
+	if (pAd->PortCfg.TxPowerPercentage == 0xffffffff)		// AUTO TX POWER control
+	{
+#if 1
+		// only INFRASTRUCTURE mode and AUTO-TX-power need furthur calibration
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		{
+			// low TX power upon very-short distance to AP to solve some vendor's AP RX problem
+			// in this case, no TSSI compensation is required.
+			if (dbm > RSSI_FOR_LOWEST_TX_POWER)
+			{
+				if (R3 > LOWEST_TX_POWER_DELTA)
+					R3 -= LOWEST_TX_POWER_DELTA;
+				else
+					R3 = 0;
+			}
+			else if (dbm > RSSI_FOR_LOW_TX_POWER)
+			{
+				if (R3 > LOW_TX_POWER_DELTA)
+					R3 -= LOW_TX_POWER_DELTA;
+				else
+					R3 = 0;
+			}
+		}
+#endif
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 90)  // 91 ~ 100% & AUTO, treat as 100% in terms of mW
+		;
+	else if (pAd->PortCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW
+	{
+		if (R3 > 2)
+			R3 -= 2;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW
+	{
+		if (R3 > 6)
+			R3 -= 6;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW
+	{
+		if (R3 > 12)
+			R3 -= 12;
+		else
+			R3 = 0;
+	}
+	else if (pAd->PortCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW
+	{
+		if (R3 > 18)
+			R3 -= 18;
+		else
+			R3 = 0;
+	}
+	else										   // 0 ~ 9 %, treat as MIN(~3%) in terms of mW
+	{
+		if (R3 > 24)
+			R3 -= 24;
+		else
+			R3 = 0;
+	}
+
+	if (R3 > 31)  R3 = 31;	 //Maximum value 31
+
+	// compare the desired R3.TxPwr value with current R3, if not equal
+	// set new R3.TxPwr
+	CurrTxPwr = (pAd->LatchRfRegs.R3 >> 9) & 0x0000001f;
+	if (CurrTxPwr != R3)
+	{
+		CurrTxPwr = R3;
+		R3 = (pAd->LatchRfRegs.R3 & 0xffffc1ff) | (R3 << 9);
+		pAd->LatchRfRegs.R3 = R3;
+
+		// Set RF value 1's set R3[bit2] = [0]
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+		RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+		// Set RF value 2's set R3[bit2] = [1]
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+		RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 | 0x04));
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+		// Set RF value 3's set R3[bit2] = [0]
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R1);
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R2);
+		RTUSBWriteRFRegister(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+		RTUSBWriteRFRegister(pAd, pAd->LatchRfRegs.R4);
+
+//		DBGPRINT(RT_DEBUG_TRACE, "AsicAdjustTxPower = %d, AvgRssi = %d\n", CurrTxPwr, dbm);
+	}
+		DBGPRINT(RT_DEBUG_TRACE, "AsicAdjustTxPower = %d, AvgRssi = %d\n", CurrTxPwr, dbm);
+
+}
+
+/*
+	==========================================================================
+	Description:
+		put PHY to sleep here, and set next wakeup timer. PHY doesn't not wakeup
+		automatically. Instead, MCU will issue a TwakeUpInterrupt to host after
+		the wakeup timer timeout. Driver has to issue a separate command to wake
+		PHY up.
+
+	==========================================================================
+ */
+VOID AsicSleepThenAutoWakeup(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT TbttNumToNextWakeUp)
+{
+	MAC_CSR11_STRUC csr11;
+
+	// we have decided to SLEEP, so at least do it for a BEACON period.
+	if (TbttNumToNextWakeUp == 0)
+		TbttNumToNextWakeUp = 1;
+
+	// set MAC_CSR11 for next wakeup
+	csr11.word = 0;
+	csr11.field.Sleep2AwakeLatency = 5;
+	csr11.field.NumOfTBTTBeforeWakeup = TbttNumToNextWakeUp - 1;
+	csr11.field.DelayAfterLastTBTTBeforeWakeup = pAd->PortCfg.BeaconPeriod - 10; // 5 TU ahead of desired TBTT
+
+	// To make sure ASIC Auto-Wakeup functionality works properly
+	// We must disable it first to let ASIC recounting the Auto-Wakeup period.
+	// After that enable it.
+	//
+	csr11.field.bAutoWakeupEnable = 0;	//Disable
+	RTUSBWriteMACRegister(pAd, MAC_CSR11, csr11.word);
+
+	csr11.field.bAutoWakeupEnable = 1;	//Enable
+	RTUSBWriteMACRegister(pAd, MAC_CSR11, csr11.word);
+
+	DBGPRINT(RT_DEBUG_TRACE, ">>>AsicSleepThenAutoWakeup(sleep %d TU)<<<\n",
+			(csr11.field.NumOfTBTTBeforeWakeup * pAd->PortCfg.BeaconPeriod) + csr11.field.DelayAfterLastTBTTBeforeWakeup);
+
+	RTUSBPutToSleep(pAd);
+
+	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
+}
+
+/*
+	==========================================================================
+	Description:
+		AsicForceWakeup() is used whenever manual wakeup is required
+		AsicForceSleep() should only be used when not in INFRA BSS. When
+		in INFRA BSS, we should use AsicSleepThenAutoWakeup() instead.
+	==========================================================================
+ */
+VOID AsicForceSleep(
+	IN PRTMP_ADAPTER pAd)
+{
+	MAC_CSR11_STRUC csr11;
+
+	DBGPRINT(RT_DEBUG_TRACE, ">>>AsicForceSleep<<<\n");
+
+	// no auto wakeup
+	csr11.word = 0;
+	csr11.field.Sleep2AwakeLatency = 5;
+	csr11.field.bAutoWakeupEnable = 0;
+	RTUSBWriteMACRegister(pAd, MAC_CSR11, csr11.word);
+
+	RTUSBPutToSleep(pAd);
+
+	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
+}
+
+/*
+	==========================================================================
+	Description:
+		AsicForceWakeup() is used whenever Twakeup timer (set via AsicSleepThenAutoWakeup)
+		expired.
+
+	==========================================================================
+ */
+VOID AsicForceWakeup(
+	IN PRTMP_ADAPTER pAd)
+{
+	MAC_CSR11_STRUC csr11;
+
+	DBGPRINT(RT_DEBUG_TRACE, ">>>AsicForceWakeup<<<\n");
+
+	RTUSBWakeUp(pAd);
+
+	// cancel auto wakeup timer
+	csr11.word = 0;
+	csr11.field.Sleep2AwakeLatency = 5;
+	csr11.field.bAutoWakeupEnable = 0;
+	RTUSBWriteMACRegister(pAd, MAC_CSR11, csr11.word);
+
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+}
+
+/*
+	==========================================================================
+	Description:
+
+	==========================================================================
+ */
+VOID AsicSetBssid(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR		 pBssid)
+{
+	ULONG		  Addr4;
+
+	DBGPRINT(RT_DEBUG_TRACE, ">>>AsicSetBssid<<<\n");
+
+	Addr4 = (ULONG)(pBssid[0])		 |
+			(ULONG)(pBssid[1] << 8)  |
+			(ULONG)(pBssid[2] << 16) |
+			(ULONG)(pBssid[3] << 24);
+	RTUSBWriteMACRegister(pAd, MAC_CSR4, Addr4);
+
+	// always one BSSID in STA mode
+	Addr4 = (ULONG)(pBssid[4]) | (ULONG)(pBssid[5] << 8) | 0x00030000;
+	RTUSBWriteMACRegister(pAd, MAC_CSR5, Addr4);
+}
+
+/*
+	==========================================================================
+	Description:
+
+	==========================================================================
+ */
+VOID AsicDisableSync(
+	IN PRTMP_ADAPTER pAd)
+{
+	TXRX_CSR9_STRUC *csr = kzalloc(sizeof(TXRX_CSR9_STRUC), GFP_KERNEL);
+	DBGPRINT(RT_DEBUG_TRACE, "--->Disable TSF synchronization\n");
+
+	if(!csr) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+
+	// 2003-12-20 disable TSF and TBTT while NIC in power-saving have side effect
+	//			  that NIC will never wakes up because TSF stops and no more
+	//			  TBTT interrupts
+	RTUSBReadMACRegister(pAd, TXRX_CSR9, &csr->word);
+	csr->field.bBeaconGen = 0;
+	csr->field.TsfSyncMode = 0;
+	csr->field.bTBTTEnable = 0;
+	csr->field.bTsfTicking = 0;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR9, csr->word);
+	kfree(csr);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicEnableBssSync(
+	IN PRTMP_ADAPTER pAd)
+{
+	TXRX_CSR9_STRUC *csr = kzalloc(sizeof(TXRX_CSR9_STRUC), GFP_KERNEL);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->AsicEnableBssSync(INFRA mode)\n");
+
+	if(!csr) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+
+	RTUSBReadMACRegister(pAd, TXRX_CSR9, &csr->word);
+
+
+	csr->field.BeaconInterval = pAd->PortCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
+	csr->field.bTsfTicking = 1;
+	csr->field.TsfSyncMode = 1; // sync TSF in INFRASTRUCTURE mode
+	csr->field.bBeaconGen  = 0; // do NOT generate BEACON
+	csr->field.bTBTTEnable = 1;
+
+	RTUSBWriteMACRegister(pAd, TXRX_CSR9, csr->word);
+	kfree(csr);
+}
+
+/*
+	==========================================================================
+	Description:
+	Note:
+		BEACON frame in shared memory should be built ok before this routine
+		can be called. Otherwise, a garbage frame maybe transmitted out every
+		Beacon period.
+
+	==========================================================================
+ */
+VOID AsicEnableIbssSync(
+	IN PRTMP_ADAPTER pAd)
+{
+	TXRX_CSR9_STRUC *csr9 = kmalloc(sizeof(TXRX_CSR9_STRUC), GFP_KERNEL);
+	PUCHAR			ptr;
+	UINT i;
+	DBGPRINT(RT_DEBUG_ERROR, "--->AsicEnableIbssSync(ADHOC mode)\n");
+
+	RTUSBReadMACRegister(pAd, TXRX_CSR9, &csr9->word);
+	csr9->field.bBeaconGen = 0;
+	csr9->field.bTBTTEnable = 0;
+	csr9->field.bTsfTicking = 0;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR9, csr9->word);
+
+	RTUSBWriteMACRegister(pAd, HW_BEACON_BASE0, 0); // invalidate BEACON0 owner/valid bit to prevent garbage
+	RTUSBWriteMACRegister(pAd, HW_BEACON_BASE1, 0); // invalidate BEACON1 owner/valid bit to prevent garbage
+	RTUSBWriteMACRegister(pAd, HW_BEACON_BASE2, 0); // invalidate BEACON2 owner/valid bit to prevent garbage
+	RTUSBWriteMACRegister(pAd, HW_BEACON_BASE3, 0); // invalidate BEACON3 owner/valid bit to prevent garbage
+
+	// move BEACON TXD and frame content to on-chip memory
+	ptr = (PUCHAR)&pAd->BeaconTxD;
+	for (i = 0; i < TXINFO_SIZE; i += 4)  // 24-byte TXINFO field
+	{
+		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + i, ptr, 4);
+		ptr += 4;
+	}
+
+	// start right after the 24-byte TXINFO field
+	ptr = pAd->BeaconBuf;
+	for (i = 0; i < pAd->BeaconTxD.DataByteCnt; i += 4)
+	{
+		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXINFO_SIZE + i, ptr, 4);
+		ptr += 4;
+	}
+
+	//
+	// For Wi-Fi faily generated beacons between participating stations.
+	// Set TBTT phase adaptive adjustment step to 8us (default 16us)
+	//
+	RTUSBWriteMACRegister(pAd, TXRX_CSR10, 0x00001008);
+
+	// start sending BEACON
+	csr9->field.BeaconInterval = pAd->PortCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
+	csr9->field.bTsfTicking = 1;
+	csr9->field.TsfSyncMode = 2; // sync TSF in IBSS mode
+	csr9->field.bTBTTEnable = 1;
+	csr9->field.bBeaconGen = 1;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR9, csr9->word);
+	kfree(csr9);
+
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSetEdcaParm(
+	IN PRTMP_ADAPTER pAd,
+	IN PEDCA_PARM	 pEdcaParm)
+{
+	AC_TXOP_CSR0_STRUC csr0;
+	AC_TXOP_CSR1_STRUC csr1;
+	AIFSN_CSR_STRUC    AifsnCsr;
+	CWMIN_CSR_STRUC    CwminCsr;
+	CWMAX_CSR_STRUC    CwmaxCsr;
+
+	DBGPRINT(RT_DEBUG_TRACE,"AsicSetEdcaParm\n");
+	if ((pEdcaParm == NULL) || (pEdcaParm->bValid == FALSE) || (pAd->PortCfg.bWmmCapable == FALSE))
+	{
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WMM_INUSED);
+
+		csr0.field.Ac0Txop = 0; 	// QID_AC_BE
+		csr0.field.Ac1Txop = 0; 	// QID_AC_BK
+		RTUSBWriteMACRegister(pAd, AC_TXOP_CSR0, csr0.word);
+		if (pAd->PortCfg.PhyMode == PHY_11B)
+		{
+			csr1.field.Ac2Txop = cpu2le16(192); 	// AC_VI: 192*32us ~= 6ms
+			csr1.field.Ac3Txop = cpu2le16(96);		// AC_VO: 96*32us  ~= 3ms
+		}
+		else
+		{
+			csr1.field.Ac2Txop = cpu2le16(96);		// AC_VI: 96*32us ~= 3ms
+			csr1.field.Ac3Txop = cpu2le16(48);		// AC_VO: 48*32us ~= 1.5ms
+		}
+		RTUSBWriteMACRegister(pAd, AC_TXOP_CSR1, csr1.word);
+
+		CwminCsr.word = 0;
+		CwminCsr.field.Cwmin0 = CW_MIN_IN_BITS;
+		CwminCsr.field.Cwmin1 = CW_MIN_IN_BITS;
+		CwminCsr.field.Cwmin2 = CW_MIN_IN_BITS;
+		CwminCsr.field.Cwmin3 = CW_MIN_IN_BITS;
+		RTUSBWriteMACRegister(pAd, CWMIN_CSR, CwminCsr.word);
+
+		CwmaxCsr.word = 0;
+		CwmaxCsr.field.Cwmax0 = CW_MAX_IN_BITS;
+		CwmaxCsr.field.Cwmax1 = CW_MAX_IN_BITS;
+		CwmaxCsr.field.Cwmax2 = CW_MAX_IN_BITS;
+		CwmaxCsr.field.Cwmax3 = CW_MAX_IN_BITS;
+		RTUSBWriteMACRegister(pAd, CWMAX_CSR, CwmaxCsr.word);
+
+		RTUSBWriteMACRegister(pAd, AIFSN_CSR, 0x00002222);
+
+		memset(&pAd->PortCfg.APEdcaParm, 0, sizeof(EDCA_PARM));
+	}
+	else
+	{
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WMM_INUSED);
+
+		//
+		// Modify Cwmin/Cwmax/Txop on queue[QID_AC_VI], Recommend by Jerry 2005/07/27
+		// To degrade our VIDO Queue's throughput for WiFi WMM S3T07 Issue.
+		//
+		pEdcaParm->Cwmin[QID_AC_VI] += 1;
+		pEdcaParm->Cwmax[QID_AC_VI] += 1;
+		pEdcaParm->Txop[QID_AC_VI] = pEdcaParm->Txop[QID_AC_VI] * 7 / 10;
+
+		csr0.field.Ac0Txop = cpu2le16(pEdcaParm->Txop[QID_AC_BE]);
+		csr0.field.Ac1Txop = cpu2le16(pEdcaParm->Txop[QID_AC_BK]);
+		RTUSBWriteMACRegister(pAd, AC_TXOP_CSR0, csr0.word);
+
+		csr1.field.Ac2Txop = cpu2le16(pEdcaParm->Txop[QID_AC_VI]);
+		csr1.field.Ac3Txop = cpu2le16(pEdcaParm->Txop[QID_AC_VO]);
+		RTUSBWriteMACRegister(pAd, AC_TXOP_CSR1, csr1.word);
+
+		CwminCsr.word = 0;
+		CwminCsr.field.Cwmin0 = pEdcaParm->Cwmin[QID_AC_BE];
+		CwminCsr.field.Cwmin1 = pEdcaParm->Cwmin[QID_AC_BK];
+		CwminCsr.field.Cwmin2 = pEdcaParm->Cwmin[QID_AC_VI];
+		CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO];
+		RTUSBWriteMACRegister(pAd, CWMIN_CSR, CwminCsr.word);
+
+		CwmaxCsr.word = 0;
+		CwmaxCsr.field.Cwmax0 = pEdcaParm->Cwmax[QID_AC_BE];
+		CwmaxCsr.field.Cwmax1 = pEdcaParm->Cwmax[QID_AC_BK];
+		CwmaxCsr.field.Cwmax2 = pEdcaParm->Cwmax[QID_AC_VI];
+		CwmaxCsr.field.Cwmax3 = pEdcaParm->Cwmax[QID_AC_VO];
+		RTUSBWriteMACRegister(pAd, CWMAX_CSR, CwmaxCsr.word);
+
+		AifsnCsr.word = 0;
+		AifsnCsr.field.Aifsn0 = pEdcaParm->Aifsn[QID_AC_BE];
+		AifsnCsr.field.Aifsn1 = pEdcaParm->Aifsn[QID_AC_BK];
+		AifsnCsr.field.Aifsn2 = pEdcaParm->Aifsn[QID_AC_VI];
+		AifsnCsr.field.Aifsn3 = pEdcaParm->Aifsn[QID_AC_VO];
+		RTUSBWriteMACRegister(pAd, AIFSN_CSR, AifsnCsr.word);
+
+		memcpy(&pAd->PortCfg.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+
+		DBGPRINT(RT_DEBUG_TRACE,"EDCA [#%d]: AIFSN CWmin CWmax	TXOP(us)  ACM\n", pEdcaParm->EdcaUpdateCount);
+		DBGPRINT(RT_DEBUG_TRACE,"	 AC_BE	   %d	  %d	 %d 	%4d 	%d\n",
+			pEdcaParm->Aifsn[0],
+			pEdcaParm->Cwmin[0],
+			pEdcaParm->Cwmax[0],
+			pEdcaParm->Txop[0]<<5,
+			pEdcaParm->bACM[0]);
+		DBGPRINT(RT_DEBUG_TRACE,"	 AC_BK	   %d	  %d	 %d 	%4d 	%d\n",
+			pEdcaParm->Aifsn[1],
+			pEdcaParm->Cwmin[1],
+			pEdcaParm->Cwmax[1],
+			pEdcaParm->Txop[1]<<5,
+			pEdcaParm->bACM[1]);
+		DBGPRINT(RT_DEBUG_TRACE,"	 AC_VI	   %d	  %d	 %d 	%4d 	%d\n",
+			pEdcaParm->Aifsn[2],
+			pEdcaParm->Cwmin[2],
+			pEdcaParm->Cwmax[2],
+			pEdcaParm->Txop[2]<<5,
+			pEdcaParm->bACM[2]);
+		DBGPRINT(RT_DEBUG_TRACE,"	 AC_VO	   %d	  %d	 %d 	%4d 	%d\n",
+			pEdcaParm->Aifsn[3],
+			pEdcaParm->Cwmin[3],
+			pEdcaParm->Cwmax[3],
+			pEdcaParm->Txop[3]<<5,
+			pEdcaParm->bACM[3]);
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSetSlotTime(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN		 bUseShortSlotTime)
+{
+	MAC_CSR9_STRUC *Csr9 = kzalloc(sizeof(MAC_CSR9_STRUC), GFP_KERNEL);
+
+	if(!Csr9) {
+                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+	if ( pAd->PortCfg.Channel > 14)  //check if in the A band
+		bUseShortSlotTime = TRUE;
+
+	if (bUseShortSlotTime && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
+	{
+		kfree(Csr9);
+		return;
+	}
+	else if ((!bUseShortSlotTime) && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)))
+	{
+		kfree(Csr9);
+		return;
+	}
+	if (bUseShortSlotTime)
+		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
+	else
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
+
+	RTUSBReadMACRegister(pAd, MAC_CSR9, &Csr9->word);
+	Csr9->field.SlotTime = (bUseShortSlotTime)? 9 : 20;
+
+	// force using short SLOT time for FAE to demo performance when TxBurst is ON
+	if (pAd->PortCfg.bEnableTxBurst)
+		Csr9->field.SlotTime = 9;
+
+	if (pAd->PortCfg.BssType == BSS_ADHOC)
+		Csr9->field.SlotTime = 20;
+
+	RTUSBWriteMACRegister(pAd, MAC_CSR9, Csr9->word);
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "AsicSetSlotTime(=%d us)\n", Csr9->field.SlotTime);
+        kfree(Csr9);
+}
+
+/*
+	==========================================================================
+	Description:
+		danamic tune BBP R17 to find a balance between sensibility and
+		noise isolation
+
+	==========================================================================
+ */
+VOID AsicBbpTuning(
+	IN PRTMP_ADAPTER pAd)
+{
+	UCHAR R17, R17UpperBound, R17LowerBound;
+	int dbm;
+
+    if ((pAd->BbpTuning.bEnable == FALSE) || (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
+        return;
+
+	if (pAd->BbpTuning.bEnable == FALSE)
+		return;
+
+	R17 = pAd->BbpWriteLatch[17];
+
+	//
+	// I. Work as a STA
+	//
+	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)  // no R17 tuning when SCANNING
+		return;
+
+	dbm = pAd->PortCfg.AvgRssi - pAd->BbpRssiToDbmDelta;
+
+	//
+	// Decide R17 Range.
+	//
+	if (dbm > -82)
+	{
+		pAd->BbpTuning.R17LowerBoundG         = 0x1C; // for best RX sensibility
+		pAd->BbpTuning.R17UpperBoundG		  = 0x40; // for best RX noise isolation to prevent false CCA
+	}
+	else if (dbm > -84)
+	{
+		pAd->BbpTuning.R17LowerBoundG         = 0x1C; // for best RX sensibility
+		pAd->BbpTuning.R17UpperBoundG		  = 0x20; // for best RX noise isolation to prevent false CCA
+	}
+	else
+	{
+		pAd->BbpTuning.R17LowerBoundG         = 0x1C; // for best RX sensibility
+		pAd->BbpTuning.R17UpperBoundG         = 0x1C; // for best RX noise isolation to prevent false CCA
+	}
+
+	// external LNA has different R17 base
+	if (pAd->NicConfig2.field.ExternalLNA)
+	{
+		pAd->BbpTuning.R17LowerBoundG += 0x14;
+		pAd->BbpTuning.R17UpperBoundG += 0x10;
+	}
+
+	if (pAd->LatchRfRegs.Channel <= 14)
+	{
+		R17UpperBound = pAd->BbpTuning.R17UpperBoundG;
+		R17LowerBound = pAd->BbpTuning.R17LowerBoundG;
+	}
+	else
+	{
+		R17UpperBound = pAd->BbpTuning.R17UpperBoundA;
+		R17LowerBound = pAd->BbpTuning.R17LowerBoundA;
+	}
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+	{
+#if 0
+		// Rule 0. "long distance case"
+		//	 when RSSI is too weak, many signals will become false CCA thus affect R17 tuning.
+		//	 so in this case, just stop R17 tuning
+		if ((dbm < -80) && (pAd->Mlme.PeriodicRound > 20))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "weak RSSI=%d, CCA=%d, stop tuning, R17 = 0x%x\n",
+				dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+			return;
+		}
+
+		// Rule 1. "special big-R17 for short-distance" when not SCANNING
+		else
+#endif
+		if (dbm >= RSSI_FOR_VERY_LOW_SENSIBILITY)
+		{
+			if (R17 != 0x60) // R17UpperBound)
+			{
+				R17 = 0x60; // R17UpperBound;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Avg RSSI=%d, BbpRssiToDbmDelta =%d\n", pAd->PortCfg.AvgRssi, pAd->BbpRssiToDbmDelta);
+			DBGPRINT(RT_DEBUG_TRACE, " 2 strong RSSI=%d, CCA=%d, fixed R17 at 0x%x\n",
+				dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+			return;
+		}
+
+		else if (dbm >= RSSI_FOR_LOW_SENSIBILITY)
+		{
+			if (R17 != R17UpperBound)
+			{
+				R17 = R17UpperBound;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "3 strong RSSI=%d, CCA=%d, fixed R17 at 0x%x\n",
+				dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+			return;
+		}
+
+		else if (dbm >= RSSI_FOR_MID_LOW_SENSIBILITY)
+		{
+			if (R17 != (R17LowerBound + 0x10))
+			{
+				R17 = R17LowerBound + 0x10;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "mid RSSI=%d, CCA=%d, fixed R17 at 0x%x\n",
+				dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+			return;
+		}
+
+		// Rule 2. "middle-R17 for mid-distance" when not SCANNING
+		else if (dbm >= RSSI_FOR_MID_SENSIBILITY)
+		{
+			if (R17 != (R17LowerBound + 0x10))
+			{
+				R17 = R17LowerBound + 0x08;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "mid RSSI=%d, CCA=%d, fixed R17 at 0x%x\n",
+				dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+			return;
+		}
+
+		// Rule 2.1 originated from RT2500 Netopia case which changes R17UpperBound according
+		//			to RSSI.
+		else
+		{
+			// lower R17UpperBound when RSSI weaker than -70 dbm
+			R17UpperBound -= 2*(RSSI_FOR_MID_SENSIBILITY - dbm);
+			if (R17UpperBound < R17LowerBound)
+				R17UpperBound = R17LowerBound;
+
+			if (R17 > R17UpperBound)
+			{
+				R17 = R17UpperBound;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+				DBGPRINT(RT_DEBUG_TRACE, "RSSI=%d, CCA=%d, R17=R17UpperBound=0x%x\n", dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+				return;
+			}
+
+			// if R17 not exceeds R17UpperBound yet, then goes down to Rule 3 "R17 tuning based on False CCA"
+		}
+
+	}
+
+	// Rule 3. otherwise, R17 is currenly in dynamic tuning range
+	//	  Keep dynamic tuning based on False CCA counter
+
+	if ((pAd->RalinkCounters.OneSecFalseCCACnt > pAd->BbpTuning.FalseCcaUpperThreshold) &&
+		(R17 < R17UpperBound))
+	{
+		R17 += pAd->BbpTuning.R17Delta;
+
+		if (R17 >= R17UpperBound)
+			R17 = R17UpperBound;
+
+		RTUSBWriteBBPRegister(pAd, 17, R17);
+		DBGPRINT(RT_DEBUG_TRACE, "RSSI=%d, CCA=%d, ++R17= 0x%x\n", dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+	}
+	else if ((pAd->RalinkCounters.OneSecFalseCCACnt < pAd->BbpTuning.FalseCcaLowerThreshold) &&
+		(R17 > R17LowerBound))
+	{
+		R17 -= pAd->BbpTuning.R17Delta;
+
+		if (R17 <= R17LowerBound)
+			R17 = R17LowerBound;
+
+		RTUSBWriteBBPRegister(pAd, 17, R17);
+		DBGPRINT(RT_DEBUG_TRACE, "RSSI=%d, CCA=%d, --R17= 0x%x\n", dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "RSSI=%d, CCA=%d, keep R17 at 0x%x\n", dbm, pAd->RalinkCounters.OneSecFalseCCACnt, R17);
+	}
+
+}
+
+VOID AsicAddSharedKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 BssIndex,
+	IN UCHAR		 KeyIdx,
+	IN UCHAR		 CipherAlg,
+	IN PUCHAR		 pKey,
+	IN PUCHAR		 pTxMic,
+	IN PUCHAR		 pRxMic)
+{
+	INT   i;
+	ULONG offset, csr0;
+	SEC_CSR1_STRUC csr1;
+
+		union aaa {
+		ULONG	temp_ul;
+		struct bbb{
+			UCHAR ch1;
+			UCHAR ch2;
+			UCHAR ch3;
+			UCHAR ch4;
+			} temp_uc;
+	} ddd;
+
+	DBGPRINT(RT_DEBUG_TRACE, "AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg], BssIndex*4 + KeyIdx);
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Key =");
+	for (i = 0; i < 16; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pKey[i]);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	if (pRxMic)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Rx MIC Key = ");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pRxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	}
+	if (pTxMic)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Tx MIC Key = ");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pTxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	}
+
+	//
+	// enable this key entry
+	//
+	RTUSBReadMACRegister(pAd, SEC_CSR0, &csr0);
+	csr0 = csr0 & ~BIT32[BssIndex*4 + KeyIdx];	   // turrn off   the valid bit
+	RTUSBWriteMACRegister(pAd, SEC_CSR0, csr0);
+
+
+	//
+	// fill key material - key + TX MIC + RX MIC
+	//
+	offset = SHARED_KEY_TABLE_BASE + (4*BssIndex + KeyIdx)*HW_KEY_ENTRY_SIZE;
+
+	for (i=0; i<MAX_LEN_OF_SHARE_KEY; i = i+4)
+	{
+		ddd.temp_uc.ch1  = pKey[i];
+		ddd.temp_uc.ch2 =  pKey[i+1];
+		ddd.temp_uc.ch3 =  pKey[i+2];
+		ddd.temp_uc.ch4 =  pKey[i+3];
+
+		RTUSBWriteMACRegister(pAd, (USHORT) (offset + i), ddd.temp_ul);
+	}
+
+	offset += MAX_LEN_OF_SHARE_KEY;
+	if (pTxMic)
+	{
+		for (i=0; i<8; i=i+4)
+		{
+			ddd.temp_uc.ch1  = pTxMic[i];
+			ddd.temp_uc.ch2 =  pTxMic[i+1];
+			ddd.temp_uc.ch3 =  pTxMic[i+2];
+			ddd.temp_uc.ch4 =  pTxMic[i+3];
+			RTUSBWriteMACRegister(pAd, (USHORT) (offset + i), ddd.temp_ul);
+		}
+	}
+
+	offset += 8;
+	if (pRxMic)
+	{
+		for (i=0; i<8; i = i+4)
+		{
+			ddd.temp_uc.ch1  = pRxMic[i];
+			ddd.temp_uc.ch2 =  pRxMic[i+1];
+			ddd.temp_uc.ch3 =  pRxMic[i+2];
+			ddd.temp_uc.ch4 =  pRxMic[i+3];
+
+			RTUSBWriteMACRegister(pAd, (USHORT) (offset + i), ddd.temp_ul);
+		}
+	}
+
+	//
+	// Update cipher algorithm. STA always use BSS0
+	//
+	RTUSBReadMACRegister(pAd, SEC_CSR1, &csr1.word);
+	if (KeyIdx == 0)
+		csr1.field.Bss0Key0CipherAlg = CipherAlg;
+	else if (KeyIdx == 1)
+		csr1.field.Bss0Key1CipherAlg = CipherAlg;
+	else if (KeyIdx == 2)
+		csr1.field.Bss0Key2CipherAlg = CipherAlg;
+	else
+		csr1.field.Bss0Key3CipherAlg = CipherAlg;
+	RTUSBWriteMACRegister(pAd, SEC_CSR1, csr1.word);
+
+	//
+	// enable this key entry
+	//
+	RTUSBReadMACRegister(pAd, SEC_CSR0, &csr0);
+	csr0 |= BIT32[BssIndex*4 + KeyIdx]; 	// turrn on the valid bit
+	RTUSBWriteMACRegister(pAd, SEC_CSR0, csr0);
+}
+
+VOID AsicRemoveSharedKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 BssIndex,
+	IN UCHAR		 KeyIdx)
+{
+	ULONG SecCsr0;
+
+	DBGPRINT(RT_DEBUG_TRACE,"AsicRemoveSharedKeyEntry: #%d \n", BssIndex*4 + KeyIdx);
+
+	ASSERT(BssIndex < 4);
+	ASSERT(KeyIdx < SHARE_KEY_NUM);
+
+	RTUSBReadMACRegister(pAd, SEC_CSR0, &SecCsr0);
+	SecCsr0 &= (~BIT32[BssIndex*4 + KeyIdx]); // clear the valid bit
+	RTUSBWriteMACRegister(pAd, SEC_CSR0, SecCsr0);
+}
+
+VOID AsicAddPairwiseKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR		 pAddr,
+	IN UCHAR		 KeyIdx,
+	IN UCHAR		 CipherAlg,
+	IN PUCHAR		 pKey,
+	IN PUCHAR		 pTxMic,
+	IN PUCHAR		 pRxMic)
+{
+	ULONG offset, csr2, csr3;
+
+	DBGPRINT(RT_DEBUG_TRACE,"AsicAddPairwiseKeyEntry: Entry#%d Alg=%s mac=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		KeyIdx, CipherName[CipherAlg], pAddr[0], pAddr[1], pAddr[2], pAddr[3], pAddr[4], pAddr[5]);
+	DBGPRINT(RT_DEBUG_TRACE,"  Key	  = %02x:%02x:%02x:%02x:...\n", pKey[0],pKey[1],pKey[2],pKey[3]);
+	DBGPRINT(RT_DEBUG_TRACE,"  TxMIC  = %02x:%02x:%02x:%02x:...\n", pTxMic[0],pTxMic[1],pTxMic[2],pTxMic[3]);
+	DBGPRINT(RT_DEBUG_TRACE,"  pRxMic = %02x:%02x:%02x:%02x:...\n", pRxMic[0],pRxMic[1],pRxMic[2],pRxMic[3]);
+
+	offset = PAIRWISE_KEY_TABLE_BASE + (KeyIdx * HW_KEY_ENTRY_SIZE);
+
+	RTUSBMultiWrite(pAd, (USHORT)(offset), pKey, HW_KEY_ENTRY_SIZE);
+
+	offset = PAIRWISE_TA_TABLE_BASE + (KeyIdx * HW_PAIRWISE_TA_ENTRY_SIZE);
+	RTUSBMultiWrite(pAd, (USHORT)(offset), pAddr, MAC_ADDR_LEN);
+
+	RTUSBMultiWrite(pAd, (USHORT)(offset+MAC_ADDR_LEN), &CipherAlg, 1);
+
+	// enable this entry
+	if (KeyIdx < 32)
+	{
+		RTUSBReadMACRegister(pAd, SEC_CSR2, &csr2);
+		csr2 |= BIT32[KeyIdx];
+		RTUSBWriteMACRegister(pAd, SEC_CSR2, csr2);
+	}
+	else
+	{
+		RTUSBReadMACRegister(pAd, SEC_CSR3, &csr3);
+		csr3 |= BIT32[KeyIdx-32];
+		RTUSBWriteMACRegister(pAd, SEC_CSR3, csr3);
+	}
+}
+
+VOID AsicRemovePairwiseKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 KeyIdx)
+{
+	ULONG csr2, csr3;
+
+	DBGPRINT(RT_DEBUG_INFO,"AsicRemovePairwiseKeyEntry: #%d \n", KeyIdx);
+
+	// invalidate this entry
+	if (KeyIdx < 32)
+	{
+		RTUSBReadMACRegister(pAd, SEC_CSR2, &csr2);
+		csr2 &= (~BIT32[KeyIdx]);
+		RTUSBWriteMACRegister(pAd, SEC_CSR2, csr2);
+	}
+	else
+	{
+		RTUSBReadMACRegister(pAd, SEC_CSR3, &csr3);
+		csr3 &= (~BIT32[KeyIdx-32]);
+		RTUSBWriteMACRegister(pAd, SEC_CSR3, csr3);
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Verify the support rate for different PHY type
+
+	Arguments:
+		pAd 				Pointer to our adapter
+
+	Return Value:
+		None
+
+	========================================================================
+*/
+VOID	RTMPCheckRates(
+	IN		PRTMP_ADAPTER	pAd,
+	IN OUT	UCHAR			SupRate[],
+	IN OUT	UCHAR			*SupRateLen)
+{
+	UCHAR	RateIdx, i, j;
+	UCHAR	NewRate[12], NewRateLen;
+
+	NewRateLen = 0;
+
+	if (pAd->PortCfg.PhyMode == PHY_11B)
+		RateIdx = 4;
+//	else if ((pAd->PortCfg.PhyMode == PHY_11BG_MIXED) &&
+//		(pAd->PortCfg.BssType == BSS_ADHOC) 		  &&
+//		(pAd->PortCfg.AdhocMode == 0))
+//		RateIdx = 4;
+	else
+		RateIdx = 12;
+
+	// Check for support rates exclude basic rate bit
+	for (i = 0; i < *SupRateLen; i++)
+		for (j = 0; j < RateIdx; j++)
+			if ((SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
+				NewRate[NewRateLen++] = SupRate[i];
+
+	*SupRateLen = NewRateLen;
+	memcpy(SupRate, NewRate, NewRateLen);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Set Rx antenna for software diversity
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		Pair1				0: for E1;	1:for E2
+		Pair2				0: for E4;	1:for E3
+
+	Return Value:
+		None
+
+	========================================================================
+*/
+VOID AsicSetRxAnt(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Pair1,
+	IN UCHAR			Pair2)
+{
+	DBGPRINT(RT_DEBUG_INFO, "AsicSetRxAnt, pair1=%d, pair2=%d\n", Pair1, Pair2);
+
+	if (pAd->RfIcType == RFIC_2528)
+	{
+		UCHAR		R77;
+
+		// Update antenna registers
+		RTUSBReadBBPRegister(pAd, BBP_R77, &R77);
+
+		R77	&= ~0x03;		// clear Bit 0,1
+		if (Pair1 == 0)
+		{
+			R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+		}
+		else
+		{
+			//R77;				// <Bit1:Bit0> = <0:0>
+		}
+
+		// Disable Rx
+		RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+		RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+
+		RT73WriteTXRXCSR0(pAd, FALSE, TRUE); // Staion not drop control frame will fail WiFi Certification.
+	}
+	else if (pAd->RfIcType == RFIC_5226)
+	{
+		UCHAR		R77;
+
+		// Update antenna registers
+		RTUSBReadBBPRegister(pAd, BBP_R77, &R77);
+
+		R77	&= ~0x03;		// clear Bit 0,1
+
+		//Support 11B/G/A
+		if (pAd->PortCfg.BandState == BG_BAND)
+		{
+			//Check Rx Anttena
+			if (Pair1 == 0)
+			{
+				R77 = R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+			}
+			else
+			{
+				//R77;				// <Bit1:Bit0> = <0:0>
+			}
+		}
+		else //A_BAND
+		{
+			//Check Rx Anttena
+			if (Pair1 == 0)
+			{
+				//R77;				// <Bit1:Bit0> = <0:0>
+			}
+			else
+			{
+				R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+			}
+		}
+
+		// Disable Rx
+		RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+		RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+
+		// enable RX of MAC block
+		RT73WriteTXRXCSR0(pAd, FALSE, TRUE);	// Staion not drop control frame will fail WiFi Certification.
+	}
+	else if (pAd->RfIcType == RFIC_5225)
+	{
+		UCHAR		R77;
+
+		// Update antenna registers
+		RTUSBReadBBPRegister(pAd, BBP_R77, &R77);
+
+		R77	&= ~0x03;		// clear Bit 0,1
+
+		//Support 11B/G/A
+		if (pAd->PortCfg.BandState == BG_BAND)
+		{
+			//Check Rx Anttena
+			if (Pair1 == 0)
+			{
+				R77 = R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+			}
+			else
+			{
+				//R77;				// <Bit1:Bit0> = <0:0>
+			}
+		}
+		else //A_BAND
+		{
+			//Check Rx Anttena
+			if (Pair1 == 0)
+			{
+				//R77;				// <Bit1:Bit0> = <0:0>
+			}
+			else
+			{
+				R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+			}
+		}
+
+		// Disable Rx
+		RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+		RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+
+		// enable RX of MAC block
+		RT73WriteTXRXCSR0(pAd, FALSE, TRUE);	// Staion not drop control frame will fail WiFi Certification.
+
+	}
+	else if (pAd->RfIcType == RFIC_2527)
+	{
+		UCHAR		R77;
+
+		// Update antenna registers
+		RTUSBReadBBPRegister(pAd, BBP_R77, &R77);
+
+		R77	&= ~0x03;		// clear Bit 0,1
+		if (Pair1 == 0)
+		{
+			R77	= R77 | 0x03;	// <Bit1:Bit0> = <1:1>
+		}
+		else
+		{
+			//R77;				// <Bit1:Bit0> = <0:0>
+		}
+
+		// Disable Rx
+		RT73WriteTXRXCSR0(pAd, TRUE, FALSE);
+		RTUSBWriteBBPRegister(pAd, BBP_R77, R77);
+
+		// enable RX of MAC block
+		RT73WriteTXRXCSR0(pAd, FALSE, TRUE); // Staion not drop control frame will fail WiFi Certification.
+
+	}
+}
+
+// switch to secondary RxAnt pair for a while to collect it's average RSSI
+// also set a timeout routine to do the actual evaluation. If evaluation
+// result shows a much better RSSI using secondary RxAnt, then a official
+// RX antenna switch is performed.
+VOID AsicEvaluateSecondaryRxAnt(
+	IN PRTMP_ADAPTER pAd)
+{
+	DBGPRINT(RT_DEBUG_TRACE,"AntDiv - before evaluate Pair1-Ant (%d,%d), Pair2-Ant (%d,%d)\n",
+		pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair1SecondaryRxAnt,pAd->RxAnt.Pair2PrimaryRxAnt, pAd->RxAnt.Pair2SecondaryRxAnt);
+
+	AsicSetRxAnt(pAd, pAd->RxAnt.Pair1SecondaryRxAnt, 0xFF);
+
+	pAd->RxAnt.EvaluatePeriod = 1; //1:Means switch to SecondaryRxAnt, 0:Means switch to Pair1PrimaryRxAnt
+	pAd->RxAnt.FirstPktArrivedWhenEvaluate = FALSE;
+	pAd->RxAnt.RcvPktNumWhenEvaluate = 0;
+
+	// a one-shot timer to end the evalution
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		RTMPSetTimer(pAd, &pAd->RxAnt.RxAntDiversityTimer, 100);
+	else
+		RTMPSetTimer(pAd, &pAd->RxAnt.RxAntDiversityTimer, 300);
+
+}
+
+// this timeout routine collect AvgRssi[SecondaryRxAnt] and decide the best Ant
+VOID AsicRxAntEvalTimeout(
+	IN	unsigned long data)
+
+{
+	RTMP_ADAPTER	*pAd = (RTMP_ADAPTER *)data;
+
+	RTUSBEnqueueInternalCmd(pAd, RT_PERFORM_SOFT_DIVERSITY);
+}
+
+VOID AsicRxAntEvalAction(
+	IN PRTMP_ADAPTER pAd)
+{
+	UCHAR			temp;
+
+	DBGPRINT(RT_DEBUG_TRACE,"After Eval,RSSI[0,1,2,3]=<%d,%d,%d,%d>,RcvPktNumWhenEvaluate=%d\n",
+		(pAd->RxAnt.Pair1AvgRssi[0] >> 3), (pAd->RxAnt.Pair1AvgRssi[1] >> 3),
+		(pAd->RxAnt.Pair2AvgRssi[0] >> 3), (pAd->RxAnt.Pair2AvgRssi[1] >> 3), pAd->RxAnt.RcvPktNumWhenEvaluate);
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	if ((pAd->RxAnt.RcvPktNumWhenEvaluate != 0) && (pAd->RxAnt.Pair1AvgRssi[pAd->RxAnt.Pair1SecondaryRxAnt] >= pAd->RxAnt.Pair1AvgRssi[pAd->RxAnt.Pair1PrimaryRxAnt]))
+	{
+		//
+		// select PrimaryRxAntPair
+		//	  Role change, Used Pair1SecondaryRxAnt as PrimaryRxAntPair.
+		//	  Since Pair1SecondaryRxAnt Quality good than Pair1PrimaryRxAnt
+		//
+		temp = pAd->RxAnt.Pair1PrimaryRxAnt;
+		pAd->RxAnt.Pair1PrimaryRxAnt = pAd->RxAnt.Pair1SecondaryRxAnt;
+		pAd->RxAnt.Pair1SecondaryRxAnt = temp;
+
+		pAd->RxAnt.Pair1LastAvgRssi = (pAd->RxAnt.Pair1AvgRssi[pAd->RxAnt.Pair1SecondaryRxAnt] >> 3);
+	}
+	else
+	{
+		AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt, 0xFF);
+	}
+
+	pAd->RxAnt.EvaluatePeriod = 0; //1:Means switch to SecondaryRxAnt, 0:Means switch to Pair1PrimaryRxAnt
+
+	DBGPRINT(RT_DEBUG_TRACE,"After Eval-Pair1 #%d,Pair2 #%d\n",pAd->RxAnt.Pair1PrimaryRxAnt,pAd->RxAnt.Pair2PrimaryRxAnt);
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Station side, Auto TxRate faster train up timer call back function.
+	Return Value:
+		None
+	========================================================================
+*/
+VOID StaQuickResponeForRateUpExec(
+	IN	unsigned long data)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)data;
+	UCHAR	UpRate, DownRate, CurrRate;
+	ULONG	TxTotalCnt, TxErrorRatio = 0;
+
+	do
+	{
+		//
+		// Only link up will to do the TxRate faster trains up.
+		//
+		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			break;
+
+		TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
+					 pAd->RalinkCounters.OneSecTxRetryOkCount +
+					 pAd->RalinkCounters.OneSecTxFailCount;
+
+		// skip this time that has no traffic in the past period
+		if (TxTotalCnt == 0)
+		{
+			break;
+		}
+
+		// decide the next upgrade rate and downgrade rate, if any
+		CurrRate = pAd->PortCfg.TxRate;
+		if ((pAd->PortCfg.Channel > 14) ||		// must be in 802.11A band
+			(pAd->PortCfg.PhyMode == PHY_11G))	// G-only mode, no CCK rates available
+		{
+			if (Phy11ANextRateUpward[CurrRate] <= pAd->PortCfg.MaxTxRate)
+				UpRate = Phy11ANextRateUpward[CurrRate];
+			else
+				UpRate = CurrRate;
+			DownRate = Phy11ANextRateDownward[CurrRate];
+		}
+		else
+		{
+			if (pAd->PortCfg.MaxTxRate < RATE_FIRST_OFDM_RATE)
+			{
+				if (Phy11BNextRateUpward[CurrRate] <= pAd->PortCfg.MaxTxRate)
+					UpRate = Phy11BNextRateUpward[CurrRate];
+				else
+					UpRate = CurrRate;
+				DownRate = Phy11BNextRateDownward[CurrRate];
+			}
+			else
+			{
+				if (Phy11BGNextRateUpward[CurrRate] <= pAd->PortCfg.MaxTxRate)
+					UpRate = Phy11BGNextRateUpward[CurrRate];
+				else
+					UpRate = CurrRate;
+				DownRate = Phy11BGNextRateDownward[CurrRate];
+			}
+		}
+
+		//
+		// PART 1. Decide TX Quality
+		//	 decide TX quality based on Tx PER when enough samples are available
+		//
+		if (TxTotalCnt > 15)
+		{
+			TxErrorRatio = ((pAd->RalinkCounters.OneSecTxRetryOkCount + pAd->RalinkCounters.OneSecTxFailCount) * 100) / TxTotalCnt;
+			// downgrade TX quality if PER >= Rate-Down threshold
+			if (TxErrorRatio >= RateDownPER[CurrRate])
+			{
+				pAd->DrsCounters.TxQuality[CurrRate] = DRS_TX_QUALITY_WORST_BOUND;
+			}
+		}
+
+		pAd->DrsCounters.PER[CurrRate] = (UCHAR)TxErrorRatio;
+
+		//
+		// PART 2. Perform TX rate switching
+		//	 perform rate switching
+		//
+		if ((pAd->DrsCounters.TxQuality[CurrRate] >= DRS_TX_QUALITY_WORST_BOUND) && (CurrRate != DownRate))
+		{
+			pAd->PortCfg.TxRate = DownRate;
+		}
+		// PART 3. Post-processing if TX rate switching did happen
+		//	   if rate-up happen, clear all bad history of all TX rates
+		//	   if rate-down happen, only clear DownRate's bad history
+
+		if (pAd->PortCfg.TxRate < CurrRate)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"StaQuickResponeForRateUpExec: Before TX rate = %d Mbps, Now Tx rate = %d Mbps\n", RateIdToMbps[CurrRate], RateIdToMbps[pAd->PortCfg.TxRate]);
+
+			// shorter stable time require more penalty in next rate UP criteria
+			//if (pAd->DrsCounters.CurrTxRateStableTime < 4)	  // less then 4 sec
+			//	  pAd->DrsCounters.TxRateUpPenalty = DRS_PENALTY; // add 8 sec penalty
+			//else if (pAd->DrsCounters.CurrTxRateStableTime < 8) // less then 8 sec
+			//	  pAd->DrsCounters.TxRateUpPenalty = 2; 		  // add 2 sec penalty
+			//else
+				pAd->DrsCounters.TxRateUpPenalty = 0;			// no penalty
+
+			pAd->DrsCounters.CurrTxRateStableTime = 0;
+			pAd->DrsCounters.LastSecTxRateChangeAction = 2; // rate down
+			pAd->DrsCounters.TxQuality[pAd->PortCfg.TxRate] = 0;
+			pAd->DrsCounters.PER[pAd->PortCfg.TxRate] = 0;
+		}
+		else
+			pAd->DrsCounters.LastSecTxRateChangeAction = 0; // rate no change
+
+		// reset all OneSecxxx counters
+		pAd->RalinkCounters.OneSecTxFailCount = 0;
+		pAd->RalinkCounters.OneSecTxNoRetryOkCount = 0;
+		pAd->RalinkCounters.OneSecTxRetryOkCount = 0;
+	} while (FALSE);
+	pAd->PortCfg.QuickResponeForRateUpTimerRunning = FALSE;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Get an unused nonpaged system-space memory for use
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		AllocVa 			Pointer to the base virtual address for later use
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_RESOURCES
+
+	Note:
+
+	========================================================================
+*/
+
+NDIS_STATUS MlmeAllocateMemory(
+	IN PRTMP_ADAPTER pAd,
+	OUT PVOID		 *AllocVa)
+{
+	PMLME_MEMORY_STRUCT 			pMlmeMemoryStruct = NULL;
+
+	DBGPRINT(RT_DEBUG_INFO,"==> MlmeAllocateMemory\n");
+
+
+	if (pAd->Mlme.MemHandler.pUnUseHead == NULL)
+	{ //There are no available memory for caller use
+		DBGPRINT(RT_DEBUG_ERROR,"MlmeAllocateMemory, failed!! (There are no available memory in list)\n");
+		DBGPRINT(RT_DEBUG_ERROR,"<== MlmeAllocateMemory\n");
+		return (NDIS_STATUS_RESOURCES);
+	}
+	pMlmeMemoryStruct = pAd->Mlme.MemHandler.pUnUseHead;
+	//Unused memory point to next available
+	pAd->Mlme.MemHandler.pUnUseHead = pAd->Mlme.MemHandler.pUnUseHead->Next;
+	if (pAd->Mlme.MemHandler.pUnUseHead == NULL)
+		pAd->Mlme.MemHandler.pUnUseTail = NULL;
+	pAd->Mlme.MemHandler.UnUseCount--;
+
+	*AllocVa = pMlmeMemoryStruct->AllocVa;			//Saved porint to Pointer the base virtual address of the nonpaged memory for caller use.
+
+	pMlmeMemoryStruct->Next = NULL;
+	//Append the unused memory link list to the in-used link list tail
+	if (pAd->Mlme.MemHandler.pInUseHead == NULL)
+	{//no head, so current Item assign to In-use Head.
+		pAd->Mlme.MemHandler.pInUseHead = pMlmeMemoryStruct;
+		pAd->Mlme.MemHandler.pInUseTail = pMlmeMemoryStruct;
+	}
+	else
+	{
+		pAd->Mlme.MemHandler.pInUseTail->Next = pMlmeMemoryStruct;
+		pAd->Mlme.MemHandler.pInUseTail = pAd->Mlme.MemHandler.pInUseTail->Next;
+	}
+	pAd->Mlme.MemHandler.InUseCount++;
+
+
+
+	DBGPRINT(RT_DEBUG_INFO, "MlmeAllocateMemory [pMlmeMemoryStruct=%p][VA=%p]\n", pMlmeMemoryStruct, pMlmeMemoryStruct->AllocVa);
+	DBGPRINT(RT_DEBUG_INFO, "<== MlmeAllocateMemory[IN:%d][UN:%d]\n",
+				pAd->Mlme.MemHandler.InUseCount, pAd->Mlme.MemHandler.UnUseCount);
+	return (NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Mlme free the in-used nonpaged memory,
+		move it to the unused memory link list
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		AllocVa 			Pointer to the base virtual address for free
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	MlmeFreeMemory(
+	IN PRTMP_ADAPTER pAd,
+	IN PVOID		 AllocVa)
+{
+	PMLME_MEMORY_STRUCT 			pPrevious;
+	PMLME_MEMORY_STRUCT 			pMlmeMemoryStruct;
+	BOOLEAN 						bIsFound;
+
+	if (AllocVa == NULL)
+		return;
+
+	bIsFound = FALSE;
+	pPrevious = NULL;
+	pMlmeMemoryStruct = pAd->Mlme.MemHandler.pInUseHead;
+	while (pMlmeMemoryStruct)
+	{
+//		DBGPRINT(RT_DEBUG_TRACE,"pMlmeMemoryStruct->AllocVa=%x\n",(int)pMlmeMemoryStruct->AllocVa);
+		if (pMlmeMemoryStruct->AllocVa == AllocVa)
+		{
+			//Found virtual address in the in-used link list
+			//Remove it from the memory in-used link list, and move it to the unused link list
+			if (pPrevious == NULL)
+				pAd->Mlme.MemHandler.pInUseHead = pMlmeMemoryStruct->Next;
+			else
+				pPrevious->Next = pMlmeMemoryStruct->Next;
+			pAd->Mlme.MemHandler.InUseCount--;
+
+			//append it to the tail of unused list
+			pMlmeMemoryStruct->Next = NULL;
+			if ((pAd->Mlme.MemHandler.pUnUseHead == NULL))
+			{ //No head, add it as head
+				pAd->Mlme.MemHandler.pUnUseHead = pMlmeMemoryStruct;
+				pAd->Mlme.MemHandler.pUnUseTail = pMlmeMemoryStruct;
+			}
+			else
+			{
+				//Append it to the tail in pAd->Mlme.MemHandler.pUnUseTail
+				pAd->Mlme.MemHandler.pUnUseTail->Next = pMlmeMemoryStruct;
+				pAd->Mlme.MemHandler.pUnUseTail = pAd->Mlme.MemHandler.pUnUseTail->Next;
+			}
+			pAd->Mlme.MemHandler.UnUseCount++;
+
+			bIsFound = TRUE;
+			break;
+		}
+		else
+		{
+			pPrevious = pMlmeMemoryStruct;
+			pMlmeMemoryStruct = pMlmeMemoryStruct->Next;
+		}
+	}
+ }
+
+/*
+	========================================================================
+
+	Routine Description:
+		Allocates resident (nonpaged) system-space memory for MLME send frames
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		Number				Total nonpaged memory for use
+		Size				Each nonpaged memory size
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_RESOURCES
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS MlmeInitMemoryHandler(
+	IN PRTMP_ADAPTER pAd,
+	IN UINT  Number,
+	IN UINT  Size)
+{
+	PMLME_MEMORY_STRUCT 		Current = NULL;
+	NDIS_STATUS 				Status = NDIS_STATUS_SUCCESS;
+	UINT						i;
+
+	DBGPRINT(RT_DEBUG_INFO,"==> MlmeInitMemory\n");
+	pAd->Mlme.MemHandler.MemoryCount = 0;
+	pAd->Mlme.MemHandler.pInUseHead = NULL;
+	pAd->Mlme.MemHandler.pInUseTail = NULL;
+	pAd->Mlme.MemHandler.pUnUseHead = NULL;
+	pAd->Mlme.MemHandler.pUnUseTail = NULL;
+	pAd->Mlme.MemHandler.MemRunning = FALSE;
+
+	//initial the memory free-pending array all to NULL;
+	for (i = 0; i < MAX_MLME_HANDLER_MEMORY; i++)
+		pAd->Mlme.MemHandler.MemFreePending[i] = NULL;
+
+	//
+	// Available nonpaged memory counts MAX_MLME_HANDLER_MEMORY
+	//
+	if (Number > MAX_MLME_HANDLER_MEMORY)
+		Number = MAX_MLME_HANDLER_MEMORY;
+
+	for (i = 0; i < Number; i++)
+	{
+		//Allocate a nonpaged memory for link list use.
+		Current= (PMLME_MEMORY_STRUCT) kmalloc(sizeof(MLME_MEMORY_STRUCT), MEM_ALLOC_FLAG);
+		if (!Current)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			break;
+		}
+
+		Current->AllocVa= (VOID *) kmalloc(Size, MEM_ALLOC_FLAG);
+		if (!Current->AllocVa)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "Not enough memory\n");
+			if( Current != NULL){
+				kfree((VOID *)Current);
+			}
+			Status = NDIS_STATUS_RESOURCES;
+			break;
+		}
+
+		memset(Current->AllocVa, 0, Size);
+
+		pAd->Mlme.MemHandler.MemoryCount++;
+
+		//build up the link list
+		if (pAd->Mlme.MemHandler.pUnUseHead != NULL)
+		{
+			Current->Next = pAd->Mlme.MemHandler.pUnUseHead;
+			pAd->Mlme.MemHandler.pUnUseHead = Current;
+		}
+		else
+		{
+			Current->Next = NULL;
+			pAd->Mlme.MemHandler.pUnUseHead = Current;
+		}
+
+		if (pAd->Mlme.MemHandler.pUnUseTail == NULL)
+			pAd->Mlme.MemHandler.pUnUseTail = Current;
+
+	}
+
+	if (pAd->Mlme.MemHandler.MemoryCount < Number)
+	{
+		Status = NDIS_STATUS_RESOURCES;
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeInitMemory Initial failed [Require=%d, available=%d]\n", Number, pAd->Mlme.MemHandler.MemoryCount);
+	}
+
+	pAd->Mlme.MemHandler.InUseCount = 0;
+	pAd->Mlme.MemHandler.UnUseCount = Number;
+	pAd->Mlme.MemHandler.PendingCount = 0;
+	DBGPRINT(RT_DEBUG_INFO, "<== MlmeInitMemory\n");
+
+	return (Status);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Free Mlme memory handler (link list, nonpaged memory, spin lock)
+
+	Arguments:
+		pAd 				Pointer to our adapter
+
+	Return Value:
+		None
+	========================================================================
+*/
+VOID MlmeFreeMemoryHandler(
+	IN PRTMP_ADAPTER pAd)
+{
+	PMLME_MEMORY_STRUCT 	 pMlmeMemoryStruct = NULL;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeFreeMemoryHandler\n");
+
+	//Free nonpaged memory, free it in the *In-used* link list.
+	while (pAd->Mlme.MemHandler.pInUseHead != NULL)
+	{
+		pMlmeMemoryStruct = pAd->Mlme.MemHandler.pInUseHead;
+		pAd->Mlme.MemHandler.pInUseHead = pAd->Mlme.MemHandler.pInUseHead->Next;
+		//Free the virtual address in AllocVa which size is MAX_LEN_OF_MLME_BUFFER
+		if(pMlmeMemoryStruct->AllocVa != NULL){
+			kfree(pMlmeMemoryStruct->AllocVa);
+		}
+		//Free the link list item self
+		if(pMlmeMemoryStruct != NULL){
+			kfree(pMlmeMemoryStruct);
+		}
+	}
+
+	//Free nonpaged memory, free it in the *Unused* link list.
+	while (pAd->Mlme.MemHandler.pUnUseHead != NULL)
+	{
+		pMlmeMemoryStruct = pAd->Mlme.MemHandler.pUnUseHead;
+		pAd->Mlme.MemHandler.pUnUseHead = pAd->Mlme.MemHandler.pUnUseHead->Next;
+		//Free the virtual address in AllocVa which size is MAX_LEN_OF_MLME_BUFFER
+		if(pMlmeMemoryStruct->AllocVa != NULL){
+			kfree(pMlmeMemoryStruct->AllocVa);
+		}
+
+		//Free the link list item self
+		if(pMlmeMemoryStruct != NULL){
+			kfree(pMlmeMemoryStruct);
+		}
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---MlmeFreeMemoryHandler\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Radar detection routine
+
+	Arguments:
+		pAd     Pointer to our adapter
+
+	Return Value:
+
+	========================================================================
+*/
+VOID RadarDetectionStart(
+	IN PRTMP_ADAPTER	pAd)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "RadarDetectionStart--->\n");
+
+	RT73WriteTXRXCSR0(pAd, TRUE, FALSE);        // Disable Rx
+
+	// Set all relative BBP register to enter into radar detection mode
+	RTUSBWriteBBPRegister(pAd, BBP_R82, 0x20);
+	RTUSBWriteBBPRegister(pAd, BBP_R83, 0);
+	RTUSBWriteBBPRegister(pAd, BBP_R84, 0x40);
+
+	RTUSBReadBBPRegister(pAd, BBP_R18, &pAd->PortCfg.RadarDetect.BBPR18);
+	RTUSBWriteBBPRegister(pAd, BBP_R18, 0xFF);
+
+	RTUSBReadBBPRegister(pAd, BBP_R21, &pAd->PortCfg.RadarDetect.BBPR21);
+	RTUSBWriteBBPRegister(pAd, BBP_R21, 0x3F);
+	RTUSBReadBBPRegister(pAd, BBP_R22, &pAd->PortCfg.RadarDetect.BBPR22);
+	RTUSBWriteBBPRegister(pAd, BBP_R22, 0x3F);
+
+	RTUSBReadBBPRegister(pAd, BBP_R16, &pAd->PortCfg.RadarDetect.BBPR16);
+	RTUSBWriteBBPRegister(pAd, BBP_R16, 0xBD);
+	RTUSBReadBBPRegister(pAd, BBP_R17, &pAd->PortCfg.RadarDetect.BBPR17);
+	if (pAd->NicConfig2.field.ExternalLNA)
+	{
+		RTUSBWriteBBPRegister(pAd, 17, 0x44); // if external LNA enable, this value need to be offset 0x10
+	}
+	else
+	{
+		RTUSBWriteBBPRegister(pAd, 17, 0x34);
+	}
+
+	RTUSBReadBBPRegister(pAd, BBP_R64, &pAd->PortCfg.RadarDetect.BBPR64);
+	RTUSBWriteBBPRegister(pAd, BBP_R64, 0x21);
+
+	RT73WriteTXRXCSR0(pAd, FALSE, FALSE);       // enable RX of MAC block
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Radar detection routine
+
+	Arguments:
+		pAd     Pointer to our adapter
+
+	Return Value:
+		TRUE    Found radar signal
+		FALSE   Not found radar signal
+
+	========================================================================
+*/
+BOOLEAN RadarDetectionStop(
+	IN PRTMP_ADAPTER	pAd)
+{
+	UCHAR	R66;
+
+	// Need to read the result of detection first
+	// If restore all registers first, then the result will be reset.
+	RTUSBReadBBPRegister(pAd, BBP_R66, &R66);
+
+	// Restore all relative BBP register to exit radar detection mode
+	RTUSBWriteBBPRegister(pAd, BBP_R16, pAd->PortCfg.RadarDetect.BBPR16);
+	RTUSBWriteBBPRegister(pAd, BBP_R17, pAd->PortCfg.RadarDetect.BBPR17);
+	RTUSBWriteBBPRegister(pAd, BBP_R18, pAd->PortCfg.RadarDetect.BBPR18);
+	RTUSBWriteBBPRegister(pAd, BBP_R21, pAd->PortCfg.RadarDetect.BBPR21);
+	RTUSBWriteBBPRegister(pAd, BBP_R22, pAd->PortCfg.RadarDetect.BBPR22);
+	RTUSBWriteBBPRegister(pAd, BBP_R64, pAd->PortCfg.RadarDetect.BBPR64);
+
+	if (R66 == 1)
+		return TRUE;
+	else
+		return FALSE;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Radar channel check routine
+
+	Arguments:
+		pAd     Pointer to our adapter
+
+	Return Value:
+		TRUE    need to do radar detect
+		FALSE   need not to do radar detect
+
+	========================================================================
+*/
+BOOLEAN RadarChannelCheck(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Ch)
+{
+	INT		i;
+	UCHAR	Channel[15]={52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140};
+
+	for (i=0; i<15; i++)
+	{
+		if (Ch == Channel[i])
+		{
+			break;
+		}
+	}
+
+	if (i != 15)
+		return TRUE;
+	else
+		return FALSE;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/mlme.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/mlme.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/mlme.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/mlme.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,454 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	mlme.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	John Chang	2003-08-28	Created
+ *	John Chang	2004-09-06	modified for RT2600
+ *
+ ***************************************************************************/
+
+#ifndef __MLME_H__
+#define __MLME_H__
+
+#include "oid.h"
+
+// maximum supported capability information -
+// ESS, IBSS, Privacy, Short Preamble, Spectrum mgmt, Short Slot
+#define SUPPORTED_CAPABILITY_INFO   0x0533
+
+#define END_OF_ARGS                 -1
+#define LFSR_MASK                   0x80000057
+#define MLME_TASK_EXEC_INTV         1000         // 1 sec
+//#define TBTT_PRELOAD_TIME         384          // usec. LomgPreamble + 24-byte at 1Mbps
+
+#define BEACON_LOST_TIME            (4*HZ)      // 2048 msec = 2 sec
+
+#define AUTH_TIMEOUT                300         // unit: msec
+#define ASSOC_TIMEOUT               300         // unit: msec
+#define JOIN_TIMEOUT                2000        // unit: msec
+#define MIN_CHANNEL_TIME            110         // unit: msec, for dual band scan
+#define MAX_CHANNEL_TIME            140         // unit: msec, for single band scan
+//#define	ACTIVE_SCAN_TIME		    30			// Active scan waiting for probe response time
+#define	FAST_ACTIVE_SCAN_TIME	    30 		    // Active scan waiting for probe response time
+#define CW_MIN_IN_BITS              4         // actual CwMin = 2^CW_MIN_IN_BITS - 1
+#define CW_MAX_IN_BITS              10        // actual CwMax = 2^CW_MAX_IN_BITS - 1
+
+// Note: RSSI_TO_DBM_OFFSET has been changed to variable for new RF (2004-0720).
+// SHould not refer to this constant anymore
+#define RSSI_TO_DBM_OFFSET          120 // for RT2530 RSSI-115 = dBm
+#define RSSI_FOR_MID_TX_POWER       -55  // -55 db is considered mid-distance
+#define RSSI_FOR_LOW_TX_POWER       -45  // -45 db is considered very short distance and
+                                        // eligible to use a lower TX power
+#define RSSI_FOR_LOWEST_TX_POWER    -30
+//#define MID_TX_POWER_DELTA          0   // 0 db from full TX power upon mid-distance to AP
+#define LOW_TX_POWER_DELTA          6    // -3 db from full TX power upon very short distance. 1 grade is 0.5 db
+#define LOWEST_TX_POWER_DELTA       16   // -8 db from full TX power upon shortest distance. 1 grade is 0.5 db
+
+#define RSSI_TRIGGERED_UPON_BELOW_THRESHOLD     0
+#define RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD   1
+#define RSSI_THRESHOLD_FOR_ROAMING              25
+#define RSSI_DELTA                              5
+
+// Channel Quality Indication
+#define CQI_IS_GOOD(cqi)            ((cqi) >= 50)
+//#define CQI_IS_FAIR(cqi)          (((cqi) >= 20) && ((cqi) < 50))
+#define CQI_IS_POOR(cqi)            (cqi < 50)  //(((cqi) >= 5) && ((cqi) < 20))
+#define CQI_IS_BAD(cqi)             (cqi < 5)
+#define CQI_IS_DEAD(cqi)            (cqi == 0)   //((cqi) < 5)
+
+// weighting factor to calculate Channel quality, total should be 100%
+#define RSSI_WEIGHTING                   50
+#define TX_WEIGHTING                     30
+#define RX_WEIGHTING                     20
+
+#define MAX_LEN_OF_BSS_TABLE             64
+#define BSS_NOT_FOUND                    0xFFFFFFFF
+
+#define SCAN_PASSIVE                     18
+#define SCAN_ACTIVE                      19
+#define FAST_SCAN_ACTIVE                 24		// scan with probe request, and wait beacon and probe response
+#define MAX_LEN_OF_MLME_QUEUE            20
+
+
+// bit definition of the 2-byte pBEACON->Capability field
+#define CAP_IS_ESS_ON(x)                 (((x) & 0x0001) != 0)
+#define CAP_IS_IBSS_ON(x)                (((x) & 0x0002) != 0)
+#define CAP_IS_CF_POLLABLE_ON(x)         (((x) & 0x0004) != 0)
+#define CAP_IS_CF_POLL_REQ_ON(x)         (((x) & 0x0008) != 0)
+#define CAP_IS_PRIVACY_ON(x)             (((x) & 0x0010) != 0)
+#define CAP_IS_SHORT_PREAMBLE_ON(x)      (((x) & 0x0020) != 0)
+#define CAP_IS_PBCC_ON(x)                (((x) & 0x0040) != 0)
+#define CAP_IS_AGILITY_ON(x)             (((x) & 0x0080) != 0)
+#define CAP_IS_SPECTRUM_MGMT(x)          (((x) & 0x0100) != 0)  // 802.11e d9
+#define CAP_IS_QOS(x)                    (((x) & 0x0200) != 0)  // 802.11e d9
+#define CAP_IS_SHORT_SLOT(x)             (((x) & 0x0400) != 0)
+#define CAP_IS_APSD(x)                   (((x) & 0x0800) != 0)  // 802.11e d9
+#define CAP_IS_IMMED_BA(x)               (((x) & 0x1000) != 0)  // 802.11e d9
+#define CAP_IS_DSSS_OFDM(x)              (((x) & 0x2000) != 0)
+#define CAP_IS_DELAY_BA(x)               (((x) & 0x4000) != 0)  // 802.11e d9
+
+#define CAP_GENERATE(ess,ibss,priv,s_pre,s_slot)  (((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((s_pre) ? 0x0020 : 0x0000) | ((s_slot) ? 0x0400 : 0x0000))
+
+#define STA_QOS_CAPABILITY               0 // 1-byte. see 802.11e d9.0 for bit definition
+
+#define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)    // 802.11g
+#define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)    // 802.11g
+#define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)    // 802.11g
+
+#define DRS_TX_QUALITY_WORST_BOUND       3
+#define DRS_PENALTY                      8
+
+
+//
+// 802.11 frame formats
+//
+
+// 2-byte QOS CONTROL field
+typedef struct PACKED {
+#ifdef BIG_ENDIAN
+    USHORT      Txop_QueueSize:8;
+    USHORT      Rsv:1;
+    USHORT      AckPolicy:2;
+    USHORT      EOSP:1;
+    USHORT      TID:4;
+#else
+    USHORT      TID:4;
+    USHORT      EOSP:1;
+    USHORT      AckPolicy:2;
+    USHORT      Rsv:1;
+    USHORT      Txop_QueueSize:8;
+#endif
+} QOS_CONTROL, *PQOS_CONTROL;
+
+// 2-byte Frame control field
+typedef	struct	PACKED {
+#ifdef BIG_ENDIAN
+    USHORT		Order:1;
+    USHORT		Wep:1;
+    USHORT		MoreData:1;
+    USHORT		PwrMgmt:1;
+    USHORT		Retry:1;
+    USHORT		MoreFrag:1;
+    USHORT		FrDs:1;
+    USHORT		ToDs:1;
+    USHORT		SubType:4;
+    USHORT		Type:2;
+    USHORT		Ver:2;
+#else
+	USHORT		Ver:2;				// Protocol version
+	USHORT		Type:2;				// MSDU type
+	USHORT		SubType:4;			// MSDU subtype
+	USHORT		ToDs:1;				// To DS indication
+	USHORT		FrDs:1;				// From DS indication
+	USHORT		MoreFrag:1;			// More fragment bit
+	USHORT		Retry:1;			// Retry status bit
+	USHORT		PwrMgmt:1;			// Power management bit
+	USHORT		MoreData:1;			// More data bit
+	USHORT		Wep:1;				// Wep data
+	USHORT		Order:1;			// Strict order expected
+#endif
+}	FRAME_CONTROL, *PFRAME_CONTROL;
+
+typedef	struct	PACKED _HEADER_802_11	{
+    FRAME_CONTROL   FC;
+    USHORT          Duration;
+    UCHAR           Addr1[MAC_ADDR_LEN];
+    UCHAR           Addr2[MAC_ADDR_LEN];
+	UCHAR			Addr3[MAC_ADDR_LEN];
+#ifdef BIG_ENDIAN
+    USHORT    		Sequence:12;
+    USHORT    		Frag:4;
+#else
+	USHORT			Frag:4;
+	USHORT			Sequence:12;
+#endif
+}	HEADER_802_11, *PHEADER_802_11;
+
+typedef struct PACKED _FRAME_802_11 {
+    HEADER_802_11   Hdr;
+    CHAR            Octet[1];
+}   FRAME_802_11, *PFRAME_802_11;
+
+typedef struct _PSPOLL_FRAME {
+    FRAME_CONTROL   FC;
+    USHORT          Aid;
+    UCHAR           Bssid[MAC_ADDR_LEN];
+    UCHAR           Ta[MAC_ADDR_LEN];
+}   PSPOLL_FRAME, *PPSPOLL_FRAME;
+
+typedef	struct	PACKED _RTS_FRAME	{
+    FRAME_CONTROL   FC;
+    USHORT          Duration;
+    UCHAR           Addr1[MAC_ADDR_LEN];
+    UCHAR           Addr2[MAC_ADDR_LEN];
+}	RTS_FRAME, *PRTS_FRAME;
+
+//
+// Contention-free parameter (without ID and Length)
+//
+typedef struct PACKED {
+    BOOLEAN     bValid;         // 1: variable contains valid value
+    UCHAR       CfpCount;
+    UCHAR       CfpPeriod;
+    USHORT      CfpMaxDuration;
+    USHORT      CfpDurRemaining;
+} CF_PARM, *PCF_PARM;
+
+typedef	struct	_CIPHER_SUITE	{
+	NDIS_802_11_ENCRYPTION_STATUS	PairCipher;		// Unicast cipher 1, this one has more secured cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS	PairCipherAux;	// Unicast cipher 2 if AP announce two unicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS	GroupCipher;	// Group cipher
+	USHORT							RsnCapability;	// RSN capability from beacon
+	BOOLEAN							bMixMode;		// Indicate Pair & Group cipher might be different
+}	CIPHER_SUITE, *PCIPHER_SUITE;
+
+// EDCA configuration from AP's BEACON/ProbeRsp
+typedef struct PACKED {
+    BOOLEAN     bValid;         // 1: variable contains valid value
+    BOOLEAN     bQAck;
+    BOOLEAN     bQueueRequest;
+    BOOLEAN     bTxopRequest;
+//  BOOLEAN     bMoreDataAck;
+    UCHAR       EdcaUpdateCount;
+    UCHAR       Aifsn[4];       // 0:AC_BK, 1:AC_BE, 2:AC_VI, 3:AC_VO
+    UCHAR       Cwmin[4];
+    UCHAR       Cwmax[4];
+    USHORT      Txop[4];      // in unit of 32-us
+    BOOLEAN     bACM[4];      // 1: Admission Control of AC_BK is mandattory
+} EDCA_PARM, *PEDCA_PARM;
+
+// QBSS LOAD information from QAP's BEACON/ProbeRsp
+typedef struct PACKED {
+    BOOLEAN     bValid;                     // 1: variable contains valid value
+    USHORT      StaNum;
+    UCHAR       ChannelUtilization;
+    USHORT      RemainingAdmissionControl;  // in unit of 32-us
+} QBSS_LOAD_PARM, *PQBSS_LOAD_PARM;
+
+// QOS Capability reported in QAP's BEACON/ProbeRsp
+// QOS Capability sent out in QSTA's AssociateReq/ReAssociateReq
+typedef struct PACKED {
+    BOOLEAN     bValid;                     // 1: variable contains valid value
+    BOOLEAN     bQAck;
+    BOOLEAN     bQueueRequest;
+    BOOLEAN     bTxopRequest;
+//  BOOLEAN     bMoreDataAck;
+    UCHAR       EdcaUpdateCount;
+} QOS_CAPABILITY_PARM, *PQOS_CAPABILITY_PARM;
+
+typedef struct {
+    UCHAR   Bssid[MAC_ADDR_LEN];
+    UCHAR   Channel;
+    UCHAR   BssType;
+    USHORT  AtimWin;
+    USHORT  BeaconPeriod;
+
+    UCHAR   SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR   SupRateLen;
+    UCHAR   ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR   ExtRateLen;
+    UCHAR   Rssi;
+    UCHAR   Privacy;			// Indicate security function ON/OFF. Don't mess up with auth mode.
+	UCHAR	Hidden;
+
+    USHORT  DtimPeriod;
+    USHORT  CapabilityInfo;
+
+    USHORT  CfpCount;
+    USHORT  CfpPeriod;
+    USHORT  CfpMaxDuration;
+    USHORT  CfpDurRemaining;
+    UCHAR   SsidLen;
+    CHAR    Ssid[MAX_LEN_OF_SSID];
+
+    unsigned long   LastBeaconRxTime; // OS's timestamp
+
+    // New for WPA2
+	CIPHER_SUITE					WPA;			// AP announced WPA cipher suite
+	CIPHER_SUITE					WPA2;			// AP announced WPA2 cipher suite
+
+	// New for microsoft WPA support
+	NDIS_802_11_FIXED_IEs	FixIEs;
+	NDIS_802_11_AUTHENTICATION_MODE	AuthModeAux;	// Addition mode for WPA2 / WPA capable AP
+	NDIS_802_11_AUTHENTICATION_MODE	AuthMode;
+	UCHAR                           AuthBitMode;
+	NDIS_802_11_WEP_STATUS	WepStatus;				// Unicast Encryption Algorithm extract from VAR_IE
+	UCHAR					VarIELen;				// Length of next VIE include EID & Length
+	UCHAR					VarIEs[MAX_VIE_LEN];
+
+	// CCX Ckip information
+    UCHAR   CkipFlag;
+	// CCX 2 TSF
+	//UCHAR	PTSF[4];		// Parent TSF
+	//UCHAR	TTSF[8];		// Target TSF
+
+    // 802.11e d9, and WMM
+	EDCA_PARM           EdcaParm;
+	QOS_CAPABILITY_PARM QosCapability;
+	QBSS_LOAD_PARM      QbssLoad;
+} BSS_ENTRY, *PBSS_ENTRY;
+
+typedef struct {
+    UCHAR           BssNr;
+    UCHAR           BssOverlapNr;
+    BSS_ENTRY       BssEntry[MAX_LEN_OF_BSS_TABLE];
+} BSS_TABLE, *PBSS_TABLE;
+
+typedef struct _MLME_QUEUE_ELEM {
+    ULONG             Machine;
+    ULONG             MsgType;
+    ULONG             MsgLen;
+    LARGE_INTEGER     TimeStamp;
+    UCHAR             Rssi;
+    UCHAR             Signal;
+    UCHAR             Channel;
+    BOOLEAN           Occupied;
+    BOOLEAN           bReqIsFromNdis;
+    UCHAR             Msg[MAX_LEN_OF_MLME_BUFFER];
+} MLME_QUEUE_ELEM, *PMLME_QUEUE_ELEM;
+
+typedef struct _MLME_QUEUE {
+    ULONG             Num;
+    ULONG             Head;
+    ULONG             Tail;
+    spinlock_t        Lock;
+    MLME_QUEUE_ELEM   Entry[MAX_LEN_OF_MLME_QUEUE];
+} MLME_QUEUE, *PMLME_QUEUE;
+
+typedef VOID (*STATE_MACHINE_FUNC)(VOID *Adaptor, MLME_QUEUE_ELEM *Elem);
+
+typedef struct _STATE_MACHINE {
+    ULONG                           Base;
+    ULONG                           NrState;
+    ULONG                           NrMsg;
+    ULONG                           CurrState;
+    STATE_MACHINE_FUNC             *TransFunc;
+} STATE_MACHINE, *PSTATE_MACHINE;
+
+// MLME AUX data structure that hold temporarliy settings during a connection attempt.
+// Once this attemp succeeds, all settings will be copy to pAd->ActiveCfg.
+// A connection attempt (user set OID, roaming, CCX fast roaming,..) consists of
+// several steps (JOIN, AUTH, ASSOC or REASSOC) and may fail at any step. We purposely
+// separate this under-trial settings away from pAd->ActiveCfg so that once
+// this new attempt failed, driver can auto-recover back to the active settings.
+typedef struct _MLME_AUX {
+    UCHAR               BssType;
+    UCHAR               Ssid[MAX_LEN_OF_SSID];
+    UCHAR               SsidLen;
+    UCHAR               Bssid[MAC_ADDR_LEN];
+	UCHAR				AutoReconnectSsid[MAX_LEN_OF_SSID];
+	UCHAR				AutoReconnectSsidLen;
+    USHORT              Alg;
+    UCHAR               ScanType;
+    UCHAR               Channel;
+    USHORT              Aid;
+    USHORT              CapabilityInfo;
+    USHORT              BeaconPeriod;
+    USHORT              CfpMaxDuration;
+    USHORT              CfpPeriod;
+    USHORT              AtimWin;
+
+	// Copy supported rate from desired AP's beacon. We are trying to match
+	// AP's supported and extended rate settings.
+	UCHAR		        SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		        ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		        SupRateLen;
+	UCHAR		        ExtRateLen;
+
+    // new for QOS
+    QOS_CAPABILITY_PARM APQosCapability;    // QOS capability of the current associated AP
+    EDCA_PARM           APEdcaParm;         // EDCA parameters of the current associated AP
+    QBSS_LOAD_PARM      APQbssLoad;         // QBSS load of the current associated AP
+
+    // new to keep Ralink specific feature
+    ULONG               APRalinkIe;
+
+    BSS_TABLE           SsidBssTab;     // AP list for the same SSID
+    BSS_TABLE           RoamTab;        // AP list eligible for roaming
+    ULONG               BssIdx;
+    ULONG               RoamIdx;
+
+	BOOLEAN				CurrReqIsFromNdis;  // TRUE - then we should call NdisMSetInformationComplete()
+                                            // FALSE - req is from driver itself.
+                                            // no NdisMSetInformationComplete() is required
+
+	RALINK_TIMER_STRUCT BeaconTimer, ScanTimer;
+	RALINK_TIMER_STRUCT AuthTimer;
+	RALINK_TIMER_STRUCT AssocTimer, ReassocTimer, DisassocTimer;
+} MLME_AUX, *PMLME_AUX;
+
+// assoc struct is equal to reassoc
+typedef struct _MLME_ASSOC_REQ_STRUCT{
+    UCHAR     Addr[MAC_ADDR_LEN];
+    USHORT    CapabilityInfo;
+    USHORT    ListenIntv;
+    ULONG     Timeout;
+} MLME_ASSOC_REQ_STRUCT, *PMLME_ASSOC_REQ_STRUCT, MLME_REASSOC_REQ_STRUCT, *PMLME_REASSOC_REQ_STRUCT;
+
+typedef struct _MLME_DISASSOC_REQ_STRUCT{
+    UCHAR     Addr[MAC_ADDR_LEN];
+    USHORT    Reason;
+} MLME_DISASSOC_REQ_STRUCT, *PMLME_DISASSOC_REQ_STRUCT;
+
+typedef struct _MLME_AUTH_REQ_STRUCT {
+    UCHAR        Addr[MAC_ADDR_LEN];
+    USHORT       Alg;
+    ULONG        Timeout;
+} MLME_AUTH_REQ_STRUCT, *PMLME_AUTH_REQ_STRUCT;
+
+typedef struct _MLME_DEAUTH_REQ_STRUCT {
+    UCHAR        Addr[MAC_ADDR_LEN];
+    USHORT       Reason;
+} MLME_DEAUTH_REQ_STRUCT, *PMLME_DEAUTH_REQ_STRUCT;
+
+typedef struct {
+    ULONG      BssIdx;
+} MLME_JOIN_REQ_STRUCT;
+
+typedef struct _MLME_SCAN_REQ_STRUCT {
+    UCHAR      Bssid[MAC_ADDR_LEN];
+    UCHAR      BssType;
+    UCHAR      ScanType;
+    UCHAR      SsidLen;
+    CHAR       Ssid[MAX_LEN_OF_SSID];
+} MLME_SCAN_REQ_STRUCT, *PMLME_SCAN_REQ_STRUCT;
+
+typedef struct _MLME_START_REQ_STRUCT {
+    CHAR        Ssid[MAX_LEN_OF_SSID];
+    UCHAR       SsidLen;
+} MLME_START_REQ_STRUCT, *PMLME_START_REQ_STRUCT;
+
+typedef struct {
+    UCHAR   Eid;
+    UCHAR   Len;
+    CHAR   Octet[1];
+} EID_STRUCT,*PEID_STRUCT;
+
+#endif  // __MLME_H__
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/oid.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/oid.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/oid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/oid.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,748 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	mlme.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	idamlaj		05-10-2006	Import rfmon implementation
+ *	idamlaj		14-10-2006	Mac Address Changing
+ *	idamlaj		14-10-2006	RFMONTx (based on MarkW's code)
+ *	RomainB     31-12-2006  RFMONTx getter, update of some ioctl values
+ *
+ ***************************************************************************/
+
+#ifndef _OID_H_
+#define _OID_H_
+
+#include <linux/wireless.h>
+
+// Ralink defined OIDs
+#if WIRELESS_EXT <= 11
+#ifndef SIOCDEVPRIVATE
+#define SIOCDEVPRIVATE                              0x8BE0
+#endif
+#define SIOCIWFIRSTPRIV								SIOCDEVPRIVATE
+#endif
+
+#define RT_PRIV_IOCTL								(SIOCIWFIRSTPRIV + 0x01)
+#define RTPRIV_IOCTL_SET							(SIOCIWFIRSTPRIV + 0x02)
+
+#ifdef DBG
+#define RTPRIV_IOCTL_BBP				(SIOCIWFIRSTPRIV + 0x03)
+#define RTPRIV_IOCTL_MAC				(SIOCIWFIRSTPRIV + 0x05)
+#endif
+
+#define RTPRIV_IOCTL_ADHOCOFDM				(SIOCIWFIRSTPRIV + 0x06)
+#define RTPRIV_IOCTL_AUTH				(SIOCIWFIRSTPRIV + 0x07)
+#define RTPRIV_IOCTL_WEPSTATUS				(SIOCIWFIRSTPRIV + 0x08)
+#define RTPRIV_IOCTL_STATISTICS				(SIOCIWFIRSTPRIV + 0x09)
+#define RTPRIV_IOCTL_WPAPSK				(SIOCIWFIRSTPRIV + 0x0A)
+#define RTPRIV_IOCTL_PSM				(SIOCIWFIRSTPRIV + 0x0B)
+#define RTPRIV_IOCTL_SETRFMONTX				(SIOCIWFIRSTPRIV + 0x0C)
+#define RTPRIV_IOCTL_GETRFMONTX				(SIOCIWFIRSTPRIV + 0x0D)
+#define RTPRIV_IOCTL_GSITESURVEY			(SIOCIWFIRSTPRIV + 0x0F)
+#define RTPRIV_IOCTL_GETRAAPCFG				(SIOCIWFIRSTPRIV + 0x11)
+#define RTPRIV_IOCTL_FORCEPRISMHEADER			(SIOCIWFIRSTPRIV + 0x12)
+
+#define OID_GET_SET_TOGGLE							0x8000
+
+#define OID_GEN_MACHINE_NAME                        0x0001021A
+
+//RaConfig (Query/SetInformation)-->
+#define OID_802_11_NETWORK_TYPES_SUPPORTED          0x0103
+#define OID_802_11_NETWORK_TYPE_IN_USE              0x0104
+#define OID_802_11_RSSI_TRIGGER                     0x0107
+#define OID_802_11_NUMBER_OF_ANTENNAS               0x010B
+#define OID_802_11_RX_ANTENNA_SELECTED              0x010C
+#define OID_802_11_TX_ANTENNA_SELECTED              0x010D
+#define OID_802_11_SUPPORTED_RATES                  0x010E
+#define OID_802_11_ADD_WEP                          0x0112
+#define OID_802_11_REMOVE_WEP                       0x0113
+#define OID_802_11_DISASSOCIATE                     0x0114
+#define OID_802_11_PRIVACY_FILTER                   0x0118
+#define OID_802_11_ASSOCIATION_INFORMATION          0x011E
+#define OID_802_11_TEST                             0x011F
+
+#define RT_OID_802_11_COUNTRY_REGION                0x0507
+#define OID_802_11_BSSID_LIST_SCAN                  0x0508
+#define OID_802_11_SSID                    			0x0509  //also in get
+#define OID_802_11_BSSID                   			0x050A  //also in get
+#define RT_OID_802_11_RADIO                         0x050B  //also in get
+#define RT_OID_802_11_PHY_MODE                      0x050C  //also in get
+#define RT_OID_802_11_STA_CONFIG                    0x050D  //also in get
+#define OID_802_11_DESIRED_RATES           		    0x050E
+#define RT_OID_802_11_PREAMBLE                      0x050F  //also in get
+#define OID_802_11_WEP_STATUS                       0x0510  //also in get
+#define OID_802_11_AUTHENTICATION_MODE              0x0511  //also in get
+#define OID_802_11_INFRASTRUCTURE_MODE              0x0512  //also in get
+#define RT_OID_802_11_RESET_COUNTERS                0x0513
+#define OID_802_11_RTS_THRESHOLD           		    0x0514  //also in get
+#define OID_802_11_FRAGMENTATION_THRESHOLD          0x0515  //also in get
+#define OID_802_11_POWER_MODE              		    0x0516  //also in get
+#define OID_802_11_TX_POWER_LEVEL                   0x0517
+#define RT_OID_802_11_ADD_WPA                       0x0518
+#define OID_802_11_REMOVE_KEY                       0x0519
+#define OID_802_11_ADD_KEY                          0x0520
+#define OID_802_11_CONFIGURATION           		    0x0521  //also in get
+#define OID_802_11_TX_PACKET_BURST			        0x0522
+#define RT_OID_802_11_QUERY_NOISE_LEVEL             0x0523
+#define RT_OID_802_11_EXTRA_INFO	                0x0524
+
+#define RT_OID_DEVICE_NAME                          0x0607
+#define RT_OID_VERSION_INFO                         0x0608
+#define OID_802_11_BSSID_LIST              		    0x0609
+#define OID_802_3_CURRENT_ADDRESS                   0x060A
+#define OID_GEN_MEDIA_CONNECT_STATUS                0x060B
+#define RT_OID_802_11_QUERY_LINK_STATUS             0x060C
+#define OID_802_11_RSSI                    		    0x060D
+#define OID_802_11_STATISTICS                       0x060E
+#define OID_GEN_RCV_OK                              0x060F
+#define OID_GEN_RCV_NO_BUFFER                       0x0610
+#define RT_OID_802_11_QUERY_EEPROM_VERSION          0x0611
+#define RT_OID_802_11_QUERY_FIRMWARE_VERSION        0x0612
+#define RT_OID_802_11_QUERY_LAST_RX_RATE            0x0613
+#define RT_OID_802_11_TX_POWER_LEVEL_1              0x0614
+#define RT_OID_802_11_QUERY_PIDVID                  0x0615
+
+//#if WPA_SUPPLICANT_SUPPORT
+#define OID_SET_COUNTERMEASURES                     0x0616
+#define OID_802_11_SET_IEEE8021X                    0x0617
+#define OID_802_11_SET_IEEE8021X_REQUIRE_KEY        0x0618
+#define OID_802_11_PMKID                            0x0620
+#define RT_OID_WPA_SUPPLICANT_SUPPORT               0x0621
+#define RT_OID_WE_VERSION_COMPILED                  0x0622
+#define OID_SET_WSC_IE_PROBE_REQ                    0x0624
+#define OID_802_11_RCV_BEACON                       0x0625
+//#endif
+
+#define OID_802_11_ENCRYPTION_STATUS                OID_802_11_WEP_STATUS
+#define OID_802_11_RELOAD_DEFAULTS                  0x011B
+//<-- RaConfig (Query/SetInformation)
+
+
+//
+// Ralink defined OIDs ******************
+//
+#ifdef TEST_MODE_SUPPORT
+#define RT_OID_ENTER_TEST_MODE						0x0D720101
+#define RT_OID_EXIT_TEST_MODE						0x0D720102
+
+#define RT_OID_START_BULK_OUT						0x0D73010E
+#define RT_OID_STOP_BULK_OUT						0x0D730115
+
+#define RT_OID_VENDOR_SELECT_CHANNEL				0x0D730112
+#define RT_OID_VENDOR_SET_TX_POWER					0x0D730113
+
+#if 0
+#define RT_OID_START_BULK_IN						0x0D720108
+#define RT_OID_STOP_BULK_IN							0x0D730116
+#else
+#define RT_OID_START_RX								0x0D720108
+#define RT_OID_STOP_RX								0x0D730116
+#endif
+
+#define RT_OID_START_CONT_TX						0x0D730120
+#define RT_OID_START_CARRIER_TX						0x0D730122
+#define RT_OID_STOP_TX								0x0D730121//stop BBP test mode continuous/carrier Tx.
+#define RT_OID_VENDOR_GET_COUNTERS					0x0D73011B
+#define RT_OID_VENDOR_GET_TX_FRAGMENTS_COUNT		0x0D73011C
+#endif  /* TEST_MODE_SUPPORT */
+
+#define RT_OID_VENDOR_GET_COUNTERS					0x0D73011B
+
+#define RT_OID_USB_VENDOR_RESET						0x0D730101
+#define RT_OID_USB_VENDOR_UNPLUG					0x0D730102
+#define RT_OID_USB_VENDOR_SWITCH_FUNCTION			0x0D730103
+
+#define RT_OID_MULTI_WRITE_MAC						0x0D730107
+#define RT_OID_MULTI_READ_MAC						0x0D730108
+#define RT_OID_USB_VENDOR_EEPROM_WRITE				0x0D73010A
+#define RT_OID_USB_VENDOR_EEPROM_READ				0x0D73010B
+
+#define RT_OID_USB_VENDOR_ENTER_TESTMODE			0x0D73010C
+#define RT_OID_USB_VENDOR_EXIT_TESTMODE				0x0D73010D
+#define RT_OID_USB_GET_DEVICE_DESC					0x0D730110
+#define RT_OID_VENDOR_WRITE_BBP						0x0D730119
+#define RT_OID_VENDOR_READ_BBP						0x0D730118
+#define RT_OID_VENDOR_WRITE_RF						0x0D73011A
+
+#define RT_OID_VENDOR_FLIP_IQ						0x0D73011D
+
+
+#define RT_OID_SET_PER_RATE_TX_RATE_SWITCHING_STRUC	0x0D730123
+#define RT_OID_GET_BBP_R17_TUNING_MODE				0x0D730124
+#define RT_OID_SET_BBP_R17_TUNING_MODE				(OID_GET_SET_TOGGLE | RT_OID_GET_BBP_R17_TUNING_MODE)
+#define RT_OID_GET_TEST_MODE_BBP_TUNING_MODE		0x0D730125
+#define RT_OID_SET_TEST_MODE_BBP_TUNING_MODE		(OID_GET_SET_TOGGLE | RT_OID_GET_TEST_MODE_BBP_TUNING_MODE)
+#define RT_OID_NOR_FLASH_ERASE_BLOCK				0x0D730126
+#define RT_OID_NOR_FLASH_WRITE						0x0D730127
+#define RT_OID_NOR_FLASH_READ						0x0D730128
+#define RT_OID_NOR_FLASH_GET						0x0D730129
+//#define RT_OID_SET_GENERAL_TX_RATE_SWITCHING_STRUC	0x0D730124
+//#define RT_OID_GET_TX_RATE_SWITCHING_COUNTERS		0x0D730125
+//used by driver internally
+#define RT_OID_USB_RESET_BULK_OUT					0x0D730210
+#define RT_OID_USB_RESET_BULK_IN					0x0D730211
+#define RT_OID_SET_PSM_BIT_SAVE						0x0D730212
+#define RT_OID_SET_RADIO							0x0D730214
+#define RT_OID_UPDATE_TX_RATE						0x0D730216
+#define OID_802_11_ADD_KEY_WEP						0x0D730218
+#define RT_OID_RESET_FROM_ERROR						0x0D73021A
+#define RT_OID_LINK_DOWN							0x0D73021B
+#define RT_OID_RESET_FROM_NDIS						0x0D73021C
+#define RT_OID_PERIODIC_EXECUT						0x0D73021D
+#define RT_OID_TEST_PERIODIC_EXECUT					0x0D73021E
+#define RT_OID_ASICLED_EXECUT						0x0D73021F
+#define RT_OID_CHECK_GPIO							0x0D730215
+#define RT_OID_REMOVE_ALLKEYS						0x0D730220
+#define RT_PERFORM_SOFT_DIVERSITY					0x0D730221
+#define RT_OID_FORCE_WAKE_UP						0x0D730222
+#define RT_OID_SET_PSM_BIT_ACTIVE					0x0D730223
+#define RT_CMD_RESET_MLME							0x0D730224
+#ifdef NETOPIA
+#define RT_OID_UPDATE_R17							0x0D730213
+#endif
+
+
+#define RT_OID_802_11_BSSID                   (OID_GET_SET_TOGGLE | OID_802_11_BSSID)
+#define RT_OID_802_11_SSID                    (OID_GET_SET_TOGGLE | OID_802_11_SSID)
+#define RT_OID_802_11_INFRASTRUCTURE_MODE     (OID_GET_SET_TOGGLE | OID_802_11_INFRASTRUCTURE_MODE)
+#define RT_OID_802_11_ADD_WEP                 (OID_GET_SET_TOGGLE | OID_802_11_ADD_WEP)
+#define RT_OID_802_11_ADD_KEY                 (OID_GET_SET_TOGGLE | OID_802_11_ADD_KEY)
+#define RT_OID_802_11_REMOVE_WEP              (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_WEP)
+#define RT_OID_802_11_REMOVE_KEY              (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_KEY)
+#define RT_OID_802_11_DISASSOCIATE            (OID_GET_SET_TOGGLE | OID_802_11_DISASSOCIATE)
+#define RT_OID_802_11_AUTHENTICATION_MODE     (OID_GET_SET_TOGGLE | OID_802_11_AUTHENTICATION_MODE)
+#define RT_OID_802_11_PRIVACY_FILTER          (OID_GET_SET_TOGGLE | OID_802_11_PRIVACY_FILTER)
+#define RT_OID_802_11_BSSID_LIST_SCAN         (OID_GET_SET_TOGGLE | OID_802_11_BSSID_LIST_SCAN)
+#define RT_OID_802_11_WEP_STATUS              (OID_GET_SET_TOGGLE | OID_802_11_WEP_STATUS)
+#define RT_OID_802_11_RELOAD_DEFAULTS         (OID_GET_SET_TOGGLE | OID_802_11_RELOAD_DEFAULTS)
+#define RT_OID_802_11_NETWORK_TYPE_IN_USE     (OID_GET_SET_TOGGLE | OID_802_11_NETWORK_TYPE_IN_USE)
+#define RT_OID_802_11_TX_POWER_LEVEL          (OID_GET_SET_TOGGLE | OID_802_11_TX_POWER_LEVEL)
+#define RT_OID_802_11_RSSI_TRIGGER            (OID_GET_SET_TOGGLE | OID_802_11_RSSI_TRIGGER)
+#define RT_OID_802_11_FRAGMENTATION_THRESHOLD (OID_GET_SET_TOGGLE | OID_802_11_FRAGMENTATION_THRESHOLD)
+#define RT_OID_802_11_RTS_THRESHOLD           (OID_GET_SET_TOGGLE | OID_802_11_RTS_THRESHOLD)
+#define RT_OID_802_11_RX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_RX_ANTENNA_SELECTED)
+#define RT_OID_802_11_TX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_TX_ANTENNA_SELECTED)
+#define RT_OID_802_11_SUPPORTED_RATES         (OID_GET_SET_TOGGLE | OID_802_11_SUPPORTED_RATES)
+#define RT_OID_802_11_DESIRED_RATES           (OID_GET_SET_TOGGLE | OID_802_11_DESIRED_RATES)
+#define RT_OID_802_11_CONFIGURATION           (OID_GET_SET_TOGGLE | OID_802_11_CONFIGURATION)
+#define RT_OID_802_11_POWER_MODE              (OID_GET_SET_TOGGLE | OID_802_11_POWER_MODE)
+
+#define RT_OID_802_11_QUERY_PREAMBLE          0x0D710101
+#define RT_OID_802_11_SET_PREAMBLE            (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_PREAMBLE)
+
+#define RT_OID_802_11_QUERY_AC_CAM            0x0D710104
+#define RT_OID_802_11_SET_AC_CAM              (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_AC_CAM)
+#ifdef DBG
+#define RT_OID_802_11_QUERY_HARDWARE_REGISTER 0x0D710105
+#define RT_OID_802_11_SET_HARDWARE_REGISTER   (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_HARDWARE_REGISTER)
+#endif
+#define RT_OID_802_11_QUERY_RACONFIG          0x0D710106
+#define RT_OID_802_11_SET_RACONFIG            (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_RACONFIG)
+
+#define RT_OID_802_11_QUERY_COUNTRY_REGION     0x0D710107
+#define RT_OID_802_11_SET_COUNTRY_REGION       (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_COUNTRY_REGION)
+
+#define	RT_OID_802_11_QUERY_RADIO			  0x0D710108
+#define RT_OID_802_11_SET_RADIO      		  (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_RADIO)
+
+#define RT_OID_802_11_QUERY_PHY_MODE          0x0D71010C
+#define RT_OID_802_11_SET_PHY_MODE            (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_PHY_MODE)
+
+#define RT_OID_802_11_QUERY_STA_CONFIG        0x0D710111
+#define RT_OID_802_11_SET_STA_CONFIG          (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_STA_CONFIG)
+
+//wpa counter measure test
+#define RT_OID_802_11_QUERY_GEN_MIC_ERROR     0x0D710115
+#define RT_OID_802_11_SET_GEN_MIC_ERROR       (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_GEN_MIC_ERROR)
+
+#define RT_OID_802_11_QUERY_CURRENT_CHANNEL_ID 0x0D710117
+
+#define	RT_OID_802_11_RSSI_2				  0x0D710125
+#define RT_OID_802_11_SET_TX_RATES            (OID_GET_SET_TOGGLE | 0x0D710127)
+#define RT_OID_802_11_QUERY_IEEE80211H			0x0D710128
+#define RT_OID_802_11_SET_IEEE80211H			(OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_IEEE80211H)
+
+//#if WPA_SUPPLICANT_SUPPORT
+#define	RT_ASSOC_EVENT_FLAG                         0x0101
+#define	RT_DISASSOC_EVENT_FLAG                      0x0102
+#define	RT_REQIE_EVENT_FLAG                         0x0103
+#define	RT_RESPIE_EVENT_FLAG                        0x0104
+#define	RT_ASSOCINFO_EVENT_FLAG                     0x0105
+#define RT_PMKIDCAND_FLAG                           0x0106
+//#endif
+
+//
+// IEEE 802.11 Structures and definitions
+//
+// new types for Media Specific Indications
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+
+typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+
+#define NDIS_802_11_AUTH_REQUEST_REAUTH             0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE          0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR     0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR        0x0E
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+// Added new types for OFDM 5G and 2.4G
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11Automode,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct PACKED _NDIS_802_11_NETWORK_TYPE_LIST
+{
+    ULONG                       NumberOfItems;  // in list below, at least 1
+    NDIS_802_11_NETWORK_TYPE    NetworkType [1];
+} NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;
+
+typedef enum _NDIS_802_11_POWER_MODE
+{
+    Ndis802_11PowerModeCAM,
+    Ndis802_11PowerModeMAX_PSP,
+    Ndis802_11PowerModeFast_PSP,
+    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
+} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;
+
+typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts
+
+//
+// Received Signal Strength Indication
+//
+typedef LONG    NDIS_802_11_RSSI;           // in dBm
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    ULONG           Length;            // Length of structure
+    ULONG           HopPattern;        // As defined by 802.11, MSB set
+    ULONG           HopSet;            // to one if non-802.11
+    ULONG           DwellTime;         // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+   ULONG                           Length;             // Length of structure
+   ULONG                           BeaconPeriod;       // units are Kusec
+   ULONG                           ATIMWindow;         // units are Kusec
+   ULONG                           DSConfig;           // Frequency, units are kHz
+   NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+typedef struct _NDIS_802_11_STATISTICS
+{
+    ULONG           Length;             // Length of structure
+    LARGE_INTEGER   TransmittedFragmentCount;
+    LARGE_INTEGER   MulticastTransmittedFrameCount;
+    LARGE_INTEGER   FailedCount;
+    LARGE_INTEGER   RetryCount;
+    LARGE_INTEGER   MultipleRetryCount;
+    LARGE_INTEGER   RTSSuccessCount;
+    LARGE_INTEGER   RTSFailureCount;
+    LARGE_INTEGER   ACKFailureCount;
+    LARGE_INTEGER   FrameDuplicateCount;
+    LARGE_INTEGER   ReceivedFragmentCount;
+    LARGE_INTEGER   MulticastReceivedFrameCount;
+    LARGE_INTEGER   FCSErrorCount;
+} NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef ULONGLONG   NDIS_802_11_KEY_RSC;
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[1];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG                   Length;        // Length of this structure
+    ULONG                   KeyIndex;
+    NDIS_802_11_MAC_ADDRESS BSSID;
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct PACKED _NDIS_802_11_WEP
+{
+    ULONG     Length;        // Length of this structure
+    ULONG     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    ULONG     KeyLength;     // length of key in bytes
+    UCHAR     KeyMaterial[1];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11Monitor,
+    Ndis802_11InfrastructureMax     // Not a real value, defined as upper bound
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+// PMKID Structures
+typedef UCHAR   NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSID_INFO
+{
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	NDIS_802_11_PMKID_VALUE PMKID;
+} BSSID_INFO, *PBSSID_INFO;
+
+typedef struct _NDIS_802_11_PMKID
+{
+	ULONG Length;
+	ULONG BSSIDInfoCount;
+	BSSID_INFO BSSIDInfo[1];
+} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
+
+//Added new types for PMKID Candidate lists.
+typedef struct _PMKID_CANDIDATE {
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	ULONG Flags;
+} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
+{
+	ULONG Version;       // Version of the structure
+	ULONG NumCandidates; // No. of pmkid candidates
+	PMKID_CANDIDATE CandidateList[1];
+} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+//Flags for PMKID Candidate list structure
+#define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01
+
+
+// Add new authentication modes
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeWPA2,
+    Ndis802_11AuthModeWPA2PSK,
+    Ndis802_11AuthModeMax           // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+#define WPA1AKMBIT	    1
+#define WPA2AKMBIT	    2
+#define WPA1PSKAKMBIT   4
+#define WPA2PSKAKMBIT   8
+
+typedef UCHAR NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef UCHAR NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+typedef struct PACKED _NDIS_802_11_SSID
+{
+    ULONG   SsidLength;         // length of SSID field below, in bytes; this can be zero.
+    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+
+typedef struct PACKED _NDIS_WLAN_BSSID
+{
+    ULONG                               Length;     // Length of this structure
+    NDIS_802_11_MAC_ADDRESS             MacAddress; // BSSID
+    UCHAR                               Reserved[2];
+    NDIS_802_11_SSID                    Ssid;       // SSID
+    ULONG                               Privacy;    // WEP encryption requirement
+    NDIS_802_11_RSSI                    Rssi;       // receive signal, strength in dBm
+    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
+    NDIS_802_11_CONFIGURATION           Configuration;
+    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+    NDIS_802_11_RATES                   SupportedRates;
+} NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;
+
+typedef struct PACKED _NDIS_802_11_BSSID_LIST
+{
+    ULONG           NumberOfItems;      // in list below, at least 1
+    NDIS_WLAN_BSSID Bssid[1];
+} NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;
+
+// Added Capabilities, IELength and IEs for each BSSID
+typedef struct PACKED _NDIS_WLAN_BSSID_EX
+{
+    ULONG                               Length;             // Length of this structure
+    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
+    UCHAR                               Reserved[2];
+    NDIS_802_11_SSID                    Ssid;               // SSID
+    ULONG                               Privacy;            // WEP encryption requirement
+    NDIS_802_11_RSSI                    Rssi;               // receive signal
+                                                            // strength in dBm
+    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
+    NDIS_802_11_CONFIGURATION           Configuration;
+    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+    NDIS_802_11_RATES_EX                SupportedRates;
+    ULONG                               IELength;
+    UCHAR                               IEs[1];
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+    ULONG                   NumberOfItems;      // in list below, at least 1
+    NDIS_WLAN_BSSID_EX      Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+    UCHAR Timestamp[8];
+    USHORT BeaconInterval;
+    USHORT Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+    UCHAR ElementID;
+    UCHAR Length;    // Number of bytes in data field
+    UCHAR data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;
+
+typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;
+
+typedef  ULONG   NDIS_802_11_ANTENNA;
+
+typedef enum _NDIS_802_11_PRIVACY_FILTER
+{
+    Ndis802_11PrivFilterAcceptAll,
+    Ndis802_11PrivFilter8021xWEP
+} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;
+
+// Added new encryption types
+// Also aliased typedef to new name
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+typedef enum _RT_802_11_PREAMBLE {
+    Rt802_11PreambleLong,
+    Rt802_11PreambleShort,
+    Rt802_11PreambleAuto
+} RT_802_11_PREAMBLE, *PRT_802_11_PREAMBLE;
+
+// 2005-03-08 match current RaConfig.
+typedef enum _RT_802_11_PHY_MODE {
+    PHY_11BG_MIXED,
+    PHY_11B,
+    PHY_11A,
+    PHY_11ABG_MIXED,
+    PHY_11G
+} RT_802_11_PHY_MODE;
+
+typedef enum _RT_802_11_ADHOC_MODE {
+	ADHOC_11B,
+	ADHOC_11BG_MIXED,
+	ADHOC_11G,
+	ADHOC_11A,
+	ADHOC_11ABG_MIXED
+} RT_802_11_ADHOC_MODE;
+
+// put all proprietery for-query objects here to reduce # of Query_OID
+typedef struct _RT_802_11_LINK_STATUS {
+    ULONG   CurrTxRate;         // in units of 0.5Mbps
+    ULONG   ChannelQuality;     // 0..100 %
+    ULONG   TxByteCount;        // both ok and fail
+    ULONG   RxByteCount;        // both ok and fail
+} RT_802_11_LINK_STATUS, *PRT_802_11_LINK_STATUS;
+
+// structure for query/set hardware register - MAC, BBP, RF register
+typedef struct _RT_802_11_HARDWARE_REGISTER {
+    ULONG   HardwareType;       // 0:MAC, 1:BBP, 2:RF register
+    ULONG   Offset;             // Q/S register offset addr
+    ULONG   Data;               // R/W data buffer
+} RT_802_11_HARDWARE_REGISTER, *PRT_802_11_HARDWARE_REGISTER;
+
+// structure to tune BBP R17 "RX AGC VGC init"
+//typedef struct _RT_802_11_RX_AGC_VGC_TUNING {
+//    UCHAR   FalseCcaLowerThreshold;  // 0-255, def 10
+//    UCHAR   FalseCcaUpperThreshold;  // 0-255, def 100
+//    UCHAR   VgcDelta;                // R17 +-= VgcDelta whenever flase CCA over UpprThreshold
+//                                     // or lower than LowerThresholdupper threshold
+//    UCHAR   VgcUpperBound;           // max value of R17
+//} RT_802_11_RX_AGC_VGC_TUNING, *PRT_802_11_RX_AGC_VGC_TUNING;
+
+// structure to query/set STA_CONFIG
+typedef struct _RT_802_11_STA_CONFIG {
+    ULONG   EnableTxBurst;      // 0-disable, 1-enable
+    ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
+    ULONG   UseBGProtection;    // 0-AUTO, 1-always ON, 2-always OFF
+    ULONG   UseShortSlotTime;   // 0-no use, 1-use 9-us short slot time when applicable
+    ULONG   AdhocMode; 			// 0-11b rates only (WIFI spec), 1 - b/g mixed, 2 - g only
+    ULONG   HwRadioStatus;      // 0-OFF, 1-ON, default is 1, Read-Only
+    ULONG   Rsv1;               // must be 0
+    ULONG   SystemErrorBitmap;  // ignore upon SET, return system error upon QUERY
+} RT_802_11_STA_CONFIG, *PRT_802_11_STA_CONFIG;
+
+typedef struct _RT_VERSION_INFO{
+    UCHAR       DriverVersionW;
+    UCHAR       DriverVersionX;
+    UCHAR       DriverVersionY;
+    UCHAR       DriverVersionZ;
+    UINT        DriverBuildYear;
+    UINT        DriverBuildMonth;
+    UINT        DriverBuildDay;
+} RT_VERSION_INFO, *PRT_VERSION_INFO;
+
+//
+// Defines the state of the LAN media
+//
+typedef enum _NDIS_MEDIA_STATE
+{
+    NdisMediaStateConnected,
+    NdisMediaStateDisconnected
+} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;
+
+
+
+// Definition of extra information code
+#define	GENERAL_LINK_UP			0x0			// Link is Up
+#define	GENERAL_LINK_DOWN		0x1			// Link is Down
+#define	HW_RADIO_OFF			0x2			// Hardware radio off
+#define	SW_RADIO_OFF			0x3			// Software radio off
+#define	AUTH_FAIL				0x4			// Open authentication fail
+#define	AUTH_FAIL_KEYS			0x5			// Shared authentication fail
+#define	ASSOC_FAIL				0x6			// Association failed
+#define	EAP_MIC_FAILURE			0x7			// Deauthencation because MIC failure
+#define	EAP_4WAY_TIMEOUT		0x8			// Deauthencation on 4-way handshake timeout
+#define	EAP_GROUP_KEY_TIMEOUT	0x9			// Deauthencation on group key handshake timeout
+#define	EAP_SUCCESS				0xa			// EAP succeed
+#define	DETECT_RADAR_SIGNAL		0xb         // Radar signal occur in current channel
+
+#define EXTRA_INFO_CLEAR		0xffffffff
+
+#endif // _OID_H_
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rt2x00debug.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt2x00debug.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rt2x00debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt2x00debug.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,76 @@
+/*
+	Copyright (C) 2004 - 2007 rt2x00 SourceForge Project
+	<http://rt2x00.serialmonkey.com>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the
+	Free Software Foundation, Inc.,
+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+	Module: rt2x00debug
+	Abstract: Data structures for the rt2x00debug module.
+	Supported chipsets: RT2460, RT2560, RT2570,
+	rt2561, rt2561s, rt2661 & rt2573.
+ */
+
+typedef void (debug_access_t)(void *dev, const unsigned long word, void *data);
+
+struct rt2x00debug_reg {
+	debug_access_t *read;
+	debug_access_t *write;
+
+	unsigned int word_size;
+	unsigned int length;
+};
+
+struct rt2x00debug {
+	/*
+	 * Name of the interface.
+	 */
+	char intf_name[16];
+
+	/*
+	 * Reference to the modules structure.
+	 */
+	struct module *owner;
+
+	/*
+	 * Driver module information
+	 */
+	char *mod_name;
+	char *mod_version;
+
+	/*
+	 * Register access information.
+	 */
+	struct rt2x00debug_reg reg_csr;
+	struct rt2x00debug_reg reg_eeprom;
+	struct rt2x00debug_reg reg_bbp;
+
+	/*
+	 * Pointer to driver structure where
+	 * this debugfs entry belongs to.
+	 */
+	void *dev;
+
+	/*
+	 * Pointer to rt2x00debug private data,
+	 * individual driver should not touch this.
+	 */
+	void *priv;
+};
+
+extern int rt2x00debug_register(struct rt2x00debug *debug);
+extern void rt2x00debug_deregister(struct rt2x00debug *debug);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rt73.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt73.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rt73.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt73.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1892 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rt73.h
+ *
+ *	Abstract: RT2573 ASIC related definition & structures
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Nemo Tang	02-20-2005	created
+ *	idamlaj	05-10-2006	Import rfmon implementation
+ *
+ ***************************************************************************/
+
+#ifndef	__RT73_H__
+#define	__RT73_H__
+////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////
+// reg for RT73 ///////////
+//////////////////////////
+
+// 8051 firmware image - base address = 0x4000
+#define FIRMWARE_IMAGE_BASE     0x800
+#define FIRMWARE_IMAGE_SIZE	2048	// 2k byte
+
+//
+// Security key table memory, base address = 0x1000
+//
+#define SHARED_KEY_TABLE_BASE       0x1000      // 32-byte * 16-entry = 512-byte
+#define PAIRWISE_KEY_TABLE_BASE     0x1200      // 32-byte * 64-entry = 2048-byte
+#define PAIRWISE_TA_TABLE_BASE      0x1a00      // 8-byte * 64-entry = 512-byte
+
+// 32-byte per entry, total 16-entry for shared key table, 64-entry for pairwise key table
+typedef struct _HW_KEY_ENTRY {          // 32-byte per entry
+	UCHAR   Key[16];
+	UCHAR   TxMic[8];
+	UCHAR   RxMic[8];
+} HW_KEY_ENTRY, *PHW_KEY_ENTRY;
+#define HW_KEY_ENTRY_SIZE           sizeof(HW_KEY_ENTRY)
+
+// 64-entry for pairwise key table
+typedef struct _HW_PAIRWISE_TA_ENTRY {  // 8-byte per entry
+	UCHAR   Address[6];
+	UCHAR   Rsv[2];
+} HW_PAIRWISE_TA_ENTRY, PHW_PAIRWISE_TA_ENTRY;
+#define HW_PAIRWISE_TA_ENTRY_SIZE   sizeof(HW_PAIRWISE_TA_ENTRY)
+
+#define HW_DEBUG_SETTING_BASE   0x2bf0  // 0x2bf0~0x2bff total 16 bytes
+#define HW_DEBUG_SETTING_END	0x2bff
+
+// on-chip BEACON frame space - base address = 0x2400
+#define HW_BEACON_BASE0         0x2400
+#define HW_BEACON_BASE1         0x2500
+#define HW_BEACON_BASE2         0x2600
+#define HW_BEACON_BASE3         0x2700
+
+//
+// MAC Control Registers - base address 0x3000
+//
+#define MAC_CSR0            0x3000
+#define MAC_CSR1            0x3004
+#define MAC_CSR2            0x3008
+#define MAC_CSR3            0x300c
+#define MAC_CSR4            0x3010
+#define MAC_CSR5            0x3014
+#define MAC_CSR6            0x3018
+#define MAC_CSR7            0x301c
+#define MAC_CSR8            0x3020  // SIFS/EIFS
+#define MAC_CSR9            0x3024
+#define MAC_CSR10           0x3028  // power state configuration
+#define MAC_CSR11           0x302c  // Power state transition time
+#define MAC_CSR12           0x3030  // power state
+#define MAC_CSR13           0x3034  // GPIO
+#define MAC_CSR14           0x3038  // LED control
+#define MAC_CSR15           0x303c  // NAV control
+
+//
+// TXRX control registers - base address 0x3000
+//
+#define TXRX_CSR0           0x3040
+#define TXRX_CSR1           0x3044
+#define TXRX_CSR2           0x3048
+#define TXRX_CSR3           0x304c
+#define TXRX_CSR4           0x3050
+#define TXRX_CSR5           0x3054
+#define TXRX_CSR6           0x3058  // ACK/CTS payload consumed time
+#define TXRX_CSR7           0x305c  // ACK/CTS payload consumed time
+#define TXRX_CSR8           0x3060  // ACK/CTS payload consumed time
+#define TXRX_CSR9           0x3064  // BEACON SYNC
+#define TXRX_CSR10          0x3068  // BEACON alignment
+#define TXRX_CSR11          0x306c  // AES mask
+#define TXRX_CSR12          0x3070  // TSF low 32
+#define TXRX_CSR13          0x3074  // TSF high 32
+#define TXRX_CSR14          0x3078  // TBTT timer
+#define TXRX_CSR15          0x307c  // TKIP MIC priority byte "AND" mask
+
+//
+// PHY control registers - base address 0x3000
+//
+#define PHY_CSR0            0x3080  // RF/PS control
+#define PHY_CSR1            0x3084
+#define PHY_CSR2            0x3088  // pre-TX BBP control
+#define PHY_CSR3            0x308c  // BBP access
+#define PHY_CSR4            0x3090  // RF serial control
+#define PHY_CSR5            0x3094  // RX to TX signal switch timing control
+#define PHY_CSR6            0x3098  // TX to RX signal timing control
+#define PHY_CSR7            0x309c  // TX DAC switching timing control
+
+//
+// Security control register - base address 0x3000
+//
+#define SEC_CSR0            0x30a0  // shared key table control
+#define SEC_CSR1            0x30a4  // shared key table security mode
+#define SEC_CSR2            0x30a8  // pairwise key table valid bitmap 0
+#define SEC_CSR3            0x30ac  // pairwise key table valid bitmap 1
+#define SEC_CSR4            0x30b0  // pairwise key table lookup control
+#define SEC_CSR5            0x30b4  // shared key table security mode
+
+//
+// STA control registers - base address 0x3000
+//
+#define STA_CSR0            0x30c0  // CRC/PLCP error counter
+#define STA_CSR1            0x30c4  // Long/False-CCA error counter
+#define STA_CSR2            0x30c8  // RX FIFO overflow counter
+#define STA_CSR3            0x30cc  // TX Beacon counter
+#define STA_CSR4            0x30d0  // TX Retry (1) Counters
+#define STA_CSR5            0x30d4  // TX Retry (2) Counters
+
+//
+// QOS control registers - base address 0x3000
+//
+#define QOS_CSR0            0x30e0  // TXOP holder MAC address 0
+#define QOS_CSR1            0x30e4  // TXOP holder MAC address 1
+#define QOS_CSR2            0x30e8  // TXOP holder timeout register
+#define QOS_CSR3            0x30ec  // RX QOS-CFPOLL MAC address 0
+#define QOS_CSR4            0x30f0  // RX QOS-CFPOLL MAC address 1
+#define QOS_CSR5            0x30f4  // "QosControl" field of the RX QOS-CFPOLL
+
+
+
+////////WMM Scheduler Register////////////
+
+#define AIFSN_CSR               0x0400
+#define CWMIN_CSR           	0x0404
+#define CWMAX_CSR           	0x0408
+#define AC_TXOP_CSR0        	0x040c
+#define AC_TXOP_CSR1        	0x0410
+////////////////////////////////////////////////////////////////////////////////////////
+
+// ================================================================
+// Tx /	Rx / Mgmt ring descriptor definition
+// ================================================================
+
+// value domain of pTxD->Owner and pRxD->Owner
+#define	DESC_OWN_HOST		    0
+#define	DESC_OWN_NIC		    1
+
+// the following PID values are used to mark outgoing frame type in TXD so that
+// proper TX statistics can be collected based on these categories
+#define PID_DATA_REQUIRE_ACK    0x00    // b0~6 = MAC table index when acking as AP
+#define PID_DATA_WITHOUT_ACK    0x40    // b0~6 = MAC table index when acting as AP
+#define PID_NULL_AT_HIGH_RATE   0x80
+#define PID_RTS_FRAME           0x81
+#define PID_MGMT_FRAME          0x82
+#define PID_CNTL_FRAME          0x83    // other non-RTS Control frame
+#define PID_MCU_INTERNAL        0xff    // frame generated internally by 8051
+
+#if 0
+// the following PID values are used to mark outgoing frame type in TXD->PID so that
+// proper TX statistics can be collected based on these categories
+// b7-6 of PID field -
+#define PTYPE_DATA_REQUIRE_ACK  0x00 // b7-6:00, b5-0: 0~59 is MAC table index (AID?), 60~63 is WDS index
+#define PTYPE_NULL_AT_HIGH_RATE 0x40 // b7-6:01, b5-0: 0~59 is MAC table index (AID?), 60~63 is WDS index
+#define PTYPE_RESERVED          0x80 // b7-6:10
+#define PTYPE_SPECIAL           0xc0 // b7-6:11
+
+// when b7-6=11 (PTYPE_SPECIAL), b5-0 coube be ...
+#define PSUBTYPE_DATA_NO_ACK    0x00
+#define PSUBTYPE_MGMT           0x01
+#define PSUBTYPE_OTHER_CNTL     0x02
+#define PSUBTYPE_RTS            0x03
+#define PSUBTYPE_MCU_INTERNAL   0x04
+#endif
+
+// value domain of pTxD->HostQId (4-bit: 0~15)
+#define QID_AC_BK               1   // meet ACI definition in 802.11e
+#define QID_AC_BE               0   // meet ACI definition in 802.11e
+#define QID_AC_VI               2
+#define QID_AC_VO               3
+#define QID_HCCA                4
+#define NUM_OF_TX_RING          5
+#define QID_MGMT                13
+#define QID_RX                  14
+#define QID_OTHER               15
+
+//-----------------------------------------------------
+// BBP & RF	definition
+//-----------------------------------------------------
+#define	BUSY		1
+#define	IDLE		0
+
+#define	BBP_R0					    0  // version
+#define	BBP_R1				        1  // TSSI
+#define	BBP_R2          			2  // TX configure
+#define BBP_R3                      3
+#define BBP_R4                      4
+#define BBP_R5                      5
+#define BBP_R6                      6
+#define	BBP_R14			            14 // RX configure
+#define BBP_R16                     16
+#define BBP_R17                     17 // RX sensibility
+#define BBP_R18                     18
+#define BBP_R21                     21
+#define BBP_R22                     22
+#define BBP_R32                     32
+#define BBP_R62                     62 // Rx SQ0 Threshold HIGH
+#define BBP_R64                     64
+#define BBP_R66                     66
+#define BBP_R70                     70 // Japan filter
+#define BBP_R77                     77
+#define BBP_R82                     82
+#define BBP_R83                     83
+#define BBP_R84                     84
+#define BBP_R94                     94 // Tx Gain Control
+
+#define BBPR94_DEFAULT              0x06 // Add 1 value will gain 1db
+
+#define RSSI_FOR_VERY_LOW_SENSIBILITY -35
+#define RSSI_FOR_LOW_SENSIBILITY    -58
+#define RSSI_FOR_MID_LOW_SENSIBILITY  -66
+#define RSSI_FOR_MID_SENSIBILITY    -74
+
+//-------------------------------------------------------------------------
+// EEPROM definition
+//-------------------------------------------------------------------------
+#define EEDO        0x10
+#define EEDI        0x08
+#define EECS        0x04
+#define EESK        0x02
+#define EERL        0x01
+
+#define EEPROM_WRITE_OPCODE     0x05
+#define EEPROM_READ_OPCODE      0x06
+#define EEPROM_EWDS_OPCODE      0x10
+#define EEPROM_EWEN_OPCODE      0x13
+
+#define	NUM_EEPROM_BBP_PARMS		19
+#define	NUM_EEPROM_TX_G_PARMS			7
+#define	NUM_EEPROM_BBP_TUNING_PARMS	7
+#define EEPROM_VERSION_OFFSET       0x2
+#define	EEPROM_MAC_ADDRESS_BASE_OFFSET		0x4
+#define	EEPROM_BBP_BASE_OFFSET		0x20
+#define	EEPROM_G_TX_PWR_OFFSET		0x46
+#define	EEPROM_FREQ_OFFSET			0x5e
+#define EEPROM_LED_OFFSET			0x60
+#define EEPROM_A_TX_PWR_OFFSET      0x62
+#define EEPROM_J52_TX_PWR_OFFSET    0x7C  //Skip 0x7C, it start from 0x7D
+#define	EEPROM_TSSI_REF_OFFSET		0x4A
+#define	EEPROM_TSSI_DELTA_OFFSET	0x1A
+
+#define	EEPROM_RSSI_BG_OFFSET			0x9a
+#define	EEPROM_RSSI_A_OFFSET			0x9c
+#define	EEPROM_BG_TSSI_CALIBRAION	0x54
+#define	EEPROM_A_TSSI_CALIBRAION	0x90
+#define EEPROM_TXPOWER_DELTA_OFFSET 0x9e
+
+// =================================================================================
+// TX / RX ring descriptor format
+// =================================================================================
+
+// the first 24-byte in TXD is called TXINFO and will be DMAed to MAC block through TXFIFO.
+// MAC block use this TXINFO to control the transmission behavior of this frame.
+#define TXINFO_SIZE                 24
+
+//
+// TX descriptor format, Tx	ring, Mgmt Ring
+//
+#ifdef BIG_ENDIAN
+typedef	struct	_TXD_STRUC {
+	//Word 0
+	ULONG       Reserved:7;
+	ULONG       bWaitingDmaDoneInt:1; // pure s/w flag. 1:TXD been filled with data and waiting for TxDoneISR for housekeeping
+	ULONG       BbpTxPower:8;
+	ULONG       PktId:8;            // driver assigned packet ID to categorize TXResult in TxDoneInterrupt
+	ULONG       FrameOffset:8;      // frame start offset inside ASIC TXFIFO (after TXINFO field)
+
+	// Word	1
+	ULONG       Eiv;
+
+	// Word	2
+	ULONG       Iv;
+
+	// Word	3
+	ULONG      	PlcpLengthHigh:8;
+	ULONG      	PlcpLengthLow:8;
+	ULONG      	PlcpService:8;
+	ULONG      	PlcpSignal:8;
+
+	//Word 4
+	ULONG       BufCount:3;         // number of buffers in this TXD
+	ULONG       HwSeq:1;            // MAC auto replace the 12-bit frame sequence #
+	ULONG       :6;
+	ULONG       IvOffset:6;
+	ULONG       Cwmax:4;
+	ULONG       Cwmin:4;
+	ULONG       Aifsn:4;
+	ULONG       HostQId:4;          // EDCA/HCCA queue ID
+
+	//Word 5
+	ULONG       CipherAlg:3;
+	ULONG       Burst2:1;            // definition as same as "Burst", for backward compatible set this one to the same as "Burst" set.
+	ULONG       DataByteCnt:12;
+	ULONG       KeyIndex:6;         // Key index (0~31) to the pairwise KEY table; or
+									// 0~3 to shared KEY table 0 (BSS0). STA always use BSS0
+									// 4~7 to shared KEY table 1 (BSS1)
+									// 8~11 to shared KEY table 2 (BSS2)
+									// 12~15 to shared KEY table 3 (BSS3)
+	ULONG       KeyTable:1;         	// 1: use per-client pairwise KEY table, 0: shared KEY table
+	ULONG       TkipMic:1;          	// 1: ASIC is responsible for appending TKIP MIC if TKIP is inused
+	ULONG		RetryMd:1;          	// 1: Long retry (4 times), 0: short retry (7 times)
+	ULONG		IFS:1;              	// 1: require a BACKOFF before this frame, 0:SIFS before this frame
+	ULONG       	Ofdm:1;             	// 1: TX using OFDM rates
+	ULONG		Timestamp:1;    	// 1: MAC auto overwrite current TSF into frame body
+	ULONG		ACK:1;              	// 1: ACK is required
+	ULONG		MoreFrag:1;		// 1: More fragment following this frame
+	ULONG		Drop:1;			// 0: skip this frame, 1:valid frame inside
+	ULONG		Burst:1;		// 1: Contiguously used current End Ponit, eg, Fragment packet should turn on.
+						//	Tell EDCA that the next frame belongs to the same "burst" even though TXOP=0
+
+}	TXD_STRUC, *PTXD_STRUC;
+#else
+typedef	struct	_TXD_STRUC {
+	// word 0
+	ULONG		Burst:1;			// 1: Contiguously used current End Ponit, eg, Fragment packet should turn on.
+									//    Tell EDCA that the next frame belongs to the same "burst" even though TXOP=0
+	ULONG		Drop:1;			    // 0: skip this frame, 1:valid frame inside
+	ULONG		MoreFrag:1;			// 1: More fragment following this frame
+	ULONG		ACK:1;              // 1: ACK is required
+	ULONG		Timestamp:1;        // 1: MAC auto overwrite current TSF into frame body
+	ULONG       	Ofdm:1;             // 1: TX using OFDM rates
+	ULONG		IFS:1;              // 1: require a BACKOFF before this frame, 0:SIFS before this frame
+	ULONG		RetryMd:1;          // 1: Long retry (4 times), 0: short retry (7 times)
+
+	ULONG       TkipMic:1;          // 1: ASIC is responsible for appending TKIP MIC if TKIP is inused
+	ULONG       KeyTable:1;         // 1: use per-client pairwise KEY table, 0: shared KEY table
+	ULONG       KeyIndex:6;         // Key index (0~31) to the pairwise KEY table; or
+									// 0~3 to shared KEY table 0 (BSS0). STA always use BSS0
+									// 4~7 to shared KEY table 1 (BSS1)
+									// 8~11 to shared KEY table 2 (BSS2)
+									// 12~15 to shared KEY table 3 (BSS3)
+
+	ULONG       DataByteCnt:12;
+	ULONG       Burst2:1;            // definition as same as "Burst", for backward compatible set this one to the same as "Burst" set.
+	ULONG       CipherAlg:3;
+
+	// Word	1
+	ULONG       HostQId:4;          // EDCA/HCCA queue ID
+	ULONG       Aifsn:4;
+	ULONG       Cwmin:4;
+	ULONG       Cwmax:4;
+	ULONG       IvOffset:6;
+	ULONG       :6;
+	ULONG       HwSeq:1;            // MAC auto replace the 12-bit frame sequence #
+	ULONG       BufCount:3;         // number of buffers in this TXD
+
+	// Word	2
+	ULONG      	PlcpSignal:8;
+	ULONG      	PlcpService:8;
+	ULONG      	PlcpLengthLow:8;
+	ULONG      	PlcpLengthHigh:8;
+
+	// Word	3
+	ULONG       Iv;
+
+	// Word	4
+	ULONG       Eiv;
+
+	// Word 5
+	ULONG       FrameOffset:8;      // frame start offset inside ASIC TXFIFO (after TXINFO field)
+	ULONG       PktId:8;            // driver assigned packet ID to categorize TXResult in TxDoneInterrupt
+	ULONG       BbpTxPower:8;
+	ULONG       bWaitingDmaDoneInt:1; // pure s/w flag. 1:TXD been filled with data and waiting for TxDoneISR for housekeeping
+	ULONG       Reserved:7;
+
+	// the above 24-byte is called TXINFO and will be DMAed to MAC block through TXFIFO.
+	// MAC block use this TXINFO to control the transmission behavior of this frame.
+
+	// The following fields are not used by MAC block. They are used by DMA block and HOST
+	// driver only. Once a frame has been DMA to ASIC, all the following fields are useless
+	// to ASIC.
+}	TXD_STRUC, *PTXD_STRUC;
+#endif
+
+//
+// Rx descriptor format, Rx	Ring
+//
+#ifdef BIG_ENDIAN
+typedef	struct	_RXD_STRUC	{
+	//Word 0
+	ULONG		Rsv3;	// BufPhyAddr;
+
+	//Word 1
+	ULONG		Rsv2;
+
+	//Word 2
+	ULONG		Iv;                 // received IV if originally encrypted; for replay attack checking
+
+	//Word 3
+	ULONG		Rsv1:1;
+	ULONG		FrameOffset:7;
+	ULONG		Rsv0:8;
+	ULONG		PlcpRssi:8;         // RSSI reported by BBP
+	ULONG		PlcpSignal:8;       // RX raw data rate reported by BBP
+
+	//Word 4
+	ULONG		CipherAlg:3;
+	ULONG		Rsv:1;
+	ULONG		DataByteCnt:12;
+	ULONG		KeyIndex:6;         // decryption key actually used
+	ULONG		CipherErr:2;        // 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
+//	ULONG		PhyErr:1;           // 1: this frame is received with PHY error
+	ULONG		Ofdm:1;             // 1: this frame is received in OFDM rate
+	ULONG		Crc:1;              // 1: CRC error
+	ULONG		MyBss:1;            // 1: this frame belongs to the same BSSID
+	ULONG		Bcast:1;            // 1: this is a broadcast frame
+	ULONG		Mcast:1;            // 1: this is a multicast frame
+	ULONG		U2M:1;              // 1: this RX frame is unicast to me
+	ULONG		Drop:1;             // 1: drop without receiving to HOST
+	ULONG		Owner:1;            // 1: owned by ASIC, 0: owned by HOST driver
+
+}	RXD_STRUC, *PRXD_STRUC;
+#else
+typedef	struct	_RXD_STRUC	{
+	// Word	0
+	ULONG		Owner:1;            // 1: owned by ASIC, 0: owned by HOST driver
+	ULONG       Drop:1;             // 1: drop without receiving to HOST
+	ULONG		U2M:1;              // 1: this RX frame is unicast to me
+	ULONG		Mcast:1;            // 1: this is a multicast frame
+	ULONG		Bcast:1;            // 1: this is a broadcast frame
+	ULONG		MyBss:1;            // 1: this frame belongs to the same BSSID
+	ULONG		Crc:1;              // 1: CRC error
+	ULONG		Ofdm:1;             // 1: this frame is received in OFDM rate
+//	ULONG		PhyErr:1;           // 1: this frame is received with PHY error
+	ULONG		CipherErr:2;        // 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
+	ULONG       KeyIndex:6;         // decryption key actually used
+	ULONG		DataByteCnt:12;
+	ULONG       Rsv:1;
+	ULONG       CipherAlg:3;
+
+	// word 1
+	ULONG       PlcpSignal:8;       // RX raw data rate reported by BBP
+	ULONG       PlcpRssi:8;         // RSSI reported by BBP
+	ULONG       Rsv0:8;
+	ULONG       FrameOffset:7;
+	ULONG       Rsv1:1;
+
+	// Word	2
+	ULONG       Iv;                 // received IV if originally encrypted; for replay attack checking
+
+	// Word 3
+	ULONG       Eiv;                // received EIV if originally encrypted; for replay attack checking
+
+	// word 4
+	ULONG       Rsv2;
+
+	// The above 20-byte is called RXINFO and is prepared by MAC RX block and passed
+	// the HOST driver.
+
+	// The following fields are for DMA block and HOST usage only. Can't be touched
+	// by ASIC MAC block.
+
+	// Word	5
+	ULONG		Rsv3;	// BufPhyAddr;
+#if 0
+	// Word	6~15
+	ULONG       Rsv3;
+	ULONG       Rsv4;
+	ULONG       Rsv5;
+	ULONG       Rsv6;
+	ULONG       Rsv7;
+	ULONG       Rsv8;
+	ULONG       Rsv9;
+	ULONG       Rsv10;
+	ULONG       Rsv11;
+	ULONG       Rsv12;
+#endif
+}	RXD_STRUC, *PRXD_STRUC;
+#endif
+
+// =================================================================================
+// HOST-MCU communication data structure
+// =================================================================================
+
+//
+// H2M_MAILBOX_CSR: Host-to-MCU Mailbox
+//
+#ifdef BIG_ENDIAN
+typedef union  _H2M_MAILBOX_STRUC {
+	struct {
+		ULONG       Owner:8;
+		ULONG       CmdToken:8;    // 0xff tells MCU not to report CmdDoneInt after excuting the command
+		ULONG       HighByte:8;
+		ULONG       LowByte:8;
+	}   field;
+	ULONG           word;
+} H2M_MAILBOX_STRUC, *PH2M_MAILBOX_STRUC;
+#else
+typedef union  _H2M_MAILBOX_STRUC {
+	struct {
+		ULONG       LowByte:8;
+		ULONG       HighByte:8;
+		ULONG       CmdToken:8;
+		ULONG       Owner:8;
+	}   field;
+	ULONG           word;
+} H2M_MAILBOX_STRUC, *PH2M_MAILBOX_STRUC;
+#endif
+
+//
+// M2H_CMD_DONE_CSR: MCU-to-Host command complete indication
+//
+#ifdef BIG_ENDIAN
+typedef union _M2H_CMD_DONE_STRUC {
+	struct  {
+		ULONG       CmdToken3;
+		ULONG       CmdToken2;
+		ULONG       CmdToken1;
+		ULONG       CmdToken0;
+	} field;
+	ULONG           word;
+} M2H_CMD_DONE_STRUC, *PM2H_CMD_DONE_STRUC;
+#else
+typedef union _M2H_CMD_DONE_STRUC {
+	struct  {
+		ULONG       CmdToken0;
+		ULONG       CmdToken1;
+		ULONG       CmdToken2;
+		ULONG       CmdToken3;
+	} field;
+	ULONG           word;
+} M2H_CMD_DONE_STRUC, *PM2H_CMD_DONE_STRUC;
+#endif
+
+//
+// MCU_INT_SOURCE_CSR, MCU_INT_MASK_CSR: MCU interrupt source/mask register
+//
+#ifdef BIG_ENDIAN
+typedef union _MCU_INT_SOURCE_STRUC {
+	struct {
+		ULONG       :22;
+		ULONG       TBTTExpire:1;
+		ULONG       Twakeup:1;
+		ULONG       McuInt7:1;
+		ULONG       McuInt6:1;
+		ULONG       McuInt5:1;
+		ULONG       McuInt4:1;
+		ULONG       McuInt3:1;
+		ULONG       McuInt2:1;
+		ULONG       McuInt1:1;
+		ULONG       McuInt0:1;
+	} field;
+	ULONG           word;
+} MCU_INT_SOURCE_STRUC, *PMCU_INT_SOURCE_STRUC, MCU_INT_MASK_STRUC, *PMCU_INT_MASK_STRUC;
+#else
+typedef union _MCU_INT_SOURCE_STRUC {
+	struct {
+		ULONG       McuInt0:1;
+		ULONG       McuInt1:1;
+		ULONG       McuInt2:1;
+		ULONG       McuInt3:1;
+		ULONG       McuInt4:1;
+		ULONG       McuInt5:1;
+		ULONG       McuInt6:1;
+		ULONG       McuInt7:1;
+		ULONG       Twakeup:1;
+		ULONG       TBTTExpire:1;
+		ULONG       :22;
+	} field;
+	ULONG           word;
+} MCU_INT_SOURCE_STRUC, *PMCU_INT_SOURCE_STRUC, MCU_INT_MASK_STRUC, *PMCU_INT_MASK_STRUC;
+#endif
+
+
+//
+// MCU_LEDCS: MCU LED Control Setting.
+//
+#ifdef BIG_ENDIAN
+typedef union  _MCU_LEDCS_STRUC {
+	struct	{
+		USHORT		PolarityRDY_A:1;
+		USHORT		PolarityRDY_G:1;
+		USHORT		PolarityACT:1;
+		USHORT		PolarityGPIO_4:1;
+		USHORT		PolarityGPIO_3:1;
+		USHORT		PolarityGPIO_2:1;
+		USHORT		PolarityGPIO_1:1;
+		USHORT		PolarityGPIO_0:1;
+		USHORT		LinkAStatus:1;
+		USHORT		LinkGStatus:1;
+		USHORT		RadioStatus:1;
+		USHORT		LedMode:5;
+	} field;
+	USHORT			word;
+} MCU_LEDCS_STRUC, *PMCU_LEDCS_STRUC;
+#else
+typedef union  _MCU_LEDCS_STRUC {
+	struct	{
+		USHORT		LedMode:5;
+		USHORT		RadioStatus:1;
+		USHORT		LinkGStatus:1;
+		USHORT		LinkAStatus:1;
+		USHORT		PolarityGPIO_0:1;
+		USHORT		PolarityGPIO_1:1;
+		USHORT		PolarityGPIO_2:1;
+		USHORT		PolarityGPIO_3:1;
+		USHORT		PolarityGPIO_4:1;
+		USHORT		PolarityACT:1;
+		USHORT		PolarityRDY_G:1;
+		USHORT		PolarityRDY_A:1;
+	} field;
+	USHORT			word;
+} MCU_LEDCS_STRUC, *PMCU_LEDCS_STRUC;
+#endif
+
+// =================================================================================
+// Register format
+// =================================================================================
+
+//
+// MAC_CSR1: System control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR1_STRUC	{
+	struct	{
+		ULONG		Rsvd1:29;
+		ULONG		HostReady:1;		// Host is ready after initialization, 1: ready
+		ULONG		BbpReset:1;			// Hardware reset BBP
+		ULONG		SoftReset:1;		// Software reset bit, 1: reset, 0: normal
+	}	field;
+	ULONG			word;
+}	MAC_CSR1_STRUC, *PMAC_CSR1_STRUC;
+#else
+typedef	union	_MAC_CSR1_STRUC	{
+	struct	{
+		ULONG		SoftReset:1;		// Software reset bit, 1: reset, 0: normal
+		ULONG		BbpReset:1;			// Hardware reset BBP
+		ULONG		HostReady:1;		// Host is ready after initialization, 1: ready
+		ULONG		Rsvd1:29;
+	}	field;
+	ULONG			word;
+}	MAC_CSR1_STRUC, *PMAC_CSR1_STRUC;
+#endif
+
+//
+// MAC_CSR2: STA MAC register 0
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR2_STRUC	{
+	struct	{
+		UCHAR		Byte3;		// MAC address byte 3
+		UCHAR		Byte2;		// MAC address byte 2
+		UCHAR		Byte1;		// MAC address byte 1
+		UCHAR		Byte0;		// MAC address byte 0
+	}	field;
+	ULONG			word;
+}	MAC_CSR2_STRUC, *PMAC_CSR2_STRUC;
+#else
+typedef	union	_MAC_CSR2_STRUC	{
+	struct	{
+		UCHAR		Byte0;		// MAC address byte 0
+		UCHAR		Byte1;		// MAC address byte 1
+		UCHAR		Byte2;		// MAC address byte 2
+		UCHAR		Byte3;		// MAC address byte 3
+	}	field;
+	ULONG			word;
+}	MAC_CSR2_STRUC, *PMAC_CSR2_STRUC;
+#endif
+
+//
+// MAC_CSR3: STA MAC register 1
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR3_STRUC	{
+	struct	{
+		UCHAR		Rsvd1;
+		UCHAR		U2MeMask;
+		UCHAR		Byte5;		// MAC address byte 5
+		UCHAR		Byte4;		// MAC address byte 4
+	}	field;
+	ULONG			word;
+}	MAC_CSR3_STRUC, *PMAC_CSR3_STRUC;
+#else
+typedef	union	_MAC_CSR3_STRUC	{
+	struct	{
+		UCHAR		Byte4;		// MAC address byte 4
+		UCHAR		Byte5;		// MAC address byte 5
+		UCHAR		U2MeMask;
+		UCHAR		Rsvd1;
+	}	field;
+	ULONG			word;
+}	MAC_CSR3_STRUC, *PMAC_CSR3_STRUC;
+#endif
+
+//
+// MAC_CSR4: BSSID register 0
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR4_STRUC	{
+	struct	{
+		UCHAR		Byte3;		// BSSID byte 3
+		UCHAR		Byte2;		// BSSID byte 2
+		UCHAR		Byte1;		// BSSID byte 1
+		UCHAR		Byte0;		// BSSID byte 0
+	}	field;
+	ULONG			word;
+}	MAC_CSR4_STRUC, *PMAC_CSR4_STRUC;
+#else
+typedef	union	_MAC_CSR4_STRUC	{
+	struct	{
+		UCHAR		Byte0;		// BSSID byte 0
+		UCHAR		Byte1;		// BSSID byte 1
+		UCHAR		Byte2;		// BSSID byte 2
+		UCHAR		Byte3;		// BSSID byte 3
+	}	field;
+	ULONG			word;
+}	MAC_CSR4_STRUC, *PMAC_CSR4_STRUC;
+#endif
+
+//
+// MAC_CSR5: BSSID register 1
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR5_STRUC	{
+	struct	{
+		USHORT		Rsvd:14;
+		USHORT		BssIdMask:2; // 11: one BSSID, 00: 4 BSSID, 10 or 01: 2 BSSID
+		UCHAR		Byte5;		 // BSSID byte 5
+		UCHAR		Byte4;		 // BSSID byte 4
+	}	field;
+	ULONG			word;
+}	MAC_CSR5_STRUC, *PMAC_CSR5_STRUC;
+#else
+typedef	union	_MAC_CSR5_STRUC	{
+	struct	{
+		UCHAR		Byte4;		 // BSSID byte 4
+		UCHAR		Byte5;		 // BSSID byte 5
+		USHORT      BssIdMask:2; // 11: one BSSID, 00: 4 BSSID, 10 or 01: 2 BSSID
+		USHORT		Rsvd:14;
+	}	field;
+	ULONG			word;
+}	MAC_CSR5_STRUC, *PMAC_CSR5_STRUC;
+#endif
+
+//
+// MAC_CSR8: SIFS/EIFS register
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR8_STRUC	{
+	struct	{
+		USHORT		Eifs;               // in unit of 1-us
+		UCHAR       SifsAfterRxOfdm;    // in unit of 1-us
+		UCHAR		Sifs;               // in unit of 1-us
+	}	field;
+	ULONG			word;
+}	MAC_CSR8_STRUC, *PMAC_CSR8_STRUC;
+#else
+typedef	union	_MAC_CSR8_STRUC	{
+	struct	{
+		UCHAR		Sifs;               // in unit of 1-us
+		UCHAR       SifsAfterRxOfdm;    // in unit of 1-us
+		USHORT		Eifs;               // in unit of 1-us
+	}	field;
+	ULONG			word;
+}	MAC_CSR8_STRUC, *PMAC_CSR8_STRUC;
+#endif
+
+//
+// MAC_CSR9: Back-Off control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR9_STRUC	{
+	struct {
+		ULONG		Rsvd:15;
+		ULONG       CWSelect:1;     // 1: CWmin/Cwmax select from register, 0:select from TxD
+		ULONG		CWMax:4;		// Bit for Cwmax, default Cwmax is 1023 (2^10 - 1).
+		ULONG		CWMin:4;		// Bit for Cwmin. default Cwmin is 31 (2^5 - 1).
+		ULONG		SlotTime:8;		// Slot time, default is 20us for 802.11B
+	}	field;
+	ULONG			word;
+}	MAC_CSR9_STRUC, *PMAC_CSR9_STRUC;
+#else
+typedef	union	_MAC_CSR9_STRUC	{
+	struct {
+		ULONG		SlotTime:8;		// Slot time, default is 20us for 802.11B
+		ULONG		CWMin:4;		// Bit for Cwmin. default Cwmin is 31 (2^5 - 1).
+		ULONG		CWMax:4;		// Bit for Cwmax, default Cwmax is 1023 (2^10 - 1).
+		ULONG       CWSelect:1;     // 1: CWmin/Cwmax select from register, 0:select from TxD
+		ULONG		Rsvd:15;
+	}	field;
+	ULONG			word;
+}	MAC_CSR9_STRUC, *PMAC_CSR9_STRUC;
+#endif
+
+//
+// MAC_CSR11: Power saving transition time register
+//
+#ifdef BG_ENDIAN
+typedef union _MAC_CSR11_STRUC {
+	struct {
+		ULONG       :12;
+		ULONG       Sleep2AwakeLatency:4;              // in unit of 1-TU
+		ULONG       bAutoWakeupEnable:1;
+		ULONG		NumOfTBTTBeforeWakeup:7;           // Number of beacon before wakeup
+		ULONG		DelayAfterLastTBTTBeforeWakeup:8;  // Delay after Tbcn expired in units of 1-TU
+	} field;
+	ULONG   word;
+} MAC_CSR11_STRUC, *PMAC_CSR11_STRUC;
+#else
+typedef union _MAC_CSR11_STRUC {
+	struct {
+		ULONG		DelayAfterLastTBTTBeforeWakeup:8;  // Delay after Tbcn expired in units of 1-TU
+		ULONG		NumOfTBTTBeforeWakeup:7;           // Number of beacon before wakeup
+		ULONG       bAutoWakeupEnable:1;
+		ULONG       Sleep2AwakeLatency:4;              // in unit of 1-TU
+		ULONG       :12;
+	} field;
+	ULONG   word;
+} MAC_CSR11_STRUC, *PMAC_CSR11_STRUC;
+#endif
+
+//
+// MAC_CSR12: Manual power control / status register (merge CSR20 & PWRCSR1)
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR12_STRUC	{
+	struct	{
+		ULONG		:28;
+		ULONG		BbpRfStatus:1;			// 0: not ready, 1:ready
+		ULONG       ForceWakeup:1;          // ForceWake has high privilege than PutToSleep when both set
+		ULONG       PutToSleep:1;
+		ULONG		CurrentPowerState:1;	// 0:sleep, 1:awake
+	}	field;
+	ULONG			word;
+}	PMAC_CSR12_STRUC, *PMAC_CSR12_STRUC;
+#else
+typedef	union	_MAC_CSR12_STRUC	{
+	struct	{
+		ULONG		CurrentPowerState:1;	// 0:sleep, 1:awake
+		ULONG       PutToSleep:1;
+		ULONG       ForceWakeup:1;          // ForceWake has high privilege than PutToSleep when both set
+		ULONG		BbpRfStatus:1;			// 0: not ready, 1:ready
+		ULONG		:28;
+	}	field;
+	ULONG			word;
+}	MAC_CSR12_STRUC, *PMAC_CSR12_STRUC;
+#endif
+
+//
+// MAC_CSR14: LED control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_MAC_CSR14_STRUC	{
+	struct	{
+		ULONG		:12;
+		ULONG       SwLed2:1;
+		ULONG       HwLedPolarity:1;    // 0: active low, 1: active high
+		ULONG		SwLed1:1;		    // s/w LED, 1: ON, 0: OFF
+		ULONG		HwLed:1;			// h/w TX activity, 1: normal OFF, blinking upon TX, 0: normal ON, blinking upon TX
+		ULONG		OffPeriod:8;		// Off period in unit of 1-ms, default 30ms
+		ULONG		OnPeriod:8;			// On period in unit of 1-ms, default 70ms
+	}	field;
+	ULONG			word;
+}	MAC_CSR14_STRUC, *PMAC_CSR14_STRUC;
+#else
+typedef	union	_MAC_CSR14_STRUC	{
+	struct	{
+		ULONG		OnPeriod:8;			// On period, default 70ms
+		ULONG		OffPeriod:8;		// Off period, default 30ms
+		ULONG		HwLed:1;			// h/w TX activity, 1: normal OFF, blinking upon TX, 0: normal ON, blinking upon TX
+		ULONG		SwLed1:1;		    // s/w LED, 1: ON, 0: OFF
+		ULONG       HwLedPolarity:1;    // 0: active low, 1: active high
+		ULONG       SwLed2:1;
+		ULONG		:12;
+	}	field;
+	ULONG			word;
+}	MAC_CSR14_STRUC, *PMAC_CSR14_STRUC;
+#endif
+
+//
+// TXRX_CSR0: TX/RX configuration register
+//
+#ifdef BIG_ENDIAN
+typedef	union	TXRX_CSR0_STRUC	{
+	struct	{
+		ULONG		:5;
+		ULONG       TxWithoutWaitingSBox:1;
+		ULONG       DropAckCts:1;       // 1: drop received ACK and CTS
+		ULONG		DropBcast:1;		// Drop broadcast frames
+		ULONG		DropMcast:1;		// Drop multicast frames
+		ULONG		DropVerErr:1;	    // Drop version error frame
+		ULONG		DropToDs:1;			// Drop fram ToDs bit is true
+		ULONG		DropNotToMe:1;		// Drop not to me unicast frame
+		ULONG		DropControl:1;		// Drop control frame
+		ULONG		DropPhyErr:1;		// Drop physical error
+		ULONG		DropCRCErr:1;		// Drop CRC error
+		ULONG		DisableRx:1;		// Disable Rx engine
+		ULONG       AutoTxSeq:1;        // 1: ASIC auto replace sequence# in outgoing frame
+		ULONG       TsfOffset:6;        // default is 24
+		ULONG       RxAckTimeout:9;
+	}	field;
+	ULONG			word;
+}	TXRX_CSR0_STRUC, *PTXRX_CSR0_STRUC;
+#else
+typedef	union	_TXRX_CSR0_STRUC	{
+	struct	{
+		ULONG       RxAckTimeout:9;
+		ULONG       TsfOffset:6;        // default is 24
+		ULONG       AutoTxSeq:1;        // 1: ASIC auto replace sequence# in outgoing frame
+		ULONG		DisableRx:1;		// Disable Rx engine
+		ULONG		DropCRCErr:1;		// Drop CRC error
+		ULONG		DropPhyErr:1;		// Drop physical error
+		ULONG		DropControl:1;		// Drop control frame
+		ULONG		DropNotToMe:1;		// Drop not to me unicast frame
+		ULONG		DropToDs:1;			// Drop fram ToDs bit is true
+		ULONG		DropVerErr:1;	    // Drop version error frame
+		ULONG		DropMcast:1;		// Drop multicast frames
+		ULONG		DropBcast:1;		// Drop broadcast frames
+		ULONG       DropAckCts:1;       // 1: drop received ACK and CTS
+		ULONG       TxWithoutWaitingSBox:1;
+		ULONG		:5;
+	}	field;
+	ULONG			word;
+}	TXRX_CSR0_STRUC, *PTXRX_CSR0_STRUC;
+#endif
+
+//
+// TXRX_CSR4: Auto-Responder/Tx-retry register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_TXRX_CSR4_STRUC	{
+	struct	{
+		ULONG       ShortRetryLimit:4;
+		ULONG       LongRetryLimit:4;
+		ULONG		Rsv1:1;
+		ULONG		OfdmTxFallbacktoCCK:1;      // 0: Fallbackt o OFDM 6M oly, 1: Fallback to CCK 1M,2M
+		ULONG       OfdmTxRateDownStep:2;       // 0:1-step, 1: 2-step, 2:3-step, 3:4-step
+		ULONG       OfdmTxRateDownEnable:1;     // 1:enable
+		ULONG       AutoResponderPreamble:1;    // 0:long, 1:short preamble
+		ULONG       AutoResponderEnable:1;
+		ULONG       AckCtsPsmBit:1;
+		ULONG       Rsv2:5;
+		ULONG       CntlFrameAckPolicy:3;
+		ULONG       TxAckTimeout:8;
+	}	field;
+	ULONG			word;
+}	TXRX_CSR4_STRUC, *PTXRX_CSR4_STRUC;
+#else
+typedef	union	_TXRX_CSR4_STRUC	{
+	struct	{
+		ULONG       TxAckTimeout:8;
+		ULONG       CntlFrameAckPolicy:3;
+		ULONG       Rsv2:5;
+		ULONG       AckCtsPsmBit:1;
+		ULONG       AutoResponderEnable:1;
+		ULONG       AutoResponderPreamble:1;    // 0:long, 1:short preamble
+		ULONG       OfdmTxRateDownEnable:1;     // 1:enable
+		ULONG       OfdmTxRateDownStep:2;       // 0:1-step, 1: 2-step, 2:3-step, 3:4-step
+		ULONG		OfdmTxFallbacktoCCK:1;      // 0: Fallbackt o OFDM 6M oly, 1: Fallback to CCK 1M,2M
+		ULONG		Rsv1:1;
+		ULONG       LongRetryLimit:4;
+		ULONG       ShortRetryLimit:4;
+	}	field;
+	ULONG			word;
+}	TXRX_CSR4_STRUC, *PTXRX_CSR4_STRUC;
+#endif
+
+//
+// TXRX_CSR9: Synchronization control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_TXRX_CSR9_STRUC	{
+	struct	{
+		ULONG		TxTimestampCompensate:8;
+		ULONG       :3;
+		ULONG		bBeaconGen:1;		// Enable beacon generator
+		ULONG       bTBTTEnable:1;
+		ULONG		TsfSyncMode:2;		// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+		ULONG		bTsfTicking:1;		// Enable TSF auto counting
+		ULONG       BeaconInterval:16;  // in unit of 1/16 TU
+	}	field;
+	ULONG			word;
+}	TXRX_CSR9_STRUC, *PTXRX_CSR9_STRUC;
+#else
+typedef	union	_TXRX_CSR9_STRUC	{
+	struct	{
+		ULONG       BeaconInterval:16;  // in unit of 1/16 TU
+		ULONG		bTsfTicking:1;		// Enable TSF auto counting
+		ULONG		TsfSyncMode:2;		// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+		ULONG       bTBTTEnable:1;
+		ULONG		bBeaconGen:1;		// Enable beacon generator
+		ULONG       :3;
+		ULONG		TxTimestampCompensate:8;
+	}	field;
+	ULONG			word;
+}	TXRX_CSR9_STRUC, *PTXRX_CSR9_STRUC;
+#endif
+
+//
+// PHY_CSR3: BBP serial control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_PHY_CSR3_STRUC	{
+	struct	{
+		ULONG		:15;
+		ULONG		Busy:1;				// 1: ASIC is busy execute BBP programming.
+		ULONG		fRead:1;		    // 0: Write	BBP, 1:	Read BBP
+		ULONG		RegNum:7;			// Selected	BBP	register
+		ULONG		Value:8;			// Register	value to program into BBP
+	}	field;
+	ULONG			word;
+}	PHY_CSR3_STRUC, *PPHY_CSR3_STRUC;
+#else
+typedef	union	_PHY_CSR3_STRUC	{
+	struct	{
+		ULONG		Value:8;			// Register	value to program into BBP
+		ULONG		RegNum:7;			// Selected	BBP	register
+		ULONG		fRead:1;		    // 0: Write	BBP, 1:	Read BBP
+		ULONG		Busy:1;				// 1: ASIC is busy execute BBP programming.
+		ULONG		:15;
+	}	field;
+	ULONG			word;
+}	PHY_CSR3_STRUC, *PPHY_CSR3_STRUC;
+#endif
+
+//
+// PHY_CSR4: RF serial control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_PHY_CSR4_STRUC	{
+	struct	{
+		ULONG		Busy:1;				// 1: ASIC is busy execute RF programming.
+		ULONG		PLL_LD:1;			// RF PLL_LD status
+		ULONG		IFSelect:1;			// 1: select IF	to program,	0: select RF to	program
+		ULONG		NumberOfBits:5;		// Number of bits used in RFRegValue (I:20,	RFMD:22)
+		ULONG		RFRegValue:24;		// Register	value (include register	id)	serial out to RF/IF	chip.
+	}	field;
+	ULONG			word;
+}	PHY_CSR4_STRUC, *PPHY_CSR4_STRUC;
+#else
+typedef	union	_PHY_CSR4_STRUC	{
+	struct	{
+		ULONG		RFRegValue:24;		// Register	value (include register	id)	serial out to RF/IF	chip.
+		ULONG		NumberOfBits:5;		// Number of bits used in RFRegValue (I:20,	RFMD:22)
+		ULONG		IFSelect:1;			// 1: select IF	to program,	0: select RF to	program
+		ULONG		PLL_LD:1;			// RF PLL_LD status
+		ULONG		Busy:1;				// 1: ASIC is busy execute RF programming.
+	}	field;
+	ULONG			word;
+}	PHY_CSR4_STRUC, *PPHY_CSR4_STRUC;
+#endif
+
+//
+// SEC_CSR1: shared key table security mode register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_SEC_CSR1_STRUC	{
+	struct	{
+		ULONG       :1;
+		ULONG       Bss1Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key0CipherAlg:3;
+	}	field;
+	ULONG			word;
+}	SEC_CSR1_STRUC, *PSEC_CSR1_STRUC;
+#else
+typedef	union	_SEC_CSR1_STRUC	{
+	struct	{
+		ULONG       Bss0Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss0Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss1Key3CipherAlg:3;
+		ULONG       :1;
+	}	field;
+	ULONG			word;
+}	SEC_CSR1_STRUC, *PSEC_CSR1_STRUC;
+#endif
+
+//
+// SEC_CSR5: shared key table security mode register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_SEC_CSR5_STRUC	{
+	struct	{
+		ULONG       :1;
+		ULONG       Bss3Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key0CipherAlg:3;
+	}	field;
+	ULONG			word;
+}	SEC_CSR5_STRUC, *PSEC_CSR5_STRUC;
+#else
+typedef	union	_SEC_CSR5_STRUC	{
+	struct	{
+		ULONG       Bss2Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss2Key3CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key0CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key1CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key2CipherAlg:3;
+		ULONG       :1;
+		ULONG       Bss3Key3CipherAlg:3;
+		ULONG       :1;
+	}	field;
+	ULONG			word;
+}	SEC_CSR5_STRUC, *PSEC_CSR5_STRUC;
+#endif
+
+//
+// STA_CSR0: RX PLCP error count & RX CRC error count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR0_STRUC	{
+	struct	{
+		USHORT  PlcpErr;
+		USHORT  CrcErr;
+	}	field;
+	ULONG			word;
+}	STA_CSR0_STRUC, *PSTA_CSR0_STRUC;
+#else
+typedef	union	_STA_CSR0_STRUC	{
+	struct	{
+		USHORT  CrcErr;
+		USHORT  PlcpErr;
+	}	field;
+	ULONG			word;
+}	STA_CSR0_STRUC, *PSTA_CSR0_STRUC;
+#endif
+
+//
+// STA_CSR1: RX False CCA count & RX LONG frame count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR1_STRUC	{
+	struct	{
+		USHORT  FalseCca;
+		USHORT  PhyErr;
+	}	field;
+	ULONG			word;
+}	STA_CSR1_STRUC, *PSTA_CSR1_STRUC;
+#else
+typedef	union	_STA_CSR1_STRUC	{
+	struct	{
+		USHORT  PhyErr;
+		USHORT  FalseCca;
+	}	field;
+	ULONG			word;
+}	STA_CSR1_STRUC, *PSTA_CSR1_STRUC;
+#endif
+
+//
+// STA_CSR2: TX Beacon count and RX FIFO overflow count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR2_STRUC	{
+	struct	{
+		USHORT  RxOverflowCount;
+		USHORT  RxFifoOverflowCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR2_STRUC, *PSTA_CSR2_STRUC;
+#else
+typedef	union	_STA_CSR2_STRUC	{
+	struct	{
+		USHORT  RxFifoOverflowCount;
+		USHORT  RxOverflowCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR2_STRUC, *PSTA_CSR2_STRUC;
+#endif
+
+//
+// STA_CSR3: TX Beacon count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR3_STRUC	{
+	struct	{
+		USHORT  Rsv;
+		USHORT  TxBeaconCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR3_STRUC, *PSTA_CSR3_STRUC;
+#else
+typedef	union	_STA_CSR3_STRUC	{
+	struct	{
+		USHORT  TxBeaconCount;
+		USHORT  Rsv;
+	}	field;
+	ULONG			word;
+}	STA_CSR3_STRUC, *PSTA_CSR3_STRUC;
+#endif
+
+//
+// STA_CSR4: TX Retry count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR4_STRUC	{
+	struct	{
+		USHORT  TxOneRetryCount;
+		USHORT  TxNoRetryCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR4_STRUC, *PSTA_CSR4_STRUC;
+#else
+typedef	union	_STA_CSR4_STRUC	{
+	struct	{
+		USHORT  TxNoRetryCount;
+		USHORT  TxOneRetryCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR4_STRUC, *PSTA_CSR4_STRUC;
+#endif
+
+
+//
+// STA_CSR5: TX Retry count
+//
+#ifdef BIG_ENDIAN
+typedef	union	_STA_CSR5_STRUC	{
+	struct	{
+		USHORT  TxRetryFailCount;
+		USHORT  TxMultiRetryCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR5_STRUC, *PSTA_CSR5_STRUC;
+#else
+typedef	union	_STA_CSR5_STRUC	{
+	struct	{
+		USHORT  TxMultiRetryCount;
+		USHORT  TxRetryFailCount;
+	}	field;
+	ULONG			word;
+}	STA_CSR5_STRUC, *PSTA_CSR5_STRUC;
+#endif
+
+//
+// HOST_CMD_CSR: For HOST to interrupt embedded processor
+//
+#ifdef BIG_ENDIAN
+typedef	union	_HOST_CMD_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv:24;
+		ULONG   InterruptMcu:1;
+		ULONG   HostCommand:7;
+	}	field;
+	ULONG			word;
+}	HOST_CMD_CSR_STRUC, *PHOST_CMD_CSR_STRUC;
+#else
+typedef	union	_HOST_CMD_CSR_STRUC	{
+	struct	{
+		ULONG   HostCommand:7;
+		ULONG   InterruptMcu:1;
+		ULONG   Rsv:24;
+	}	field;
+	ULONG			word;
+}	HOST_CMD_CSR_STRUC, *PHOST_CMD_CSR_STRUC;
+#endif
+
+//
+// TX_RING_CSR0: TX Ring size for AC_BK, AC_BE, AC_VI, AC_VO
+//
+#ifdef BIG_ENDIAN
+typedef	union	_TX_RING_CSR0_STRUC	{
+	struct	{
+		UCHAR   Ac3Total;
+		UCHAR   Ac2Total;
+		UCHAR   Ac1Total;
+		UCHAR   Ac0Total;
+	}	field;
+	ULONG			word;
+}	TX_RING_CSR0_STRUC, *PTX_RING_CSR0_STRUC;
+#else
+typedef	union	_TX_RING_CSR0_STRUC	{
+	struct	{
+		UCHAR   Ac0Total;
+		UCHAR   Ac1Total;
+		UCHAR   Ac2Total;
+		UCHAR   Ac3Total;
+	}	field;
+	ULONG			word;
+}	TX_RING_CSR0_STRUC, *PTX_RING_CSR0_STRUC;
+#endif
+
+//
+// TX_RING_CSR1: TX Ring size for MGMT Ring, HCCA Ring
+//
+#ifdef BIG_ENDIAN
+typedef	union	_TX_RING_CSR1_STRUC	{
+	struct	{
+		ULONG   Rsv:10;
+		ULONG   TxdSize:6;      // in unit of 32-bit
+		ULONG   HccaTotal:8;
+		ULONG   MgmtTotal:8;
+	}	field;
+	ULONG			word;
+}	TX_RING_CSR1_STRUC, *PTX_RING_CSR1_STRUC;
+#else
+typedef	union	_TX_RING_CSR1_STRUC	{
+	struct	{
+		ULONG   MgmtTotal:8;
+		ULONG   HccaTotal:8;
+		ULONG   TxdSize:6;      // in unit of 32-bit
+		ULONG   Rsv:10;
+	}	field;
+	ULONG			word;
+}	TX_RING_CSR1_STRUC, *PTX_RING_CSR1_STRUC;
+#endif
+
+//
+// AIFSN_CSR: AIFSN for each EDCA AC
+//
+#ifdef BIG_ENDIAN
+typedef	union	_AIFSN_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv:16;
+		ULONG   Aifsn3:4;       // for AC_VO
+		ULONG   Aifsn2:4;       // for AC_VI
+		ULONG   Aifsn1:4;       // for AC_BK
+		ULONG   Aifsn0:4;       // for AC_BE
+	}	field;
+	ULONG			word;
+}	AIFSN_CSR_STRUC, *PAIFSN_CSR_STRUC;
+#else
+typedef	union	_AIFSN_CSR_STRUC	{
+	struct	{
+		ULONG   Aifsn0:4;       // for AC_BE
+		ULONG   Aifsn1:4;       // for AC_BK
+		ULONG   Aifsn2:4;       // for AC_VI
+		ULONG   Aifsn3:4;       // for AC_VO
+		ULONG   Rsv:16;
+	}	field;
+	ULONG			word;
+}	AIFSN_CSR_STRUC, *PAIFSN_CSR_STRUC;
+#endif
+
+//
+// CWMIN_CSR: CWmin for each EDCA AC
+//
+#ifdef BIG_ENDIAN
+typedef	union	_CWMIN_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv:16;
+		ULONG   Cwmin3:4;       // for AC_VO
+		ULONG   Cwmin2:4;       // for AC_VI
+		ULONG   Cwmin1:4;       // for AC_BK
+		ULONG   Cwmin0:4;       // for AC_BE
+	}	field;
+	ULONG			word;
+}	CWMIN_CSR_STRUC, *PCWMIN_CSR_STRUC;
+#else
+typedef	union	_CWMIN_CSR_STRUC	{
+	struct	{
+		ULONG   Cwmin0:4;       // for AC_BE
+		ULONG   Cwmin1:4;       // for AC_BK
+		ULONG   Cwmin2:4;       // for AC_VI
+		ULONG   Cwmin3:4;       // for AC_VO
+		ULONG   Rsv:16;
+	}	field;
+	ULONG			word;
+}	CWMIN_CSR_STRUC, *PCWMIN_CSR_STRUC;
+#endif
+
+//
+// CWMAX_CSR: CWmin for each EDCA AC
+//
+#ifdef BIG_ENDIAN
+typedef	union	_CWMAX_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv:16;
+		ULONG   Cwmax3:4;       // for AC_VO
+		ULONG   Cwmax2:4;       // for AC_VI
+		ULONG   Cwmax1:4;       // for AC_BK
+		ULONG   Cwmax0:4;       // for AC_BE
+	}	field;
+	ULONG			word;
+}	CWMAX_CSR_STRUC, *PCWMAX_CSR_STRUC;
+#else
+typedef	union	_CWMAX_CSR_STRUC	{
+	struct	{
+		ULONG   Cwmax0:4;       // for AC_BE
+		ULONG   Cwmax1:4;       // for AC_BK
+		ULONG   Cwmax2:4;       // for AC_VI
+		ULONG   Cwmax3:4;       // for AC_VO
+		ULONG   Rsv:16;
+	}	field;
+	ULONG			word;
+}	CWMAX_CSR_STRUC, *PCWMAX_CSR_STRUC;
+#endif
+
+//
+// TX_CNTL_CSR: KICK/Abort TX
+//
+#ifdef BIG_ENDIAN
+typedef	union	_TX_CNTL_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv1:11;
+		ULONG   AbortTxMgmt:1;
+		ULONG   AbortTxAc3:1;       // for AC_VO
+		ULONG   AbortTxAc2:1;       // for AC_VI
+		ULONG   AbortTxAc1:1;       // for AC_BE
+		ULONG   AbortTxAc0:1;       // for AC_BK
+		ULONG   Rsv2:11;
+		ULONG   KickTxMgmt:1;
+		ULONG   KickTxAc3:1;       // for AC_VO
+		ULONG   KickTxAc2:1;       // for AC_VI
+		ULONG   KickTxAc1:1;       // for AC_BE
+		ULONG   KickTxAc0:1;       // for AC_BK
+	}	field;
+	ULONG			word;
+}	TX_CNTL_CSR_STRUC, *PTX_CNTL_CSR_STRUC;
+#else
+typedef	union	_TX_CNTL_CSR_STRUC	{
+	struct	{
+		ULONG   KickTxAc0:1;       // for AC_BK
+		ULONG   KickTxAc1:1;       // for AC_BE
+		ULONG   KickTxAc2:1;       // for AC_VI
+		ULONG   KickTxAc3:1;       // for AC_VO
+		ULONG   KickTxMgmt:1;
+		ULONG   Rsv2:11;
+		ULONG   AbortTxAc0:1;       // for AC_BK
+		ULONG   AbortTxAc1:1;       // for AC_BE
+		ULONG   AbortTxAc2:1;       // for AC_VI
+		ULONG   AbortTxAc3:1;       // for AC_VO
+		ULONG   AbortTxMgmt:1;
+		ULONG   Rsv1:11;
+	}	field;
+	ULONG			word;
+}	TX_CNTL_CSR_STRUC, *PTX_CNTL_CSR_STRUC;
+#endif
+
+//
+// CWMAX_CSR: CWmin for each EDCA AC
+//
+#ifdef BIG_ENDIAN
+typedef	union	_RX_RING_CSR_STRUC	{
+	struct	{
+		ULONG   Rsv:13;
+		ULONG   RxdWritebackSize:3;
+		ULONG   :2;
+		ULONG   RxdSize:6;      // in unit of 32-bit
+		ULONG   RxRingTotal:8;
+	}	field;
+	ULONG			word;
+}	RX_RING_CSR_STRUC, *PRX_RING_CSR_STRUC;
+#else
+typedef	union	_RX_RING_CSR_STRUC	{
+	struct	{
+		ULONG   RxRingTotal:8;
+		ULONG   RxdSize:6;      // in unit of 32-bit
+		ULONG   :2;
+		ULONG   RxdWritebackSize:3;
+		ULONG   Rsv:13;
+	}	field;
+	ULONG			word;
+}	RX_RING_CSR_STRUC, *PRX_RING_CSR_STRUC;
+#endif
+
+//
+// INT_SOURCE_CSR: Interrupt source register. Write one to clear corresponding bit
+//
+#ifdef BIG_ENDIAN
+typedef	union	_INT_SOURCE_CSR_STRUC	{
+	struct	{
+		ULONG       :10;
+		ULONG       HccaDmaDone:1;
+		ULONG       MgmtDmaDone:1;
+		ULONG       Ac3DmaDone:1;
+		ULONG       Ac2DmaDone:1;
+		ULONG       Ac1DmaDone:1;
+		ULONG       Ac0DmaDone:1;
+		ULONG		:11;
+		ULONG       TxAbortDone:1;
+		ULONG       :1;
+		ULONG       BeaconTxDone:1;
+		ULONG		RxDone:1;
+		ULONG		TxDone:1;
+	}	field;
+	ULONG			word;
+}	INT_SOURCE_CSR_STRUC, *PINT_SOURCE_CSR_STRUC;
+#else
+typedef	union	_INT_SOURCE_CSR_STRUC	{
+	struct	{
+		ULONG		TxDone:1;
+		ULONG		RxDone:1;
+		ULONG       BeaconTxDone:1;
+		ULONG       :1;
+		ULONG       TxAbortDone:1;
+		ULONG		:11;
+		ULONG       Ac0DmaDone:1;
+		ULONG       Ac1DmaDone:1;
+		ULONG       Ac2DmaDone:1;
+		ULONG       Ac3DmaDone:1;
+		ULONG       MgmtDmaDone:1;
+		ULONG       HccaDmaDone:1;
+		ULONG       :10;
+	}	field;
+	ULONG			word;
+} INT_SOURCE_CSR_STRUC, *PINT_SOURCE_CSR_STRUC;
+#endif
+
+//
+// INT_MASK_CSR:   Interrupt MASK register.   1: the interrupt is mask OFF
+//
+#ifdef BIG_ENDIAN
+typedef	union	_INT_MASK_CSR_STRUC	{
+	struct	{
+		ULONG       :10;
+		ULONG       HccaDmaDone:1;
+		ULONG       MgmtDmaDone:1;
+		ULONG       Ac3DmaDone:1;
+		ULONG       Ac2DmaDone:1;
+		ULONG       Ac1DmaDone:1;
+		ULONG       Ac0DmaDone:1;
+		ULONG       MitigationPeriod:8; // interrupt mitigation in unit of 32 PCI clock
+		ULONG       bEnableMitigationPeriod:1;
+		ULONG		:2;
+		ULONG       TxAbortDone:1;
+		ULONG       :1;
+		ULONG       BeaconTxDone:1;
+		ULONG		RxDone:1;
+		ULONG		TxDone:1;
+	}	field;
+	ULONG			word;
+}INT_MASK_CSR_STRUC, *PINT_MASK_CSR_STRUC;
+#else
+typedef	union	_INT_MASK_CSR_STRUC	{
+	struct	{
+		ULONG		TxDone:1;
+		ULONG		RxDone:1;
+		ULONG       BeaconTxDone:1;
+		ULONG       :1;
+		ULONG       TxAbortDone:1;
+		ULONG		:2;
+		ULONG       bEnableMitigationPeriod:1;
+		ULONG       MitigationPeriod:8; // interrupt mitigation in unit of 32 PCI clock
+		ULONG       Ac0DmaDone:1;
+		ULONG       Ac1DmaDone:1;
+		ULONG       Ac2DmaDone:1;
+		ULONG       Ac3DmaDone:1;
+		ULONG       MgmtDmaDone:1;
+		ULONG       HccaDmaDone:1;
+		ULONG       :10;
+	}	field;
+	ULONG			word;
+} INT_MASK_CSR_STRUC, *PINT_MASK_CSR_STRUC;
+#endif
+//
+// E2PROM_CSR: EEPROM control register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_E2PROM_CSR_STRUC	{
+	struct	{
+		ULONG		Rsvd:25;
+		ULONG       LoadStatus:1;   // 1:loading, 0:done
+		ULONG		Type:1;			// 1: 93C46, 0:93C66
+		ULONG		EepromDO:1;
+		ULONG		EepromDI:1;
+		ULONG		EepromCS:1;
+		ULONG		EepromSK:1;
+		ULONG		Reload:1;		// Reload EEPROM content, write one to reload, self-cleared.
+	}	field;
+	ULONG			word;
+}	E2PROM_CSR_STRUC, *PE2PROM_CSR_STRUC;
+#else
+typedef	union	_E2PROM_CSR_STRUC	{
+	struct	{
+		ULONG		Reload:1;		// Reload EEPROM content, write one to reload, self-cleared.
+		ULONG		EepromSK:1;
+		ULONG		EepromCS:1;
+		ULONG		EepromDI:1;
+		ULONG		EepromDO:1;
+		ULONG		Type:1;			// 1: 93C46, 0:93C66
+		ULONG       LoadStatus:1;   // 1:loading, 0:done
+		ULONG		Rsvd:25;
+	}	field;
+	ULONG			word;
+}	E2PROM_CSR_STRUC, *PE2PROM_CSR_STRUC;
+#endif
+
+//
+// AC_TXOP_CSR0: AC_BK/AC_BE TXOP register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_AC_TXOP_CSR0_STRUC	{
+	struct	{
+		USHORT  Ac1Txop;        // for AC_BE, in unit of 32us
+		USHORT  Ac0Txop;        // for AC_BK, in unit of 32us
+	}	field;
+	ULONG			word;
+}	AC_TXOP_CSR0_STRUC, *PAC_TXOP_CSR0_STRUC;
+#else
+typedef	union	_AC_TXOP_CSR0_STRUC	{
+	struct	{
+		USHORT  Ac0Txop;        // for AC_BK, in unit of 32us
+		USHORT  Ac1Txop;        // for AC_BE, in unit of 32us
+	}	field;
+	ULONG			word;
+}	AC_TXOP_CSR0_STRUC, *PAC_TXOP_CSR0_STRUC;
+#endif
+
+//
+// AC_TXOP_CSR1: AC_VO/AC_VI TXOP register
+//
+#ifdef BIG_ENDIAN
+typedef	union	_AC_TXOP_CSR1_STRUC	{
+	struct	{
+		USHORT  Ac3Txop;        // for AC_VO, in unit of 32us
+		USHORT  Ac2Txop;        // for AC_VI, in unit of 32us
+	}	field;
+	ULONG			word;
+}	AC_TXOP_CSR1_STRUC, *PAC_TXOP_CSR1_STRUC;
+#else
+typedef	union	_AC_TXOP_CSR1_STRUC	{
+	struct	{
+		USHORT  Ac2Txop;        // for AC_VI, in unit of 32us
+		USHORT  Ac3Txop;        // for AC_VO, in unit of 32us
+	}	field;
+	ULONG			word;
+}	AC_TXOP_CSR1_STRUC, *PAC_TXOP_CSR1_STRUC;
+#endif
+
+
+// -------------------------------------------------------------------
+//  E2PROM data layout
+// -------------------------------------------------------------------
+
+//
+// EEPROM antenna select format
+//
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_ANTENNA_STRUC	{
+	struct	{
+		USHORT      RfIcType:5;             // see E2PROM document
+		USHORT		HardwareRadioControl:1;	// 1: Hardware controlled radio enabled, Read GPIO0 required.
+		USHORT      DynamicTxAgcControl:1;
+		USHORT		Rsv:2;
+		USHORT		FrameType:1;			// 0: DPDT , 1: SPDT , noted this bit is valid for g only.
+		USHORT		RxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT		TxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT		NumOfAntenna:2;			// Number of antenna
+	}	field;
+	USHORT			word;
+}	EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
+#else
+typedef	union	_EEPROM_ANTENNA_STRUC	{
+	struct	{
+		USHORT		NumOfAntenna:2;			// Number of antenna
+		USHORT		TxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT		RxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT		FrameType:1;			// 0: DPDT , 1: SPDT , noted this bit is valid for g only.
+		USHORT		Rsv:2;
+		USHORT      DynamicTxAgcControl:1;
+		USHORT		HardwareRadioControl:1;	// 1: Hardware controlled radio enabled, Read GPIO0 required.
+		USHORT      RfIcType:5;             // see E2PROM document
+	}	field;
+	USHORT			word;
+}	EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
+#endif
+
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_NIC_CINFIG2_STRUC	{
+	struct	{
+		USHORT      Rsv2:11;					// must be 0
+		USHORT		ExternalLNA:1;			// external LNA enable
+		USHORT		Rsv1:4;
+	}	field;
+	USHORT			word;
+}	EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
+#else
+typedef	union	_EEPROM_NIC_CINFIG2_STRUC	{
+	struct	{
+		USHORT		Rsv1:4;
+		USHORT		ExternalLNA:1;			// external LNA enable
+		USHORT      Rsv2:11;                 // must be 0
+	}	field;
+	USHORT			word;
+}	EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
+#endif
+
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_TX_PWR_STRUC	{
+	struct	{
+		UCHAR	Byte1;				// High Byte
+		UCHAR	Byte0;				// Low Byte
+	}	field;
+	USHORT	word;
+}	EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
+#else
+typedef	union	_EEPROM_TX_PWR_STRUC	{
+	struct	{
+		UCHAR	Byte0;				// Low Byte
+		UCHAR	Byte1;				// High Byte
+	}	field;
+	USHORT	word;
+}	EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
+#endif
+
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_VERSION_STRUC	{
+	struct	{
+		UCHAR	Version;			// High Byte
+		UCHAR	FaeReleaseNumber;	// Low Byte
+	}	field;
+	USHORT	word;
+}	EEPROM_VERSION_STRUC, *PEEPROM_VERSION_STRUC;
+#else
+typedef	union	_EEPROM_VERSION_STRUC	{
+	struct	{
+		UCHAR	FaeReleaseNumber;	// Low Byte
+		UCHAR	Version;			// High Byte
+	}	field;
+	USHORT	word;
+}	EEPROM_VERSION_STRUC, *PEEPROM_VERSION_STRUC;
+#endif
+
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_LED_STRUC	{
+	struct	{
+		USHORT	Rsvd:3;				// Reserved
+		USHORT	LedMode:5;			// Led mode.
+		USHORT	PolarityGPIO_4:1;	// Polarity GPIO#4 setting.
+		USHORT	PolarityGPIO_3:1;	// Polarity GPIO#3 setting.
+		USHORT	PolarityGPIO_2:1;	// Polarity GPIO#2 setting.
+		USHORT	PolarityGPIO_1:1;	// Polarity GPIO#1 setting.
+		USHORT	PolarityGPIO_0:1;	// Polarity GPIO#0 setting.
+		USHORT	PolarityACT:1;		// Polarity ACT setting.
+		USHORT	PolarityRDY_A:1;		// Polarity RDY_A setting.
+		USHORT	PolarityRDY_G:1;		// Polarity RDY_G setting.
+	}	field;
+	USHORT	word;
+}	EEPROM_LED_STRUC, *PEEPROM_LED_STRUC;
+#else
+typedef	union	_EEPROM_LED_STRUC	{
+	struct	{
+		USHORT	PolarityRDY_G:1;		// Polarity RDY_G setting.
+		USHORT	PolarityRDY_A:1;		// Polarity RDY_A setting.
+		USHORT	PolarityACT:1;		// Polarity ACT setting.
+		USHORT	PolarityGPIO_0:1;	// Polarity GPIO#0 setting.
+		USHORT	PolarityGPIO_1:1;	// Polarity GPIO#1 setting.
+		USHORT	PolarityGPIO_2:1;	// Polarity GPIO#2 setting.
+		USHORT	PolarityGPIO_3:1;	// Polarity GPIO#3 setting.
+		USHORT	PolarityGPIO_4:1;	// Polarity GPIO#4 setting.
+		USHORT	LedMode:5;			// Led mode.
+		USHORT	Rsvd:3;				// Reserved
+	}	field;
+	USHORT	word;
+}	EEPROM_LED_STRUC, *PEEPROM_LED_STRUC;
+#endif
+
+#ifdef BIG_ENDIAN
+typedef	union	_EEPROM_TXPOWER_DELTA_STRUC	{
+	struct	{
+		UCHAR	TxPowerEnable:1;// Enable
+		UCHAR	Type:1;			// 1: plus the delta value, 0: minus the delta value
+		UCHAR	DeltaValue:6;	// Tx Power dalta value (MAX=4)
+	}	field;
+	UCHAR	value;
+}	EEPROM_TXPOWER_DELTA_STRUC, *PEEPROM_TXPOWER_DELTA_STRUC;
+#else
+typedef	union	_EEPROM_TXPOWER_DELTA_STRUC	{
+	struct	{
+		UCHAR	DeltaValue:6;	// Tx Power dalta value (MAX=4)
+		UCHAR	Type:1;			// 1: plus the delta value, 0: minus the delta value
+		UCHAR	TxPowerEnable:1;// Enable
+	}	field;
+	UCHAR	value;
+}	EEPROM_TXPOWER_DELTA_STRUC, *PEEPROM_TXPOWER_DELTA_STRUC;
+#endif
+
+#ifndef _PRISMHEADER
+#define _PRISMHEADER
+
+enum {
+	DIDmsg_lnxind_wlansniffrm		= 0x00000044,
+	DIDmsg_lnxind_wlansniffrm_hosttime	= 0x00010044,
+	DIDmsg_lnxind_wlansniffrm_mactime	= 0x00020044,
+	DIDmsg_lnxind_wlansniffrm_channel	= 0x00030044,
+	DIDmsg_lnxind_wlansniffrm_rssi		= 0x00040044,
+	DIDmsg_lnxind_wlansniffrm_sq		= 0x00050044,
+	DIDmsg_lnxind_wlansniffrm_signal	= 0x00060044,
+	DIDmsg_lnxind_wlansniffrm_noise		= 0x00070044,
+	DIDmsg_lnxind_wlansniffrm_rate		= 0x00080044,
+	DIDmsg_lnxind_wlansniffrm_istx		= 0x00090044,
+	DIDmsg_lnxind_wlansniffrm_frmlen	= 0x000A0044
+};
+enum {
+	P80211ENUM_msgitem_status_no_value	= 0x00
+};
+enum {
+	P80211ENUM_truth_false			= 0x00,
+	P80211ENUM_truth_true			= 0x01
+};
+
+typedef struct {
+	u_int32_t did;
+	u_int16_t status;
+	u_int16_t len;
+	u_int32_t data;
+} p80211item_uint32_t;
+
+typedef struct {
+	u_int32_t msgcode;
+	u_int32_t msglen;
+#define WLAN_DEVNAMELEN_MAX 16
+	u_int8_t devname[WLAN_DEVNAMELEN_MAX];
+	p80211item_uint32_t hosttime;
+	p80211item_uint32_t mactime;
+	p80211item_uint32_t channel;
+	p80211item_uint32_t rssi;
+	p80211item_uint32_t sq;
+	p80211item_uint32_t signal;
+	p80211item_uint32_t noise;
+	p80211item_uint32_t rate;
+	p80211item_uint32_t istx;
+	p80211item_uint32_t frmlen;
+} wlan_ng_prism2_header;
+
+#endif
+
+#endif	// __RT73_H__
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rt_config.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt_config.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rt_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rt_config.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,275 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rt_config.h
+ *
+ *	Abstract: Central header file to maintain all include files for all
+ *		  driver routines.
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Nemo Tang	02-20-2005	created
+ *
+ ***************************************************************************/
+
+#ifndef	__RT_CONFIG_H__
+#define	__RT_CONFIG_H__
+
+#define PROFILE_PATH                "/etc/Wireless/RT73STA/rt73sta.dat"
+#define NIC_DEVICE_NAME             "RT73STA"
+#define RT2573_IMAGE_FILE_NAME      "rt73.bin"
+#define DRIVER_NAME                 "rt73"
+#define DRIVER_VERSION		    "1.0.3.6 CVS"
+#define DRIVER_RELDATE              "2007091001"
+
+// Query from UI
+#define DRV_MAJORVERSION        1
+#define DRV_MINORVERSION        0
+#define DRV_SUBVERSION          3
+#define DRV_TESTVERSION         6
+#define DRV_YEAR                2006
+#define DRV_MONTH               7
+#define DRV_DAY                 4
+
+/* Operational parameters that are set at compile time. */
+#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
+#warning  You must compile this file with the correct options!
+#warning  See the last lines of the source file.
+#error  You must compile this driver with "-O".
+#endif
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,25))	// N.A. earlier
+#include <linux/moduleparam.h>	// Only need to explicitly include
+#endif							// in early 2.6 series
+
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+//#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/wireless.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/if_arp.h>
+#include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/kmod.h>
+#include <linux/firmware.h>
+
+
+#include <linux/ioport.h>
+//usb header files
+#include <linux/usb.h>
+
+#if LINUX_VERSION_CODE >= 0x20407
+#include <linux/mii.h>
+#endif
+#include <asm/processor.h>      /* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <asm/byteorder.h>
+
+// load firmware
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <asm/uaccess.h>
+
+
+#ifndef ULONG
+#define CHAR            signed char
+#define INT             int
+#define SHORT           int
+#define UINT            u32
+#define ULONG           u32
+#define USHORT          u16
+#define UCHAR           u8
+
+#define uint32			u32
+#define uint8			u8
+
+
+#define BOOLEAN         u8
+//#define LARGE_INTEGER s64
+#define VOID            void
+#define LONG            int
+#define LONGLONG        s64
+#define ULONGLONG       u64
+typedef VOID            *PVOID;
+typedef CHAR            *PCHAR;
+typedef UCHAR           *PUCHAR;
+typedef USHORT          *PUSHORT;
+typedef LONG            *PLONG;
+typedef ULONG           *PULONG;
+
+typedef union _LARGE_INTEGER {
+    struct {
+        ULONG LowPart;
+        LONG HighPart;
+    }vv;
+    struct {
+        ULONG LowPart;
+        LONG HighPart;
+    } u;
+    s64 QuadPart;
+} LARGE_INTEGER;
+
+#endif
+
+
+#define IN
+#define OUT
+
+#define TRUE        1
+#define FALSE       0
+
+#define ETH_LENGTH_OF_ADDRESS   6       // = MAC_ADDR_LEN
+
+#define NDIS_STATUS                             INT
+#define NDIS_STATUS_SUCCESS                     0x00
+#define NDIS_STATUS_FAILURE                     0x01
+#define NDIS_STATUS_RESOURCES                   0x03
+#define NDIS_STATUS_MEDIA_DISCONNECT            0x04
+#define NDIS_STATUS_MEDIA_CONNECT               0x05
+#define NDIS_STATUS_RESET                       0x06
+#define NDIS_STATUS_RINGFULL                    0x07 /* Thomas add */
+
+
+// ** Wireless Extensions **
+// 1. wireless events support        : v14 or newer
+// 2. requirements of wpa-supplicant : v15 or newer
+#if WIRELESS_EXT >= 15
+#define WPA_SUPPLICANT_SUPPORT  1
+#else
+#define WPA_SUPPLICANT_SUPPORT  0
+#endif
+
+
+//
+//	Hradware related header files
+//
+#include	"rt73.h"
+
+//
+//	Miniport defined header files
+//
+#include	"rt2x00debug.h"
+#include	"rtmp_type.h"
+#include	"rtmp_def.h"
+#include    "oid.h"
+#include	"mlme.h"
+#include    "md5.h"
+#include    "wpa.h"
+#include	"rtmp.h"
+
+
+#define MEM_ALLOC_FLAG      (GFP_DMA | GFP_ATOMIC)
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a,b,c) ((a)*65536+(b)*256+(c))
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,29)
+static inline unsigned int jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+	return (1000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+	return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+	return (j * 1000) / HZ;
+#endif
+}
+
+static inline unsigned int jiffies_to_usecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+	return (1000000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+	return (j*1000 + (HZ - 1000))/(HZ / 1000);
+#else
+	return (j * 1000000) / HZ;
+#endif
+}
+
+static inline unsigned long msecs_to_jiffies(const unsigned int m)
+{
+	if (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+	return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+	return m * (HZ / 1000);
+#else
+	return (m * HZ + 999) / 1000;
+#endif
+}
+
+static inline void msleep(unsigned long msecs)
+{
+        set_current_state(TASK_UNINTERRUPTIBLE);
+        schedule_timeout(msecs_to_jiffies(msecs) + 1);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define rtusb_submit_urb(purb) usb_submit_urb(purb, GFP_KERNEL)
+#else
+#define rtusb_submit_urb(purb) usb_submit_urb(purb)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
+#define RTUSB_UNLINK_URB(urb)	usb_kill_urb(urb)
+#else
+#define RTUSB_UNLINK_URB(urb)	usb_unlink_urb(urb)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+#define skb_reset_mac_header(skb) (skb->mac.raw = skb->data)
+
+#define first_net_device()		dev_base
+#define next_net_device(device)	((device)->next)
+
+#endif
+
+#ifndef USB_ST_NOERROR
+#define  USB_ST_NOERROR     0
+#endif
+
+#define READ_PROFILE_FROM_FILE      //read RaConfig profile parameters from rt73sta.dat
+#define INIT_FROM_EEPROM
+
+
+#endif	// __RT_CONFIG_H__
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,3586 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	idamlaj		05-10-2006	Import rfmon implementation
+ *	idamlaj		14-10-2006	RFMonTx (based on MarkW's code)
+ *	RomainB     31-12-2206  RFMonTx getter
+ *
+ ***************************************************************************/
+
+#ifndef __RTMP_H__
+#define __RTMP_H__
+
+#include "mlme.h"
+#include "oid.h"
+#include "wpa.h"
+
+//
+// Extern
+//
+extern UCHAR BROADCAST_ADDR[MAC_ADDR_LEN];
+extern UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN];
+extern ULONG BIT32[32];
+extern UCHAR BIT8[8];
+extern char* CipherName[];
+
+extern UCHAR SNAP_802_1H[6];
+extern UCHAR SNAP_BRIDGE_TUNNEL[6];
+extern UCHAR EAPOL_LLC_SNAP[8];
+extern UCHAR EAPOL[2];
+extern UCHAR IPX[2];
+extern UCHAR APPLE_TALK[2];
+extern UCHAR RateIdToPlcpSignal[12]; // see IEEE802.11a-1999 p.14
+extern UCHAR OfdmSignalToRateId[16] ;
+extern UCHAR default_cwmin[4];
+extern UCHAR default_cwmax[4];
+extern UCHAR default_sta_aifsn[4];
+extern UCHAR MapUserPriorityToAccessCategory[8];
+
+extern UCHAR  Phy11BNextRateDownward[];
+extern UCHAR  Phy11BNextRateUpward[];
+extern UCHAR  Phy11BGNextRateDownward[];
+extern UCHAR  Phy11BGNextRateUpward[];
+extern UCHAR  Phy11ANextRateDownward[];
+extern UCHAR  Phy11ANextRateUpward[];
+extern CHAR   RssiSafeLevelForTxRate[];
+extern UCHAR  RateIdToMbps[];
+extern USHORT RateIdTo500Kbps[];
+
+extern UCHAR  CipherSuiteWpaNoneTkip[];
+extern UCHAR  CipherSuiteWpaNoneTkipLen;
+
+extern UCHAR  CipherSuiteWpaNoneAes[];
+extern UCHAR  CipherSuiteWpaNoneAesLen;
+
+extern UCHAR  SsidIe;
+extern UCHAR  SupRateIe;
+extern UCHAR  ExtRateIe;
+extern UCHAR  ErpIe;
+extern UCHAR  DsIe;
+extern UCHAR  TimIe;
+extern UCHAR  WpaIe;
+extern UCHAR  Wpa2Ie;
+extern UCHAR  IbssIe;
+
+extern UCHAR  WPA_OUI[];
+extern UCHAR  WME_INFO_ELEM[];
+extern UCHAR  WME_PARM_ELEM[];
+extern UCHAR  RALINK_OUI[];
+
+extern struct usb_device_id rtusb_usb_id[];
+extern INT const rtusb_usb_id_len;
+
+//
+// MACRO for linux usb
+//
+typedef struct urb *purbb_t;
+typedef struct usb_ctrlrequest devctrlrequest;
+
+// for vendor-specific control operations
+#define CONTROL_TIMEOUT_MS		(1000)	 /* msec */  // lengthen timeout for loading firmware
+#define CONTROL_TIMEOUT_JIFFIES ((CONTROL_TIMEOUT_MS * HZ)/1000)
+
+/* map devrequest fields onto usb_ctrlrequest's */
+#define DEVREQ_REQUEST(x)		((x)->bRequest)
+#define DEVREQ_REQUESTTYPE(x)	((x)->bRequestType)
+#define DEVREQ_VALUE(x) 		((x)->wValue)
+#define DEVREQ_INDEX(x) 		((x)->wIndex)
+#define DEVREQ_LENGTH(x)		((x)->wLength)
+
+#define PURB		purbb_t
+#define PIRP		PVOID
+#define PMDL		PVOID
+#define NDIS_OID	UINT
+
+#define STATUS_SUCCESS		0x00
+#define STATUS_UNSUCCESSFUL 0x01
+
+typedef LONG		NTSTATUS;
+typedef NTSTATUS	*PNTSTATUS;
+
+//
+//	Macro for debugging information
+//
+#ifdef DBG
+extern ULONG	RTDebugLevel;
+
+#define DBGPRINT(Level, fmt, args...)						\
+{															\
+	if (Level & RTDebugLevel)								\
+	{														\
+		printk(KERN_DEBUG DRIVER_NAME ": " fmt, ## args);	\
+	}														\
+}
+
+#define DBGPRINT_ERR(fmt, args...)									\
+{																	\
+	if (RT_DEBUG_ERROR & RTDebugLevel)										\
+	{																\
+		printk(KERN_DEBUG DRIVER_NAME " ERROR!!! " fmt, ## args);	\
+	}																\
+}
+
+#define DBGPRINT_RAW(Level, fmt, args...)	\
+{											\
+	if (Level & RTDebugLevel)				\
+	{										\
+		printk(fmt, ## args);				\
+	}										\
+}
+#else
+#define DBGPRINT(Level, fmt, args...)
+#define DBGPRINT_ERR(fmt, args...)
+#define DBGPRINT_RAW(Level, fmt, args...)
+#endif
+
+#  define assert(expr)											\
+		if(unlikely(!(expr))) {									\
+		printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n",	\
+		#expr,__FILE__,__FUNCTION__,__LINE__);					\
+		}
+
+#ifndef kzalloc
+#define kzalloc(size, flags)			\
+({						\
+	void *data = kmalloc(size, flags);	\
+	if (data)				\
+		memset(data,0,size);		\
+	data;					\
+})
+#endif
+
+#ifndef free_netdev
+#define free_netdev kfree
+#endif
+
+//
+//	spin_lock enhanced for Nested spin lock
+//
+#define	NdisAllocateSpinLock(lock)	\
+{									\
+	spin_lock_init(lock);			\
+}
+#if 0
+#define NdisReleaseSpinLock(lock, flagg)    \
+{											\
+	if (in_interrupt())						\
+		spin_unlock_irqrestore(lock, flagg);\
+	else									\
+		spin_unlock(lock);					\
+}
+
+#define NdisAcquireSpinLock(lock, flagg)    \
+{											\
+	if (in_interrupt())						\
+		spin_lock_irqsave(lock, flagg);		\
+	else									\
+		spin_lock(lock);					\
+}
+#else
+#define NdisReleaseSpinLock(lock, flagg)	\
+{											\
+	spin_unlock_irqrestore(lock, (unsigned long)flagg);	\
+}
+#define NdisAcquireSpinLock(lock, flagg)	\
+{											\
+	spin_lock_irqsave(lock, flagg);			\
+}
+#endif
+
+#define NdisFreeSpinLock(lock)			\
+{										\
+}
+
+#define RTUSBFreeSkbBuffer(skb)				\
+{											\
+	dev_kfree_skb_any(skb);					\
+}
+
+
+#define RTUSBMlmeUp(pAd)	        \
+{								    \
+	if(pAd->MLMEThr_pid>0)				    \
+        up(&(pAd->mlme_semaphore)); \
+}
+
+#define RTUSBCMDUp(pAd)	                \
+{									    \
+	if(pAd->RTUSBCmdThr_pid>0)		    \
+	    up(&(pAd->RTUSBCmd_semaphore)); \
+}
+
+//Setup Packet used in Ctrl urb's filler....
+#define FILL_REQUEST(a,aa,ab,ac,ad,ae)		\
+  do {										\
+	  (a)->devreq->request = aa;			\
+	  (a)->devreq->requesttype = ab;		\
+	  (a)->devreq->value = cpu_to_le16(ac); \
+	  (a)->devreq->index = cpu_to_le16(ad); \
+	  (a)->devreq->length = cpu_to_le16(ae);\
+  }while(0);
+
+
+// direction is specified in TransferFlags
+#define URB_FUNCTION_RESERVED0						0x0016
+
+//
+// These are for sending vendor and class commands
+// on the default pipe
+//
+// direction is specified in TransferFlags
+#define URB_FUNCTION_VENDOR_DEVICE					 0x0017
+#define URB_FUNCTION_VENDOR_INTERFACE				 0x0018
+#define URB_FUNCTION_VENDOR_ENDPOINT				 0x0019
+#define URB_FUNCTION_VENDOR_OTHER					 0x0020
+
+#define URB_FUNCTION_CLASS_DEVICE					 0x001A
+#define URB_FUNCTION_CLASS_INTERFACE				 0x001B
+#define URB_FUNCTION_CLASS_ENDPOINT 				 0x001C
+#define URB_FUNCTION_CLASS_OTHER					 0x001F
+
+//
+// Reserved function codes
+//
+#define URB_FUNCTION_RESERVED						 0x001D
+
+#define URB_FUNCTION_GET_CONFIGURATION				 0x0026
+#define URB_FUNCTION_GET_INTERFACE					 0x0027
+
+#define URB_FUNCTION_LAST							 0x0029
+
+
+//
+//	Assert MACRO to make sure program running
+//
+#undef	ASSERT
+#define ASSERT(x)																\
+{																				\
+	if (!(x))																	\
+	{																			\
+		printk(KERN_WARNING __FILE__ ":%d assert " #x "failed\n", __LINE__);	\
+	}																			\
+}
+
+//
+//	Macros for flag and ref count operations
+//
+#define RTMP_SET_FLAG(_M, _F)		((_M)->Flags |= (_F))
+#define RTMP_CLEAR_FLAG(_M, _F) 	((_M)->Flags &= ~(_F))
+#define RTMP_CLEAR_FLAGS(_M)		((_M)->Flags = 0)
+#define RTMP_TEST_FLAG(_M, _F)		(((_M)->Flags & (_F)) != 0)
+#define RTMP_TEST_FLAGS(_M, _F) 	(((_M)->Flags & (_F)) == (_F))
+
+// Flags control for RT2500 USB bulk out frame type
+#define RTUSB_SET_BULK_FLAG(_M, _F)				((_M)->BulkFlags |= (_F))
+#define RTUSB_CLEAR_BULK_FLAG(_M, _F)			((_M)->BulkFlags &= ~(_F))
+#define RTUSB_TEST_BULK_FLAG(_M, _F)			(((_M)->BulkFlags & (_F)) != 0)
+
+#define OPSTATUS_SET_FLAG(_pAd, _F) 	((_pAd)->PortCfg.OpStatusFlags |= (_F))
+#define OPSTATUS_CLEAR_FLAG(_pAd, _F)	((_pAd)->PortCfg.OpStatusFlags &= ~(_F))
+#define OPSTATUS_TEST_FLAG(_pAd, _F)	(((_pAd)->PortCfg.OpStatusFlags & (_F)) != 0)
+
+#define CLIENT_STATUS_SET_FLAG(_pEntry,_F)		((_pEntry)->ClientStatusFlags |= (_F))
+#define CLIENT_STATUS_CLEAR_FLAG(_pEntry,_F)	((_pEntry)->ClientStatusFlags &= ~(_F))
+#define CLIENT_STATUS_TEST_FLAG(_pEntry,_F) 	(((_pEntry)->ClientStatusFlags & (_F)) != 0)
+
+
+#define INC_RING_INDEX(_idx, _RingSize)    \
+{										   \
+	(_idx)++;							   \
+	if ((_idx) >= (_RingSize)) _idx=0;	   \
+}
+
+// Increase TxTsc value for next transmission
+// TODO:
+// When i==6, means TSC has done one full cycle, do re-keying stuff follow specs
+// Should send a special event microsoft defined to request re-key
+#define INC_TX_TSC(_tsc)								\
+{														\
+	int i=0;											\
+	while (++_tsc[i] == 0x0)							\
+	{													\
+		i++;											\
+		if (i == 6) 									\
+			break;										\
+	}													\
+}
+
+
+#undef	NdisMoveMemory
+#undef	NdisZeroMemory
+#undef	NdisFillMemory
+#undef	NdisEqualMemory
+
+#define NdisMoveMemory(Destination, Source, Length) RTMPMoveMemory(Destination, Source, Length)
+#define NdisZeroMemory(Destination, Length) 		RTMPZeroMemory(Destination, Length)
+#define NdisFillMemory(Destination, Length, Fill)	RTMPFillMemory(Destination, Length, Fill)
+#define NdisEqualMemory(Source1, Source2, Length)	RTMPEqualMemory(Source1, Source2, Length)
+
+#define MAC_ADDR_EQUAL(pAddr1,pAddr2)				RTMPEqualMemory((PVOID)(pAddr1), (PVOID)(pAddr2), MAC_ADDR_LEN)
+#define COPY_MAC_ADDR(Addr1, Addr2) 				memcpy((Addr1), (Addr2), MAC_ADDR_LEN)
+#define SSID_EQUAL(ssid1, len1, ssid2, len2)		((len1==len2) && (RTMPEqualMemory(ssid1, ssid2, len1)))
+
+#define NdisMSleep                                  mdelay
+
+
+#define 	MAP_CHANNEL_ID_TO_KHZ(ch, khz)	{				\
+				switch (ch) 								\
+				{											\
+					case 1: 	khz = 2412000;	 break; 	\
+					case 2: 	khz = 2417000;	 break; 	\
+					case 3: 	khz = 2422000;	 break; 	\
+					case 4: 	khz = 2427000;	 break; 	\
+					case 5: 	khz = 2432000;	 break; 	\
+					case 6: 	khz = 2437000;	 break; 	\
+					case 7: 	khz = 2442000;	 break; 	\
+					case 8: 	khz = 2447000;	 break; 	\
+					case 9: 	khz = 2452000;	 break; 	\
+					case 10:	khz = 2457000;	 break; 	\
+					case 11:	khz = 2462000;	 break; 	\
+					case 12:	khz = 2467000;	 break; 	\
+					case 13:	khz = 2472000;	 break; 	\
+					case 14:	khz = 2484000;	 break; 	\
+					case 36:  /* UNII */  khz = 5180000;   break;	  \
+					case 40:  /* UNII */  khz = 5200000;   break;	  \
+					case 44:  /* UNII */  khz = 5220000;   break;	  \
+					case 48:  /* UNII */  khz = 5240000;   break;	  \
+					case 52:  /* UNII */  khz = 5260000;   break;	  \
+					case 56:  /* UNII */  khz = 5280000;   break;	  \
+					case 60:  /* UNII */  khz = 5300000;   break;	  \
+					case 64:  /* UNII */  khz = 5320000;   break;	  \
+					case 149: /* UNII */  khz = 5745000;   break;	  \
+					case 153: /* UNII */  khz = 5765000;   break;	  \
+					case 157: /* UNII */  khz = 5785000;   break;	  \
+					case 161: /* UNII */  khz = 5805000;   break;	  \
+					case 165: /* UNII */  khz = 5825000;   break;	  \
+					case 100: /* HiperLAN2 */  khz = 5500000;	break;	   \
+					case 104: /* HiperLAN2 */  khz = 5520000;	break;	   \
+					case 108: /* HiperLAN2 */  khz = 5540000;	break;	   \
+					case 112: /* HiperLAN2 */  khz = 5560000;	break;	   \
+					case 116: /* HiperLAN2 */  khz = 5580000;	break;	   \
+					case 120: /* HiperLAN2 */  khz = 5600000;	break;	   \
+					case 124: /* HiperLAN2 */  khz = 5620000;	break;	   \
+					case 128: /* HiperLAN2 */  khz = 5640000;	break;	   \
+					case 132: /* HiperLAN2 */  khz = 5660000;	break;	   \
+					case 136: /* HiperLAN2 */  khz = 5680000;	break;	   \
+					case 140: /* HiperLAN2 */  khz = 5700000;	break;	   \
+					case 34:  /* Japan MMAC */	 khz = 5170000;   break;   \
+					case 38:  /* Japan MMAC */	 khz = 5190000;   break;   \
+					case 42:  /* Japan MMAC */	 khz = 5210000;   break;   \
+					case 46:  /* Japan MMAC */	 khz = 5230000;   break;   \
+					default:	khz = 2412000;	 break; 	\
+				}											\
+			}
+
+#define 	MAP_KHZ_TO_CHANNEL_ID(khz, ch)	{				\
+				switch (khz)								\
+				{											\
+					case 2412000:	 ch = 1;	 break; 	\
+					case 2417000:	 ch = 2;	 break; 	\
+					case 2422000:	 ch = 3;	 break; 	\
+					case 2427000:	 ch = 4;	 break; 	\
+					case 2432000:	 ch = 5;	 break; 	\
+					case 2437000:	 ch = 6;	 break; 	\
+					case 2442000:	 ch = 7;	 break; 	\
+					case 2447000:	 ch = 8;	 break; 	\
+					case 2452000:	 ch = 9;	 break; 	\
+					case 2457000:	 ch = 10;	 break; 	\
+					case 2462000:	 ch = 11;	 break; 	\
+					case 2467000:	 ch = 12;	 break; 	\
+					case 2472000:	 ch = 13;	 break; 	\
+					case 2484000:	 ch = 14;	 break; 	\
+					case 5180000:	 ch = 36;  /* UNII */  break;	  \
+					case 5200000:	 ch = 40;  /* UNII */  break;	  \
+					case 5220000:	 ch = 44;  /* UNII */  break;	  \
+					case 5240000:	 ch = 48;  /* UNII */  break;	  \
+					case 5260000:	 ch = 52;  /* UNII */  break;	  \
+					case 5280000:	 ch = 56;  /* UNII */  break;	  \
+					case 5300000:	 ch = 60;  /* UNII */  break;	  \
+					case 5320000:	 ch = 64;  /* UNII */  break;	  \
+					case 5745000:	 ch = 149; /* UNII */  break;	  \
+					case 5765000:	 ch = 153; /* UNII */  break;	  \
+					case 5785000:	 ch = 157; /* UNII */  break;	  \
+					case 5805000:	 ch = 161; /* UNII */  break;	  \
+					case 5825000:	 ch = 165; /* UNII */  break;	  \
+					case 5500000:	 ch = 100; /* HiperLAN2 */	break;	   \
+					case 5520000:	 ch = 104; /* HiperLAN2 */	break;	   \
+					case 5540000:	 ch = 108; /* HiperLAN2 */	break;	   \
+					case 5560000:	 ch = 112; /* HiperLAN2 */	break;	   \
+					case 5580000:	 ch = 116; /* HiperLAN2 */	break;	   \
+					case 5600000:	 ch = 120; /* HiperLAN2 */	break;	   \
+					case 5620000:	 ch = 124; /* HiperLAN2 */	break;	   \
+					case 5640000:	 ch = 128; /* HiperLAN2 */	break;	   \
+					case 5660000:	 ch = 132; /* HiperLAN2 */	break;	   \
+					case 5680000:	 ch = 136; /* HiperLAN2 */	break;	   \
+					case 5700000:	 ch = 140; /* HiperLAN2 */	break;	   \
+					case 5170000:	 ch = 34;  /* Japan MMAC */   break;   \
+					case 5190000:	 ch = 38;  /* Japan MMAC */   break;   \
+					case 5210000:	 ch = 42;  /* Japan MMAC */   break;   \
+					case 5230000:	 ch = 46;  /* Japan MMAC */   break;   \
+					default:		 ch = 1;	 break; 	\
+				}											\
+			}
+
+
+//
+// Common fragment list structure -  Identical to the scatter gather frag list structure
+//
+#define NIC_MAX_PHYS_BUF_COUNT				8
+
+typedef struct _RTMP_SCATTER_GATHER_ELEMENT {
+	PVOID		Address;
+	ULONG		Length;
+	PULONG		Reserved;
+} RTMP_SCATTER_GATHER_ELEMENT, *PRTMP_SCATTER_GATHER_ELEMENT;
+
+typedef struct _RTMP_SCATTER_GATHER_LIST {
+	ULONG  NumberOfElements;
+	PULONG Reserved;
+	RTMP_SCATTER_GATHER_ELEMENT Elements[NIC_MAX_PHYS_BUF_COUNT];
+} RTMP_SCATTER_GATHER_LIST, *PRTMP_SCATTER_GATHER_LIST;
+
+
+//
+//	Some utility macros
+//
+#ifndef min
+#define min(_a, _b) 	(((_a) < (_b)) ? (_a) : (_b))
+#endif
+
+#ifndef max
+#define max(_a, _b) 	(((_a) > (_b)) ? (_a) : (_b))
+#endif
+
+#define INC_COUNTER(Val)		(Val.QuadPart++)
+#define	INC_COUNTER64(Val)		(Val.QuadPart++)
+
+#define INFRA_ON(_p)			(OPSTATUS_TEST_FLAG(_p, fOP_STATUS_INFRA_ON))
+#define ADHOC_ON(_p)			(OPSTATUS_TEST_FLAG(_p, fOP_STATUS_ADHOC_ON))
+
+
+// b0-b3 as User Priority
+#define RTMP_SET_PACKET_UP(_p, _prio)				((_p)->cb[10] = ((_p)->cb[10] & 0xf0) | (_prio))
+#define RTMP_GET_PACKET_UP(_p)						((_p)->cb[10] & 0x0f)
+
+// b4-b7 as fragment #
+#define RTMP_SET_PACKET_FRAGMENTS(_p, number)		((_p)->cb[10] = ((_p)->cb[10] & 0x0f) | (number << 4))
+#define RTMP_GET_PACKET_FRAGMENTS(_p)				(((_p)->cb[10] & 0xf0) >> 4)
+
+// 0x0 ~0x7f: TX to AP's own BSS which has the specified AID (this value also as MAC table index)
+// 0x80~0xff: TX to a WDS link. b0~6: WDS index
+#define RTMP_SET_PACKET_WDS(_p, _wdsidx)			((_p)->cb[11] = _wdsidx)
+#define RTMP_GET_PACKET_WDS(_p) 					((_p)->cb[11])
+
+// 0xff: PKTSRC_NDIS, others: local TX buffer index. This value affects how to a packet
+#define RTMP_SET_PACKET_SOURCE(_p, _pktsrc) 		((_p)->cb[12]= _pktsrc)
+#define RTMP_GET_PACKET_SOURCE(_p)					((_p)->cb[12])
+
+// b0~2: RTS/CTS-to-self protection method
+#define RTMP_SET_PACKET_RTS(_p, _num)				((_p)->cb[13] = ((_p)->cb[13] & 0xf8) | (_num))
+#define RTMP_GET_PACKET_RTS(_p) 					((_p)->cb[13] & 0x07)
+
+// b3~7: TX rate index
+#define RTMP_SET_PACKET_TXRATE(_p, _rate)			((_p)->cb[13] = ((_p)->cb[13] & 0x07) | (_rate << 3))
+#define RTMP_GET_PACKET_TXRATE(_p)					(((_p)->cb[13] & 0xf8) >> 3)
+
+
+#define PKTSRC_NDIS 			0x7f
+#define PKTSRC_DRIVER			0x0f
+
+#define	MAKE_802_3_HEADER(_p, _pMac1, _pMac2, _pType)					\
+{																		\
+	NdisMoveMemory(_p, _pMac1, MAC_ADDR_LEN);							\
+	NdisMoveMemory((_p + MAC_ADDR_LEN), _pMac2, MAC_ADDR_LEN);			\
+	NdisMoveMemory((_p + MAC_ADDR_LEN * 2), _pType, LENGTH_802_3_TYPE);	\
+}
+
+// if pData has no LLC/SNAP (neither RFC1042 nor Bridge tunnel), keep it that way.
+// else if the received frame is LLC/SNAP-encaped IPX or APPLETALK, preserve the LLC/SNAP field
+// else remove the LLC/SNAP field from the result Ethernet frame
+// Patch for WHQL only, which did not turn on Netbios but use IPX within its payload
+// Note:
+//	   _pData & _DataSize may be altered (remove 8-byte LLC/SNAP) by this MACRO
+//	   _pRemovedLLCSNAP: pointer to removed LLC/SNAP; NULL is not removed
+#define CONVERT_TO_802_3(_p8023hdr, _pDA, _pSA, _pData, _DataSize, _pRemovedLLCSNAP)	  \
+{																		\
+	char LLC_Len[2];													\
+																		\
+	_pRemovedLLCSNAP = NULL;											\
+	if (NdisEqualMemory(SNAP_802_1H, _pData, 6)  || 					\
+		NdisEqualMemory(SNAP_BRIDGE_TUNNEL, _pData, 6)) 				\
+	{																	\
+		PUCHAR pProto = _pData + 6; 									\
+																		\
+		if ((NdisEqualMemory(IPX, pProto, 2) || NdisEqualMemory(APPLE_TALK, pProto, 2)) &&	\
+			NdisEqualMemory(SNAP_802_1H, _pData, 6))					\
+		{																\
+			LLC_Len[0] = (UCHAR)(_DataSize / 256);						\
+			LLC_Len[1] = (UCHAR)(_DataSize % 256);						\
+			MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, LLC_Len);			\
+		}																\
+		else															\
+		{																\
+			MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, pProto);			\
+			_pRemovedLLCSNAP = _pData;									\
+			_DataSize -= LENGTH_802_1_H;								\
+			_pData += LENGTH_802_1_H;									\
+		}																\
+	}																	\
+	else																\
+	{																	\
+		LLC_Len[0] = (UCHAR)(_DataSize / 256);							\
+		LLC_Len[1] = (UCHAR)(_DataSize % 256);							\
+		MAKE_802_3_HEADER(_p8023hdr, _pDA, _pSA, LLC_Len);				\
+	}																	\
+}
+
+#define RECORD_LATEST_RX_DATA_RATE(_pAd, _pRxD) 								\
+{																				\
+	if ((_pRxD)->Ofdm)															\
+		(_pAd)->LastRxRate = OfdmSignalToRateId[(_pRxD)->PlcpSignal & 0x0f];	\
+	else if ((_pRxD)->PlcpSignal == 10) 										\
+		(_pAd)->LastRxRate = RATE_1;											\
+	else if ((_pRxD)->PlcpSignal == 20) 										\
+		(_pAd)->LastRxRate = RATE_2;											\
+	else if ((_pRxD)->PlcpSignal == 55) 										\
+		(_pAd)->LastRxRate = RATE_5_5;											\
+	else																		\
+		(_pAd)->LastRxRate = RATE_11;											\
+}
+
+// INFRA mode- Address 1 - AP, Address 2 - this STA, Address 3 - DA
+// ADHOC mode- Address 1 - DA, Address 2 - this STA, Address 3 - BSSID
+#define MAKE_802_11_HEADER(_pAd, _80211hdr, _pDA, _seq) 						\
+{																				\
+	NdisZeroMemory(&_80211hdr, sizeof(HEADER_802_11));							\
+	if (INFRA_ON(_pAd)) 														\
+	{																			\
+		COPY_MAC_ADDR(_80211hdr.Addr1, _pAd->PortCfg.Bssid);					\
+		COPY_MAC_ADDR(_80211hdr.Addr3, _pDA);									\
+		_80211hdr.FC.ToDs = 1;													\
+	}																			\
+	else																		\
+	{																			\
+		COPY_MAC_ADDR(_80211hdr.Addr1, _pDA);									\
+		COPY_MAC_ADDR(_80211hdr.Addr3, _pAd->PortCfg.Bssid);					\
+	}																			\
+	COPY_MAC_ADDR(_80211hdr.Addr2, _pAd->CurrentAddress);						\
+	_80211hdr.Sequence = _seq;													\
+	_80211hdr.FC.Type = BTYPE_DATA; 											\
+	_80211hdr.FC.PwrMgmt = (_pAd->PortCfg.Psm == PWR_SAVE); 					\
+}
+
+//Need to collect each ant's rssi concurrently
+//rssi1 is report to pair2 Ant and rss2 is reprot to pair1 Ant when 4 Ant
+#define COLLECT_RX_ANTENNA_AVERAGE_RSSI(_pAd, _rssi1, _rssi2)					\
+{																				\
+	SHORT	AvgRssi;															\
+	UCHAR	UsedAnt;															\
+	if (_pAd->RxAnt.EvaluatePeriod == 0)									\
+	{																		\
+		UsedAnt = _pAd->RxAnt.Pair1PrimaryRxAnt;							\
+		AvgRssi = _pAd->RxAnt.Pair1AvgRssi[UsedAnt];						\
+		if (AvgRssi < 0)													\
+			AvgRssi = AvgRssi - (AvgRssi >> 3) + _rssi1;					\
+		else																\
+			AvgRssi = _rssi1 << 3;											\
+		_pAd->RxAnt.Pair1AvgRssi[UsedAnt] = AvgRssi;						\
+	}																		\
+	else																	\
+	{																		\
+		UsedAnt = _pAd->RxAnt.Pair1SecondaryRxAnt;							\
+		AvgRssi = _pAd->RxAnt.Pair1AvgRssi[UsedAnt];						\
+		if ((AvgRssi < 0) && (_pAd->RxAnt.FirstPktArrivedWhenEvaluate))		\
+			AvgRssi = AvgRssi - (AvgRssi >> 3) + _rssi1;					\
+		else																\
+		{																	\
+			_pAd->RxAnt.FirstPktArrivedWhenEvaluate = TRUE;					\
+			AvgRssi = _rssi1 << 3;											\
+		}																	\
+		_pAd->RxAnt.Pair1AvgRssi[UsedAnt] = AvgRssi;						\
+		_pAd->RxAnt.RcvPktNumWhenEvaluate++;								\
+	}																		\
+}
+
+#define RELEASE_NDIS_PACKET(_pAd, _pSkb)								\
+{																		\
+	if (RTMP_GET_PACKET_SOURCE(_pSkb) == PKTSRC_NDIS)					\
+	{																	\
+		RTUSBFreeSkbBuffer(_pSkb);										\
+		_pAd->RalinkCounters.PendingNdisPacketCount --; 				\
+	}																	\
+	else																\
+		RTUSBFreeSkbBuffer(_pSkb);										\
+}
+
+#define EnqueueCmd(cmdq, cmdqelmt)		\
+{										\
+	if (cmdq->size == 0)				\
+		cmdq->head = cmdqelmt;			\
+	else								\
+		cmdq->tail->next = cmdqelmt;	\
+	cmdq->tail = cmdqelmt;				\
+	cmdqelmt->next = NULL;				\
+	cmdq->size++;						\
+}
+
+// Free Tx ring descriptor MACRO
+// This can only called from complete function since it will change the IO counters
+#define	FREE_TX_RING(_p, _b, _t)			\
+{										\
+	(_t)->InUse 	 = FALSE;			\
+	(_t)->LastOne	 = FALSE;			\
+	(_t)->IRPPending = FALSE;			\
+	(_t)->bWaitingBulkOut = FALSE;		\
+	(_t)->BulkOutSize= 0;				\
+	(_p)->NextBulkOutIndex[_b] = (((_p)->NextBulkOutIndex[_b] + 1) % TX_RING_SIZE);	\
+	atomic_dec(&(_p)->TxCount); \
+}
+
+#define	LOCAL_TX_RING_EMPTY(_p, _i)		(((_p)->TxContext[_i][(_p)->NextBulkOutIndex[_i]].InUse) == FALSE)
+
+typedef	struct _CmdQElmt	{
+	UINT				command;
+	PVOID				buffer;
+	ULONG				bufferlength;
+	BOOLEAN				CmdFromNdis;
+	BOOLEAN				SetOperation;
+	BOOLEAN				InUse;
+	struct _CmdQElmt	*next;
+}	CmdQElmt, *PCmdQElmt;
+
+typedef	struct	_CmdQ	{
+	UINT		size;
+	CmdQElmt	*head;
+	CmdQElmt	*tail;
+}	CmdQ, *PCmdQ;
+
+
+////////////////////////////////////////////////////////////////////////////
+// The TX_BUFFER structure forms the transmitted USB packet to the device
+////////////////////////////////////////////////////////////////////////////
+typedef struct __TX_BUFFER{
+	TXD_STRUC		TxDesc;
+	union	{
+		UCHAR			WirelessPacket[2342];
+		HEADER_802_11	NullFrame;
+		PSPOLL_FRAME	PsPollPacket;
+		RTS_FRAME		RTSFrame;
+	};
+} TX_BUFFER, *PTX_BUFFER;
+
+////////////////////////////////////////////////////////////////////////////
+// The RTS_BUFFER structure forms the transmitted USB packet to the device
+////////////////////////////////////////////////////////////////////////////
+typedef struct __RTS_BUFFER{
+	TXD_STRUC	   TxDesc;
+	UCHAR		   RTSPacket[16];
+} RTS_BUFFER, *PRTS_BUFFER;
+
+// used to track driver-generated write irps
+typedef struct _TX_CONTEXT
+{
+	PVOID			pAd;			//Initialized in MiniportInitialize
+	PURB			pUrb;			//Initialized in MiniportInitialize
+//	PIRP			pIrp;			//Initialized in MiniportInitialize, used to cancel pending bulk out
+	PTX_BUFFER		TransferBuffer;	//Initialized in MiniportInitialize
+	ULONG			BulkOutSize;
+	UCHAR			BulkOutPipeId;
+	BOOLEAN			InUse;
+	BOOLEAN			bWaitingBulkOut;
+	BOOLEAN			IRPPending;
+	BOOLEAN			LastOne;
+}	TX_CONTEXT, *PTX_CONTEXT, **PPTX_CONTEXT;
+
+typedef enum _Pendingirp {
+	NONEPENDING,
+	IRP0PENDING,
+	IRP1PENDING
+}	PendingIRP;
+
+typedef enum _BEACON_INDEX {
+	BEACON0,
+	BEACON1
+}	BEACON_INDEX;
+
+
+#define   IRPLOCK_COMPLETED 		0
+#define   IRPLOCK_CANCELABLE		1
+#define   IRPLOCK_CANCE_START		2
+#define   IRPLOCK_CANCE_COMPLETE	3
+//
+// Structure to keep track of receive packets and buffers to indicate
+// receive data to the protocol.
+//
+typedef struct _RX_CONTEXT
+{
+	PUCHAR				TransferBuffer;
+	PVOID				pAd;
+//	PIRP				pIrp;//used to cancel pending bulk in.
+	PURB				pUrb;
+	BOOLEAN				InUse;
+	BOOLEAN				IRPPending;		// TODO: To be removed
+	atomic_t			IrpLock;
+}	RX_CONTEXT, *PRX_CONTEXT;
+
+//
+// Register set pair for initialzation register set definition
+//
+typedef struct	_RTMP_REG_PAIR
+{
+	ULONG	Register;
+	ULONG	Value;
+}	RTMP_REG_PAIR, *PRTMP_REG_PAIR;
+
+typedef struct	_BBP_REG_PAIR
+{
+	UCHAR	Register;
+	UCHAR	Value;
+}	BBP_REG_PAIR, *PBBP_REG_PAIR;
+
+//
+// Register set pair for initialzation register set definition
+//
+typedef struct	_RTMP_RF_REGS
+{
+	UCHAR	Channel;
+	ULONG	R1;
+	ULONG	R2;
+	ULONG	R3;
+	ULONG	R4;
+}	RTMP_RF_REGS, *PRTMP_RF_REGS;
+
+//
+//	Statistic counter structure
+//
+typedef struct _COUNTER_802_3
+{
+	// General Stats
+	ULONG		GoodTransmits;
+	ULONG		GoodReceives;
+	ULONG		TxErrors;
+	ULONG		RxErrors;
+	ULONG		RxNoBuffer;
+
+	// Ethernet Stats
+	ULONG		RcvAlignmentErrors;
+	ULONG		OneCollision;
+	ULONG		MoreCollisions;
+
+}	COUNTER_802_3, *PCOUNTER_802_3;
+
+typedef struct _COUNTER_802_11 {
+	ULONG			Length;
+	LARGE_INTEGER	TransmittedFragmentCount;
+	LARGE_INTEGER	MulticastTransmittedFrameCount;
+	LARGE_INTEGER	FailedCount;
+	LARGE_INTEGER	NoRetryCount;
+	LARGE_INTEGER	RetryCount;
+	LARGE_INTEGER	MultipleRetryCount;
+	LARGE_INTEGER	RTSSuccessCount;
+	LARGE_INTEGER	RTSFailureCount;
+	LARGE_INTEGER	ACKFailureCount;
+	LARGE_INTEGER	FrameDuplicateCount;
+	LARGE_INTEGER	ReceivedFragmentCount;
+	LARGE_INTEGER	MulticastReceivedFrameCount;
+	LARGE_INTEGER	FCSErrorCount;
+} COUNTER_802_11, *PCOUNTER_802_11;
+
+typedef struct _COUNTER_RALINK {
+	ULONG			TransmittedByteCount;	// both successful and failure, used to calculate TX throughput
+	ULONG			ReceivedByteCount;		// both CRC okay and CRC error, used to calculate RX throughput
+	ULONG			BeenDisassociatedCount;
+	ULONG			BadCQIAutoRecoveryCount;
+	ULONG			PoorCQIRoamingCount;
+	ULONG			MgmtRingFullCount;
+	ULONG			RxCount;
+	ULONG			RxRingErrCount;
+	ULONG			KickTxCount;
+	ULONG			TxRingErrCount;
+	LARGE_INTEGER	RealFcsErrCount;
+	ULONG			PendingNdisPacketCount;
+
+	ULONG			OneSecOsTxCount[NUM_OF_TX_RING];
+	ULONG			OneSecDmaDoneCount[NUM_OF_TX_RING];
+	ULONG			OneSecTxDoneCount;
+	ULONG			OneSecTxAggregationCount;
+	ULONG			OneSecRxAggregationCount;
+
+	ULONG			OneSecTxNoRetryOkCount;
+	ULONG			OneSecTxRetryOkCount;
+	ULONG			OneSecTxFailCount;
+	ULONG			OneSecFalseCCACnt;		// CCA error count, for debug purpose, might move to global counter
+	ULONG			OneSecRxOkCnt;			// RX without error
+	ULONG			OneSecRxFcsErrCnt;		// CRC error
+	ULONG			OneSecBeaconSentCnt;
+} COUNTER_RALINK, *PCOUNTER_RALINK;
+
+typedef struct _COUNTER_DRS {
+	// to record the each TX rate's quality. 0 is best, the bigger the worse.
+	USHORT			TxQuality[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR			PER[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR			TxRateUpPenalty;	  // extra # of second penalty due to last unstable condition
+	ULONG			CurrTxRateStableTime; // # of second in current TX rate
+	BOOLEAN 		fNoisyEnvironment;
+	UCHAR			LastSecTxRateChangeAction; // 0: no change, 1:rate UP, 2:rate down
+} COUNTER_DRS, *PCOUNTER_DRS;
+
+typedef struct _COUNTER_QA {
+	LARGE_INTEGER	CRCErrorCount;
+	LARGE_INTEGER	RXOverFlowCount;
+	LARGE_INTEGER	PHYErrorCount;
+	LARGE_INTEGER	FalseCCACount;
+	LARGE_INTEGER	U2MDataCount;
+	LARGE_INTEGER	OtherDataCount;
+	LARGE_INTEGER	BeaconCount;
+	LARGE_INTEGER	othersCount;
+}	COUNTER_QA, *PCOUNTER_QA;
+
+//
+//	Arcfour Structure Added by PaulWu
+//
+typedef struct	_ARCFOUR
+{
+	UINT			X;
+	UINT			Y;
+	UCHAR			STATE[256];
+}	ARCFOURCONTEXT, *PARCFOURCONTEXT;
+
+typedef	struct	_IV_CONTROL_
+{
+	union
+	{
+		struct
+		{
+			UCHAR		rc0;
+			UCHAR		rc1;
+			UCHAR		rc2;
+
+			union
+			{
+				struct
+				{
+#ifdef BIG_ENDIAN
+					UCHAR	KeyID:2;
+					UCHAR	ExtIV:1;
+					UCHAR	Rsvd:5;
+#else
+					UCHAR	Rsvd:5;
+					UCHAR	ExtIV:1;
+					UCHAR	KeyID:2;
+#endif
+				}	field;
+				UCHAR		Byte;
+			}	CONTROL;
+		}	field;
+
+		ULONG	word;
+	}	IV16;
+
+	ULONG	IV32;
+}	TKIP_IV, *PTKIP_IV;
+
+
+// Shared key data structure
+typedef struct	_WEP_KEY {
+	UCHAR	KeyLen; 					// Key length for each key, 0: entry is invalid
+	UCHAR	Key[MAX_LEN_OF_KEY];		// right now we implement 4 keys, 128 bits max
+}	WEP_KEY, *PWEP_KEY;
+
+typedef struct _CIPHER_KEY {
+	UCHAR	BssId[6];
+	UCHAR	CipherAlg;			// 0-none, 1:WEP64, 2:WEP128, 3:TKIP, 4:AES, 5:CKIP64, 6:CKIP128
+	UCHAR	KeyLen; 			// Key length for each key, 0: entry is invalid
+	UCHAR	Key[16];			// right now we implement 4 keys, 128 bits max
+	UCHAR	RxMic[8];
+	UCHAR	TxMic[8];
+	UCHAR	TxTsc[6];			// 48bit TSC value
+	UCHAR	RxTsc[6];			// 48bit TSC value
+	UCHAR	Type;				// Indicate Pairwise/Group when reporting MIC error
+}	CIPHER_KEY, *PCIPHER_KEY;
+
+typedef struct _BBP_TUNING_STRUCT {
+	BOOLEAN 	Enable;
+	UCHAR		FalseCcaCountUpperBound;  // 100 per sec
+	UCHAR		FalseCcaCountLowerBound;  // 10 per sec
+	UCHAR		R17LowerBound;			  // specified in E2PROM
+	UCHAR		R17UpperBound;			  // 0x68 according to David Tung
+	UCHAR		CurrentR17Value;
+} BBP_TUNING, *PBBP_TUNING;
+
+typedef struct _SOFT_RX_ANT_DIVERSITY_STRUCT {
+	UCHAR	  EvaluatePeriod;		 // 0:not evalute status, 1: evaluate status, 2: switching status
+	UCHAR	  Pair1PrimaryRxAnt;	 // 0:Ant-E1, 1:Ant-E2
+	UCHAR	  Pair1SecondaryRxAnt;	 // 0:Ant-E1, 1:Ant-E2
+	UCHAR	  Pair2PrimaryRxAnt;	 // 0:Ant-E3, 1:Ant-E4
+	UCHAR	  Pair2SecondaryRxAnt;	 // 0:Ant-E3, 1:Ant-E4
+	SHORT	  Pair1AvgRssi[2];		 // AvgRssi[0]:E1, AvgRssi[1]:E2
+	SHORT	  Pair2AvgRssi[2];		 // AvgRssi[0]:E3, AvgRssi[1]:E4
+	SHORT	  Pair1LastAvgRssi; 	 //
+	SHORT	  Pair2LastAvgRssi; 	 //
+	ULONG	  RcvPktNumWhenEvaluate;
+	BOOLEAN   FirstPktArrivedWhenEvaluate;
+	RALINK_TIMER_STRUCT    RxAntDiversityTimer;
+} SOFT_RX_ANT_DIVERSITY, *PSOFT_RX_ANT_DIVERSITY;
+
+typedef struct {
+	BOOLEAN 	Enable;
+	UCHAR		Delta;
+	BOOLEAN 	PlusSign;
+} CCK_TX_POWER_CALIBRATE, *PCCK_TX_POWER_CALIBRATE;
+
+//
+// Receive Tuple Cache Format
+//
+typedef struct	_TUPLE_CACHE	{
+	BOOLEAN 		Valid;
+	UCHAR			MacAddress[MAC_ADDR_LEN];
+	USHORT			Sequence;
+	USHORT			Frag;
+}	TUPLE_CACHE, *PTUPLE_CACHE;
+
+//
+// Fragment Frame structure
+//
+typedef struct	_FRAGMENT_FRAME {
+	UCHAR		Header802_3[LENGTH_802_3];
+	UCHAR		Header_LLC[LENGTH_802_1_H];
+	UCHAR		Buffer[LENGTH_802_3 + MAX_FRAME_SIZE];	// Add header to prevent NETBUEI continuous buffer isssue
+	ULONG		RxSize;
+	USHORT		Sequence;
+	USHORT		LastFrag;
+	ULONG		Flags;			// Some extra frame information. bit 0: LLC presented
+}	FRAGMENT_FRAME, *PFRAGMENT_FRAME;
+
+//
+// Tkip Key structure which RC4 key & MIC calculation
+//
+typedef struct	_TKIP_KEY_INFO	{
+	UINT		nBytesInM;	// # bytes in M for MICKEY
+	ULONG		IV16;
+	ULONG		IV32;
+	ULONG		K0; 		// for MICKEY Low
+	ULONG		K1; 		// for MICKEY Hig
+	ULONG		L;			// Current state for MICKEY
+	ULONG		R;			// Current state for MICKEY
+	ULONG		M;			// Message accumulator for MICKEY
+	UCHAR		RC4KEY[16];
+	UCHAR		MIC[8];
+}	TKIP_KEY_INFO, *PTKIP_KEY_INFO;
+
+//
+// Private / Misc data, counters for driver internal use
+//
+typedef struct	__PRIVATE_STRUC {
+	ULONG		SystemResetCnt; 		// System reset counter
+	ULONG		TxRingFullCnt;			// Tx ring full occurrance number
+	ULONG		PhyRxErrCnt;			// PHY Rx error count, for debug purpose, might move to global counter
+	// Variables for WEP encryption / decryption in rtmp_wep.c
+	ULONG			FCSCRC32;
+	ARCFOURCONTEXT	WEPCONTEXT;
+	// Tkip stuff
+	TKIP_KEY_INFO	Tx;
+	TKIP_KEY_INFO	Rx;
+}	PRIVATE_STRUC, *PPRIVATE_STRUC;
+
+// structure to store Simple Config Attributes Info
+typedef struct _WSC_LV_INFO {
+    USHORT  ValueLen;
+    UCHAR   Value[512];
+} WSC_LV_INFO;
+
+// structure to tune BBP R17 "RX AGC VGC init"
+typedef struct _BBP_R17_TUNING {
+	BOOLEAN 	bEnable;
+	UCHAR		R17LowerBoundG;
+	UCHAR		R17LowerBoundA;
+	UCHAR		R17UpperBoundG;
+	UCHAR		R17UpperBoundA;
+//	  UCHAR 	  LastR17Value;
+//	  SHORT 	  R17Dec;	  // R17Dec = 0x79 - RssiToDbm, for old version R17Dec = 0.
+//							  // This is signed value
+	USHORT		FalseCcaLowerThreshold;  // default 100
+	USHORT		FalseCcaUpperThreshold;  // default 512
+	UCHAR		R17Delta;				 // R17 +- R17Delta whenever false CCA over UpperThreshold or lower than LowerThreshold
+	UCHAR		R17CurrentValue;
+	BOOLEAN		R17LowerUpperSelect; //Before LinkUp, Used LowerBound or UpperBound as R17 value.
+} BBP_R17_TUNING, *PBBP_R17_TUNING;
+
+// structure to store channel TX power
+typedef struct _CHANNEL_TX_POWER {
+	UCHAR	   Channel;
+	CHAR	   Power;
+}	CHANNEL_TX_POWER, *PCHANNEL_TX_POWER;
+
+typedef enum _ABGBAND_STATE_ {
+	UNKNOWN_BAND,
+	BG_BAND,
+	A_BAND,
+} ABGBAND_STATE;
+
+typedef struct _MLME_MEMORY_STRUCT {
+	PVOID							AllocVa;	//Pointer to the base virtual address of the allocated memory
+	struct _MLME_MEMORY_STRUCT		*Next;		//Pointer to the next virtual address of the allocated memory
+}	MLME_MEMORY_STRUCT, *PMLME_MEMORY_STRUCT;
+
+typedef struct	_MLME_MEMORY_HANDLER {
+	BOOLEAN 				MemRunning; 		//The flag of the Mlme memory handler's status
+	UINT					MemoryCount;		//Total nonpaged system-space memory not size
+	UINT					InUseCount; 		//Nonpaged system-space memory in used counts
+	UINT					UnUseCount; 		//Nonpaged system-space memory available counts
+	UINT					PendingCount;		//Nonpaged system-space memory for free counts
+	PMLME_MEMORY_STRUCT 	pInUseHead; 		//Pointer to the first nonpaed memory not used
+	PMLME_MEMORY_STRUCT 	pInUseTail; 		//Pointer to the last nonpaged memory not used
+	PMLME_MEMORY_STRUCT 	pUnUseHead; 		//Pointer to the first nonpaged memory in used
+	PMLME_MEMORY_STRUCT 	pUnUseTail; 		//Pointer to the last nonpaged memory in used
+	PULONG					MemFreePending[MAX_MLME_HANDLER_MEMORY];   //an array to keep pending free-memory's pointer (32bits)
+}	MLME_MEMORY_HANDLER, *PMLME_MEMORY_HANDLER;
+
+typedef struct _MLME_STRUCT {
+	STATE_MACHINE			CntlMachine;
+	STATE_MACHINE			AssocMachine;
+	STATE_MACHINE			AuthMachine;
+	STATE_MACHINE			AuthRspMachine;
+	STATE_MACHINE			SyncMachine;
+	STATE_MACHINE			WpaPskMachine;
+	STATE_MACHINE_FUNC		AssocFunc[ASSOC_FUNC_SIZE];
+	STATE_MACHINE_FUNC		AuthFunc[AUTH_FUNC_SIZE];
+	STATE_MACHINE_FUNC		AuthRspFunc[AUTH_RSP_FUNC_SIZE];
+	STATE_MACHINE_FUNC		SyncFunc[SYNC_FUNC_SIZE];
+	STATE_MACHINE_FUNC		WpaPskFunc[WPA_PSK_FUNC_SIZE];
+
+	ULONG					ChannelQuality;  // 0..100, Channel Quality Indication for Roaming
+	unsigned long				Now;			 // latch the value of NdisGetSystemUpTime()
+
+	BOOLEAN 				bRunning;
+	spinlock_t				TaskLock;
+	MLME_QUEUE				Queue;
+
+	UINT					ShiftReg;
+
+	RALINK_TIMER_STRUCT 	PeriodicTimer;
+	RALINK_TIMER_STRUCT 	LinkDownTimer;
+	ULONG					PeriodicRound;
+
+	MLME_MEMORY_HANDLER 	MemHandler; 		//The handler of the nonpaged memory inside MLME
+} MLME_STRUCT, *PMLME_STRUCT;
+
+//
+// Management ring buffer format
+//
+typedef	struct	_MGMT_STRUC	{
+	BOOLEAN		Valid;
+	PUCHAR		pBuffer;
+	ULONG		Length;
+}	MGMT_STRUC, *PMGMT_STRUC;
+
+// structure for radar detection and channel switch
+typedef struct _RADAR_DETECT_STRUCT {
+	UCHAR		CSCount;			//Channel switch counter
+	UCHAR		CSPeriod;			//Channel switch period (beacon count)
+	UCHAR		RDCount;			//Radar detection counter
+	UCHAR		RDMode;				//Radar Detection mode
+	UCHAR		BBPR16;
+	UCHAR		BBPR17;
+	UCHAR		BBPR18;
+	UCHAR		BBPR21;
+	UCHAR		BBPR22;
+	UCHAR		BBPR64;
+	ULONG		InServiceMonitorCount; // unit: sec
+} RADAR_DETECT_STRUCT, *PRADAR_DETECT_STRUCT;
+
+//
+//	configuration and status
+//
+typedef struct _PORT_CONFIG {
+
+	// MIB:ieee802dot11.dot11smt(1).dot11StationConfigTable(1)
+	USHORT		Psm;				  // power management mode	 (PWR_ACTIVE|PWR_SAVE)
+	USHORT		DisassocReason;
+	UCHAR		DisassocSta[MAC_ADDR_LEN];
+	USHORT		DeauthReason;
+	UCHAR		DeauthSta[MAC_ADDR_LEN];
+	USHORT		AuthFailReason;
+	UCHAR		AuthFailSta[MAC_ADDR_LEN];
+
+	NDIS_802_11_AUTHENTICATION_MODE 	AuthMode;		// This should match to whatever microsoft defined
+	NDIS_802_11_WEP_STATUS				WepStatus;
+	NDIS_802_11_WEP_STATUS				OrigWepStatus;	// Original wep status set from OID
+
+
+	// Add to support different cipher suite for WPA2/WPA mode
+	NDIS_802_11_ENCRYPTION_STATUS		GroupCipher;		// Multicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS		PairCipher;			// Unicast cipher suite
+	BOOLEAN								bMixCipher;			// Indicate current Pair & Group use different cipher suites
+	USHORT								RsnCapability;
+
+	// MIB:ieee802dot11.dot11smt(1).dot11WEPDefaultKeysTable(3)
+	CIPHER_KEY	PskKey; 				// WPA PSK mode PMK
+	UCHAR		PTK[64];				// WPA PSK mode PTK
+	BSSID_INFO	SavedPMK[PMKID_NO];
+	ULONG		SavedPMKNum;			// Saved PMKID number
+
+	// WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED
+	UCHAR		PortSecured;
+	UCHAR		RSN_IE[44];
+	UCHAR		RSN_IELen;
+
+//#if WPA_SUPPLICANT_SUPPORT
+	BOOLEAN     IEEE8021X;				// Enable or disable IEEE 802.1x
+	CIPHER_KEY	DesireSharedKey[4];		// Record user desired WEP keys
+	BOOLEAN		IEEE8021x_required_keys;				// Enable or disable dynamic wep key updating
+	BOOLEAN     WPA_Supplicant;         // Enable or disable WPA_SUPPLICANT
+	BOOLEAN     Send_Beacon;
+//#endif
+
+	// For WPA countermeasures
+	unsigned long	LastMicErrorTime;	// record last MIC error time
+	ULONG		MicErrCnt;			// Should be 0, 1, 2, then reset to zero (after disassoiciation).
+	BOOLEAN 	bBlockAssoc;		// Block associate attempt for 60 seconds after counter measure occurred.
+	// For WPA-PSK supplicant state
+	WPA_STATE	WpaState;			// Default is SS_NOTUSE and handled by microsoft 802.1x
+	UCHAR		ReplayCounter[8];
+	UCHAR		ANonce[32]; 		// ANonce for WPA-PSK from aurhenticator
+	UCHAR		SNonce[32]; 		// SNonce for WPA-PSK
+
+	// MIB:ieee802dot11.dot11smt(1).dot11PrivacyTable(5)
+	UCHAR								DefaultKeyId;
+	NDIS_802_11_PRIVACY_FILTER			PrivacyFilter;	// PrivacyFilter enum for 802.1X
+
+
+	// MIB:ieee802dot11.dot11mac(2).dot11OperationTable(1)
+	USHORT		RtsThreshold;			// in unit of BYTE
+	USHORT		FragmentThreshold;		// in unit of BYTE
+	BOOLEAN 	bFragmentZeroDisable;	// Microsoft use 0 as disable
+
+	// MIB:ieee802dot11.dot11phy(4).dot11PhyTxPowerTable(3)
+	UCHAR		TxPower;				// in unit of mW
+	ULONG		TxPowerPercentage;		// 0~100 %
+	ULONG		TxPowerDefault; 		// keep for TxPowerPercentage
+
+	// MIB:ieee802dot11.dot11phy(4).dot11PhyDSSSTable(5)
+	UCHAR		Channel;		  // current (I)BSS channel used in the station
+	UCHAR       AdhocChannel;     // current (I)BSS channel used in the station
+	UCHAR		CountryRegion;	  // Enum of country region, 0:FCC, 1:IC, 2:ETSI, 3:SPAIN, 4:France, 5:MKK, 6:MKK1, 7:Israel
+	UCHAR		CountryRegionForABand;	// Enum of country region for A band
+
+
+	// Copy supported rate from desired AP's beacon. We are trying to match
+	// AP's supported and extended rate settings.
+	UCHAR		SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		SupRateLen;
+	UCHAR		ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		ExtRateLen;
+	UCHAR		ExpectedACKRate[MAX_LEN_OF_SUPPORTED_RATES];
+
+	ULONG		BasicRateBitmap;		// backup basic ratebitmap
+
+	//
+	// other parameters not defined in standard MIB
+	//
+	UCHAR		DesireRate[MAX_LEN_OF_SUPPORTED_RATES]; 	 // OID_802_11_DESIRED_RATES
+	UCHAR		MaxDesiredRate;
+    UCHAR       BasicMlmeRate;          // Default Rate for sending MLME frames
+	UCHAR		MlmeRate;
+	UCHAR		RtsRate;				// RATE_xxx
+	UCHAR		TxRate; 				// RATE_1, RATE_2, RATE_5_5, RATE_11, ...
+	UCHAR		MaxTxRate;				// RATE_1, RATE_2, RATE_5_5, RATE_11
+
+	UCHAR		Bssid[MAC_ADDR_LEN];
+	USHORT		BeaconPeriod;
+	CHAR		Ssid[MAX_LEN_OF_SSID];		// NOT NULL-terminated
+	UCHAR		SsidLen;					// the actual ssid length in used
+	UCHAR		LastSsidLen;				// the actual ssid length in used
+	CHAR		LastSsid[MAX_LEN_OF_SSID];	// NOT NULL-terminated
+	UCHAR		LastBssid[MAC_ADDR_LEN];
+
+	UCHAR		BssType;				// BSS_INFRA or BSS_ADHOC
+	USHORT		AtimWin;				// used when starting a new IBSS
+
+	UCHAR		RssiTrigger;
+	UCHAR		RssiTriggerMode;		// RSSI_TRIGGERED_UPON_BELOW_THRESHOLD or RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD
+	USHORT		DefaultListenCount; 	// default listen count;
+	ULONG		WindowsPowerMode;			// Power mode for AC power
+	ULONG		WindowsBatteryPowerMode;	// Power mode for battery if exists
+	BOOLEAN 	bWindowsACCAMEnable;		// Enable CAM power mode when AC on
+	BOOLEAN 	bAutoReconnect; 		// Set to TRUE when setting OID_802_11_SSID with no matching BSSID
+
+	UCHAR		LastRssi;				// last received BEACON's RSSI
+	UCHAR		LastRssi2;				// last received BEACON's RSSI for smart antenna
+	USHORT		AvgRssi;				// last 8 BEACON's average RSSI
+	USHORT		AvgRssiX8;				// sum of last 8 BEACON's RSSI
+	ULONG		NumOfAvgRssiSample;
+
+	unsigned long	LastBeaconRxTime;		// OS's timestamp of the last BEACON RX time
+	unsigned long	Last11bBeaconRxTime;	// OS's timestamp of the last 11B BEACON RX time
+	unsigned long	LastScanTime;			// Record last scan time for issue BSSID_SCAN_LIST
+	ULONG		ScanCnt;			  // Scan counts since most recent SSID, BSSID, SCAN OID request
+	BOOLEAN 	bSwRadio;				// Software controlled Radio On/Off, TRUE: On
+	BOOLEAN 	bHwRadio;				// Hardware controlled Radio On/Off, TRUE: On
+	BOOLEAN 	bRadio; 				// Radio state, And of Sw & Hw radio state
+	BOOLEAN 	bHardwareRadio; 		// Hardware controlled Radio enabled
+	BOOLEAN 	bShowHiddenSSID;	  // Show all known SSID in SSID list get operation
+
+
+	// PHY specification
+	UCHAR	  PhyMode;			// PHY_11A, PHY_11B, PHY_11BG_MIXED, PHY_ABG_MIXED
+	USHORT	  Dsifs;			// in units of usec
+	USHORT	  TxPreamble;		// Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto
+
+	// New for WPA, windows want us to to keep association information and
+	// Fixed IEs from last association response
+	NDIS_802_11_ASSOCIATION_INFORMATION 	AssocInfo;
+	UCHAR					ReqVarIELen;				// Length of next VIE include EID & Length
+	UCHAR					ReqVarIEs[MAX_VIE_LEN];
+	UCHAR					ResVarIELen;				// Length of next VIE include EID & Length
+	UCHAR					ResVarIEs[MAX_VIE_LEN];
+
+	ULONG					EnableTurboRate;	  // 1: enable 72/100 Mbps whenever applicable, 0: never use 72/100 Mbps
+	ULONG					UseBGProtection;	  // 0:AUTO, 1-always ON,2-always OFF
+	ULONG					UseShortSlotTime;	  // 0: disable, 1 - use short slot (9us)
+
+
+	// EDCA Qos
+	BOOLEAN 				bWmmCapable;		// 0:disable WMM, 1:enable WMM
+	QOS_CAPABILITY_PARM		APQosCapability;	// QOS capability of the current associated AP
+	EDCA_PARM				APEdcaParm; 		// EDCA parameters of the current associated AP
+	QBSS_LOAD_PARM			APQbssLoad; 		// QBSS load of the current associated AP
+
+	BOOLEAN					bEnableTxBurst; 		// 0: disable, 1: enable TX PACKET BURST
+	BOOLEAN					bAggregationCapable;	// 1: enable TX aggregation when the peer supports it
+	BOOLEAN 				bUseZeroToDisableFragment;			// Microsoft use 0 as disable
+	BOOLEAN 				bIEEE80211H;			// 1: enable IEEE802.11h spec.
+
+	// a bitmap of BOOLEAN flags. each bit represent an operation status of a particular
+	// BOOLEAN control, either ON or OFF. These flags should always be accessed via
+	// OPSTATUS_TEST_FLAG(), OPSTATUS_SET_FLAG(), OP_STATUS_CLEAR_FLAG() macros.
+	// see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition
+	ULONG					OpStatusFlags;
+
+	UCHAR					AckPolicy[4];		// ACK policy of the specified AC. see ACK_xxx
+
+	ABGBAND_STATE			BandState;			// For setting BBP used on B/G or A mode
+
+	ULONG					AdhocMode;			// 0:WIFI mode (11b rates only), 1: b/g mixed, 2: 11g only, 3: 11a only, 4: 11abg mixed
+
+	RALINK_TIMER_STRUCT		QuickResponeForRateUpTimer;
+	BOOLEAN					QuickResponeForRateUpTimerRunning;
+
+
+    // Fast Roaming
+    BOOLEAN                 bFastRoaming;       // 0:disable fast roaming, 1:enable fast roaming
+    ULONG                   dBmToRoam;          // the condition to roam when receiving Rssi less than this value. It's negative value.
+
+    RADAR_DETECT_STRUCT	    RadarDetect;
+
+    BOOLEAN                 bGetAPConfig;
+
+    BOOLEAN                 bWscCapable;	// 1:use simple config, 0:otherwise
+    WSC_LV_INFO             WscIEProbeReq;
+    WSC_LV_INFO             WscIEBeacon;
+
+} PORT_CONFIG, *PPORT_CONFIG;
+
+
+// This data structure keep the current active BSS/IBSS's configuration that this STA
+// had agreed upon joining the network. Which means these parameters are usually decided
+// by the BSS/IBSS creator instead of user configuration. Data in this data structurre
+// is valid only when either ADHOC_ON(pAd) or INFRA_ON(pAd) is TRUE.
+// Normally, after SCAN or failed roaming attempts, we need to recover back to
+// the current active settings.
+typedef struct _ACTIVE_CONFIG {
+	USHORT		Aid;
+	USHORT		AtimWin;				// in kusec; IBSS parameter set element
+	USHORT		CapabilityInfo;
+	USHORT		CfpMaxDuration;
+	USHORT		CfpPeriod;
+
+	// Copy supported rate from desired AP's beacon. We are trying to match
+	// AP's supported and extended rate settings.
+	UCHAR		SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		SupRateLen;
+	UCHAR		ExtRateLen;
+} ACTIVE_CONFIG, *PACTIVE_CONFIG;
+
+
+//
+//	The miniport adapter structure
+//
+typedef struct _RTMP_ADAPTER
+{
+	//----------------------------
+	// Linux specific
+	//----------------------------
+	CHAR							nickn[IW_ESSID_MAX_SIZE+1]; // nickname, only used in the iwconfig i/f
+	struct usb_device				*pUsb_Dev;
+	struct net_device				*net_dev;
+	struct tasklet_struct			rx_bh;
+	struct tasklet_struct			rx_bk;
+	struct usb_config_descriptor	*config;
+	devctrlrequest					*devreq;
+
+	struct rt2x00debug debug;
+	INT	EAPOLVer;
+
+	/* The device we're working with
+	 * It's important to note:
+	 *	  (o) you must hold dev_semaphore to change pUsb_Dev
+	 */
+	struct semaphore	usbdev_semaphore;		/* protect	usb */
+	// Thread
+	struct semaphore	mlme_semaphore;			/* to sleep thread on	*/
+	struct semaphore	RTUSBCmd_semaphore;		/* to sleep thread on	*/
+
+	struct completion	notify;					/* thread begin/end	 */
+	pid_t			MLMEThr_pid;
+	pid_t			RTUSBCmdThr_pid;
+
+	wait_queue_head_t	*wait;
+
+#if WIRELESS_EXT >= 12
+	struct iw_statistics iw_stats;
+#endif
+	struct net_device_stats stats;
+
+	ULONG  VendorDesc;		// VID/PID
+
+
+	// resource for software backlog queues
+	struct sk_buff_head			TxSwQueue[NUM_OF_TX_RING];	// 4 AC + 1 HCCA
+	MGMT_STRUC				MgmtRing[MGMT_RING_SIZE];
+
+
+	// outgoing BEACON frame buffer and corresponding TXD
+	TXD_STRUC				BeaconTxD;
+	CHAR					BeaconBuf[256]; // NOTE: BeaconBuf should be 4-byte aligned
+
+	// pre-build PS-POLL and NULL frame upon link up. for efficiency purpose.
+	PSPOLL_FRAME			PsPollFrame;
+	HEADER_802_11			NullFrame;
+
+	// configuration: read from Registry & E2PROM
+	BOOLEAN 				bLocalAdminMAC; 					// Use user changed MAC
+	UCHAR					PermanentAddress[MAC_ADDR_LEN]; 	// Factory default MAC address
+	UCHAR					CurrentAddress[MAC_ADDR_LEN];		// User changed MAC address
+
+	MLME_STRUCT 			Mlme;
+
+	// ---------------------------
+	// STA specific configuration
+	// ---------------------------
+	PORT_CONFIG 			PortCfg;			// user desired settings
+	ACTIVE_CONFIG			ActiveCfg;			// valid only when ADHOC_ON(pAd) || INFRA_ON(pAd)
+	MLME_AUX				MlmeAux;			// temporary settings used during MLME state machine
+	BSS_TABLE				ScanTab;			// store the latest SCAN result
+
+	// encryption/decryption KEY tables
+	CIPHER_KEY				SharedKey[4];
+//	CIPHER_KEY				PairwiseKey[64];		// for AP only
+
+	// Boolean control for packet filter
+	BOOLEAN 				bAcceptDirect;
+	BOOLEAN 				bAcceptMulticast;
+	BOOLEAN 				bAcceptBroadcast;
+	BOOLEAN 				bAcceptAllMulticast;
+	BOOLEAN 				bAcceptRFMONTx;
+
+	UINT					ForcePrismHeader;
+
+	// 802.3 multicast support
+	ULONG					NumberOfMcastAddresses; 	// Number of mcast entry exists
+	UCHAR					McastTable[MAX_MCAST_LIST_SIZE][MAC_ADDR_LEN];		// Mcast list
+
+
+	// RX Tuple chahe for duplicate frame check
+	TUPLE_CACHE				TupleCache[MAX_CLIENT];		// Maximum number of tuple caches, only useful in Ad-Hoc
+	UCHAR					TupleCacheLastUpdateIndex;	// 0..MAX_CLIENT-1
+
+	// RX re-assembly buffer for fragmentation
+	FRAGMENT_FRAME			FragFrame;					// Frame storage for fragment frame
+
+	// various Counters
+	COUNTER_802_3			Counters8023;				// 802.3 counters
+	COUNTER_802_11			WlanCounters;				// 802.11 MIB counters
+	COUNTER_RALINK			RalinkCounters;				// Ralink propriety counters
+	COUNTER_DRS 			DrsCounters;				// counters for Dynamic TX Rate Switching
+	PRIVATE_STRUC			PrivateInfo;				// Private information & counters
+
+	// Counters for 802.3 & generic.
+	// Add 802.11 specific counters later
+	COUNTER_802_3			Counters;					// 802.3 counters
+	COUNTER_QA				QACounters;				// Ralink propriety counters
+
+	// flags, see fRTMP_ADAPTER_xxx flags
+	ULONG					Flags;						// Represent current device status
+
+	// current TX sequence #
+	USHORT					Sequence;
+
+	// Control disconnect / connect event generation
+	ULONG					LinkDownTime;
+	ULONG					LastRxRate;
+	BOOLEAN 				bConfigChanged; 		// Config Change flag for the same SSID setting
+
+	ULONG					ExtraInfo;				// Extra information for displaying status
+	ULONG					SystemErrorBitmap;		// b0: E2PROM version error
+
+	// ---------------------------
+	// E2PROM
+	// ---------------------------
+	ULONG					EepromVersion;			// byte 0: version, byte 1: revision, byte 2~3: unused
+	UCHAR					EEPROMAddressNum;		// 93c46=6	93c66=8
+	USHORT					EEPROMDefaultValue[NUM_EEPROM_BBP_PARMS];
+
+	ULONG					FirmwareVersion;		// byte 0: Minor version, byte 1: Major version, otherwise unused.
+
+	// ---------------------------
+	// BBP Control
+	// ---------------------------
+	UCHAR					BbpWriteLatch[110]; 	// record last BBP register value written via BBP_IO_WRITE/BBP_IO_WRITE_VY_REG_ID
+	UCHAR					BbpRssiToDbmDelta;
+	BBP_R17_TUNING			BbpTuning;
+
+	// ----------------------------
+	// RFIC control
+	// ----------------------------
+	UCHAR					RfIcType;		// RFIC_xxx
+	ULONG					RfFreqOffset;	// Frequency offset for channel switching
+	BOOLEAN 				bAutoTxAgc;		// Enable driver auto Tx Agc control
+	RTMP_RF_REGS			LatchRfRegs;	// latch th latest RF programming value since RF IC doesn't support READ
+//	  CCK_TX_POWER_CALIBRATE  CckTxPowerCalibrate;	  // 2004-05-25 add CCK TX power caliberation based on E2PROM settings
+
+
+	UCHAR					RFProgSeq;
+	EEPROM_ANTENNA_STRUC	Antenna;							// Since ANtenna definition is different for a & g. We need to save it for future reference.
+	EEPROM_NIC_CONFIG2_STRUC	NicConfig2;
+	CHANNEL_TX_POWER		TxPower[MAX_NUM_OF_CHANNELS];		// Store Tx power value for all channels.
+	CHANNEL_TX_POWER		ChannelList[MAX_NUM_OF_CHANNELS];	// list all supported channels for site survey
+	UCHAR		            ChannelListNum; 		            // number of channel in ChannelList[]
+    EEPROM_TXPOWER_DELTA_STRUC  TxPowerDeltaConfig;				// Compensate the Tx power BBP94 with this configurate value
+	UCHAR					    Bbp94;
+	BOOLEAN					    BbpForCCK;
+
+//	UCHAR		ChannelTssiRef[MAX_NUM_OF_CHANNELS];		// Store Tssi Reference value for all channels.
+//	UCHAR		ChannelTssiDelta;							// Store Tx TSSI delta increment / decrement value
+
+	// This soft Rx Antenna Diversity mechanism is used only when user set
+	// RX Antenna = DIVERSITY ON
+	SOFT_RX_ANT_DIVERSITY	RxAnt;
+
+
+	BOOLEAN 	bAutoTxAgcA;				// Enable driver auto Tx Agc control
+	UCHAR		TssiRefA;					// Store Tssi reference value as 25 tempature.
+	UCHAR		TssiPlusBoundaryA[5];		// Tssi boundary for increase Tx power to compensate.
+	UCHAR		TssiMinusBoundaryA[5];		// Tssi boundary for decrease Tx power to compensate.
+	UCHAR		TxAgcStepA;					// Store Tx TSSI delta increment / decrement value
+	CHAR		TxAgcCompensateA;			// Store the compensation (TxAgcStep * (idx-1))
+
+	BOOLEAN 	bAutoTxAgcG;				// Enable driver auto Tx Agc control
+	UCHAR		TssiRefG;					// Store Tssi reference value as 25 tempature.
+	UCHAR		TssiPlusBoundaryG[5];		// Tssi boundary for increase Tx power to compensate.
+	UCHAR		TssiMinusBoundaryG[5];		// Tssi boundary for decrease Tx power to compensate.
+	UCHAR		TxAgcStepG;					// Store Tx TSSI delta increment / decrement value
+	CHAR		TxAgcCompensateG;			// Store the compensation (TxAgcStep * (idx-1))
+
+	CHAR		BGRssiOffset1;				// Store B/G RSSI#1 Offset value on EEPROM 0x9Ah
+	CHAR		BGRssiOffset2;				// Store B/G RSSI#2 Offset value
+	CHAR		ARssiOffset1;				// Store A RSSI#1 Offset value on EEPROM 0x9Ch
+	CHAR		ARssiOffset2;
+
+
+	// ----------------------------
+	// LED control
+	// ----------------------------
+	MCU_LEDCS_STRUC		LedCntl;
+	USHORT				LedIndicatorStrength;
+
+
+	// ----------------------------
+	// DEBUG paramerts
+	// ----------------------------
+//	ULONG					DebugSetting[4];
+
+
+
+	//////////////////////////////////////////////////////////////////////
+	//	USB
+	//////////////////////////////////////////////////////////////////////
+
+	USHORT				BulkOutMaxPacketSize;	   // 64 in XP
+	USHORT				BulkInMaxPacketSize;
+
+	CmdQ				CmdQ;
+	CmdQElmt			CmdQElements[COMMAND_QUEUE_SIZE];
+
+	BOOLEAN				DeQueueRunning[4];		// for ensuring RTUSBDeQueuePacket get call once
+
+	// SpinLocks
+	spinlock_t			SendTxWaitQueueLock[4]; // SendTxWaitQueue spinlock
+
+	spinlock_t			DataQLock[4];
+	spinlock_t			DeQueueLock[4];
+
+	spinlock_t			MLMEWaitQueueLock;	// SendTxWaitQueue spinlock
+	spinlock_t			CmdQLock;			// SendTxWaitQueue spinlock
+	spinlock_t			BulkOutLock[4];		// SendTxWaitQueue spinlock for 4 ACs
+
+//	spinlock_t			ControlLock;		// SendTxWaitQueue spinlock
+	spinlock_t			MLMEQLock;			// SendTxWaitQueue spinlock
+//	spinlock_t			GenericLock;		// SendTxWaitQueue spinlock
+
+	/////////////////////
+	// Transmit Path
+	/////////////////////
+	TX_CONTEXT				MLMEContext[PRIO_RING_SIZE];
+	TX_CONTEXT				BeaconContext[BEACON_RING_SIZE];
+	TX_CONTEXT				NullContext;
+	TX_CONTEXT				PsPollContext;
+	TX_CONTEXT				RTSContext;
+//	PUCHAR					TxBuffer;
+//	TX_BUFFER				TxMgmtBuf;
+//	PURB					pTxMgmtUrb;
+//	PIRP					pTxMgmtIrp;
+	struct sk_buff_head			SendTxWaitQueue[4];
+
+	UINT32					TxRingTotalNumber[4];
+	UCHAR					NextTxIndex[4];				// Next TxD write pointer
+
+	UCHAR					NextMLMEIndex;				// Next PrioD write pointer
+	UCHAR					PushMgmtIndex;				// Next SW management ring index
+	UCHAR					PopMgmtIndex;				// Next SW management ring index
+	atomic_t				MgmtQueueSize;				// Number of Mgmt request stored in MgmtRing
+	UCHAR					NextRxBulkInIndex;
+
+	// 4 sets of Bulk Out index and pending flag
+	UCHAR					NextBulkOutIndex[4];
+	BOOLEAN					BulkOutPending[4];
+
+//	BOOLEAN					ControlPending;
+	ULONG					PrioRingTxCnt;
+	UCHAR					PrioRingFirstIndex;
+
+	atomic_t				TxCount;		// Number of Bulkout waiting to be send.
+	LONG					PendingTx;
+
+	// Data related context and AC specified, 4 AC supported
+	TX_CONTEXT				TxContext[4][TX_RING_SIZE];
+	LONG					NumPacketsQueued[4];
+//	PURB					pTxUrb[4];
+//	PIRP					pTxIrp[4];
+
+	/////////////////////
+	// Receive Path
+	/////////////////////
+	RX_CONTEXT				RxContext[RX_RING_SIZE];
+//	PURB					pRxUrb;
+//	PIRP					pRxIrp;
+//	PUCHAR					RxBuffer;
+	atomic_t				PendingRx;
+
+	/////////////////////
+	//	Control Flags
+	/////////////////////
+//	atomic_t				PendingIoCount;
+	// Flags for bulk out data priority
+	ULONG					BulkFlags;
+
+//	spinlock_t				MemLock;	// need to check
+	ULONG					BulkOutDataOneSecCount;
+	ULONG					BulkInDataOneSecCount;
+	ULONG					BulkLastOneSecCount; // BulkOutDataOneSecCount + BulkInDataOneSecCount
+
+}	RTMP_ADAPTER, *PRTMP_ADAPTER;
+
+/* Define in md5.h */
+//
+// SHA context
+//
+//typedef struct
+//{
+//	ULONG		H[5];
+//	ULONG		W[80];
+//	INT 		lenW;
+//	ULONG		sizeHi, sizeLo;
+//}	SHA_CTX;
+
+
+//
+// Prototypes of function definition
+//
+
+//
+// Miniport routines in rtmp_main.c
+//
+VOID RTUSBHalt(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	BOOLEAN 		IsFree);
+
+VOID CMDHandler(
+	IN PRTMP_ADAPTER pAd);
+
+INT MlmeThread(
+	IN void * Context);
+
+INT RTUSBCmdThread(
+	IN void * Context);
+
+#if WIRELESS_EXT >= 12
+struct iw_statistics *rt73_get_wireless_stats(
+	IN	struct net_device *net_dev);
+#endif
+
+struct net_device_stats *rt73_get_ether_stats(
+	IN	struct net_device *net_dev);
+
+long rt_abs(long arg);
+
+
+//
+// Routines in rtmp_init.c
+//
+VOID CreateThreads( struct net_device *net_dev );
+
+NDIS_STATUS NICInitTransmit(
+	IN	PRTMP_ADAPTER	 pAd );
+
+NDIS_STATUS NICInitRecv(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID ReleaseAdapter(
+	IN	PRTMP_ADAPTER pAd,
+    IN  BOOLEAN         IsFree,
+    IN  BOOLEAN         IsOnlyTx);
+
+NDIS_STATUS	RTMPInitAdapterBlock(
+	IN	PRTMP_ADAPTER	pAd);
+
+NDIS_STATUS	RTUSBWriteHWMACAddress(
+	IN	PRTMP_ADAPTER		pAd);
+
+VOID NICReadEEPROMParameters(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID NICInitAsicFromEEPROM(
+	IN	PRTMP_ADAPTER	pAd);
+
+NDIS_STATUS	NICInitializeAsic(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID NICIssueReset(
+	IN	PRTMP_ADAPTER	pAd);
+
+BOOLEAN	NICCheckForHang(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID NICUpdateRawCounters(
+	IN PRTMP_ADAPTER pAd);
+
+VOID NICResetFromError(
+	IN	PRTMP_ADAPTER	pAd);
+
+INT LoadFirmware (IN PRTMP_ADAPTER pAd, char *firmName);
+
+PUCHAR RTMPFindSection(
+	IN	PCHAR	buffer);
+
+#ifndef BIG_ENDIAN
+ULONG	RTMPEqualMemory(
+	IN	PVOID	pSrc1,
+	IN	PVOID	pSrc2,
+	IN	ULONG	Length);
+#endif
+
+ULONG	RTMPCompareMemory(
+	IN	PVOID	pSrc1,
+	IN	PVOID	pSrc2,
+	IN	ULONG	Length);
+
+VOID	RTMPZeroMemory(
+	IN	PVOID	pSrc,
+	IN	ULONG	Length);
+
+VOID	RTMPFillMemory(
+	IN	PVOID	pSrc,
+	IN	ULONG	Length,
+	IN	UCHAR	Fill);
+
+VOID	RTMPMoveMemory(
+	OUT PVOID	pDest,
+	IN	PVOID	pSrc,
+	IN	ULONG	Length);
+
+VOID	PortCfgInit(
+	IN	PRTMP_ADAPTER pAd);
+
+UCHAR BtoH(
+	IN CHAR		ch);
+
+VOID AtoH(
+	IN CHAR		*src,
+	OUT UCHAR	*dest,
+	IN INT		destlen);
+
+VOID	RTMPPatchMacBbpBug(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTMPusecDelay(
+	IN	ULONG	usec);
+
+VOID	RTMPSetLED(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Status);
+
+VOID RTMPSetSignalLED(
+	IN PRTMP_ADAPTER	pAd,
+	IN NDIS_802_11_RSSI Dbm);
+
+VOID RTMPCckBbpTuning(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UINT			TxRate);
+
+VOID	RTMPInitTimer(
+	IN	PRTMP_ADAPTER			pAd,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	PVOID					pTimerFunc);
+
+VOID	RTMPSetTimer(
+	IN	PRTMP_ADAPTER			pAd,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	ULONG					Value);
+
+INT	RTMPCancelTimer(
+	IN	PRALINK_TIMER_STRUCT	pTimer);
+
+char * rtstrstr(const char * s1,const char * s2);
+
+
+//
+// MLME routines
+//
+
+// Asic/RF/BBP related functions
+VOID AsicSwitchChannel(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 Channel);
+
+VOID AsicLockChannel(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 Channel);
+
+VOID AsicAntennaSelect(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Channel);
+
+VOID AsicAntennaSetting(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ABGBAND_STATE	BandState);
+
+VOID AsicAdjustTxPower(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicSleepThenAutoWakeup(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT		 TbttNumToNextWakeUp);
+
+VOID AsicForceSleep(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicForceWakeup(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicSetBssid(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR		 pBssid);
+
+VOID AsicDisableSync(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicEnableBssSync(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicEnableIbssSync(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicSetEdcaParm(
+	IN PRTMP_ADAPTER pAd,
+	IN PEDCA_PARM	 pEdcaParm);
+
+VOID AsicSetSlotTime(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN		 bUseShortSlotTime);
+
+VOID AsicBbpTuning(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicAddSharedKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 BssIndex,
+	IN UCHAR		 KeyIdx,
+	IN UCHAR		 CipherAlg,
+	IN PUCHAR		 pKey,
+	IN PUCHAR		 pTxMic,
+	IN PUCHAR		 pRxMic);
+
+VOID AsicRemoveSharedKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 BssIndex,
+	IN UCHAR		 KeyIdx);
+
+VOID AsicAddPairwiseKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR		 pAddr,
+	IN UCHAR		 KeyIdx,
+	IN UCHAR		 CipherAlg,
+	IN PUCHAR		 pKey,
+	IN PUCHAR		 pTxMic,
+	IN PUCHAR		 pRxMic);
+
+VOID AsicRemovePairwiseKeyEntry(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR		 KeyIdx);
+
+VOID	RTMPCheckRates(
+	IN		PRTMP_ADAPTER	pAd,
+	IN OUT	UCHAR			SupRate[],
+	IN OUT	UCHAR			*SupRateLen);
+
+VOID AsicSetRxAnt(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Pair1,
+	IN UCHAR			Pair2);
+
+VOID AsicEvaluateSecondaryRxAnt(
+	IN PRTMP_ADAPTER pAd);
+
+VOID AsicRxAntEvalTimeout(
+	IN	unsigned long data);
+
+VOID AsicRxAntEvalAction(
+	IN PRTMP_ADAPTER pAd);
+
+UCHAR RandomByte(
+	IN PRTMP_ADAPTER pAd);
+
+VOID StaQuickResponeForRateUpExec(
+	IN	unsigned long data);
+
+VOID BssTableInit(
+	IN BSS_TABLE *Tab);
+
+ULONG BssTableSearch(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 pBssid,
+	IN UCHAR	 Channel);
+
+ULONG BssSsidTableSearch(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 pBssid,
+	IN PUCHAR	 pSsid,
+	IN UCHAR	 SsidLen,
+	IN UCHAR	 Channel);
+
+ULONG BssTableSearchWithSSID(
+	IN BSS_TABLE *Tab,
+	IN PUCHAR	 Bssid,
+	IN PUCHAR	 pSsid,
+	IN UCHAR	 SsidLen,
+	IN UCHAR	 Channel);
+
+VOID BssTableDeleteEntry(
+	IN OUT	BSS_TABLE *Tab,
+	IN		PUCHAR	  pBssid,
+	IN		UCHAR	  Channel);
+
+VOID BssEntrySet(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_ENTRY *pBss,
+	IN PUCHAR pBssid,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN USHORT BeaconPeriod,
+	IN PCF_PARM pCfParm,
+	IN USHORT AtimWin,
+	IN USHORT CapabilityInfo,
+	IN UCHAR SupRate[],
+	IN UCHAR SupRateLen,
+	IN UCHAR ExtRate[],
+	IN UCHAR ExtRateLen,
+	IN UCHAR Channel,
+	IN UCHAR Rssi,
+	IN LARGE_INTEGER TimeStamp,
+	IN UCHAR CkipFlag,
+	IN PEDCA_PARM pEdcaParm,
+	IN PQOS_CAPABILITY_PARM pQosCapability,
+	IN PQBSS_LOAD_PARM pQbssLoad,
+	IN UCHAR LengthVIE,
+	IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+ULONG BssTableSetEntry(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_TABLE *Tab,
+	IN PUCHAR pBssid,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN USHORT BeaconPeriod,
+	IN CF_PARM *CfParm,
+	IN USHORT AtimWin,
+	IN USHORT CapabilityInfo,
+	IN UCHAR SupRate[],
+	IN UCHAR SupRateLen,
+	IN UCHAR ExtRate[],
+	IN UCHAR ExtRateLen,
+	IN UCHAR ChannelNo,
+	IN UCHAR Rssi,
+	IN LARGE_INTEGER TimeStamp,
+	IN UCHAR CkipFlag,
+	IN PEDCA_PARM pEdcaParm,
+	IN PQOS_CAPABILITY_PARM pQosCapability,
+	IN PQBSS_LOAD_PARM pQbssLoad,
+	IN UCHAR LengthVIE,
+	IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+VOID BssTableSsidSort(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT BSS_TABLE *OutTab,
+	IN	CHAR Ssid[],
+	IN	UCHAR SsidLen);
+
+VOID BssTableSortByRssi(
+	IN OUT BSS_TABLE *OutTab);
+
+VOID BssCipherParse(
+	IN OUT	PBSS_ENTRY	pBss);
+
+VOID MacAddrRandomBssid(
+	IN PRTMP_ADAPTER pAd,
+	OUT PUCHAR pAddr);
+
+VOID MgtMacHeaderInit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN OUT PHEADER_802_11 pHdr80211,
+	IN UCHAR SubType,
+	IN UCHAR ToDs,
+	IN PUCHAR pDA,
+	IN PUCHAR pBssid);
+
+ULONG MakeOutgoingFrame(
+	OUT CHAR *Buffer,
+	OUT ULONG *FrameLen, ...);
+
+NDIS_STATUS MlmeInit(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeHandler(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeHalt(
+	IN PRTMP_ADAPTER pAd) ;
+
+VOID MlmeSuspend(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN linkdown);
+
+VOID MlmeResume(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID MlmePeriodicExec(
+	IN	unsigned long data);
+
+VOID STAMlmePeriodicExec(
+	IN	PRTMP_ADAPTER pAd);
+
+VOID LinkDownExec(
+	IN	unsigned long data);
+
+VOID MlmeAutoScan(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeAutoRecoverNetwork(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeAutoReconnectLastSSID(
+	IN PRTMP_ADAPTER pAd);
+
+BOOLEAN	MlmeValidateSSID(
+	IN PUCHAR	pSsid,
+	IN UCHAR	SsidLen);
+
+VOID MlmeCheckForRoaming(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now);
+
+VOID MlmeCheckForFastRoaming(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now);
+
+VOID MlmeCalculateChannelQuality(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now);
+
+VOID MlmeDynamicTxRateSwitching(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeCheckPsmChange(
+	IN PRTMP_ADAPTER pAd,
+	IN unsigned long Now);
+
+VOID MlmeSetPsmBit(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT psm);
+
+VOID MlmeSetTxPreamble(
+	IN PRTMP_ADAPTER pAd,
+	IN USHORT TxPreamble);
+
+VOID MlmeUpdateTxRates(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN		 bLinkUp);
+
+VOID MlmeRadioOff(
+	IN PRTMP_ADAPTER pAd);
+
+VOID MlmeRadioOn(
+	IN PRTMP_ADAPTER pAd);
+
+NDIS_STATUS MlmeQueueInit(
+	IN MLME_QUEUE *Queue);
+
+BOOLEAN MlmeEnqueue(
+	IN	PRTMP_ADAPTER	pAd,
+	IN ULONG Machine,
+	IN ULONG MsgType,
+	IN ULONG MsgLen,
+	IN VOID *Msg);
+
+BOOLEAN MlmeEnqueueForRecv(
+	IN	PRTMP_ADAPTER	pAd,
+	IN UCHAR Rssi,
+	IN ULONG MsgLen,
+	IN VOID *Msg,
+	IN UCHAR Signal);
+
+BOOLEAN MlmeDequeue(
+	IN MLME_QUEUE *Queue,
+	OUT MLME_QUEUE_ELEM **Elem);
+
+VOID MlmeRestartStateMachine(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID MlmePostRestartStateMachine(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID MlmeQueueDestroy(
+	IN MLME_QUEUE *pQueue);
+
+BOOLEAN MsgTypeSubst(
+	IN PRTMP_ADAPTER  pAd,
+	IN PFRAME_802_11 pFrame,
+	OUT INT *Machine,
+	OUT INT *MsgType);
+
+VOID StateMachineInit(
+	IN STATE_MACHINE *S,
+	IN STATE_MACHINE_FUNC Trans[],
+	IN ULONG StNr,
+	IN ULONG MsgNr,
+	IN STATE_MACHINE_FUNC DefFunc,
+	IN ULONG InitState,
+	IN ULONG Base);
+
+VOID StateMachineSetAction(
+	IN STATE_MACHINE *S,
+	IN ULONG St,
+	IN ULONG Msg,
+	IN STATE_MACHINE_FUNC Func);
+
+VOID StateMachinePerformAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN STATE_MACHINE *S,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID Drop(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID LfsrInit(
+	IN PRTMP_ADAPTER pAd,
+	IN ULONG Seed);
+
+NDIS_STATUS MlmeAllocateMemory(
+	IN PRTMP_ADAPTER pAd,
+	OUT PVOID		 *AllocVa);
+
+VOID	MlmeFreeMemory(
+	IN PRTMP_ADAPTER pAd,
+	IN PVOID		 AllocVa);
+
+NDIS_STATUS MlmeInitMemoryHandler(
+	IN PRTMP_ADAPTER pAd,
+	IN UINT  Number,
+	IN UINT  Size);
+
+VOID MlmeFreeMemoryHandler(
+	IN PRTMP_ADAPTER pAd);
+
+VOID RadarDetectionStart(
+	IN PRTMP_ADAPTER	pAd);
+
+BOOLEAN RadarDetectionStop(
+	IN PRTMP_ADAPTER	pAd);
+
+BOOLEAN RadarChannelCheck(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Ch);
+
+
+// Assoc/Auth/Auth_rsp related functions
+VOID AssocStateMachineInit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	STATE_MACHINE *S,
+	OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID AssocTimeout(
+	IN	unsigned long data);
+
+VOID ReassocTimeout(
+	IN	unsigned long data);
+
+VOID DisassocTimeout(
+	IN	unsigned long data);
+
+VOID MlmeAssocReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID MlmeReassocReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID MlmeDisassocReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAssocRspAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerReassocRspAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID AssocPostProc(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR pAddr2,
+	IN USHORT CapabilityInfo,
+	IN USHORT Aid,
+	IN UCHAR SupRate[],
+	IN UCHAR SupRateLen,
+	IN UCHAR ExtRate[],
+	IN UCHAR ExtRateLen,
+	IN PEDCA_PARM pEdcaParm);
+
+VOID PeerDisassocAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID AssocTimeoutAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID ReassocTimeoutAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID DisassocTimeoutAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenAssoc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenReassoc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenDisassociate(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID Cls3errAction(
+	IN PRTMP_ADAPTER pAd,
+	IN PUCHAR	   pAddr);
+
+VOID AuthStateMachineInit(
+	IN PRTMP_ADAPTER pAd,
+	IN PSTATE_MACHINE Sm,
+	OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID AuthTimeout(
+	IN	unsigned long data);
+
+VOID MlmeAuthReqAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthRspAtSeq2Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthRspAtSeq4Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID AuthTimeoutAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID Cls2errAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR pAddr);
+
+VOID MlmeDeauthReqAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenAuth(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID AuthRspStateMachineInit(
+	IN PRTMP_ADAPTER pAd,
+	IN PSTATE_MACHINE Sm,
+	IN STATE_MACHINE_FUNC Trans[]);
+
+VOID PeerAuthSimpleRspGenAndSend(
+	IN PRTMP_ADAPTER pAd,
+	IN PHEADER_802_11 pHdr80211,
+	IN USHORT Alg,
+	IN USHORT Seq,
+	IN USHORT Reason,
+	IN USHORT Status);
+
+VOID PeerDeauthAction(
+	IN PRTMP_ADAPTER pAd,
+	IN PMLME_QUEUE_ELEM Elem);
+
+VOID MlmeCntlInit(
+	IN PRTMP_ADAPTER pAd,
+	IN STATE_MACHINE *S,
+	OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID MlmeCntlMachinePerformAction(
+	IN PRTMP_ADAPTER pAd,
+	IN STATE_MACHINE *S,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlIdleProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlOidScanProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlOidSsidProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlOidRTBssidProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlMlmeRoamingProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitDisassocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitJoinProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitStartProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAuthProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAuthProc2(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAssocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitReassocProc(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID LinkUp(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR BssType);
+
+VOID LinkDown(
+	IN PRTMP_ADAPTER pAd,
+	IN	BOOLEAN 	 IsReqFromAP);
+
+VOID IterateOnBssTab(
+	IN PRTMP_ADAPTER pAd);
+
+VOID IterateOnBssTab2(
+	IN PRTMP_ADAPTER pAd);
+
+VOID JoinParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_JOIN_REQ_STRUCT *JoinReq,
+	IN ULONG BssIdx);
+
+VOID AssocParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq,
+	IN PUCHAR					  pAddr,
+	IN USHORT					  CapabilityInfo,
+	IN ULONG					  Timeout,
+	IN USHORT					  ListenIntv);
+
+VOID ScanParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_SCAN_REQ_STRUCT *ScanReq,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen,
+	IN UCHAR BssType,
+	IN UCHAR ScanType);
+
+VOID DisassocParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq,
+	IN PUCHAR pAddr,
+	IN USHORT Reason);
+
+VOID StartParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_START_REQ_STRUCT *StartReq,
+	IN CHAR Ssid[],
+	IN UCHAR SsidLen);
+
+VOID AuthParmFill(
+	IN PRTMP_ADAPTER pAd,
+	IN OUT MLME_AUTH_REQ_STRUCT *AuthReq,
+	IN PUCHAR pAddr,
+	IN USHORT Alg);
+
+VOID ComposePsPoll(
+	IN PRTMP_ADAPTER pAd);
+
+VOID ComposeNullFrame(
+	IN PRTMP_ADAPTER pAd);
+
+ULONG MakeIbssBeacon(
+	IN PRTMP_ADAPTER pAd);
+
+//
+// Private routines in Sync.c
+//
+VOID SyncStateMachineInit(
+	IN PRTMP_ADAPTER pAd,
+	IN STATE_MACHINE *Sm,
+	OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID BeaconTimeout(
+	IN	unsigned long data);
+
+VOID ScanTimeout(
+	IN	unsigned long data) ;
+
+VOID MlmeScanReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID MlmeJoinReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID MlmeStartReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeaconAtScanAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeaconAtJoinAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeacon(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerProbeReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID BeaconTimeoutAtJoinAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID ScanTimeoutAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID ScanNextChannel(
+	IN PRTMP_ADAPTER pAd);
+
+VOID InvalidStateWhenScan(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenJoin(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenStart(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem);
+
+VOID EnqueuePsPoll(
+	IN PRTMP_ADAPTER pAd);
+
+VOID EnqueueBeaconFrame(
+	IN PRTMP_ADAPTER pAd);
+
+VOID EnqueueProbeRequest(
+	IN PRTMP_ADAPTER pAd);
+
+VOID BuildChannelList(
+	IN PRTMP_ADAPTER pAd);
+
+UCHAR NextChannel(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR channel);
+
+UCHAR FirstChannel(
+	IN PRTMP_ADAPTER pAd);
+
+CHAR	ConvertToRssi(
+	IN PRTMP_ADAPTER pAd,
+	IN	UCHAR	Rssi,
+	IN	UCHAR	RssiNumber);
+
+//
+// prototypes in sanity.c
+//
+BOOLEAN MlmeScanReqSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT UCHAR *pBssType,
+	OUT CHAR Ssid[],
+	OUT UCHAR *pSsidLen,
+	OUT UCHAR *pScanType);
+
+BOOLEAN MlmeStartReqSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT CHAR Ssid[],
+	OUT UCHAR *pSsidLen);
+
+BOOLEAN MlmeAssocReqSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pApAddr,
+	OUT USHORT *pCapabilityInfo,
+	OUT ULONG *pTimeout,
+	OUT USHORT *pListenIntv);
+
+BOOLEAN MlmeAuthReqSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr,
+	OUT ULONG *pTimeout,
+	OUT USHORT *pAlg);
+
+BOOLEAN PeerAssocRspSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *pMsg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT USHORT *pCapabilityInfo,
+	OUT USHORT *pStatus,
+	OUT USHORT *pAid,
+	OUT UCHAR SupRate[],
+	OUT UCHAR *pSupRateLen,
+	OUT UCHAR ExtRate[],
+	OUT UCHAR *pExtRateLen,
+	OUT PEDCA_PARM pEdcaParm);
+
+BOOLEAN PeerDisassocSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT USHORT *pReason);
+
+BOOLEAN PeerDeauthSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT USHORT *pReason);
+
+BOOLEAN PeerAuthSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr,
+	OUT USHORT *pAlg,
+	OUT USHORT *pSeq,
+	OUT USHORT *pStatus,
+	CHAR *pChlgText);
+
+BOOLEAN PeerProbeReqSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT CHAR Ssid[],
+	OUT UCHAR *pSsidLen);
+
+BOOLEAN PeerBeaconAndProbeRspSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT PUCHAR pBssid,
+	OUT CHAR Ssid[],
+	OUT UCHAR *pSsidLen,
+	OUT UCHAR *pBssType,
+	OUT USHORT *pBeaconPeriod,
+	OUT UCHAR *pChannel,
+	OUT UCHAR *pNewChannel,
+	OUT LARGE_INTEGER *pTimestamp,
+	OUT CF_PARM *pCfParm,
+	OUT USHORT *pAtimWin,
+	OUT USHORT *pCapabilityInfo,
+	OUT UCHAR *pErp,
+	OUT UCHAR *pDtimCount,
+	OUT UCHAR *pDtimPeriod,
+	OUT UCHAR *pBcastFlag,
+	OUT UCHAR *pMessageToMe,
+	OUT UCHAR SupRate[],
+	OUT UCHAR *pSupRateLen,
+	OUT UCHAR ExtRate[],
+	OUT UCHAR *pExtRateLen,
+	OUT	UCHAR *pCkipFlag,
+	OUT	UCHAR *pAironetCellPowerLimit,
+	OUT PEDCA_PARM		 pEdcaParm,
+	OUT PQBSS_LOAD_PARM  pQbssLoad,
+	OUT PQOS_CAPABILITY_PARM pQosCapability,
+	OUT ULONG *pRalinkIe,
+	OUT UCHAR *LengthVIE,
+	OUT	PNDIS_802_11_VARIABLE_IEs pVIE);
+
+BOOLEAN GetTimBit(
+	IN CHAR *Ptr,
+	IN USHORT Aid,
+	OUT UCHAR *TimLen,
+	OUT UCHAR *BcastFlag,
+	OUT UCHAR *DtimCount,
+	OUT UCHAR *DtimPeriod,
+	OUT UCHAR *MessageToMe);
+
+UCHAR ChannelSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN UCHAR channel);
+
+NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
+	IN UCHAR  Channel,
+	IN UCHAR  SupRate[],
+	IN UCHAR  SupRateLen,
+	IN UCHAR  ExtRate[],
+	IN UCHAR  ExtRateLen);
+
+ UCHAR PeerTxTypeInUseSanity(
+	IN UCHAR  Channel,
+	IN UCHAR  SupRate[],
+	IN UCHAR  SupRateLen,
+	IN UCHAR  ExtRate[],
+	IN UCHAR  ExtRateLen);
+
+NDIS_STATUS	RTMPWPAWepKeySanity(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+NDIS_STATUS	RTMPRemoveKeySanity(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+
+//
+// prototypes in rtusb_bulk.c
+//
+VOID	RTUSBBulkOutDataPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			BulkOutPipeId,
+	IN	UCHAR			Index);
+
+VOID	RTUSBBulkOutNullFrame(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBBulkOutRTSFrame(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBBulkOutMLMEPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Index);
+
+VOID	RTUSBBulkOutPsPoll(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	rtusb_bulkrx(
+	IN 	unsigned long	data);
+
+VOID	RTUSBBulkReceive(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBKickBulkOut(
+	IN	PRTMP_ADAPTER pAd);
+
+VOID	RTUSBCleanUpDataBulkOutQueue(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBCleanUpMLMEBulkOutQueue(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBCancelPendingIRPs(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID RTUSBCancelPendingBulkOutIRP(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBCancelPendingBulkInIRP(
+	IN	PRTMP_ADAPTER	pAd);
+
+
+// macro definitions and prototypes of completion funuc.
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#define RTUSBBulkOutDataPacketComplete(purb, pt_regs)    RTUSBBulkOutDataPacketComplete(purb)
+#define RTUSBBulkOutNullFrameComplete(pUrb, pt_regs)     RTUSBBulkOutNullFrameComplete(pUrb)
+#define RTUSBBulkOutRTSFrameComplete(pUrb, pt_regs)      RTUSBBulkOutRTSFrameComplete(pUrb)
+#define RTUSBBulkOutMLMEPacketComplete(pUrb, pt_regs)    RTUSBBulkOutMLMEPacketComplete(pUrb)
+#define RTUSBBulkOutPsPollComplete(pUrb, pt_regs)        RTUSBBulkOutPsPollComplete(pUrb)
+#define RTUSBBulkRxComplete(pUrb, pt_regs)               RTUSBBulkRxComplete(pUrb)
+#endif
+VOID RTUSBBulkOutDataPacketComplete(purbb_t purb, struct pt_regs *pt_regs);
+VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs);
+VOID RTUSBBulkOutRTSFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs);
+VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs);
+VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb, struct pt_regs *pt_regs);
+VOID RTUSBBulkRxComplete(purbb_t pUrb, struct pt_regs *pt_regs);
+
+
+//
+// prototypes in rtusb_io.c
+//
+NTSTATUS	RTUSBFirmwareRun(
+	IN	PRTMP_ADAPTER	pAd);
+
+NTSTATUS	RTUSBMultiRead(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PVOID			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBMultiWrite(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	PVOID			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBReadMACRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PULONG			pValue);
+
+NTSTATUS	RT73WriteTXRXCSR0(
+	IN	PRTMP_ADAPTER pAd,
+	IN	BOOLEAN 	disableRx,
+	IN	BOOLEAN		dropControl);
+
+NTSTATUS	RTUSBWriteMACRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	ULONG			Value);
+
+NTSTATUS	RTUSBSetLED(
+	IN	PRTMP_ADAPTER		pAd,
+	IN	MCU_LEDCS_STRUC		LedStatus,
+	IN	USHORT				LedIndicatorStrength);
+
+NTSTATUS	RTUSBReadBBPRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Id,
+	IN	PUCHAR			pValue);
+
+NTSTATUS	RTUSBWriteBBPRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Id,
+	IN	UCHAR			Value);
+
+NTSTATUS	RTUSBWriteRFRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			Value);
+
+NTSTATUS	RTUSBReadEEPROM(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PVOID			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBWriteEEPROM(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	PVOID			pData,
+	IN	USHORT			length);
+
+NTSTATUS RTUSBPutToSleep(
+	IN	PRTMP_ADAPTER	pAd);
+
+NTSTATUS RTUSBWakeUp(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBInitializeCmdQ(
+	IN	PCmdQ	cmdq);
+
+NDIS_STATUS		RTUSBEnqueueCmdFromNdis(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	NDIS_OID		Oid,
+	IN	BOOLEAN			SetInformation,
+	IN	PVOID			pInformationBuffer,
+	IN	ULONG			InformationBufferLength);
+
+VOID	RTUSBEnqueueInternalCmd(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	NDIS_OID		Oid);
+
+VOID	RTUSBDequeueCmd(
+	IN	PCmdQ		cmdq,
+	OUT	PCmdQElmt	*pcmdqelmt);
+
+INT		RTUSB_VendorRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			TransferFlags,
+	IN	UCHAR			RequestType,
+	IN	UCHAR			Request,
+	IN	USHORT			Value,
+	IN	USHORT			Index,
+	IN	PVOID			TransferBuffer,
+	IN	ULONG			TransferBufferLength);
+
+NTSTATUS	RTUSB_ResetDevice(
+	IN	PRTMP_ADAPTER	pAd);
+#ifdef DBG
+NDIS_STATUS 	RTUSBQueryHardWareRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+NDIS_STATUS 	RTUSBSetHardWareRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+#endif
+
+//
+// prototypes  in rtusb_data.c
+//
+NDIS_STATUS Sniff2BytesFromNdisBuffer(
+	IN	struct sk_buff	*pFirstSkb,
+	IN	UCHAR			DesiredOffset,
+	OUT PUCHAR			pByte0,
+	OUT PUCHAR			pByte1);
+
+NDIS_STATUS	RTMPSendPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb);
+
+INT RTMPSendPackets(
+	IN	struct sk_buff		*pSkb,
+	IN	struct net_device	*net_dev);
+
+#ifndef BIG_ENDIAN
+NDIS_STATUS RTUSBHardTransmit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb,
+	IN	UCHAR			NumberRequired,
+	IN	UCHAR			QueIdx);
+#endif
+
+VOID	RTUSBMlmeHardTransmit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PMGMT_STRUC		pMgmt);
+
+NDIS_STATUS	RTUSBFreeDescriptorRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			RingType,
+	IN	UCHAR			BulkOutPipeId,
+	IN	UCHAR			NumberRequired);
+
+VOID	RTUSBRejectPendingPackets(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBWriteTxDescriptor(
+	IN	PRTMP_ADAPTER pAd,
+	IN	PTXD_STRUC	pSourceTxD,
+	IN	UCHAR		CipherAlg,
+	IN	UCHAR		KeyTable,
+	IN	UCHAR		KeyIdx,
+	IN	BOOLEAN		Ack,
+	IN	BOOLEAN		Fragment,
+	IN	BOOLEAN 	InsTimestamp,
+	IN	UCHAR		RetryMode,
+	IN	UCHAR		Ifs,
+	IN	UINT		Rate,
+	IN	ULONG		Length,
+	IN	UCHAR		QueIdx,
+	IN	UCHAR		PID,
+    IN  BOOLEAN     bAfterRTSCTS);
+
+VOID	RTMPDeQueuePacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			BulkOutPipeId);
+
+VOID	RTUSBRxPacket(
+	IN	 unsigned long data);
+
+VOID	RTUSBDequeueMLMEPacket(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBCleanUpMLMEWaitQueue(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBSuspendMsduTransmission(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	RTUSBResumeMsduTransmission(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID	MiniportMMRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuffer,
+	IN	ULONG			Length);
+
+BOOLEAN	RTMPSearchTupleCache(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader);
+
+VOID	RTMPUpdateTupleCache(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader);
+
+NDIS_STATUS	RTMPApplyPacketFilter(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PRXD_STRUC		pRxD,
+	IN	PHEADER_802_11	pHeader);
+
+NDIS_STATUS	RTMPCheckRxDescriptor(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader,
+	IN	PRXD_STRUC	pRxD);
+
+VOID	RTMPReportMicError(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PCIPHER_KEY		pWpaKey);
+
+VOID	RTMPSendNullFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			TxRate);
+
+VOID	RTMPSendRTSCTSFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			pDA,
+	IN	ULONG			NextMpduSize,
+	IN	UCHAR			TxRate,
+	IN	UCHAR			RTSRate,
+	IN	USHORT			AckDuration,
+	IN	UCHAR			QueIdx,
+	IN	UCHAR			FrameGap,
+	IN	UCHAR			Type);
+
+USHORT	RTMPCalcDuration(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Rate,
+	IN	ULONG			Size);
+
+BOOLEAN 	RTMPCheckDHCPFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb);
+
+
+//
+// prototypes in rtmp_wep.c
+//
+VOID	RTMPInitWepEngine(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pKey,
+	IN	UCHAR			KeyId,
+	IN	UCHAR			KeyLen,
+	IN OUT	PUCHAR		pDest);
+
+VOID	RTMPEncryptData(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDest,
+	IN	UINT			Len);
+
+VOID	ARCFOUR_INIT(
+	IN	PARCFOURCONTEXT Ctx,
+	IN	PUCHAR			pKey,
+	IN	UINT			KeyLen);
+
+UCHAR	ARCFOUR_BYTE(
+	IN	PARCFOURCONTEXT 	Ctx);
+
+VOID	ARCFOUR_DECRYPT(
+	IN	PARCFOURCONTEXT Ctx,
+	IN	PUCHAR			pDest,
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len);
+
+VOID	ARCFOUR_ENCRYPT(
+	IN	PARCFOURCONTEXT Ctx,
+	IN	PUCHAR			pDest,
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len);
+
+ULONG	RTMP_CALC_FCS32(
+	IN	ULONG	Fcs,
+	IN	PUCHAR	Cp,
+	IN	INT 	Len);
+
+VOID	RTMPSetICV(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR	pDest);
+
+//
+// prototypes in rtmp_tkip.c
+//
+VOID	RTMPInitTkipEngine(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pTKey,
+	IN	UCHAR			KeyId,
+	IN	PUCHAR			pTA,
+	IN	PUCHAR			pMICKey,
+	IN	PUCHAR			pTSC,
+	OUT PULONG			pIV16,
+	OUT PULONG			pIV32);
+
+VOID	RTMPInitMICEngine(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pKey,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	UCHAR			UserPriority,
+	IN	PUCHAR			pMICKey);
+
+BOOLEAN RTMPTkipCompareMICValue(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len);
+
+VOID	RTMPCalculateMICValue(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct sk_buff	*pSkb,
+	IN	PUCHAR			pEncap,
+	IN	PCIPHER_KEY		pKey);
+
+BOOLEAN	RTMPTkipCompareMICValueWithLLC(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pLLC,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len);
+
+VOID	RTMPTkipAppend(
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	PUCHAR			pSrc,
+	IN	UINT			nBytes);
+
+VOID	RTMPTkipGetMIC(
+	IN	PTKIP_KEY_INFO	pTkip);
+
+//
+// prototypes in wpa.c
+//
+BOOLEAN WpaMsgTypeSubst(
+	IN	UCHAR	EAPType,
+	OUT ULONG	*MsgType);
+
+VOID WpaPskStateMachineInit(
+	IN	PRTMP_ADAPTER		pAd,
+	IN	STATE_MACHINE		*S,
+	OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID WpaEAPOLKeyAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID	WpaPairMsg1Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID	WpaPairMsg3Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID	WpaGroupMsg1Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID	WpaMacHeaderInit(
+	IN		PRTMP_ADAPTER	pAd,
+	IN OUT	PHEADER_802_11	pHdr80211,
+	IN		UCHAR			wep,
+	IN		PUCHAR			pAddr1);
+
+VOID	Wpa2PairMsg1Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID	Wpa2PairMsg3Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM *Elem);
+
+VOID ParseKeyData(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			pKeyData,
+	IN	UCHAR			KeyDataLen);
+
+VOID WPAMake8023Hdr(
+	IN PRTMP_ADAPTER	pAd,
+	IN PCHAR			pDAddr,
+	IN OUT PCHAR		pHdr);
+
+VOID RTMPToWirelessSta(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pFrame,
+	IN	UINT			FrameLen);
+
+VOID	HMAC_SHA1(
+	IN	UCHAR	*text,
+	IN	UINT	text_len,
+	IN	UCHAR	*key,
+	IN	UINT	key_len,
+	IN	UCHAR	*digest);
+
+VOID	PRF(
+	IN	UCHAR	*key,
+	IN	INT 	key_len,
+	IN	UCHAR	*prefix,
+	IN	INT 	prefix_len,
+	IN	UCHAR	*data,
+	IN	INT 	data_len,
+	OUT UCHAR	*output,
+	IN	INT 	len);
+
+VOID WpaCountPTK(
+	IN	UCHAR	*PMK,
+	IN	UCHAR	*ANonce,
+	IN	UCHAR	*AA,
+	IN	UCHAR	*SNonce,
+	IN	UCHAR	*SA,
+	OUT UCHAR	*output,
+	IN	UINT	len);
+
+VOID	GenRandom(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT UCHAR			*random);
+
+VOID	AES_GTK_KEY_UNWRAP(
+	IN	UCHAR	*key,
+	OUT UCHAR	*plaintext,
+	IN UCHAR	c_len,
+	IN	UCHAR	*ciphertext);
+
+//#if WPA_SUPPLICANT_SUPPORT
+INT	RTMPCheckWPAframeForEapCode(
+	IN PRTMP_ADAPTER   		pAd,
+	IN PUCHAR				pFrame,
+	IN ULONG				FrameLen,
+	IN ULONG				OffSet);
+//#endif
+
+//
+// prototypes for *iwpriv* in rtmp_info.c
+//
+INT rt73_ioctl(
+	IN	struct net_device	*net_dev,
+	IN	OUT	struct ifreq	*rq,
+	IN	INT					cmd);
+
+INT RTMPSetInformation(
+	IN	PRTMP_ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 			cmd);
+
+INT RTMPQueryInformation(
+	IN	PRTMP_ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 			cmd);
+
+NDIS_STATUS	RTMPWPAAddKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+NDIS_STATUS	RTMPWPARemoveKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+VOID	RTMPWPARemoveAllKeys(
+	IN	PRTMP_ADAPTER	pAd);
+
+VOID RTMPIndicateWPA2Status(
+	IN	PRTMP_ADAPTER  pAd);
+
+VOID	RTMPSetPhyMode(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			phymode);
+
+VOID	RTMPSetDesiredRates(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	LONG			Rates);
+
+INT Set_DriverVersion_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+
+INT Set_CountryRegion_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+
+INT Set_CountryRegionABand_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+
+INT Set_SSID_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_WirelessMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_TxRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_AdhocModeRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_Channel_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+#ifdef DBG
+INT	Set_Debug_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+#endif	//#ifdef DBG
+
+INT Set_BGProtection_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_TxPreamble_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_RTSThreshold_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_FragThreshold_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_TxBurst_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+#ifdef AGGREGATION_SUPPORT
+INT	Set_PktAggregate_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+#endif	/* AGGREGATION_SUPPORT */
+
+INT Set_TurboRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+#if 0
+INT	Set_WmmCapable_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+#endif
+
+INT Set_ShortSlot_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT	Set_IEEE80211H_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+
+INT Set_NetworkType_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_AuthMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_EncrypType_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_DefaultKeyID_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_Key1_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_Key2_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_Key3_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_Key4_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT Set_WPAPSK_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+INT	Set_ResetStatCounter_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg);
+
+INT Set_PSMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg);
+
+#ifdef DBG
+VOID RTMPIoctlBBP(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPIoctlMAC(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+#endif //#ifdef DBG
+INT  RTMPIoctlAdhocOfdm(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPIoctlSetRFMONTx(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPIoctlGetRFMONTx(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT	struct iwreq	*wrq);
+
+VOID RTMPIoctlForcePrismHeader(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPIoctlWriteMAC(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq);
+
+
+VOID RTMPIoctlStatistics(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPIoctlGetSiteSurvey(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+VOID RTMPMakeRSNIE(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	UCHAR			GroupCipher);
+
+NDIS_STATUS RTMPWPANoneAddKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf);
+
+#if 1
+INT RTMPIoctlSetAuth(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+INT RTMPIoctlSetKeyId(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+INT RTMPIoctlSetEncryp(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+INT RTMPIoctlSetWpapsk(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+INT RTMPIoctlSetPsm(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+#endif
+
+#ifdef BIG_ENDIAN
+static inline VOID	RTMPDescriptorEndianChange(
+	IN	PUCHAR			pData,
+	IN	ULONG			DescriptorType)
+{
+	int size = (DescriptorType == TYPE_TXD) ? TXD_SIZE : RXD_SIZE;
+	int i;
+	for (i=1; i<size/4; i++) {
+		/*
+		 * Handle IV and EIV with little endian
+		 */
+		if (DescriptorType == TYPE_TXD) {
+			 /* Skip Word 3 IV and Word 4 EIV of TXD */
+			if (i==3||i==4)
+				continue;
+		}
+		else {
+			 /* Skip Word 2 IV and Word 3 EIV of RXD */
+			if (i==2||i==3)
+				continue;
+		}
+		*((ULONG *)(pData + i*4)) = SWAP32(*((ULONG *)(pData + i*4)));
+	}
+	*(ULONG *)pData = SWAP32(*(ULONG *)pData);	// Word 0; this must be swapped last
+
+}
+
+static inline VOID	WriteBackToDescriptor(
+	IN	PUCHAR			Dest,
+	IN	PUCHAR			Src,
+	IN	BOOLEAN			DoEncrypt,
+	IN	ULONG			DescriptorType)
+{
+	PULONG p1, p2;
+	UCHAR i;
+	int size = (DescriptorType == TYPE_TXD) ? TXD_SIZE : RXD_SIZE;
+
+	p1 = ((PULONG)Dest) + 1;
+	p2 = ((PULONG)Src) + 1;
+	for (i = 1; i < size/4 ; i++)
+		*p1++ = *p2++;
+	*(PULONG)Dest = *(PULONG)Src;		// Word 0; this must be written back last
+}
+
+static inline VOID	RTMPFrameEndianChange(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pData,
+	IN	ULONG			Dir,
+	IN	BOOLEAN 		FromRxDoneInt)
+{
+	PFRAME_802_11	pFrame;
+	PUCHAR			pMacHdr;
+
+	// swab 16 bit fields - Frame Control field
+	if(Dir == DIR_READ)
+	{
+		*(USHORT *)pData = SWAP16(*(USHORT *)pData);
+	}
+
+	pFrame = (PFRAME_802_11) pData;
+	pMacHdr = (PUCHAR) pFrame;
+
+	// swab 16 bit fields - Duration/ID field
+	*(USHORT *)(pMacHdr + 2) = SWAP16(*(USHORT *)(pMacHdr + 2));
+
+	// swab 16 bit fields - Sequence Control field
+	*(USHORT *)(pMacHdr + 22) = SWAP16(*(USHORT *)(pMacHdr + 22));
+
+	if(pFrame->Hdr.FC.Type == BTYPE_MGMT)
+	{
+		switch(pFrame->Hdr.FC.SubType)
+		{
+			case SUBTYPE_ASSOC_REQ:
+			case SUBTYPE_REASSOC_REQ:
+				// swab 16 bit fields - CapabilityInfo field
+				pMacHdr += LENGTH_802_11;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+				// swab 16 bit fields - Listen Interval field
+				pMacHdr += 2;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+				break;
+
+			case SUBTYPE_ASSOC_RSP:
+			case SUBTYPE_REASSOC_RSP:
+				// swab 16 bit fields - CapabilityInfo field
+				pMacHdr += LENGTH_802_11;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+				// swab 16 bit fields - Status Code field
+				pMacHdr += 2;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+				// swab 16 bit fields - AID field
+				pMacHdr += 2;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+				break;
+
+			case SUBTYPE_AUTH:
+				// If from RTMPHandleRxDoneInterrupt routine, it is still a encrypt format.
+				// The convertion is delayed to RTMPHandleDecryptionDoneInterrupt.
+				if(!FromRxDoneInt && pFrame->Hdr.FC.Wep != 1)
+				{
+					// swab 16 bit fields - Auth Alg No. field
+					pMacHdr += LENGTH_802_11;
+					*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+					// swab 16 bit fields - Auth Seq No. field
+					pMacHdr += 2;
+					*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+					// swab 16 bit fields - Status Code field
+					pMacHdr += 2;
+					*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+				}
+				break;
+
+			case SUBTYPE_BEACON:
+			case SUBTYPE_PROBE_RSP:
+				// swab 16 bit fields - BeaconInterval field
+				pMacHdr += LENGTH_802_11 + TIMESTAMP_LEN;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+				// swab 16 bit fields - CapabilityInfo field
+				pMacHdr += sizeof(USHORT);
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+				break;
+
+			case SUBTYPE_DEAUTH:
+			case SUBTYPE_DISASSOC:
+				// swab 16 bit fields - Reason code field
+				pMacHdr += LENGTH_802_11;
+				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+				break;
+		}
+	}
+	else if(pFrame->Hdr.FC.Type == BTYPE_DATA)
+	{
+	}
+	else if(pFrame->Hdr.FC.Type == BTYPE_CNTL)
+	{
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Invalid Frame Type!!!\n");
+	}
+
+	// swab 16 bit fields - Frame Control
+	if(Dir == DIR_WRITE)
+	{
+		*(USHORT *)pData = SWAP16(*(USHORT *)pData);
+	}
+}
+
+static inline ULONG   RTMPEqualMemory(
+	IN	PVOID	pSrc1,
+	IN	PVOID	pSrc2,
+	IN	ULONG	Length)
+{
+	PUCHAR	pMem1;
+	PUCHAR	pMem2;
+	ULONG	Index = 0;
+
+	pMem1 = (PUCHAR) pSrc1;
+	pMem2 = (PUCHAR) pSrc2;
+
+	for (Index = 0; Index < Length; Index++)
+	{
+		if (pMem1[Index] != pMem2[Index])
+		{
+			break;
+		}
+	}
+
+	if (Index == Length)
+	{
+		return (1);
+	}
+	else
+	{
+		return (0);
+	}
+}
+#endif
+
+VOID RTMPIoctlGetRaAPCfg(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq);
+
+BOOLEAN BackDoorProbeRspSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT CHAR *pCfgDataBuf);
+
+#endif /* __RTMP_H__ */
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_def.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_def.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_def.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_def.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,880 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_def.h
+ *
+ *	Abstract: Miniport related definition header
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Lin	08-01-2002	created
+ *	John Chang	08-05-2003	add definition for 11g & other drafts
+ *	idamlaj	04-10-2006	Add extra devices
+ *
+ ***************************************************************************/
+
+#ifndef __RTMP_DEF_H__
+#define __RTMP_DEF_H__
+
+//
+//	Debug information verbosity: lower values indicate higher urgency
+//
+
+#ifdef __BIG_ENDIAN
+#warning "Big endian support is still experimental, use at your own risk."
+#define BIG_ENDIAN
+#endif
+
+#define RT_DEBUG_OFF		0
+#define RT_DEBUG_ERROR		1
+#define RT_DEBUG_WARN		2
+#define RT_DEBUG_TRACE		4
+#define RT_DEBUG_INFO		8
+#define RT_DEBUG_LOUD		16
+
+#ifdef BIG_ENDIAN
+#define DIR_READ					0
+#define DIR_WRITE					1
+#define TYPE_TXD					0
+#define TYPE_RXD					1
+#endif
+
+//WEP
+#define WEP_SMALL_KEY_LEN	(40/8)
+#define WEP_LARGE_KEY_LEN	(104/8)
+
+//
+// Entry number for each DMA descriptor ring
+//
+#define TX_RING_SIZE			32
+#define PRIO_RING_SIZE			16
+#define RX_RING_SIZE			32
+#define	BEACON_RING_SIZE		2
+#define MGMT_RING_SIZE			PRIO_RING_SIZE
+#define PRIO_BUFFER_SIZE		1024	// 2048
+#define BUFFER_SIZE				2400	//2048
+#define	MAX_FRAME_SIZE			2346	// Maximum 802.11 frame size
+#define ALLOC_RX_PACKET_POOL	(RX_RING_SIZE)
+#define ALLOC_RX_BUFFER_POOL	(ALLOC_RX_PACKET_POOL)
+#define	TX_RING					0xa
+#define	ATIM_RING				0xb
+#define	PRIO_RING				0xc
+#define	RX_RING					0xd
+#define	BEACON_RING				0xe
+#define	NULL_RING				0xf
+#define	MAX_TX_PROCESS			2
+#define	MAX_RX_PROCESS			4
+#define	MAX_CLIENT				2
+
+#define LOCAL_TXBUF_SIZE		2048
+#define TXD_SIZE				64
+#define RXD_SIZE				64
+#define TX_DMA_1ST_BUFFER_SIZE	64	  // only the 1st physical buffer is pre-allocated
+#define MGMT_DMA_BUFFER_SIZE	2048
+#define RX_DMA_BUFFER_SIZE      4096
+#define MAX_AGGREGATION_SIZE	4096
+#define MAX_DMA_DONE_PROCESS	TX_RING_SIZE
+#define MAX_TX_DONE_PROCESS 	8
+#define MAX_NUM_OF_TUPLE_CACHE	2
+#define MAX_MCAST_LIST_SIZE 	32
+
+
+//
+//	RTMP_ADAPTER flags
+//
+#define	fRTMP_ADAPTER_TEST_MODE				0x00000001
+#define fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS	 0x00000002
+#define fRTMP_ADAPTER_HARDWARE_ERROR		0x00000004
+#define fRTMP_ADAPTER_SEND_PACKET_ERROR 	0x00000010
+#define fRTMP_ADAPTER_RECEIVE_PACKET_ERROR	0x00000020
+#define fRTMP_ADAPTER_HALT_IN_PROGRESS		0x00000040
+#define fRTMP_ADAPTER_RESET_IN_PROGRESS 	0x00000080
+#define fRTMP_ADAPTER_NIC_NOT_EXIST 		0x00000100
+#define fRTMP_ADAPTER_TX_RING_ALLOCATED 	0x00000200
+#define fRTMP_ADAPTER_ATIM_RING_ALLOCATED	0x00000400
+#define fRTMP_ADAPTER_PRIO_RING_ALLOCATED	0x00000800
+#define fRTMP_ADAPTER_RX_RING_ALLOCATED 	0x00001000
+#define fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS	0x00002000
+#define fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS	0x00004000
+#define	fRTMP_ADAPTER_REASSOC_IN_PROGRESS	0x00008000
+#define	fRTMP_ADAPTER_MEDIA_STATE_PENDING	0x00010000
+#define	fRTMP_ADAPTER_RADIO_OFF				0x00020000
+#define	fRTMP_ADAPTER_BULKOUT_RESET			0x00040000
+#define	fRTMP_ADAPTER_BULKIN_RESET			0x00080000
+#define fRTMP_ADAPTER_RESET_DATA_SW_QUEUE	0x00100000
+#define fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS 0x00200000
+#define fRTMP_ADAPTER_SCAN_CHANNEL_IN_PROGRESS 0x04000000
+#define	fRTMP_ADAPTER_RADIO_MEASUREMENT		0x08000000
+
+#define fRTMP_ADAPTER_MEDIA_STATE_CHANGE	0x20000000
+
+
+// Lock bit for accessing different ring buffers
+#define fRTMP_ADAPTER_TX_RING_BUSY			0x80000000
+#define fRTMP_ADAPTER_PRIO_RING_BUSY		0x40000000
+#define fRTMP_ADAPTER_ATIM_RING_BUSY		0x20000000
+#define fRTMP_ADAPTER_RX_RING_BUSY			0x10000000
+
+// Lock bit for accessing different queue
+#define	fRTMP_ADAPTER_TX_QUEUE_BUSY 		0x08000000
+#define	fRTMP_ADAPTER_PRIO_QUEUE_BUSY		0x04000000
+
+
+//
+//	STA operation status flags
+//
+#define fOP_STATUS_INFRA_ON 				0x00000001
+#define fOP_STATUS_ADHOC_ON 				0x00000002
+#define fOP_STATUS_BG_PROTECTION_INUSED 	0x00000004
+#define fOP_STATUS_SHORT_SLOT_INUSED		0x00000008
+#define fOP_STATUS_SHORT_PREAMBLE_INUSED	0x00000010
+#define fOP_STATUS_RECEIVE_DTIM 			0x00000020
+#define fOP_STATUS_TX_RATE_SWITCH_ENABLED	0x00000040
+#define fOP_STATUS_MEDIA_STATE_CONNECTED	0x00000080
+#define fOP_STATUS_WMM_INUSED				0x00000100
+#define fOP_STATUS_AGGREGATION_INUSED		0x00000200
+#define fOP_STATUS_DOZE 					0x00000400
+#define fOP_STATUS_MAX_RETRY_ENABLED		0x00000800
+#define fOP_STATUS_RTS_PROTECTION_ENABLE	0x00001000
+#define fOP_STATUS_FIRMWARE_LOAD	0x00002000
+
+//
+// Flags for Bulkflags control for bulk out data
+//
+#define	fRTUSB_BULK_OUT_DATA_NULL				0x00000001
+#define fRTUSB_BULK_OUT_RTS						0x00000002
+#define	fRTUSB_BULK_OUT_MLME					0x00000004
+#define	fRTUSB_BULK_OUT_BEACON_1				0x00000008
+
+#define	fRTUSB_BULK_OUT_DATA_NORMAL				0x00010000
+#define	fRTUSB_BULK_OUT_DATA_NORMAL_2			0x00020000
+#define	fRTUSB_BULK_OUT_DATA_NORMAL_3			0x00040000
+#define	fRTUSB_BULK_OUT_DATA_NORMAL_4			0x00080000
+
+
+#define	fRTUSB_BULK_OUT_BEACON_0				0x00000010
+#define	fRTUSB_BULK_OUT_PSPOLL					0x00000020
+#define	fRTUSB_BULK_OUT_DATA_FRAG				0x00000040
+#define	fRTUSB_BULK_OUT_DATA_FRAG_2				0x00000080
+#define	fRTUSB_BULK_OUT_DATA_FRAG_3				0x00000100
+#define	fRTUSB_BULK_OUT_DATA_FRAG_4				0x00000200
+
+//
+//	AP's client table operation status flags
+//
+#define fCLIENT_STATUS_WMM_CAPABLE			0x00000001	// CLIENT can parse QOS DATA frame
+#define fCLIENT_STATUS_AGGREGATION_CAPABLE	0x00000002	// CLIENT can receive Ralink's proprietary TX aggregation frame
+
+//
+//	STA configuration flags
+//
+//#define fSTA_CFG_ENABLE_TX_BURST			0x00000001
+
+
+//
+// Error code section
+//
+// NDIS_ERROR_CODE_ADAPTER_NOT_FOUND
+#define ERRLOG_READ_PCI_SLOT_FAILED 	0x00000101L
+#define ERRLOG_WRITE_PCI_SLOT_FAILED	0x00000102L
+#define ERRLOG_VENDOR_DEVICE_NOMATCH	0x00000103L
+
+// NDIS_ERROR_CODE_ADAPTER_DISABLED
+#define ERRLOG_BUS_MASTER_DISABLED		0x00000201L
+
+// NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION
+#define ERRLOG_INVALID_SPEED_DUPLEX 	0x00000301L
+#define ERRLOG_SET_SECONDARY_FAILED 	0x00000302L
+
+// NDIS_ERROR_CODE_OUT_OF_RESOURCES
+#define ERRLOG_OUT_OF_MEMORY			0x00000401L
+#define ERRLOG_OUT_OF_SHARED_MEMORY 	0x00000402L
+#define ERRLOG_OUT_OF_MAP_REGISTERS 	0x00000403L
+#define ERRLOG_OUT_OF_BUFFER_POOL		0x00000404L
+#define ERRLOG_OUT_OF_NDIS_BUFFER		0x00000405L
+#define ERRLOG_OUT_OF_PACKET_POOL		0x00000406L
+#define ERRLOG_OUT_OF_NDIS_PACKET		0x00000407L
+#define ERRLOG_OUT_OF_LOOKASIDE_MEMORY	0x00000408L
+
+// NDIS_ERROR_CODE_HARDWARE_FAILURE
+#define ERRLOG_SELFTEST_FAILED			0x00000501L
+#define ERRLOG_INITIALIZE_ADAPTER		0x00000502L
+#define ERRLOG_REMOVE_MINIPORT			0x00000503L
+
+// NDIS_ERROR_CODE_RESOURCE_CONFLICT
+#define ERRLOG_MAP_IO_SPACE 			0x00000601L
+#define ERRLOG_QUERY_ADAPTER_RESOURCES	0x00000602L
+#define ERRLOG_NO_IO_RESOURCE			0x00000603L
+#define ERRLOG_NO_INTERRUPT_RESOURCE	0x00000604L
+#define ERRLOG_NO_MEMORY_RESOURCE		0x00000605L
+
+//============================================================
+// Length definitions
+#define PEER_KEY_NO                       2
+#define MAC_ADDR_LEN                      6
+#define TIMESTAMP_LEN                     8
+#define MAX_LEN_OF_SUPPORTED_RATES        12    // 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+#define MAX_LEN_OF_KEY                    32      // 32 octets == 256 bits, Redefine for WPA
+
+#define MAX_NUM_OF_CHANNELS               43    //1-14, 36/40/44/48/52/56/60/64/100/104/108/112/116/120/124/
+                                                //128/132/136/140/149/153/157/161/165/34/38/42/46 + 1 as NULL termination
+#define MAX_NUM_OF_A_CHANNELS             24    //36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165
+#define J52_CHANNEL_START_OFFSET          38    //1-14, 36/40/44/48/52/56/60/64/100/104/108/112/116/120/124/
+                                                //128/132/136/140/149/153/157/161/165/
+#define MAX_LEN_OF_SSID                   32
+#define CIPHER_TEXT_LEN                   128
+#define MAX_LEN_OF_MLME_BUFFER            2048
+#define MAX_MLME_HANDLER_MEMORY           20    //each them cantains  MAX_LEN_OF_MLME_BUFFER size
+#define MAX_FRAME_LEN                     2338
+#define	MAX_VIE_LEN                       160	// New for WPA cipher suite variable IE sizes.
+
+#define MAX_TX_POWER_LEVEL                100   /* mW */
+#define MAX_RSSI_TRIGGER                 -10    /* dBm */
+#define MIN_RSSI_TRIGGER                 -200   /* dBm */
+#define MAX_FRAG_THRESHOLD                2346  /* byte count */
+#define MIN_FRAG_THRESHOLD                256   /* byte count */
+#define MAX_RTS_THRESHOLD                 2347  /* byte count */
+#define MIN_RTS_THRESHOLD                 0
+
+// key related definitions
+#define SHARE_KEY_NUM                     4
+#define MAX_LEN_OF_SHARE_KEY              16    // byte count
+#define MAX_LEN_OF_PEER_KEY               16    // byte count
+#define PAIRWISE_KEY_NO                   64    // in MAC ASIC pairwise key table
+#define GROUP_KEY_NO                      4
+#define	PMKID_NO                          4     // Number of PMKID saved supported
+
+
+// power status related definitions
+#define PWR_ACTIVE                        0
+#define PWR_SAVE                          1
+#define PWR_UNKNOWN                       2
+
+// BSS Type definitions
+#define BSS_ADHOC                         0  // = Ndis802_11IBSS
+#define BSS_INFRA                         1  // = Ndis802_11Infrastructure
+#define BSS_ANY                           2  // = Ndis802_11AutoUnknown
+#define BSS_MONITOR			  3  // = Ndis802_11Monitor
+
+// Reason code definitions
+#define REASON_RESERVED                   0
+#define REASON_UNSPECIFY                  1
+#define REASON_NO_LONGER_VALID            2
+#define REASON_DEAUTH_STA_LEAVING         3
+#define REASON_DISASSOC_INACTIVE          4
+#define REASON_DISASSPC_AP_UNABLE         5
+#define REASON_CLS2ERR                    6
+#define REASON_CLS3ERR                    7
+#define REASON_DISASSOC_STA_LEAVING       8
+#define REASON_STA_REQ_ASSOC_NOT_AUTH     9
+#define	REASON_INVALID_IE                 13
+#define	REASON_MIC_FAILURE                14
+#define REASON_4_WAY_TIMEOUT              15
+#define REASON_GROUP_KEY_HS_TIMEOUT       16
+#define REASON_IE_DIFFERENT               17
+#define REASON_MCIPHER_NOT_VALID          18
+#define REASON_UCIPHER_NOT_VALID          19
+#define REASON_AKMP_NOT_VALID             20
+#define REASON_UNSUPPORT_RSNE_VER         21
+#define REASON_INVALID_RSNE_CAP           22
+#define REASON_8021X_AUTH_FAIL            23
+#define REASON_CIPHER_SUITE_REJECTED      24
+
+// Status code definitions
+#define MLME_SUCCESS                      0
+#define MLME_UNSPECIFY_FAIL               1
+#define MLME_CANNOT_SUPPORT_CAP           10
+#define MLME_REASSOC_DENY_ASSOC_EXIST     11
+#define MLME_ASSOC_DENY_OUT_SCOPE         12
+#define MLME_ALG_NOT_SUPPORT              13
+#define MLME_SEQ_NR_OUT_OF_SEQUENCE       14
+#define MLME_REJ_CHALLENGE_FAILURE        15
+#define MLME_REJ_TIMEOUT                  16
+#define MLME_ASSOC_REJ_UNABLE_HANDLE_STA  17
+#define MLME_ASSOC_REJ_DATA_RATE          18
+
+#define MLME_ASSOC_REJ_NO_EXT_RATE        22
+#define MLME_ASSOC_REJ_NO_EXT_RATE_PBCC   23
+#define MLME_ASSOC_REJ_NO_CCK_OFDM        24
+
+#define MLME_INVALID_FORMAT               0x51
+#define MLME_FAIL_NO_RESOURCE             0x52
+#define MLME_STATE_MACHINE_REJECT         0x53
+#define MLME_MAC_TABLE_FAIL               0x54
+
+//IE code
+#define IE_SSID                           0
+#define IE_SUPP_RATES                     1
+#define IE_FH_PARM                        2
+#define IE_DS_PARM                        3
+#define IE_CF_PARM                        4
+#define IE_TIM                            5
+#define IE_IBSS_PARM                      6
+#define IE_COUNTRY                        7     // 802.11d
+#define IE_802_11D_REQUEST                10    // 802.11d
+#define IE_QBSS_LOAD                      11    // 802.11e d9
+#define IE_EDCA_PARAMETER                 12    // 802.11e d9
+#define IE_TSPEC                          13    // 802.11e d9
+#define IE_TCLAS                          14    // 802.11e d9
+#define IE_SCHEDULE                       15    // 802.11e d9
+#define IE_CHALLENGE_TEXT                 16
+#define IE_POWER_CONSTRAINT               32    // 802.11h d3.3
+#define IE_POWER_CAPABILITY               33    // 802.11h d3.3
+#define IE_TPC_REQUEST                    34    // 802.11h d3.3
+#define IE_TPC_REPORT                     35    // 802.11h d3.3
+#define IE_SUPP_CHANNELS                  36    // 802.11h d3.3
+#define IE_CHANNEL_SWITCH_ANNOUNCEMENT    37    // 802.11h d3.3
+#define IE_MEASUREMENT_REQUEST            38    // 802.11h d3.3
+#define IE_MEASUREMENT_REPORT             39    // 802.11h d3.3
+#define IE_QUIET                          40    // 802.11h d3.3
+#define IE_IBSS_DFS                       41    // 802.11h d3.3
+#define IE_ERP                            42    // 802.11g
+#define IE_TS_DELAY                       43    // 802.11e d9
+#define IE_TCLAS_PROCESSING               44    // 802.11e d9
+#define IE_QOS_CAPABILITY                 45    // 802.11e d6
+#define IE_EXT_SUPP_RATES                 50    // 802.11g
+#define IE_WPA                            221   // WPA
+#define IE_VENDOR_SPECIFIC                221   // Wifi,WMM (WME),EOU
+#define IE_RSN                            48    // 802.11i d3.0
+#define IE_WPA2                           48    // WPA2
+
+
+
+// ========================================================
+// MLME state machine definition
+// ========================================================
+
+// STA MLME state mahcines
+#define ASSOC_STATE_MACHINE             1
+#define AUTH_STATE_MACHINE              2
+#define AUTH_RSP_STATE_MACHINE          3
+#define SYNC_STATE_MACHINE              4
+#define MLME_CNTL_STATE_MACHINE         5
+#define WPA_PSK_STATE_MACHINE           6
+
+//
+// STA's CONTROL/CONNECT state machine: states, events, total function #
+//
+#define CNTL_IDLE                       0
+#define CNTL_WAIT_DISASSOC              1
+#define CNTL_WAIT_JOIN                  2
+#define CNTL_WAIT_REASSOC               3
+#define CNTL_WAIT_START                 4
+#define CNTL_WAIT_AUTH                  5
+#define CNTL_WAIT_ASSOC                 6
+#define CNTL_WAIT_AUTH2                 7
+#define CNTL_WAIT_OID_LIST_SCAN         8
+#define CNTL_WAIT_OID_DISASSOC          9
+
+#define MT2_ASSOC_CONF                  34
+#define MT2_AUTH_CONF                   35
+#define MT2_DEAUTH_CONF                 36
+#define MT2_DISASSOC_CONF               37
+#define MT2_REASSOC_CONF                38
+#define MT2_PWR_MGMT_CONF               39
+#define MT2_JOIN_CONF                   40
+#define MT2_SCAN_CONF                   41
+#define MT2_START_CONF                  42
+#define MT2_GET_CONF                    43
+#define MT2_SET_CONF                    44
+#define MT2_RESET_CONF                  45
+
+#define MT2_DEAUTH_IND              	46
+#define MT2_ASSOC_IND               	47
+#define MT2_DISASSOC_IND            	48
+#define MT2_REASSOC_IND             	49
+#define MT2_AUTH_IND                	50
+
+#define MT2_SCAN_END_CONF               51  // For scan end
+#define MT2_MLME_ROAMING_REQ            52
+
+#define CNTL_FUNC_SIZE                  1
+
+//
+// STA's ASSOC state machine: states, events, total function #
+//
+#define ASSOC_IDLE                      0
+#define ASSOC_WAIT_RSP                  1
+#define REASSOC_WAIT_RSP                2
+#define DISASSOC_WAIT_RSP               3
+#define MAX_ASSOC_STATE                 4
+
+#define ASSOC_MACHINE_BASE              0
+#define MT2_MLME_ASSOC_REQ              0
+#define MT2_MLME_REASSOC_REQ            1
+#define MT2_MLME_DISASSOC_REQ           2
+#define MT2_PEER_DISASSOC_REQ           3
+#define MT2_PEER_ASSOC_REQ              4
+#define MT2_PEER_ASSOC_RSP              5
+#define MT2_PEER_REASSOC_REQ            6
+#define MT2_PEER_REASSOC_RSP            7
+#define MT2_DISASSOC_TIMEOUT            8
+#define MT2_ASSOC_TIMEOUT               9
+#define MT2_REASSOC_TIMEOUT             10
+#define MAX_ASSOC_MSG                   11
+
+#define ASSOC_FUNC_SIZE                 (MAX_ASSOC_STATE * MAX_ASSOC_MSG)
+
+//
+// STA's AUTHENTICATION state machine: states, evvents, total function #
+//
+#define AUTH_REQ_IDLE					0
+#define AUTH_WAIT_SEQ2					1
+#define AUTH_WAIT_SEQ4					2
+#define MAX_AUTH_STATE					3
+
+#define AUTH_MACHINE_BASE				0
+#define MT2_MLME_AUTH_REQ				0
+#define MT2_PEER_AUTH_EVEN				1
+#define MT2_AUTH_TIMEOUT				2
+#define MAX_AUTH_MSG					3
+
+#define AUTH_FUNC_SIZE					(MAX_AUTH_STATE * MAX_AUTH_MSG)
+
+//
+// STA's AUTH_RSP state machine: states, events, total function #
+//
+#define AUTH_RSP_IDLE                   0
+#define AUTH_RSP_WAIT_CHAL              1
+#define MAX_AUTH_RSP_STATE              2
+
+#define AUTH_RSP_MACHINE_BASE           0
+#define MT2_AUTH_CHALLENGE_TIMEOUT      0
+#define MT2_PEER_AUTH_ODD               1
+#define MT2_PEER_DEAUTH                 2
+#define MAX_AUTH_RSP_MSG                3
+
+#define AUTH_RSP_FUNC_SIZE              (MAX_AUTH_RSP_STATE * MAX_AUTH_RSP_MSG)
+
+//
+// STA's SYNC state machine: states, events, total function #
+//
+#define SYNC_IDLE                       0  // merge NO_BSS,IBSS_IDLE,IBSS_ACTIVE and BSS in to 1 state
+#define JOIN_WAIT_BEACON                1
+#define SCAN_LISTEN                     2
+#define MAX_SYNC_STATE                  3
+
+#define SYNC_MACHINE_BASE               0
+#define MT2_MLME_SCAN_REQ               0
+#define MT2_MLME_JOIN_REQ               1
+#define MT2_MLME_START_REQ              2
+#define MT2_PEER_BEACON                 3
+#define MT2_PEER_PROBE_RSP              4
+#define MT2_PEER_ATIM                   5
+#define MT2_SCAN_TIMEOUT                6
+#define MT2_BEACON_TIMEOUT              7
+#define MT2_ATIM_TIMEOUT                8
+#define MT2_PEER_PROBE_REQ              9
+#define MAX_SYNC_MSG                    10
+
+#define SYNC_FUNC_SIZE                  (MAX_SYNC_STATE * MAX_SYNC_MSG)
+
+//
+// STA's WPA-PSK State machine: states, events, total function #
+//
+#define WPA_PSK_IDLE					0
+#define MAX_WPA_PSK_STATE				1
+
+#define WPA_MACHINE_BASE				0
+#define MT2_EAPPacket					0
+#define MT2_EAPOLStart					1
+#define MT2_EAPOLLogoff 				2
+#define MT2_EAPOLKey					3
+#define MT2_EAPOLASFAlert				4
+#define MAX_WPA_PSK_MSG 				5
+
+#define	WPA_PSK_FUNC_SIZE				(MAX_WPA_PSK_STATE * MAX_WPA_PSK_MSG)
+
+//
+// MIB access: messages #
+//
+#define MT2_GET_REQ 					31
+#define MT2_SET_REQ 					32
+#define MT2_RESET_REQ					33
+
+// =============================================================================
+
+// value domain of MacHdr.tyte, which is b3..b2 of the 1st-byte of MAC header
+#define BTYPE_MGMT					0
+#define BTYPE_CNTL					1
+#define BTYPE_DATA					2
+
+// value domain of MacHdr.subtype, which is b7..4 of the 1st-byte of MAC header
+// Management frame
+#define SUBTYPE_ASSOC_REQ           0
+#define SUBTYPE_ASSOC_RSP           1
+#define SUBTYPE_REASSOC_REQ         2
+#define SUBTYPE_REASSOC_RSP         3
+#define SUBTYPE_PROBE_REQ           4
+#define SUBTYPE_PROBE_RSP           5
+#define SUBTYPE_BEACON              8
+#define SUBTYPE_ATIM                9
+#define SUBTYPE_DISASSOC            10
+#define SUBTYPE_AUTH                11
+#define SUBTYPE_DEAUTH              12
+#define SUBTYPE_ACTION              13
+
+// Control Frame
+#define SUBTYPE_BLOCK_ACK_REQ       8
+#define SUBTYPE_BLOCK_ACK           9
+#define SUBTYPE_PS_POLL             10
+#define SUBTYPE_RTS                 11  // 1011
+#define SUBTYPE_CTS                 12  // 1100
+#define SUBTYPE_ACK                 13  // 1101
+#define SUBTYPE_CFEND               14
+#define SUBTYPE_CFEND_CFACK         15
+
+// Data Frame
+#define SUBTYPE_DATA                0
+#define SUBTYPE_DATA_CFACK          1
+#define SUBTYPE_DATA_CFPOLL         2
+#define SUBTYPE_DATA_CFACK_CFPOLL   3
+#define SUBTYPE_NULL_FUNC           4
+#define SUBTYPE_CFACK               5  // 0101
+#define SUBTYPE_CFPOLL              6
+#define SUBTYPE_CFACK_CFPOLL        7
+#define SUBTYPE_QDATA               8
+#define SUBTYPE_QDATA_CFACK         9
+#define SUBTYPE_QDATA_CFPOLL        10
+#define SUBTYPE_QDATA_CFACK_CFPOLL  11
+#define SUBTYPE_QOS_NULL            12
+#define SUBTYPE_QOS_CFACK           13
+#define SUBTYPE_QOS_CFPOLL          14
+#define SUBTYPE_QOS_CFACK_CFPOLL    15
+
+// ACK policy of QOS Control field bit 6:5
+#define NORMAL_ACK                  0x00  // b6:5 = 00
+#define NO_ACK                      0x20  // b6:5 = 01
+#define NO_EXPLICIT_ACK             0x40  // b6:5 = 10
+#define BLOCK_ACK                   0x60  // b6:5 = 11
+
+//
+// rtmp_data.c use these definition
+//
+#define	LENGTH_802_11				24
+#define LENGTH_802_11_WITH_ADDR4    30
+#define	LENGTH_802_11_AND_H			30
+#define	LENGTH_802_11_CRC_H			34
+#define	LENGTH_802_11_CRC			28
+#define	LENGTH_802_3				14
+#define LENGTH_802_3_TYPE			2
+#define LENGTH_802_1_H				8
+#define LENGTH_EAPOL_H				4
+#define	LENGTH_CRC                  4
+#define	MAX_SEQ_NUMBER				0x0fff
+
+#define	TX_RESULT_SUCCESS       0
+#define TX_RESULT_ZERO_LENGTH   1
+#define TX_RESULT_UNDER_RUN     2
+#define TX_RESULT_PHY_ERROR     4
+#define	TX_RESULT_RETRY_FAIL	6
+
+#define	RATE_1					0
+#define	RATE_2					1
+#define	RATE_5_5				2
+#define	RATE_11					3
+#define RATE_6					4	// OFDM
+#define RATE_9					5	// OFDM
+#define RATE_12 				6	// OFDM
+#define RATE_18 				7	// OFDM
+#define RATE_24 				8	// OFDM
+#define RATE_36 				9	// OFDM
+#define RATE_48 				10	// OFDM
+#define RATE_54 				11	// OFDM
+#define RATE_FIRST_OFDM_RATE	RATE_6
+#define RATE_AUTO_SWITCH		255 // for UserCfg.FixedTxRate only
+
+
+#define CCK_RATE                    1
+#define OFDM_RATE                   2
+#define CCKOFDM_RATE                3
+
+// pTxD->Ifs
+#define	IFS_BACKOFF				0
+#define	IFS_SIFS				1
+
+// pTxD->RetryMode
+#define	LONG_RETRY				1
+#define	SHORT_RETRY				0
+
+// Country Region definition
+#define REGION_0_BG_BAND                  0 	  // 1-11
+#define REGION_1_BG_BAND                  1 	  // 1-13
+#define REGION_2_BG_BAND                  2 	  // 10-11
+#define REGION_3_BG_BAND                  3 	  // 10-13
+#define REGION_4_BG_BAND                  4 	  // 14
+#define REGION_5_BG_BAND                  5 	  // 1-14
+#define REGION_6_BG_BAND                  6 	  // 3-9
+#define REGION_7_BG_BAND                  7 	  // 5-13
+#define REGION_MAXIMUM_BG_BAND            REGION_7_BG_BAND
+
+#define REGION_0_A_BAND                   0 	  // 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165
+#define REGION_1_A_BAND                   1 	  // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
+#define REGION_2_A_BAND                   2 	  // 36, 40, 44, 48, 52, 56, 60, 64
+#define REGION_3_A_BAND                   3 	  // 52, 56, 60, 64, 149, 153, 157, 161
+#define REGION_4_A_BAND                   4 	  // 149, 153, 157, 161, 165
+#define REGION_5_A_BAND                   5 	  // 149, 153, 157, 161
+#define REGION_6_A_BAND                   6 	  // 36, 40, 44, 48
+#define REGION_7_A_BAND                   7 	  // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165
+#define REGION_8_A_BAND                   8       // 52, 56, 60, 64
+#define REGION_9_A_BAND                   9       // 34, 38, 42, 46
+#define REGION_10_A_BAND                  10      // 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64
+#define REGION_MAXIMUM_A_BAND             REGION_10_A_BAND
+
+
+// pTxD->CipherAlg
+#define	CIPHER_NONE				0
+#define	CIPHER_WEP64			1
+#define	CIPHER_WEP128			2
+#define	CIPHER_TKIP				3
+#define	CIPHER_AES				4
+#define CIPHER_CKIP64			5
+#define CIPHER_CKIP128			6
+#define CIPHER_TKIP_NO_MIC		7	 // MIC has been appended by driver, not a valid value in hardware key table
+
+
+// value domain for pAd->RfIcType
+#define RFIC_5226				1  //A/B/G
+#define RFIC_2528				2  //B/G
+#define RFIC_5225				3  //A/B/G
+#define RFIC_2527				4  //B/G
+
+// LED Status.
+#define LED_LINK_DOWN               0
+#define LED_LINK_UP                 1
+#define LED_RADIO_OFF               2
+#define LED_RADIO_ON                3
+#define LED_HALT                    4
+
+// value domain of pAdapter->LedCntl.LedMode and E2PROM
+#define LED_MODE_DEFAULT			0
+#define LED_MODE_TWO_LED			1
+#define LED_MODE_SIGNAL_STREGTH		2
+
+
+// RC4 init value, used fro WEP & TKIP
+#define PPPINITFCS32			0xffffffff	 /* Initial FCS value */
+
+#define PAIRWISE_KEY_TABLE			1
+#define SHARED_KEY_TABLE			0
+
+#define DEFAULT_BBP_TX_POWER		0
+#define DEFAULT_RF_TX_POWER 		5
+
+#define MAX_INI_BUFFER_SIZE 		(4*1024)	// 4K bytes
+
+#define MAX_LEN_OF_MAC_TABLE        64
+#define HASH_TABLE_SIZE             256
+
+// Event definition
+#define MAX_NUM_OF_EVENT            10  // entry # in EVENT table
+#define EVENT_MAX_EVENT_TYPE        6
+
+
+// 802.1X controlled port definition
+#define	WPA_802_1X_PORT_SECURED			1
+#define	WPA_802_1X_PORT_NOT_SECURED		2
+
+#define	PAIRWISE_KEY			1
+#define	GROUP_KEY				2
+
+#define AUTH_MODE_OPEN					  0x00
+#define AUTH_MODE_KEY					  0x01
+#define AUTH_MODE_AUTO_SWITCH			  0x03
+
+// wpapsk EAPOL Key descripter frame format related length
+#define LEN_KEY_DESC_NONCE          32
+#define LEN_KEY_DESC_IV             16
+#define LEN_KEY_DESC_RSC            8
+#define LEN_KEY_DESC_ID             8
+#define LEN_KEY_DESC_REPLAY         8
+#define LEN_KEY_DESC_MIC            16
+
+#define LEN_MASTER_KEY              32
+
+// EAPOL EK, MK
+#define LEN_EAP_EK                  16
+#define LEN_EAP_MICK                16
+#define LEN_EAP_KEY                 ((LEN_EAP_EK)+(LEN_EAP_MICK))
+#define PMK_LEN                     32
+
+// TKIP key related
+#define LEN_PMKID                   16
+#define LEN_TKIP_EK                 16
+#define LEN_TKIP_RXMICK             8
+#define LEN_TKIP_TXMICK             8
+#define LEN_AES_EK                  16
+#define LEN_AES_KEY                 LEN_AES_EK
+#define LEN_TKIP_KEY                ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+#define TKIP_AP_TXMICK_OFFSET       ((LEN_EAP_KEY)+(LEN_TKIP_EK))
+#define TKIP_AP_RXMICK_OFFSET       (TKIP_AP_TXMICK_OFFSET+LEN_TKIP_TXMICK)
+#define	TKIP_GTK_LENGTH             ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+
+#define LEN_PTK                     ((LEN_EAP_KEY)+(LEN_TKIP_KEY))
+#define MAX_LEN_OF_RSNIE            80
+#define MIN_LEN_OF_RSNIE            8
+
+
+// definition RSSI Number
+#define RSSI_NO_1					1
+#define RSSI_NO_2					2
+
+
+// definition of radar detection
+#define RD_NORMAL_MODE              0	// Not found radar signal
+#define RD_SWITCHING_MODE           1	// Found radar signal, and doing channel switch
+#define RD_SILENCE_MODE             2	// After channel switch, need to be silence a while to ensure radar not found
+
+#define MAX_CFG_BUFFER_LEN          1056
+////////////////////////////////////////////////////////////////////////////
+// RT73 internal usage
+////////////////////////////////////////////////////////////////////////////
+#define	CMD_RESET_BULKOUT		0
+#define	CMD_RESET_BULKIN		1
+#define	CMD_RESET_FROM_ERROR		2
+#define	CMD_LINK_DOWN			3
+#define	CMD_UPDATE_TX_RATE		4
+#define	CMD_SET_PSM_SAVE		5
+#define	CMD_RESET_FROM_NDIS		6
+#define	CMD_PERIODIC_EXECUT		7
+#define CMD_ASICLED_EXECUT		8
+#define CMD_CHECK_GPIO			9
+#define CMD_Remove_AllKeys		10
+#define CMD_SOFT_DIVERSITY		11
+#define CMD_FORCE_WAKEUP		12
+#define CMD_SET_PSM_ACTIVE		13
+
+#define COMMAND_QUEUE_SIZE		14
+
+
+#define	USB_DEVICE_MAX_CONFIG_DESCRIPTOR_SIZE	1024
+
+#define UNLINK_TIMEOUT_MS		3
+
+//-------------------
+// Frame Sizes
+//-------------------
+
+#define MAC_ADDRESS_LENGTH              6
+
+#define HEADER_SIZE                     14
+#define MAXIMUM_PACKET_SIZE             1500
+
+#define	USB_DEVICE_MAX_CONFIG_DESCRIPTOR_SIZE	1024
+
+#define MAX_QUEUE_SIZE                  100
+
+#define USB_TX_HEADER_SIZE              8//WLength+TxRate+PaddingBytes+Reserved
+#define USB_RX_HEADER_SIZE              12
+
+#define WIRELESS_HEADER_OVERHEAD        18
+#define MAX_TX_PADDING_BYTES            50
+#define MAX_RX_PADDING_BYTES            66
+#define CRC32_BYTES                     4
+
+#define MAX_WIRELESS_SIZE               WIRELESS_HEADER_OVERHEAD + HEADER_SIZE + MAXIMUM_PACKET_SIZE + CRC32_BYTES
+
+
+//--------------------
+// REQUEST SUPPORT
+//--------------------
+#define DEVICE_VENDOR_REQUEST_OUT       (USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE)  // 0x40
+#define DEVICE_VENDOR_REQUEST_IN        (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE )  // 0xc0
+#define INTERFACE_VENDOR_REQUEST_OUT    0x41
+#define INTERFACE_VENDOR_REQUEST_IN     0xc1
+
+
+#define	RETRY_LIMIT			3
+
+typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH];
+
+
+//-------------------
+// VID/PID
+//-------------------
+
+#define RT73_USB_DEVICES { \
+ /* AboCom */\
+ {USB_DEVICE(0x07b8,0xb21d)},\
+ /* Askey */\
+ {USB_DEVICE(0x1690,0x0722)},\
+ /* ASUS */\
+ {USB_DEVICE(0x0b05,0x1723)},\
+ {USB_DEVICE(0x0b05,0x1724)},\
+ /* Buffalo */\                                                                                                                     
+ {USB_DEVICE(0x0411,0x00f4)},\
+ /* Belkin */\
+ {USB_DEVICE(0x050d,0x7050)},\
+ {USB_DEVICE(0x050d,0x705a)},\
+ {USB_DEVICE(0x050d,0x905b)},\
+ /* Billionton */\
+ {USB_DEVICE(0x1631,0xc019)},\
+ /* CNet */\
+ {USB_DEVICE(0x1371,0x9022)},\
+ {USB_DEVICE(0x1371,0x9032)},\
+ /* Conceptronic */\
+ {USB_DEVICE(0x14b2,0x3c22)},\
+ /* D-Link */\
+ {USB_DEVICE(0x07d1,0x3c03)},\
+ {USB_DEVICE(0x07d1,0x3c04)},\
+ {USB_DEVICE(0x07d1,0x3c06)},\
+ /* Gemtek*/\
+ {USB_DEVICE(0x15a9,0x0004)},\
+ /* Gigabyte */\
+ {USB_DEVICE(0x1044,0x8008)},\
+ {USB_DEVICE(0x1044,0x800a)},\
+ /* Huawei-3Com */\
+ {USB_DEVICE(0x1472,0x0009)},\
+ /* Hercules */\
+ {USB_DEVICE(0x06f8,0xe010)},\
+ {USB_DEVICE(0x06f8,0xe020)},\
+ /* LinkSys */\
+ {USB_DEVICE(0x13b1,0x0020)},\
+ {USB_DEVICE(0x13b1,0x0023)},\
+ /* MSI */\
+ {USB_DEVICE(0x0db0,0x6877)},\
+ {USB_DEVICE(0x0db0,0xa861)},\
+ {USB_DEVICE(0x0db0,0xa874)},\
+ /* Ralink */\
+ {USB_DEVICE(0x148f,0x2573)},\
+ {USB_DEVICE(0x148f,0x2671)},\
+ /* Qcom */\
+ {USB_DEVICE(0x18e8,0x6196)},\
+ {USB_DEVICE(0x18e8,0x6229)},\
+ {USB_DEVICE(0x18e8,0x6238)},\
+ /* Sitecom */\
+ {USB_DEVICE(0x0df6,0x9712)},\
+ {USB_DEVICE(0x0df6,0x90ac)},\
+ /* Surecom */\
+ {USB_DEVICE(0x0769,0x31f3)},\
+ /* Planex */\
+ {USB_DEVICE(0x2019,0xab01)},\
+ {USB_DEVICE(0x2019,0xab50)},\
+ /* Senao */\
+ {USB_DEVICE(0x1740,0x7100)},\
+ {USB_DEVICE(0,0)}} /* end marker */
+
+
+#endif	// __RTMP_DEF_H__
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_info.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_info.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_info.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_info.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,5991 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_info.c
+ *
+ *	Abstract: IOCTL related subroutines
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Rory Chen	01-03-2003	created
+ *	Rory Chen	02-14-2005	modify to support RT61
+ *	idamlaj		05-10-2006	Import rfmon implementation
+ *	idamlaj		14-10-2006	Mac Address Changing
+ *	idamlaj		14-10-2006	RFMONTx (based on MarkW's code)
+ *	RomainB		31-12-2006	RFMONTx getter
+ *
+ ***************************************************************************/
+
+#include	"rt_config.h"
+#include <net/iw_handler.h>
+
+
+#ifdef DBG
+extern ULONG	RTDebugLevel;
+#endif
+
+#ifndef IW_ESSID_MAX_SIZE
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+#endif
+
+extern UCHAR	CipherWpa2Template[];
+extern UCHAR	CipherWpa2TemplateLen;
+extern UCHAR	CipherWpaPskTkip[];
+extern UCHAR	CipherWpaPskTkipLen;
+
+#define NR_WEP_KEYS 4
+//#define WEP_SMALL_KEY_LEN (40/8)  //move to rtmp_def.h
+//#define WEP_LARGE_KEY_LEN (104/8)
+
+
+struct iw_priv_args privtab[] = {
+{ RTPRIV_IOCTL_SET,
+  IW_PRIV_TYPE_CHAR | 1024, 0,
+  "set"},
+
+#ifdef DBG
+{ RTPRIV_IOCTL_BBP,
+  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+  "bbp"},
+{ RTPRIV_IOCTL_MAC,
+  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+  "mac"},
+#endif
+
+{ RTPRIV_IOCTL_ADHOCOFDM,
+  IW_PRIV_TYPE_INT 	| 1, 0,
+  "adhocOfdm"},
+{ RTPRIV_IOCTL_STATISTICS,
+  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+  "stat"},
+{ RTPRIV_IOCTL_GSITESURVEY,
+  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024 ,
+  "get_site_survey"},
+{ RTPRIV_IOCTL_GETRAAPCFG,  IW_PRIV_TYPE_CHAR | 1024, 0,
+  "get_RaAP_Cfg"},
+{ RTPRIV_IOCTL_FORCEPRISMHEADER,
+  IW_PRIV_TYPE_CHAR | 1024, 0,
+  "forceprism"},
+{ RTPRIV_IOCTL_SETRFMONTX,
+  IW_PRIV_TYPE_CHAR | 1024, 0,
+  "rfmontx"},
+{ RTPRIV_IOCTL_GETRFMONTX,
+  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+  "get_rfmontx"},
+{ RTPRIV_IOCTL_AUTH,
+  IW_PRIV_TYPE_INT	|1, 0,
+  "auth"},
+{ RTPRIV_IOCTL_WEPSTATUS,
+  IW_PRIV_TYPE_INT	|1, 0,
+  "enc"},
+{ RTPRIV_IOCTL_WPAPSK,
+  IW_PRIV_TYPE_CHAR |64, 0,
+  "wpapsk"},
+{ RTPRIV_IOCTL_PSM,
+ IW_PRIV_TYPE_INT  |1, 0,
+ "psm"},
+
+};
+
+static struct {
+	CHAR *name;
+	INT (*set_proc)(PRTMP_ADAPTER pAdapter, PUCHAR arg);
+} *PRTMP_PRIVATE_SET_PROC, RTMP_PRIVATE_SUPPORT_PROC[] = {
+	{"DriverVersion",				Set_DriverVersion_Proc},
+	{"CountryRegion",				Set_CountryRegion_Proc},
+	{"CountryRegionABand",			Set_CountryRegionABand_Proc},
+	{"SSID",						Set_SSID_Proc},
+	{"WirelessMode",				Set_WirelessMode_Proc},
+	{"TxRate",						Set_TxRate_Proc},
+	{"Channel",						Set_Channel_Proc},
+	{"BGProtection",				Set_BGProtection_Proc},
+	{"TxPreamble",					Set_TxPreamble_Proc},
+	{"RTSThreshold",				Set_RTSThreshold_Proc},
+	{"FragThreshold",				Set_FragThreshold_Proc},
+	{"TxBurst",						Set_TxBurst_Proc},
+	{"AdhocOfdm",					Set_AdhocModeRate_Proc},
+#ifdef AGGREGATION_SUPPORT
+	{"PktAggregate",				Set_PktAggregate_Proc},
+#endif
+	{"TurboRate",					Set_TurboRate_Proc},
+#if 0
+	{"WmmCapable",					Set_WmmCapable_Proc},
+#endif
+	{"IEEE80211H",					Set_IEEE80211H_Proc},
+	{"NetworkType", 				Set_NetworkType_Proc},
+	{"AuthMode",					Set_AuthMode_Proc},
+	{"EncrypType",					Set_EncrypType_Proc},
+	{"DefaultKeyID",				Set_DefaultKeyID_Proc},
+	{"Key1",						Set_Key1_Proc},
+	{"Key2",						Set_Key2_Proc},
+	{"Key3",						Set_Key3_Proc},
+	{"Key4",						Set_Key4_Proc},
+	{"WPAPSK",						Set_WPAPSK_Proc},
+	{"ResetCounter",				Set_ResetStatCounter_Proc},
+	{"PSMode",						Set_PSMode_Proc},
+#ifdef DBG
+	{"Debug",						Set_Debug_Proc},
+#endif
+	{NULL,}
+};
+
+char * rtstrchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+
+/*
+This is required for LinEX2004/kernel2.6.7 to provide iwlist scanning function
+*/
+
+int
+rt_ioctl_giwname(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+	strncpy(name, "RT73 WLAN", IFNAMSIZ);
+	return 0;
+}
+
+int rt_ioctl_siwfreq(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_freq *freq, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	int 	chan = -1;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (freq->e > 1)
+		return -EINVAL;
+
+	if((freq->e == 0) && (freq->m <= 1000))
+		chan = freq->m;	// Setting by channel number
+	else
+		MAP_KHZ_TO_CHANNEL_ID( (freq->m /100) , chan); // Setting by frequency - search the table , like 2.412G, 2.422G,
+	pAdapter->PortCfg.Channel = chan;
+	DBGPRINT(RT_DEBUG_ERROR, "==>rt_ioctl_siwfreq::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n", SIOCSIWFREQ, pAdapter->PortCfg.Channel);
+
+	if (pAdapter->PortCfg.BssType == BSS_MONITOR)
+	{
+		pAdapter->PortCfg.Channel = chan;
+		AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+		AsicLockChannel(pAdapter, pAdapter->PortCfg.Channel);
+	}
+
+	return 0;
+}
+int rt_ioctl_giwfreq(struct net_device *dev,
+		   struct iw_request_info *info,
+		   struct iw_freq *freq, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	ULONG	m;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	DBGPRINT(RT_DEBUG_TRACE,"==>rt_ioctl_giwfreq  %d\n",pAdapter->PortCfg.Channel);
+
+	MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.Channel, m);
+	freq->m = m * 100;
+	freq->e = 1;
+	freq->i = 0;
+	return 0;
+}
+
+int rt_ioctl_siwmode(struct net_device *dev,
+		   struct iw_request_info *info,
+		   __u32 *mode, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	switch (*mode)
+	{
+		case IW_MODE_ADHOC:
+			if (pAdapter->PortCfg.BssType != BSS_ADHOC)
+			{
+				// Config has changed
+				if (pAdapter->PortCfg.BssType == BSS_MONITOR)
+				{
+					RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+					// First cancel linkdown timer
+					DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n");
+				}
+
+			}
+			pAdapter->PortCfg.BssType = BSS_ADHOC;
+			pAdapter->net_dev->type = 1;
+			RT73WriteTXRXCSR0(pAdapter, FALSE, TRUE);
+			DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_siwmode::SIOCSIWMODE (AD-HOC)\n");
+			break;
+		case IW_MODE_INFRA:
+			if (pAdapter->PortCfg.BssType != BSS_INFRA)
+			{
+				// Config has changed
+				if (ADHOC_ON(pAdapter))
+					RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+			}
+			pAdapter->PortCfg.BssType = BSS_INFRA;
+			pAdapter->net_dev->type = 1;
+			RT73WriteTXRXCSR0(pAdapter, FALSE, TRUE);
+			DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_siwmode::SIOCSIWMODE (INFRA)\n");
+			break;
+		case IW_MODE_MONITOR:
+			if (pAdapter->PortCfg.BssType != BSS_MONITOR)
+			{
+				RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+			}
+			pAdapter->PortCfg.BssType = BSS_MONITOR;
+
+			if (pAdapter->bAcceptRFMONTx == TRUE) {
+				if (pAdapter->ForcePrismHeader == 1)
+					pAdapter->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+				else
+					pAdapter->net_dev->type = 801; // ARPHRD_IEEE80211
+			} else {
+				if (pAdapter->ForcePrismHeader == 2)
+					pAdapter->net_dev->type = 801; // ARPHRD_IEEE80211
+				else
+					pAdapter->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+			}
+
+			RT73WriteTXRXCSR0(pAdapter, FALSE, TRUE);
+			DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_siwmode::SIOCSIWMODE (MONITOR)\n");
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_siwmode::SIOCSIWMODE (unknown)\n");
+			return -EINVAL;
+	}
+
+	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	pAdapter->PortCfg.WpaState = SS_NOTUSE;
+
+	return 0;
+}
+
+int rt_ioctl_giwmode(struct net_device *dev,
+		   struct iw_request_info *info,
+		   __u32 *mode, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	switch( pAdapter->PortCfg.BssType) {
+	case BSS_ADHOC:
+		*mode = IW_MODE_ADHOC;
+		break;
+	case BSS_INFRA:
+		*mode = IW_MODE_INFRA;
+		break;
+	case BSS_MONITOR:
+		*mode = IW_MODE_MONITOR;
+		break;
+	default:
+		*mode = IW_MODE_AUTO;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,"==>rt_ioctl_giwmode\n");
+	return 0;
+}
+
+int rt_ioctl_siwsens(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+    PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	return 0;
+}
+
+int rt_ioctl_giwsens(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+    PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	return 0;
+}
+
+int rt_ioctl_giwrange(struct net_device *dev,
+		   struct iw_request_info *info,
+		   struct iw_point *data, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	struct iw_range *range = (struct iw_range *) extra;
+	u16 val;
+	int i, chan;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	DBGPRINT(RT_DEBUG_TRACE,"===>rt_ioctl_giwrange\n");
+	data->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+
+	range->txpower_capa = IW_TXPOW_DBM;
+
+	if (INFRA_ON(pAdapter)||ADHOC_ON(pAdapter))
+	{
+		range->min_pmp = 1 * 1024;
+		range->max_pmp = 65535 * 1024;
+		range->min_pmt = 1 * 1024;
+		range->max_pmt = 1000 * 1024;
+		range->pmp_flags = IW_POWER_PERIOD;
+		range->pmt_flags = IW_POWER_TIMEOUT;
+		range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |
+			IW_POWER_UNICAST_R | IW_POWER_ALL_R;
+	}
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 14;
+
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->min_retry = 0;
+	range->max_retry = 255;
+
+  val = 0;
+	for (i = 0; i < 14; i++) {
+		chan = pAdapter->ChannelList[val].Channel;
+		if (chan != 0)
+		{
+			range->freq[val].i = chan;
+			MAP_CHANNEL_ID_TO_KHZ(range->freq[val].i, range->freq[val].m);
+			range->freq[val].m*=100;
+			range->freq[val].e = 1;
+			val++;
+		}
+	}
+
+	range->num_frequency = val;
+	range->num_channels = val;
+
+	val = 0;
+	for (i = 0; i < pAdapter->PortCfg.SupRateLen; i++) {
+		range->bitrate[i]=1000000*(pAdapter->PortCfg.SupRate[i] & 0x7f)/2;
+		val++;
+		if (val == IW_MAX_BITRATES)
+			break;
+	}
+	range->num_bitrates = val;
+
+	range->max_qual.qual = 100; /* what is correct max? This was not
+                                * documented exactly. At least
+					            * 69 has been observed. */
+	range->max_qual.level = 0; /* dB */
+	range->max_qual.noise = 0; /* dB */
+
+	/* What would be suitable values for "average/typical" qual? */
+	range->avg_qual.qual = 20;
+	range->avg_qual.level = -60;
+	range->avg_qual.noise = -95;
+	range->sensitivity = 3;
+
+	range->max_encoding_tokens = NR_WEP_KEYS;
+	range->num_encoding_sizes = 2;
+	range->encoding_size[0] = 5;
+	range->encoding_size[1] = 13;
+
+#if 0
+	over2 = 0;
+	len = prism2_get_datarates(dev, rates);
+	range->num_bitrates = 0;
+	for (i = 0; i < len; i++) {
+		if (range->num_bitrates < IW_MAX_BITRATES) {
+			range->bitrate[range->num_bitrates] =
+				rates[i] * 500000;
+			range->num_bitrates++;
+		}
+		if (rates[i] == 0x0b || rates[i] == 0x16)
+			over2 = 1;
+	}
+	/* estimated maximum TCP throughput values (bps) */
+	range->throughput = over2 ? 5500000 : 1500000;
+#endif
+	range->min_rts = MIN_RTS_THRESHOLD;
+	range->max_rts = MAX_RTS_THRESHOLD;
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	return 0;
+}
+
+int rt_ioctl_giwap(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct sockaddr *ap_addr, char *extra)
+{
+
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+	{
+		ap_addr->sa_family = ARPHRD_ETHER;
+		memcpy(ap_addr->sa_data, &pAdapter->PortCfg.Bssid, ETH_ALEN);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWAP(=EMPTY)\n");
+		return -ENOTCONN;
+	}
+
+	return 0;
+}
+
+/*
+ * Units are in db above the noise floor. That means the
+ * rssi values reported in the tx/rx descriptors in the
+ * driver are the SNR expressed in db.
+ *
+ * If you assume that the noise floor is -95, which is an
+ * excellent assumption 99.5 % of the time, then you can
+ * derive the absolute signal level (i.e. -95 + rssi).
+ * There are some other slight factors to take into account
+ * depending on whether the rssi measurement is from 11b,
+ * 11g, or 11a.   These differences are at most 2db and
+ * can be documented.
+ *
+ * NB: various calculations are based on the orinoco/wavelan
+ *	   drivers for compatibility
+ */
+static void set_quality(PRTMP_ADAPTER pAdapter,
+                        struct iw_quality *iq,
+                        u_int rssi)
+{
+    u32 ChannelQuality, NorRssi;
+
+
+    // Normalize Rssi
+    if (rssi > 0x50)
+        NorRssi = 100;
+    else if (rssi  < 0x20)
+        NorRssi = 0;
+    else
+        NorRssi = (rssi  - 0x20) * 2;
+
+    // ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER	 (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
+    ChannelQuality = (RSSI_WEIGHTING * NorRssi +
+					    TX_WEIGHTING * (100 - 0) +
+				        RX_WEIGHTING* (100 - 0)) / 100;
+
+    if (ChannelQuality >= 100)
+        ChannelQuality = 100;
+
+    iq->qual = ChannelQuality;
+
+#ifdef RTMP_EMBEDDED
+    iq->level = rt_abs(rssi);   // signal level (dBm)
+#else
+    iq->level = abs(rssi);      // signal level (dBm)
+#endif
+    iq->level += 256 - pAdapter->BbpRssiToDbmDelta;
+    iq->noise = (pAdapter->BbpWriteLatch[17] > pAdapter->BbpTuning.R17UpperBoundG) ? pAdapter->BbpTuning.R17UpperBoundG : ((ULONG) pAdapter->BbpWriteLatch[17]); 	// noise level (dBm)
+    iq->noise += 256 - 143;
+    iq->updated = pAdapter->iw_stats.qual.updated;
+
+}
+
+int rt_ioctl_iwaplist(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	struct sockaddr addr[IW_MAX_AP];
+	struct iw_quality qual[IW_MAX_AP];
+	int i;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	for (i = 0; i <IW_MAX_AP ; i++)
+	{
+		if (i >=  pAdapter->ScanTab.BssNr)
+			break;
+		addr[i].sa_family = ARPHRD_ETHER;
+			memcpy(addr[i].sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
+		set_quality(pAdapter, &qual[i], pAdapter->ScanTab.BssEntry[i].Rssi);
+	}
+	data->length = i;
+	memcpy(extra, &addr, i*sizeof(addr[0]));
+	data->flags = 1;		/* signal quality present (sort of) */
+	memcpy(extra + i*sizeof(addr[0]), &qual, i*sizeof(qual[i]));
+
+	return 0;
+}
+
+#ifdef SIOCGIWSCAN
+int rt_ioctl_siwscan(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+	ULONG								Now;
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	int Status = NDIS_STATUS_SUCCESS;
+	//BOOLEAN		StateMachineTouched = FALSE;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		return 0;
+	do{
+		Now = jiffies;
+
+		if ((OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED)) &&
+			((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+			(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+			(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+			(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) &&
+			(pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+			)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "!!! Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n");
+			Status = NDIS_STATUS_SUCCESS;
+			break;
+		}
+
+		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE  && (pAdapter->MLMEThr_pid > 0))
+		{
+			MlmeEnqueue(pAdapter,
+                        MLME_CNTL_STATE_MACHINE,
+                        RT_CMD_RESET_MLME,
+                        0,
+                        NULL);
+		}
+
+		// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+		// this request, because this request is initiated by NDIS.
+		pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
+		// Reset Missed scan number
+		pAdapter->PortCfg.ScanCnt = 0;
+		pAdapter->PortCfg.LastScanTime = Now;
+
+		MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_BSSID_LIST_SCAN,
+					0,
+					NULL);
+		RTUSBMlmeUp(pAdapter);
+
+		Status = NDIS_STATUS_SUCCESS;
+		//StateMachineTouched = TRUE;
+
+	}while(0);
+	return 0;
+}
+
+#define MAX_CUSTOM_LEN 64
+int
+rt_ioctl_giwscan(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	int i=2, j;
+	char *current_ev = extra, *previous_ev = extra;
+	char *end_buf = extra + IW_SCAN_MAX_DATA;   // some of platforms restricted on IW_SCAN_MAX_DATA
+	char *current_val;
+    struct iw_event iwe;
+
+#if 0   // support bit rate, extended rate, quality and last beacon timing
+    //-------------------------------------------
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	char SupRateLen, ExtRateLen;
+	char rate, max_rate;
+    int  k;
+	//-------------------------------------------
+#endif
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)){
+		/*
+		 * Still scanning, indicate the caller should try again.
+		 */
+		return -EAGAIN;
+	}
+	for (i = 0; i < pAdapter->ScanTab.BssNr; i++)
+	{
+		if (current_ev >= end_buf)
+			break;
+
+		//MAC address
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWAP;
+		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        memcpy(iwe.u.ap_addr.sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid, ETH_ALEN);
+
+        previous_ev = current_ev;
+        current_ev = iwe_stream_add_event(current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
+        if (current_ev == previous_ev)
+            break;
+
+		//ESSID
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWESSID;
+		iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].SsidLen;
+		iwe.u.data.flags = 1;
+
+        previous_ev = current_ev;
+		current_ev = iwe_stream_add_point(current_ev,end_buf, &iwe, pAdapter->ScanTab.BssEntry[i].Ssid);
+        if (current_ev == previous_ev)
+            break;
+
+		//Network Type
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWMODE;
+		if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11IBSS)
+		{
+			iwe.u.mode = IW_MODE_ADHOC;
+		}
+		else if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11Infrastructure)
+		{
+			iwe.u.mode = IW_MODE_INFRA;
+		}
+		else
+		{
+			iwe.u.mode = IW_MODE_AUTO;
+		}
+		iwe.len = IW_EV_UINT_LEN;
+
+        previous_ev = current_ev;
+		current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe,  IW_EV_UINT_LEN);
+        if (current_ev == previous_ev)
+            break;
+
+		//Channel and Frequency
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWFREQ;
+		if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+			iwe.u.freq.m = pAdapter->ScanTab.BssEntry[i].Channel;
+		else
+			iwe.u.freq.m = pAdapter->ScanTab.BssEntry[i].Channel;
+		iwe.u.freq.e = 0;
+		iwe.u.freq.i = 0;
+
+		previous_ev = current_ev;
+		current_ev = iwe_stream_add_event(current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
+        if (current_ev == previous_ev)
+            break;
+
+		//Encyption key
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWENCODE;
+		if (CAP_IS_PRIVACY_ON (pAdapter->ScanTab.BssEntry[i].CapabilityInfo ))
+			iwe.u.data.flags =IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		else
+			iwe.u.data.flags = IW_ENCODE_DISABLED;
+
+        previous_ev = current_ev;
+        current_ev = iwe_stream_add_point(current_ev, end_buf,&iwe,  (char *)pAdapter->SharedKey[(iwe.u.data.flags & IW_ENCODE_INDEX)-1].Key);
+        if (current_ev == previous_ev)
+            break;
+
+#if 1	// support bit rate
+		//Bit Rate
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWRATE;
+		current_val = current_ev + IW_EV_LCP_LEN;
+		//for (j = 0; j < pAdapter->ScanTab.BssEntry[i].RatesLen;j++)
+		for (j = 0; j < 1;j++)
+		{
+			iwe.u.bitrate.value = RateIdToMbps[pAdapter->ScanTab.BssEntry[i].SupRate[i]/2] * 1000000;
+			iwe.u.bitrate.disabled = 0;
+			current_val = iwe_stream_add_value(current_ev,
+				current_val, end_buf, &iwe,
+				IW_EV_PARAM_LEN);
+		}
+
+
+        if((current_val-current_ev)>IW_EV_LCP_LEN)
+            current_ev = current_val;
+        else
+            break;
+
+
+#else	// support bit rate, extended rate, quality and last beacon timing
+        // max. of displays used IW_SCAN_MAX_DATA are about 22~24 cells
+		//Bit Rate
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWRATE;
+		current_val = current_ev + IW_EV_LCP_LEN;
+
+		SupRateLen = pAdapter->ScanTab.BssEntry[i].SupRateLen;
+		ExtRateLen = pAdapter->ScanTab.BssEntry[i].ExtRateLen;
+
+		max_rate = 0;
+		p = custom;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+		for (k = 0, j = 0; k < SupRateLen; )
+		{
+			if (j < ExtRateLen &&
+			((pAdapter->ScanTab.BssEntry[i].ExtRate[j] & 0x7F) <
+				(pAdapter->ScanTab.BssEntry[i].SupRate[k] & 0x7F)))
+			{
+				rate = pAdapter->ScanTab.BssEntry[i].ExtRate[j++] & 0x7F;
+			}
+			else
+			{
+				rate = pAdapter->ScanTab.BssEntry[i].SupRate[k++] & 0x7F;
+			}
+
+			if (rate > max_rate)
+				max_rate = rate;
+			p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+					  "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		}
+
+		for (; j < ExtRateLen; j++)
+		{
+			rate = pAdapter->ScanTab.BssEntry[i].ExtRate[j] & 0x7F;
+			p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+					  "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+			if (rate > max_rate)
+				max_rate = rate;
+		}
+		iwe.u.bitrate.value = max_rate * 500000;
+		iwe.u.bitrate.disabled = 0;
+		current_val = iwe_stream_add_value(current_ev,
+			current_val, end_buf, &iwe,
+			IW_EV_PARAM_LEN);
+		if((current_val-current_ev)>IW_EV_LCP_LEN)
+			current_ev = current_val;
+		else
+		    break;
+
+		//Extended Rate
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		iwe.u.data.length = p - custom;
+		if (iwe.u.data.length)
+		{
+		    previous_ev = current_ev;
+			current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, custom);
+            if (current_ev == previous_ev)
+                break;
+        }
+		//Quality Statistics
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVQUAL;
+		set_quality(pAdapter, &iwe.u.qual, pAdapter->ScanTab.BssEntry[i].Rssi);
+
+		previous_ev = current_ev;
+		current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+        if (current_ev == previous_ev)
+            break;
+
+		//Age to display seconds since last beacon
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		p = custom;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+				  " Last beacon: %lums ago", (jiffies - pAdapter->ScanTab.BssEntry[i].LastBeaconRxTime) / (HZ / 100));
+		iwe.u.data.length = p - custom;
+		if (iwe.u.data.length)
+		{
+		    previous_ev = current_ev;
+			current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, custom);
+            if (current_ev == previous_ev)
+                break;
+        }
+#endif
+
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+
+	}
+	data->length = current_ev - extra;
+	DBGPRINT(RT_DEBUG_ERROR,"===>rt_ioctl_giwscan. %d(%d) BSS returned\n",i , pAdapter->ScanTab.BssNr);
+	return 0;
+}
+#endif
+
+int rt_ioctl_siwessid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *essid)
+{
+
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	ULONG		Length;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+    memset(&Ssid, 0, sizeof(NDIS_802_11_SSID));
+
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	Length = data->length - 1;
+	#else
+	Length = data->length;
+	#endif
+
+	if (data->flags)
+	{
+		if (data->length > IW_ESSID_MAX_SIZE)
+		{
+			return -E2BIG;
+		}
+
+		memcpy(Ssid.Ssid, essid, Length);
+		Ssid.SsidLength = Length;	//minus null character.
+
+		memcpy(pAdapter->PortCfg.Ssid, essid, Length);
+		pAdapter->PortCfg.SsidLen = Length;
+	}
+	else
+	{
+		Ssid.SsidLength = 0;  // ANY ssid
+        memcpy(Ssid.Ssid, "", 0);
+
+		// reset to infra/open/none as the user set ANY ssid
+        // $ iwconfig [interface] essid ""
+		pAdapter->PortCfg.BssType = BSS_INFRA;
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+		pAdapter->PortCfg.WepStatus  = Ndis802_11EncryptionDisabled;
+    }
+
+	pSsid = &Ssid;
+
+	if ((pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) && (pAdapter->MLMEThr_pid > 0))
+	{
+		MlmeEnqueue(pAdapter,
+                    MLME_CNTL_STATE_MACHINE,
+                    RT_CMD_RESET_MLME,
+                    0,
+                    NULL);
+    }
+
+	// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+	// this request, because this request is initiated by NDIS.
+
+	// To prevent some kernel thread is very low priority ...so essid copy immediately for later wpapsk counting.
+	if ((pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA) && (pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone))
+		memcpy(pAdapter->MlmeAux.Ssid, Ssid.Ssid, Ssid.SsidLength);
+
+	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
+	DBGPRINT(RT_DEBUG_TRACE,"===>rt_ioctl_siwessid:: (Ssid.SsidLength = %d, %s)\n",Ssid.SsidLength, Ssid.Ssid);
+
+	if (pAdapter->MLMEThr_pid > 0)
+	{
+		MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_SSID,
+					sizeof(NDIS_802_11_SSID),
+					(VOID *)pSsid);
+	}
+	RTUSBMlmeUp(pAdapter);
+
+	return 0;
+}
+
+int rt_ioctl_giwessid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *essid)
+{
+
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	data->flags = 1;		/* active */
+
+	data->length = pAdapter->PortCfg.SsidLen;
+	memcpy(essid, pAdapter->PortCfg.Ssid, pAdapter->PortCfg.SsidLen);
+	pAdapter->PortCfg.Ssid[pAdapter->PortCfg.SsidLen] = '\0';
+	DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_giwessid:: (Len=%d, ssid=%s...)\n", pAdapter->PortCfg.SsidLen, pAdapter->PortCfg.Ssid);
+
+	return 0;
+
+}
+
+int rt_ioctl_siwnickn(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *nickname)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (data->length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+
+	memset(pAdapter->nickn, 0, IW_ESSID_MAX_SIZE);
+	memcpy(pAdapter->nickn, nickname, data->length);
+
+
+	return 0;
+}
+
+int rt_ioctl_giwnickn(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *nickname)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	data->length = strlen(pAdapter->nickn) ;
+	memcpy(nickname, pAdapter->nickn, data->length);
+	nickname[data->length] = '\0';
+	data->flags = 1;
+	return 0;
+}
+
+int rt_ioctl_siwrts(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_param *rts, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	u16 val;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (rts->disabled)
+		val = MAX_RTS_THRESHOLD;
+	else if (rts->value < 0 || rts->value > MAX_RTS_THRESHOLD)
+		return -EINVAL;
+	else if (rts->value == 0)
+		val = MAX_RTS_THRESHOLD;
+	else
+		val = rts->value;
+
+	pAdapter->PortCfg.RtsThreshold = val;
+
+	return 0;
+}
+
+int rt_ioctl_giwrts(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_param *rts, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	rts->value = pAdapter->PortCfg.RtsThreshold;
+	rts->disabled = (rts->value == MAX_RTS_THRESHOLD);
+	rts->fixed = 1;
+
+	return 0;
+}
+
+int rt_ioctl_siwfrag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *rts, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	u16 val;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (rts->disabled)
+		val = MAX_FRAG_THRESHOLD;
+	else if (rts->value >= MIN_FRAG_THRESHOLD || rts->value <= MAX_FRAG_THRESHOLD)
+		val = __cpu_to_le16(rts->value & ~0x1); /* even numbers only */
+	else if (rts->value == 0)
+		val = MAX_FRAG_THRESHOLD;
+	else
+		return -EINVAL;
+
+	pAdapter->PortCfg.FragmentThreshold = val;
+	return 0;
+}
+
+int rt_ioctl_giwfrag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *rts, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	rts->value = pAdapter->PortCfg.FragmentThreshold;
+	rts->disabled = (rts->value == 2346);
+	rts->fixed = 1;
+
+	return 0;
+}
+
+int rt_ioctl_siwencode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_point *erq, char *keybuf)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	union {
+		char buf[sizeof(NDIS_802_11_WEP)+MAX_LEN_OF_KEY- 1];
+		NDIS_802_11_WEP keyinfo;
+	} WepKey;
+	int 	index, i, len;
+	CHAR	kid = 0;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	memset(&WepKey, 0, sizeof(WepKey));
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		pAdapter->PortCfg.PairCipher = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.WepStatus = Ndis802_11WEPDisabled;
+	}
+	else
+	{
+		pAdapter->PortCfg.PairCipher = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.WepStatus = Ndis802_11WEPEnabled;
+	}
+
+	if (erq->flags & IW_ENCODE_RESTRICTED)
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+	else
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+	if(pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+	if ((erq->flags & IW_ENCODE_DISABLED) == 0)
+	{
+		/* Enable crypto. */
+		if (erq->length > IFNAMSIZ)
+			return -EINVAL;
+
+		/* Old solution to take  default key  */
+		index = (erq->flags & IW_ENCODE_INDEX) ;
+		if((index < 0) || (index > NR_WEP_KEYS))
+			return -EINVAL;
+		DBGPRINT(RT_DEBUG_TRACE," erq->flags = %x\n",erq->flags);
+
+		if (index != 0)
+		{
+			pAdapter->PortCfg.DefaultKeyId = index -1;
+		}
+
+		if ((erq->length == 1) && (index == 0))
+		{
+			/* New solution to take  default key  when old way not work, not change KeyMaterial*/
+			memcpy(&kid, keybuf, 1 );
+			if((index < 0) || (index >= NR_WEP_KEYS))
+				return -EINVAL;
+
+			DBGPRINT(RT_DEBUG_TRACE,"kid = %d , erq->length = %d\n",kid, erq->length);
+			if (kid > 0)
+				pAdapter->PortCfg.DefaultKeyId = kid-1;
+			else
+				pAdapter->PortCfg.DefaultKeyId = 0;
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"DefaultKeyId = %d , erq->length = %d, flags 0x%x\n",pAdapter->PortCfg.DefaultKeyId, erq->length,erq->flags);
+			len = erq->length;
+			if(len > WEP_LARGE_KEY_LEN)
+				len = WEP_LARGE_KEY_LEN;
+
+			// If this instruction default key
+			memset(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, 0, MAX_LEN_OF_KEY);
+			memcpy(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, keybuf, len);
+			memcpy(WepKey.keyinfo.KeyMaterial, keybuf, len);
+			WepKey.keyinfo.KeyIndex = 0x80000000 + pAdapter->PortCfg.DefaultKeyId;
+			WepKey.keyinfo.KeyLength = len;
+			pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen =(UCHAR) (len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN);
+			DBGPRINT(RT_DEBUG_TRACE,"SharedKey	");
+			for (i=0; i < 5;i++)
+				DBGPRINT_RAW(RT_DEBUG_TRACE,"	%x ", pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key[i]);
+			DBGPRINT(RT_DEBUG_TRACE,   "\n");
+			// need to enqueue cmd to thread
+			RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey.keyinfo) + len - 1);
+
+		}
+
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::AuthMode=%x\n",pAdapter->PortCfg.AuthMode);
+	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",pAdapter->PortCfg.DefaultKeyId , pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen);
+	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::WepStatus=%x\n",pAdapter->PortCfg.WepStatus);
+	return 0;
+}
+
+int
+rt_ioctl_giwencode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_point *erq, char *key)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	int kid;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	kid = erq->flags & IW_ENCODE_INDEX;
+	DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_giwencode %d\n", erq->flags & IW_ENCODE_INDEX);
+
+	if (pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+	{
+		erq->length = 0;
+		erq->flags = IW_ENCODE_DISABLED;
+	}
+	else if ((kid > 0) && (kid <=4))
+	{
+		// copy wep key
+		erq->flags = kid ;			/* NB: base 1 */
+		if (erq->length > pAdapter->SharedKey[kid-1].KeyLen)
+			erq->length = pAdapter->SharedKey[kid-1].KeyLen;
+		memcpy(key, pAdapter->SharedKey[kid-1].Key, erq->length);
+		//if ((kid == pAdapter->PortCfg.DefaultKeyId))
+		//erq->flags |= IW_ENCODE_ENABLED;	/* XXX */
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+		else
+			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
+
+	}
+	else if (kid == 0)
+	{
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+		else
+			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
+		erq->length = pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen;
+		memcpy(key, pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, erq->length);
+		// copy default key ID
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+		else
+			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
+		erq->flags = pAdapter->PortCfg.DefaultKeyId + 1;			/* NB: base 1 */
+		erq->flags |= IW_ENCODE_ENABLED;	/* XXX */
+	}
+
+	return 0;
+
+}
+
+static int
+rt_ioctl_setparam(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	char *this_char = extra;
+	char *value;
+	int  Status=0;
+
+    //check if the interface is down
+    if (pAdapter->RTUSBCmdThr_pid < 0)
+        return -ENETDOWN;
+
+	if (!*this_char)
+		return Status;
+
+	if ((value = rtstrchr(this_char, '=')) != NULL)
+		*value++ = 0;
+
+	if (!value)
+		return Status;
+
+	// reject setting nothing besides ANY ssid(ssidLen=0)
+	if (!*value && (strcmp(this_char, "SSID") != 0))
+		return Status;
+
+	for (PRTMP_PRIVATE_SET_PROC = RTMP_PRIVATE_SUPPORT_PROC; PRTMP_PRIVATE_SET_PROC->name; PRTMP_PRIVATE_SET_PROC++)
+	{
+		if (strcmp(this_char, PRTMP_PRIVATE_SET_PROC->name) == 0)
+		{
+			if(!PRTMP_PRIVATE_SET_PROC->set_proc(pAdapter, value))
+			{	//FALSE:Set private failed then return Invalid argument
+				Status = -EINVAL;
+			}
+			break;	//Exit for loop.
+		}
+	}
+
+	if(PRTMP_PRIVATE_SET_PROC->name == NULL)
+	{  //Not found argument
+		Status = -EINVAL;
+		DBGPRINT(RT_DEBUG_TRACE, "===>rt_ioctl_setparam:: (iwpriv) Not Support Set Command [%s=%s]\n", this_char, value);
+	}
+
+	return Status;
+}
+
+static const iw_handler rt_handler[] =
+{
+	(iw_handler) NULL,						/* SIOCSIWCOMMIT */
+	(iw_handler) rt_ioctl_giwname,			/* SIOCGIWNAME	1 */
+	(iw_handler) NULL,						/* SIOCSIWNWID */
+	(iw_handler) NULL,						/* SIOCGIWNWID */
+	(iw_handler) rt_ioctl_siwfreq,			/* SIOCSIWFREQ */
+	(iw_handler) rt_ioctl_giwfreq,			/* SIOCGIWFREQ	5 */
+	(iw_handler) rt_ioctl_siwmode,			/* SIOCSIWMODE */
+	(iw_handler) rt_ioctl_giwmode,			/* SIOCGIWMODE */
+	(iw_handler) NULL,						/* SIOCSIWSENS */
+	(iw_handler) NULL,						/* SIOCGIWSENS */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWRANGE */
+	(iw_handler) rt_ioctl_giwrange,			/* SIOCGIWRANGE 11 */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWPRIV */
+	(iw_handler) NULL /* kernel code */,	/* SIOCGIWPRIV */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWSTATS */
+	(iw_handler) NULL /* kernel code */,	/* SIOCGIWSTATS f */
+	(iw_handler) NULL,						/* SIOCSIWSPY */
+	(iw_handler) NULL,						/* SIOCGIWSPY */
+	(iw_handler) NULL,						/* -- hole -- */
+	(iw_handler) NULL,						/* -- hole -- */
+	(iw_handler) NULL,						/* SIOCSIWAP */
+	(iw_handler) rt_ioctl_giwap,			/* SIOCGIWAP	0x15*/
+	(iw_handler) NULL,						/* -- hole --	0x16 */
+	(iw_handler) rt_ioctl_iwaplist,			/* SIOCGIWAPLIST */
+#ifdef SIOCGIWSCAN
+	(iw_handler) rt_ioctl_siwscan,			/* SIOCSIWSCAN	0x18*/
+	(iw_handler) rt_ioctl_giwscan,			/* SIOCGIWSCAN */
+#else
+	(iw_handler) NULL,						/* SIOCSIWSCAN */
+	(iw_handler) NULL,						/* SIOCGIWSCAN */
+#endif /* SIOCGIWSCAN */
+	(iw_handler) rt_ioctl_siwessid,			/* SIOCSIWESSID */
+	(iw_handler) rt_ioctl_giwessid,			/* SIOCGIWESSID */
+	(iw_handler) rt_ioctl_siwnickn,			/* SIOCSIWNICKN */
+	(iw_handler) rt_ioctl_giwnickn,			/* SIOCGIWNICKN 1d*/
+	(iw_handler) NULL,						/* -- hole -- */
+	(iw_handler) NULL,						/* -- hole -- */
+	(iw_handler) NULL,						/* SIOCSIWRATE	20*/
+	(iw_handler) NULL,						/* SIOCGIWRATE */
+	(iw_handler) rt_ioctl_siwrts,			/* SIOCSIWRTS */
+	(iw_handler) rt_ioctl_giwrts,			/* SIOCGIWRTS */
+	(iw_handler) rt_ioctl_siwfrag,			/* SIOCSIWFRAG */
+	(iw_handler) rt_ioctl_giwfrag,			/* SIOCGIWFRAG	25*/
+	(iw_handler) NULL,						/* SIOCSIWTXPOW */
+	(iw_handler) NULL,						/* SIOCGIWTXPOW */
+	(iw_handler) NULL,						/* SIOCSIWRETRY */
+	(iw_handler) NULL,						/* SIOCGIWRETRY  29*/
+	(iw_handler) rt_ioctl_siwencode,		/* SIOCSIWENCODE 2a*/
+	(iw_handler) rt_ioctl_giwencode,		/* SIOCGIWENCODE 2b*/
+	(iw_handler) NULL,						/* SIOCSIWPOWER  2c*/
+	(iw_handler) NULL,						/* SIOCGIWPOWER  2d*/
+};
+
+static const iw_handler rt_priv_handlers[] = {
+	(iw_handler) rt_ioctl_setparam,		/* SIOCWFIRSTPRIV+1 */
+};
+
+const struct iw_handler_def rt73_iw_handler_def =
+{
+#define	N(a)	(sizeof (a) / sizeof (a[0]))
+	.standard	= (iw_handler *) rt_handler,
+	.num_standard	= sizeof(rt_handler) / sizeof(iw_handler),
+	.private	= (iw_handler *) rt_priv_handlers,
+	.num_private		= N(rt_priv_handlers),
+	.private_args	= (struct iw_priv_args *) privtab,
+	.num_private_args	= N(privtab),
+#if IW_HANDLER_VERSION >= 6
+	.get_wireless_stats = rt73_get_wireless_stats,
+#endif
+#if WIRELESS_EXT > 15
+//	.spy_offset	= offsetof(struct hostap_interface, spy_data),
+#endif /* WIRELESS_EXT > 15 */
+};
+
+INT RTMPSetInformation(
+	IN	PRTMP_ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 				cmd)
+{
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	NDIS_802_11_MAC_ADDRESS 			Bssid;
+	RT_802_11_PHY_MODE					PhyMode;
+	RT_802_11_STA_CONFIG				StaConfig, *pStaConfig=NULL;
+	NDIS_802_11_RATES					aryRates;
+	RT_802_11_PREAMBLE					Preamble;
+	NDIS_802_11_WEP_STATUS				WepStatus;
+	NDIS_802_11_AUTHENTICATION_MODE 	AuthMode;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_POWER_MODE				PowerMode;
+	NDIS_802_11_TX_POWER_LEVEL			TxPowerLevel;
+	PNDIS_802_11_KEY					pKey = NULL;
+	PNDIS_802_11_REMOVE_KEY 			pRemoveKey = NULL;
+	NDIS_802_11_CONFIGURATION			Config, *pConfig = NULL;
+	NDIS_802_11_NETWORK_TYPE			NetType;
+	ULONG								Now;
+	ULONG								KeyIdx;
+	INT 								Status = NDIS_STATUS_SUCCESS;
+	ULONG								AntDiv;
+	BOOLEAN 							RadioState;
+    BOOLEAN							    StateMachineTouched = FALSE;
+
+#if WPA_SUPPLICANT_SUPPORT
+    PNDIS_802_11_WEP			        pWepKey =NULL;
+    PNDIS_802_11_PMKID                  pPmkId = NULL;
+    BOOLEAN				                IEEE8021xState;
+    BOOLEAN				                IEEE8021x_required_keys;
+    BOOLEAN                             wpa_supplicant_enable;
+    BOOLEAN                             start_send_beacon_up;
+#endif
+
+	switch(cmd & 0x7FFF) {
+		case RT_OID_802_11_COUNTRY_REGION:
+			if (wrq->u.data.length < sizeof(UCHAR))
+				Status = -EINVAL;
+			else if (!(pAdapter->PortCfg.CountryRegion & 0x80) && !(pAdapter->PortCfg.CountryRegionForABand & 0x80))	// Only avaliable when EEPROM not programming
+			{
+				ULONG	Country;
+				UCHAR	TmpPhy;
+
+				Status = copy_from_user(&Country, wrq->u.data.pointer, wrq->u.data.length);
+				pAdapter->PortCfg.CountryRegion = (UCHAR)(Country & 0x000000FF);
+				pAdapter->PortCfg.CountryRegionForABand = (UCHAR)((Country >> 8) & 0x000000FF);
+
+				TmpPhy = pAdapter->PortCfg.PhyMode;
+				pAdapter->PortCfg.PhyMode = 0xff;
+				// Build all corresponding channel information
+				Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_SET_PHY_MODE, TRUE, &TmpPhy, sizeof(TmpPhy));
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_SET_COUNTRY_REGION (A:%d  B/G:%d)\n", pAdapter->PortCfg.CountryRegionForABand,
+					pAdapter->PortCfg.CountryRegion);
+			}
+			break;
+		case OID_802_11_BSSID_LIST_SCAN:
+			Now = jiffies;
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_BSSID_LIST_SCAN, TxCnt = %d \n", pAdapter->BulkLastOneSecCount);
+
+			if (pAdapter->BulkLastOneSecCount > 100)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "!!! Link UP, ignore this set::OID_802_11_BSSID_LIST_SCAN\n");
+				//Status = NDIS_STATUS_SUCCESS;
+				pAdapter->PortCfg.ScanCnt = 99;		// Prevent auto scan triggered by this OID
+				break;
+			}
+
+			if ((OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED)) &&
+				((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+				(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+				(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+				(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+#if WPA_SUPPLICANT_SUPPORT
+			  	 || (pAdapter->PortCfg.IEEE8021X == TRUE)
+#endif
+				) &&
+				(pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "!!! Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n");
+				Status = NDIS_STATUS_SUCCESS;
+				pAdapter->PortCfg.ScanCnt = 99;		// Prevent auto scan triggered by this OID
+				break;
+			}
+
+			Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_BSSID_LIST_SCAN, TRUE, NULL, 0);
+			break;
+		case OID_802_11_SSID:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_SSID))
+				Status = -EINVAL;
+			else
+			{
+				Status = copy_from_user(&Ssid, wrq->u.data.pointer, wrq->u.data.length);
+				pSsid = &Ssid;
+
+				if (pSsid->SsidLength > MAX_LEN_OF_SSID)
+					Status = -EINVAL;
+				else
+				{
+					// reset SSID to null
+					if (pSsid->SsidLength == 0)
+					{
+						memcpy(pSsid->Ssid, "", 0);
+					}
+
+					RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_SSID, TRUE, pSsid, sizeof(NDIS_802_11_SSID));
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_SSID (Len=%d,Ssid=%s)\n", pSsid->SsidLength, pSsid->Ssid);
+				}
+			}
+			break;
+		case OID_802_11_BSSID:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_MAC_ADDRESS))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&Bssid, wrq->u.data.pointer, wrq->u.data.length);
+
+				RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_BSSID, TRUE, &Bssid, wrq->u.data.length);
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_BSSID %02x:%02x:%02x:%02x:%02x:%02x\n",
+										Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]);
+			}
+			break;
+		case RT_OID_802_11_RADIO:
+			if (wrq->u.data.length != sizeof(BOOLEAN))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&RadioState, wrq->u.data.pointer, wrq->u.data.length);
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_RADIO (=%d)\n", RadioState);
+				if (pAdapter->PortCfg.bSwRadio != RadioState)
+				{
+					pAdapter->PortCfg.bSwRadio = RadioState;
+					if (pAdapter->PortCfg.bRadio != (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio))
+					{
+						pAdapter->PortCfg.bRadio = (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio);
+						RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_SET_RADIO, TRUE, NULL, 0);
+					}
+				}
+			}
+			break;
+		case RT_OID_802_11_PHY_MODE:
+			if (wrq->u.data.length != sizeof(RT_802_11_PHY_MODE))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&PhyMode, wrq->u.data.pointer, wrq->u.data.length);
+				RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_PHY_MODE, TRUE, &PhyMode, sizeof(RT_802_11_PHY_MODE));
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_PHY_MODE (=%d)\n", PhyMode);
+			}
+			break;
+		case RT_OID_802_11_STA_CONFIG:
+			if (wrq->u.data.length != sizeof(RT_802_11_STA_CONFIG))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&StaConfig, wrq->u.data.pointer, wrq->u.data.length);
+				pStaConfig = &StaConfig;
+				RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_STA_CONFIG, TRUE, pStaConfig, sizeof(RT_802_11_STA_CONFIG));
+
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_SET_STA_CONFIG (Burst=%d,BGprot=%d,ShortSlot=%d,Adhoc=%d\n",
+					pStaConfig->EnableTxBurst,
+					pStaConfig->UseBGProtection,
+					pStaConfig->UseShortSlotTime,
+					pStaConfig->AdhocMode);
+			}
+			break;
+		case OID_802_11_DESIRED_RATES:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RATES))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&aryRates, wrq->u.data.pointer, wrq->u.data.length);
+				memset(pAdapter->PortCfg.DesireRate, 0, MAX_LEN_OF_SUPPORTED_RATES);
+				memcpy(pAdapter->PortCfg.DesireRate, &aryRates, sizeof(NDIS_802_11_RATES));
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_DESIRED_RATES (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
+					pAdapter->PortCfg.DesireRate[0],pAdapter->PortCfg.DesireRate[1],
+					pAdapter->PortCfg.DesireRate[2],pAdapter->PortCfg.DesireRate[3],
+					pAdapter->PortCfg.DesireRate[4],pAdapter->PortCfg.DesireRate[5],
+					pAdapter->PortCfg.DesireRate[6],pAdapter->PortCfg.DesireRate[7] );
+					// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+					RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_UPDATE_TX_RATE, TRUE, NULL, 0);
+			}
+			break;
+		case RT_OID_802_11_PREAMBLE:
+			if (wrq->u.data.length != sizeof(RT_802_11_PREAMBLE))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&Preamble, wrq->u.data.pointer, wrq->u.data.length);
+				if ((Preamble == Rt802_11PreambleShort) || (Preamble == Rt802_11PreambleLong) || (Preamble == Rt802_11PreambleAuto))
+				{
+					RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_PREAMBLE, TRUE, &Preamble, sizeof(RT_802_11_PREAMBLE));
+				}
+				else
+				{
+					Status = -EINVAL;
+					break;
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_SET_PREAMBLE (=%d)\n", Preamble);
+			}
+			break;
+		case OID_802_11_WEP_STATUS:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_WEP_STATUS))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&WepStatus, wrq->u.data.pointer, wrq->u.data.length);
+				// Since TKIP, AES, WEP are all supported. It should not have any invalid setting
+				if (WepStatus <= Ndis802_11Encryption3KeyAbsent)
+				{
+					if (pAdapter->PortCfg.WepStatus != WepStatus)
+					{
+						// Config has changed
+						pAdapter->bConfigChanged = TRUE;
+					}
+					//Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_WEP_STATUS, TRUE, &WepStatus, sizeof(NDIS_802_11_WEP_STATUS));
+					pAdapter->PortCfg.WepStatus 	= WepStatus;
+					pAdapter->PortCfg.OrigWepStatus = WepStatus;
+					pAdapter->PortCfg.PairCipher	= WepStatus;
+					pAdapter->PortCfg.GroupCipher	= WepStatus;
+				}
+				else
+				{
+					Status	= -EINVAL;
+					break;
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_WEP_STATUS (=%d)\n",WepStatus);
+			}
+			break;
+		case OID_802_11_AUTHENTICATION_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_AUTHENTICATION_MODE))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&AuthMode, wrq->u.data.pointer, wrq->u.data.length);
+				if (AuthMode > Ndis802_11AuthModeMax)
+				{
+					Status	= -EINVAL;
+					break;
+				}
+				else
+				{
+					if (pAdapter->PortCfg.AuthMode != AuthMode)
+					{
+						// Config has changed
+						pAdapter->bConfigChanged = TRUE;
+					}
+					pAdapter->PortCfg.AuthMode = AuthMode;
+				}
+				pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_AUTHENTICATION_MODE (=%d) \n",pAdapter->PortCfg.AuthMode);
+			}
+			break;
+		case OID_802_11_INFRASTRUCTURE_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_INFRASTRUCTURE))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&BssType, wrq->u.data.pointer, wrq->u.data.length);
+				if (BssType == Ndis802_11IBSS)
+				{
+					if (pAdapter->PortCfg.BssType != BSS_ADHOC)
+					{
+						// Config has changed
+						if (INFRA_ON(pAdapter))
+						{
+							RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+							// First cancel linkdown timer
+							DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n");
+						}
+						//pAdapter->bConfigChanged = TRUE;
+					}
+					pAdapter->PortCfg.BssType = BSS_ADHOC;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (AD-HOC)\n");
+				}
+				else if (BssType == Ndis802_11Infrastructure)
+				{
+					if (pAdapter->PortCfg.BssType != BSS_INFRA)
+					{
+						// Config has changed
+						//pAdapter->bConfigChanged = TRUE;
+						if (ADHOC_ON(pAdapter))
+							RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+					}
+					pAdapter->PortCfg.BssType = BSS_INFRA;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (INFRA)\n");
+				}
+				else
+				{
+					Status	= -EINVAL;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (unknown)\n");
+				}
+			}
+			// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+			pAdapter->PortCfg.WpaState = SS_NOTUSE;
+			break;
+	    case OID_802_11_REMOVE_WEP:
+            DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_WEP\n");
+            if (wrq->u.data.length != sizeof(NDIS_802_11_KEY_INDEX)){
+		        Status = -EINVAL;
+            }
+            else
+            {
+		        KeyIdx = *(NDIS_802_11_KEY_INDEX *) wrq->u.data.pointer;
+
+		        if (KeyIdx & 0x80000000)
+		        {
+			        // Should never set default bit when remove key
+			        Status = -EINVAL;
+		        }
+		        else
+		        {
+			        KeyIdx = KeyIdx & 0x0fffffff;
+			        if (KeyIdx >= 4){
+				        Status = -EINVAL;
+			        }
+			        else
+			        {
+				        pAdapter->SharedKey[KeyIdx].KeyLen = 0;
+				        pAdapter->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+				        AsicRemoveSharedKeyEntry(pAdapter, 0, (UCHAR)KeyIdx);
+			        }
+		        }
+            }
+            break;
+		case RT_OID_802_11_RESET_COUNTERS:
+			memset(&pAdapter->WlanCounters, 0, sizeof(COUNTER_802_11));
+			memset(&pAdapter->Counters8023, 0, sizeof(COUNTER_802_3));
+			memset(&pAdapter->RalinkCounters, 0, sizeof(COUNTER_RALINK));
+			pAdapter->Counters8023.RxNoBuffer	= 0;
+			pAdapter->Counters8023.GoodReceives = 0;
+			pAdapter->Counters8023.RxNoBuffer	= 0;
+			DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_RESET_COUNTERS (=%d)\n", pAdapter->Counters8023.GoodReceives);
+			break;
+		case OID_802_11_RTS_THRESHOLD:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RTS_THRESHOLD))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&RtsThresh, wrq->u.data.pointer, wrq->u.data.length);
+				if (RtsThresh > MAX_RTS_THRESHOLD)
+					Status	= -EINVAL;
+				else
+					pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_RTS_THRESHOLD (=%d)\n",RtsThresh);
+			break;
+		case OID_802_11_FRAGMENTATION_THRESHOLD:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_FRAGMENTATION_THRESHOLD))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&FragThresh, wrq->u.data.pointer, wrq->u.data.length);
+				pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+				if (FragThresh > MAX_FRAG_THRESHOLD || FragThresh < MIN_FRAG_THRESHOLD)
+				{
+					if (FragThresh == 0)
+					{
+						pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+						pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
+					}
+					else
+						Status	= -EINVAL;
+				}
+				else
+					pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_FRAGMENTATION_THRESHOLD (=%d) \n",FragThresh);
+			break;
+		case OID_802_11_POWER_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_POWER_MODE))
+				Status = -EINVAL;
+			else
+			{
+				Status = copy_from_user(&PowerMode, wrq->u.data.pointer, wrq->u.data.length);
+				// save user's policy here, but not change PortCfg.Psm immediately
+				if (PowerMode == Ndis802_11PowerModeCAM)
+				{
+					// clear PSM bit immediately
+					MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+
+					OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+					if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+					pAdapter->PortCfg.WindowsBatteryPowerMode = PowerMode;
+				}
+				else if (PowerMode == Ndis802_11PowerModeMAX_PSP)
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+					// to exclude certain situations.
+					//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+					if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+					pAdapter->PortCfg.WindowsBatteryPowerMode = PowerMode;
+					OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+					pAdapter->PortCfg.DefaultListenCount = 5;
+				}
+				else if (PowerMode == Ndis802_11PowerModeFast_PSP)
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+					// to exclude certain situations.
+					//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+					OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+					if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+					pAdapter->PortCfg.WindowsBatteryPowerMode = PowerMode;
+					pAdapter->PortCfg.DefaultListenCount = 3;
+				}
+				else
+					Status = -EINVAL;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_POWER_MODE (=%d)\n",PowerMode);
+			break;
+		case OID_802_11_TX_POWER_LEVEL:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_TX_POWER_LEVEL))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&TxPowerLevel, wrq->u.data.pointer, wrq->u.data.length);
+				if (TxPowerLevel > MAX_TX_POWER_LEVEL)
+					Status	= -EINVAL;
+				else
+					pAdapter->PortCfg.TxPower = (UCHAR)TxPowerLevel;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_TX_POWER_LEVEL (=%d) \n",TxPowerLevel);
+			break;
+		case RT_OID_802_11_TX_POWER_LEVEL_1:
+			if (wrq->u.data.length	< sizeof(ULONG))
+				Status = -EINVAL;
+			else
+			{
+				ULONG	PowerTemp;
+
+				Status = copy_from_user(&PowerTemp, wrq->u.data.pointer, wrq->u.data.length);
+				if (PowerTemp > 100)
+					PowerTemp = 0xffffffff;  // AUTO
+				pAdapter->PortCfg.TxPowerDefault = PowerTemp; //keep current setting.
+
+				// Only update TxPowerPercentage if the value is smaller than current AP setting
+// TODO: 2005-03-08 john removed the following line.
+//				if (pAdapter->PortCfg.TxPowerDefault < pAdapter->PortCfg.TxPowerPercentage)
+					pAdapter->PortCfg.TxPowerPercentage = pAdapter->PortCfg.TxPowerDefault;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_TX_POWER_LEVEL_1 (=%d)\n", pAdapter->PortCfg.TxPowerPercentage);
+			}
+			break;
+		case OID_802_11_PRIVACY_FILTER:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_PRIVACY_FILTER))
+				Status = -EINVAL;
+			else
+			{
+				NDIS_802_11_PRIVACY_FILTER	Filter;
+
+				Status = copy_from_user(&Filter, wrq->u.data.pointer, wrq->u.data.length);
+				if ((Filter == Ndis802_11PrivFilterAcceptAll) || (Filter == Ndis802_11PrivFilter8021xWEP))
+					pAdapter->PortCfg.PrivacyFilter = Filter;
+				else
+					Status = -EINVAL;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_PRIVACY_FILTER (=%d) \n",pAdapter->PortCfg.PrivacyFilter);
+			break;
+		case OID_802_11_NETWORK_TYPE_IN_USE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_TYPE))
+				Status = -EINVAL;
+			else
+			{
+				Status = copy_from_user(&NetType, wrq->u.data.pointer, wrq->u.data.length);
+				RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_NETWORK_TYPE_IN_USE, TRUE, &NetType, wrq->u.data.length);
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_NETWORK_TYPE_IN_USE (=%d)\n",NetType);
+			}
+			break;
+
+		case OID_802_11_RX_ANTENNA_SELECTED:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA))
+				Status = -EINVAL;
+			else
+			{
+				Status = copy_from_user(&AntDiv, wrq->u.data.pointer, wrq->u.data.length);
+				RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_RX_ANTENNA_SELECTED, FALSE, &AntDiv, wrq->u.data.length);
+			}
+			break;
+		case OID_802_11_TX_ANTENNA_SELECTED:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA))
+				Status = -EINVAL;
+			else
+			{
+				Status = copy_from_user(&AntDiv, wrq->u.data.pointer, wrq->u.data.length);
+				RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_TX_ANTENNA_SELECTED, FALSE, &AntDiv, wrq->u.data.length);
+			}
+			break;
+		// For WPA PSK PMK key
+		case RT_OID_802_11_ADD_WPA:
+			DBGPRINT(RT_DEBUG_ERROR, "!!!!!!!!!!!!!!!!!!!!!Set::RT_OID_802_11_ADD_WPA !!\n");
+			pKey = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+			if(pKey == NULL)
+			{
+				Status = -ENOMEM;
+				break;
+			}
+
+			Status = copy_from_user(pKey, wrq->u.data.pointer, wrq->u.data.length);
+			if (pKey->Length != wrq->u.data.length)
+			{
+				Status	= -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA, Failed!!\n");
+			}
+			else
+			{
+				if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&\
+					(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&\
+					(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) )
+				{
+					Status = -EOPNOTSUPP;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA, Failed!! [AuthMode != WPAPSK/WPA2PSK/WPANONE]\n");
+				}
+				else if ((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||\
+						(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ) 	// Only for WPA PSK mode
+				{
+					INT i;
+
+					pAdapter->PortCfg.PskKey.KeyLen = (UCHAR) pKey->KeyLength;
+					memcpy(pAdapter->PortCfg.PskKey.Key, &pKey->KeyMaterial, pKey->KeyLength);
+					// Use RaConfig as PSK agent.
+					// Start STA supplicant state machine
+					pAdapter->PortCfg.WpaState = SS_START;
+
+					DBGPRINT(RT_DEBUG_TRACE,"PskKey =  Len = %d \n ",pKey->KeyLength);
+					for (i = 0; i < 32; i++)
+					{
+						DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pAdapter->PortCfg.PskKey.Key[i]);
+					}
+					DBGPRINT(RT_DEBUG_TRACE,"\n");
+					// Use RaConfig as PSK agent.
+					// Start STA supplicant state machine
+					pAdapter->PortCfg.WpaState = SS_START;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA (id=0x%x, Len=%d-byte)\n", pKey->KeyIndex, pKey->KeyLength);
+				}
+				else
+				{
+					Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, pKey, pKey->Length);
+				}
+			}
+			if(pKey != NULL){
+				kfree(pKey);
+			}
+			break;
+		case OID_802_11_REMOVE_KEY:
+			pRemoveKey = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+			if(pRemoveKey == NULL)
+			{
+				Status = -ENOMEM;
+				break;
+			}
+
+			Status = copy_from_user(pRemoveKey, wrq->u.data.pointer, wrq->u.data.length);
+			if (pRemoveKey->Length != wrq->u.data.length)
+			{
+				Status = -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY, Failed!!\n");
+			}
+			else
+			{
+				Status = RTMPRemoveKeySanity(pAdapter, pRemoveKey);
+				if (Status == NDIS_STATUS_SUCCESS)
+				{
+					RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_REMOVE_KEY, TRUE, pRemoveKey, wrq->u.data.length);
+				}
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY (id=0x%x, Len=%d-byte)\n", pRemoveKey->KeyIndex, pRemoveKey->Length);
+			if(pRemoveKey != NULL){
+				kfree(pRemoveKey);
+			}
+			break;
+		// New for WPA
+		case OID_802_11_ADD_KEY:
+			DBGPRINT(RT_DEBUG_ERROR, "!!!!!!!!!!!!!!!!!!!!!Set::OID_802_11_ADD_KEY !!\n");
+			pKey = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+			if(pKey == NULL)
+			{
+				Status = -ENOMEM;
+				break;
+			}
+
+			Status = copy_from_user(pKey, wrq->u.data.pointer, wrq->u.data.length);
+			if (pKey->Length != wrq->u.data.length)
+			{
+				Status	= -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_KEY, Failed!!\n");
+			}
+			else
+			{
+				if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+				{
+					// Probably PortCfg.Bssid reset to zero as linkdown,
+				    // Set pKey.BSSID to Broadcast bssid in order to ensure AsicAddSharedKeyEntry done
+				    if(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+				    {
+				        memcpy(pKey->BSSID, BROADCAST_ADDR, 6);
+				    }
+
+					RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, pKey, pKey->Length);
+				}
+				else	// Old WEP stuff
+				{
+					Status = RTMPWPAWepKeySanity(pAdapter, pKey);
+					if (Status == NDIS_STATUS_SUCCESS)
+						RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY_WEP, TRUE, pKey, wrq->u.data.length);
+				}
+
+				KeyIdx = pKey->KeyIndex & 0x0fffffff;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_KEY (id=0x%x, Len=%d-byte)\n", KeyIdx, pKey->KeyLength);
+			}
+			if(pKey != NULL){
+				kfree(pKey);
+			}
+			break;
+#if WPA_SUPPLICANT_SUPPORT
+		case OID_802_11_SET_IEEE8021X:
+			if (wrq->u.data.length != sizeof(BOOLEAN))
+                Status  = -EINVAL;
+            else
+            {
+                Status = copy_from_user(&IEEE8021xState, wrq->u.data.pointer, wrq->u.data.length);
+				pAdapter->PortCfg.IEEE8021X = IEEE8021xState;
+
+
+		        // set WEP key to ASIC for static wep mode
+                if(pAdapter->PortCfg.IEEE8021X == FALSE && pAdapter->PortCfg.AuthMode < Ndis802_11AuthModeWPA )
+                {
+                     int idx;
+
+                     idx = pAdapter->PortCfg.DefaultKeyId;
+                     //for (idx=0; idx < 4; idx++)
+                     {
+                          DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic for static wep mode =>\n");
+
+                          if(pAdapter->PortCfg.DesireSharedKey[idx].KeyLen != 0)
+                          {
+                                 pAdapter->SharedKey[idx].KeyLen = pAdapter->PortCfg.DesireSharedKey[idx].KeyLen;
+                                 memcpy(pAdapter->SharedKey[idx].Key, pAdapter->PortCfg.DesireSharedKey[idx].Key, pAdapter->SharedKey[idx].KeyLen);
+
+                                 pAdapter->SharedKey[idx].CipherAlg = pAdapter->PortCfg.DesireSharedKey[idx].CipherAlg;
+
+                                 AsicAddSharedKeyEntry(pAdapter, 0, (UCHAR)idx, pAdapter->SharedKey[idx].CipherAlg, pAdapter->SharedKey[idx].Key, NULL, NULL);
+                          }
+                    }
+                }
+
+
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_SET_IEEE8021X (=%d)\n", pAdapter->PortCfg.IEEE8021X);
+			}
+			break;
+		case OID_802_11_SET_IEEE8021X_REQUIRE_KEY:
+			if (wrq->u.data.length != sizeof(BOOLEAN))
+				 Status  = -EINVAL;
+            else
+            {
+                Status = copy_from_user(&IEEE8021x_required_keys, wrq->u.data.pointer, wrq->u.data.length);
+				pAdapter->PortCfg.IEEE8021x_required_keys = IEEE8021x_required_keys;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_SET_IEEE8021X_REQUIRE_KEY (%d)\n", pAdapter->PortCfg.IEEE8021x_required_keys);
+			}
+			break;
+	    // For WPA_SUPPLICANT to set dynamic wep key
+	    case OID_802_11_ADD_WEP:
+			DBGPRINT(RT_DEBUG_ERROR, "!!!!!!!!!!!!!!!!!!!!!Set::OID_802_11_ADD_WEP !!\n");
+	        pWepKey = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+
+	        if(pWepKey == NULL)
+            {
+                Status = -ENOMEM;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP, Failed!!\n");
+                break;
+            }
+            Status = copy_from_user(pWepKey, wrq->u.data.pointer, wrq->u.data.length);
+            if (pWepKey->Length != wrq->u.data.length)
+            {
+                Status  = -EINVAL;
+                DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP, Failed (length mismatch)!!\n");
+            }
+            else
+            {
+
+		        KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
+
+                // KeyIdx must be smaller than 4
+                if (KeyIdx > 4)
+		        {
+                    Status = -EINVAL;
+                    DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP, Failed (KeyIdx must be smaller than 4)!!\n");
+                }
+                else
+                {
+                    // After receiving eap-success in 802.1x mode, PortSecured will be TRUE.
+			        // At this moment, wpa_supplicant will set dynamic wep key to driver.
+			        // Otherwise, driver only records it, not set to Asic.
+ 			        if(pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_SECURED)
+			        {
+                        UCHAR CipherAlg;
+
+                        pAdapter->SharedKey[KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
+                        memcpy(pAdapter->SharedKey[KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+
+                        if (pWepKey->KeyLength == 5)
+                            CipherAlg = CIPHER_WEP64;
+                        else
+                            CipherAlg = CIPHER_WEP128;
+
+                        pAdapter->SharedKey[KeyIdx].CipherAlg = CipherAlg;
+
+                        if (pWepKey->KeyIndex & 0x80000000)
+                        {
+                            // Default key for tx (shared key)
+                            pAdapter->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+                        }
+
+			            AsicAddSharedKeyEntry(pAdapter, 0, (UCHAR)KeyIdx, CipherAlg, pAdapter->SharedKey[KeyIdx].Key, NULL, NULL);
+
+			            DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP (id=0x%x, Len=%d-byte), Port Secured\n", pWepKey->KeyIndex, pWepKey->KeyLength);
+
+	                }
+			        else // PortSecured is NOT SECURED
+			        {
+			            UCHAR CipherAlg;
+
+				        pAdapter->PortCfg.DesireSharedKey[KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
+                        memcpy(pAdapter->PortCfg.DesireSharedKey[KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+
+				        if (pWepKey->KeyLength == 5)
+                            CipherAlg = CIPHER_WEP64;
+                        else
+                            CipherAlg = CIPHER_WEP128;
+
+                            pAdapter->PortCfg.DesireSharedKey[KeyIdx].CipherAlg = CipherAlg;
+
+                        if (pWepKey->KeyIndex & 0x80000000)
+                        {
+                            // Default key for tx (shared key)
+                            pAdapter->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+                        }
+
+				        DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP (id=0x%x, Len=%d-byte), Port Not Secured\n", pWepKey->KeyIndex, pWepKey->KeyLength);
+			        }
+		        }
+
+	        }
+	        if(pWepKey != NULL){
+		      kfree(pWepKey);
+		}
+	        break;
+#endif
+		case OID_802_11_CONFIGURATION:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_CONFIGURATION))
+				Status	= -EINVAL;
+			else
+			{
+				Status = copy_from_user(&Config, wrq->u.data.pointer, wrq->u.data.length);
+				pConfig = &Config;
+
+				if ((pConfig->BeaconPeriod >= 20) && (pConfig->BeaconPeriod <=400))
+					pAdapter->PortCfg.BeaconPeriod = (USHORT) pConfig->BeaconPeriod;
+
+				pAdapter->PortCfg.AtimWin = (USHORT) pConfig->ATIMWindow;
+				MAP_KHZ_TO_CHANNEL_ID(pConfig->DSConfig, pAdapter->PortCfg.Channel);
+				//
+				// Save the channel on MlmeAux for CntlOidRTBssidProc used.
+				//
+				pAdapter->MlmeAux.Channel = pAdapter->PortCfg.Channel;
+
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_CONFIGURATION (BeacnPeriod=%d,AtimW=%d,Ch=%d)\n",
+					pConfig->BeaconPeriod, pConfig->ATIMWindow, pAdapter->PortCfg.Channel);
+				// Config has changed
+				pAdapter->bConfigChanged = TRUE;
+			}
+			break;
+#if WPA_SUPPLICANT_SUPPORT
+		case OID_SET_COUNTERMEASURES:
+			if (wrq->u.param.value)
+		    {
+		        pAdapter->PortCfg.bBlockAssoc = TRUE;
+		        DBGPRINT(RT_DEBUG_TRACE, "Set::OID_SET_COUNTERMEASURES bBlockAssoc=TRUE \n");
+			}
+			else
+			{
+		        // WPA MIC error should block association attempt for 60 seconds
+		        pAdapter->PortCfg.bBlockAssoc = FALSE;
+		        DBGPRINT(RT_DEBUG_TRACE, "Set::OID_SET_COUNTERMEASURES bBlockAssoc=FALSE \n");
+		    }
+		    break;
+		case OID_802_11_DISASSOCIATE:
+		    // Set to immediately send the media disconnect event
+		    pAdapter->MlmeAux.CurrReqIsFromNdis = TRUE;
+
+		    DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_DISASSOCIATE \n");
+
+		    if (INFRA_ON(pAdapter))
+		    {
+		        if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+			    {
+				    MlmeEnqueue(pAdapter,
+				                MLME_CNTL_STATE_MACHINE,
+				                RT_CMD_RESET_MLME,
+				                0,
+				                NULL);
+			    }
+
+			    MlmeEnqueue(pAdapter,
+						    MLME_CNTL_STATE_MACHINE,
+						    OID_802_11_DISASSOCIATE,
+						    0,
+						    NULL);
+
+		        StateMachineTouched = TRUE;
+		    }
+		    break;
+		case OID_802_11_PMKID:
+		    pPmkId = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+
+		    if(pPmkId == NULL) {
+		        Status = -ENOMEM;
+		        break;
+		    }
+
+		    Status = copy_from_user(pPmkId, wrq->u.data.pointer, wrq->u.data.length);
+
+		    DBGPRINT(RT_DEBUG_OFF, "Set::OID_802_11_PMKID \n");
+
+		    // check the PMKID information
+		    if (pPmkId->BSSIDInfoCount == 0)
+			    break;
+		    else
+		    {
+			    PBSSID_INFO	pBssIdInfo;
+			    ULONG		BssIdx;
+			    ULONG		CachedIdx;
+
+			    for (BssIdx = 0; BssIdx < pPmkId->BSSIDInfoCount; BssIdx++)
+			    {
+				    // point to the indexed BSSID_INFO structure
+				    pBssIdInfo = (PBSSID_INFO) ((PUCHAR) pPmkId + 2 * sizeof(ULONG) + BssIdx * sizeof(BSSID_INFO));
+				    // Find the entry in the saved data base.
+				    for (CachedIdx = 0; CachedIdx < pAdapter->PortCfg.SavedPMKNum; CachedIdx++)
+				    {
+					    // compare the BSSID
+					    if (NdisEqualMemory(pBssIdInfo->BSSID, pAdapter->PortCfg.SavedPMK[CachedIdx].BSSID, sizeof(NDIS_802_11_MAC_ADDRESS)))
+						    break;
+				    }
+
+				    // Found, replace it
+				    if (CachedIdx < PMKID_NO)
+				    {
+					    DBGPRINT(RT_DEBUG_OFF, "Update OID_802_11_PMKID, idx = %d\n", CachedIdx);
+					    memcpy(&pAdapter->PortCfg.SavedPMK[CachedIdx], pBssIdInfo, sizeof(BSSID_INFO));
+					    pAdapter->PortCfg.SavedPMKNum++;
+				    }
+				    // Not found, replace the last one
+				    else
+				    {
+					    // Randomly replace one
+					    CachedIdx = (pBssIdInfo->BSSID[5] % PMKID_NO);
+					    DBGPRINT(RT_DEBUG_OFF, "Update OID_802_11_PMKID, idx = %d\n", CachedIdx);
+					    memcpy(&pAdapter->PortCfg.SavedPMK[CachedIdx], pBssIdInfo, sizeof(BSSID_INFO));
+				    }
+			    }
+		   }
+		   break;
+		case RT_OID_WPA_SUPPLICANT_SUPPORT:
+		    if (wrq->u.data.length != sizeof(BOOLEAN))
+		        Status  = -EINVAL;
+		    else
+		    {
+		        Status = copy_from_user(&wpa_supplicant_enable, wrq->u.data.pointer, wrq->u.data.length);
+		        pAdapter->PortCfg.WPA_Supplicant = wpa_supplicant_enable;
+			    DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_WPA_SUPPLICANT_SUPPORT (=%d)\n", pAdapter->PortCfg.WPA_Supplicant);
+		    }
+		    break;
+		case OID_802_11_RCV_BEACON:
+		    if (wrq->u.data.length != sizeof(BOOLEAN))
+		        Status  = -EINVAL;
+		    else
+		    {
+		        Status = copy_from_user(&start_send_beacon_up, wrq->u.data.pointer, wrq->u.data.length);
+		        pAdapter->PortCfg.Send_Beacon= start_send_beacon_up;
+		        DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_RCV_BEACON (=%d)\n", pAdapter->PortCfg.Send_Beacon);
+		    }
+		    break;
+		case OID_SET_WSC_IE_PROBE_REQ:
+		    DBGPRINT(RT_DEBUG_TRACE, "Set::OID_SET_WSC_IE_PROBE_REQ \n");
+		    if (pAdapter->PortCfg.bWscCapable && (wrq->u.data.length != 0))
+		    {
+		        Status = copy_from_user(pAdapter->PortCfg.WscIEProbeReq.Value, wrq->u.data.pointer, wrq->u.data.length);
+		        if (Status == NDIS_STATUS_SUCCESS)
+		        {
+		            pAdapter->PortCfg.WscIEProbeReq.ValueLen = wrq->u.data.length;
+		        }
+		        else
+		        {
+		            Status = -EFAULT;
+		            pAdapter->PortCfg.WscIEProbeReq.ValueLen = 0;
+		        }
+		    }
+		    else
+		    {
+		        Status = -EFAULT;
+		        pAdapter->PortCfg.WscIEProbeReq.ValueLen = 0;
+		    }
+		    break;
+#endif
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "Set::unknown IOCTL's subcmd = 0x%08x\n", cmd);
+			Status = -EOPNOTSUPP;
+            break;
+	}
+	return Status;
+
+}
+
+INT RTMPQueryInformation(
+	IN	PRTMP_ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 				cmd)
+{
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	NDIS_802_11_BSSID_LIST_EX			*pBssidList = NULL;
+	PNDIS_WLAN_BSSID_EX 				pBss;
+	NDIS_802_11_SSID					Ssid;
+	NDIS_802_11_CONFIGURATION			Configuration;
+	RT_802_11_LINK_STATUS				LinkStatus;
+	RT_802_11_STA_CONFIG				StaConfig;
+	NDIS_802_11_STATISTICS				Statistics;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_POWER_MODE				PowerMode;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType;
+	RT_802_11_PREAMBLE					PreamType;
+	NDIS_802_11_AUTHENTICATION_MODE 	AuthMode;
+	NDIS_802_11_WEP_STATUS				WepStatus;
+	RT_VERSION_INFO 					DriverVersionInfo;
+	NDIS_MEDIA_STATE					MediaState;
+	ULONG								BssBufSize;
+	ULONG								BssLen;
+	ULONG								ulInfo = 0;
+	PUCHAR								pBuf = NULL;
+	PUCHAR								pPtr;
+	INT 								Status = NDIS_STATUS_SUCCESS;
+	UCHAR								Padding;
+	UINT								i;
+	BOOLEAN 							RadioState;
+	ULONG								NetworkTypeList[4];
+    	UINT                                we_version_compiled;
+
+	switch(cmd) {
+		case RT_OID_DEVICE_NAME:
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_DEVICE_NAME\n");
+			wrq->u.data.length = sizeof(NIC_DEVICE_NAME);
+			Status = copy_to_user(wrq->u.data.pointer, NIC_DEVICE_NAME, wrq->u.data.length);
+			break;
+		case RT_OID_VERSION_INFO:
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_VERSION_INFO \n");
+			DriverVersionInfo.DriverVersionW = DRV_MAJORVERSION;
+			DriverVersionInfo.DriverVersionX = DRV_MINORVERSION;
+			DriverVersionInfo.DriverVersionY = DRV_SUBVERSION;
+			DriverVersionInfo.DriverVersionZ = DRV_TESTVERSION;
+			DriverVersionInfo.DriverBuildYear	= DRV_YEAR;
+			DriverVersionInfo.DriverBuildMonth	= DRV_MONTH;
+			DriverVersionInfo.DriverBuildDay	= DRV_DAY;
+			wrq->u.data.length = sizeof(RT_VERSION_INFO);
+			Status = copy_to_user(wrq->u.data.pointer, &DriverVersionInfo, wrq->u.data.length);
+			break;
+		case OID_802_11_BSSID_LIST:
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_BSSID_LIST (%d BSS returned)\n",pAdapter->ScanTab.BssNr);
+			// Claculate total buffer size required
+			BssBufSize = sizeof(ULONG);
+
+			for (i = 0; i < pAdapter->ScanTab.BssNr; i++)
+			{
+				// Align pointer to 4 bytes boundary.
+				Padding = 4 - (pAdapter->ScanTab.BssEntry[i].VarIELen & 0x0003);
+				if (Padding == 4)
+					Padding = 0;
+				BssBufSize += (sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->ScanTab.BssEntry[i].VarIELen + Padding);
+			}
+
+			// For safety issue, we add 256 bytes just in case
+			BssBufSize += 256;
+			// Allocate the same size as passed from higher layer
+			pBuf = kmalloc(BssBufSize, MEM_ALLOC_FLAG);
+			if(pBuf == NULL)
+			{
+				Status = -ENOMEM;
+				break;
+			}
+			// Init 802_11_BSSID_LIST_EX structure
+			memset(pBuf, 0, BssBufSize);
+			pBssidList = (PNDIS_802_11_BSSID_LIST_EX) pBuf;
+			pBssidList->NumberOfItems = pAdapter->ScanTab.BssNr;
+
+			// Calculate total buffer length
+			BssLen = 4; // Consist of NumberOfItems
+			// Point to start of NDIS_WLAN_BSSID_EX
+			// pPtr = pBuf + sizeof(ULONG);
+			pPtr = (PUCHAR) &pBssidList->Bssid[0];
+			for (i = 0; i < pAdapter->ScanTab.BssNr; i++)
+			{
+				pBss = (PNDIS_WLAN_BSSID_EX) pPtr;
+				memcpy(&pBss->MacAddress, &pAdapter->ScanTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
+				if ((pAdapter->ScanTab.BssEntry[i].Hidden == 1) && (pAdapter->PortCfg.bShowHiddenSSID == FALSE))
+				{
+					pBss->Ssid.SsidLength = 0;
+				}
+				else
+				{
+					pBss->Ssid.SsidLength = pAdapter->ScanTab.BssEntry[i].SsidLen;
+					memcpy(pBss->Ssid.Ssid, pAdapter->ScanTab.BssEntry[i].Ssid, pAdapter->ScanTab.BssEntry[i].SsidLen);
+				}
+				pBss->Privacy = pAdapter->ScanTab.BssEntry[i].Privacy;
+				pBss->Rssi = pAdapter->ScanTab.BssEntry[i].Rssi - pAdapter->BbpRssiToDbmDelta;
+
+				pBss->NetworkTypeInUse = NetworkTypeInUseSanity(pAdapter->ScanTab.BssEntry[i].Channel,
+																pAdapter->ScanTab.BssEntry[i].SupRate,
+																pAdapter->ScanTab.BssEntry[i].SupRateLen,
+																pAdapter->ScanTab.BssEntry[i].ExtRate,
+																pAdapter->ScanTab.BssEntry[i].ExtRateLen);
+
+				pBss->Configuration.Length = sizeof(NDIS_802_11_CONFIGURATION);
+				pBss->Configuration.BeaconPeriod = pAdapter->ScanTab.BssEntry[i].BeaconPeriod;
+				pBss->Configuration.ATIMWindow = pAdapter->ScanTab.BssEntry[i].AtimWin;
+
+				MAP_CHANNEL_ID_TO_KHZ(pAdapter->ScanTab.BssEntry[i].Channel, pBss->Configuration.DSConfig);
+
+				if (pAdapter->ScanTab.BssEntry[i].BssType == BSS_INFRA)
+					pBss->InfrastructureMode = Ndis802_11Infrastructure;
+				else
+					pBss->InfrastructureMode = Ndis802_11IBSS;
+
+				memcpy(pBss->SupportedRates, pAdapter->ScanTab.BssEntry[i].SupRate, pAdapter->ScanTab.BssEntry[i].SupRateLen);
+// TODO: 2004-09-13 john -	should we copy ExtRate into this array? if not, some APs annouced all 8 11g rates
+// in ExtRateIE which may be mis-treated as 802.11b AP by ZeroConfig
+				memcpy(pBss->SupportedRates + pAdapter->ScanTab.BssEntry[i].SupRateLen,
+							   pAdapter->ScanTab.BssEntry[i].ExtRate,
+							   pAdapter->ScanTab.BssEntry[i].ExtRateLen);
+
+				DBGPRINT(RT_DEBUG_TRACE,"BSS#%d - %s, Ch %d = %d Khz, Sup+Ext rate# = %d\n",
+					i,pBss->Ssid.Ssid,
+					pAdapter->ScanTab.BssEntry[i].Channel,
+					pBss->Configuration.DSConfig,
+					pAdapter->ScanTab.BssEntry[i].SupRateLen + pAdapter->ScanTab.BssEntry[i].ExtRateLen);
+
+
+				if (pAdapter->ScanTab.BssEntry[i].VarIELen == 0)
+				{
+					pBss->IELength = sizeof(NDIS_802_11_FIXED_IEs);
+					memcpy(pBss->IEs, &pAdapter->ScanTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+					pPtr = pPtr + sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs);
+				}
+				else
+				{
+					pBss->IELength = sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->ScanTab.BssEntry[i].VarIELen;
+					pPtr = pPtr + sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs);
+					memcpy(pBss->IEs, &pAdapter->ScanTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+					memcpy(pPtr, pAdapter->ScanTab.BssEntry[i].VarIEs, pAdapter->ScanTab.BssEntry[i].VarIELen);
+					pPtr += pAdapter->ScanTab.BssEntry[i].VarIELen;
+				}
+				// Align pointer to 4 bytes boundary.
+				Padding = 4 - (pAdapter->ScanTab.BssEntry[i].VarIELen & 0x0003);
+				if (Padding == 4)
+					Padding = 0;
+				pPtr += Padding;
+				pBss->Length = sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->ScanTab.BssEntry[i].VarIELen + Padding;
+				BssLen += pBss->Length;
+			}
+			wrq->u.data.length = BssLen;
+			Status = copy_to_user(wrq->u.data.pointer, pBssidList, wrq->u.data.length);
+			if(pBssidList != NULL){
+				kfree(pBssidList);
+			}
+			break;
+		case OID_802_3_CURRENT_ADDRESS:
+			wrq->u.data.length = MAC_ADDR_LEN;
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->CurrentAddress, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_3_CURRENT_ADDRESS \n");
+			break;
+		case OID_GEN_MEDIA_CONNECT_STATUS:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_MEDIA_CONNECT_STATUS \n");
+			if (OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED))
+				MediaState = NdisMediaStateConnected;
+			else
+				MediaState = NdisMediaStateDisconnected;
+
+			wrq->u.data.length = sizeof(NDIS_MEDIA_STATE);
+			Status = copy_to_user(wrq->u.data.pointer, &MediaState, wrq->u.data.length);
+			break;
+		case OID_802_11_BSSID:
+			if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+			{
+				wrq->u.data.length = sizeof(NDIS_802_11_MAC_ADDRESS);
+				Status = copy_to_user(wrq->u.data.pointer, &pAdapter->PortCfg.Bssid, wrq->u.data.length);
+
+				DBGPRINT(RT_DEBUG_INFO, "IOCTL::SIOCGIWAP(=%02x:%02x:%02x:%02x:%02x:%02x)\n",
+						pAdapter->PortCfg.Bssid[0],pAdapter->PortCfg.Bssid[1],pAdapter->PortCfg.Bssid[2],
+						pAdapter->PortCfg.Bssid[3],pAdapter->PortCfg.Bssid[4],pAdapter->PortCfg.Bssid[5]);
+
+			}
+			else
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_BSSID(=EMPTY)\n");
+				Status = -ENOTCONN;
+			}
+			break;
+		case OID_802_11_SSID:
+			Ssid.SsidLength = pAdapter->PortCfg.SsidLen;
+			memset(Ssid.Ssid, 0, MAX_LEN_OF_SSID);
+			memcpy(Ssid.Ssid, pAdapter->PortCfg.Ssid, Ssid.SsidLength);
+			wrq->u.data.length = sizeof(NDIS_802_11_SSID);
+			Status = copy_to_user(wrq->u.data.pointer, &Ssid, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_SSID (Len=%d, ssid=%s)\n", Ssid.SsidLength,Ssid.Ssid);
+			break;
+		case RT_OID_802_11_QUERY_LINK_STATUS:
+			LinkStatus.CurrTxRate = RateIdTo500Kbps[pAdapter->PortCfg.TxRate];	 // unit : 500 kbps
+			LinkStatus.ChannelQuality = pAdapter->Mlme.ChannelQuality;
+			LinkStatus.RxByteCount = pAdapter->RalinkCounters.ReceivedByteCount;
+			LinkStatus.TxByteCount = pAdapter->RalinkCounters.TransmittedByteCount;
+			wrq->u.data.length = sizeof(RT_802_11_LINK_STATUS);
+			Status = copy_to_user(wrq->u.data.pointer, &LinkStatus, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_QUERY_LINK_STATUS\n");
+			break;
+		case OID_802_11_CONFIGURATION:
+			Configuration.Length = sizeof(NDIS_802_11_CONFIGURATION);
+			Configuration.BeaconPeriod = pAdapter->PortCfg.BeaconPeriod;
+			Configuration.ATIMWindow = pAdapter->PortCfg.AtimWin;
+			MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.Channel, Configuration.DSConfig);
+			wrq->u.data.length = sizeof(NDIS_802_11_CONFIGURATION);
+			Status = copy_to_user(wrq->u.data.pointer, &Configuration, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_CONFIGURATION(BeaconPeriod=%d,AtimW=%d,Channel=%d) \n",
+									Configuration.BeaconPeriod, Configuration.ATIMWindow, pAdapter->PortCfg.Channel);
+			break;
+		case OID_802_11_RSSI_TRIGGER:
+			ulInfo = pAdapter->PortCfg.LastRssi - pAdapter->BbpRssiToDbmDelta;
+			wrq->u.data.length = sizeof(ulInfo);
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_RSSI_TRIGGER(=%d)\n", ulInfo);
+			break;
+		case OID_802_11_STATISTICS:
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_STATISTICS \n");
+
+			// add the most up-to-date h/w raw counters into software counters
+			NICUpdateRawCounters(pAdapter);
+
+			// Sanity check for calculation of sucessful count
+			if (pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart < pAdapter->WlanCounters.RetryCount.QuadPart)
+				pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart = pAdapter->WlanCounters.RetryCount.QuadPart;
+
+			Statistics.TransmittedFragmentCount.QuadPart = pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart;
+			Statistics.MulticastTransmittedFrameCount.QuadPart = pAdapter->WlanCounters.MulticastTransmittedFrameCount.QuadPart;
+			Statistics.FailedCount.QuadPart = pAdapter->WlanCounters.FailedCount.QuadPart;
+			Statistics.RetryCount.QuadPart = pAdapter->WlanCounters.RetryCount.QuadPart;
+			Statistics.MultipleRetryCount.QuadPart = pAdapter->WlanCounters.MultipleRetryCount.QuadPart;
+			Statistics.RTSSuccessCount.QuadPart = pAdapter->WlanCounters.RTSSuccessCount.QuadPart;
+			Statistics.RTSFailureCount.QuadPart = pAdapter->WlanCounters.RTSFailureCount.QuadPart;
+			Statistics.ACKFailureCount.QuadPart = pAdapter->WlanCounters.ACKFailureCount.QuadPart;
+			Statistics.FrameDuplicateCount.QuadPart = pAdapter->WlanCounters.FrameDuplicateCount.QuadPart;
+			Statistics.ReceivedFragmentCount.QuadPart = pAdapter->WlanCounters.ReceivedFragmentCount.QuadPart;
+			Statistics.MulticastReceivedFrameCount.QuadPart = pAdapter->WlanCounters.MulticastReceivedFrameCount.QuadPart;
+#ifdef DBG
+			Statistics.FCSErrorCount = pAdapter->RalinkCounters.RealFcsErrCount;
+#else
+			Statistics.FCSErrorCount.QuadPart = pAdapter->WlanCounters.FCSErrorCount.QuadPart;
+			Statistics.FrameDuplicateCount.vv.LowPart = pAdapter->WlanCounters.FrameDuplicateCount.vv.LowPart / 100;
+#endif
+			wrq->u.data.length = sizeof(NDIS_802_11_STATISTICS);
+			Status = copy_to_user(wrq->u.data.pointer, &Statistics, wrq->u.data.length);
+			break;
+		case OID_GEN_RCV_OK:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_RCV_OK \n");
+			ulInfo = pAdapter->Counters8023.GoodReceives;
+			wrq->u.data.length = sizeof(ulInfo);
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			break;
+		case OID_GEN_RCV_NO_BUFFER:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_RCV_NO_BUFFER \n");
+			ulInfo = pAdapter->Counters8023.RxNoBuffer;
+			wrq->u.data.length = sizeof(ulInfo);
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			break;
+		case RT_OID_802_11_PHY_MODE:
+			ulInfo = (ULONG)pAdapter->PortCfg.PhyMode;
+			wrq->u.data.length = sizeof(ulInfo);
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_PHY_MODE (=%d)\n", ulInfo);
+			break;
+		case RT_OID_802_11_STA_CONFIG:
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_STA_CONFIG\n");
+			StaConfig.EnableTxBurst = pAdapter->PortCfg.bEnableTxBurst;
+			StaConfig.EnableTurboRate = pAdapter->PortCfg.EnableTurboRate;
+			StaConfig.UseBGProtection = pAdapter->PortCfg.UseBGProtection;
+			StaConfig.UseShortSlotTime = pAdapter->PortCfg.UseShortSlotTime;
+			StaConfig.AdhocMode = pAdapter->PortCfg.AdhocMode;
+			StaConfig.HwRadioStatus = (pAdapter->PortCfg.bHwRadio == TRUE) ? 1 : 0;
+			StaConfig.Rsv1 = 0;
+			StaConfig.SystemErrorBitmap = pAdapter->SystemErrorBitmap;
+			wrq->u.data.length = sizeof(RT_802_11_STA_CONFIG);
+			Status = copy_to_user(wrq->u.data.pointer, &StaConfig, wrq->u.data.length);
+			break;
+		case OID_802_11_RTS_THRESHOLD:
+			RtsThresh = pAdapter->PortCfg.RtsThreshold;
+			wrq->u.data.length = sizeof(RtsThresh);
+			Status = copy_to_user(wrq->u.data.pointer, &RtsThresh, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_RTS_THRESHOLD(=%d)\n", RtsThresh);
+			break;
+		case OID_802_11_FRAGMENTATION_THRESHOLD:
+			FragThresh = pAdapter->PortCfg.FragmentThreshold;
+			if (pAdapter->PortCfg.bFragmentZeroDisable == TRUE)
+				FragThresh = 0;
+			wrq->u.data.length = sizeof(FragThresh);
+			Status = copy_to_user(wrq->u.data.pointer, &FragThresh, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_FRAGMENTATION_THRESHOLD(=%d)\n", FragThresh);
+			break;
+		case OID_802_11_POWER_MODE:
+			PowerMode = pAdapter->PortCfg.WindowsPowerMode;
+			wrq->u.data.length = sizeof(PowerMode);
+			Status = copy_to_user(wrq->u.data.pointer, &PowerMode, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_POWER_MODE(=%d)\n", PowerMode);
+			break;
+		case RT_OID_802_11_RADIO:
+			RadioState = (BOOLEAN) pAdapter->PortCfg.bSwRadio;
+			wrq->u.data.length = sizeof(RadioState);
+			Status = copy_to_user(wrq->u.data.pointer, &RadioState, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_QUERY_RADIO (=%d)\n", RadioState);
+			break;
+		case OID_802_11_INFRASTRUCTURE_MODE:
+			if (ADHOC_ON(pAdapter))
+				BssType = Ndis802_11IBSS;
+			else if (INFRA_ON(pAdapter))
+				BssType = Ndis802_11Infrastructure;
+			else
+				BssType = Ndis802_11AutoUnknown;
+
+			wrq->u.data.length = sizeof(BssType);
+			Status = copy_to_user(wrq->u.data.pointer, &BssType, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_INFRASTRUCTURE_MODE(=%d)\n", BssType);
+			break;
+		case RT_OID_802_11_PREAMBLE:
+			PreamType = pAdapter->PortCfg.TxPreamble;
+			wrq->u.data.length = sizeof(PreamType);
+			Status = copy_to_user(wrq->u.data.pointer, &PreamType, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_PREAMBLE(=%d)\n", PreamType);
+			break;
+		case OID_802_11_AUTHENTICATION_MODE:
+			AuthMode = pAdapter->PortCfg.AuthMode;
+			wrq->u.data.length = sizeof(AuthMode);
+			Status = copy_to_user(wrq->u.data.pointer, &AuthMode, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_AUTHENTICATION_MODE(=%d)\n", AuthMode);
+			break;
+		case OID_802_11_WEP_STATUS:
+			WepStatus = pAdapter->PortCfg.WepStatus;
+			wrq->u.data.length = sizeof(WepStatus);
+			Status = copy_to_user(wrq->u.data.pointer, &WepStatus, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_WEP_STATUS(=%d)\n", WepStatus);
+			break;
+		case OID_802_11_TX_POWER_LEVEL:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->PortCfg.TxPower, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_TX_POWER_LEVEL %x\n",pAdapter->PortCfg.TxPower);
+			break;
+		case RT_OID_802_11_TX_POWER_LEVEL_1:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->PortCfg.TxPowerPercentage, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_TX_POWER_LEVEL_1 (=%d)\n", pAdapter->PortCfg.TxPowerPercentage);
+			break;
+		case OID_802_11_NETWORK_TYPES_SUPPORTED:
+			if ((pAdapter->RfIcType == RFIC_5226) || (pAdapter->RfIcType == RFIC_5225))
+			{
+				NetworkTypeList[0] = 3; 				// NumberOfItems = 3
+				NetworkTypeList[1] = Ndis802_11DS;		// NetworkType[1] = 11b
+				NetworkTypeList[2] = Ndis802_11OFDM24;	// NetworkType[2] = 11g
+				NetworkTypeList[3] = Ndis802_11OFDM5;	// NetworkType[3] = 11a
+				wrq->u.data.length = 16;
+				Status = copy_to_user(wrq->u.data.pointer, &NetworkTypeList[0], wrq->u.data.length);
+			}
+			else
+			{
+				NetworkTypeList[0] = 2; 				// NumberOfItems = 2
+				NetworkTypeList[1] = Ndis802_11DS;		// NetworkType[1] = 11b
+				NetworkTypeList[2] = Ndis802_11OFDM24;	// NetworkType[2] = 11g
+				wrq->u.data.length = 12;
+				Status = copy_to_user(wrq->u.data.pointer, &NetworkTypeList[0], wrq->u.data.length);
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Query::OID_802_11_NETWORK_TYPES_SUPPORTED\n");
+			break;
+		case OID_802_11_NETWORK_TYPE_IN_USE:
+			wrq->u.data.length = sizeof(ULONG);
+			if (pAdapter->PortCfg.PhyMode == PHY_11A)
+				ulInfo = Ndis802_11OFDM5;
+			else if ((pAdapter->PortCfg.PhyMode == PHY_11BG_MIXED) || (pAdapter->PortCfg.PhyMode == PHY_11G))
+				ulInfo = Ndis802_11OFDM24;
+			else
+				ulInfo = Ndis802_11DS;
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_NETWORK_TYPE_IN_USE(=%d)\n", ulInfo);
+			break;
+		case RT_OID_802_11_QUERY_LAST_RX_RATE:
+			ulInfo = (ULONG)pAdapter->LastRxRate;
+			wrq->u.data.length = sizeof(ulInfo);
+			Status = copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_QUERY_LAST_RX_RATE (=%d)\n", ulInfo);
+			break;
+		case RT_OID_802_11_QUERY_EEPROM_VERSION:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->EepromVersion, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_QUERY_EEPROM_VERSION (=%d)\n", pAdapter->EepromVersion);
+			break;
+		case RT_OID_802_11_QUERY_FIRMWARE_VERSION:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->FirmwareVersion, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_QUERY_FIRMWARE_VERSION (=%d)\n", pAdapter->FirmwareVersion);
+			break;
+		case RT_OID_802_11_QUERY_NOISE_LEVEL:
+			// TODO: how to measure NOISE LEVEL now?????
+			wrq->u.data.length = sizeof(UCHAR);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->BbpWriteLatch[17], wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_QUERY_NOISE_LEVEL (=%d)\n", pAdapter->BbpWriteLatch[17]);
+			break;
+		case RT_OID_802_11_EXTRA_INFO:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->ExtraInfo, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_TRACE, "Query::RT_OID_802_11_EXTRA_INFO (=%d)\n", pAdapter->ExtraInfo);
+			break;
+		case RT_OID_802_11_QUERY_PIDVID:
+			wrq->u.data.length = sizeof(ULONG);
+			Status = copy_to_user(wrq->u.data.pointer, &pAdapter->VendorDesc, wrq->u.data.length);
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_QUERY_PIDVID (=%d)\n", pAdapter->VendorDesc);
+			break;
+	    case RT_OID_WE_VERSION_COMPILED:
+	        wrq->u.data.length = sizeof(UINT);
+	        we_version_compiled = WIRELESS_EXT;
+	        Status = copy_to_user(wrq->u.data.pointer, &we_version_compiled, wrq->u.data.length);
+	        DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_WE_VERSION_COMPILED (=%d)\n", we_version_compiled);
+	        break;
+
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "Query::unknown IOCTL's subcmd = 0x%08x\n", cmd);
+			Status = -EOPNOTSUPP;
+			break;
+	}
+	return Status;
+}
+
+INT rt73_ioctl(
+	IN	struct net_device	*net_dev,
+	IN	OUT	struct ifreq	*rq,
+	IN	INT					cmd)
+{
+	RTMP_ADAPTER						*pAd = net_dev->priv;
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	struct iw_point 					*erq = NULL;
+	struct iw_freq						*frq = NULL;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType = Ndis802_11Infrastructure;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_MAC_ADDRESS 			Bssid;
+	BOOLEAN 							StateMachineTouched = FALSE;
+	INT 								Status = NDIS_STATUS_SUCCESS;
+	USHORT								subcmd;
+	int 								chan=-1, index=0, len=0, i=0;
+
+
+	if ( (RTMP_TEST_FLAG(pAd , fRTMP_ADAPTER_NIC_NOT_EXIST)) ||
+		 (RTMP_TEST_FLAG(pAd , fRTMP_ADAPTER_RESET_IN_PROGRESS)))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "IOCTL::remove in progress!\n");
+		return -ENETDOWN;
+	}
+
+    	if (pAd->RTUSBCmdThr_pid < 0)
+		return -ENETDOWN;
+
+	switch(cmd)
+	{
+		case SIOCGIFHWADDR:     //get  MAC addresses
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIFHWADDR\n");
+			memcpy(wrq->u.name, pAd->CurrentAddress, ETH_ALEN);
+            DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIFHWADDR(=%02x:%02x:%02x:%02x:%02x:%02x)\n",
+		        pAd->CurrentAddress[0],pAd->CurrentAddress[1],pAd->CurrentAddress[2],
+		        pAd->CurrentAddress[3],pAd->CurrentAddress[4],pAd->CurrentAddress[5]);
+			break;
+		case SIOCGIWNAME:
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWNAME\n");
+			strcpy(wrq->u.name, "RT73 WLAN");
+			break;
+		case SIOCSIWESSID:	//Set ESSID
+			erq = &wrq->u.essid;
+			memset(&Ssid, 0, sizeof(NDIS_802_11_SSID));
+			if (erq->flags)
+			{
+				if (erq->length > IW_ESSID_MAX_SIZE)
+				{
+					Status = -E2BIG;
+					break;
+				}
+
+				Status = copy_from_user(Ssid.Ssid, erq->pointer, (erq->length - 1));
+				Ssid.SsidLength = erq->length - 1;	//minus null character.
+			}
+			else
+			{
+				Ssid.SsidLength = 0;  // ANY ssid
+				memcpy(pSsid->Ssid, "", 0);
+			}
+			pSsid = &Ssid;
+			if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+			{
+				MlmeEnqueue(pAd,
+				            MLME_CNTL_STATE_MACHINE,
+				            RT_CMD_RESET_MLME,
+				            0,
+				            NULL);
+			}
+
+			// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+			// this request, because this request is initiated by NDIS.
+			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+			MlmeEnqueue(pAd,
+						MLME_CNTL_STATE_MACHINE,
+						OID_802_11_SSID,
+						sizeof(NDIS_802_11_SSID),
+						(VOID *)pSsid);
+
+			Status = NDIS_STATUS_SUCCESS;
+			StateMachineTouched = TRUE;
+
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWESSID[cmd=0x%x] (Len=%d,Ssid=%s)\n", SIOCSIWESSID, pSsid->SsidLength, pSsid->Ssid);
+			break;
+		case SIOCGIWESSID:	//Get ESSID
+			erq = &wrq->u.essid;
+			erq->flags=1;
+			erq->length = pAd->PortCfg.SsidLen;
+			Status = copy_to_user(erq->pointer, pAd->PortCfg.Ssid, erq->length);
+
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWESSID (Len=%d, ssid=%lu...)\n", erq->length, (unsigned long)erq->pointer);
+			break;
+		case SIOCSIWNWID:	// set network id (the cell)
+		case SIOCGIWNWID:	// get network id
+			Status = -EOPNOTSUPP;
+			break;
+		case SIOCSIWFREQ:	//set channel/frequency (Hz)
+			frq = &wrq->u.freq;
+			if((frq->e == 0) && (frq->m <= 1000))
+				chan = frq->m;	// Setting by channel number
+			else
+				MAP_KHZ_TO_CHANNEL_ID( (frq->m /100) , chan); // Setting by frequency - search the table , like 2.412G, 2.422G,
+			pAd->PortCfg.Channel = chan;
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n", SIOCSIWFREQ, pAd->PortCfg.Channel);
+			if (pAd->PortCfg.BssType == BSS_MONITOR)
+			{
+				pAd->PortCfg.Channel = chan;
+				AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+				AsicLockChannel(pAd, pAd->PortCfg.Channel);
+			}
+			break;
+		case SIOCGIWFREQ:	// get channel/frequency (Hz)
+			wrq->u.freq.m = pAd->PortCfg.Channel;
+			wrq->u.freq.e = 0;
+			wrq->u.freq.i = 0;
+			break;
+		case SIOCSIWNICKN: //set node name/nickname
+			erq = &wrq->u.data;
+			if (erq->flags)
+			{
+				if (erq->length <= IW_ESSID_MAX_SIZE)
+					Status = copy_from_user(pAd->nickn, erq->pointer, erq->length);
+				else
+					Status = -E2BIG;
+			}
+			break;
+		case SIOCGIWNICKN: //get node name/nickname
+			erq = &wrq->u.data;
+			erq->length = strlen(pAd->nickn);
+			Status = copy_to_user(erq->pointer, pAd->nickn, erq->length);
+			break;
+
+		case SIOCGIWRATE:	//get default bit rate (bps)
+			wrq->u.bitrate.value = RateIdTo500Kbps[pAd->PortCfg.TxRate] * 500000;
+			wrq->u.bitrate.disabled = 0;
+			break;
+		case SIOCSIWRATE:  //set default bit rate (bps)
+			RTMPSetDesiredRates(pAd, wrq->u.bitrate.value);
+			break;
+		case SIOCGIWRTS:  // get RTS/CTS threshold (bytes)
+			wrq->u.rts.value = (INT) pAd->PortCfg.RtsThreshold;
+			wrq->u.rts.disabled = (wrq->u.rts.value == MAX_RTS_THRESHOLD);
+			wrq->u.rts.fixed = 1;
+			break;
+		case SIOCSIWRTS:  //set RTS/CTS threshold (bytes)
+			RtsThresh = wrq->u.rts.value;
+			if (wrq->u.rts.disabled)
+				RtsThresh = MAX_RTS_THRESHOLD;
+
+			if((RtsThresh > 0) && (RtsThresh <= MAX_RTS_THRESHOLD))
+				pAd->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+			else if (RtsThresh == 0)
+				pAd->PortCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWRTS (=%d)\n", pAd->PortCfg.RtsThreshold);
+			break;
+		case SIOCGIWFRAG:  //get fragmentation thr (bytes)
+			wrq->u.frag.value = (INT) pAd->PortCfg.FragmentThreshold;
+			wrq->u.frag.disabled = (wrq->u.frag.value >= MAX_FRAG_THRESHOLD);
+			wrq->u.frag.fixed = 1;
+			break;
+		case SIOCSIWFRAG:  //set fragmentation thr (bytes)
+			FragThresh = wrq->u.frag.value;
+			if (wrq->u.rts.disabled)
+				FragThresh = MAX_FRAG_THRESHOLD;
+
+			if ( (FragThresh >= MIN_FRAG_THRESHOLD) && (FragThresh <= MAX_FRAG_THRESHOLD))
+				pAd->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+			else if (FragThresh == 0)
+				pAd->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+
+			if (pAd->PortCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+				pAd->PortCfg.bFragmentZeroDisable = TRUE;
+			else
+				pAd->PortCfg.bFragmentZeroDisable = FALSE;
+
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWFRAG (=%d)\n", pAd->PortCfg.FragmentThreshold);
+			break;
+		case SIOCGIWENCODE:  //get encoding token & mode
+			index = (wrq->u.encoding.flags & IW_ENCODE_INDEX) - 1;
+			if ((index < 0) || (index >= NR_WEP_KEYS))
+				index = pAd->PortCfg.DefaultKeyId; // Default key for tx (shared key)
+
+			if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeOpen)
+				wrq->u.encoding.flags = IW_ENCODE_OPEN;
+			else if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+				wrq->u.encoding.flags = IW_ENCODE_RESTRICTED;
+
+			if (pAd->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+				wrq->u.encoding.flags |= IW_ENCODE_DISABLED;
+			else
+			{
+				if(wrq->u.encoding.pointer)
+				{
+					wrq->u.encoding.length = pAd->SharedKey[index].KeyLen;
+					Status = copy_to_user(wrq->u.encoding.pointer,
+								pAd->SharedKey[index].Key,
+								pAd->SharedKey[index].KeyLen);
+					wrq->u.encoding.flags |= (index + 1);
+				}
+			}
+			break;
+		case SIOCSIWENCODE:  //set encoding token & mode
+			index = (wrq->u.encoding.flags & IW_ENCODE_INDEX) - 1;
+			/* take the old default key if index is invalid */
+			if((index < 0) || (index >= NR_WEP_KEYS))
+				index = pAd->PortCfg.DefaultKeyId;	   // Default key for tx (shared key)
+
+			if(wrq->u.encoding.pointer)
+			{
+				len = wrq->u.encoding.length;
+				if(len > WEP_LARGE_KEY_LEN)
+					len = WEP_LARGE_KEY_LEN;
+
+				memset(pAd->SharedKey[index].Key, 0, MAX_LEN_OF_KEY);
+				Status = copy_from_user(pAd->SharedKey[index].Key,
+								wrq->u.encoding.pointer, len);
+				pAd->SharedKey[index].KeyLen = len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
+			}
+			pAd->PortCfg.DefaultKeyId = (UCHAR) index;
+			if (wrq->u.encoding.flags & IW_ENCODE_DISABLED)
+				pAd->PortCfg.WepStatus = Ndis802_11WEPDisabled;
+			else
+				pAd->PortCfg.WepStatus = Ndis802_11WEPEnabled;
+
+			if (wrq->u.encoding.flags & IW_ENCODE_RESTRICTED)
+				pAd->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+			else
+				pAd->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+			if(pAd->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+				pAd->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWENCODE Key[%x] => \n", index);
+			for (i = 0; i < len; i++)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[index].Key[i]);
+				if (i%16 == 15)
+					DBGPRINT(RT_DEBUG_TRACE, "\n");
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "\n");
+			break;
+		case SIOCGIWAP: 	//get access point MAC addresses
+			if (INFRA_ON(pAd) || ADHOC_ON(pAd))
+			{
+				wrq->u.ap_addr.sa_family = ARPHRD_ETHER;
+				memcpy(wrq->u.ap_addr.sa_data, &pAd->PortCfg.Bssid, ETH_ALEN);
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWAP(=%02x:%02x:%02x:%02x:%02x:%02x)\n",
+					pAd->PortCfg.Bssid[0],pAd->PortCfg.Bssid[1],pAd->PortCfg.Bssid[2],
+					pAd->PortCfg.Bssid[3],pAd->PortCfg.Bssid[4],pAd->PortCfg.Bssid[5]);
+			}
+			else
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWAP(=EMPTY)\n");
+				Status = -ENOTCONN;
+			}
+			break;
+		case SIOCSIWAP:  //set access point MAC addresses
+			memcpy(&Bssid, &wrq->u.ap_addr.sa_data,
+					sizeof(NDIS_802_11_MAC_ADDRESS));
+			if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+			{
+				MlmeEnqueue(pAd,
+				            MLME_CNTL_STATE_MACHINE,
+				            RT_CMD_RESET_MLME,
+				            0,
+				            NULL);
+			}
+
+			// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+			// this request, because this request is initiated by NDIS.
+			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+			MlmeEnqueue(pAd,
+						MLME_CNTL_STATE_MACHINE,
+						OID_802_11_BSSID,
+						sizeof(NDIS_802_11_MAC_ADDRESS),
+						(VOID *)&Bssid);
+			Status = NDIS_STATUS_SUCCESS;
+			StateMachineTouched = TRUE;
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWAP %02x:%02x:%02x:%02x:%02x:%02x\n",
+				Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]);
+			break;
+		case SIOCGIWMODE:	//get operation mode
+			if (pAd->PortCfg.BssType == BSS_ADHOC)
+			{
+				BssType = Ndis802_11IBSS;
+				wrq->u.mode = IW_MODE_ADHOC;
+			}
+			else if (pAd->PortCfg.BssType == BSS_INFRA)
+			{
+				BssType = Ndis802_11Infrastructure;
+				wrq->u.mode = IW_MODE_INFRA;
+			}
+			else if (pAd->PortCfg.BssType == BSS_MONITOR)
+			{
+				BssType = Ndis802_11Monitor;
+				wrq->u.mode = IW_MODE_MONITOR;
+			}
+			else
+			{
+				BssType = Ndis802_11AutoUnknown;
+				wrq->u.mode = IW_MODE_AUTO;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWMODE(=%d)\n", BssType);
+			break;
+		case SIOCSIWMODE:	//set operation mode
+			if(wrq->u.mode == IW_MODE_ADHOC)
+			{
+				if (pAd->PortCfg.BssType != BSS_ADHOC)
+				{
+					// Config has changed
+					pAd->bConfigChanged = TRUE;
+				}
+				pAd->PortCfg.BssType = BSS_ADHOC;
+				pAd->net_dev->type = 1;
+				RT73WriteTXRXCSR0(pAd, FALSE, TRUE);
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWMODE (AD-HOC)\n");
+			}
+			else if (wrq->u.mode == IW_MODE_INFRA)
+			{
+				if (pAd->PortCfg.BssType != BSS_INFRA)
+				{
+					// Config has changed
+					pAd->bConfigChanged = TRUE;
+				}
+				pAd->PortCfg.BssType = BSS_INFRA;
+				pAd->net_dev->type = 1;
+				RT73WriteTXRXCSR0(pAd, FALSE, TRUE);
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWMODE (INFRA)\n");
+			}
+			else if (wrq->u.mode == IW_MODE_MONITOR)
+			{
+				if (pAd->PortCfg.BssType != BSS_MONITOR)
+				{
+					pAd->bConfigChanged = TRUE;
+				}
+
+				pAd->PortCfg.BssType = BSS_MONITOR;
+
+				if (pAd->bAcceptRFMONTx == TRUE) {
+					if (pAd->ForcePrismHeader == 1)
+						pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+					else
+						pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+				}
+				else
+				{
+					if (pAd->ForcePrismHeader == 2)
+						pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+					else
+						pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+				}
+
+				RT73WriteTXRXCSR0(pAd, FALSE, TRUE);
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWMODE (MONITOR)\n");
+			}
+			else
+			{
+				Status	= -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWMODE (unknown)\n");
+			}
+			// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+			pAd->PortCfg.WpaState = SS_NOTUSE;
+			break;
+		case SIOCGIWSENS:	//get sensitivity (dBm)
+		case SIOCSIWSENS:	//set sensitivity (dBm)
+		case SIOCGIWPOWER:	//get Power Management settings
+		case SIOCSIWPOWER:	//set Power Management settings
+		case SIOCGIWTXPOW:	//get transmit power (dBm)
+		case SIOCSIWTXPOW:	//set transmit power (dBm)
+		case SIOCGIWRANGE:	//Get range of parameters
+		case SIOCGIWRETRY:	//get retry limits and lifetime
+		case SIOCSIWRETRY:	//set retry limits and lifetime
+			Status = -EOPNOTSUPP;
+			break;
+		case RT_PRIV_IOCTL:
+			subcmd = wrq->u.data.flags;
+			if( subcmd & OID_GET_SET_TOGGLE)
+				Status = RTMPSetInformation(pAd, rq, subcmd);
+			else
+				Status = RTMPQueryInformation(pAd, rq, subcmd);
+			break;
+		case SIOCGIWPRIV:
+			if (wrq->u.data.pointer) {
+				if ( access_ok(VERIFY_WRITE, wrq->u.data.pointer, sizeof(privtab)) != TRUE)
+					break;
+				wrq->u.data.length = sizeof(privtab) / sizeof(privtab[0]);
+				if (copy_to_user(wrq->u.data.pointer, privtab, sizeof(privtab)))
+					Status = -EFAULT;
+			}
+			break;
+		case RTPRIV_IOCTL_SET:
+			{
+				CHAR *this_char;
+				CHAR *value;
+
+				if( access_ok(VERIFY_READ, wrq->u.data.pointer, wrq->u.data.length)!=TRUE )
+					break;
+
+				this_char = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+				if(this_char == NULL)
+				{
+					Status = -ENOMEM;
+					break;
+				}
+
+				Status = copy_from_user(this_char, wrq->u.data.pointer, wrq->u.data.length);
+
+				if (!*this_char)
+					break;
+
+				if ((value = rtstrchr(this_char, '=')) != NULL)
+					*value++ = 0;
+
+				if (!value)
+					break;
+
+				// reject setting nothing besides ANY ssid(ssidLen=0)
+				if (!*value && (strcmp(this_char, "SSID") != 0))
+					break;
+
+				for (PRTMP_PRIVATE_SET_PROC = RTMP_PRIVATE_SUPPORT_PROC; PRTMP_PRIVATE_SET_PROC->name; PRTMP_PRIVATE_SET_PROC++)
+				{
+					if (!strcmp(this_char, PRTMP_PRIVATE_SET_PROC->name))
+					{
+						if(!PRTMP_PRIVATE_SET_PROC->set_proc(pAd, value))
+						{	//FALSE:Set private failed then return Invalid argument
+							Status = -EINVAL;
+						}
+						break;	//Exit for loop.
+					}
+				}
+
+				if(PRTMP_PRIVATE_SET_PROC->name == NULL)
+				{  //Not found argument
+					Status = -EINVAL;
+					DBGPRINT(RT_DEBUG_TRACE, "IOCTL::(iwpriv) Command not Support [%s=%s]\n", this_char, value);
+					break;
+				}
+				if(this_char != NULL){
+					kfree(this_char);
+				}
+			}
+			break;
+		case RTPRIV_IOCTL_GSITESURVEY:
+			RTMPIoctlGetSiteSurvey(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_ADHOCOFDM:
+			RTMPIoctlAdhocOfdm(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_STATISTICS:
+			RTMPIoctlStatistics(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_SETRFMONTX:
+			RTMPIoctlSetRFMONTx(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_GETRFMONTX:
+			RTMPIoctlGetRFMONTx(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_FORCEPRISMHEADER:
+			RTMPIoctlForcePrismHeader(pAd, wrq);
+			break;
+#ifdef DBG
+		case RTPRIV_IOCTL_BBP:
+			RTMPIoctlBBP(pAd, wrq);
+			break;
+
+		case RTPRIV_IOCTL_MAC:
+			RTMPIoctlMAC(pAd, wrq);
+			break;
+#endif
+
+#if 1
+		case RTPRIV_IOCTL_AUTH:
+			Status = RTMPIoctlSetAuth(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_WEPSTATUS:
+			Status = RTMPIoctlSetEncryp(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_WPAPSK:
+			Status = RTMPIoctlSetWpapsk(pAd, wrq);
+			break;
+		case RTPRIV_IOCTL_PSM:
+			Status = RTMPIoctlSetPsm(pAd, wrq);
+			break;
+#endif
+        	case RTPRIV_IOCTL_GETRAAPCFG:
+			RTMPIoctlGetRaAPCfg(pAd, wrq);
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_ERROR, "IOCTL::unknown IOCTL's cmd = 0x%08x\n", cmd);
+			if (cmd == 0x89F1)
+				Status = NDIS_STATUS_SUCCESS; // ignore default config by some of platforms, e.g. SuSE
+			else
+				Status = -EOPNOTSUPP;
+
+			break;
+	}
+
+	if(StateMachineTouched) // Upper layer sent a MLME-related operations
+		RTUSBMlmeUp(pAd);
+
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Add WPA key process
+
+	Arguments:
+		pAd						Pointer to our adapter
+		pBuf					Pointer to the where the key stored
+
+	Return Value:
+		NDIS_SUCCESS			Add key successfully
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPAAddKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_KEY	pKey;
+	ULONG				KeyIdx;
+//	NDIS_STATUS			Status;
+
+	PUCHAR		pTxMic, pRxMic;
+	BOOLEAN 	bTxKey; 		// Set the key as transmit key
+	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
+	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
+								// Otherwise, it will set by the NIC.
+	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
+
+	pKey = (PNDIS_802_11_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0xff;
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+	// Bit 29 of Add-key KeyRSC
+	bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
+	// Bit 28 of Add-key Authenticator
+	bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
+
+	//
+	// Check Group / Pairwise Key
+	//
+	if (bPairwise)	// Pairwise Key
+	{
+		// 1. KeyIdx must be 0, otherwise, return NDIS_STATUS_FAILURE
+		if (KeyIdx != 0)
+			return(NDIS_STATUS_FAILURE);
+
+		// 2. Check bTx, it must be true, otherwise, return NDIS_STATUS_FAILURE
+		if (bTxKey == FALSE)
+			return(NDIS_STATUS_FAILURE);
+
+		// 3. If BSSID is all 0xff, return NDIS_STATUS_FAILURE
+		if (MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR))
+			return(NDIS_STATUS_FAILURE);
+
+		// 3.1 Check Pairwise key length for TKIP key. For AES, it's always 128 bits
+		//if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && (pKey->KeyLength != LEN_TKIP_KEY))
+		if ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) && (pKey->KeyLength != LEN_TKIP_KEY))
+			return(NDIS_STATUS_FAILURE);
+
+		pAd->SharedKey[KeyIdx].Type = PAIRWISE_KEY;
+
+		if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)
+		{
+			// Send media specific event to start PMKID caching
+			RTMPIndicateWPA2Status(pAd);
+		}
+	}
+	else			// Group Key
+	{
+		// 1. Check BSSID, if not current BSSID or Bcast, return NDIS_STATUS_FAILURE
+		if ((! MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR)) &&
+			(! MAC_ADDR_EQUAL(pKey->BSSID, pAd->PortCfg.Bssid)))
+			return(NDIS_STATUS_FAILURE);
+
+		// 2. Check Key index for supported Group Key
+		if (KeyIdx >= GROUP_KEY_NO)
+			return(NDIS_STATUS_FAILURE);
+
+		// 3. Set as default Tx Key if bTxKey is TRUE
+		if (bTxKey == TRUE)
+			pAd->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+
+		pAd->SharedKey[KeyIdx].Type = GROUP_KEY;
+	}
+
+
+	// 4. Select RxMic / TxMic based on Supp / Authenticator
+	if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+	{
+		// for WPA-None Tx, Rx MIC is the same
+		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+		pRxMic = pTxMic;
+	}
+	else if (bAuthenticator == TRUE)
+	{
+		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+		pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+	}
+	else
+	{
+		pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+	}
+
+	// 5. Check RxTsc
+	if (bKeyRSC == TRUE)
+		memcpy(pAd->SharedKey[KeyIdx].RxTsc, &pKey->KeyRSC, 6);
+	else
+		memset(pAd->SharedKey[KeyIdx].RxTsc, 0, 6);
+
+	// 6. Copy information into Pairwise Key structure.
+	// pKey->KeyLength will include TxMic and RxMic, therefore, we use 16 bytes hardcoded.
+	pAd->SharedKey[KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+	memcpy(pAd->SharedKey[KeyIdx].Key, &pKey->KeyMaterial, 16);
+
+	if (pKey->KeyLength == LEN_TKIP_KEY)
+	{
+		// Only Key lenth equal to TKIP key have these
+		memcpy(pAd->SharedKey[KeyIdx].RxMic, pRxMic, 8);
+		memcpy(pAd->SharedKey[KeyIdx].TxMic, pTxMic, 8);
+	}
+	COPY_MAC_ADDR(pAd->SharedKey[KeyIdx].BssId, pKey->BSSID);
+
+	// Init TxTsc to one based on WiFi WPA specs
+	pAd->SharedKey[KeyIdx].TxTsc[0] = 1;
+	pAd->SharedKey[KeyIdx].TxTsc[1] = 0;
+	pAd->SharedKey[KeyIdx].TxTsc[2] = 0;
+	pAd->SharedKey[KeyIdx].TxTsc[3] = 0;
+	pAd->SharedKey[KeyIdx].TxTsc[4] = 0;
+	pAd->SharedKey[KeyIdx].TxTsc[5] = 0;
+
+	if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+		pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_AES;
+	else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)
+		pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_TKIP;
+	else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled)
+	{
+		if (pAd->SharedKey[KeyIdx].KeyLen == 5)
+			pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_WEP64;
+		else if (pAd->SharedKey[KeyIdx].KeyLen == 13)
+			pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_WEP128;
+		else
+			pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+	}
+	else
+		pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+
+	if ((pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA) && (pAd->PortCfg.AuthMode != Ndis802_11AuthModeWPANone))
+	{
+		//
+		// Support WPA-Both , Update Group Key Cipher.
+		//
+		if (!bPairwise)
+		{
+			if (pAd->PortCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+				pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_AES;
+			else if (pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+				pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_TKIP;
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "pAd->SharedKey[%d].CipherAlg = %d\n", KeyIdx, pAd->SharedKey[KeyIdx].CipherAlg);
+
+#if 0
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "%s Key #%d", CipherName[pAd->SharedKey[KeyIdx].CipherAlg],KeyIdx);
+	for (i = 0; i < 16; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].Key[i]);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 Rx MIC Key = ");
+	for (i = 0; i < 8; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].RxMic[i]);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 Tx MIC Key = ");
+	for (i = 0; i < 8; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].TxMic[i]);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 RxTSC = ");
+	for (i = 0; i < 6; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].RxTsc[i]);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
+		pKey->BSSID[0],pKey->BSSID[1],pKey->BSSID[2],pKey->BSSID[3],pKey->BSSID[4],pKey->BSSID[5]);
+#endif
+	AsicAddSharedKeyEntry(pAd,
+						  0,
+						  (UCHAR)KeyIdx,
+						  pAd->SharedKey[KeyIdx].CipherAlg,
+						  pAd->SharedKey[KeyIdx].Key,
+						  pAd->SharedKey[KeyIdx].TxMic,
+						  pAd->SharedKey[KeyIdx].RxMic);
+
+	if (pAd->SharedKey[KeyIdx].Type == GROUP_KEY)
+	{
+		// 802.1x port control
+		pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+	}
+
+	return (NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Remove WPA Key process
+
+	Arguments:
+		pAd						Pointer to our adapter
+		pBuf					Pointer to the where the key stored
+
+	Return Value:
+		NDIS_SUCCESS			Add key successfully
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPARemoveKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_REMOVE_KEY	pKey;
+	ULONG					KeyIdx;
+	NDIS_STATUS				Status = NDIS_STATUS_FAILURE;
+	BOOLEAN 	bTxKey; 		// Set the key as transmit key
+	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
+	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
+								// Otherwise, it will set by the NIC.
+	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
+	INT 		i;
+
+	DBGPRINT(RT_DEBUG_TRACE,"---> RTMPWPARemoveKeyProc\n");
+
+	pKey = (PNDIS_802_11_REMOVE_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0xff;
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+	// Bit 29 of Add-key KeyRSC
+	bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
+	// Bit 28 of Add-key Authenticator
+	bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
+
+	// 1. If bTx is TRUE, return failure information
+	if (bTxKey == TRUE)
+		return(NDIS_STATUS_FAILURE);
+
+	// 2. Check Pairwise Key
+	if (bPairwise)
+	{
+		// a. If BSSID is broadcast, remove all pairwise keys.
+		// b. If not broadcast, remove the pairwise specified by BSSID
+		for (i = 0; i < SHARE_KEY_NUM; i++)
+		{
+			if (MAC_ADDR_EQUAL(pAd->SharedKey[i].BssId, pKey->BSSID))
+			{
+				DBGPRINT(RT_DEBUG_TRACE,"RTMPWPARemoveKeyProc(KeyIdx=%d)\n", i);
+				pAd->SharedKey[i].KeyLen = 0;
+				pAd->SharedKey[i].CipherAlg = CIPHER_NONE;
+				AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)i);
+				Status = NDIS_STATUS_SUCCESS;
+				break;
+			}
+		}
+	}
+	// 3. Group Key
+	else
+	{
+		// a. If BSSID is broadcast, remove all group keys indexed
+		// b. If BSSID matched, delete the group key indexed.
+		DBGPRINT(RT_DEBUG_TRACE,"RTMPWPARemoveKeyProc(KeyIdx=%d)\n", KeyIdx);
+		pAd->SharedKey[KeyIdx].KeyLen = 0;
+		pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+		AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx);
+		Status = NDIS_STATUS_SUCCESS;
+	}
+
+	return (Status);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Construct and indicate WPA2 Media Specific Status
+
+	Arguments:
+		pAd	Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPIndicateWPA2Status(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	struct
+	{
+		NDIS_802_11_STATUS_TYPE				Status;
+		NDIS_802_11_PMKID_CANDIDATE_LIST	List;
+	}	Candidate;
+
+
+	Candidate.Status = Ndis802_11StatusType_PMKID_CandidateList;
+	Candidate.List.Version = 1;
+	// This might need to be fixed to accomadate with current saved PKMIDs
+	Candidate.List.NumCandidates = 1;
+	memcpy(&Candidate.List.CandidateList[0].BSSID, pAd->PortCfg.Bssid, 6);
+	Candidate.List.CandidateList[0].Flags = 0;
+//	NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, &Candidate, sizeof(Candidate));
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIndicateWPA2Status\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Remove All WPA Keys
+
+	Arguments:
+		pAd						Pointer to our adapter
+
+	Return Value:
+		None
+
+	========================================================================
+*/
+VOID	RTMPWPARemoveAllKeys(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	INT i;
+
+	DBGPRINT(RT_DEBUG_TRACE,"RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n", pAd->PortCfg.AuthMode, pAd->PortCfg.WepStatus);
+
+	// For WPA-None, there is no need to remove it, since WinXP won't set it again after
+	// Link up. And it will be replaced if user changed it.
+	if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		return;
+
+	for (i = 0; i < SHARE_KEY_NUM; i++)
+	{
+//		if ((pAd->SharedKey[i].CipherAlg == CIPHER_WEP64)  ||
+//			(pAd->SharedKey[i].CipherAlg == CIPHER_WEP128) ||
+//			(pAd->SharedKey[i].CipherAlg == CIPHER_CKIP64) ||
+//			(pAd->SharedKey[i].CipherAlg == CIPHER_CKIP128))
+//			continue;
+
+		DBGPRINT(RT_DEBUG_TRACE,"remove %s key #%d\n", CipherName[pAd->SharedKey[i].CipherAlg], i);
+		pAd->SharedKey[i].CipherAlg = CIPHER_NONE;
+		pAd->SharedKey[i].KeyLen = 0;
+		AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)i);
+	}
+
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Change NIC PHY mode. Re-association may be necessary. possible settings
+		include - PHY_11B, PHY_11BG_MIXED, PHY_11A, and PHY_11ABG_MIXED
+
+	Arguments:
+		pAd - Pointer to our adapter
+		phymode  -
+
+	========================================================================
+*/
+VOID	RTMPSetPhyMode(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			phymode)
+{
+	INT	i;
+
+	DBGPRINT(RT_DEBUG_TRACE,"RTMPSetPhyMode(=%d)\n", phymode);
+
+// pAd->RfIcType is not ready on RTMPReadParametersFromFile() init
+#if 0
+	// the selected phymode must be supported by the RF IC encoded in E2PROM
+	if ((pAd->RfIcType == RFIC_5226) || (pAd->RfIcType == RFIC_5225))
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"RFIC[%d], Phymode(=%d)\n", pAd->RfIcType, phymode);
+	}
+	else if ((pAd->RfIcType == RFIC_2528) || (pAd->RfIcType == RFIC_2527))
+	{
+		if ((phymode == PHY_11A) || (phymode == PHY_11ABG_MIXED))
+			phymode = PHY_11BG_MIXED;
+		DBGPRINT(RT_DEBUG_TRACE,"RFIC[%d], Phymode(=%d)\n", pAd->RfIcType, phymode);
+	}
+#endif
+	// if no change, do nothing
+	if (pAd->PortCfg.PhyMode == phymode)
+		return;
+
+	pAd->PortCfg.PhyMode = (UCHAR)phymode;
+	BuildChannelList(pAd);
+
+	// sanity check user setting in Registry
+	for (i = 0; i < pAd->ChannelListNum; i++)
+	{
+		if (pAd->PortCfg.Channel == pAd->ChannelList[i].Channel)
+			break;
+	}
+	if (i == pAd->ChannelListNum)
+		pAd->PortCfg.Channel = FirstChannel(pAd);
+
+	memset(pAd->PortCfg.SupRate, 0, MAX_LEN_OF_SUPPORTED_RATES);
+	memset(pAd->PortCfg.ExtRate, 0, MAX_LEN_OF_SUPPORTED_RATES);
+	memset(pAd->PortCfg.DesireRate, 0, MAX_LEN_OF_SUPPORTED_RATES);
+	switch (phymode) {
+		case PHY_11B:
+			pAd->PortCfg.SupRate[0]  = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[1]  = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[2]  = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[3]  = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRateLen  = 4;
+			pAd->PortCfg.ExtRateLen  = 0;
+			pAd->PortCfg.DesireRate[0]	= 2;	 // 1 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[1]	= 4;	 // 2 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[2]	= 11;	 // 5.5 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[3]	= 22;	 // 11 mbps, in units of 0.5 Mbps
+			break;
+
+		case PHY_11G:
+		case PHY_11BG_MIXED:
+		case PHY_11ABG_MIXED:
+			pAd->PortCfg.SupRate[0]  = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[1]  = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[2]  = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[3]  = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[4]  = 0x12;	// 9 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[5]  = 0x24;	// 18 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[6]  = 0x48;	// 36 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[7]  = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRateLen  = 8;
+			pAd->PortCfg.ExtRate[0]  = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.ExtRate[1]  = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.ExtRate[2]  = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.ExtRate[3]  = 0x60;	// 48 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.ExtRateLen  = 4;
+			pAd->PortCfg.DesireRate[0]	= 2;	 // 1 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[1]	= 4;	 // 2 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[2]	= 11;	 // 5.5 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[3]	= 22;	 // 11 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[4]	= 12;	 // 6 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[5]	= 18;	 // 9 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[6]	= 24;	 // 12 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[7]	= 36;	 // 18 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[8]	= 48;	 // 24 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[9]	= 72;	 // 36 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[10] = 96;	 // 48 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[11] = 108;	 // 54 mbps, in units of 0.5 Mbps
+			break;
+
+		case PHY_11A:
+			pAd->PortCfg.SupRate[0]  = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[1]  = 0x12;	// 9 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[2]  = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[3]  = 0x24;	// 18 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[4]  = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+			pAd->PortCfg.SupRate[5]  = 0x48;	// 36 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[6]  = 0x60;	// 48 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRate[7]  = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.SupRateLen  = 8;
+			pAd->PortCfg.ExtRateLen  = 0;
+			pAd->PortCfg.DesireRate[0]	= 12;	 // 6 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[1]	= 18;	 // 9 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[2]	= 24;	 // 12 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[3]	= 36;	 // 18 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[4]	= 48;	 // 24 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[5]	= 72;	 // 36 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[6]	= 96;	 // 48 mbps, in units of 0.5 Mbps
+			pAd->PortCfg.DesireRate[7]	= 108;	 // 54 mbps, in units of 0.5 Mbps
+			break;
+
+		default:
+			break;
+	}
+
+	MlmeUpdateTxRates(pAd, FALSE);
+	AsicSetSlotTime(pAd, (BOOLEAN)pAd->PortCfg.UseShortSlotTime);
+
+	pAd->PortCfg.BandState = UNKNOWN_BAND;
+//  MakeIbssBeacon(pAd);	  // supported rates may change
+}
+
+VOID	RTMPSetDesiredRates(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	LONG			Rates)
+{
+	NDIS_802_11_RATES aryRates;
+
+	memset(&aryRates, 0, sizeof(NDIS_802_11_RATES));
+	switch (pAdapter->PortCfg.PhyMode)
+	{
+		case PHY_11A: // A only
+			switch (Rates)
+			{
+				case 6000000: //6M
+					aryRates[0] = 0x0c; // 6M
+					break;
+				case 9000000: //9M
+					aryRates[0] = 0x12; // 9M
+					break;
+				case 12000000: //12M
+					aryRates[0] = 0x18; // 12M
+					break;
+				case 18000000: //18M
+					aryRates[0] = 0x24; // 18M
+					break;
+				case 24000000: //24M
+					aryRates[0] = 0x30; // 24M
+					break;
+				case 36000000: //36M
+					aryRates[0] = 0x48; // 36M
+					break;
+				case 48000000: //48M
+					aryRates[0] = 0x60; // 48M
+					break;
+				case 54000000: //54M
+					aryRates[0] = 0x6c; // 54M
+					break;
+				case -1: //Auto
+				default:
+					aryRates[0] = 0x6c; // 54Mbps
+					aryRates[1] = 0x60; // 48Mbps
+					aryRates[2] = 0x48; // 36Mbps
+					aryRates[3] = 0x30; // 24Mbps
+					aryRates[4] = 0x24; // 18M
+					aryRates[5] = 0x18; // 12M
+					aryRates[6] = 0x12; // 9M
+					aryRates[7] = 0x0c; // 6M
+					break;
+			}
+			break;
+		case PHY_11BG_MIXED: // B/G Mixed
+		case PHY_11B: // B only
+		case PHY_11ABG_MIXED: // A/B/G Mixed
+		default:
+			switch (Rates)
+			{
+				case 1000000: //1M
+					aryRates[0] = 0x02;
+					break;
+				case 2000000: //2M
+					aryRates[0] = 0x04;
+					break;
+				case 5000000: //5.5M
+					aryRates[0] = 0x0b; // 5.5M
+					break;
+				case 11000000: //11M
+					aryRates[0] = 0x16; // 11M
+					break;
+				case 6000000: //6M
+					aryRates[0] = 0x0c; // 6M
+					break;
+				case 9000000: //9M
+					aryRates[0] = 0x12; // 9M
+					break;
+				case 12000000: //12M
+					aryRates[0] = 0x18; // 12M
+					break;
+				case 18000000: //18M
+					aryRates[0] = 0x24; // 18M
+					break;
+				case 24000000: //24M
+					aryRates[0] = 0x30; // 24M
+					break;
+				case 36000000: //36M
+					aryRates[0] = 0x48; // 36M
+					break;
+				case 48000000: //48M
+					aryRates[0] = 0x60; // 48M
+					break;
+				case 54000000: //54M
+					aryRates[0] = 0x6c; // 54M
+					break;
+				case -1: //Auto
+				default:
+					if (pAdapter->PortCfg.PhyMode == PHY_11B)
+					{ //B Only
+						aryRates[0] = 0x16; // 11Mbps
+						aryRates[1] = 0x0b; // 5.5Mbps
+						aryRates[2] = 0x04; // 2Mbps
+						aryRates[3] = 0x02; // 1Mbps
+					}
+					else
+					{ //(B/G) Mixed or (A/B/G) Mixed
+						aryRates[0] = 0x6c; // 54Mbps
+						aryRates[1] = 0x60; // 48Mbps
+						aryRates[2] = 0x48; // 36Mbps
+						aryRates[3] = 0x30; // 24Mbps
+						aryRates[4] = 0x16; // 11Mbps
+						aryRates[5] = 0x0b; // 5.5Mbps
+						aryRates[6] = 0x04; // 2Mbps
+						aryRates[7] = 0x02; // 1Mbps
+					}
+					break;
+			}
+			break;
+	}
+
+	memset(pAdapter->PortCfg.DesireRate, 0, MAX_LEN_OF_SUPPORTED_RATES);
+	memcpy(pAdapter->PortCfg.DesireRate, &aryRates, sizeof(NDIS_802_11_RATES));
+	DBGPRINT(RT_DEBUG_TRACE, " RTMPSetDesiredRates (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
+		pAdapter->PortCfg.DesireRate[0],pAdapter->PortCfg.DesireRate[1],
+		pAdapter->PortCfg.DesireRate[2],pAdapter->PortCfg.DesireRate[3],
+		pAdapter->PortCfg.DesireRate[4],pAdapter->PortCfg.DesireRate[5],
+		pAdapter->PortCfg.DesireRate[6],pAdapter->PortCfg.DesireRate[7] );
+	// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+	MlmeUpdateTxRates(pAdapter, FALSE);
+}
+
+INT Set_DriverVersion_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "Driver version-%s\n", DRIVER_VERSION);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Country Region.
+		This command will not work, if the field of CountryRegion in eeprom is programmed.
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_CountryRegion_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	ULONG region;
+
+	region = simple_strtol(arg, 0, 10);
+
+	// Country can be set only when EEPROM not programmed
+	if (pAd->PortCfg.CountryRegion & 0x80)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_CountryRegion_Proc::parameter of CountryRegion in eeprom is programmed \n");
+		return FALSE;
+	}
+
+	if(region <= REGION_MAXIMUM_BG_BAND)
+	{
+		pAd->PortCfg.CountryRegion = (UCHAR) region;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_CountryRegion_Proc::parameters out of range\n");
+		return FALSE;
+	}
+
+	// if set country region, driver needs to be reset
+	BuildChannelList(pAd);
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_CountryRegion_Proc::(CountryRegion=%d)\n", pAd->PortCfg.CountryRegion);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Country Region for A band.
+		This command will not work, if the field of CountryRegion in eeprom is programmed.
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_CountryRegionABand_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	ULONG region;
+
+	region = simple_strtol(arg, 0, 10);
+
+	// Country can be set only when EEPROM not programmed
+	if (pAd->PortCfg.CountryRegionForABand & 0x80)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_CountryRegionABand_Proc::parameter of CountryRegion in eeprom is programmed \n");
+		return FALSE;
+	}
+
+	if(region <= REGION_MAXIMUM_A_BAND)
+	{
+		pAd->PortCfg.CountryRegionForABand = (UCHAR) region;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_CountryRegionABand_Proc::parameters out of range\n");
+		return FALSE;
+	}
+
+	// if set country region, driver needs to be reset
+	BuildChannelList(pAd);
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_CountryRegionABand_Proc::(CountryRegion=%d)\n", pAd->PortCfg.CountryRegionForABand);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set SSID
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_SSID_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	BOOLEAN 							StateMachineTouched = FALSE;
+	int 								success = TRUE;
+
+	if( strlen(arg) <= MAX_LEN_OF_SSID)
+	{
+
+		memset(&Ssid, 0, MAX_LEN_OF_SSID);
+		if (strlen(arg) != 0)
+		{
+			memcpy(Ssid.Ssid, arg, strlen(arg));
+			Ssid.SsidLength = strlen(arg);
+		}
+		else
+		{
+			Ssid.SsidLength = 0; //ANY ssid
+            memcpy(Ssid.Ssid, "", 0);
+
+			// reset to infra/open/none as the user sets ANY ssid
+            // $ iwpriv [interface] set SSID=""
+			pAdapter->PortCfg.BssType = BSS_INFRA;
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+			pAdapter->PortCfg.WepStatus  = Ndis802_11EncryptionDisabled;
+		}
+
+		pSsid = &Ssid;
+
+		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+		{
+			MlmeEnqueue(pAdapter,
+                        MLME_CNTL_STATE_MACHINE,
+                        RT_CMD_RESET_MLME,
+                        0,
+                        NULL);
+		}
+	    // tell CNTL state machine to call NdisMSetInformationComplete() after completing
+		// this request, because this request is initiated by NDIS.
+		pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+		MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_SSID,
+					sizeof(NDIS_802_11_SSID),
+					(VOID *)pSsid);
+
+		StateMachineTouched = TRUE;
+		DBGPRINT(RT_DEBUG_TRACE, "Set_SSID_Proc::(Len=%d,Ssid=%s)\n", Ssid.SsidLength, Ssid.Ssid);
+	}
+	else
+		success = FALSE;
+
+	if (StateMachineTouched) // Upper layer sent a MLME-related operations
+		RTUSBMlmeUp(pAdapter);
+
+	return success;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Wireless Mode
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_WirelessMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG								WirelessMode;
+	int 								success = TRUE;
+
+	WirelessMode = simple_strtol(arg, 0, 10);
+
+	if ((WirelessMode == PHY_11BG_MIXED) || (WirelessMode == PHY_11B) ||
+		(WirelessMode == PHY_11A) || (WirelessMode == PHY_11ABG_MIXED) ||
+		(WirelessMode == PHY_11G))
+	{
+		// protect no A-band support
+		if ((pAdapter->RfIcType != RFIC_5226) && (pAdapter->RfIcType != RFIC_5225))
+		{
+			if ((WirelessMode == PHY_11A) || (WirelessMode == PHY_11ABG_MIXED))
+			{
+				DBGPRINT_ERR("!!!!! Not support A band in RfIcType= %d\n", pAdapter->RfIcType);
+				return FALSE;
+			}
+		}
+
+		RTMPSetPhyMode(pAdapter, WirelessMode);
+
+		DBGPRINT(RT_DEBUG_TRACE, "Set_WirelessMode_Proc::(=%d)\n", WirelessMode);
+
+		return success;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_WirelessMode_Proc::parameters out of range\n");
+		return FALSE;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+		Set TxRate
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG								TxRate;
+	int 								success = TRUE;
+
+	TxRate = simple_strtol(arg, 0, 10);
+
+	if ((pAdapter->PortCfg.PhyMode == PHY_11B && TxRate <= 4) ||\
+		((pAdapter->PortCfg.PhyMode == PHY_11BG_MIXED || pAdapter->PortCfg.PhyMode == PHY_11ABG_MIXED) && TxRate <= 12) ||\
+		((pAdapter->PortCfg.PhyMode == PHY_11A || pAdapter->PortCfg.PhyMode == PHY_11G) && (TxRate == 0 ||(TxRate > 4 && TxRate <= 12))))
+	{
+		if (TxRate == 0)
+			RTMPSetDesiredRates(pAdapter, -1);
+		else
+			RTMPSetDesiredRates(pAdapter, (LONG) (RateIdToMbps[TxRate-1] * 1000000));
+
+		DBGPRINT(RT_DEBUG_TRACE, "Set_TxRate_Proc::(TxRate=%d)\n", TxRate);
+
+		return success;
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Set_TxRate_Proc::parameters out of range\n");
+		return FALSE;	//Invalid argument
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Channel
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Channel_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	int 								success = TRUE;
+	UCHAR								Channel;
+
+	Channel = (UCHAR) simple_strtol(arg, 0, 10);
+
+	if (ChannelSanity(pAdapter, Channel) == TRUE)
+	{
+		pAdapter->PortCfg.Channel = Channel;
+
+        if (pAdapter->PortCfg.BssType == BSS_ADHOC)
+			pAdapter->PortCfg.AdhocChannel = pAdapter->PortCfg.Channel; // sync. to the value of PortCfg.Channel
+
+		DBGPRINT(RT_DEBUG_TRACE, "Set_Channel_Proc::(Channel=%d)\n", Channel);
+	}
+	else
+		success = FALSE;
+
+	return success;
+}
+
+#ifdef DBG
+/*
+	==========================================================================
+	Description:
+		For Debug information
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT	Set_Debug_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "==> Set_Debug_Proc *******************\n");
+
+	if(simple_strtol(arg, 0, 10) <= RT_DEBUG_LOUD)
+		RTDebugLevel = simple_strtol(arg, 0, 10);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== Set_Debug_Proc(RTDebugLevel = %d)\n", RTDebugLevel);
+
+	return TRUE;
+}
+#endif
+
+/*
+	==========================================================================
+	Description:
+		Set 11B/11G Protection
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_BGProtection_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+
+{
+	switch (simple_strtol(arg, 0, 10))
+	{
+		case 0: //AUTO
+			pAdapter->PortCfg.UseBGProtection = 0;
+			break;
+		case 1: //Always On
+			pAdapter->PortCfg.UseBGProtection = 1;
+			break;
+		case 2: //Always OFF
+			pAdapter->PortCfg.UseBGProtection = 2;
+			break;
+		default:  //Invalid argument
+			return FALSE;
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "Set_BGProtection_Proc::(BGProtection=%d)\n", pAdapter->PortCfg.UseBGProtection);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set TxPreamble
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxPreamble_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	RT_802_11_PREAMBLE					Preamble;
+
+	Preamble = simple_strtol(arg, 0, 10);
+	switch (Preamble)
+	{
+		case Rt802_11PreambleShort:
+			pAdapter->PortCfg.TxPreamble = Preamble;
+			MlmeSetTxPreamble(pAdapter, Rt802_11PreambleShort);
+			break;
+		case Rt802_11PreambleLong:
+		case Rt802_11PreambleAuto:
+			// if user wants AUTO, initialize to LONG here, then change according to AP's
+			// capability upon association.
+			pAdapter->PortCfg.TxPreamble = Preamble;
+			MlmeSetTxPreamble(pAdapter, Rt802_11PreambleLong);
+			break;
+		default: //Invalid argument
+			return FALSE;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_TxPreamble_Proc::(TxPreamble=%d)\n", Preamble);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set RTS Threshold
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_RTSThreshold_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+
+	RtsThresh = simple_strtol(arg, 0, 10);
+
+	if((RtsThresh > 0) && (RtsThresh <= MAX_RTS_THRESHOLD))
+		pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+	else if (RtsThresh == 0)
+		pAdapter->PortCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+	else
+		return FALSE;
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_RTSThreshold_Proc::(RTSThreshold=%d)\n", pAdapter->PortCfg.RtsThreshold);
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Fragment Threshold
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_FragThreshold_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	NDIS_802_11_FRAGMENTATION_THRESHOLD 	FragThresh;
+
+	FragThresh = simple_strtol(arg, 0, 10);
+
+	if ( (FragThresh >= MIN_FRAG_THRESHOLD) && (FragThresh <= MAX_FRAG_THRESHOLD))
+		pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+	else if (FragThresh == 0)
+		pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+	else
+		return FALSE; //Invalid argument
+
+	if (pAdapter->PortCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+		pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
+	else
+		pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_FragThreshold_Proc::(FragThreshold=%d)\n", FragThresh);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set TxBurst
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxBurst_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG								TxBurst;
+
+	TxBurst = simple_strtol(arg, 0, 10);
+
+	if (TxBurst == 1)
+		pAdapter->PortCfg.bEnableTxBurst = TRUE;
+	else if (TxBurst == 0)
+		pAdapter->PortCfg.bEnableTxBurst = FALSE;
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_TxBurst_Proc::(TxBurst=%d)\n", pAdapter->PortCfg.bEnableTxBurst);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set AdhocMode support Rate can or can not exceed 11Mbps against WiFi spec.
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_AdhocModeRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG		AdhocMode;
+
+	AdhocMode = (ULONG)simple_strtol(arg, 0, 10);
+
+	if (AdhocMode > 4)
+		return FALSE;  //Invalid argument
+
+	if (pAdapter->PortCfg.AdhocMode != AdhocMode)
+	{
+		pAdapter->PortCfg.AdhocMode = AdhocMode;
+		MlmeUpdateTxRates(pAdapter, FALSE);
+		MakeIbssBeacon(pAdapter);			// re-build BEACON frame
+		AsicEnableIbssSync(pAdapter);		// copy to on-chip memory
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_AdhocModeRate_Proc::(AdhocMode=%d)\n", pAdapter->PortCfg.AdhocMode);
+
+	return TRUE;
+}
+#ifdef AGGREGATION_SUPPORT
+/*
+	==========================================================================
+	Description:
+		Set TxBurst
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT	Set_PktAggregate_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	ULONG aggre;
+
+	aggre = simple_strtol(arg, 0, 10);
+
+	if (aggre == 1)
+		pAd->PortCfg.bAggregationCapable = TRUE;
+	else if (aggre == 0)
+		pAd->PortCfg.bAggregationCapable = FALSE;
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_PktAggregate_Proc::(AGGRE=%d)\n", pAd->PortCfg.bAggregationCapable);
+
+	return TRUE;
+}
+#endif
+
+/*
+	==========================================================================
+	Description:
+		Set TurboRate Enable or Disable
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TurboRate_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG								TurboRate;
+
+	TurboRate = simple_strtol(arg, 0, 10);
+
+	if (TurboRate == 1)
+		pAdapter->PortCfg.EnableTurboRate = TRUE;
+	else if (TurboRate == 0)
+		pAdapter->PortCfg.EnableTurboRate = FALSE;
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_TurboRate_Proc::(TurboRate=%d)\n", pAdapter->PortCfg.EnableTurboRate);
+
+	return TRUE;
+}
+#if 0
+/*
+	==========================================================================
+	Description:
+		Set WmmCapable Enable or Disable
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT	Set_WmmCapable_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	BOOLEAN	bWmmCapable;
+
+	bWmmCapable = simple_strtol(arg, 0, 10);
+
+	if (bWmmCapable == 1)
+		pAd->PortCfg.bWmmCapable = TRUE;
+	else if (bWmmCapable == 0)
+		pAd->PortCfg.bWmmCapable = FALSE;
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_WmmCapable_Proc::(bWmmCapable=%d)\n", pAd->PortCfg.bWmmCapable);
+
+	return TRUE;
+}
+#endif
+/*
+	==========================================================================
+	Description:
+		Set IEEE80211H.
+		This parameter is 1 when needs radar detection, otherwise 0
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT	Set_IEEE80211H_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	ULONG ieee80211h;
+
+	ieee80211h = simple_strtol(arg, 0, 10);
+
+	if (ieee80211h == 1)
+		pAd->PortCfg.bIEEE80211H = TRUE;
+	else if (ieee80211h == 0)
+		pAd->PortCfg.bIEEE80211H = FALSE;
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_IEEE80211H_Proc::(IEEE80211H=%d)\n", pAd->PortCfg.bIEEE80211H);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Network Type(Infrastructure/Adhoc mode)
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_NetworkType_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	if (strcmp(arg, "Adhoc") == 0)
+	{
+		if (pAdapter->PortCfg.BssType != BSS_ADHOC)
+		{
+			// Config has changed
+			if (INFRA_ON(pAdapter))
+				RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+		}
+		pAdapter->PortCfg.BssType = BSS_ADHOC;
+	}
+	else
+	{
+		if (pAdapter->PortCfg.BssType != BSS_INFRA)
+		{
+			// Config has changed
+			if (ADHOC_ON(pAdapter))
+				RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+		}
+		pAdapter->PortCfg.BssType = BSS_INFRA;
+	}
+
+	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	pAdapter->PortCfg.WpaState = SS_NOTUSE;
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_NetworkType_Proc::(NetworkType=%d)\n", pAdapter->PortCfg.BssType);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Authentication mode
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_AuthMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	if ((strcmp(arg, "WEPAUTO") == 0) || (strcmp(arg, "wepauto") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeAutoSwitch;
+	else if ((strcmp(arg, "OPEN") == 0) || (strcmp(arg, "open") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+	else if ((strcmp(arg, "SHARED") == 0) || (strcmp(arg, "shared") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+	else if ((strcmp(arg, "WPAPSK") == 0) || (strcmp(arg, "wpapsk") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+	else if ((strcmp(arg, "WPANONE") == 0) || (strcmp(arg, "wpanone") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
+	else if ((strcmp(arg, "WPA2PSK") == 0) || (strcmp(arg, "wpa2psk") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+    else if ((strcmp(arg, "WPA") == 0) || (strcmp(arg, "wpa") == 0))
+        pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPA;
+	else
+		return FALSE;
+
+	pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_AuthMode_Proc::(AuthMode=%d)\n", pAdapter->PortCfg.AuthMode);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Encryption Type
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_EncrypType_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	if ((strcmp(arg, "NONE") == 0) || (strcmp(arg, "none") == 0))
+	{
+		pAdapter->PortCfg.WepStatus   = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.PairCipher  = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPDisabled;
+	}
+	else if ((strcmp(arg, "WEP") == 0) || (strcmp(arg, "wep") == 0))
+	{
+		pAdapter->PortCfg.WepStatus   = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.PairCipher  = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPEnabled;
+	}
+	else if ((strcmp(arg, "TKIP") == 0) || (strcmp(arg, "tkip") == 0))
+	{
+		pAdapter->PortCfg.WepStatus   = Ndis802_11Encryption2Enabled;
+		pAdapter->PortCfg.PairCipher  = Ndis802_11Encryption2Enabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11Encryption2Enabled;
+	}
+	else if ((strcmp(arg, "AES") == 0) || (strcmp(arg, "aes") == 0))
+	{
+		pAdapter->PortCfg.WepStatus   = Ndis802_11Encryption3Enabled;
+		pAdapter->PortCfg.PairCipher  = Ndis802_11Encryption3Enabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11Encryption3Enabled;
+	}
+	else
+		return FALSE;
+
+	RTMPMakeRSNIE(pAdapter, pAdapter->PortCfg.GroupCipher);
+//	RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_WEP_STATUS, TRUE, &(pAdapter->PortCfg.WepStatus),
+//							sizeof(pAdapter->PortCfg.WepStatus));
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_EncrypType_Proc::(EncrypType=%d)\n", pAdapter->PortCfg.WepStatus);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Default Key ID
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_DefaultKeyID_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	ULONG								KeyIdx;
+
+	KeyIdx = simple_strtol(arg, 0, 10);
+	if((KeyIdx >= 1 ) && (KeyIdx <= 4))
+		pAdapter->PortCfg.DefaultKeyId = (UCHAR) (KeyIdx - 1 );
+	else
+		return FALSE;  //Invalid argument
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_DefaultKeyID_Proc::(DefaultKeyID=%d)\n", pAdapter->PortCfg.DefaultKeyId);
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set WEP KEY1
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key1_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	UCHAR								CipherAlg=CIPHER_WEP64;
+
+
+	if (pAdapter->PortCfg.WepStatus != Ndis802_11WEPEnabled ||\
+		pAdapter->PortCfg.DefaultKeyId != 0)
+		return TRUE;	// do nothing
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->SharedKey[0].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[0].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[0].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[0].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->SharedKey[0].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[0].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[0].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[0].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key1_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+
+	pAdapter->SharedKey[0].CipherAlg = CipherAlg;
+
+	// Set keys (into ASIC)
+	if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+		;	// not support
+	else	// Old WEP stuff
+	{
+		AsicAddSharedKeyEntry(pAdapter,
+							  0,
+							  0,
+							  pAdapter->SharedKey[0].CipherAlg,
+							  pAdapter->SharedKey[0].Key,
+							  NULL,
+							  NULL);
+	}
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set WEP KEY2
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key2_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	UCHAR								CipherAlg=CIPHER_WEP64;
+
+	if (pAdapter->PortCfg.WepStatus != Ndis802_11WEPEnabled ||\
+		pAdapter->PortCfg.DefaultKeyId != 1)
+		return TRUE;	// do nothing
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->SharedKey[1].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[1].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[1].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[1].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->SharedKey[1].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[1].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[1].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[1].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+	pAdapter->SharedKey[1].CipherAlg = CipherAlg;
+
+	// Set keys (into ASIC)
+	if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+		;	// not support
+	else	// Old WEP stuff
+	{
+		AsicAddSharedKeyEntry(pAdapter,
+							  0,
+							  1,
+							  pAdapter->SharedKey[1].CipherAlg,
+							  pAdapter->SharedKey[1].Key,
+							  NULL,
+							  NULL);
+	}
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set WEP KEY3
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key3_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	UCHAR								CipherAlg=CIPHER_WEP64;
+
+	if (pAdapter->PortCfg.WepStatus != Ndis802_11WEPEnabled ||\
+		pAdapter->PortCfg.DefaultKeyId != 2)
+		return TRUE;	// do nothing
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->SharedKey[2].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[2].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[2].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[2].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->SharedKey[2].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[2].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[2].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[2].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+	pAdapter->SharedKey[2].CipherAlg = CipherAlg;
+
+	// Set keys (into ASIC)
+	if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+		;	// not support
+	else	// Old WEP stuff
+	{
+		AsicAddSharedKeyEntry(pAdapter,
+							  0,
+							  2,
+							  pAdapter->SharedKey[2].CipherAlg,
+							  pAdapter->SharedKey[2].Key,
+							  NULL,
+							  NULL);
+   }
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set WEP KEY4
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key4_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	UCHAR								CipherAlg=CIPHER_WEP64;
+
+	if (pAdapter->PortCfg.WepStatus != Ndis802_11WEPEnabled ||\
+		pAdapter->PortCfg.DefaultKeyId != 3)
+		return TRUE;	// do nothing
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->SharedKey[3].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[3].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[3].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[3].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP64;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->SharedKey[3].KeyLen = KeyLen;
+			memcpy(pAdapter->SharedKey[3].Key, arg, KeyLen);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->SharedKey[3].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->SharedKey[3].Key, KeyLen / 2);
+			CipherAlg = CIPHER_WEP128;
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+	pAdapter->SharedKey[3].CipherAlg = CipherAlg;
+
+	// Set keys (into ASIC)
+	if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+		;	// not support
+	else	// Old WEP stuff
+	{
+		AsicAddSharedKeyEntry(pAdapter,
+							  0,
+							  3,
+							  pAdapter->SharedKey[3].CipherAlg,
+							  pAdapter->SharedKey[3].Key,
+							  NULL,
+							  NULL);
+	}
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set WPA PSK key
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_WPAPSK_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	UCHAR					keyMaterial[40];
+	INT 					Status;
+
+	if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&\
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&\
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) )
+		return TRUE;	// do nothing
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_WPAPSK_Proc::(WPAPSK=%s)\n", arg);
+
+	memset(keyMaterial, 0, 40);
+
+	if ((strlen(arg) < 8) || (strlen(arg) > 64))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "Set failed!!(WPAPSK=%s), WPAPSK key-string required 8 ~ 64 characters \n", arg);
+		return FALSE;
+	}
+
+	if (strlen(arg) == 64)
+	{
+		AtoH(arg, keyMaterial, 32);
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+	}
+	else
+	{
+		PasswordHash((char *)arg, pAdapter->MlmeAux.Ssid, pAdapter->MlmeAux.SsidLen, keyMaterial);
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+	}
+
+	RTMPMakeRSNIE(pAdapter, pAdapter->PortCfg.GroupCipher);
+
+	if(pAdapter->PortCfg.BssType == BSS_ADHOC &&\
+	   pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+	{
+		//RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, sizeof(Key));
+		Status = RTMPWPANoneAddKeyProc(pAdapter, &keyMaterial[0]);
+
+		if (Status != NDIS_STATUS_SUCCESS)
+			return FALSE;
+
+		pAdapter->PortCfg.WpaState = SS_NOTUSE;
+	}
+	else	// Use RaConfig as PSK agent.
+	{
+		// Start STA supplicant state machine
+		pAdapter->PortCfg.WpaState = SS_START;
+	}
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Reset statistics counter
+
+	Arguments:
+		pAdapter			Pointer to our adapter
+		arg
+
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT	Set_ResetStatCounter_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			arg)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "==>Set_ResetStatCounter_Proc\n");
+
+	// add the most up-to-date h/w raw counters into software counters
+	NICUpdateRawCounters(pAd);
+
+	memset(&pAd->WlanCounters, 0, sizeof(COUNTER_802_11));
+	memset(&pAd->Counters8023, 0, sizeof(COUNTER_802_3));
+	memset(&pAd->RalinkCounters, 0, sizeof(COUNTER_RALINK));
+
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		Set Power Saving mode
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_PSMode_Proc(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			arg)
+{
+	if (pAdapter->PortCfg.BssType == BSS_INFRA)
+	{
+		if ((strcmp(arg, "MAX_PSP") == 0) || (strcmp(arg, "max_psp") == 0))
+		{
+			// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+			// to exclude certain situations.
+			//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeMAX_PSP;
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			pAdapter->PortCfg.DefaultListenCount = 5;
+
+		}
+		else if ((strcmp(arg, "Fast_PSP") == 0) || (strcmp(arg, "fast_psp") == 0) ||
+				 (strcmp(arg, "FAST_PSP") == 0))
+		{
+			// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+			// to exclude certain situations.
+			//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeFast_PSP;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeFast_PSP;
+			pAdapter->PortCfg.DefaultListenCount = 3;
+		}
+		else
+		{
+			//Default Ndis802_11PowerModeCAM
+			// clear PSM bit immediately
+			MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+		}
+
+		DBGPRINT(RT_DEBUG_TRACE, "Set_PSMode_Proc::(PSMode=%d)\n", pAdapter->PortCfg.WindowsPowerMode);
+	}
+	else
+		return FALSE;
+
+
+	return TRUE;
+}
+
+VOID RTMPIoctlSetRFMONTx(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq)
+{
+	CHAR				arg[31];
+	INT				Status = 0;
+
+	memset(arg,0,32);
+
+	if(wrq->u.data.length > 1)		//No parameters
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, 32);
+		if ((arg[0]-'0') == 1)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "==>RTMPIoctlSetRFMONTx  -->  1\n");
+			pAd->bAcceptRFMONTx = TRUE;
+
+			if (pAd->ForcePrismHeader == 1)
+                		pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+			else
+				pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "==>RTMPIoctlSetRFMONTx  -->  0\n");
+			pAd->bAcceptRFMONTx = FALSE;
+
+			if (pAd->ForcePrismHeader == 2)
+				pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+			else
+		             	pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+		}
+	}
+}
+
+VOID RTMPIoctlGetRFMONTx(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT	struct iwreq	*wrq)
+{
+    *(int *) wrq->u.name = pAd->bAcceptRFMONTx == TRUE ? 1 : 0;
+}
+
+VOID RTMPIoctlForcePrismHeader(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq)
+{
+	CHAR				arg[31];
+	INT				Status = 0;
+
+	memset(arg,0,32);
+
+	if(wrq->u.data.length > 1)		//No parameters
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, 32);
+		if ((arg[0]-'0') == 2)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "==>RTMPIoctlForcePrismHeader  -->  2\n");
+			pAd->ForcePrismHeader = 2;
+			pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+		}
+		else if ((arg[0]-'0') == 1)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "==>RTMPIoctlForcePrismHeader  -->  1\n");
+			pAd->ForcePrismHeader = 1;
+			pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "==>RTMPIoctlForcePrismHeader  -->  0\n");
+			pAd->ForcePrismHeader = 0;
+
+			if (pAd->bAcceptRFMONTx == TRUE)
+				pAd->net_dev->type = 801; // ARPHRD_IEEE80211
+			else
+	                	pAd->net_dev->type = 802; // ARPHRD_IEEE80211_PRISM
+		}
+	}
+}
+
+#ifdef DBG
+/*
+	==========================================================================
+	Description:
+		Read / Write BBP
+	Arguments:
+		pAdapter					Pointer to our adapter
+		wrq 						Pointer to the ioctl argument
+
+	Return Value:
+		None
+
+	Note:
+		Usage:
+			   1.) iwpriv wlan0 bbp			   ==> read all BBP
+			   2.) iwpriv wlan0 bbp 1			   ==> read BBP where RegID=1
+			   3.) iwpriv wlan0 bbp 1=10		   ==> write BBP R1=0x10
+	==========================================================================
+*/
+VOID RTMPIoctlBBP(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR				*this_char;
+	CHAR				*value;
+	UCHAR				regBBP;
+	CHAR				msg[2048];
+	CHAR				arg[255];
+	LONG				bbpId;
+	LONG				bbpValue;
+	BOOLEAN				bIsPrintAllBBP = FALSE;
+	INT 				Status = 0;
+
+	DBGPRINT(RT_DEBUG_INFO, "==>RTMPIoctlBBP\n");
+
+	memset(msg, 0, 2048);
+	if (wrq->u.data.length > 1) //No parameters.
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, (wrq->u.data.length > 255) ? 255 : wrq->u.data.length);
+		sprintf(msg, "\n");
+
+		//Parsing Read or Write
+		this_char = arg;
+		DBGPRINT(RT_DEBUG_INFO, "this_char=%s\n", this_char);
+		if (!*this_char)
+			goto next;
+
+		if ((value = rtstrchr(this_char, '=')) != NULL)
+			*value++ = 0;
+
+		if (!value || !*value)
+		{ //Read
+			DBGPRINT(RT_DEBUG_INFO, "this_char=%s, value=%s\n", this_char, value);
+			if (sscanf(this_char, "%d", &(bbpId)) == 1)
+			{
+				if (bbpId <= 108)
+				{
+					RTUSBReadBBPRegister(pAdapter, bbpId, &regBBP);
+					sprintf(msg+strlen(msg), "R%02d[0x%02X]:%02X  ", bbpId, bbpId*2, regBBP);
+					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
+				}
+				else
+				{//Invalid parametes, so default printk all bbp
+					bIsPrintAllBBP = TRUE;
+					goto next;
+				}
+			}
+			else
+			{ //Invalid parametes, so default printk all bbp
+				bIsPrintAllBBP = TRUE;
+				goto next;
+			}
+		}
+		else
+		{ //Write
+			DBGPRINT(RT_DEBUG_INFO, "this_char=%s, value=%s\n", this_char, value);
+			if ((sscanf(this_char, "%d", &(bbpId)) == 1) && (sscanf(value, "%x", &(bbpValue)) == 1))
+			{
+				DBGPRINT(RT_DEBUG_INFO, "bbpID=%02d, value=0x%x\n", bbpId, bbpValue);
+				if (bbpId <= 108)
+				{
+					RTUSBWriteBBPRegister(pAdapter, (UCHAR)bbpId,(UCHAR) bbpValue);
+					//Read it back for showing
+					RTUSBReadBBPRegister(pAdapter, bbpId, &regBBP);
+					sprintf(msg+strlen(msg), "R%02d[0x%02X]:%02X\n", bbpId, bbpId*2, regBBP);
+					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
+				}
+				else
+				{//Invalid parametes, so default printk all bbp
+					bIsPrintAllBBP = TRUE;
+					goto next;
+				}
+			}
+			else
+			{ //Invalid parametes, so default printk all bbp
+				bIsPrintAllBBP = TRUE;
+				goto next;
+			}
+		}
+	}
+	else
+		bIsPrintAllBBP = TRUE;
+
+next:
+	if (bIsPrintAllBBP)
+	{
+		memset(msg, 0, 2048);
+		sprintf(msg, "\n");
+		for (bbpId = 0; bbpId <= 108; bbpId++)
+		{
+			RTUSBReadBBPRegister(pAdapter, bbpId, &regBBP);
+			sprintf(msg+strlen(msg), "R%02d[0x%02X]:%02X	", bbpId, bbpId*2, regBBP);
+			if (bbpId%5 == 4)
+				sprintf(msg+strlen(msg), "\n");
+		}
+		// Copy the information into the user buffer
+		DBGPRINT(RT_DEBUG_TRACE, "strlen(msg)=%d\n", (int)strlen(msg));
+		wrq->u.data.length = strlen(msg);
+		Status = copy_to_user(wrq->u.data.pointer, msg, wrq->u.data.length);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_INFO, "copy to user [msg=%s]\n", msg);
+		// Copy the information into the user buffer
+		DBGPRINT(RT_DEBUG_INFO, "strlen(msg) =%d\n", (int)strlen(msg));
+		wrq->u.data.length = strlen(msg);
+		Status =  copy_to_user(wrq->u.data.pointer, msg, wrq->u.data.length);
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "<==RTMPIoctlBBP\n\n");
+}
+
+/*
+	==========================================================================
+	Description:
+		Read / Write MAC
+	Arguments:
+		pAdapter					Pointer to our adapter
+		wrq 						Pointer to the ioctl argument
+
+	Return Value:
+		None
+
+	Note:
+		Usage:
+			   1.) iwpriv wlan0 mac 0		  ==> read MAC where Addr=0x0
+			   2.) iwpriv wlan0 mac 0=12	  ==> write MAC where Addr=0x0, value=12
+	==========================================================================
+*/
+VOID RTMPIoctlMAC(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR				*this_char;
+	CHAR				*value;
+	INT					j = 0, k = 0;
+	CHAR				msg[1024];
+	CHAR				arg[255];
+	ULONG				macAddr = 0;
+	UCHAR				temp[16], temp2[16];
+	ULONG				macValue;
+	INT 				Status = 0;
+
+	DBGPRINT(RT_DEBUG_INFO, "==>RTMPIoctlMAC\n");
+	memset(msg, 0, 1024);
+	if (wrq->u.data.length > 1) //No parameters.
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, (wrq->u.data.length > 255) ? 255 : wrq->u.data.length);
+		sprintf(msg, "\n");
+
+		//Parsing Read or Write
+		this_char = arg;
+		DBGPRINT(RT_DEBUG_INFO, "this_char=%s\n", this_char);
+		if (!*this_char)
+			goto next;
+
+		if ((value = rtstrchr(this_char, '=')) != NULL)
+			*value++ = 0;
+
+		if (!value || !*value)
+		{ //Read
+			DBGPRINT(RT_DEBUG_INFO, "Read: this_char=%s, strlen=%d\n", this_char, (int)strlen(this_char));
+
+			// Sanity check
+			if(strlen(this_char) > 4)
+				goto next;
+
+			j = strlen(this_char);
+			while(j-- > 0)
+			{
+				if(this_char[j] > 'f' || this_char[j] < '0')
+					return;
+			}
+
+			// Mac Addr
+			k = j = strlen(this_char);
+			while(j-- > 0)
+			{
+				this_char[4-k+j] = this_char[j];
+			}
+
+			while(k < 4)
+				this_char[3-k++]='0';
+			this_char[4]='\0';
+
+			if(strlen(this_char) == 4)
+			{
+				AtoH(this_char, temp, 4);
+				macAddr = *temp*256 + temp[1];
+				if (macAddr < 0xFFFF)
+				{
+					RTUSBReadMACRegister(pAdapter, macAddr, &macValue);
+					DBGPRINT(RT_DEBUG_TRACE, "MacAddr=%x, MacValue=%x\n", macAddr, macValue);
+					sprintf(msg+strlen(msg), "[0x%08X]:%08X  ", macAddr , macValue);
+					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
+				}
+				else
+				{//Invalid parametes, so default printk all bbp
+					goto next;
+				}
+			}
+		}
+		else
+		{ //Write
+			DBGPRINT(RT_DEBUG_INFO, "Write: this_char=%s, strlen(value)=%d, value=%s\n", this_char, (int)strlen(value), value);
+			memcpy(&temp2, value, strlen(value));
+			temp2[strlen(value)] = '\0';
+
+			// Sanity check
+			if((strlen(this_char) > 4) || strlen(temp2) > 8)
+				goto next;
+
+			j = strlen(this_char);
+			while(j-- > 0)
+			{
+				if(this_char[j] > 'f' || this_char[j] < '0')
+					return;
+			}
+
+			j = strlen(temp2);
+			while(j-- > 0)
+			{
+				if(temp2[j] > 'f' || temp2[j] < '0')
+					return;
+			}
+
+			//MAC Addr
+			k = j = strlen(this_char);
+			while(j-- > 0)
+			{
+				this_char[4-k+j] = this_char[j];
+			}
+
+			while(k < 4)
+				this_char[3-k++]='0';
+			this_char[4]='\0';
+
+			//MAC value
+			k = j = strlen(temp2);
+			while(j-- > 0)
+			{
+				temp2[8-k+j] = temp2[j];
+			}
+
+			while(k < 8)
+				temp2[7-k++]='0';
+			temp2[8]='\0';
+
+			{
+				AtoH(this_char, temp, 4);
+				macAddr = *temp*256 + temp[1];
+
+				AtoH(temp2, temp, 8);
+				macValue = *temp*256*256*256 + temp[1]*256*256 + temp[2]*256 + temp[3];
+
+				// debug mode
+				if (macAddr == (HW_DEBUG_SETTING_BASE + 4))
+				{
+					// 0x2bf4: byte0 non-zero: enable R17 tuning, 0: disable R17 tuning
+					if (macValue & 0x000000ff)
+					{
+						pAdapter->BbpTuning.bEnable = TRUE;
+						DBGPRINT(RT_DEBUG_TRACE,"turn on R17 tuning\n");
+					}
+					else
+					{
+						UCHAR R17;
+						pAdapter->BbpTuning.bEnable = FALSE;
+						if (pAdapter->PortCfg.Channel > 14)
+							R17 = pAdapter->BbpTuning.R17LowerBoundA;
+						else
+							R17 = pAdapter->BbpTuning.R17LowerBoundG;
+						RTUSBWriteBBPRegister(pAdapter, 17, R17);
+						DBGPRINT(RT_DEBUG_TRACE,"turn off R17 tuning, restore to 0x%02x\n", R17);
+					}
+					return;
+				}
+
+				DBGPRINT(RT_DEBUG_TRACE, "MacAddr=%02x, MacValue=0x%x\n", macAddr, macValue);
+
+				RTUSBWriteMACRegister(pAdapter, macAddr, macValue);
+				sprintf(msg+strlen(msg), "[0x%08X]:%08X  ", macAddr, macValue);
+				DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
+			}
+		}
+	}
+next:
+	if(strlen(msg) == 1)
+		sprintf(msg+strlen(msg), "===>Error command format!");
+	DBGPRINT(RT_DEBUG_INFO, "copy to user [msg=%s]\n", msg);
+	// Copy the information into the user buffer
+	DBGPRINT(RT_DEBUG_INFO, "strlen(msg) =%d\n", (int)strlen(msg));
+	wrq->u.data.length = strlen(msg);
+	Status = copy_to_user(wrq->u.data.pointer, msg, wrq->u.data.length);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==RTMPIoctlMAC\n\n");
+}
+
+#endif //#ifdef DBG
+
+/*
+	==========================================================================
+	Description:
+		Read statistics counter
+Arguments:
+	pAdapter					Pointer to our adapter
+	wrq 						Pointer to the ioctl argument
+
+	Return Value:
+		None
+
+	Note:
+		Usage:
+			   1.) iwpriv wlan0 stat 0 		==> Read statistics counter
+	==========================================================================
+*/
+VOID RTMPIoctlStatistics(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct iwreq	*wrq)
+{
+	char				msg[1600];
+	INT 				Status=0;
+
+	memset(msg, 0, 1600);
+	sprintf(msg, "\n");
+
+	sprintf(msg+strlen(msg), "Tx success					  = %d\n", (ULONG)pAd->WlanCounters.TransmittedFragmentCount.QuadPart);
+	sprintf(msg+strlen(msg), "Tx success without retry		  = %d\n", (ULONG)pAd->WlanCounters.TransmittedFragmentCount.QuadPart - (ULONG)pAd->WlanCounters.RetryCount.QuadPart);
+	sprintf(msg+strlen(msg), "Tx success after retry		  = %d\n", (ULONG)pAd->WlanCounters.RetryCount.QuadPart);
+	sprintf(msg+strlen(msg), "Tx fail to Rcv ACK after retry  = %d\n", (ULONG)pAd->WlanCounters.FailedCount.QuadPart);
+	sprintf(msg+strlen(msg), "RTS Success Rcv CTS			  = %d\n", (ULONG)pAd->WlanCounters.RTSSuccessCount.QuadPart);
+	sprintf(msg+strlen(msg), "RTS Fail Rcv CTS				  = %d\n", (ULONG)pAd->WlanCounters.RTSFailureCount.QuadPart);
+
+	sprintf(msg+strlen(msg), "Rx success					  = %d\n", (ULONG)pAd->WlanCounters.ReceivedFragmentCount.QuadPart);
+	sprintf(msg+strlen(msg), "Rx with CRC					  = %d\n", (ULONG)pAd->WlanCounters.FCSErrorCount.QuadPart);
+	sprintf(msg+strlen(msg), "Rx drop due to out of resource  = %d\n", (ULONG)pAd->Counters8023.RxNoBuffer);
+	sprintf(msg+strlen(msg), "Rx duplicate frame			  = %d\n", (ULONG)pAd->WlanCounters.FrameDuplicateCount.QuadPart);
+
+	sprintf(msg+strlen(msg), "False CCA (one second)		  = %d\n", (ULONG)pAd->RalinkCounters.OneSecFalseCCACnt);
+	sprintf(msg+strlen(msg), "RSSI-A						  = %d\n", (LONG)(pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta));
+	sprintf(msg+strlen(msg), "RSSI-B (if available) 		  = %d\n\n", (LONG)(pAd->PortCfg.LastRssi2 - pAd->BbpRssiToDbmDelta));
+
+	// Copy the information into the user buffer
+	DBGPRINT(RT_DEBUG_INFO, "copy to user [msg=%s]\n", msg);
+	wrq->u.data.length = strlen(msg);
+	Status = copy_to_user(wrq->u.data.pointer, msg, wrq->u.data.length);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==RTMPIoctlStatistics\n");
+}
+
+/*
+	==========================================================================
+	Description:
+		Parse encryption type
+Arguments:
+	pAdapter					Pointer to our adapter
+	wrq 						Pointer to the ioctl argument
+
+	Return Value:
+		None
+
+	Note:
+	==========================================================================
+*/
+static CHAR *GetEncryptType(CHAR enc)
+{
+	if(enc == Ndis802_11WEPDisabled)
+		return "NONE";
+	if(enc == Ndis802_11WEPEnabled)
+		return "WEP";
+	if(enc == Ndis802_11Encryption2Enabled)
+		return "TKIP";
+	if(enc == Ndis802_11Encryption3Enabled)
+		return "AES";
+	else
+		return "UNKNOW";
+}
+
+static CHAR *GetAuthMode(CHAR auth)
+{
+	if(auth == Ndis802_11AuthModeOpen)
+		return "OPEN";
+	if(auth == Ndis802_11AuthModeShared)
+		return "SHARED";
+	if(auth == Ndis802_11AuthModeWPA)
+		return "WPA";
+	if(auth == Ndis802_11AuthModeWPAPSK)
+		return "WPA-PSK";
+	if(auth == Ndis802_11AuthModeWPANone)
+		return "WPANONE";
+	if(auth == Ndis802_11AuthModeWPA2)
+		return "WPA2";
+	if(auth == Ndis802_11AuthModeWPA2PSK)
+		return "WPA2-PSK";
+	else
+		return "UNKNOW";
+}
+
+/*
+	==========================================================================
+	Description:
+		Get site survey results
+	Arguments:
+		pAdapter					Pointer to our adapter
+		wrq 						Pointer to the ioctl argument
+
+	Return Value:
+		None
+
+	Note:
+		Usage:
+				1.) UI needs to wait 4 seconds after issue a site survey command
+				2.) iwpriv ra0 get_site_survey
+				3.) UI needs to prepare at least 4096bytes to get the results
+	==========================================================================
+*/
+#define	LINE_LEN	(8+8+36+20+12+12+12)	// Channel+RSSI+SSID+Bssid+WepStatus+AuthMode+NetworkType
+VOID RTMPIoctlGetSiteSurvey(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR		*msg;
+	INT 		i=0;
+	INT 		Status=0;
+
+	msg = (CHAR *) kmalloc(sizeof(CHAR)*((MAX_LEN_OF_BSS_TABLE)*LINE_LEN), MEM_ALLOC_FLAG);
+
+    if (msg == NULL)
+    {
+        return;
+    }
+
+	memset(msg, 0 ,(MAX_LEN_OF_BSS_TABLE)*LINE_LEN );
+	sprintf(msg,"%s","\n");
+	sprintf(msg+strlen(msg),"%-8s%-8s%-36s%-20s%-12s%-12s%-12s\n",
+	    "Channel", "RSSI", "SSID", "BSSID", "Enc", "Auth", "NetworkType");
+	for (i=0;i<MAX_LEN_OF_BSS_TABLE;i++)
+	{
+		if( pAdapter->ScanTab.BssEntry[i].Channel==0)
+		break;
+
+		if((strlen(msg)+LINE_LEN ) >= ((MAX_LEN_OF_BSS_TABLE)*LINE_LEN) )
+			break;
+
+		sprintf(msg+strlen(msg),"%-8d", pAdapter->ScanTab.BssEntry[i].Channel);
+		sprintf(msg+strlen(msg),"%-8d", pAdapter->ScanTab.BssEntry[i].Rssi - pAdapter->BbpRssiToDbmDelta);
+        sprintf(msg+strlen(msg),"%-36s", pAdapter->ScanTab.BssEntry[i].Ssid);
+		sprintf(msg+strlen(msg),"%02x:%02x:%02x:%02x:%02x:%02x   ",
+			pAdapter->ScanTab.BssEntry[i].Bssid[0],
+			pAdapter->ScanTab.BssEntry[i].Bssid[1],
+			pAdapter->ScanTab.BssEntry[i].Bssid[2],
+			pAdapter->ScanTab.BssEntry[i].Bssid[3],
+			pAdapter->ScanTab.BssEntry[i].Bssid[4],
+			pAdapter->ScanTab.BssEntry[i].Bssid[5]);
+		sprintf(msg+strlen(msg),"%-12s",GetEncryptType(pAdapter->ScanTab.BssEntry[i].WepStatus));
+		sprintf(msg+strlen(msg),"%-12s",GetAuthMode(pAdapter->ScanTab.BssEntry[i].AuthMode));
+        if (pAdapter->ScanTab.BssEntry[i].BssType == BSS_ADHOC)
+            sprintf(msg+strlen(msg),"%-12s\n", "Adhoc");
+        else
+		    sprintf(msg+strlen(msg),"%-12s\n", "Infra");
+	}
+
+	wrq->u.data.length = strlen(msg);
+	Status = copy_to_user(wrq->u.data.pointer, msg, wrq->u.data.length);
+	if(msg != NULL){
+		kfree(msg);
+	}
+}
+
+VOID RTMPMakeRSNIE(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	UCHAR			GroupCipher)
+{
+
+	if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+	{
+		memcpy(pAdapter->PortCfg.RSN_IE, CipherWpa2Template, CipherWpa2TemplateLen);
+		// Modify Group cipher
+		pAdapter->PortCfg.RSN_IE[7] = ((GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+		// Modify Pairwise cipher
+		pAdapter->PortCfg.RSN_IE[13] = ((pAdapter->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+		// Modify AKM
+		pAdapter->PortCfg.RSN_IE[19] = ((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
+
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA2PSK GroupC=%d, PairC=%d\n",pAdapter->PortCfg.GroupCipher ,
+			pAdapter->PortCfg.PairCipher);
+
+		pAdapter->PortCfg.RSN_IELen = CipherWpa2TemplateLen;
+	}
+	else if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+	{
+		memcpy(pAdapter->PortCfg.RSN_IE, CipherWpaPskTkip, CipherWpaPskTkipLen);
+		// Modify Group cipher
+		pAdapter->PortCfg.RSN_IE[11] = ((GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+		// Modify Pairwise cipher
+		pAdapter->PortCfg.RSN_IE[17] = ((pAdapter->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+		// Modify AKM
+		pAdapter->PortCfg.RSN_IE[23] = ((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
+
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"WPAPSK GroupC = %d, PairC=%d ,  \n ",pAdapter->PortCfg.GroupCipher ,
+			pAdapter->PortCfg.PairCipher);
+
+		pAdapter->PortCfg.RSN_IELen = CipherWpaPskTkipLen;
+
+
+	}
+	else
+		pAdapter->PortCfg.RSN_IELen = 0;
+
+}
+
+NDIS_STATUS RTMPWPANoneAddKeyProc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_KEY		pKey;
+	ULONG					KeyLen;
+	ULONG					BufLen;
+	NDIS_STATUS 			Status = NDIS_STATUS_SUCCESS;
+	int 					i;
+
+	KeyLen = 32;
+	BufLen = sizeof(NDIS_802_11_KEY) + KeyLen - 1;
+
+	pKey = kmalloc(BufLen, MEM_ALLOC_FLAG);
+	if (pKey == NULL)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "RTMPWPANoneAddKeyProc() allocate memory failed \n");
+		Status = NDIS_STATUS_FAILURE;
+		return	Status;
+	}
+
+	memset(pKey, 0, BufLen);
+	pKey->Length = BufLen;
+	pKey->KeyIndex	= 0x80000000;
+	pKey->KeyLength = KeyLen;
+	for (i=0; i<6; i++)
+		pKey->BSSID[i] = 0xff;
+
+	memcpy(pKey->KeyMaterial, pBuf, 32);
+	RTMPWPAAddKeyProc(pAd, pKey);
+	if(pKey != NULL){
+		kfree(pKey);
+	}
+	return Status;
+}
+
+INT RTMPIoctlAdhocOfdm(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR	 arg[1];
+	INT 	 Status = 0;
+
+	if (wrq->u.data.length != 1)
+	{
+		Status = -EINVAL;
+		return (Status);
+
+	}
+	else
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+
+		if (arg[0] == 1)
+			pAdapter->PortCfg.AdhocMode = 0;
+		else if (arg[0] == 1)
+			pAdapter->PortCfg.AdhocMode = 1;
+		else if (arg[0] == 2)
+			pAdapter->PortCfg.AdhocMode = 2;
+		else
+		{
+			Status = -EINVAL;
+			return (Status);
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetAdhocOfdm::(AdhocMode=%d)\n", pAdapter->PortCfg.AdhocMode);
+
+	return (Status);
+}
+
+#if 1
+INT RTMPIoctlSetAuth(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR	 arg[1];
+	INT 	 Status = 0;
+
+	if (wrq->u.data.length != 1)
+	{
+		Status = -EINVAL;
+		return (Status);
+
+	}
+	else
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+
+		if (arg[0] == 1)
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+		else if (arg[0] == 2)
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+		else if (arg[0] == 3)
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+		else if (arg[0] == 4)
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+		else if (arg[0] == 5)
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
+		else
+		{
+			Status = -EINVAL;
+			return (Status);
+		}
+	}
+
+
+	pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetAuth::(AuthMode=%d)\n", pAdapter->PortCfg.AuthMode);
+
+	return (Status);
+}
+
+INT RTMPIoctlSetEncryp(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR	 arg[1];
+	INT 	 Status = 0;
+
+	if (wrq->u.data.length != 1)
+	{
+		Status = -EINVAL;
+		return (Status);
+	}
+	else
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+
+		if (arg[0] == 1)	// NONE
+		{
+			pAdapter->PortCfg.WepStatus   = Ndis802_11WEPDisabled;
+			pAdapter->PortCfg.PairCipher  = Ndis802_11WEPDisabled;
+			pAdapter->PortCfg.GroupCipher = Ndis802_11WEPDisabled;
+		}
+		else if (arg[0] == 2)	// WEP
+		{
+			pAdapter->PortCfg.WepStatus   = Ndis802_11WEPEnabled;
+			pAdapter->PortCfg.PairCipher  = Ndis802_11WEPEnabled;
+			pAdapter->PortCfg.GroupCipher = Ndis802_11WEPEnabled;
+
+		}
+		else if (arg[0] == 3)	// TKIP
+		{
+			pAdapter->PortCfg.WepStatus   = Ndis802_11Encryption2Enabled;
+			pAdapter->PortCfg.PairCipher  = Ndis802_11Encryption2Enabled;
+			pAdapter->PortCfg.GroupCipher = Ndis802_11Encryption2Enabled;
+
+		}
+		else if (arg[0] == 4)	// AES
+		{
+			pAdapter->PortCfg.WepStatus   = Ndis802_11Encryption3Enabled;
+			pAdapter->PortCfg.PairCipher  = Ndis802_11Encryption3Enabled;
+			pAdapter->PortCfg.GroupCipher = Ndis802_11Encryption3Enabled;
+
+		}
+		else
+		{
+			Status = -EINVAL;
+			return (Status);
+		}
+	}
+
+
+	RTMPMakeRSNIE(pAdapter, pAdapter->PortCfg.GroupCipher);
+//	RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_WEP_STATUS, TRUE, &(pAdapter->PortCfg.WepStatus),
+//							sizeof(pAdapter->PortCfg.WepStatus));
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetEncryp::(EncrypType=%d)\n", pAdapter->PortCfg.WepStatus);
+
+	return (Status);
+}
+
+INT RTMPIoctlSetWpapsk(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR			arg[128];
+	UCHAR			keyMaterial[40];
+	INT 			Status = 0;
+
+	if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&\
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&\
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) )
+		return TRUE;	// do nothing
+
+	Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+
+	memset(keyMaterial, 0, 40);
+
+	if ((wrq->u.data.length < 8) || (wrq->u.data.length > 64))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "Set failed!!(WPAPSK=%s), WPAPSK key-string required 8 ~ 64 characters \n", arg);
+		Status = -EINVAL;
+		return (Status);
+	}
+	else if (wrq->u.data.length == 64)
+	{
+		AtoH(arg, keyMaterial, 32);
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+	}
+	else
+	{
+		PasswordHash((char *)arg, pAdapter->MlmeAux.Ssid, pAdapter->MlmeAux.SsidLen, keyMaterial);
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+	}
+
+	RTMPMakeRSNIE(pAdapter, pAdapter->PortCfg.GroupCipher);
+
+	if(pAdapter->PortCfg.BssType == BSS_ADHOC &&\
+	   pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+	{
+		//RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, sizeof(Key));
+		Status = RTMPWPANoneAddKeyProc(pAdapter, &keyMaterial[0]);
+
+		if (Status != NDIS_STATUS_SUCCESS)
+			return -ENOMEM;
+
+		pAdapter->PortCfg.WpaState = SS_NOTUSE;
+	}
+	else	 // Use RaConfig as PSK agent.
+	{
+		// Start STA supplicant state machine
+		pAdapter->PortCfg.WpaState = SS_START;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetWpapsk::(WPAPSK=%s)\n", arg);
+
+	return (Status);
+}
+
+INT RTMPIoctlSetPsm(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	CHAR	 arg[1];
+	INT 	 Status = 0;
+
+	if (wrq->u.data.length != 1)
+	{
+		Status = -EINVAL;
+		return (Status);
+	}
+	else
+	{
+		Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+
+		if (arg[0] == 0)
+		{
+			//Default Ndis802_11PowerModeCAM
+			// clear PSM bit immediately
+			MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+		}
+		else if (arg[0] == 1)
+		{
+			// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+			// to exclude certain situations.
+			//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeMAX_PSP;
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			pAdapter->PortCfg.DefaultListenCount = 5;
+
+		}
+		else if (arg[0] == 2)
+		{
+			// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+			// to exclude certain situations.
+			//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+			OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_RECEIVE_DTIM);
+			if (pAdapter->PortCfg.bWindowsACCAMEnable == FALSE)
+				pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeFast_PSP;
+			pAdapter->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeFast_PSP;
+			pAdapter->PortCfg.DefaultListenCount = 3;
+		}
+		else
+		{
+			Status = -EINVAL;
+			return (Status);
+		}
+	}
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetPsm::(PSMode=%d)\n", pAdapter->PortCfg.WindowsPowerMode);
+	return (Status);
+
+}
+
+VOID RTMPIoctlGetRaAPCfg(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct iwreq	*wrq)
+{
+	pAdapter->PortCfg.bGetAPConfig = TRUE;
+	EnqueueProbeRequest(pAdapter);
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlGetRaAPCfg::(bGetAPConfig=%d)\n", pAdapter->PortCfg.bGetAPConfig);
+	return;
+}
+
+#endif
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_init.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_init.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_init.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,2392 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_init.c
+ *
+ *	Abstract: Miniport generic portion header file
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Lin	2002-08-01	created
+ *	John Chang	2004-08-20	RT2561/2661 use scatter-gather scheme
+ *	Olivier Cornu	2007-05-14	Remove .dat file code
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define RT_USB_ALLOC_URB(iso)	usb_alloc_urb(iso, GFP_ATOMIC);
+#else
+#define RT_USB_ALLOC_URB(iso)	usb_alloc_urb(iso);
+#endif
+
+UCHAR	 BIT8[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
+ULONG	 BIT32[] = {0x00000001, 0x00000002, 0x00000004, 0x00000008,
+					0x00000010, 0x00000020, 0x00000040, 0x00000080,
+					0x00000100, 0x00000200, 0x00000400, 0x00000800,
+					0x00001000, 0x00002000, 0x00004000, 0x00008000,
+					0x00010000, 0x00020000, 0x00040000, 0x00080000,
+					0x00100000, 0x00200000, 0x00400000, 0x00800000,
+					0x01000000, 0x02000000, 0x04000000, 0x08000000,
+					0x10000000, 0x20000000, 0x40000000, 0x80000000};
+
+char*	CipherName[] = {"none","wep64","wep128","TKIP","AES","CKIP64","CKIP128"};
+
+const unsigned short ccitt_16Table[] = {
+	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
+	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
+	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
+	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
+	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
+	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
+	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
+	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
+	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
+	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
+	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
+	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
+	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
+	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
+	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
+	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
+	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
+	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
+	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
+	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
+	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
+	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
+	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
+	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
+	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
+	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
+	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
+	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
+	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
+	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
+	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
+};
+#define ByteCRC16(v, crc) \
+	(unsigned short)((crc << 8) ^  ccitt_16Table[((crc >> 8) ^ (v)) & 255])
+
+
+//
+// BBP register initialization set
+//
+BBP_REG_PAIR   BBPRegTable[] = {
+	{3, 	0x80},
+	{15,	0x30},
+	{17,	0x20},
+	{21,	0xc8},
+	{22,	0x38},
+	{23,	0x06},
+	{24,	0xfe},
+	{25,	0x0a},
+	{26,	0x0d},
+	{32,	0x0b},
+	{34,	0x12},
+	{37,	0x07},
+	{39,	0xf8}, // 2005-09-02 by Gary, Atheros 11b issue
+	{41,	0x60}, // 03-09 gary
+	{53,	0x10}, // 03-09 gary
+	{54,	0x18}, // 03-09 gary
+	{60,	0x10},
+	{61,	0x04},
+	{62,	0x04},
+	{75,	0xfe},
+	{86,	0xfe},
+	{88,	0xfe},
+	{90,	0x0f},
+	{99,	0x00},
+	{102,	0x16},
+	{107,	0x04},
+};
+#define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(BBP_REG_PAIR))
+
+
+//
+// ASIC register initialization sets
+//
+RTMP_REG_PAIR	MACRegTable[] =	{
+	{TXRX_CSR0, 	0x025fb032}, // 0x3040, RX control, default Disable RX
+	{TXRX_CSR1, 	0x9eaa9eaf}, // 0x3044, BBP 30:Ant-A RSSI, R51:Ant-B RSSI, R42:OFDM rate, R47:CCK SIGNAL
+	{TXRX_CSR2, 	0x8a8b8c8d}, // 0x3048, CCK TXD BBP registers
+	{TXRX_CSR3, 	0x00858687}, // 0x304c, OFDM TXD BBP registers
+	{TXRX_CSR7, 	0x2E31353B}, // 0x305c, ACK/CTS payload consume time for 18/12/9/6 mbps
+	{TXRX_CSR8, 	0x2a2a2a2c}, // 0x3060, ACK/CTS payload consume time for 54/48/36/24 mbps
+	{TXRX_CSR15,	0x0000000f}, // 0x307c, TKIP MIC priority byte "AND" mask
+	{MAC_CSR6,		0x00000fff}, // 0x3018, MAX frame length
+	{MAC_CSR8,		0x016c030a}, // 0x3020, SIFS/EIFS time, set SIFS delay time.
+	{MAC_CSR10, 	0x00000718}, // 0x3028, ASIC PIN control in various power states
+	{MAC_CSR12, 	0x00000004}, // 0x3030, power state control, set to AWAKE state
+	{MAC_CSR13, 	0x00007f00}, // 0x3034, GPIO pin#7 as bHwRadio (input:0), otherwise (output:1)
+	{SEC_CSR0,		0x00000000}, // 0x30a0, invalidate all shared key entries
+	{SEC_CSR1,		0x00000000}, // 0x30a4, reset all shared key algorithm to "none"
+	{SEC_CSR5,		0x00000000}, // 0x30b4, reset all shared key algorithm to "none"
+	{PHY_CSR1,		0x000023b0}, // 0x3084, BBP Register R/W mode set to "Parallel mode"
+	{PHY_CSR5,		0x00040a06}, //  0x060a100c
+	{PHY_CSR6,		0x00080606},
+	{PHY_CSR7,		0x00000408},
+	{AIFSN_CSR, 	0x00002273},
+	{CWMIN_CSR, 	0x00002344},
+	{CWMAX_CSR, 	0x000034aa},
+};
+#define	NUM_MAC_REG_PARMS	(sizeof(MACRegTable) / sizeof(RTMP_REG_PAIR))
+
+VOID CreateThreads( struct net_device *net_dev )
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) net_dev->priv;
+
+	// Creat MLME Thread
+	pAd->MLMEThr_pid= -1;
+
+	pAd->MLMEThr_pid = kernel_thread(MlmeThread, pAd, CLONE_VM);
+	if (pAd->MLMEThr_pid < 0) {
+		printk (KERN_WARNING "%s: unable to start mlme thread\n",pAd->net_dev->name);
+	}
+
+	// Creat Command Thread
+	pAd->RTUSBCmdThr_pid= -1;
+
+	pAd->RTUSBCmdThr_pid = kernel_thread(RTUSBCmdThread, pAd, CLONE_VM);
+	if (pAd->RTUSBCmdThr_pid < 0) {
+		printk (KERN_WARNING "%s: unable to start RTUSBCmd thread\n",pAd->net_dev->name);
+	}
+
+	/* Wait for the thread to start */
+	wait_for_completion(&(pAd->notify));
+
+}
+
+NDIS_STATUS NICInitTransmit(
+	IN	PRTMP_ADAPTER	 pAd )
+{
+	UCHAR			i, acidx;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
+	PTX_CONTEXT		pNullContext   = &(pAd->NullContext);
+	PTX_CONTEXT		pRTSContext    = &(pAd->RTSContext);
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitTransmit\n");
+
+	// Init 4 set of Tx parameters
+	for (i = 0; i < 4; i++)
+	{
+		// Initialize all Transmit releated queues
+		skb_queue_head_init(&pAd->SendTxWaitQueue[i]);
+
+		pAd->NextTxIndex[i]			= 0;		// Next Free local Tx ring pointer
+		pAd->TxRingTotalNumber[i]	= 0;
+		pAd->NextBulkOutIndex[i]	= 0;		// Next Local tx ring pointer waiting for buck out
+		pAd->BulkOutPending[i]		= FALSE;	// Buck Out control flag
+	}
+
+	pAd->PrivateInfo.TxRingFullCnt = 0;
+
+	pAd->NextRxBulkInIndex	   = 0;	// Rx Bulk pointer
+	pAd->NextMLMEIndex		   = 0;
+	pAd->PushMgmtIndex		   = 0;
+	pAd->PopMgmtIndex		   = 0;
+	atomic_set(&pAd->MgmtQueueSize, 0);
+
+
+	pAd->PrioRingFirstIndex    = 0;
+	pAd->PrioRingTxCnt		   = 0;
+
+	do
+	{
+		//
+		// TX_RING_SIZE
+		//
+		for (acidx = 0; acidx < 4; acidx++)
+		{
+			for ( i= 0; i < TX_RING_SIZE; i++ )
+			{
+				PTX_CONTEXT pTxContext = &(pAd->TxContext[acidx][i]);
+
+				//Allocate URB
+				pTxContext->pUrb = RT_USB_ALLOC_URB(0);
+				if(pTxContext->pUrb == NULL){
+					Status = NDIS_STATUS_RESOURCES;
+					goto done;
+				}
+				pTxContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+				Status = NDIS_STATUS_SUCCESS;
+				if(!pTxContext->TransferBuffer){
+					DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+					Status = NDIS_STATUS_RESOURCES;
+					goto out1;
+				}
+
+				memset(pTxContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+
+				pTxContext->pAd = pAd;
+				pTxContext->InUse = FALSE;
+				pTxContext->IRPPending = FALSE;
+			}
+		}
+
+
+		//
+		// PRIO_RING_SIZE
+		//
+		for ( i= 0; i < PRIO_RING_SIZE; i++ )
+		{
+			PTX_CONTEXT	pMLMEContext = &(pAd->MLMEContext[i]);
+
+			pMLMEContext->pUrb = RT_USB_ALLOC_URB(0);
+			if(pMLMEContext->pUrb == NULL){
+				Status = NDIS_STATUS_RESOURCES;
+				goto out1;
+			}
+
+			pMLMEContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+			if(!pMLMEContext->TransferBuffer){
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				goto out2;
+			}
+
+			memset(pMLMEContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+			pMLMEContext->pAd = pAd ;
+			pMLMEContext->InUse = FALSE;
+			pMLMEContext->IRPPending = FALSE;
+		}
+
+
+		//
+		// BEACON_RING_SIZE
+		//
+		for (i = 0; i < BEACON_RING_SIZE; i++)
+		{
+			PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
+			pBeaconContext->pUrb = RT_USB_ALLOC_URB(0);
+			if(pBeaconContext->pUrb == NULL){
+				Status = NDIS_STATUS_RESOURCES;
+				goto out2;
+			}
+
+			pBeaconContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+			if(!pBeaconContext->TransferBuffer){
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				goto out3;
+			}
+			memset(pBeaconContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+
+			pBeaconContext->pAd = pAd;
+			pBeaconContext->InUse = FALSE;
+			pBeaconContext->IRPPending = FALSE;
+		}
+
+
+		//
+		// NullContext
+		//
+		pNullContext->pUrb = RT_USB_ALLOC_URB(0);
+		if(pNullContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto out3;
+		}
+
+		pNullContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+		if(!pNullContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto out4;
+		}
+
+		memset(pNullContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+		pNullContext->pAd = pAd;
+		pNullContext->InUse = FALSE;
+		pNullContext->IRPPending = FALSE;
+
+		//
+		// RTSContext
+		//
+		pRTSContext->pUrb = RT_USB_ALLOC_URB(0);
+		if(pRTSContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto out4;
+		}
+
+		pRTSContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+		if(!pRTSContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto out5;
+		}
+
+		memset(pRTSContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+		pRTSContext->pAd = pAd;
+		pRTSContext->InUse = FALSE;
+		pRTSContext->IRPPending = FALSE;
+
+
+		//
+		// PsPollContext
+		//
+		pPsPollContext->pUrb = RT_USB_ALLOC_URB(0);
+		if(pPsPollContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto out5;
+		}
+
+		pPsPollContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+		if(!pPsPollContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto out6;
+		}
+
+		memset(pPsPollContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+		pPsPollContext->pAd = pAd;
+		pPsPollContext->InUse = FALSE;
+		pPsPollContext->IRPPending = FALSE;
+
+	}  while (FALSE);
+
+	return Status;
+
+
+out6:
+	if (NULL != pPsPollContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pPsPollContext->pUrb);
+		usb_free_urb(pPsPollContext->pUrb);
+		pPsPollContext->pUrb = NULL;
+	}
+	if (NULL != pPsPollContext->TransferBuffer)
+	{
+		kfree(pPsPollContext->TransferBuffer);
+		pPsPollContext->TransferBuffer = NULL;
+	}
+out5:
+	if (NULL != pRTSContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pRTSContext->pUrb);
+		usb_free_urb(pRTSContext->pUrb);
+		pRTSContext->pUrb = NULL;
+	}
+	if (NULL != pRTSContext->TransferBuffer)
+	{
+		kfree(pRTSContext->TransferBuffer);
+		pRTSContext->TransferBuffer = NULL;
+	}
+out4:
+	if (NULL != pNullContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pNullContext->pUrb);
+		usb_free_urb(pNullContext->pUrb);
+		pNullContext->pUrb = NULL;
+	}
+	if (NULL != pNullContext->TransferBuffer)
+	{
+		kfree(pNullContext->TransferBuffer);
+		pNullContext->TransferBuffer = NULL;
+	}
+out3:
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
+		if ( NULL != pBeaconContext->pUrb )
+		{
+			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
+			usb_free_urb(pBeaconContext->pUrb);
+			pBeaconContext->pUrb = NULL;
+		}
+
+		if ( NULL != pBeaconContext->TransferBuffer )
+		{
+			kfree( pBeaconContext->TransferBuffer);
+			pBeaconContext->TransferBuffer = NULL;
+		}
+	}
+out2:
+	for ( i= 0; i < PRIO_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pMLMEContext = &(pAd->MLMEContext[i]);
+
+		if ( NULL != pMLMEContext->pUrb )
+		{
+			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
+			usb_free_urb(pMLMEContext->pUrb);
+			pMLMEContext->pUrb = NULL;
+		}
+
+		if ( NULL != pMLMEContext->TransferBuffer )
+		{
+			kfree( pMLMEContext->TransferBuffer);
+			pMLMEContext->TransferBuffer = NULL;
+		}
+	}
+out1:
+	for (acidx = 0; acidx < 4; acidx++)
+	{
+		for ( i= 0; i < TX_RING_SIZE; i++ )
+		{
+			PTX_CONTEXT pTxContext = &(pAd->TxContext[acidx][i]);
+
+			if ( NULL != pTxContext->pUrb )
+			{
+				RTUSB_UNLINK_URB(pTxContext->pUrb);
+				usb_free_urb(pTxContext->pUrb);
+				pTxContext->pUrb = NULL;
+			}
+			if ( NULL != pTxContext->TransferBuffer )
+			{
+				kfree( pTxContext->TransferBuffer);
+				pTxContext->TransferBuffer = NULL;
+			}
+		}
+	}
+
+done:
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Initialize receive data structures
+
+	Arguments:
+		Adapter 					Pointer to our adapter
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_RESOURCES
+
+	Note:
+		Initialize all receive releated private buffer, include those define
+		in RTMP_ADAPTER structure and all private data structures. The mahor
+		work is to allocate buffer for each packet and chain buffer to
+		NDIS packet descriptor.
+
+	========================================================================
+*/
+NDIS_STATUS NICInitRecv(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	UCHAR	i;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitRecv\n");
+	pAd->NextRxBulkInIndex = 0;
+	atomic_set( &pAd->PendingRx, 0);
+	for (i = 0; i < RX_RING_SIZE; i++)
+	{
+		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+		pRxContext->pUrb = RT_USB_ALLOC_URB(0);
+		if(pRxContext->pUrb == NULL)
+		{
+			Status = NDIS_STATUS_RESOURCES;
+			DBGPRINT(RT_DEBUG_TRACE,"--> pRxContext->pUrb == NULL\n");
+			break;
+		}
+
+		pRxContext->TransferBuffer= (PUCHAR) kmalloc(BUFFER_SIZE, MEM_ALLOC_FLAG);
+		if(!pRxContext->TransferBuffer)
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			break;
+		}
+
+		memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
+
+		pRxContext->pAd	= pAd;
+		pRxContext->InUse = FALSE;
+		pRxContext->IRPPending	= FALSE;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitRecv\n");
+	return Status;
+}
+
+////////////////////////////////////////////////////////////////////////////
+//
+//	FUNCTION
+//		ReleaseAdapter
+//
+//	DESCRIPTION
+//		Calls USB_InterfaceStop and frees memory allocated for the URBs
+//		calls NdisMDeregisterDevice and frees the memory
+//		allocated in VNetInitialize for the Adapter Object
+//
+//	INPUT
+//		Adapter 	Pointer to RTMP_ADAPTER structure
+//
+//	OUTPUT
+//		-
+//
+////////////////////////////////////////////////////////////////////////////
+VOID ReleaseAdapter(
+	IN	PRTMP_ADAPTER pAd,
+    IN  BOOLEAN         IsFree,
+	IN  BOOLEAN         IsOnlyTx)
+{
+	UINT			i, acidx;
+	PTX_CONTEXT		pNullContext   = &pAd->NullContext;
+	PTX_CONTEXT		pPsPollContext = &pAd->PsPollContext;
+	PTX_CONTEXT 	pRTSContext    = &pAd->RTSContext;
+
+	DBGPRINT(RT_DEBUG_TRACE, "---> ReleaseAdapter\n");
+
+    if (!IsOnlyTx)
+    {
+	    // Free all resources for the RECEIVE buffer queue.
+	    for (i = 0; i < RX_RING_SIZE; i++)
+	    {
+		    PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+
+		    if (pRxContext->pUrb != NULL)
+		    {
+			    RTUSB_UNLINK_URB(pRxContext->pUrb);
+			    if (IsFree)
+			    usb_free_urb(pRxContext->pUrb);
+			    pRxContext->pUrb = NULL;
+		    }
+		    if (pRxContext->TransferBuffer != NULL)
+		    {
+			    kfree(pRxContext->TransferBuffer);
+			    pRxContext->TransferBuffer = NULL;
+		    }
+
+	    }
+    }
+
+	// Free PsPoll frame resource
+	if (NULL != pPsPollContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pPsPollContext->pUrb);
+		if (IsFree)
+		usb_free_urb(pPsPollContext->pUrb);
+		pPsPollContext->pUrb = NULL;
+	}
+	if (NULL != pPsPollContext->TransferBuffer)
+	{
+		kfree(pPsPollContext->TransferBuffer);
+		pPsPollContext->TransferBuffer = NULL;
+	}
+
+	// Free NULL frame resource
+	if (NULL != pNullContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pNullContext->pUrb);
+		if (IsFree)
+		usb_free_urb(pNullContext->pUrb);
+		pNullContext->pUrb = NULL;
+	}
+	if (NULL != pNullContext->TransferBuffer)
+	{
+		kfree(pNullContext->TransferBuffer);
+		pNullContext->TransferBuffer = NULL;
+	}
+
+	// Free RTS frame resource
+	if (NULL != pRTSContext->pUrb)
+	{
+		RTUSB_UNLINK_URB(pRTSContext->pUrb);
+		if (IsFree)
+		usb_free_urb(pRTSContext->pUrb);
+		pRTSContext->pUrb = NULL;
+	}
+	if (NULL != pRTSContext->TransferBuffer)
+	{
+		kfree(pRTSContext->TransferBuffer);
+		pRTSContext->TransferBuffer = NULL;
+	}
+
+	// Free beacon frame resource
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
+		if ( NULL != pBeaconContext->pUrb )
+		{
+			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pBeaconContext->pUrb);
+			pBeaconContext->pUrb = NULL;
+		}
+
+		if ( NULL != pBeaconContext->TransferBuffer )
+		{
+			kfree( pBeaconContext->TransferBuffer);
+			pBeaconContext->TransferBuffer = NULL;
+		}
+	}
+
+	// Free Prio frame resource
+	for ( i= 0; i < PRIO_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pMLMEContext = &(pAd->MLMEContext[i]);
+
+		if ( NULL != pMLMEContext->pUrb )
+		{
+			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pMLMEContext->pUrb);
+			pMLMEContext->pUrb = NULL;
+		}
+
+		if ( NULL != pMLMEContext->TransferBuffer )
+		{
+			kfree( pMLMEContext->TransferBuffer);
+			pMLMEContext->TransferBuffer = NULL;
+		}
+	}
+
+	// Free Tx frame resource
+	for (acidx = 0; acidx < 4; acidx++)
+	{
+		for ( i= 0; i < TX_RING_SIZE; i++ )
+		{
+			PTX_CONTEXT pTxContext = &(pAd->TxContext[acidx][i]);
+
+			if ( NULL != pTxContext->pUrb )
+			{
+				RTUSB_UNLINK_URB(pTxContext->pUrb);
+				if (IsFree)
+				usb_free_urb(pTxContext->pUrb);
+				pTxContext->pUrb = NULL;
+			}
+
+			if ( NULL != pTxContext->TransferBuffer )
+			{
+				kfree( pTxContext->TransferBuffer);
+				pTxContext->TransferBuffer = NULL;
+			}
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "<--- ReleaseAdapter\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Allocate DMA memory blocks for send, receive
+
+	Arguments:
+		Adapter		Pointer to our adapter
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_RESOURCES
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPInitAdapterBlock(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NDIS_STATUS		Status=NDIS_STATUS_SUCCESS;
+	UINT			i;
+	PCmdQElmt		cmdqelmt;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> RTMPInitAdapterBlock\n");
+
+	// init counter
+	pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart =  0;
+	pAd->WlanCounters.MulticastTransmittedFrameCount.vv.LowPart =0;
+	pAd->WlanCounters.FailedCount.vv.LowPart =0;
+	pAd->WlanCounters.NoRetryCount.vv.LowPart =0;
+	pAd->WlanCounters.RetryCount.vv.LowPart =0;
+	pAd->WlanCounters.MultipleRetryCount.vv.LowPart =0;
+	pAd->WlanCounters.RTSSuccessCount.vv.LowPart =0;
+	pAd->WlanCounters.RTSFailureCount.vv.LowPart =0;
+	pAd->WlanCounters.ACKFailureCount.vv.LowPart =0;
+	pAd->WlanCounters.FrameDuplicateCount.vv.LowPart =0;
+	pAd->WlanCounters.ReceivedFragmentCount.vv.LowPart =0;
+	pAd->WlanCounters.MulticastReceivedFrameCount.vv.LowPart =0;
+	pAd->WlanCounters.FCSErrorCount.vv.LowPart =0;
+
+	pAd->WlanCounters.TransmittedFragmentCount.vv.HighPart =  0;
+	pAd->WlanCounters.MulticastTransmittedFrameCount.vv.HighPart =0;
+	pAd->WlanCounters.FailedCount.vv.HighPart =0;
+	pAd->WlanCounters.NoRetryCount.vv.HighPart =0;
+	pAd->WlanCounters.RetryCount.vv.HighPart =0;
+	pAd->WlanCounters.MultipleRetryCount.vv.HighPart =0;
+	pAd->WlanCounters.RTSSuccessCount.vv.HighPart =0;
+	pAd->WlanCounters.RTSFailureCount.vv.HighPart =0;
+	pAd->WlanCounters.ACKFailureCount.vv.HighPart =0;
+	pAd->WlanCounters.FrameDuplicateCount.vv.HighPart =0;
+	pAd->WlanCounters.ReceivedFragmentCount.vv.HighPart =0;
+	pAd->WlanCounters.MulticastReceivedFrameCount.vv.HighPart =0;
+	pAd->WlanCounters.FCSErrorCount.vv.HighPart =0;
+
+	do
+	{
+		for (i = 0; i < COMMAND_QUEUE_SIZE; i++)
+		{
+			cmdqelmt = &(pAd->CmdQElements[i]);
+			memset(cmdqelmt, 0, sizeof(CmdQElmt));
+			cmdqelmt->buffer = NULL;
+			cmdqelmt->CmdFromNdis = FALSE;
+			cmdqelmt->InUse = FALSE;
+		}
+		RTUSBInitializeCmdQ(&pAd->CmdQ);
+
+		init_MUTEX(&(pAd->usbdev_semaphore));
+		init_MUTEX(&(pAd->mlme_semaphore));
+		down(&pAd->mlme_semaphore);
+		init_MUTEX(&(pAd->RTUSBCmd_semaphore));
+		down(&pAd->RTUSBCmd_semaphore);
+
+		init_completion (&pAd->notify); 	// event initially non-signalled
+
+		////////////////////////
+		// Spinlock
+		NdisAllocateSpinLock(&pAd->MLMEQLock);
+		NdisAllocateSpinLock(&pAd->BulkOutLock[0]);
+		NdisAllocateSpinLock(&pAd->BulkOutLock[1]);
+		NdisAllocateSpinLock(&pAd->BulkOutLock[2]);
+		NdisAllocateSpinLock(&pAd->BulkOutLock[3]);
+		NdisAllocateSpinLock(&pAd->CmdQLock);
+		NdisAllocateSpinLock(&pAd->SendTxWaitQueueLock[0]);
+		NdisAllocateSpinLock(&pAd->SendTxWaitQueueLock[1]);
+		NdisAllocateSpinLock(&pAd->SendTxWaitQueueLock[2]);
+		NdisAllocateSpinLock(&pAd->SendTxWaitQueueLock[3]);
+		NdisAllocateSpinLock(&pAd->DeQueueLock[0]);
+		NdisAllocateSpinLock(&pAd->DeQueueLock[1]);
+		NdisAllocateSpinLock(&pAd->DeQueueLock[2]);
+		NdisAllocateSpinLock(&pAd->DeQueueLock[3]);
+		NdisAllocateSpinLock(&pAd->DataQLock[0]);
+		NdisAllocateSpinLock(&pAd->DataQLock[1]);
+		NdisAllocateSpinLock(&pAd->DataQLock[2]);
+		NdisAllocateSpinLock(&pAd->DataQLock[3]);
+
+		NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock);
+
+	}	while (FALSE);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- RTMPInitAdapterBlock\n");
+
+	return Status;
+}
+
+NDIS_STATUS	RTUSBWriteHWMACAddress(
+	IN	PRTMP_ADAPTER		pAd)
+{
+	MAC_CSR2_STRUC		StaMacReg0;
+	MAC_CSR3_STRUC		StaMacReg1;
+	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
+	PUCHAR			curMAC;
+	int			t;
+
+	if (pAd->bLocalAdminMAC != TRUE)
+	{
+		if (!memcmp(pAd->net_dev->dev_addr, "\x00\x00\x00\x00\x00\x00", 6)) {
+			printk(KERN_INFO "***rt73***: Interface goes up for the first time, activating permanent MAC\n");
+			curMAC = pAd->PermanentAddress;
+		} else {
+			printk(KERN_INFO "***rt73***: net_device supplies MAC, activating this one\n");
+			curMAC = pAd->net_dev->dev_addr;
+		}
+
+		printk(KERN_INFO "***rt73***: Active MAC is: %02x:%02x:%02x:%02x:%02x:%02x.\n", curMAC[0], curMAC[1], curMAC[2], curMAC[3], curMAC[4], curMAC[5]);
+		for (t=0; t<6; t++) pAd->CurrentAddress[t] = curMAC[t];
+	}
+
+	// Write New MAC address to MAC_CSR2 & MAC_CSR3 & let ASIC know our new MAC
+	StaMacReg0.field.Byte0 = pAd->CurrentAddress[0];
+	StaMacReg0.field.Byte1 = pAd->CurrentAddress[1];
+	StaMacReg0.field.Byte2 = pAd->CurrentAddress[2];
+	StaMacReg0.field.Byte3 = pAd->CurrentAddress[3];
+	StaMacReg1.field.Byte4 = pAd->CurrentAddress[4];
+	StaMacReg1.field.Byte5 = pAd->CurrentAddress[5];
+	StaMacReg1.field.U2MeMask = 0xff;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
+			pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]);
+
+	RTUSBWriteMACRegister(pAd, MAC_CSR2, StaMacReg0.word);
+	RTUSBWriteMACRegister(pAd, MAC_CSR3, StaMacReg1.word);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Read initial parameters from EEPROM
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID NICReadEEPROMParameters(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	USHORT  i, value2;
+	USHORT  *value = kzalloc(sizeof(USHORT), GFP_KERNEL);
+	EEPROM_ANTENNA_STRUC	Antenna;
+	EEPROM_VERSION_STRUC  *Version = kzalloc(sizeof(EEPROM_VERSION_STRUC), GFP_KERNEL);
+	CHAR *ChannelTxPower = kzalloc(sizeof(CHAR)*MAX_NUM_OF_CHANNELS, GFP_KERNEL);
+	EEPROM_LED_STRUC *LedSetting = kzalloc(sizeof(EEPROM_LED_STRUC), GFP_KERNEL);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> NICReadEEPROMParameters\n");
+
+	if(!value || !Version || !ChannelTxPower || !LedSetting) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+	//Read MAC address.
+	RTUSBReadEEPROM(pAd, EEPROM_MAC_ADDRESS_BASE_OFFSET, pAd->PermanentAddress, MAC_ADDR_LEN);
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			pAd->PermanentAddress[0], pAd->PermanentAddress[1], pAd->PermanentAddress[2],
+			pAd->PermanentAddress[3], pAd->PermanentAddress[4], pAd->PermanentAddress[5]);
+
+	// Init the channel number for TX channel power
+	// 0. 11b/g
+	for (i = 0; i < 14; i++)
+		pAd->TxPower[i].Channel = i + 1;
+	// 1. UNI 36 - 64
+	for (i = 0; i < 8; i++)
+		pAd->TxPower[i + 14].Channel = 36 + i * 4;
+	// 2. HipperLAN 2 100 - 140
+	for (i = 0; i < 11; i++)
+		pAd->TxPower[i + 22].Channel = 100 + i * 4;
+	// 3. UNI 140 - 165
+	for (i = 0; i < 5; i++)
+		pAd->TxPower[i + 33].Channel = 149 + i * 4;
+
+	// 34/38/42/46
+	for (i = 0; i < 4; i++)
+		pAd->TxPower[i + 38].Channel = 34 + i * 4;
+
+	// if E2PROM version mismatch with driver's expectation, then skip
+	// all subsequent E2RPOM retieval and set a system error bit to notify GUI
+	RTUSBReadEEPROM(pAd, EEPROM_VERSION_OFFSET, (PUCHAR)&Version->word, 2);
+	pAd->EepromVersion = Version->field.Version + Version->field.FaeReleaseNumber * 256;
+	DBGPRINT(RT_DEBUG_TRACE, "E2PROM: Version = %d, FAE release #%d\n", Version->field.Version, Version->field.FaeReleaseNumber);
+	// Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd
+	RTUSBReadEEPROM(pAd, EEPROM_BBP_BASE_OFFSET, (PUCHAR)(pAd->EEPROMDefaultValue), 2 * NUM_EEPROM_BBP_PARMS);
+
+	// We have to parse NIC configuration 0 at here.
+	// If TSSI did not have preloaded value, it should reset the TxAutoAgc to false
+	// Therefore, we have to read TxAutoAgc control beforehand.
+	// Read Tx AGC control bit
+	Antenna.word = pAd->EEPROMDefaultValue[0];
+	if (Antenna.field.DynamicTxAgcControl == 1)
+		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
+	else
+		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
+
+	//
+	// Reset PhyMode if we don't support 802.11a
+	//
+	if ((pAd->PortCfg.PhyMode == PHY_11ABG_MIXED) || (pAd->PortCfg.PhyMode == PHY_11A))
+	{
+		//
+		// Only RFIC_5226, RFIC_5225 suport 11a
+		//
+		if ((Antenna.field.RfIcType == RFIC_2528) || (Antenna.field.RfIcType == RFIC_2527))
+			pAd->PortCfg.PhyMode = PHY_11BG_MIXED;
+
+		//
+		// Reset Adhoc Mode if we don't support 802.11a
+		//
+		if ((pAd->PortCfg.AdhocMode == ADHOC_11A) || (pAd->PortCfg.AdhocMode == ADHOC_11ABG_MIXED))
+		{
+			//
+			// Only RFIC_5226, RFIC_5225 suport 11a
+			//
+			if ((Antenna.field.RfIcType == RFIC_2528) || (Antenna.field.RfIcType == RFIC_2527))
+				pAd->PortCfg.AdhocMode = ADHOC_11BG_MIXED;
+		}
+
+    }
+
+
+	// Read Tx power value for all 14 channels
+	// Value from 1 - 0x7f. Default value is 24.
+	// 0. 11b/g
+	// Power value 0xFA (-6) ~ 0x24 (36)
+	RTUSBReadEEPROM(pAd, EEPROM_G_TX_PWR_OFFSET, ChannelTxPower, 2 * NUM_EEPROM_TX_G_PARMS);
+	for (i = 0; i < 2 * NUM_EEPROM_TX_G_PARMS; i++)
+	{
+		if ((ChannelTxPower[i] > 36) || (ChannelTxPower[i] < -6))
+			pAd->TxPower[i].Power = 24;
+		else
+			pAd->TxPower[i].Power = ChannelTxPower[i];
+
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[i].Channel, pAd->TxPower[i].Power);
+	}
+
+	// 1. UNI 36 - 64, HipperLAN 2 100 - 140, UNI 140 - 165
+	// Power value 0xFA (-6) ~ 0x24 (36)
+	RTUSBReadEEPROM(pAd, EEPROM_A_TX_PWR_OFFSET, ChannelTxPower, MAX_NUM_OF_A_CHANNELS);
+	for (i = 0; i < MAX_NUM_OF_A_CHANNELS; i++)
+	{
+		if ((ChannelTxPower[i] > 36) || (ChannelTxPower[i] < -6))
+			pAd->TxPower[i + 14].Power = 24;
+		else
+			pAd->TxPower[i + 14].Power = ChannelTxPower[i];
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[i + 14].Channel, pAd->TxPower[i + 14].Power);
+	}
+
+	//
+	// Please note, we must skip frist value, so we get TxPower as ChannelTxPower[i + 1];
+	// because the TxPower was stored from 0x7D, but we need to read EEPROM from 0x7C. (Word alignment)
+	//
+	// for J52, 34/38/42/46
+	RTUSBReadEEPROM(pAd, EEPROM_J52_TX_PWR_OFFSET, ChannelTxPower, 6); //must Read even valuse
+
+	for (i = 0; i < 4; i++)
+	{
+		ASSERT(pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Channel == 34 + i * 4);
+		if ((ChannelTxPower[i] > 36) || (ChannelTxPower[i] < -6))
+			pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power = 24;
+		else
+			pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power = ChannelTxPower[i + 1];
+
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Channel, pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power);
+	}
+
+	// Read TSSI reference and TSSI boundary for temperature compensation.
+	// 0. 11b/g
+	{
+		RTUSBReadEEPROM(pAd, EEPROM_BG_TSSI_CALIBRAION, ChannelTxPower, 10);
+		pAd->TssiMinusBoundaryG[4] = ChannelTxPower[0];
+		pAd->TssiMinusBoundaryG[3] = ChannelTxPower[1];
+		pAd->TssiMinusBoundaryG[2] = ChannelTxPower[2];
+		pAd->TssiMinusBoundaryG[1] = ChannelTxPower[3];
+		pAd->TssiPlusBoundaryG[1] = ChannelTxPower[4];
+		pAd->TssiPlusBoundaryG[2] = ChannelTxPower[5];
+		pAd->TssiPlusBoundaryG[3] = ChannelTxPower[6];
+		pAd->TssiPlusBoundaryG[4] = ChannelTxPower[7];
+		pAd->TssiRefG	= ChannelTxPower[8];
+		pAd->TxAgcStepG = ChannelTxPower[9];
+		pAd->TxAgcCompensateG = 0;
+		pAd->TssiMinusBoundaryG[0] = pAd->TssiRefG;
+		pAd->TssiPlusBoundaryG[0]  = pAd->TssiRefG;
+
+		// Disable TxAgc if the based value is not right
+		if (pAd->TssiRefG == 0xff)
+			pAd->bAutoTxAgcG = FALSE;
+
+		DBGPRINT(RT_DEBUG_TRACE,"E2PROM: G Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
+			pAd->TssiMinusBoundaryG[4], pAd->TssiMinusBoundaryG[3], pAd->TssiMinusBoundaryG[2], pAd->TssiMinusBoundaryG[1],
+			pAd->TssiRefG,
+			pAd->TssiPlusBoundaryG[1], pAd->TssiPlusBoundaryG[2], pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
+			pAd->TxAgcStepG, pAd->bAutoTxAgcG);
+	}
+	// 1. 11a
+	{
+		RTUSBReadEEPROM(pAd, EEPROM_A_TSSI_CALIBRAION, ChannelTxPower, 10);
+		pAd->TssiMinusBoundaryA[4] = ChannelTxPower[0];
+		pAd->TssiMinusBoundaryA[3] = ChannelTxPower[1];
+		pAd->TssiMinusBoundaryA[2] = ChannelTxPower[2];
+		pAd->TssiMinusBoundaryA[1] = ChannelTxPower[3];
+		pAd->TssiPlusBoundaryA[1] = ChannelTxPower[4];
+		pAd->TssiPlusBoundaryA[2] = ChannelTxPower[5];
+		pAd->TssiPlusBoundaryA[3] = ChannelTxPower[6];
+		pAd->TssiPlusBoundaryA[4] = ChannelTxPower[7];
+		pAd->TssiRefA	= ChannelTxPower[8];
+		pAd->TxAgcStepA = ChannelTxPower[9];
+		pAd->TxAgcCompensateA = 0;
+		pAd->TssiMinusBoundaryA[0] = pAd->TssiRefA;
+		pAd->TssiPlusBoundaryA[0]  = pAd->TssiRefA;
+
+		// Disable TxAgc if the based value is not right
+		if (pAd->TssiRefA == 0xff)
+			pAd->bAutoTxAgcA = FALSE;
+
+		DBGPRINT(RT_DEBUG_TRACE,"E2PROM: A Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
+			pAd->TssiMinusBoundaryA[4], pAd->TssiMinusBoundaryA[3], pAd->TssiMinusBoundaryA[2], pAd->TssiMinusBoundaryA[1],
+			pAd->TssiRefA,
+			pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2], pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
+			pAd->TxAgcStepA, pAd->bAutoTxAgcA);
+	}
+
+	pAd->BbpRssiToDbmDelta = 0x79;
+	RTUSBReadEEPROM(pAd, EEPROM_FREQ_OFFSET, (PUCHAR)value, 2);
+	if ((*value & 0xFF00) == 0xFF00)
+	{
+		pAd->RFProgSeq = 0;
+	}
+	else
+	{
+		pAd->RFProgSeq = (*value & 0x0300) >> 8;  // bit 8,9
+	}
+
+	*value &= 0x00FF;
+	if (*value != 0x00FF)
+		pAd->RfFreqOffset = (ULONG) *value;
+	else
+		pAd->RfFreqOffset = 0;
+	DBGPRINT(RT_DEBUG_TRACE, "E2PROM: RF freq offset=0x%x\n", pAd->RfFreqOffset);
+
+	//CountryRegion byte offset = 0x25
+	*value = pAd->EEPROMDefaultValue[2] >> 8;
+	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;
+    if ((*value <= REGION_MAXIMUM_BG_BAND) && (value2 <= REGION_MAXIMUM_A_BAND))
+	{
+		pAd->PortCfg.CountryRegion = ((UCHAR) *value) | 0x80;
+		pAd->PortCfg.CountryRegionForABand = ((UCHAR) value2) | 0x80;
+	}
+
+	//
+	// Get RSSI Offset on EEPROM 0x9Ah & 0x9Ch.
+	// The valid value are (-10 ~ 10)
+	//
+	RTUSBReadEEPROM(pAd, EEPROM_RSSI_BG_OFFSET, (PUCHAR)value, 2);
+	pAd->BGRssiOffset1 = *value & 0x00ff;
+	pAd->BGRssiOffset2 = (*value >> 8);
+	// Validate 11b/g RSSI_1 offset.
+	if ((pAd->BGRssiOffset1 < -10) || (pAd->BGRssiOffset1 > 10))
+		pAd->BGRssiOffset1 = 0;
+
+	// Validate 11b/g RSSI_2 offset.
+	if ((pAd->BGRssiOffset2 < -10) || (pAd->BGRssiOffset2 > 10))
+		pAd->BGRssiOffset2 = 0;
+
+	RTUSBReadEEPROM(pAd, EEPROM_RSSI_A_OFFSET, (PUCHAR)value, 2);
+	pAd->ARssiOffset1 = *value & 0x00ff;
+	pAd->ARssiOffset2 = (*value >> 8);
+
+	// Validate 11a RSSI_1 offset.
+	if ((pAd->ARssiOffset1 < -10) || (pAd->ARssiOffset1 > 10))
+		pAd->ARssiOffset1 = 0;
+
+	//Validate 11a RSSI_2 offset.
+	if ((pAd->ARssiOffset2 < -10) || (pAd->ARssiOffset2 > 10))
+		pAd->ARssiOffset2 = 0;
+
+	//
+	// Get LED Setting.
+	//
+	RTUSBReadEEPROM(pAd, EEPROM_LED_OFFSET, (PUCHAR)&LedSetting->word, 2);
+	if (LedSetting->word == 0xFFFF)
+	{
+		//
+		// Set it to Default.
+		//
+		LedSetting->field.PolarityRDY_G = 0;   // Active High.
+		LedSetting->field.PolarityRDY_A = 0;   // Active High.
+		LedSetting->field.PolarityACT = 0;   // Active High.
+		LedSetting->field.PolarityGPIO_0 = 0; // Active High.
+		LedSetting->field.PolarityGPIO_1 = 0; // Active High.
+		LedSetting->field.PolarityGPIO_2 = 0; // Active High.
+		LedSetting->field.PolarityGPIO_3 = 0; // Active High.
+		LedSetting->field.PolarityGPIO_4 = 0; // Active High.
+		LedSetting->field.LedMode = LED_MODE_DEFAULT;
+	}
+	pAd->LedCntl.word = 0;
+	pAd->LedCntl.field.LedMode = LedSetting->field.LedMode;
+	pAd->LedCntl.field.PolarityRDY_G = LedSetting->field.PolarityRDY_G;
+	pAd->LedCntl.field.PolarityRDY_A = LedSetting->field.PolarityRDY_A;
+	pAd->LedCntl.field.PolarityACT = LedSetting->field.PolarityACT;
+	pAd->LedCntl.field.PolarityGPIO_0 = LedSetting->field.PolarityGPIO_0;
+	pAd->LedCntl.field.PolarityGPIO_1 = LedSetting->field.PolarityGPIO_1;
+	pAd->LedCntl.field.PolarityGPIO_2 = LedSetting->field.PolarityGPIO_2;
+	pAd->LedCntl.field.PolarityGPIO_3 = LedSetting->field.PolarityGPIO_3;
+	pAd->LedCntl.field.PolarityGPIO_4 = LedSetting->field.PolarityGPIO_4;
+
+	RTUSBReadEEPROM(pAd, EEPROM_TXPOWER_DELTA_OFFSET, (PUCHAR)value, 2);
+	*value = *value & 0x00ff;
+	if (*value != 0xff)
+	{
+		pAd->TxPowerDeltaConfig.value = (UCHAR) *value;
+		if (pAd->TxPowerDeltaConfig.field.DeltaValue > 0x04)
+			pAd->TxPowerDeltaConfig.field.DeltaValue = 0x04;
+	}
+	else
+		pAd->TxPowerDeltaConfig.field.TxPowerEnable = FALSE;
+
+	kfree(Version);
+	kfree(ChannelTxPower);
+	kfree(value);
+	kfree(LedSetting);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- NICReadEEPROMParameters\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Set default value from EEPROM
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID NICInitAsicFromEEPROM(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	ULONG					data;
+	USHORT					i;
+	ULONG					MiscMode;
+	EEPROM_ANTENNA_STRUC	Antenna;
+	EEPROM_NIC_CONFIG2_STRUC	NicConfig2;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> NICInitAsicFromEEPROM\n");
+
+	for(i = 3; i < NUM_EEPROM_BBP_PARMS; i++)
+	{
+		UCHAR BbpRegIdx, BbpValue;
+
+		if ((pAd->EEPROMDefaultValue[i] != 0xFFFF) && (pAd->EEPROMDefaultValue[i] != 0))
+		{
+			BbpRegIdx = (UCHAR)(pAd->EEPROMDefaultValue[i] >> 8);
+			BbpValue  = (UCHAR)(pAd->EEPROMDefaultValue[i] & 0xff);
+			RTUSBWriteBBPRegister(pAd, BbpRegIdx, BbpValue);
+		}
+	}
+
+	Antenna.word = pAd->EEPROMDefaultValue[0];
+
+	if (Antenna.word == 0xFFFF)
+	{
+		Antenna.word = 0;
+		Antenna.field.RfIcType = RFIC_5226;
+		Antenna.field.HardwareRadioControl = 0; 	// no hardware control
+		Antenna.field.DynamicTxAgcControl = 0;
+		Antenna.field.FrameType = 0;
+		Antenna.field.RxDefaultAntenna = 2; 		// Ant-B
+		Antenna.field.TxDefaultAntenna = 2; 		// Ant-B
+		Antenna.field.NumOfAntenna = 2;
+		DBGPRINT(RT_DEBUG_WARN, "E2PROM error, hard code as 0x%04x\n", Antenna.word);
+	}
+
+	pAd->RfIcType = (UCHAR) Antenna.field.RfIcType;
+	DBGPRINT(RT_DEBUG_WARN, "pAd->RfIcType = %d\n", pAd->RfIcType);
+
+	//
+	// For RFIC RFIC_5225 & RFIC_2527
+	// Must enable RF RPI mode on PHY_CSR1 bit 16.
+	//
+	if ((pAd->RfIcType == RFIC_5225) || (pAd->RfIcType == RFIC_2527))
+	{
+		RTUSBReadMACRegister(pAd, PHY_CSR1, &MiscMode);
+		MiscMode |= 0x10000;
+		RTUSBWriteMACRegister(pAd, PHY_CSR1, MiscMode);
+	}
+
+	// Save the antenna for future use
+	pAd->Antenna.word = Antenna.word;
+
+	// Read Hardware controlled Radio state enable bit
+	if (Antenna.field.HardwareRadioControl == 1)
+	{
+		pAd->PortCfg.bHardwareRadio = TRUE;
+
+		// Read GPIO pin7 as Hardware controlled radio state
+		RTUSBReadMACRegister(pAd, MAC_CSR13, &data);
+
+		//
+		// The GPIO pin7 default is 1:Pull-High, means HW Radio Enable.
+		// When the value is 0, means HW Radio disable.
+		//
+		if ((data & 0x80) == 0)
+		{
+			pAd->PortCfg.bHwRadio = FALSE;
+			// Update extra information to link is up
+			pAd->ExtraInfo = HW_RADIO_OFF;
+		}
+	}
+	else
+		pAd->PortCfg.bHardwareRadio = FALSE;
+
+	pAd->PortCfg.bRadio = pAd->PortCfg.bSwRadio && pAd->PortCfg.bHwRadio;
+
+	if (pAd->PortCfg.bRadio == FALSE)
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR10, 0x00001818);
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+
+		RTMPSetLED(pAd, LED_RADIO_OFF);
+	}
+	else
+	{
+		RTMPSetLED(pAd, LED_RADIO_ON);
+	}
+
+	NicConfig2.word = pAd->EEPROMDefaultValue[1];
+	if (NicConfig2.word == 0xffff)
+	{
+		NicConfig2.word = 0;
+	}
+	// Save the antenna for future use
+	pAd->NicConfig2.word = NicConfig2.word;
+
+	DBGPRINT(RT_DEBUG_TRACE, "Use Hw Radio Control Pin=%d; if used Pin=%d;\n",
+		pAd->PortCfg.bHardwareRadio, pAd->PortCfg.bHardwareRadio);
+
+	DBGPRINT(RT_DEBUG_TRACE, "RFIC=%d, LED mode=%d\n", pAd->RfIcType, pAd->LedCntl.field.LedMode);
+
+	pAd->PortCfg.BandState = UNKNOWN_BAND;
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- NICInitAsicFromEEPROM\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Initialize NIC hardware
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	NICInitializeAsic(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	ULONG     Index;
+	ULONG *Counter = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	UCHAR *Value = kzalloc(sizeof(UCHAR), GFP_KERNEL);
+	ULONG *Version = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	MAC_CSR12_STRUC *MacCsr12 = kzalloc(sizeof(MAC_CSR12_STRUC), GFP_KERNEL);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> NICInitializeAsic\n");
+
+	if(!Counter || !Value || !Version || !MacCsr12) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+
+	*Value = 0xff;
+	RTUSBReadMACRegister(pAd, MAC_CSR0, Version);
+
+	// Initialize MAC register to default value
+	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++)
+	{
+		RTUSBWriteMACRegister(pAd, (USHORT)MACRegTable[Index].Register, MACRegTable[Index].Value);
+	}
+
+	// Set Host ready before kicking Rx
+	RTUSBWriteMACRegister(pAd, MAC_CSR1, 0x3);
+	RTUSBWriteMACRegister(pAd, MAC_CSR1, 0x0);
+
+	//
+	// Before program BBP, we need to wait BBP/RF get wake up.
+	//
+	Index = 0;
+	do
+	{
+		RTUSBReadMACRegister(pAd, MAC_CSR12, &MacCsr12->word);
+
+		if (MacCsr12->field.BbpRfStatus == 1)
+			break;
+
+		RTUSBWriteMACRegister(pAd, MAC_CSR12, 0x4); //Force wake up.
+		RTMPusecDelay(1000);
+	} while (Index++ < 1000);
+
+	// Read BBP register, make sure BBP is up and running before write new data
+	Index = 0;
+	do
+	{
+		RTUSBReadBBPRegister(pAd, BBP_R0, Value);
+		DBGPRINT(RT_DEBUG_TRACE, "BBP version = %d\n", *Value);
+	} while ((++Index < 100) && ((*Value == 0xff) || (*Value == 0x00)));
+	// Initialize BBP register to default value
+	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++)
+	{
+		RTUSBWriteBBPRegister(pAd, BBPRegTable[Index].Register, BBPRegTable[Index].Value);
+	}
+
+	// Clear raw counters
+	RTUSBReadMACRegister(pAd, STA_CSR0, Counter);
+	RTUSBReadMACRegister(pAd, STA_CSR1, Counter);
+	RTUSBReadMACRegister(pAd, STA_CSR2, Counter);
+	// assert HOST ready bit
+	RTUSBWriteMACRegister(pAd, MAC_CSR1, 0x4);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- NICInitializeAsic\n");
+
+	kfree(Version);
+	kfree(MacCsr12);
+	kfree(Counter);
+	kfree(Value);
+	return NDIS_STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Reset NIC Asics
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		Reset NIC to initial state AS IS system boot up time.
+
+	========================================================================
+*/
+VOID NICIssueReset(
+	IN	PRTMP_ADAPTER	pAd)
+{
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Check ASIC registers and find any reason the system might hang
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	========================================================================
+*/
+BOOLEAN	NICCheckForHang(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	return (FALSE);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Read statistical counters from hardware registers and record them
+		in software variables for later on query
+
+	Arguments:
+		pAd					Pointer to our adapter
+
+	Return Value:
+		None
+
+
+	========================================================================
+*/
+VOID NICUpdateRawCounters(
+	IN PRTMP_ADAPTER pAd)
+{
+	ULONG	OldValue;
+	STA_CSR0_STRUC *StaCsr0 = kzalloc(sizeof(STA_CSR0_STRUC), GFP_KERNEL);
+	STA_CSR1_STRUC *StaCsr1 = kzalloc(sizeof(STA_CSR1_STRUC), GFP_KERNEL);
+	STA_CSR2_STRUC *StaCsr2 = kzalloc(sizeof(STA_CSR2_STRUC), GFP_KERNEL);
+	STA_CSR3_STRUC *StaCsr3 = kzalloc(sizeof(STA_CSR3_STRUC), GFP_KERNEL);
+	STA_CSR4_STRUC *StaCsr4 = kzalloc(sizeof(STA_CSR4_STRUC), GFP_KERNEL);
+	STA_CSR5_STRUC *StaCsr5 = kzalloc(sizeof(STA_CSR5_STRUC), GFP_KERNEL);
+
+	if(!StaCsr0 || !StaCsr1 || !StaCsr2 || !StaCsr3 || !StaCsr4 || !StaCsr5) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return;
+	}
+	RTUSBReadMACRegister(pAd, STA_CSR0, &StaCsr0->word);
+
+	// Update RX PLCP error counter
+	pAd->PrivateInfo.PhyRxErrCnt += StaCsr0->field.PlcpErr;
+
+	// Update FCS counters
+	OldValue= pAd->WlanCounters.FCSErrorCount.vv.LowPart;
+	pAd->WlanCounters.FCSErrorCount.vv.LowPart += (StaCsr0->field.CrcErr); // >> 7);
+	if (pAd->WlanCounters.FCSErrorCount.vv.LowPart < OldValue)
+		pAd->WlanCounters.FCSErrorCount.vv.HighPart++;
+
+	// Add FCS error count to private counters
+	OldValue = pAd->RalinkCounters.RealFcsErrCount.vv.LowPart;
+	pAd->RalinkCounters.RealFcsErrCount.vv.LowPart += StaCsr0->field.CrcErr;
+	if (pAd->RalinkCounters.RealFcsErrCount.vv.LowPart < OldValue)
+		pAd->RalinkCounters.RealFcsErrCount.vv.HighPart++;
+
+
+	// Update False CCA counter
+	RTUSBReadMACRegister(pAd, STA_CSR1, &StaCsr1->word);
+	pAd->RalinkCounters.OneSecFalseCCACnt += StaCsr1->field.FalseCca;
+
+	// Update RX Overflow counter
+	RTUSBReadMACRegister(pAd, STA_CSR2, &StaCsr2->word);
+	pAd->Counters8023.RxNoBuffer += (StaCsr2->field.RxOverflowCount + StaCsr2->field.RxFifoOverflowCount);
+
+	// Update BEACON sent count
+	RTUSBReadMACRegister(pAd, STA_CSR3, &StaCsr3->word);
+	pAd->RalinkCounters.OneSecBeaconSentCnt += StaCsr3->field.TxBeaconCount;
+
+	RTUSBReadMACRegister(pAd, STA_CSR4, &StaCsr4->word);
+	RTUSBReadMACRegister(pAd, STA_CSR5, &StaCsr5->word);
+
+	// 1st - Transmit Success
+	OldValue = pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart;
+	pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart += (StaCsr4->field.TxOneRetryCount + StaCsr4->field.TxNoRetryCount + StaCsr5->field.TxMultiRetryCount);
+	if (pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.TransmittedFragmentCount.vv.HighPart++;
+	}
+
+	// 2rd	-success and no retry
+	OldValue = pAd->WlanCounters.RetryCount.vv.LowPart;
+	pAd->WlanCounters.NoRetryCount.vv.LowPart += StaCsr4->field.TxNoRetryCount;
+	if (pAd->WlanCounters.NoRetryCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.NoRetryCount.vv.HighPart++;
+	}
+
+	// 3rd	-success and retry
+	OldValue = pAd->WlanCounters.RetryCount.vv.LowPart;
+	pAd->WlanCounters.RetryCount.vv.LowPart += (StaCsr4->field.TxOneRetryCount  +StaCsr5->field.TxMultiRetryCount);
+	if (pAd->WlanCounters.RetryCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.RetryCount.vv.HighPart++;
+	}
+	// 4th - fail
+	OldValue = pAd->WlanCounters.FailedCount.vv.LowPart;
+	pAd->WlanCounters.FailedCount.vv.LowPart += StaCsr5->field.TxRetryFailCount;
+	if (pAd->WlanCounters.FailedCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.FailedCount.vv.HighPart++;
+	}
+
+
+	pAd->RalinkCounters.OneSecTxNoRetryOkCount = StaCsr4->field.TxNoRetryCount;
+	pAd->RalinkCounters.OneSecTxRetryOkCount = StaCsr4->field.TxOneRetryCount + StaCsr5->field.TxMultiRetryCount;
+	pAd->RalinkCounters.OneSecTxFailCount = StaCsr5->field.TxRetryFailCount;
+	pAd->RalinkCounters.OneSecFalseCCACnt = StaCsr1->field.FalseCca;
+	pAd->RalinkCounters.OneSecRxOkCnt = pAd->RalinkCounters.RxCount;
+	pAd->RalinkCounters.RxCount = 0; //Reset RxCount
+	pAd->RalinkCounters.OneSecRxFcsErrCnt = StaCsr0->field.CrcErr;
+	pAd->RalinkCounters.OneSecBeaconSentCnt = StaCsr3->field.TxBeaconCount;
+
+	kfree(StaCsr0);
+	kfree(StaCsr1);
+	kfree(StaCsr2);
+	kfree(StaCsr3);
+	kfree(StaCsr4);
+	kfree(StaCsr5);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Reset NIC from error
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		Reset NIC from error state
+
+	========================================================================
+*/
+VOID NICResetFromError(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NICInitializeAsic(pAd);
+#ifdef	INIT_FROM_EEPROM
+	NICInitAsicFromEEPROM(pAd);
+#endif
+	RTUSBWriteHWMACAddress(pAd);
+
+}
+
+INT LoadFirmware (PRTMP_ADAPTER pAd, char *firmName)
+{
+	const struct firmware *fw_entry;
+	struct usb_device *dev = pAd->pUsb_Dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	char udevice[16];
+	snprintf(udevice, sizeof(udevice), "rt73%3.3d%3.3d", dev->bus->busnum, dev->devnum);
+#else
+	struct device *udevice = &dev->dev;
+#endif
+
+	size_t size;
+	u8 *data;
+	USHORT i, loaded = 0;
+	ULONG *reg = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	u16 crc = 0;
+	INT status;
+#define BUFFERED_COPY
+#ifdef BUFFERED_COPY
+	u8 buf[64];
+#else
+	u32 buf;
+#endif
+	DBGPRINT(RT_DEBUG_TRACE, "--> LoadFirmware \n");
+
+	if(!reg) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+
+	// Access firmware file
+	if ((status = request_firmware(&fw_entry, firmName, udevice))) {
+		printk(KERN_ERR "rt73: Failed to request_firmware. "
+				"Check your firmware file location\n");
+		goto fw_error;
+	}
+
+	if (fw_entry->size != FIRMWARE_IMAGE_SIZE) {
+		printk(KERN_ERR "rt73: Firmware file size error "
+			"(%d instead of %d)\n",
+			fw_entry->size, FIRMWARE_IMAGE_SIZE);
+		status = EBADF;
+		goto error;
+	}
+
+	// Firmware CRC check
+	size = fw_entry->size - 2;
+	data = fw_entry->data;
+
+	for (i=0; i < size; i++)
+		crc = ByteCRC16(*data++, crc);
+	crc = ByteCRC16(0x00, crc);
+	crc = ByteCRC16(0x00, crc);
+
+	if (crc != ((fw_entry->data[size] << 8) | fw_entry->data[size + 1])) {
+		printk(KERN_ERR "rt73: Firmware CRC error "
+				"Check your firmware file integrity\n");
+		status = EBADF;
+		goto error;
+	}
+
+	// Wait for stable hardware
+	for (i = 0; i < 100; i++) {
+		RTUSBReadMACRegister(pAd, MAC_CSR0, reg);
+		if (reg)
+			break;
+		msleep(1);
+	}
+
+	if (!reg) {
+		printk(KERN_ERR "rt73: Unstable hardware\n");
+		status = EBUSY;
+		goto error;
+	}
+
+	// Write firmware to device
+	for (i = 0; i < FIRMWARE_IMAGE_SIZE; i += sizeof(buf)) {
+#ifdef BUFFERED_COPY
+		memcpy(&buf, &fw_entry->data[i], sizeof(buf));
+#else
+		buf = *(u32 *) &fw_entry->data[i];
+#endif
+		if ((status = RTUSBMultiWrite(pAd, FIRMWARE_IMAGE_BASE + i,
+						&buf, sizeof(buf))) < 0) {
+			printk(KERN_ERR "rt73: Firmware loading error\n");
+			goto error;
+		}
+		loaded += status;
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "%d bytes written to device.\n", loaded);
+
+	if (loaded < FIRMWARE_IMAGE_SIZE) {
+		// Should never happen
+		printk(KERN_ERR "rt73: Firmware loading incomplete\n");
+		status = EIO;
+		goto error;
+	}
+
+
+	// Send 'run firmware' request to device
+	if ((status = RTUSBFirmwareRun(pAd)) < 0) {
+		printk(KERN_ERR "rt73: Device refuses to run firmware\n");
+		goto error;
+	}
+
+	// Reset LED
+	RTMPSetLED(pAd, LED_LINK_DOWN);
+
+	// Firmware loaded ok
+	OPSTATUS_SET_FLAG (pAd, fOP_STATUS_FIRMWARE_LOAD );
+	status = 0;
+
+error:
+	release_firmware(fw_entry);
+
+fw_error:
+	DBGPRINT(RT_DEBUG_TRACE, "<-- LoadFirmware (status: %d, loaded: %d)\n",
+							status, loaded);
+	kfree(reg);
+	return status;
+}
+
+ /**
+  * strstr - Find the first substring in a %NUL terminated string
+  * @s1: The string to be searched
+  * @s2: The string to search for
+  */
+char * rtstrstr(const char * s1,const char * s2)
+{
+	INT l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+
+	l1 = strlen(s1);
+
+	while (l1 >= l2)
+	{
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+
+	return NULL;
+}
+
+/**
+ * rstrtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ * * WARNING: strtok is deprecated, use strsep instead. However strsep is not compatible with old architecture.
+ */
+char * __rstrtok;
+char * rstrtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : __rstrtok;
+	if (!sbegin)
+	{
+		return NULL;
+	}
+
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0')
+	{
+		__rstrtok = NULL;
+		return( NULL );
+	}
+
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+
+	__rstrtok = send;
+
+	return (sbegin);
+}
+
+#ifndef BIG_ENDIAN
+/*
+	========================================================================
+
+	Routine Description:
+		Compare two memory block
+
+	Arguments:
+		Adapter 					Pointer to our adapter
+
+	Return Value:
+		1:			memory are equal
+		0:			memory are not equal
+
+	Note:
+
+	========================================================================
+*/
+ULONG	RTMPEqualMemory(
+	IN	PVOID	pSrc1,
+	IN	PVOID	pSrc2,
+	IN	ULONG	Length)
+{
+	PUCHAR	pMem1;
+	PUCHAR	pMem2;
+	ULONG	Index = 0;
+
+	pMem1 = (PUCHAR) pSrc1;
+	pMem2 = (PUCHAR) pSrc2;
+
+	for (Index = 0; Index < Length; Index++)
+	{
+		if (pMem1[Index] != pMem2[Index])
+		{
+			break;
+		}
+	}
+
+	if (Index == Length)
+	{
+		return (1);
+	}
+	else
+	{
+		return (0);
+	}
+}
+#endif
+/*
+	========================================================================
+
+	Routine Description:
+		Compare two memory block
+
+	Arguments:
+		pSrc1		Pointer to first memory address
+		pSrc2		Pointer to second memory addres
+
+	Return Value:
+		0:			memory is equal
+		1:			pSrc1 memory is larger
+		2:			pSrc2 memory is larger
+
+	Note:
+
+	========================================================================
+*/
+ULONG	RTMPCompareMemory(
+	IN	PVOID	pSrc1,
+	IN	PVOID	pSrc2,
+	IN	ULONG	Length)
+{
+	PUCHAR	pMem1;
+	PUCHAR	pMem2;
+	ULONG	Index = 0;
+
+	pMem1 = (PUCHAR) pSrc1;
+	pMem2 = (PUCHAR) pSrc2;
+
+	for (Index = 0; Index < Length; Index++)
+	{
+		if (pMem1[Index] > pMem2[Index])
+			return (1);
+		else if (pMem1[Index] < pMem2[Index])
+			return (2);
+	}
+
+	// Equal
+	return (0);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Zero out memory block
+
+	Arguments:
+		pSrc1		Pointer to memory address
+		Length		Size
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPZeroMemory(
+	IN	PVOID	pSrc,
+	IN	ULONG	Length)
+{
+	memset(pSrc, 0, Length);
+}
+
+VOID	RTMPFillMemory(
+	IN	PVOID	pSrc,
+	IN	ULONG	Length,
+	IN	UCHAR	Fill)
+{
+	memset(pSrc, Fill, Length);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Copy data from memory block 1 to memory block 2
+
+	Arguments:
+		pDest		Pointer to destination memory address
+		pSrc		Pointer to source memory address
+		Length		Copy size
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPMoveMemory(
+	OUT PVOID	pDest,
+	IN	PVOID	pSrc,
+	IN	ULONG	Length)
+{
+#ifdef RTMP_EMBEDDED
+	if(Length <= 8)
+	{
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		if(--Length == 0)	return;
+	}
+	else
+		memcpy(pDest, pSrc, Length);
+#else
+	memcpy(pDest, pSrc, Length);
+#endif
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Initialize port configuration structure
+
+	Arguments:
+		Adapter			Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	PortCfgInit(
+	IN	PRTMP_ADAPTER pAd)
+{
+	UINT i;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> PortCfgInit\n");
+
+	//
+	//	part I. intialize common configuration
+	//
+	for(i = 0; i < SHARE_KEY_NUM; i++)
+	{
+		pAd->SharedKey[i].KeyLen = 0;
+		pAd->SharedKey[i].CipherAlg = CIPHER_NONE;
+	}
+
+	pAd->Antenna.field.TxDefaultAntenna = 2;	// Ant-B
+	pAd->Antenna.field.RxDefaultAntenna = 2;	// Ant-B
+	pAd->Antenna.field.NumOfAntenna = 2;
+
+	pAd->LedCntl.field.LedMode = LED_MODE_DEFAULT;
+	pAd->LedIndicatorStrength = 0;
+	pAd->bAutoTxAgcA = FALSE;			// Default is OFF
+	pAd->bAutoTxAgcG = FALSE;			// Default is OFF
+	pAd->RfIcType = RFIC_5226;
+
+	pAd->PortCfg.Dsifs = 10;	  // in units of usec
+	pAd->PortCfg.PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+	pAd->PortCfg.TxPower = 100; //mW
+	pAd->PortCfg.TxPowerPercentage = 0xffffffff; // AUTO
+	pAd->PortCfg.TxPowerDefault = 0xffffffff; // AUTO
+	pAd->PortCfg.TxPreamble = Rt802_11PreambleAuto; // use Long preamble on TX by defaut
+	pAd->PortCfg.bUseZeroToDisableFragment = FALSE;
+	pAd->PortCfg.RtsThreshold = 2347;
+	pAd->PortCfg.FragmentThreshold = 2346;
+    pAd->PortCfg.dBmToRoam = 70;    // default threshold used
+	pAd->PortCfg.UseBGProtection = 0;	 // 0: AUTO
+	pAd->PortCfg.bEnableTxBurst = 0;
+	pAd->PortCfg.PhyMode = 0xff;	 // unknown
+	pAd->PortCfg.BandState = UNKNOWN_BAND;
+	pAd->PortCfg.UseShortSlotTime = TRUE;   // default short slot used, it depends on AP's capability
+
+	pAd->bAcceptDirect = TRUE;
+	pAd->bAcceptMulticast = FALSE;
+	pAd->bAcceptBroadcast = TRUE;
+	pAd->bAcceptAllMulticast = TRUE;
+	pAd->bAcceptRFMONTx	= FALSE;
+
+	pAd->bLocalAdminMAC = FALSE; //TRUE;
+
+
+    pAd->PortCfg.RadarDetect.CSPeriod = 10;
+	pAd->PortCfg.RadarDetect.CSCount = 0;
+	pAd->PortCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
+
+
+	//
+	// part II. intialize STA specific configuration
+	//
+	pAd->PortCfg.Psm = PWR_ACTIVE;
+	pAd->PortCfg.BeaconPeriod = 100;	 // in mSec
+
+	pAd->PortCfg.ScanCnt = 0;
+
+	pAd->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+	pAd->PortCfg.WepStatus = Ndis802_11EncryptionDisabled;
+	pAd->PortCfg.PairCipher = Ndis802_11EncryptionDisabled;
+	pAd->PortCfg.GroupCipher = Ndis802_11EncryptionDisabled;
+	pAd->PortCfg.bMixCipher = FALSE;
+	pAd->PortCfg.DefaultKeyId = 0;
+
+	// 802.1x port control
+	pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+	pAd->PortCfg.LastMicErrorTime = 0;
+	pAd->PortCfg.MicErrCnt		  = 0;
+	pAd->PortCfg.bBlockAssoc	  = FALSE;
+	pAd->PortCfg.WpaState		  = SS_NOTUSE;		// Handle by microsoft unless RaConfig changed it.
+
+	pAd->PortCfg.RssiTrigger = 0;
+	pAd->PortCfg.LastRssi = 0;
+	pAd->PortCfg.LastRssi2 = 0;
+	pAd->PortCfg.AvgRssi  = 0;
+	pAd->PortCfg.AvgRssiX8 = 0;
+	pAd->PortCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
+	pAd->PortCfg.AtimWin = 0;
+	pAd->PortCfg.DefaultListenCount = 3;//default listen count;
+	pAd->PortCfg.BssType = BSS_INFRA;  // BSS_INFRA or BSS_ADHOC
+	pAd->PortCfg.AdhocMode = 0;
+
+	// global variables mXXXX used in MAC protocol state machines
+	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
+
+	// PHY specification
+	pAd->PortCfg.PhyMode = PHY_11ABG_MIXED; 	// default PHY mode
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);  // CCK use LONG preamble
+
+	// user desired power mode
+	pAd->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+	pAd->PortCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+	pAd->PortCfg.bWindowsACCAMEnable = FALSE;
+
+
+	RTMPInitTimer(pAd, &pAd->PortCfg.QuickResponeForRateUpTimer, &StaQuickResponeForRateUpExec);
+	pAd->PortCfg.QuickResponeForRateUpTimerRunning = FALSE;
+
+
+	pAd->PortCfg.bHwRadio  = TRUE; // Default Hardware Radio status is On
+	pAd->PortCfg.bSwRadio  = TRUE; // Default Software Radio status is On
+	pAd->PortCfg.bRadio    = TRUE; // bHwRadio && bSwRadio
+	pAd->PortCfg.bHardwareRadio = FALSE;		// Default is OFF
+	pAd->PortCfg.bShowHiddenSSID = FALSE;		// Default no show
+	pAd->PortCfg.AdhocMode = 0; // b/g in adhoc
+
+	// Nitro mode control
+	pAd->PortCfg.bAutoReconnect = TRUE;
+
+	// Save the init time as last scan time, the system should do scan after 2 seconds.
+	// This patch is for driver wake up from standby mode, system will do scan right away.
+	pAd->PortCfg.LastScanTime = 0;
+
+	// Default for extra information is not valid
+	pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+
+	// Default Config change flag
+	pAd->bConfigChanged = FALSE;
+
+
+	//
+	// part III. others
+	//
+	// dynamic BBP R17:sensibity tuning to overcome background noise
+	pAd->BbpTuning.bEnable				  = TRUE;
+	pAd->BbpTuning.R17LowerBoundG		  = 0x20; // for best RX sensibility
+	pAd->BbpTuning.R17UpperBoundG		  = 0x40; // for best RX noise isolation to prevent false CCA
+	pAd->BbpTuning.R17LowerBoundA		  = 0x28; // for best RX sensibility
+	pAd->BbpTuning.R17UpperBoundA		  = 0x48; // for best RX noise isolation to prevent false CCA
+	pAd->BbpTuning.R17LowerUpperSelect	  = 0;	  // Default used LowerBound.
+	pAd->BbpTuning.FalseCcaLowerThreshold = 100;
+	pAd->BbpTuning.FalseCcaUpperThreshold = 512;
+	pAd->BbpTuning.R17Delta 			  = 4;
+
+    pAd->Bbp94 = BBPR94_DEFAULT;
+	pAd->BbpForCCK = FALSE;
+
+//#if WPA_SUPPLICANT_SUPPORT
+	pAd->PortCfg.IEEE8021X = 0;
+	pAd->PortCfg.IEEE8021x_required_keys = 0;
+	pAd->PortCfg.WPA_Supplicant = FALSE;
+	pAd->PortCfg.bWscCapable = TRUE;
+	pAd->PortCfg.WscIEProbeReq.ValueLen = 0;
+	pAd->PortCfg.Send_Beacon = FALSE;
+//#endif
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- PortCfgInit\n");
+
+}
+
+UCHAR BtoH(
+	IN CHAR		ch)
+{
+	if (ch >= '0' && ch <= '9') return (ch - '0');		  // Handle numerals
+	if (ch >= 'A' && ch <= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits
+	if (ch >= 'a' && ch <= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits
+	return(255);
+}
+
+//
+//	PURPOSE:  Converts ascii string to network order hex
+//
+//	PARAMETERS:
+//	  src	 - pointer to input ascii string
+//	  dest	 - pointer to output hex
+//	  destlen - size of dest
+//
+//	COMMENTS:
+//
+//	  2 ascii bytes make a hex byte so must put 1st ascii byte of pair
+//	  into upper nibble and 2nd ascii byte of pair into lower nibble.
+//
+VOID AtoH(
+	IN CHAR		*src,
+	OUT UCHAR	*dest,
+	IN INT		destlen)
+{
+	CHAR *srcptr;
+	PUCHAR destTemp;
+
+	srcptr = src;
+	destTemp = (PUCHAR) dest;
+
+	while(destlen--)
+	{
+		*destTemp = BtoH(*srcptr++) << 4;	 // Put 1st ascii byte in upper nibble.
+		*destTemp += BtoH(*srcptr++);	   // Add 2nd ascii byte to above.
+		destTemp++;
+	}
+}
+
+VOID	RTMPPatchMacBbpBug(
+	IN	PRTMP_ADAPTER	pAd)
+{
+#if 0
+	ULONG	Index;
+
+	// Initialize BBP register to default value
+	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++)
+	{
+		RTUSBWriteBBPRegister(pAd, BBPRegTable[Index].Register, (UCHAR)BBPRegTable[Index].Value);
+	}
+
+	// Initialize RF register to default value
+	AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+	AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+	// Re-init BBP register from EEPROM value
+	NICInitAsicFromEEPROM(pAd);
+#endif
+}
+
+// Unify all delay routine by using udelay
+VOID	RTMPusecDelay(
+	IN	ULONG	usec)
+{
+	ULONG	i;
+
+	for (i = 0; i < (usec / 50); i++)
+		udelay(50);
+
+	if (usec % 50)
+		udelay(usec % 50);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Set LED Status
+
+	Arguments:
+		pAd						Pointer to our adapter
+		Status					LED Status
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPSetLED(
+	IN PRTMP_ADAPTER	pAd,
+	IN UCHAR			Status)
+{
+	switch (Status)
+	{
+		case LED_LINK_DOWN:
+			pAd->LedCntl.field.LinkGStatus = 0;
+			pAd->LedCntl.field.LinkAStatus = 0;
+			pAd->LedIndicatorStrength = 0;
+			RTUSBSetLED(pAd, pAd->LedCntl, pAd->LedIndicatorStrength);
+			break;
+		case LED_LINK_UP:
+			if (pAd->PortCfg.Channel <= 14)
+			{
+				// 11 G mode
+				pAd->LedCntl.field.LinkGStatus = 1;
+				pAd->LedCntl.field.LinkAStatus = 0;
+			}
+			else
+			{
+				//11 A mode
+				pAd->LedCntl.field.LinkGStatus = 0;
+				pAd->LedCntl.field.LinkAStatus = 1;
+			}
+
+			RTUSBSetLED(pAd, pAd->LedCntl, pAd->LedIndicatorStrength);
+			break;
+		case LED_RADIO_ON:
+			pAd->LedCntl.field.RadioStatus = 1;
+			RTUSBSetLED(pAd, pAd->LedCntl, pAd->LedIndicatorStrength);
+			break;
+		case LED_HALT:
+			//Same as Radio Off.
+		case LED_RADIO_OFF:
+			pAd->LedCntl.field.RadioStatus = 0;
+			pAd->LedCntl.field.LinkGStatus = 0;
+			pAd->LedCntl.field.LinkAStatus = 0;
+			pAd->LedIndicatorStrength = 0;
+			RTUSBSetLED(pAd, pAd->LedCntl, pAd->LedIndicatorStrength);
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_WARN, "RTMPSetLED::Unknown Status %d\n", Status);
+			break;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Set LED Signal Stregth
+
+	Arguments:
+		pAd						Pointer to our adapter
+		Dbm						Signal Stregth
+
+	Return Value:
+		None
+
+	Note:
+		Can be run on any IRQL level.
+
+		According to Microsoft Zero Config Wireless Signal Stregth definition as belows.
+		<= -90	No Signal
+		<= -81	Very Low
+		<= -71	Low
+		<= -67	Good
+		<= -57	Very Good
+		 > -57	Excellent
+	========================================================================
+*/
+VOID RTMPSetSignalLED(
+	IN PRTMP_ADAPTER	pAd,
+	IN NDIS_802_11_RSSI Dbm)
+{
+	USHORT		nLed = 0;
+
+	if (Dbm <= -90)
+		nLed = 0;
+	else if (Dbm <= -81)
+		nLed = 1;
+	else if (Dbm <= -71)
+		nLed = 2;
+	else if (Dbm <= -67)
+		nLed = 3;
+	else if (Dbm <= -57)
+		nLed = 4;
+	else
+		nLed = 5;
+
+	//
+	// Update Signal Stregth to if changed.
+	//
+	if ((pAd->LedIndicatorStrength != nLed) &&
+		(pAd->LedCntl.field.LedMode == LED_MODE_SIGNAL_STREGTH))
+	{
+		pAd->LedIndicatorStrength = nLed;
+		RTUSBSetLED(pAd, pAd->LedCntl, pAd->LedIndicatorStrength);
+	}
+}
+
+VOID RTMPCckBbpTuning(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UINT			TxRate)
+{
+	CHAR		Bbp94 = 0xFF;
+	USHORT		Value = 0;
+
+	//
+	// Do nothing if TxPowerEnable == FALSE
+	//
+	if (pAd->TxPowerDeltaConfig.field.TxPowerEnable == FALSE)
+		return;
+
+	if ((TxRate < RATE_FIRST_OFDM_RATE) &&
+		(pAd->BbpForCCK == FALSE))
+	{
+		Bbp94 = pAd->Bbp94;
+
+		if (pAd->TxPowerDeltaConfig.field.Type == 1)
+		{
+			Bbp94 += pAd->TxPowerDeltaConfig.field.DeltaValue;
+		}
+		else
+		{
+			Bbp94 -= pAd->TxPowerDeltaConfig.field.DeltaValue;
+		}
+		pAd->BbpForCCK = TRUE;
+	}
+	else if ((TxRate >= RATE_FIRST_OFDM_RATE) &&
+		(pAd->BbpForCCK == TRUE))
+	{
+		Bbp94 = pAd->Bbp94;
+		pAd->BbpForCCK = FALSE;
+	}
+
+	if ((Bbp94 >= 0) && (Bbp94 <= 0x0C))
+	{
+		Value = (Bbp94 << 8) + BBP_R94;
+        RTUSBEnqueueCmdFromNdis(pAd, RT_OID_VENDOR_WRITE_BBP, TRUE, (PVOID) &Value, sizeof(Value));
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Init timer objects
+
+	Arguments:
+		pAd			Pointer to our adapter
+		pTimer				Timer structure
+		pTimerFunc			Function to execute when timer expired
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPInitTimer(
+	IN	PRTMP_ADAPTER			pAd,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	PVOID					pTimerFunc)
+{
+	init_timer(&pTimer->Timer);
+	pTimer->Timer.data = (unsigned long)pAd;
+	pTimer->Timer.function = pTimerFunc;
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Init timer objects
+
+	Arguments:
+		pAd			Pointer to our adapter
+		pTimer				Timer structure
+		Value				Timer value in milliseconds
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPSetTimer(
+	IN	PRTMP_ADAPTER			pAd,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	ULONG					Value)
+{
+	//
+	// We should not set a timer when driver is on Halt state.
+	//
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+	pTimer->Timer.expires = jiffies + (Value * HZ)/1000;
+	add_timer(&pTimer->Timer);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Cancel timer objects
+
+	Arguments:
+		pTimer				Timer structure
+
+	Return Value:
+		None
+
+	Note:
+		Reset NIC to initial state AS IS system boot up time.
+
+	========================================================================
+*/
+INT	RTMPCancelTimer(
+	IN	PRALINK_TIMER_STRUCT	pTimer)
+{
+	// reset timer if caller isn't the timer function itself
+	if (timer_pending(&pTimer->Timer))
+		return del_timer_sync(&pTimer->Timer);
+	return 0;
+}
+
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_main.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_main.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_main.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,2344 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_main.c
+ *
+ *	Abstract: Main initialization routines
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Jan Lee		01-10-2005	modified
+ *	idamlaj		04-10-2006	Apply patch by Ace17 (from forum)
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+
+ULONG	RTDebugLevel = RT_DEBUG_OFF;
+static ULONG	debug = RT_DEBUG_OFF;
+static char *firmName = RT2573_IMAGE_FILE_NAME;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+#else
+module_param(debug, int, 0);
+module_param(firmName, charp, S_IRUGO );
+#endif
+
+MODULE_PARM_DESC(debug, "Debug mask: n selects filter, 0 for none");
+MODULE_PARM_DESC(firmName, "Permit to load a different firmware: (default: rt73.bin) ");
+
+// Following information will be show when you run 'modinfo'
+MODULE_AUTHOR("http://rt2x00.serialmonkey.com");
+MODULE_DESCRIPTION("Ralink RT73 802.11abg WLAN Driver " DRIVER_VERSION " " DRIVER_RELDATE);
+
+// *** open source release
+MODULE_LICENSE("GPL");
+
+/* Kernel thread and vars, which handles packets that are completed. Only
+ * packets that have a "complete" function are sent here. This way, the
+ * completion is run out of kernel context, and doesn't block the rest of
+ * the stack. */
+static int mlme_kill;
+static int RTUSBCmd_kill;
+
+extern	const struct iw_handler_def rt73_iw_handler_def;
+
+
+/* module table */
+struct usb_device_id    rtusb_usb_id[] = RT73_USB_DEVICES;
+INT const               rtusb_usb_id_len = sizeof(rtusb_usb_id) / sizeof(struct usb_device_id);
+MODULE_DEVICE_TABLE(usb, rtusb_usb_id);
+
+
+#ifndef PF_NOFREEZE
+#define PF_NOFREEZE  0
+#endif
+
+
+/**************************************************************************/
+/**************************************************************************/
+//tested for kernel 2.4 series
+/**************************************************************************/
+/**************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+
+static void usb_rtusb_disconnect(struct usb_device *dev, void *ptr);
+static void *usb_rtusb_probe(struct usb_device *dev, UINT interface,
+				const struct usb_device_id *id_table);
+
+struct usb_driver rtusb_driver = {
+		name:"rt73",
+		probe:usb_rtusb_probe,
+		disconnect:usb_rtusb_disconnect,
+		id_table:rtusb_usb_id,
+	};
+#else
+/**************************************************************************/
+/**************************************************************************/
+//tested for kernel 2.6series
+/**************************************************************************/
+/**************************************************************************/
+static int usb_rtusb_probe (struct usb_interface *intf,
+					  const struct usb_device_id *id);
+
+static void usb_rtusb_disconnect(struct usb_interface *intf);
+
+struct usb_driver rtusb_driver = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+	.owner = THIS_MODULE,
+#endif
+	.name="rt73",
+	.probe=usb_rtusb_probe,
+	.disconnect=usb_rtusb_disconnect,
+	.id_table=rtusb_usb_id,
+	};
+
+
+#endif
+
+
+struct net_device_stats *rt73_get_ether_stats(
+    IN  struct net_device *net_dev)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) net_dev->priv;
+
+	DBGPRINT(RT_DEBUG_INFO, "rt73_get_ether_stats --->\n");
+
+	pAd->stats.rx_packets = pAd->WlanCounters.ReceivedFragmentCount.vv.LowPart;        // total packets received
+	pAd->stats.tx_packets = pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart;     // total packets transmitted
+
+	pAd->stats.rx_bytes= pAd->RalinkCounters.ReceivedByteCount;             // total bytes received
+	pAd->stats.tx_bytes = pAd->RalinkCounters.TransmittedByteCount;         // total bytes transmitted
+
+	pAd->stats.rx_errors = pAd->Counters8023.RxErrors;                      // bad packets received
+	pAd->stats.tx_errors = pAd->Counters8023.TxErrors;                      // packet transmit problems
+
+	pAd->stats.rx_dropped = pAd->Counters8023.RxNoBuffer;                   // no space in linux buffers
+	pAd->stats.tx_dropped = pAd->WlanCounters.FailedCount.vv.LowPart;                  // no space available in linux
+
+	pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.vv.LowPart;   // multicast packets received
+	pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;  // Collision packets
+
+	pAd->stats.rx_length_errors = 0;
+	pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;               // receiver ring buff overflow
+	pAd->stats.rx_crc_errors = 0;//pAd->WlanCounters.FCSErrorCount;         // recved pkt with crc error
+	pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;      // recv'd frame alignment error
+	pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;               // recv'r fifo overrun
+	pAd->stats.rx_missed_errors = 0;                                        // receiver missed packet
+
+	// detailed tx_errors
+	pAd->stats.tx_aborted_errors = 0;
+	pAd->stats.tx_carrier_errors = 0;
+	pAd->stats.tx_fifo_errors = 0;
+	pAd->stats.tx_heartbeat_errors = 0;
+	pAd->stats.tx_window_errors = 0;
+
+	// for cslip etc
+	pAd->stats.rx_compressed = 0;
+	pAd->stats.tx_compressed = 0;
+
+	return &pAd->stats;
+}
+
+#if WIRELESS_EXT >= 12
+/*
+	========================================================================
+
+	Routine Description:
+		get wireless statistics
+
+	Arguments:
+		net_dev                     Pointer to net_device
+
+	Return Value:
+		struct iw_statistics
+
+	Note:
+		This function will be called when query /proc
+
+	========================================================================
+*/
+long rt_abs(long arg)	{	return (arg<0)? -arg : arg;}
+struct iw_statistics *rt73_get_wireless_stats(
+	IN  struct net_device *net_dev)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) net_dev->priv;
+
+	DBGPRINT(RT_DEBUG_TRACE, "rt73_get_wireless_stats --->\n");
+
+	// TODO: All elements are zero before be implemented
+
+	pAd->iw_stats.status = 0;   // Status - device dependent for now
+
+    pAd->iw_stats.qual.qual = pAd->Mlme.ChannelQuality; // link quality (%retries, SNR, %missed beacons or better...)
+#ifdef RTMP_EMBEDDED
+    pAd->iw_stats.qual.level = rt_abs(pAd->PortCfg.LastRssi);   // signal level (dBm)
+#else
+    pAd->iw_stats.qual.level = abs(pAd->PortCfg.LastRssi);      // signal level (dBm)
+#endif
+	pAd->iw_stats.qual.level += 256 - pAd->BbpRssiToDbmDelta;
+
+    pAd->iw_stats.qual.noise = (pAd->BbpWriteLatch[17] > pAd->BbpTuning.R17UpperBoundG) ? pAd->BbpTuning.R17UpperBoundG : ((ULONG) pAd->BbpWriteLatch[17]); // noise level (dBm)
+    pAd->iw_stats.qual.noise += 256 - 143;
+	pAd->iw_stats.qual.updated = 1;     // Flags to know if updated
+
+	pAd->iw_stats.discard.nwid = 0;     // Rx : Wrong nwid/essid
+	pAd->iw_stats.miss.beacon = 0;      // Missed beacons/superframe
+
+	// pAd->iw_stats.discard.code, discard.fragment, discard.retries, discard.misc has counted in other place
+
+	return &pAd->iw_stats;
+}
+#endif
+
+VOID RTUSBHalt(
+	IN	PRTMP_ADAPTER	pAd,
+	IN  BOOLEAN         IsFree)
+{
+	MLME_DISASSOC_REQ_STRUCT DisReq;
+	MLME_QUEUE_ELEM          MsgElem;
+	INT                      i;
+
+	DBGPRINT(RT_DEBUG_TRACE, "====> RTUSBHalt\n");
+
+	//
+	// before set flag fRTMP_ADAPTER_HALT_IN_PROGRESS,
+	// we should send a disassoc frame to our AP.
+	//
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+	{
+		if (INFRA_ON(pAd))
+		{
+			COPY_MAC_ADDR(DisReq.Addr, pAd->PortCfg.Bssid);
+			DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+
+			MsgElem.Machine = ASSOC_STATE_MACHINE;
+			MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
+			MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
+			memcpy(MsgElem.Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+
+			MlmeDisassocReqAction(pAd, &MsgElem);
+			RTMPusecDelay(1000);
+		}
+
+        //
+		// Patch to fully turn off BBP, need to send a fake NULL frame.
+		//
+		RTUSBWriteMACRegister(pAd, MAC_CSR10, 0x0018);
+		for (i=0; i<10; i++)
+		{
+			RTMPSendNullFrame(pAd, RATE_6);
+			RTMPusecDelay(1000);
+		}
+
+		// disable BEACON generation and other BEACON related hardware timers
+		AsicDisableSync(pAd);
+		RTMPSetLED(pAd, LED_HALT);
+
+	}
+
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+
+	RTUSBCleanUpMLMEWaitQueue(pAd);
+	RTUSBCleanUpMLMEBulkOutQueue(pAd);
+
+    RTMPCancelTimer(&pAd->PortCfg.QuickResponeForRateUpTimer);
+	RTMPCancelTimer(&pAd->RxAnt.RxAntDiversityTimer);
+
+	// Free MLME stuff
+	MlmeHalt(pAd);
+
+    // Sleep 50 milliseconds so pending io might finish normally
+	RTMPusecDelay(50000);
+
+	// We want to wait until all pending receives and sends to the
+	// device object. We cancel any
+	// irps. Wait until sends and receives have stopped.
+	//
+	RTUSBCancelPendingIRPs(pAd);
+
+    // Free the entire adapter object
+	ReleaseAdapter(pAd, IsFree, FALSE);
+
+	// reset mlme & command thread
+    pAd->MLMEThr_pid = -1;
+	pAd->RTUSBCmdThr_pid = -1;
+
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+}
+
+VOID CMDHandler(
+    IN PRTMP_ADAPTER pAd)
+{
+	PCmdQElmt	cmdqelmt;
+	PUCHAR	    pData;
+	NDIS_STATUS	NdisStatus = NDIS_STATUS_SUCCESS;
+  unsigned long IrqFlags;
+    ULONG       Now;
+
+	while (pAd->CmdQ.size > 0)
+	{
+
+		NdisStatus = NDIS_STATUS_SUCCESS;
+		NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+		RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
+		NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+		if (cmdqelmt == NULL)
+			break;
+		pData = cmdqelmt->buffer;
+
+        //DBGPRINT_RAW(RT_DEBUG_INFO, "Cmd = %x\n", cmdqelmt->command);
+		switch (cmdqelmt->command)
+		{
+			case RT_OID_CHECK_GPIO:
+			{
+				ULONG data;
+				// Read GPIO pin7 as Hardware controlled radio state
+				RTUSBReadMACRegister(pAd, MAC_CSR13, &data);
+				if (data & 0x80)
+				{
+					pAd->PortCfg.bHwRadio = TRUE;
+				}
+				else
+				{
+					pAd->PortCfg.bHwRadio = FALSE;
+				}
+				if (pAd->PortCfg.bRadio != (pAd->PortCfg.bHwRadio && pAd->PortCfg.bSwRadio))
+				{
+					pAd->PortCfg.bRadio = (pAd->PortCfg.bHwRadio && pAd->PortCfg.bSwRadio);
+					if (pAd->PortCfg.bRadio == TRUE)
+					{
+						MlmeRadioOn(pAd);
+						// Update extra information
+						pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+					}
+					else
+					{
+						MlmeRadioOff(pAd);
+						// Update extra information
+						pAd->ExtraInfo = HW_RADIO_OFF;
+					}
+				}
+			}
+			break;
+
+			case RT_OID_PERIODIC_EXECUT:
+			    STAMlmePeriodicExec(pAd);
+			break;
+
+			case OID_802_11_BSSID_LIST_SCAN:
+			{
+				if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					MlmeEnqueue(pAd,
+					            MLME_CNTL_STATE_MACHINE,
+					            RT_CMD_RESET_MLME,
+					            0,
+					            NULL);
+
+				}
+
+				Now = jiffies;
+				pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+				// Reset Missed scan number
+				pAd->PortCfg.ScanCnt = 0;
+				pAd->PortCfg.LastScanTime = Now;
+				MlmeEnqueue(pAd,
+							MLME_CNTL_STATE_MACHINE,
+							OID_802_11_BSSID_LIST_SCAN,
+							0,
+							NULL);
+				RTUSBMlmeUp(pAd);
+			}
+			break;
+
+			case RT_OID_802_11_BSSID:
+			{
+
+				if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					MlmeEnqueue(pAd,
+					            MLME_CNTL_STATE_MACHINE,
+					            RT_CMD_RESET_MLME,
+					            0,
+					            NULL);
+
+				}
+
+				pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+				// Reset allowed scan retries
+				pAd->PortCfg.ScanCnt = 0;
+
+				MlmeEnqueue(pAd,
+							MLME_CNTL_STATE_MACHINE,
+							OID_802_11_BSSID,
+							cmdqelmt->bufferlength,
+							cmdqelmt->buffer);
+				RTUSBMlmeUp(pAd);
+			}
+			break;
+
+			case OID_802_11_SSID:
+			{
+				if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					MlmeEnqueue(pAd,
+					            MLME_CNTL_STATE_MACHINE,
+					            RT_CMD_RESET_MLME,
+					            0,
+					            NULL);
+
+				}
+
+				pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+
+				// Reset allowed scan retries
+				pAd->PortCfg.ScanCnt = 0;
+				pAd->bConfigChanged = TRUE;
+
+				MlmeEnqueue(pAd,
+							MLME_CNTL_STATE_MACHINE,
+							OID_802_11_SSID,
+							cmdqelmt->bufferlength,
+							pData);
+				RTUSBMlmeUp(pAd);
+			}
+			break;
+
+			case OID_802_11_DISASSOCIATE:
+			{
+				if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					MlmeEnqueue(pAd,
+					            MLME_CNTL_STATE_MACHINE,
+					            RT_CMD_RESET_MLME,
+					            0,
+					            NULL);
+
+				}
+
+				// Set to immediately send the media disconnect event
+				pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+
+				MlmeEnqueue(pAd,
+							MLME_CNTL_STATE_MACHINE,
+							OID_802_11_DISASSOCIATE,
+							0,
+							NULL);
+				RTUSBMlmeUp(pAd);
+			}
+			break;
+
+			case OID_802_11_RX_ANTENNA_SELECTED:
+			{
+
+		        NDIS_802_11_ANTENNA	Antenna = *(NDIS_802_11_ANTENNA *)pData;
+
+				    if (Antenna == 0)
+					    pAd->Antenna.field.RxDefaultAntenna = 1;    // ant-A
+				    else if(Antenna == 1)
+					    pAd->Antenna.field.RxDefaultAntenna = 2;    // ant-B
+				    else
+					    pAd->Antenna.field.RxDefaultAntenna = 0;    // diversity
+
+			    pAd->PortCfg.BandState = UNKNOWN_BAND;
+			    AsicAntennaSelect(pAd, pAd->LatchRfRegs.Channel);
+			    DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_RX_ANTENNA_SELECTED (=%d)\n", Antenna);
+            }
+		    break;
+
+			case OID_802_11_TX_ANTENNA_SELECTED:
+		    {
+			    NDIS_802_11_ANTENNA	Antenna = *(NDIS_802_11_ANTENNA *)pData;
+
+			    if (Antenna == 0)
+				    pAd->Antenna.field.TxDefaultAntenna = 1;    // ant-A
+			    else if(Antenna == 1)
+				    pAd->Antenna.field.TxDefaultAntenna = 2;    // ant-B
+			    else
+				    pAd->Antenna.field.TxDefaultAntenna = 0;    // diversity
+
+			    pAd->PortCfg.BandState = UNKNOWN_BAND;
+			    AsicAntennaSelect(pAd, pAd->LatchRfRegs.Channel);
+			    DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_TX_ANTENNA_SELECTED (=%d)\n", Antenna);
+            }
+		    break;
+#if 0
+	        case RT_OID_802_11_QUERY_HARDWARE_REGISTER:
+		        NdisStatus = RTUSBQueryHardWareRegister(pAd, pData);
+		    break;
+
+		    case RT_OID_802_11_SET_HARDWARE_REGISTER:
+		        NdisStatus = RTUSBSetHardWareRegister(pAd, pData);
+			break;
+#endif
+			case RT_OID_MULTI_READ_MAC:
+	        {
+			    USHORT	Offset = *((PUSHORT)pData);
+			    USHORT	Length = *((PUSHORT)(pData + 2));
+		        RTUSBMultiRead(pAd, Offset, pData + 4, Length);
+		    }
+		    break;
+
+			case RT_OID_MULTI_WRITE_MAC:
+	        {
+		        USHORT	Offset = *((PUSHORT)pData);
+			    USHORT	Length = *((PUSHORT)(pData + 2));
+			    RTUSBMultiWrite(pAd, Offset, pData + 4, Length);
+		    }
+		    break;
+
+			case RT_OID_USB_VENDOR_EEPROM_READ:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBReadEEPROM(pAd, Offset, pData + 4, Length);
+			}
+			break;
+
+			case RT_OID_USB_VENDOR_EEPROM_WRITE:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+#if 0
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBWriteEEPROM(pAd, Offset, pData + 4, Length);
+#else//F/W restricts the max EEPROM write size to 62 bytes.
+				USHORT	Residual = *((PUSHORT)(pData + 2));
+				pData += 4;
+				while (Residual > 62)
+				{
+				RTUSBWriteEEPROM(pAd, Offset, pData, 62);
+				Offset += 62;
+				Residual -= 62;
+				pData += 62;
+				}
+				RTUSBWriteEEPROM(pAd, Offset, pData, Residual);
+#endif
+			}
+			break;
+
+			case RT_OID_USB_VENDOR_ENTER_TESTMODE:
+			    RTUSB_VendorRequest(pAd,
+					0,
+					DEVICE_VENDOR_REQUEST_OUT,
+					0x1,
+					0x4,
+					0x1,
+					NULL,
+					0);
+					break;
+
+			case RT_OID_USB_VENDOR_EXIT_TESTMODE:
+				RTUSB_VendorRequest(pAd,
+					0,
+					DEVICE_VENDOR_REQUEST_OUT,
+					0x1,
+					0x4,
+					0x0,
+					NULL,
+					0);
+			break;
+			case RT_OID_USB_RESET_BULK_OUT:
+			{
+				INT 	Index;
+
+		        DBGPRINT_RAW(RT_DEBUG_ERROR, "RT_OID_USB_RESET_BULK_OUT\n");
+
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+
+				RTUSBRejectPendingPackets(pAd); //reject all NDIS packets waiting in TX queue
+				RTUSBCancelPendingBulkOutIRP(pAd);
+				RTUSBCleanUpDataBulkOutQueue(pAd);
+
+				NICInitializeAsic(pAd);
+				ReleaseAdapter(pAd, FALSE, TRUE);   // unlink urb releated tx context
+				NICInitTransmit(pAd);
+
+				RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+
+				if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
+				{
+					RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				}
+
+				if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+				{
+					for (Index = 0; Index < 4; Index++)
+					{
+						if(!skb_queue_empty(&pAd->SendTxWaitQueue[Index]))
+						{
+							RTMPDeQueuePacket(pAd, Index);
+						}
+					}
+
+					RTUSBKickBulkOut(pAd);
+				}
+			}
+
+    	    break;
+
+			case RT_OID_USB_RESET_BULK_IN:
+		    {
+			    int	i;
+				DBGPRINT_RAW(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+				NICInitializeAsic(pAd);
+				//RTUSBWriteMACRegister(pAd, TXRX_CSR0, 0x025eb032); // ??
+				for (i = 0; i < RX_RING_SIZE; i++)
+				{
+					PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+
+					if (pRxContext->pUrb != NULL)
+					{
+						RTUSB_UNLINK_URB(pRxContext->pUrb);
+						usb_free_urb(pRxContext->pUrb);
+						pRxContext->pUrb = NULL;
+					}
+					if (pRxContext->TransferBuffer != NULL)
+					{
+						kfree(pRxContext->TransferBuffer);
+						pRxContext->TransferBuffer = NULL;
+					}
+				}
+				NICInitRecv(pAd);
+				RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+				if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET))
+				{
+					RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
+				}
+
+				if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+				{
+					RTUSBBulkReceive(pAd);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR0, 0x0276b032);  // enable RX of MAC block
+				}
+		    }
+			break;
+
+			case RT_OID_802_11_STA_CONFIG:
+			{
+				RT_802_11_STA_CONFIG *pStaConfig = (RT_802_11_STA_CONFIG *)pData;
+				if (pStaConfig->EnableTxBurst != pAd->PortCfg.bEnableTxBurst)
+				{
+					pAd->PortCfg.bEnableTxBurst = (pStaConfig->EnableTxBurst == 1);
+					//Currently Tx burst mode is only implemented in infrastructure mode.
+					if (INFRA_ON(pAd))
+					{
+						if (pAd->PortCfg.bEnableTxBurst)
+						{
+							//Extend slot time if any encryption method is used to give ASIC more time to do encryption/decryption during Tx burst mode.
+							if (pAd->PortCfg.WepStatus != Ndis802_11EncryptionDisabled)
+							{
+							// Nemo  RT2573USBWriteMACRegister_old(pAd, MAC_CSR10, 0x20);
+							}
+							//Set CWmin/CWmax to 0.
+							// Nemo 2004    RT2573USBWriteMACRegister_old(pAd, MAC_CSR22, 0x100);
+						}
+						else
+						{
+							if (pAd->PortCfg.WepStatus != Ndis802_11EncryptionDisabled)
+								AsicSetSlotTime(pAd, (BOOLEAN)pAd->PortCfg.UseShortSlotTime);
+						// Nemo 2004    RT2573USBWriteMACRegister_old(pAd, MAC_CSR22, 0x53);
+						}
+					}
+				}
+				//pAd->PortCfg.EnableTurboRate = pStaConfig->EnableTurboRate;
+				pAd->PortCfg.UseBGProtection = pStaConfig->UseBGProtection;
+				//pAd->PortCfg.UseShortSlotTime = pStaConfig->UseShortSlotTime;
+				pAd->PortCfg.UseShortSlotTime = 1; // 2003-10-30 always SHORT SLOT capable
+				if (pAd->PortCfg.AdhocMode != pStaConfig->AdhocMode)
+				{
+					// allow dynamic change of "USE OFDM rate or not" in ADHOC mode
+					// if setting changed, need to reset current TX rate as well as BEACON frame format
+					pAd->PortCfg.AdhocMode = pStaConfig->AdhocMode;
+					if (pAd->PortCfg.BssType == BSS_ADHOC)
+					{
+						MlmeUpdateTxRates(pAd, FALSE);
+						MakeIbssBeacon(pAd);
+						AsicEnableIbssSync(pAd);
+					}
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "CmdThread::RT_OID_802_11_SET_STA_CONFIG (Burst=%d,BGprot=%d,ShortSlot=%d,Adhoc=%d,Protection=%d\n",
+					pStaConfig->EnableTxBurst,
+					pStaConfig->UseBGProtection,
+					pStaConfig->UseShortSlotTime,
+					pStaConfig->AdhocMode,
+					pAd->PortCfg.UseBGProtection);
+			}
+		    break;
+
+			case RT_OID_SET_PSM_BIT_SAVE:
+				MlmeSetPsmBit(pAd, PWR_SAVE);
+				RTMPSendNullFrame(pAd, pAd->PortCfg.TxRate);
+		    break;
+
+		    case RT_OID_SET_RADIO:
+			    if (pAd->PortCfg.bRadio == TRUE)
+                {
+				    MlmeRadioOn(pAd);
+				    // Update extra information
+				    pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+			    }
+			    else
+                {
+			        MlmeRadioOff(pAd);
+				    // Update extra information
+    			    pAd->ExtraInfo = SW_RADIO_OFF;
+    		    }
+		    break;
+
+			case RT_OID_RESET_FROM_ERROR:
+			case RT_OID_RESET_FROM_NDIS:
+			{
+				UINT	i = 0;
+
+				RTUSBRejectPendingPackets(pAd);//reject all NDIS packets waiting in TX queue
+				RTUSBCleanUpDataBulkOutQueue(pAd);
+				MlmeSuspend(pAd, FALSE);
+
+				//Add code to access necessary registers here.
+				//disable Rx
+				RTUSBWriteMACRegister(pAd, TXRX_CSR2, 1);
+				//Ask our device to complete any pending bulk in IRP.
+				while ((atomic_read(&pAd->PendingRx) > 0) ||
+                       (pAd->BulkOutPending[0] == TRUE) ||
+					   (pAd->BulkOutPending[1] == TRUE) ||
+					   (pAd->BulkOutPending[2] == TRUE) ||
+					   (pAd->BulkOutPending[3] == TRUE))
+
+				{
+				    if (atomic_read(&pAd->PendingRx) > 0)
+					{
+						DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+						RTUSB_VendorRequest(pAd,
+											0,
+											DEVICE_VENDOR_REQUEST_OUT,
+											0x0C,
+											0x0,
+											0x0,
+											NULL,
+											0);
+					}
+
+					if ((pAd->BulkOutPending[0] == TRUE) ||
+						(pAd->BulkOutPending[1] == TRUE) ||
+						(pAd->BulkOutPending[2] == TRUE) ||
+						(pAd->BulkOutPending[3] == TRUE))
+					{
+						DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+						if (i == 0)
+						{
+							RTUSBCancelPendingBulkOutIRP(pAd);
+							i++;
+						}
+					}
+
+					RTMPusecDelay(500000);
+				}
+
+				NICResetFromError(pAd);
+				if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR))
+				{
+					RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR);
+				}
+				if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET))
+				{
+					RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
+				}
+				if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
+				{
+					RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				}
+
+				RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+				if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+				{
+					MlmeResume(pAd);
+					RTUSBBulkReceive(pAd);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x7e);
+				}
+			}
+			break;
+
+			case RT_OID_LINK_DOWN:
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(RT_OID_LINK_DOWN)\n");
+				LinkDown(pAd, TRUE);
+			break;
+
+			case RT_OID_VENDOR_WRITE_BBP:
+			{
+				UCHAR	Offset, Value;
+				Offset = *((PUCHAR)pData);
+				Value = *((PUCHAR)(pData + 1));
+				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%02x	value = 0x%02x\n", Offset, Value);
+				RTUSBWriteBBPRegister(pAd, Offset, Value);
+			}
+			break;
+
+			case RT_OID_VENDOR_READ_BBP:
+			{
+				UCHAR	Offset = *((PUCHAR)pData);
+				PUCHAR	pValue = (PUCHAR)(pData + 1);
+
+				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%02x\n", Offset);
+				RTUSBReadBBPRegister(pAd, Offset, pValue);
+				DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%02x\n", *pValue);
+			}
+			break;
+
+			case RT_OID_VENDOR_WRITE_RF:
+			{
+				ULONG	Value = *((PULONG)pData);
+
+				DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%08x\n", Value);
+				RTUSBWriteRFRegister(pAd, Value);
+			}
+			break;
+
+			case RT_OID_802_11_RESET_COUNTERS:
+			{
+				UCHAR	Value[22];
+
+				RTUSBMultiRead(pAd, STA_CSR0, Value, 24);
+			}
+			break;
+
+			case RT_OID_USB_VENDOR_RESET:
+				RTUSB_VendorRequest(pAd,
+									0,
+									DEVICE_VENDOR_REQUEST_OUT,
+									1,
+									1,
+									0,
+									NULL,
+									0);
+			break;
+
+			case RT_OID_USB_VENDOR_UNPLUG:
+				RTUSB_VendorRequest(pAd,
+									0,
+									DEVICE_VENDOR_REQUEST_OUT,
+									1,
+									2,
+									0,
+									NULL,
+									0);
+			break;
+#if 0
+			case RT_OID_USB_VENDOR_SWITCH_FUNCTION:
+				RTUSBWriteMACRegister(pAd, MAC_CSR13, 0x2121);
+				RTUSBWriteMACRegister(pAd, MAC_CSR14, 0x1e1e);
+				RTUSBWriteMACRegister(pAd, MAC_CSR1, 3);
+				RTUSBWriteMACRegister(pAd, PHY_CSR4, 0xf);
+
+				RTUSB_VendorRequest(pAd,
+									0,
+									DEVICE_VENDOR_REQUEST_OUT,
+									1,
+									3,
+									0,
+									NULL,
+									0);
+			break;
+#endif
+			case RT_OID_VENDOR_FLIP_IQ:
+			{
+				ULONG	Value1, Value2;
+				RTUSBReadMACRegister(pAd, PHY_CSR5, &Value1);
+				RTUSBReadMACRegister(pAd, PHY_CSR6, &Value2);
+				if (*pData == 1)
+				{
+					DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Flip\n");
+					Value1 = Value1 | 0x0004;
+					Value2 = Value2 | 0x0004;
+				}
+				else
+				{
+					DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Not Flip\n");
+					Value1 = Value1 & 0xFFFB;
+					Value2 = Value2 & 0xFFFB;
+				}
+				RTUSBWriteMACRegister(pAd, PHY_CSR5, Value1);
+				RTUSBWriteMACRegister(pAd, PHY_CSR6, Value2);
+			}
+			break;
+
+			case RT_OID_UPDATE_TX_RATE:
+				MlmeUpdateTxRates(pAd, FALSE);
+				if (ADHOC_ON(pAd))
+					MakeIbssBeacon(pAd);
+			break;
+
+			case RT_OID_802_11_PREAMBLE:
+			{
+				ULONG	Preamble = *((PULONG)(cmdqelmt->buffer));
+				if (Preamble == Rt802_11PreambleShort)
+				{
+					pAd->PortCfg.TxPreamble = Preamble;
+					MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
+				}
+				else if ((Preamble == Rt802_11PreambleLong) || (Preamble == Rt802_11PreambleAuto))
+				{
+					// if user wants AUTO, initialize to LONG here, then change according to AP's
+					// capability upon association.
+					pAd->PortCfg.TxPreamble = Preamble;
+					MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
+				}
+				else
+					NdisStatus = NDIS_STATUS_FAILURE;
+				DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::RT_OID_802_11_SET_PREAMBLE (=%d)\n", Preamble);
+			}
+			break;
+			case OID_802_11_NETWORK_TYPE_IN_USE:
+			{
+				NDIS_802_11_NETWORK_TYPE	NetType = *(PNDIS_802_11_NETWORK_TYPE)(cmdqelmt->buffer);
+				if (NetType == Ndis802_11DS)
+					RTMPSetPhyMode(pAd, PHY_11B);
+				else if (NetType == Ndis802_11OFDM24)
+					RTMPSetPhyMode(pAd, PHY_11BG_MIXED);
+				else if (NetType == Ndis802_11OFDM5)
+					RTMPSetPhyMode(pAd, PHY_11A);
+				else
+					NdisStatus = NDIS_STATUS_FAILURE;
+				DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_NETWORK_TYPE_IN_USE (=%d)\n",NetType);
+
+            }
+            break;
+			case RT_OID_802_11_PHY_MODE:
+				{
+					ULONG	phymode = *(ULONG *)(cmdqelmt->buffer);
+					RTMPSetPhyMode(pAd, phymode);
+					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::RT_OID_802_11_SET_PHY_MODE (=%d)\n", phymode);
+				}
+			break;
+
+#if 0
+			case OID_802_11_WEP_STATUS:
+				{
+					USHORT	Value;
+					NDIS_802_11_WEP_STATUS	WepStatus = *(PNDIS_802_11_WEP_STATUS)pData;
+
+					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::66- OID_802_11_WEP_STATUS  \n");
+			break;
+
+					if (pAd->PortCfg.WepStatus != WepStatus)
+					{
+						DBGPRINT(RT_DEBUG_ERROR, "Config Changed !!status= %x  \n", WepStatus);
+
+						// Config has changed
+						pAd->bConfigChanged = TRUE;
+					}
+					pAd->PortCfg.WepStatus   = WepStatus;
+					pAd->PortCfg.PairCipher  = WepStatus;
+				    pAd->PortCfg.GroupCipher = WepStatus;
+
+#if 1
+					if ((WepStatus == Ndis802_11Encryption1Enabled) &&
+						(pAd->SharedKey[pAd->PortCfg.DefaultKeyId].KeyLen != 0))
+					{
+						if (pAd->SharedKey[pAd->PortCfg.DefaultKeyId].KeyLen <= 5)
+						{
+							DBGPRINT(RT_DEBUG_ERROR, "WEP64!  \n");
+
+							pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg = CIPHER_WEP64;
+						}
+						else
+						{
+							DBGPRINT(RT_DEBUG_ERROR, "WEP128!  \n");
+
+							pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg = CIPHER_WEP128;
+						}
+#if 0
+						RTUSBReadMACRegister_old(pAd, TXRX_CSR0, &Value);
+						Value &= 0xfe00;
+						Value |= ((LENGTH_802_11 << 3) | (pAd->PortCfg.CipherAlg));
+						RTUSBWriteMACRegister_old(pAd, TXRX_CSR0, Value);
+#endif
+					}
+					else if (WepStatus == Ndis802_11Encryption2Enabled)
+					{
+						DBGPRINT(RT_DEBUG_ERROR, " TKIP !!!  \n");
+
+						pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg = CIPHER_TKIP;
+#if 0
+						RTUSBReadMACRegister_old(pAd, TXRX_CSR0, &Value);
+						Value &= 0xfe00;
+						Value |= ((LENGTH_802_11 << 3) | (pAd->PortCfg.CipherAlg));
+						RTUSBWriteMACRegister_old(pAd, TXRX_CSR0, Value);
+#endif
+					}
+					else if (WepStatus == Ndis802_11Encryption3Enabled)
+					{
+						DBGPRINT(RT_DEBUG_ERROR, " AES  !!!  \n");
+						pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg = CIPHER_AES;
+#if 0
+						RTUSBReadMACRegister_old(pAd, TXRX_CSR0, &Value);
+						Value &= 0xfe00;
+						Value |= ((LENGTH_802_11 << 3) | (pAd->PortCfg.CipherAlg));
+						RTUSBWriteMACRegister_old(pAd, TXRX_CSR0, Value);
+#endif
+					}
+					else if (WepStatus == Ndis802_11EncryptionDisabled)
+					{
+						DBGPRINT(RT_DEBUG_ERROR, " CIPHER_NONE  !!!  \n");
+
+						pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg = CIPHER_NONE;
+#if 0
+						RTUSBReadMACRegister_old(pAd, TXRX_CSR0, &Value);
+						Value &= 0xfe00;
+						RTUSBWriteMACRegister_old(pAd, TXRX_CSR0, Value);
+#endif
+					}else
+					{
+						DBGPRINT(RT_DEBUG_ERROR, " ERROR Cipher   !!!  \n");
+					}
+#endif
+				}
+			break;
+#endif
+			case OID_802_11_ADD_WEP:
+			{
+				ULONG	KeyIdx;
+				PNDIS_802_11_WEP	pWepKey;
+
+				DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_WEP  \n");
+
+				pWepKey = (PNDIS_802_11_WEP)pData;
+				KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
+
+				// it is a shared key
+				if ((KeyIdx >= 4) || ((pWepKey->KeyLength != 5) && (pWepKey->KeyLength != 13)))
+				{
+					NdisStatus = NDIS_STATUS_FAILURE;
+					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_ADD_WEP, INVALID_DATA!!\n");
+				}
+				else
+				{
+					UCHAR CipherAlg;
+					pAd->SharedKey[KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
+					memcpy(pAd->SharedKey[KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+					CipherAlg = (pAd->SharedKey[KeyIdx].KeyLen == 5)? CIPHER_WEP64 : CIPHER_WEP128;
+					pAd->SharedKey[KeyIdx].CipherAlg = CipherAlg;
+					if (pWepKey->KeyIndex & 0x80000000)
+					{
+						// Default key for tx (shared key)
+						pAd->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+					}
+					AsicAddSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx, CipherAlg, pWepKey->KeyMaterial, NULL, NULL);
+					DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_WEP (KeyIdx=%d, Len=%d-byte)\n", KeyIdx, pWepKey->KeyLength);
+				}
+			}
+			break;
+
+			case OID_802_11_REMOVE_WEP:
+			{
+				ULONG		KeyIdx;
+
+
+				KeyIdx = *(NDIS_802_11_KEY_INDEX *) pData;
+				if (KeyIdx & 0x80000000)
+				{
+					NdisStatus = NDIS_STATUS_FAILURE;
+					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_WEP, INVALID_DATA!!\n");
+				}
+				else
+				{
+					KeyIdx = KeyIdx & 0x0fffffff;
+					if (KeyIdx >= 4)
+					{
+						NdisStatus = NDIS_STATUS_FAILURE;
+						DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_WEP, Invalid KeyIdx[=%d]!!\n", KeyIdx);
+					}
+					else
+					{
+						pAd->SharedKey[KeyIdx].KeyLen = 0;
+						pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+						AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx);
+						DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_REMOVE_WEP (KeyIdx=%d)\n", KeyIdx);
+					}
+				}
+			}
+			break;
+
+			case OID_802_11_ADD_KEY_WEP:
+			{
+				PNDIS_802_11_KEY		pKey;
+				ULONG					i, KeyIdx;
+
+				pKey = (PNDIS_802_11_KEY) pData;
+				KeyIdx = pKey->KeyIndex & 0x0fffffff;
+
+				// it is a shared key
+			    if (KeyIdx >= 4)
+				{
+			        NdisStatus = NDIS_STATUS_FAILURE;
+			        DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_ADD_KEY_WEP, Invalid KeyIdx[=%d]!!\n", KeyIdx);
+			    }
+			    else
+			    {
+			        UCHAR CipherAlg;
+
+			        pAd->SharedKey[KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+			        memcpy(pAd->SharedKey[KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+
+			        if (pKey->KeyLength == 5)
+				        CipherAlg = CIPHER_WEP64;
+				    else
+				        CipherAlg = CIPHER_WEP128;
+
+				    // always expand the KEY to 16-byte here for efficiency sake. so that in case CKIP is used
+				    // sometime later we don't have to do key expansion for each TX in RTUSBHardTransmit().
+				    // However, we shouldn't change pAd->SharedKey[BSS0][KeyIdx].KeyLen
+				    if (pKey->KeyLength < 16)
+				    {
+				        for(i = 1; i < (16 / pKey->KeyLength); i++)
+				        {
+				            memcpy(&pAd->SharedKey[KeyIdx].Key[i * pKey->KeyLength],
+										   &pKey->KeyMaterial[0],
+										   pKey->KeyLength);
+				        }
+					    memcpy(&pAd->SharedKey[KeyIdx].Key[i * pKey->KeyLength],
+									   &pKey->KeyMaterial[0],
+									   16 - (i * pKey->KeyLength));
+				    }
+
+				    pAd->SharedKey[KeyIdx].CipherAlg = CipherAlg;
+				    if (pKey->KeyIndex & 0x80000000)
+					{
+				        // Default key for tx (shared key)
+					    pAd->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+				    }
+
+				    AsicAddSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx, CipherAlg, pAd->SharedKey[KeyIdx].Key, NULL, NULL);
+				    DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_KEY_WEP (KeyIdx=%d, KeyLen=%d, CipherAlg=%d)\n",
+				        pAd->PortCfg.DefaultKeyId, pAd->SharedKey[KeyIdx].KeyLen, pAd->SharedKey[KeyIdx].CipherAlg);
+				}
+			}
+			break;
+
+			case OID_802_11_ADD_KEY:
+			{
+                PNDIS_802_11_KEY	pkey = (PNDIS_802_11_KEY)pData;
+
+				NdisStatus = RTMPWPAAddKeyProc(pAd, pkey);
+				RTUSBBulkReceive(pAd);
+				DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_KEY\n");
+			}
+			break;
+
+#if 0
+			case RT_OID_802_11_REMOVE_WEP:
+			case OID_802_11_REMOVE_WEP:
+			{
+				ULONG  KeyIdx;
+
+
+				KeyIdx = *(NDIS_802_11_KEY_INDEX *) pData;
+				if (KeyIdx & 0x80000000)
+				{
+					NdisStatus = NDIS_STATUS_FAILURE;
+					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_WEP, INVALID_DATA!!\n");
+				}
+				else
+				{
+					KeyIdx = KeyIdx & 0x0fffffff;
+					if (KeyIdx >= 4)
+					{
+						NdisStatus = NDIS_STATUS_FAILURE;
+						DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_WEP, INVALID_DATA!!\n");
+					}
+						else
+					{
+
+					}
+				}
+			}
+			break;
+#if 0
+			{
+				//PNDIS_802_11_REMOVE_KEY  pRemoveKey;
+				ULONG  KeyIdx;
+				//pRemoveKey = (PNDIS_802_11_REMOVE_KEY) pData;
+				//KeyIdx = pRemoveKey->KeyIndex;
+
+
+				DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_WEP\n");
+				//if (InformationBufferLength != sizeof(NDIS_802_11_KEY_INDEX))
+				//	Status = NDIS_STATUS_INVALID_LENGTH;
+				//else
+				{
+					KeyIdx = *(NDIS_802_11_KEY_INDEX *) pData;
+
+					if (KeyIdx & 0x80000000)
+					{
+						// Should never set default bit when remove key
+						//Status = NDIS_STATUS_INVALID_DATA;
+					}
+					else
+					{
+						KeyIdx = KeyIdx & 0x0fffffff;
+						if (KeyIdx >= 4)
+						{
+							//Status = NDIS_STATUS_INVALID_DATA;
+						}
+						else
+						{
+							pAd->SharedKey[KeyIdx].KeyLen = 0;
+							//Status = RT2573USBEnqueueCmdFromNdis(pAd, OID_802_11_REMOVE_WEP, TRUE, pInformationBuffer, InformationBufferLength);
+
+							AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx);
+						}
+					}
+				}
+			}
+			break;
+#endif
+#endif
+			case OID_802_11_REMOVE_KEY:
+			{
+				PNDIS_802_11_REMOVE_KEY  pRemoveKey;
+				ULONG  KeyIdx;
+
+				pRemoveKey = (PNDIS_802_11_REMOVE_KEY) pData;
+				if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+				{
+					NdisStatus = RTMPWPARemoveKeyProc(pAd, pData);
+					DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::RTMPWPARemoveKeyProc\n");
+				}
+				else
+				{
+					KeyIdx = pRemoveKey->KeyIndex;
+
+					if (KeyIdx & 0x80000000)
+					{
+						// Should never set default bit when remove key
+						NdisStatus = NDIS_STATUS_FAILURE;
+						DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_KEY, Invalid KeyIdx[=%d]!!\n", KeyIdx);
+					}
+					else
+					{
+						KeyIdx = KeyIdx & 0x0fffffff;
+						if (KeyIdx >= 4)
+						{
+							NdisStatus = NDIS_STATUS_FAILURE;
+							DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_REMOVE_KEY, Invalid KeyIdx[=%d]!!\n", KeyIdx);
+						}
+						else
+						{
+							pAd->SharedKey[KeyIdx].KeyLen = 0;
+							pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+							AsicRemoveSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx);
+							DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::AsicRemoveSharedKeyEntry(KeyIdx=%d)\n", KeyIdx);
+						}
+					}
+				}
+
+			}
+			break;
+
+			case OID_802_11_POWER_MODE:
+			{
+				NDIS_802_11_POWER_MODE PowerMode = *(PNDIS_802_11_POWER_MODE) pData;
+				DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_POWER_MODE (=%d)\n",PowerMode);
+
+				// save user's policy here, but not change PortCfg.Psm immediately
+				if (PowerMode == Ndis802_11PowerModeCAM)
+				{
+					// clear PSM bit immediately
+					MlmeSetPsmBit(pAd, PWR_ACTIVE);
+
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
+					if (pAd->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAd->PortCfg.WindowsPowerMode = PowerMode;
+					pAd->PortCfg.WindowsBatteryPowerMode = PowerMode;
+				}
+				else if (PowerMode == Ndis802_11PowerModeMAX_PSP)
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckPsmChange()
+					// to exclude certain situations.
+					//     MlmeSetPsmBit(pAd, PWR_SAVE);
+					if (pAd->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAd->PortCfg.WindowsPowerMode = PowerMode;
+					pAd->PortCfg.WindowsBatteryPowerMode = PowerMode;
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
+					pAd->PortCfg.DefaultListenCount = 5;
+				}
+				else if (PowerMode == Ndis802_11PowerModeFast_PSP)
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckPsmChange()
+					// to exclude certain situations.
+					//     MlmeSetPsmBit(pAd, PWR_SAVE);
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
+					if (pAd->PortCfg.bWindowsACCAMEnable == FALSE)
+						pAd->PortCfg.WindowsPowerMode = PowerMode;
+					pAd->PortCfg.WindowsBatteryPowerMode = PowerMode;
+					pAd->PortCfg.DefaultListenCount = 3;
+				}
+			}
+			break;
+
+			case RT_PERFORM_SOFT_DIVERSITY:
+				AsicRxAntEvalAction(pAd);
+			break;
+
+		    case RT_OID_FORCE_WAKE_UP:
+			    AsicForceWakeup(pAd);
+			break;
+
+		    case RT_OID_SET_PSM_BIT_ACTIVE:
+			    MlmeSetPsmBit(pAd, PWR_ACTIVE);
+		    break;
+
+			default:
+			break;
+		}
+
+
+		if (cmdqelmt->CmdFromNdis == TRUE)
+		{
+
+			if ((cmdqelmt->command != OID_802_11_BSSID_LIST_SCAN) &&
+				(cmdqelmt->command != RT_OID_802_11_BSSID) &&
+				(cmdqelmt->command != OID_802_11_SSID) &&
+				(cmdqelmt->command != OID_802_11_DISASSOCIATE))
+			{
+			}
+
+			if ((cmdqelmt->command != RT_OID_MULTI_READ_MAC) &&
+				(cmdqelmt->command != RT_OID_VENDOR_READ_BBP) &&
+#ifdef DBG
+				(cmdqelmt->command != RT_OID_802_11_QUERY_HARDWARE_REGISTER) &&
+#endif
+				(cmdqelmt->command != RT_OID_USB_VENDOR_EEPROM_READ))
+			{
+#if 1
+
+				if (cmdqelmt->buffer != NULL){
+					kfree(cmdqelmt->buffer);
+				}
+#endif
+			}
+#if 1
+			if(cmdqelmt != NULL){
+				kfree((PCmdQElmt)cmdqelmt);
+			}
+#endif
+		}
+		else{
+			cmdqelmt->InUse = FALSE;
+		}
+
+
+	}
+
+
+}
+
+#ifdef RT2X00DEBUGFS
+/*
+ * Ethtool handlers.
+ */
+#define CSR_REG_BASE			0x3000
+#define CSR_REG_SIZE			0x04b0
+#define EEPROM_BASE			0x0000
+#define EEPROM_SIZE			0x0100
+#define BBP_SIZE			0x0080
+
+
+static void rt73usb_read_csr(void *dev, const unsigned long word,
+		void *data)
+{
+	RTMP_ADAPTER *pAd = dev;
+
+	RTUSBReadMACRegister(pAd, CSR_REG_BASE + (word * sizeof(u32)), (u32*)data);
+}
+
+static void rt73usb_write_csr(void *dev, const unsigned long word,
+	void *data)
+{
+	RTMP_ADAPTER *pAd = dev;
+
+	RTUSBWriteMACRegister(pAd, word, *((u32*)data));
+}
+
+static void rt73usb_read_eeprom(void *dev, const unsigned long word,
+		void *data)
+{
+	RTMP_ADAPTER *pAd = dev;
+
+	RTUSBReadEEPROM(pAd, word * sizeof(u16), ((u8*)data), 2);
+}
+
+static void rt73usb_write_eeprom(void *dev, const unsigned long word,
+	void *data)
+{
+	/* DANGEROUS, DON'T DO THIS! */
+}
+
+static void rt73usb_read_bbp(void *dev, const unsigned long word,
+		void *data)
+{
+	RTMP_ADAPTER *pAd = dev;
+
+	RTUSBReadBBPRegister(pAd, (u8)word, ((u8*)data));
+}
+
+static void rt73usb_write_bbp(void *dev, const unsigned long word,
+	void *data)
+{
+	RTMP_ADAPTER *pAd = dev;
+
+	RTUSBWriteBBPRegister(pAd, word, *((u8*)data));
+}
+
+static void rt73usb_open_debugfs(RTMP_ADAPTER *pAd)
+{
+	struct rt2x00debug *debug = &pAd->debug;
+
+	debug->owner 			= THIS_MODULE;
+	debug->mod_name			= DRIVER_NAME;
+	debug->mod_version		= DRIVER_VERSION;
+	debug->reg_csr.read		= rt73usb_read_csr;
+	debug->reg_csr.write		= rt73usb_write_csr;
+	debug->reg_csr.word_size	= sizeof(u32);
+	debug->reg_csr.length		= CSR_REG_SIZE;
+	debug->reg_eeprom.read		= rt73usb_read_eeprom;
+	debug->reg_eeprom.write		= rt73usb_write_eeprom;
+	debug->reg_eeprom.word_size	= sizeof(u16);
+	debug->reg_eeprom.length	= EEPROM_SIZE;
+	debug->reg_bbp.read		= rt73usb_read_bbp;
+	debug->reg_bbp.write		= rt73usb_write_bbp;
+	debug->reg_bbp.word_size	= sizeof(u8);
+	debug->reg_bbp.length		= BBP_SIZE;
+	debug->dev 			= pAd;
+
+	snprintf(debug->intf_name, sizeof(debug->intf_name),
+		"%s", pAd->net_dev->name);
+
+	if (rt2x00debug_register(debug))
+		printk(KERN_ERR "Failed to register debug handler.\n");
+}
+
+static void rt73usb_close_debugfs(RTMP_ADAPTER *pAd)
+{
+	rt2x00debug_deregister(&pAd->debug);
+}
+#else /* RT2X00DEBUGFS */
+static inline void rt73usb_open_debugfs(RTMP_ADAPTER *pAd){}
+static inline void rt73usb_close_debugfs(RTMP_ADAPTER *pAd){}
+#endif /* RT2X00DEBUGFS */
+
+static int usb_rtusb_open(struct net_device *net_dev)
+{
+	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
+	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
+	UCHAR           TmpPhy;
+	int ret = 0;
+
+	printk("rt73 driver version - %s\n", DRIVER_VERSION);
+	if ( !OPSTATUS_TEST_FLAG (pAd,fOP_STATUS_FIRMWARE_LOAD) ) {
+		DBGPRINT(RT_DEBUG_ERROR, "Firmware not load");
+		ret = -EIO;
+		goto out_firmware_error;
+	}
+
+	init_MUTEX(&(pAd->usbdev_semaphore));
+
+	// init mediastate to disconnected
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+
+	pAd->rx_bh.func = RTUSBRxPacket;
+	pAd->rx_bk.func = rtusb_bulkrx;
+
+	// Initialize pAd->PortCfg to manufacture default
+	PortCfgInit(pAd);
+
+
+	// Init  RTMP_ADAPTER CmdQElements
+	Status = RTMPInitAdapterBlock(pAd);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		return Status;
+	}
+
+    //
+	// Init send data structures and related parameters
+    //
+	Status = NICInitTransmit(pAd);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		return Status;
+	}
+
+	//
+	// Init receive data structures and related parameters
+	//
+	Status = NICInitRecv(pAd);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		goto out;
+	}
+
+	// Initialize Asics
+	NICInitializeAsic(pAd);
+
+	//
+	// Read additional info from NIC such as MAC address
+	// This function must called after register CSR base address
+	//
+#ifdef	INIT_FROM_EEPROM
+	NICReadEEPROMParameters(pAd);
+	NICInitAsicFromEEPROM(pAd);
+#endif
+	RTUSBWriteHWMACAddress(pAd);
+
+	// external LNA has different R17 base
+	if (pAd->NicConfig2.field.ExternalLNA)
+	{
+		pAd->BbpTuning.R17LowerBoundA += 0x10;
+		pAd->BbpTuning.R17UpperBoundA += 0x10;
+		pAd->BbpTuning.R17LowerBoundG += 0x10;
+		pAd->BbpTuning.R17UpperBoundG += 0x10;
+	}
+
+	// hardware initialization after all parameters are acquired from
+	// Registry or E2PROM
+	TmpPhy = pAd->PortCfg.PhyMode;
+	pAd->PortCfg.PhyMode = 0xff;
+	RTMPSetPhyMode(pAd, TmpPhy);
+
+
+	//
+	// initialize MLME
+    //
+	Status = MlmeInit(pAd);
+	if(Status != NDIS_STATUS_SUCCESS)
+	{
+		goto out;
+	}
+
+	// mlmethread & RTUSBCmd flag restart
+	mlme_kill = 0;
+	RTUSBCmd_kill = 0;
+
+	CreateThreads(net_dev);
+
+	// at every open handler, copy mac address.
+	if (!memcmp(net_dev->dev_addr, "\x00\x00\x00\x00\x00\x00", 6))
+		memcpy(pAd->net_dev->dev_addr, pAd->CurrentAddress, pAd->net_dev->addr_len);
+	else
+		memcpy(pAd->CurrentAddress, pAd->net_dev->dev_addr, pAd->net_dev->addr_len);
+
+	// Clear Reset Flag before starting receiving/transmitting
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+	{
+		RTUSBBulkReceive(pAd);
+        RTUSBWriteMACRegister(pAd, TXRX_CSR0, 0x025eb032);    // enable RX of MAC block, Staion not drop control frame
+        // Initialize RF register to default value
+	    AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+	    AsicLockChannel(pAd, pAd->PortCfg.Channel);
+	}
+
+
+    // USB_ID info for UI
+    pAd->VendorDesc = 0x148F2573;
+
+	// Start net_dev interface tx /rx
+	netif_start_queue(net_dev);
+
+	netif_carrier_on(net_dev);
+	netif_wake_queue(net_dev);
+	return 0;
+
+
+out:
+	ReleaseAdapter(pAd, TRUE, FALSE);
+out_firmware_error:
+	return ret;
+
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int usb_rtusb_close(struct net_device *net_dev)
+{
+	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
+	int             ret;
+	int		i = 0;
+
+	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup);
+	DECLARE_WAITQUEUE (wait, current);
+
+	DBGPRINT(RT_DEBUG_TRACE,"-->rt73_close\n");
+
+	netif_carrier_off(pAd->net_dev);
+	netif_stop_queue(pAd->net_dev);
+
+	DBGPRINT(RT_DEBUG_INFO,"Ensure there are no more active urbs \n");
+	// ensure there are no more active urbs.
+	add_wait_queue (&unlink_wakeup, &wait);
+	pAd->wait = &unlink_wakeup;
+	// maybe wait for deletions to finish.
+	while ((i < 10) && atomic_read(&pAd->PendingRx) > 0) {
+		//msleep(UNLINK_TIMEOUT_MS);
+		i++;
+		DBGPRINT (RT_DEBUG_INFO,"waited for %d urb to complete\n", atomic_read(&pAd->PendingRx));
+	}
+	pAd->wait = NULL;
+	remove_wait_queue (&unlink_wakeup, &wait);
+
+	if (pAd->MLMEThr_pid >= 0)
+	{
+		mlme_kill = 1;
+		RTUSBMlmeUp(pAd);
+		wmb(); // need to check
+		ret = kill_proc (pAd->MLMEThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
+			//return ret;		Fix process killing
+		}
+		wait_for_completion (&pAd->notify);
+	}
+	if (pAd->RTUSBCmdThr_pid>= 0)
+	{
+		RTUSBCmd_kill = 1;
+		RTUSBCMDUp(pAd);
+		wmb(); // need to check
+		ret = kill_proc (pAd->RTUSBCmdThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
+			//return ret;		Fix process killing
+		}
+	    wait_for_completion (&pAd->notify);
+	}
+
+	RTUSBHalt(pAd, TRUE);
+	DBGPRINT(RT_DEBUG_TRACE,"<--rt73_close\n");
+
+	return 0;
+}
+
+INT MlmeThread(
+    IN void * Context)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
+
+	daemonize();
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAd->notify));
+#if 1
+	while (1)
+	{
+		//if(down_interruptible(&pAd->mlme_semaphore))
+			//break;
+
+		/* lock the device pointers */
+		down(&(pAd->mlme_semaphore));
+
+		if (mlme_kill)
+			break;
+
+		/* lock the device pointers , need to check if required*/
+		down(&(pAd->usbdev_semaphore));
+		MlmeHandler(pAd);
+
+		/* unlock the device pointers */
+		up(&(pAd->usbdev_semaphore));
+	}
+#else
+	// I tried this way for thread handling
+	while(1)
+	{
+		timeout = next_tick;
+		do {
+			timeout = interruptible_sleep_on_timeout (&pAd->MLMEThr_wait, timeout);
+			/* make swsusp happy with our thread */
+			if (current->flags & PF_FREEZE)
+				refrigerator(PF_FREEZE);
+			DBGPRINT(RT_DEBUG_TRACE, "current->flags  = 0x%x\n",current->flags );
+		} while (!signal_pending (current) && (timeout > 0));
+
+		if (signal_pending (current)) {
+			flush_signals(current);
+		}
+
+		if (mlme_kill)
+			break;
+	}
+#endif
+
+	/* notify the exit routine that we're actually exiting now
+	 *
+	 * complete()/wait_for_completion() is similar to up()/down(),
+	 * except that complete() is safe in the case where the structure
+	 * is getting deleted in a parallel mode of execution (i.e. just
+	 * after the down() -- that's necessary for the thread-shutdown
+	 * case.
+	 *
+	 * complete_and_exit() goes even further than this -- it is safe in
+	 * the case that the thread of the caller is going away (not just
+	 * the structure) -- this is necessary for the module-remove case.
+	 * This is important in preemption kernels, which transfer the flow
+	 * of execution immediately upon a complete().
+	 */
+	complete_and_exit (&pAd->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+
+}
+INT RTUSBCmdThread(
+    IN void * Context)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
+
+	daemonize();
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAd->notify));
+
+	while (1)
+	{
+		//if(down_interruptible(&pAd->mlme_semaphore))
+			//break;
+
+		/* lock the device pointers */
+		down(&(pAd->RTUSBCmd_semaphore));
+
+		if (RTUSBCmd_kill)
+			break;
+
+		/* lock the device pointers , need to check if required*/
+		down(&(pAd->usbdev_semaphore));
+		CMDHandler(pAd);
+
+		/* unlock the device pointers */
+		up(&(pAd->usbdev_semaphore));
+	}
+
+	/* notify the exit routine that we're actually exiting now
+	 *
+	 * complete()/wait_for_completion() is similar to up()/down(),
+	 * except that complete() is safe in the case where the structure
+	 * is getting deleted in a parallel mode of execution (i.e. just
+	 * after the down() -- that's necessary for the thread-shutdown
+	 * case.
+	 *
+	 * complete_and_exit() goes even further than this -- it is safe in
+	 * the case that the thread of the caller is going away (not just
+	 * the structure) -- this is necessary for the module-remove case.
+	 * This is important in preemption kernels, which transfer the flow
+	 * of execution immediately upon a complete().
+	 */
+	complete_and_exit (&pAd->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBCmdThread\n");
+
+}
+
+static void *usb_rtusb_probe(struct usb_device *dev, UINT interface,
+				const struct usb_device_id *id_table)
+{
+		PRTMP_ADAPTER       pAd;
+	int                 i;
+	struct net_device   *netdev;
+	int                 res = -ENOMEM;
+
+	for (i = 0; i < rtusb_usb_id_len; i++)
+	{
+		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
+			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "idVendor = 0x%x, idProduct = 0x%x \n",
+					le16_to_cpu(dev->descriptor.idVendor),
+					le16_to_cpu(dev->descriptor.idProduct));
+			break;
+		}
+	}
+	if (i == rtusb_usb_id_len) {
+		printk("Device Descriptor not matching\n");
+		goto out_noalloc;
+	}
+
+	/* RTMP_ADAPTER is too big with 64-bit pointers, and using the
+	   builtin net_device private area causes the allocation to
+	   exceed 128KB and fail.  So we allocate it separately. */
+	pAd = kzalloc(sizeof (*pAd), GFP_KERNEL);
+	if (!pAd) {
+		printk("couldn't allocate RTMP_ADAPTER\n");
+		goto out_noalloc;
+	}
+
+	netdev = alloc_etherdev(0);
+	if (!netdev) {
+		goto out_nonetdev;
+	}
+
+	netdev->priv = pAd;
+	pAd->net_dev = netdev;
+	netif_stop_queue(netdev);
+	pAd->config = dev->config;
+	pAd->pUsb_Dev= dev;
+	SET_MODULE_OWNER(netdev);
+	ether_setup(netdev);
+
+	netdev->open = usb_rtusb_open;
+	netdev->hard_start_xmit = RTMPSendPackets;
+	netdev->stop = usb_rtusb_close;
+	netdev->priv = pAd;
+	netdev->get_stats = rt73_get_ether_stats;
+#if WIRELESS_EXT >= 15
+#if WIRELESS_EXT < 17
+	netdev->get_wireless_stats = rt73_get_wireless_stats;
+#endif
+	netdev->wireless_handlers = (struct iw_handler_def *) &rt73_iw_handler_def;
+#endif
+	netdev->do_ioctl = rt73_ioctl;
+	netdev->hard_header_len = 14;
+	netdev->mtu = 1500;
+	netdev->addr_len = 6;
+#if WIRELESS_EXT >= 15
+	netdev->weight = 64;
+#endif
+
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+
+	{// find available
+		int 	i=0;
+		char	slot_name[IFNAMSIZ];
+		struct  net_device	*device;
+		struct  usb_interface *ifp= &dev->actconfig->interface[interface];  // get interface from system
+        struct  usb_interface_descriptor *as;
+        struct  usb_endpoint_descriptor *ep;
+
+		for (i = 0; i < 8; i++)
+		{
+			sprintf(slot_name, "wlan%d", i);
+
+			read_lock_bh(&dev_base_lock); // avoid multiple init
+			for (device = first_net_device(); device != NULL;
+					device = next_net_device(device))
+			{
+				if (strncmp(device->name, slot_name, 4) == 0)
+				{
+					break;
+				}
+			}
+			read_unlock_bh(&dev_base_lock);
+
+			if(device == NULL)	break;
+		}
+		if(i == 8)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
+			goto out;
+		}
+
+		sprintf(netdev->name, "wlan%d", i);
+		DBGPRINT(RT_DEBUG_ERROR, "usb device name %s\n",netdev->name);
+
+        /* get Max Packet Size from usb_dev endpoint */
+//        ifp = dev->actconfig->interface + i;
+        as = ifp->altsetting + ifp->act_altsetting;
+        ep = as->endpoint;
+
+        pAd->BulkOutMaxPacketSize = (USHORT)ep[i].wMaxPacketSize;
+        DBGPRINT(RT_DEBUG_TRACE, "BulkOutMaxPacketSize  %d\n", pAd->BulkOutMaxPacketSize);
+
+
+	}
+
+	//pAd->rx_bh.data = (unsigned long)pAd;
+	pAd->rx_bh.func = RTUSBRxPacket;
+	pAd->rx_bk.func = rtusb_bulkrx;
+
+	res = register_netdev(netdev);
+	if (res) {
+		printk("register_netdev failed err=%d\n",res);
+		goto out;
+	}
+
+	return pAd;
+
+out:
+	free_netdev(netdev);
+out_nonetdev:
+	kfree(pAd);
+out_noalloc:
+	MOD_DEC_USE_COUNT;
+	usb_dec_dev_use(dev);
+	return NULL;
+}
+
+//Disconnect function is called within exit routine
+static void usb_rtusb_disconnect(struct usb_device *dev, void *ptr)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) ptr;
+
+
+	if (!pAd)
+		return;
+
+	tasklet_kill(&pAd->rx_bh);
+	tasklet_kill(&pAd->rx_bk);
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
+	// for debug, wait to show some messages to /proc system
+	udelay(1);
+	//After Add Thread implementation, Upon exec there, pAd->net_dev seems becomes NULL,
+	//need to check why???
+	//assert(pAd->net_dev != NULL)
+	if(pAd->net_dev != NULL)
+	{
+		printk("unregister_netdev()\n");
+		unregister_netdev (pAd->net_dev);
+	}
+	udelay(1);
+	udelay(1);
+
+	while (MOD_IN_USE > 0) {
+		MOD_DEC_USE_COUNT;
+	}
+	udelay(1);
+	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
+
+}
+
+#else
+static int usb_rtusb_close(struct net_device *net_dev)
+{
+	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
+	int             ret;
+	int	            i = 0;
+
+	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup);
+	DECLARE_WAITQUEUE (wait, current);
+
+	DBGPRINT(RT_DEBUG_TRACE,"-->rt73_close \n");
+
+	netif_carrier_off(pAd->net_dev);
+	netif_stop_queue(pAd->net_dev);
+
+	// ensure there are no more active urbs.
+	add_wait_queue (&unlink_wakeup, &wait);
+	pAd->wait = &unlink_wakeup;
+
+	// maybe wait for deletions to finish.
+	while ((i < 25) && atomic_read(&pAd->PendingRx) > 0) {
+#if LINUX_VERSION_CODE >KERNEL_VERSION(2,6,9)
+
+		msleep(UNLINK_TIMEOUT_MS);
+#endif
+		i++;
+	}
+	pAd->wait = NULL;
+	remove_wait_queue (&unlink_wakeup, &wait);
+
+	if (pAd->MLMEThr_pid >= 0)
+	{
+		mlme_kill = 1;
+		RTUSBMlmeUp(pAd);
+		wmb(); // need to check
+		ret = kill_proc (pAd->MLMEThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
+			//return ret;
+		}
+		wait_for_completion (&pAd->notify);
+	}
+	if (pAd->RTUSBCmdThr_pid>= 0)
+	{
+		RTUSBCmd_kill = 1;
+		RTUSBCMDUp(pAd);
+		wmb(); // need to check
+		ret = kill_proc (pAd->RTUSBCmdThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
+			//return ret;
+		}
+		wait_for_completion (&pAd->notify);
+	}
+	RTUSBHalt(pAd, TRUE);
+
+	DBGPRINT(RT_DEBUG_TRACE,"<--rt73_close \n");
+
+	return 0;
+}
+
+INT MlmeThread(
+    IN void * Context)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
+
+	daemonize("rt73");
+	allow_signal(SIGTERM);
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAd->notify));
+
+	while (1)
+	{
+		//if(down_interruptible(&pAd->mlme_semaphore))
+			//break;
+
+		/* lock the device pointers */
+		down(&(pAd->mlme_semaphore));
+
+		if (mlme_kill)
+			break;
+
+		/* lock the device pointers , need to check if required*/
+		down(&(pAd->usbdev_semaphore));
+
+		MlmeHandler(pAd);
+
+		/* unlock the device pointers */
+		up(&(pAd->usbdev_semaphore));
+	}
+
+	/* notify the exit routine that we're actually exiting now
+	 *
+	 * complete()/wait_for_completion() is similar to up()/down(),
+	 * except that complete() is safe in the case where the structure
+	 * is getting deleted in a parallel mode of execution (i.e. just
+	 * after the down() -- that's necessary for the thread-shutdown
+	 * case.
+	 *
+	 * complete_and_exit() goes even further than this -- it is safe in
+	 * the case that the thread of the caller is going away (not just
+	 * the structure) -- this is necessary for the module-remove case.
+	 * This is important in preemption kernels, which transfer the flow
+	 * of execution immediately upon a complete().
+	 */
+	complete_and_exit (&pAd->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+}
+
+INT RTUSBCmdThread(
+    IN void * Context)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
+
+	daemonize("rt73");
+	allow_signal(SIGTERM);
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAd->notify));
+
+	while (1)
+	{
+		//if(down_interruptible(&pAd->mlme_semaphore))
+			//break;
+
+		/* lock the device pointers */
+		down(&(pAd->RTUSBCmd_semaphore));
+
+		if (RTUSBCmd_kill)
+			break;
+
+		/* lock the device pointers , need to check if required*/
+		down(&(pAd->usbdev_semaphore));
+
+		CMDHandler(pAd);
+
+		/* unlock the device pointers */
+		up(&(pAd->usbdev_semaphore));
+	}
+
+	/* notify the exit routine that we're actually exiting now
+	 *
+	 * complete()/wait_for_completion() is similar to up()/down(),
+	 * except that complete() is safe in the case where the structure
+	 * is getting deleted in a parallel mode of execution (i.e. just
+	 * after the down() -- that's necessary for the thread-shutdown
+	 * case.
+	 *
+	 * complete_and_exit() goes even further than this -- it is safe in
+	 * the case that the thread of the caller is going away (not just
+	 * the structure) -- this is necessary for the module-remove case.
+	 * This is important in preemption kernels, which transfer the flow
+	 * of execution immediately upon a complete().
+	 */
+	complete_and_exit (&pAd->notify, 0);
+}
+
+static int usb_rtusb_probe (struct usb_interface *intf,
+					  const struct usb_device_id *id)
+{
+	struct usb_device   *dev = interface_to_usbdev(intf);
+	PRTMP_ADAPTER       pAd;
+	int                 i;
+	struct net_device   *netdev;
+	int                 res = -ENOMEM;
+
+	usb_get_dev(dev);
+	for (i = 0; i < rtusb_usb_id_len; i++)
+	{
+		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
+			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
+		{
+			/* printk("idVendor = 0x%x, idProduct = 0x%x \n",
+					le16_to_cpu(dev->descriptor.idVendor),
+					le16_to_cpu(dev->descriptor.idProduct));
+			*/
+			break;
+		}
+	}
+	if (i == rtusb_usb_id_len) {
+		printk("Device Descriptor not matching\n");
+		goto out_noalloc;
+	}
+
+	/* RTMP_ADAPTER is too big with 64-bit pointers, and using the
+	   builtin net_device private area causes the allocation to
+	   exceed 128KB and fail.  So we allocate it separately. */
+	pAd = kzalloc(sizeof (*pAd), GFP_KERNEL);
+	if (!pAd) {
+		printk("couldn't allocate RTMP_ADAPTER\n");
+		goto out_noalloc;
+	}
+
+	netdev = alloc_etherdev(0);
+	if (!netdev) {
+		printk("alloc_etherdev failed\n");
+		goto out_nonetdev;
+	}
+
+	netdev->priv = pAd;
+	pAd->net_dev = netdev;
+	netif_stop_queue(netdev);
+	pAd->config = &dev->config->desc;
+	pAd->pUsb_Dev = dev;
+	SET_MODULE_OWNER(netdev);
+	ether_setup(netdev);
+
+	netdev->open = usb_rtusb_open;
+	netdev->stop = usb_rtusb_close;
+	netdev->priv = pAd;
+	netdev->hard_start_xmit = RTMPSendPackets;
+	netdev->get_stats = rt73_get_ether_stats;
+
+#if WIRELESS_EXT >= 12
+#if WIRELESS_EXT < 17
+	netdev->get_wireless_stats = rt73_get_wireless_stats;
+#endif
+	netdev->wireless_handlers = (struct iw_handler_def *) &rt73_iw_handler_def;
+#endif
+	netdev->do_ioctl = rt73_ioctl;
+
+	netdev->hard_header_len = 14;
+	netdev->mtu = 1500;
+	netdev->addr_len = 6;
+	netdev->weight = 64;
+
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+
+	pAd->MLMEThr_pid= -1;
+	pAd->RTUSBCmdThr_pid= -1;
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+
+	{// find available
+		int 	i=0;
+		char	slot_name[IFNAMSIZ];
+		//struct  net_device	*device;
+        struct  usb_host_interface *iface_desc;
+        struct  usb_endpoint_descriptor *endpoint;
+
+
+		for (i = 0; i < 8; i++)
+		{
+			sprintf(slot_name, "wlan%d", i);
+
+#if 1
+			if(dev_get_by_name(slot_name)==NULL)
+				break;
+#else
+			read_lock_bh(&dev_base_lock); // avoid multiple init
+			for (device = first_net_device(); device != NULL;
+					device = next_net_device(device))
+			{
+				if (strncmp(device->name, slot_name, 4) == 0)
+				{
+					break;
+				}
+			}
+			read_unlock_bh(&dev_base_lock);
+
+			if(device == NULL)	break;
+#endif
+		}
+		if(i == 8)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
+			return res;
+		}
+
+		sprintf(pAd->net_dev->name, "wlan%d", i);
+		DBGPRINT(RT_DEBUG_ERROR, "usb device name %s\n", pAd->net_dev->name);
+
+
+        /* get the active interface descriptor */
+        iface_desc = intf->cur_altsetting;
+
+        /* check out the endpoint: it has to be Interrupt & IN */
+        endpoint = &iface_desc->endpoint[i].desc;
+
+        /* get Max Packet Size from endpoint */
+        pAd->BulkOutMaxPacketSize = (USHORT)endpoint->wMaxPacketSize;
+        DBGPRINT(RT_DEBUG_TRACE, "BulkOutMaxPacketSize  %d\n", pAd->BulkOutMaxPacketSize);
+
+	}
+
+    //bottom half data is assign at  each task_scheduler
+	//pAd->rx_bh.data = (unsigned long)pAd;
+	pAd->rx_bh.func = RTUSBRxPacket;
+
+
+	res = register_netdev(netdev);
+	if (res) {
+		printk("register_netdev failed err=%d\n",res);
+		goto out;
+	}
+
+	usb_set_intfdata(intf, pAd);
+
+
+	rt73usb_open_debugfs(pAd);
+	res = LoadFirmware(pAd, firmName);
+	if (res) {
+		DBGPRINT(RT_DEBUG_ERROR, "Failed to request Firmware.\n");
+		goto out;
+	}
+	return 0;
+
+out:
+	free_netdev(netdev);
+out_nonetdev:
+	kfree(pAd);
+out_noalloc:
+	module_put(THIS_MODULE);
+	return res;
+}
+
+static void usb_rtusb_disconnect(struct usb_interface *intf)
+{
+	struct usb_device   *dev = interface_to_usbdev(intf);
+	PRTMP_ADAPTER       pAd = (PRTMP_ADAPTER)NULL;
+
+	pAd = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
+	DBGPRINT(RT_DEBUG_ERROR,"unregister usbnet usb-%s-%s\n",
+		dev->bus->bus_name, dev->devpath);
+	if (!pAd)
+		return;
+
+	rt73usb_close_debugfs(pAd);
+
+	tasklet_kill(&pAd->rx_bh);
+	tasklet_kill(&pAd->rx_bk);
+	// for debug, wait to show some messages to /proc system
+	udelay(1);
+	//After Add Thread implementation, Upon exec there, pAd->net_dev seems becomes NULL,
+	//need to check why???
+	//assert(pAd->net_dev != NULL)
+	if(pAd->net_dev!= NULL)
+	{
+		//printk("unregister_netdev()\n");
+		unregister_netdev (pAd->net_dev);
+	}
+	udelay(1);
+	flush_scheduled_work ();
+	udelay(1);
+
+	free_netdev(pAd->net_dev);
+	kfree(pAd);
+	usb_put_dev(dev);
+	udelay(1);
+	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
+
+}
+#endif
+
+
+//
+// Driver module load function
+//
+INT __init usb_rtusb_init(void)
+{
+    //printk("rtusb init ====>\n");
+	#ifdef DBG
+    RTDebugLevel = debug;
+	#else
+	if (debug) {}	// keep compiler from complaining
+	#endif
+	if ( strlen(firmName)  > FIRMWARE_NAME_MAX ) {
+		DBGPRINT(RT_DEBUG_ERROR,"Firmware name too long\n");
+		return -E2BIG;
+	}
+	return usb_register(&rtusb_driver);
+}
+
+//
+// Driver module unload function
+//
+VOID __exit usb_rtusb_exit(void)
+{
+	udelay(1);
+	udelay(1);
+	usb_deregister(&rtusb_driver);
+
+	//printk("<=== rtusb exit\n");
+}
+
+static int __init rt73_wlan_opt(char *str)
+{
+	if (!str || !*str)
+		return -EINVAL;
+
+	if (!strncmp(str, "debug:", 6)) {
+		debug = simple_strtoul(str + 6, NULL, 0);
+	}
+
+	return 0;
+}
+
+/**************************************/
+__setup("rt73wlan=", rt73_wlan_opt);
+module_init(usb_rtusb_init);
+module_exit(usb_rtusb_exit);
+/**************************************/
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_tkip.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_tkip.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_tkip.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_tkip.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,545 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_tkip.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Wu		02-25-02	Initial
+ *
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+// Rotation functions on 32 bit values
+#define ROL32( A, n ) \
+	( ((A) << (n)) | ( ((A)>>(32-(n))) & ( (1UL << (n)) - 1 ) ) )
+#define ROR32( A, n ) ROL32( (A), 32-(n) )
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Convert from UCHAR[] to ULONG in a portable way
+
+	Arguments:
+      pMICKey		pointer to MIC Key
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+ULONG	RTMPTkipGetUInt32(
+	IN	PUCHAR	pMICKey)
+{
+	ULONG	res = 0;
+	INT		i;
+
+	for (i = 0; i < 4; i++)
+	{
+		res |= (*pMICKey++) << (8 * i);
+	}
+
+	return res;
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Convert from ULONG to UCHAR[] in a portable way
+
+	Arguments:
+      pDst			pointer to destination for convert ULONG to UCHAR[]
+      val			the value for convert
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPTkipPutUInt32(
+	IN OUT	PUCHAR		pDst,
+	IN		ULONG		val)
+{
+	INT i;
+
+	for(i = 0; i < 4; i++)
+	{
+		*pDst++ = (UCHAR) (val & 0xff);
+		val >>= 8;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Set the MIC Key.
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+      pMICKey		pointer to MIC Key
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID    RTMPTkipSetMICKey(
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	PUCHAR			pMICKey)
+{
+	// Set the key
+	pTkip->K0 = RTMPTkipGetUInt32(pMICKey);
+	pTkip->K1 = RTMPTkipGetUInt32(pMICKey + 4);
+	// and reset the message
+	pTkip->L = pTkip->K0;
+	pTkip->R = pTkip->K1;
+	pTkip->nBytesInM = 0;
+	pTkip->M = 0;
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculate the MIC Value.
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+      uChar			Append this uChar
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPTkipAppendByte(
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	UCHAR 			uChar)
+{
+	// Append the byte to our word-sized buffer
+	pTkip->M |= (uChar << (8* pTkip->nBytesInM));
+	pTkip->nBytesInM++;
+	// Process the word if it is full.
+	if( pTkip->nBytesInM >= 4 )
+	{
+		pTkip->L ^= pTkip->M;
+		pTkip->R ^= ROL32( pTkip->L, 17 );
+		pTkip->L += pTkip->R;
+		pTkip->R ^= ((pTkip->L & 0xff00ff00) >> 8) | ((pTkip->L & 0x00ff00ff) << 8);
+		pTkip->L += pTkip->R;
+		pTkip->R ^= ROL32( pTkip->L, 3 );
+		pTkip->L += pTkip->R;
+		pTkip->R ^= ROR32( pTkip->L, 2 );
+		pTkip->L += pTkip->R;
+		// Clear the buffer
+		pTkip->M = 0;
+		pTkip->nBytesInM = 0;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculate the MIC Value.
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+      pSrc			Pointer to source data for Calculate MIC Value
+      Len			Indicate the length of the source data
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPTkipAppend(
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	PUCHAR			pSrc,
+	IN	UINT			nBytes)
+{
+	// This is simple
+	while(nBytes > 0)
+	{
+		RTMPTkipAppendByte(pTkip, *pSrc++);
+		nBytes--;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Get the MIC Value.
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		the MIC Value is store in pAdapter->PrivateInfo.MIC
+	========================================================================
+*/
+VOID	RTMPTkipGetMIC(
+	IN	PTKIP_KEY_INFO	pTkip)
+{
+	// Append the minimum padding
+	RTMPTkipAppendByte(pTkip, 0x5a );
+	RTMPTkipAppendByte(pTkip, 0 );
+	RTMPTkipAppendByte(pTkip, 0 );
+	RTMPTkipAppendByte(pTkip, 0 );
+	RTMPTkipAppendByte(pTkip, 0 );
+	// and then zeroes until the length is a multiple of 4
+	while( pTkip->nBytesInM != 0 )
+	{
+		RTMPTkipAppendByte(pTkip, 0 );
+	}
+	// The appendByte function has already computed the result.
+	RTMPTkipPutUInt32(pTkip->MIC, pTkip->L);
+	RTMPTkipPutUInt32(pTkip->MIC + 4, pTkip->R);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Init Tkip function.
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
+		KeyId		TK Key ID
+		pTA			Pointer to transmitter address
+		pMICKey		pointer to MIC Key
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPInitTkipEngine(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pKey,
+	IN	UCHAR			KeyId,
+	IN	PUCHAR			pTA,
+	IN	PUCHAR			pMICKey,
+	IN	PUCHAR			pTSC,
+	OUT	PULONG			pIV16,
+	OUT	PULONG			pIV32)
+{
+	TKIP_IV	tkipIv;
+
+	// Prepare 8 bytes TKIP encapsulation for MPDU
+	memset(&tkipIv, 0, sizeof(TKIP_IV));
+	tkipIv.IV16.field.rc0 = *(pTSC + 1);
+	tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;
+	tkipIv.IV16.field.rc2 = *pTSC;
+	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
+	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
+	memcpy(&tkipIv.IV32, (pTSC + 2), 4);   // Copy IV
+
+	*pIV16 = tkipIv.IV16.word;
+	*pIV32 = tkipIv.IV32;
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Init MIC Value calculation function which include set MIC key &
+		calculate first 16 bytes (DA + SA + priority +  0)
+
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPInitMICEngine(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pKey,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN  UCHAR           UserPriority,
+	IN	PUCHAR			pMICKey)
+{
+	ULONG Priority = UserPriority;
+
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Tx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pDA, MAC_ADDR_LEN);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSA, MAC_ADDR_LEN);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, (PUCHAR)&Priority, 4);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Compare MIC value of received MSDU
+
+	Arguments:
+		pAdapter	Pointer to our adapter
+		pSrc        Pointer to the received Plain text data
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+		Len         the length of the received plain text data exclude MIC value
+
+	Return Value:
+		TRUE        MIC value matched
+		FALSE       MIC value mismatched
+
+	Note:
+
+	========================================================================
+*/
+BOOLEAN	    RTMPTkipCompareMICValue(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len)
+{
+	UCHAR	OldMic[8];
+	ULONG	Priority = 0;
+	INT		i;
+
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Rx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pDA, MAC_ADDR_LEN);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, (PUCHAR)&Priority, 4);
+
+	// Calculate MIC value from plain text data
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSrc, Len);
+
+	// Get MIC valude from received frame
+	memcpy(OldMic, pSrc + Len, 8);
+
+	// Get MIC value from decrypted plain data
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Rx);
+
+	// Move MIC value from MSDU, this steps should move to data path.
+	// Since the MIC value might cross MPDUs.
+	if(!NdisEqualMemory(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Orig MIC value =");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated MIC value =");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		return (FALSE);
+	}
+	return (TRUE);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Compare MIC value of received MSDU
+
+	Arguments:
+		pAdapter	Pointer to our adapter
+		pLLC		LLC header
+		pSrc        Pointer to the received Plain text data
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+		Len         the length of the received plain text data exclude MIC value
+
+	Return Value:
+		TRUE        MIC value matched
+		FALSE       MIC value mismatched
+
+	Note:
+
+	========================================================================
+*/
+BOOLEAN	    RTMPTkipCompareMICValueWithLLC(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	PUCHAR			pLLC,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len)
+{
+	UCHAR	OldMic[8];
+	ULONG	Priority = 0;
+	INT		i;
+
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Rx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pDA, MAC_ADDR_LEN);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, (PUCHAR)&Priority, 4);
+
+	// Start with LLC header
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pLLC, 8);
+
+	// Calculate MIC value from plain text data
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSrc, Len);
+
+	// Get MIC valude from received frame
+	memcpy(OldMic, pSrc + Len, 8);
+
+	// Get MIC value from decrypted plain data
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Rx);
+
+	// Move MIC value from MSDU, this steps should move to data path.
+	// Since the MIC value might cross MPDUs.
+	if(!NdisEqualMemory(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Orig MIC value =");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated MIC value =");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		return (FALSE);
+	}
+	return (TRUE);
+}
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set
+	appropriate ASIC register to kick hardware transmit function
+
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		PNDIS_PACKET	Pointer to Ndis Packet for MIC calculation
+		pEncap			Pointer to LLC encap data
+		LenEncap		Total encap length, might be 0 which indicates no encap
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPCalculateMICValue(
+	IN	PRTMP_ADAPTER	pAdapter,
+	IN	struct sk_buff  *pSkb,
+	IN	PUCHAR			pEncap,
+	IN	PCIPHER_KEY		pKey)
+{
+	PVOID			pVirtualAddress;
+	UINT			Length;
+	PUCHAR			pSrc;
+    UCHAR           UserPriority;
+
+	pVirtualAddress = pSkb->data;
+	Length = pSkb->len;
+
+    UserPriority = RTMP_GET_PACKET_UP(pSkb);
+	pSrc = (PUCHAR) pVirtualAddress;
+
+	// Start Calculate MIC Value
+	RTMPInitMICEngine(
+		pAdapter,
+		pKey->Key,
+		pSrc,
+		pSrc + 6,
+		UserPriority,
+		pKey->TxMic);
+
+	if (pEncap != NULL)
+	{
+		// LLC encapsulation
+		RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pEncap, 6);
+		// Protocol Type
+		RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc + 12, 2);
+	}
+	Length -= 14;
+	pSrc += 14;
+	do
+	{
+		if (Length > 0)
+		{
+			RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc, Length);
+		}
+	}	while (FALSE);		// End of copying payload
+
+	// Compute the final MIC Value
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Tx);
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_type.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_type.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_type.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_type.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,180 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_type.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Lin	1-2-2004
+ *
+ ***************************************************************************/
+
+#ifndef __RTMP_TYPE_H__
+#define __RTMP_TYPE_H__
+
+// Put platform dependent declaration here
+// For example, linux type definition
+
+//#ifdef  Linux
+typedef u16      UINT16;
+typedef u32      UINT32;
+typedef u64      UINT64;
+//#endif
+
+#ifndef Win32
+#define Win32
+
+#undef  BIG_ENDIAN          // Only little endian for WIN32 system
+
+//
+// Following type define have been already define in
+// %include%\basetsd.h     eg. c:\winddk\3790\inc\wxp\basetsd.h
+//     Defined  Win2k      WinXP
+//     UINT16     X           O
+//     UINT32     O           O
+//     UINT64     X           O
+#ifdef NDIS50_MINIPORT
+
+typedef unsigned short      UINT16;
+//typedef   unsigned long       UINT32;
+typedef unsigned __int64    UINT64;
+
+#endif //#ifdef NDIS50_MINIPORT
+
+#endif //#ifndef Win32
+
+
+// Endian byte swapping codes
+#define SWAP16(x) \
+    ((UINT16)( \
+    (((UINT16)(x) & (UINT16) 0x00ffU) << 8) | \
+    (((UINT16)(x) & (UINT16) 0xff00U) >> 8) ))
+
+#define SWAP32(x) \
+    ((UINT32)( \
+    (((UINT32)(x) & (UINT32) 0x000000ffUL) << 24) | \
+    (((UINT32)(x) & (UINT32) 0x0000ff00UL) <<  8) | \
+    (((UINT32)(x) & (UINT32) 0x00ff0000UL) >>  8) | \
+    (((UINT32)(x) & (UINT32) 0xff000000UL) >> 24) ))
+
+#define SWAP64(x) \
+    ((UINT64)( \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00000000000000ffULL) << 56) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x000000000000ff00ULL) << 40) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x0000000000ff0000ULL) << 24) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00000000ff000000ULL) <<  8) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x000000ff00000000ULL) >>  8) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x0000ff0000000000ULL) >> 24) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00ff000000000000ULL) >> 40) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0xff00000000000000ULL) >> 56) ))
+
+#ifdef BIG_ENDIAN
+#define PACKED  __attribute__ ((packed))
+
+#define cpu2le64(x) SWAP64((x))
+#define le2cpu64(x) SWAP64((x))
+#define cpu2le32(x) SWAP32((x))
+#define le2cpu32(x) SWAP32((x))
+#define cpu2le16(x) SWAP16((x))
+#define le2cpu16(x) SWAP16((x))
+#define cpu2be64(x) ((UINT64)(x))
+#define be2cpu64(x) ((UINT64)(x))
+#define cpu2be32(x) ((UINT32)(x))
+#define be2cpu32(x) ((UINT32)(x))
+#define cpu2be16(x) ((UINT16)(x))
+#define be2cpu16(x) ((UINT16)(x))
+
+#else   // Little_Endian
+
+
+#ifdef RTMP_EMBEDDED
+#define PACKED  __attribute__ ((packed))
+#else
+#define PACKED
+#endif  // RTMP_EMBEDDED
+
+
+#define cpu2le64(x) ((UINT64)(x))
+#define le2cpu64(x) ((UINT64)(x))
+#define cpu2le32(x) ((UINT32)(x))
+#define le2cpu32(x) ((UINT32)(x))
+#define cpu2le16(x) ((UINT16)(x))
+#define le2cpu16(x) ((UINT16)(x))
+#define cpu2be64(x) SWAP64((x))
+#define be2cpu64(x) SWAP64((x))
+#define cpu2be32(x) SWAP32((x))
+#define be2cpu32(x) SWAP32((x))
+#define cpu2be16(x) SWAP16((x))
+#define be2cpu16(x) SWAP16((x))
+
+#endif  // BIG_ENDIAN
+
+
+// Ralink timer control block
+typedef struct  _RALINK_TIMER_STRUCT    {
+	struct timer_list	 Timer;
+	ULONG				TimerValue;		// Timer value in milliseconds
+	BOOLEAN				State;			// True if timer cancelled
+}   RALINK_TIMER_STRUCT, *PRALINK_TIMER_STRUCT;
+
+typedef struct	PACKED _RSN_IE_HEADER_STRUCT	{
+	UCHAR		Eid;
+	UCHAR		Length;
+	USHORT		Version;	// Little endian format
+}	RSN_IE_HEADER_STRUCT, *PRSN_IE_HEADER_STRUCT;
+
+// Cipher suite selector types
+typedef struct PACKED _CIPHER_SUITE_STRUCT	{
+	UCHAR		Oui[3];
+	UCHAR		Type;
+}	CIPHER_SUITE_STRUCT, *PCIPHER_SUITE_STRUCT;
+
+// Authentication and Key Management suite selector
+typedef struct PACKED _AKM_SUITE_STRUCT	{
+	UCHAR		Oui[3];
+	UCHAR		Type;
+}	AKM_SUITE_STRUCT, *PAKM_SUITE_STRUCT;
+
+#ifdef BIG_ENDIAN
+typedef struct	_RSN_CAPABILITY	{
+	USHORT		PreAuth:1;
+	USHORT		NoPairwise:1;
+	USHORT		PTKSAReplayCnt:2;
+	USHORT		GTKSAReplayCnt:2;
+	USHORT		Rsv:10;
+}	RSN_CAPABILITY, *PRSN_CAPABILITY;
+#else
+// RSN capability
+typedef struct	_RSN_CAPABILITY	{
+	USHORT		Rsv:10;
+	USHORT		GTKSAReplayCnt:2;
+	USHORT		PTKSAReplayCnt:2;
+	USHORT		NoPairwise:1;
+	USHORT		PreAuth:1;
+}	RSN_CAPABILITY, *PRSN_CAPABILITY;
+#endif /* !BIG_ENDIAN */
+
+#endif	// __RTMP_TYPE_H__
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_wep.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_wep.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtmp_wep.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtmp_wep.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,388 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtmp_wep.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Wu		10-28-02	Initial
+ *
+ ***************************************************************************/
+
+#include    "rt_config.h"
+
+ULONG FCSTAB_32[256] =
+{
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
+    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
+    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
+    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
+    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
+    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
+    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
+    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
+    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
+    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
+    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
+    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
+    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
+    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
+    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
+    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
+    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
+    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
+    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
+    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
+    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
+    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
+    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
+    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
+    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
+    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
+    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
+    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
+    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
+    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
+    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
+    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
+    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
+    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
+    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
+    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
+    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
+    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
+    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
+    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
+    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+UCHAR   WEPKEY[] = {
+        //IV
+        0x00, 0x11, 0x22,
+        //WEP KEY
+        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
+    };
+
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Init WEP function.
+
+    Arguments:
+      pAdapter      Pointer to our adapter
+        pKey        Pointer to the WEP KEY
+        KeyId       WEP Key ID
+        KeyLen      the length of WEP KEY
+        pDest       Pointer to the destination which Encryption data will store in.
+
+    Return Value:
+        None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    RTMPInitWepEngine(
+    IN  PRTMP_ADAPTER   pAdapter,
+    IN  PUCHAR          pKey,
+    IN  UCHAR           KeyId,
+    IN  UCHAR           KeyLen,
+    IN OUT  PUCHAR      pDest)
+{
+    UINT i;
+
+    pAdapter->PrivateInfo.FCSCRC32 = PPPINITFCS32;   //Init crc32.
+    memcpy(WEPKEY + 3, pKey, KeyLen);
+
+    for(i = 0; i < 3; i++)
+        WEPKEY[i] = RandomByte(pAdapter);   //Call mlme RandomByte() function.
+    ARCFOUR_INIT(&pAdapter->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);  //INIT SBOX, KEYLEN+3(IV)
+
+    memcpy(pDest, WEPKEY, 3);  //Append Init Vector
+    *(pDest+3) = (KeyId << 6);       //Append KEYID
+
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Encrypt transimitted data
+
+    Arguments:
+      pAdapter      Pointer to our adapter
+      pSrc          Pointer to the transimitted source data that will be encrypt
+      pDest         Pointer to the destination where entryption data will be store in.
+      Len           Indicate the length of the source data
+
+    Return Value:
+      None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    RTMPEncryptData(
+    IN  PRTMP_ADAPTER   pAdapter,
+    IN  PUCHAR          pSrc,
+    IN  PUCHAR          pDest,
+    IN  UINT            Len)
+{
+    pAdapter->PrivateInfo.FCSCRC32 = RTMP_CALC_FCS32(pAdapter->PrivateInfo.FCSCRC32, pSrc, Len);
+    ARCFOUR_ENCRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pDest, pSrc, Len);
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        The Stream Cipher Encryption Algorithm "ARCFOUR" initialize
+
+    Arguments:
+       Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+        pKey        Pointer to the WEP KEY
+        KeyLen      Indicate the length fo the WEP KEY
+
+    Return Value:
+       None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    ARCFOUR_INIT(
+    IN  PARCFOURCONTEXT Ctx,
+    IN  PUCHAR          pKey,
+    IN  UINT            KeyLen)
+{
+    UCHAR   t, u;
+    UINT    keyindex;
+    UINT    stateindex;
+    PUCHAR  state;
+    UINT    counter;
+
+    state = Ctx->STATE;
+    Ctx->X = 0;
+    Ctx->Y = 0;
+    for (counter = 0; counter < 256; counter++)
+        state[counter] = (UCHAR)counter;
+    keyindex = 0;
+    stateindex = 0;
+    for (counter = 0; counter < 256; counter++)
+    {
+        t = state[counter];
+        stateindex = (stateindex + pKey[keyindex] + t) & 0xff;
+        u = state[stateindex];
+        state[stateindex] = t;
+        state[counter] = u;
+        if (++keyindex >= KeyLen)
+            keyindex = 0;
+    }
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Get bytes from ARCFOUR CONTEXT (S-BOX)
+
+    Arguments:
+       Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+
+    Return Value:
+       UCHAR  - the value of the ARCFOUR CONTEXT (S-BOX)
+
+    Note:
+
+    ========================================================================
+*/
+UCHAR   ARCFOUR_BYTE(
+    IN  PARCFOURCONTEXT     Ctx)
+{
+  UINT x;
+  UINT y;
+  UCHAR sx, sy;
+  PUCHAR state;
+
+  state = Ctx->STATE;
+  x = (Ctx->X + 1) & 0xff;
+  sx = state[x];
+  y = (sx + Ctx->Y) & 0xff;
+  sy = state[y];
+  Ctx->X = x;
+  Ctx->Y = y;
+  state[y] = sx;
+  state[x] = sy;
+
+  return(state[(sx + sy) & 0xff]);
+
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        The Stream Cipher Decryption Algorithm
+
+    Arguments:
+        Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+        pDest           Pointer to the Destination
+        pSrc        Pointer to the Source data
+        Len         Indicate the length of the Source data
+
+    Return Value:
+        None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    ARCFOUR_DECRYPT(
+    IN  PARCFOURCONTEXT Ctx,
+    IN  PUCHAR          pDest,
+    IN  PUCHAR          pSrc,
+    IN  UINT            Len)
+{
+    UINT i;
+
+    for (i = 0; i < Len; i++)
+        pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        The Stream Cipher Encryption Algorithm
+
+    Arguments:
+        Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+        pDest           Pointer to the Destination
+        pSrc        Pointer to the Source data
+        Len         Indicate the length of the Source dta
+
+    Return Value:
+        None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    ARCFOUR_ENCRYPT(
+    IN  PARCFOURCONTEXT Ctx,
+    IN  PUCHAR          pDest,
+    IN  PUCHAR          pSrc,
+    IN  UINT            Len)
+{
+    UINT i;
+
+    for (i = 0; i < Len; i++)
+        pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Calculate a new FCS given the current FCS and the new data.
+
+    Arguments:
+        Fcs       the original FCS value
+        Cp          pointer to the data which will be calculate the FCS
+        Len         the length of the data
+
+    Return Value:
+        ULONG - FCS 32 bits
+
+    Note:
+
+    ========================================================================
+*/
+ULONG   RTMP_CALC_FCS32(
+    IN  ULONG   Fcs,
+    IN  PUCHAR  Cp,
+    IN  INT     Len)
+{
+    while (Len--)
+       Fcs = (((Fcs) >> 8) ^ FCSTAB_32[((Fcs) ^ (*Cp++)) & 0xff]);
+
+    return (Fcs);
+}
+
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Get last FCS and encrypt it to the destination
+
+    Arguments:
+        pDest           Pointer to the Destination
+
+    Return Value:
+        None
+
+    Note:
+
+    ========================================================================
+*/
+VOID    RTMPSetICV(
+    IN  PRTMP_ADAPTER   pAdapter,
+    IN  PUCHAR  pDest)
+{
+    pAdapter->PrivateInfo.FCSCRC32 ^= 0xffffffff;             /* complement */
+
+#ifdef BIG_ENDIAN
+    pAdapter->PrivateInfo.FCSCRC32 = SWAP32(pAdapter->PrivateInfo.FCSCRC32);
+#endif
+
+    ARCFOUR_ENCRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pDest, (PUCHAR) &pAdapter->PrivateInfo.FCSCRC32, 4);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_bulk.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_bulk.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_bulk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_bulk.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1321 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtusb_bulk.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	idamlaj		14-10-2006	RFMONTx (based on MarkW's code)
+ *
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+
+void RTusb_fill_bulk_urb (struct urb *pUrb,
+	struct usb_device *pUsb_Dev,
+	unsigned int bulkpipe,
+	void *pTransferBuf,
+	int BufSize,
+	usb_complete_t Complete,
+	void *pContext)
+{
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, Complete, pContext);
+#else
+	FILL_BULK_URB(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, Complete, pContext);
+#endif
+
+}
+
+// ************************ Completion Func ************************ //
+VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PTX_CONTEXT 	pTxContext;
+	PRTMP_ADAPTER	pAd;
+	NTSTATUS		status;
+	UCHAR			BulkOutPipeId;
+	unsigned long			IrqFlags;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutDataPacketComplete\n");
+	pTxContext= (PTX_CONTEXT)pUrb->context;
+	pAd = pTxContext->pAd;
+	status = pUrb->status;
+
+	// Store BulkOut PipeId
+	BulkOutPipeId = pTxContext->BulkOutPipeId;
+	pAd->BulkOutDataOneSecCount++;
+
+	if (status == USB_ST_NOERROR)
+	{
+		DBGPRINT_RAW(RT_DEBUG_INFO, "BulkOutDataPacketComplete %d (STATUS_SUCCESS)\n", BulkOutPipeId);
+
+		if (pTxContext->LastOne == TRUE)
+		{
+			pAd->Counters.GoodTransmits++;
+			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+            pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+
+			if (!skb_queue_empty(&pAd->SendTxWaitQueue[BulkOutPipeId]))
+			{
+				RTMPDeQueuePacket(pAd, BulkOutPipeId);
+			}
+		}
+		else
+		{
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+				pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+				// Indicate next one is frag data which has highest priority
+				RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
+			}
+			else
+			{
+				while (pTxContext->LastOne != TRUE)
+				{
+					FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+					pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+					pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+				}
+
+				FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+				pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+			}
+		}
+	}
+#if 1	// STATUS_OTHER
+	else
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "BulkOutDataPacketComplete %d (STATUS_OTHER)\n", BulkOutPipeId);
+
+		while (pTxContext->LastOne != TRUE)
+		{
+			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+			pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+		}
+		FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+		pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+		}
+
+	}
+#endif
+
+
+	pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+	//
+	// bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut
+	// bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out.
+	//
+	if ((pTxContext->bWaitingBulkOut == TRUE) && !RTUSB_TEST_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId)))
+	{
+		// Indicate There is data avaliable
+		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
+	}
+
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAd);
+}
+
+// NULL frame use BulkOutPipeId = 0
+VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PRTMP_ADAPTER	pAd;
+	PTX_CONTEXT		pNullContext;
+	NTSTATUS		status;
+	unsigned long			IrqFlags;
+
+	pNullContext= (PTX_CONTEXT)pUrb->context;
+	pAd = pNullContext->pAd;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrameComplete\n");
+
+	// Reset Null frame context flags
+	pNullContext->IRPPending = FALSE;
+	pNullContext->InUse = FALSE;
+
+	status = pUrb->status;
+
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTMPDeQueuePacket(pAd, 0);
+	}
+#if 1	// STATUS_OTHER
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	pAd->BulkOutPending[0] = FALSE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAd);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+
+}
+
+// RTS frame use BulkOutPipeId = PipeID
+VOID RTUSBBulkOutRTSFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PRTMP_ADAPTER	pAd;
+	PTX_CONTEXT		pRTSContext;
+	NTSTATUS		status;
+	unsigned long			IrqFlags;
+
+	pRTSContext= (PTX_CONTEXT)pUrb->context;
+	pAd = pRTSContext->pAd;
+
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutRTSFrameComplete\n");
+
+	// Reset RTS frame context flags
+	pRTSContext->IRPPending = FALSE;
+	pRTSContext->InUse = FALSE;
+
+	status = pUrb->status;
+
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTMPDeQueuePacket(pAd, pRTSContext->BulkOutPipeId);
+	}
+#if 1	// STATUS_OTHER
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out RTS Frame Failed\n");
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
+	pAd->BulkOutPending[pRTSContext->BulkOutPipeId] = FALSE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAd);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutRTSFrameComplete\n");
+
+}
+
+// MLME use BulkOutPipeId = 0
+VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PTX_CONTEXT			pMLMEContext;
+	PRTMP_ADAPTER		pAd;
+	NTSTATUS			status;
+	unsigned long				IrqFlags;
+
+	pMLMEContext= (PTX_CONTEXT)pUrb->context;
+	pAd = pMLMEContext->pAd;
+	status = pUrb->status;
+
+	pAd->PrioRingTxCnt--;
+	if (pAd->PrioRingTxCnt < 0)
+		pAd->PrioRingTxCnt = 0;
+
+	pAd->PrioRingFirstIndex++;
+	if (pAd->PrioRingFirstIndex >= PRIO_RING_SIZE)
+	{
+		pAd->PrioRingFirstIndex = 0;
+	}
+
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacketComplete::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
+			pAd->PrioRingFirstIndex,
+			pAd->PrioRingTxCnt, pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutMLMEPacketComplete\n");
+
+	// Reset MLME context flags
+	pMLMEContext->IRPPending	= FALSE;
+	pMLMEContext->InUse 		= FALSE;
+
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDequeueMLMEPacket(pAd);
+	}
+#if 1	// STATUS_OTHER
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out MLME Failed\n");
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	pAd->BulkOutPending[0] = FALSE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAd);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacketComplete\n");
+
+}
+
+// PS-Poll frame use BulkOutPipeId = 0
+VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+	PRTMP_ADAPTER	pAd;
+	PTX_CONTEXT		pPsPollContext;
+	NTSTATUS		status;
+	unsigned long			IrqFlags;
+
+	pPsPollContext= (PTX_CONTEXT)pUrb->context;
+	pAd = pPsPollContext->pAd;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutPsPollComplete\n");
+
+	// Reset PsPoll context flags
+	pPsPollContext->IRPPending	= FALSE;
+	pPsPollContext->InUse		= FALSE;
+
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTMPDeQueuePacket(pAd, 0);
+	}
+#if 1	// STATUS_OTHER
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out PSPoll Failed\n");
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	pAd->BulkOutPending[0] = FALSE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAd);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutPsPollComplete\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		This routine process Rx Irp and call rx complete function.
+
+	Arguments:
+		DeviceObject	Pointer to the device object for next lower
+						device. DeviceObject passed in here belongs to
+						the next lower driver in the stack because we
+						were invoked via IoCallDriver in USB_RxPacket
+						AND it is not OUR device object
+	  Irp				Ptr to completed IRP
+	  Context			Ptr to our Adapter object (context specified
+						in IoSetCompletionRoutine
+
+	Return Value:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+
+	Note:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+	========================================================================
+*/
+VOID RTUSBBulkRxComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PRX_CONTEXT 	pRxContext;
+	PRTMP_ADAPTER	pAd;
+	NTSTATUS		status;
+
+	pRxContext= (PRX_CONTEXT)pUrb->context;
+	pAd = pRxContext->pAd;
+
+	//
+	// We have a number of cases:
+	//		1) The USB read timed out and we received no data.
+	//		2) The USB read timed out and we received some data.
+	//		3) The USB read was successful and fully filled our irp buffer.
+	//		4) The irp was cancelled.
+	//		5) Some other failure from the USB device object.
+	//
+
+	//
+	// Free the IRP  and its mdl because they were	alloced by us
+	//
+#if 0
+	if ( (atomread = (atomic_read(&pRxContext->IrpLock))) == IRPLOCK_CANCE_START)
+	{
+		atomic_dec(&pAd->PendingRx);
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_COMPLETE);
+	}
+#endif
+	status = pUrb->status;
+	atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
+	atomic_dec(&pAd->PendingRx);
+
+	switch (status)
+	{
+		case 0:
+			 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+			{
+				//RTUSBRxPacket(pUrb);
+				pAd->rx_bh.data = (unsigned long)pUrb;
+				tasklet_schedule(&pAd->rx_bh);
+				break;
+
+			}// STATUS_SUCCESS
+			DBGPRINT(RT_DEBUG_INFO,"==> RTUSBBulkRxComplete  (IrpLock) = %d\n", atomic_read(&pRxContext->IrpLock));
+			break;
+
+		case -ECONNRESET:		// async unlink
+		case -ESHUTDOWN:		// hardware gone = -108
+			pUrb = NULL;
+			DBGPRINT(RT_DEBUG_ERROR,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+			//tasklet_schedule(&pAd->rx_bh);
+			break;
+
+	}
+#if 0
+	 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+	{
+		RTUSBRxPacket(pUrb);
+		//tasklet_schedule(&pAd->rx_bh);
+
+	}// STATUS_SUCCESS
+	else
+	{
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+		pRxContext->InUse = FALSE;
+
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk In Failed\n");
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
+		}
+	}
+
+#endif
+}
+
+VOID	RTUSBInitTxDesc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PTX_CONTEXT 	pTxContext,
+	IN	UCHAR			BulkOutPipeId,
+	IN	usb_complete_t	Func)
+{
+	PURB				pUrb;
+	PUCHAR				pSrc = NULL;
+
+	pUrb = pTxContext->pUrb;
+	ASSERT(pUrb);
+
+	// Store BulkOut PipeId
+	pTxContext->BulkOutPipeId = BulkOutPipeId;
+
+    pSrc = (PUCHAR) &pTxContext->TransferBuffer->TxDesc;
+
+
+	//Initialize a tx bulk urb
+	RTusb_fill_bulk_urb(pUrb,
+						pAd->pUsb_Dev,
+						usb_sndbulkpipe(pAd->pUsb_Dev, 1),
+						pSrc,
+						pTxContext->BulkOutSize,
+						Func,
+						pTxContext);
+
+}
+
+VOID	RTUSBInitRxDesc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PRX_CONTEXT		pRxContext)
+{
+	PURB				pUrb;
+
+	pUrb = pRxContext->pUrb;
+	ASSERT(pUrb);
+
+	//Initialize a rx bulk urb
+	RTusb_fill_bulk_urb(pUrb,
+						pAd->pUsb_Dev,
+						usb_rcvbulkpipe(pAd->pUsb_Dev, 1),
+						pRxContext->TransferBuffer,
+						BUFFER_SIZE,
+						RTUSBBulkRxComplete,
+						pRxContext);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBBulkOutDataPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			BulkOutPipeId,
+	IN	UCHAR			Index)
+{
+	PTX_CONTEXT	pTxContext;
+	PURB		pUrb;
+	int 		ret = 0;
+	unsigned long		IrqFlags;
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	if (pAd->BulkOutPending[BulkOutPipeId] == TRUE)
+	{
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		return;
+	}
+	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+
+	pTxContext = &(pAd->TxContext[BulkOutPipeId][Index]);
+
+	// Increase Total transmit byte counter
+	pAd->RalinkCounters.TransmittedByteCount +=  pTxContext->BulkOutSize;
+
+
+	// Clear Data flag
+	RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
+	RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
+
+	if (pTxContext->bWaitingBulkOut	!= TRUE)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, pTxContext->bWaitingBulkOut != TRUE, Index %d, NextBulkOutIndex %d\n",
+			Index, pAd->NextBulkOutIndex[BulkOutPipeId]);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		return;
+	}
+	else if (pTxContext->BulkOutSize == 0)
+	{
+		//
+		// This may happen on CCX Leap Ckip or Cmic
+		// When the Key was been set not on time.
+		// We will break it when the Key was Zero on RTUSBHardTransmit
+		// And this will cause deadlock that the TxContext always InUse.
+		//
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+
+		pTxContext->InUse	   = FALSE;
+		pTxContext->LastOne    = FALSE;
+		pTxContext->IRPPending = FALSE;
+		pTxContext->bWaitingBulkOut = FALSE;
+		pTxContext->BulkOutSize= 0;
+		pAd->NextBulkOutIndex[BulkOutPipeId] = (pAd->NextBulkOutIndex[BulkOutPipeId] + 1) % TX_RING_SIZE;
+		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+
+		return;
+	}
+	else if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
+			!(pAd->PortCfg.BssType == BSS_MONITOR && pAd->bAcceptRFMONTx==TRUE))
+	{
+		//
+		// Since there is no connection, so we need to empty the Tx Bulk out Ring.
+		//
+		while (atomic_read(&pAd->TxCount) > 0)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, since NdisMediaStateDisconnected discard NextBulkOutIndex %d, NextIndex = %d\n",
+				pAd->NextBulkOutIndex[BulkOutPipeId], pAd->NextTxIndex[BulkOutPipeId]);
+
+			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+			pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+		}
+
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+
+		return;
+	}
+
+
+	// Init Tx context descriptor
+	RTUSBInitTxDesc(pAd, pTxContext, BulkOutPipeId, RTUSBBulkOutDataPacketComplete);
+
+
+	pTxContext->IRPPending = TRUE;
+
+	pUrb = pTxContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Submit Tx URB failed %d\n", ret);
+		return;
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutDataPacket \n");
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note: NULL frame use BulkOutPipeId = 0
+
+	========================================================================
+*/
+VOID	RTUSBBulkOutNullFrame(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PTX_CONTEXT	pNullContext = &(pAd->NullContext);
+	PURB		pUrb;
+	int 		ret = 0;
+	unsigned long		IrqFlags;
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	if (pAd->BulkOutPending[0] == TRUE)
+	{
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		return;
+	}
+	pAd->BulkOutPending[0] = TRUE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	// Increase Total transmit byte counter
+	pAd->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrame \n");
+
+	// Clear Null frame bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
+
+
+	// Init Tx context descriptor
+	RTUSBInitTxDesc(pAd, pNullContext, 0, RTUSBBulkOutNullFrameComplete);
+	pNullContext->IRPPending = TRUE;
+
+	pUrb = pNullContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrame \n");
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBBulkOutRTSFrame(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PTX_CONTEXT	pRTSContext = &(pAd->RTSContext);
+	PURB		pUrb;
+	int 		ret = 0;
+	unsigned long		IrqFlags;
+	UCHAR		PipeID=0;
+
+	if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4))
+		PipeID= 3;
+	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3))
+		PipeID= 2;
+	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2))
+		PipeID= 1;
+	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL))
+		PipeID= 0;
+
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+	if (pAd->BulkOutPending[PipeID] == TRUE)
+	{
+		NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+		return;
+	}
+	pAd->BulkOutPending[PipeID] = TRUE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+
+	// Increase Total transmit byte counter
+	pAd->RalinkCounters.TransmittedByteCount +=  pRTSContext->BulkOutSize;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutRTSFrame \n");
+
+	// Clear RTS frame bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_RTS);
+
+	// Init Tx context descriptor
+	RTUSBInitTxDesc(pAd, pRTSContext, PipeID, RTUSBBulkOutRTSFrameComplete);
+	pRTSContext->IRPPending = TRUE;
+
+	pUrb = pRTSContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutRTSFrame \n");
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note: MLME use BulkOutPipeId = 0
+
+	========================================================================
+*/
+VOID	RTUSBBulkOutMLMEPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Index)
+{
+	PTX_CONTEXT		pMLMEContext;
+	PURB			pUrb;
+	int 			ret = 0;
+	unsigned long			IrqFlags;
+
+	pMLMEContext = &pAd->MLMEContext[Index];
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	if (pAd->BulkOutPending[0] == TRUE)
+	{
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		return;
+	}
+	pAd->BulkOutPending[0] = TRUE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	// Increase Total transmit byte counter
+	pAd->RalinkCounters.TransmittedByteCount +=  pMLMEContext->BulkOutSize;
+
+	// Clear MLME bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
+			pAd->PrioRingFirstIndex,
+			pAd->PrioRingTxCnt, pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutMLMEPacket\n");
+
+
+	// Init Tx context descriptor
+	RTUSBInitTxDesc(pAd, pMLMEContext, 0, RTUSBBulkOutMLMEPacketComplete);
+	pMLMEContext->IRPPending = TRUE;
+
+
+	pUrb = pMLMEContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit MLME URB failed %d\n", ret);
+		return;
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacket \n");
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note: PsPoll use BulkOutPipeId = 0
+
+	========================================================================
+*/
+VOID	RTUSBBulkOutPsPoll(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
+	PURB			pUrb;
+	int 			ret = 0;
+	unsigned long			IrqFlags;
+
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	if (pAd->BulkOutPending[0] == TRUE)
+	{
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		return;
+	}
+	pAd->BulkOutPending[0] = TRUE;
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutPsPoll \n");
+
+	// Clear PS-Poll bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);
+
+
+	// Init Tx context descriptor
+	RTUSBInitTxDesc(pAd, pPsPollContext, 0, RTUSBBulkOutPsPollComplete);
+	pPsPollContext->IRPPending = TRUE;
+
+	pUrb = pPsPollContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutPsPoll \n");
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+	USB_RxPacket initializes a URB and uses the Rx IRP to submit it
+	to USB. It checks if an Rx Descriptor is available and passes the
+	the coresponding buffer to be filled. If no descriptor is available
+	fails the request. When setting the completion routine we pass our
+	Adapter Object as Context.
+
+	Arguments:
+
+	Return Value:
+		TRUE			found matched tuple cache
+		FALSE			no matched found
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBBulkReceive(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PRX_CONTEXT pRxContext;
+	PURB		pUrb;
+	int 		ret = 0;
+
+	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS)))
+	{
+		return;
+	}
+
+	DBGPRINT(RT_DEBUG_INFO,"RTUSBBulkReceive:: pAd->NextRxBulkInIndex = %d\n",pAd->NextRxBulkInIndex);
+
+	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
+	pRxContext->InUse = TRUE;
+	pAd->NextRxBulkInIndex = (pAd->NextRxBulkInIndex + 1) % RX_RING_SIZE;
+
+	atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCELABLE);
+	atomic_inc(&pAd->PendingRx);
+
+	// Init Rx context descriptor
+	memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
+	RTUSBInitRxDesc(pAd, pRxContext);
+
+	pUrb = pRxContext->pUrb;
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Rx URB failed %d\n", ret);
+		return;
+	}
+
+	return;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+	RTUSBBulkReceive cannot be called when in an interrupt as it raises a
+	bug on ARM, so we schedule this function so that it calls
+	RTUSBBulkReceive outside of interrupt context.
+
+	Arguments: ulong data, memory address to pAd structure.
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+
+VOID	rtusb_bulkrx(
+	IN	unsigned long	data)
+{
+	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)data;
+
+	RTUSBBulkReceive(pAd);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBKickBulkOut(
+	IN	PRTMP_ADAPTER pAd)
+{
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBKickBulkOut\n");
+
+
+	if (!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+		!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS)) &&
+		!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)))
+	{
+
+		// 1. Data Fragment has highest priority
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 0)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 0, pAd->NextBulkOutIndex[0]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_2))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 1)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 1, pAd->NextBulkOutIndex[1]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_3))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 2)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 2, pAd->NextBulkOutIndex[2]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_4))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 3)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 3, pAd->NextBulkOutIndex[3]);
+			}
+		}
+
+		// 2. PS-Poll frame is next
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL))
+		{
+			RTUSBBulkOutPsPoll(pAd);
+		}
+		// 5. Mlme frame is next
+		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME))
+		{
+			RTUSBBulkOutMLMEPacket(pAd, pAd->PrioRingFirstIndex);
+		}
+
+		// 6. Data frame normal is next
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 0)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 0, pAd->NextBulkOutIndex[0]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 1)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 1, pAd->NextBulkOutIndex[1]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 2)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 2, pAd->NextBulkOutIndex[2]);
+			}
+		}
+
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4))
+		{
+			if ((!LOCAL_TX_RING_EMPTY(pAd, 3)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+			{
+				RTUSBBulkOutDataPacket(pAd, 3, pAd->NextBulkOutIndex[3]);
+			}
+		}
+
+		// 7. Null frame is the last
+		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL))
+		{
+			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			{
+				RTUSBBulkOutNullFrame(pAd);
+			}
+		}
+
+		// 8. No data avaliable
+		else
+		{
+
+		}
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBKickBulkOut\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCleanUpDataBulkOutQueue(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	UCHAR			Idx;
+	PTX_CONTEXT 	pTxContext;
+	unsigned long			IrqFlags;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpDataBulkOutQueue\n");
+
+	for (Idx = 0; Idx < 4; Idx++)
+	{
+		while (!LOCAL_TX_RING_EMPTY(pAd, Idx))
+		{
+			pTxContext						= &(pAd->TxContext[Idx][pAd->NextBulkOutIndex[Idx]]);
+			pTxContext->LastOne 			= FALSE;
+			pTxContext->InUse				= FALSE;
+			pTxContext->bWaitingBulkOut		= FALSE;
+			pAd->NextBulkOutIndex[Idx] = (pAd->NextBulkOutIndex[Idx] + 1) % TX_RING_SIZE;
+		}
+		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		pAd->BulkOutPending[Idx] = FALSE;
+		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpDataBulkOutQueue\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCleanUpMLMEBulkOutQueue(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	unsigned long			IrqFlags;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEBulkOutQueue\n");
+
+	NdisAcquireSpinLock(&pAd->MLMEQLock, IrqFlags);
+	while (pAd->PrioRingTxCnt > 0)
+	{
+		pAd->MLMEContext[pAd->PrioRingFirstIndex].InUse = FALSE;
+
+		pAd->PrioRingFirstIndex++;
+		if (pAd->PrioRingFirstIndex >= PRIO_RING_SIZE)
+		{
+			pAd->PrioRingFirstIndex = 0;
+		}
+
+		pAd->PrioRingTxCnt--;
+	}
+	NdisReleaseSpinLock(&pAd->MLMEQLock, IrqFlags);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEBulkOutQueue\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCancelPendingBulkInIRP(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PRX_CONTEXT	pRxContext;
+	UINT		i;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"--->RTUSBCancelPendingBulkInIRP\n");
+	for ( i = 0; i < RX_RING_SIZE; i++)
+	{
+		pRxContext = &(pAd->RxContext[i]);
+		if(atomic_read(&pRxContext->IrpLock) == IRPLOCK_CANCELABLE)
+		{
+			RTUSB_UNLINK_URB(pRxContext->pUrb);
+		}
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_START);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"<---RTUSBCancelPendingBulkInIRP\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCancelPendingBulkOutIRP(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PTX_CONTEXT		pTxContext;
+	PTX_CONTEXT		pMLMEContext;
+	PTX_CONTEXT		pBeaconContext;
+	PTX_CONTEXT		pNullContext;
+	PTX_CONTEXT		pPsPollContext;
+	PTX_CONTEXT		pRTSContext;
+	UINT			i, Idx;
+	unsigned long			IrqFlags;
+
+	for (Idx = 0; Idx < 4; Idx++)
+	{
+		for (i = 0; i < TX_RING_SIZE; i++)
+		{
+			pTxContext = &(pAd->TxContext[Idx][i]);
+
+			if (pTxContext->IRPPending == TRUE)
+			{
+
+				// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
+				// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
+				//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+				//
+
+				RTUSB_UNLINK_URB(pTxContext->pUrb);
+
+				// Sleep 200 microseconds to give cancellation time to work
+				RTMPusecDelay(200);
+			}
+		}
+	}
+
+	for (i = 0; i < PRIO_RING_SIZE; i++)
+	{
+		pMLMEContext = &(pAd->MLMEContext[i]);
+
+		if(pMLMEContext->IRPPending == TRUE)
+		{
+
+			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
+			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
+			//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+			//
+
+			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
+
+			// Sleep 200 microsecs to give cancellation time to work
+			RTMPusecDelay(200);
+		}
+	}
+
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		pBeaconContext = &(pAd->BeaconContext[i]);
+
+		if(pBeaconContext->IRPPending == TRUE)
+		{
+
+			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
+			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
+			//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+			//
+
+			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
+
+			// Sleep 200 microsecs to give cancellation time to work
+			RTMPusecDelay(200);
+		}
+	}
+
+	pNullContext = &(pAd->NullContext);
+	if (pNullContext->IRPPending == TRUE)
+		RTUSB_UNLINK_URB(pNullContext->pUrb);
+
+	pRTSContext = &(pAd->RTSContext);
+	if (pRTSContext->IRPPending == TRUE)
+		RTUSB_UNLINK_URB(pRTSContext->pUrb);
+
+	pPsPollContext = &(pAd->PsPollContext);
+	if (pPsPollContext->IRPPending == TRUE)
+		RTUSB_UNLINK_URB(pPsPollContext->pUrb);
+
+	for (Idx = 0; Idx < 4; Idx++)
+	{
+		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		pAd->BulkOutPending[Idx] = FALSE;
+		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCancelPendingIRPs(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	RTUSBCancelPendingBulkInIRP(pAd);
+	RTUSBCancelPendingBulkOutIRP(pAd);
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_data.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_data.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_data.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_data.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,3433 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtusb_data.c
+ *
+ *	Abstract: Ralink USB driver Tx/Rx functions
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	idamlaj		05-10-2006	Import rfmon implementation
+ *	idamlaj		14-10-2006	RFMONTx (based on MarkW's code)
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+#include <net/iw_handler.h>
+
+extern	UCHAR Phy11BGNextRateUpward[]; // defined in mlme.c
+
+UCHAR	SNAP_802_1H[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+UCHAR	SNAP_BRIDGE_TUNNEL[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+UCHAR	EAPOL_LLC_SNAP[]= {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e};
+UCHAR	EAPOL[] = {0x88, 0x8e};
+
+UCHAR	IPX[] = {0x81, 0x37};
+UCHAR	APPLE_TALK[] = {0x80, 0xf3};
+
+UINT	_11G_RATES[12] = { 0, 0, 0, 0, 6, 9, 12, 18, 24, 36, 48, 54 };
+
+UCHAR	RateIdToPlcpSignal[12] = {
+	 0, /* RATE_1 */	1, /* RATE_2 */ 	2, /* RATE_5_5 */	3, /* RATE_11 */	// see BBP spec
+	11, /* RATE_6 */   15, /* RATE_9 */    10, /* RATE_12 */   14, /* RATE_18 */	// see IEEE802.11a-1999 p.14
+	 9, /* RATE_24 */  13, /* RATE_36 */	8, /* RATE_48 */   12  /* RATE_54 */ }; // see IEEE802.11a-1999 p.14
+
+UCHAR	 OfdmSignalToRateId[16] = {
+	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
+	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
+	RATE_48,  RATE_24,	RATE_12,  RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
+	RATE_54,  RATE_36,	RATE_18,  RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
+};
+
+UCHAR default_cwmin[]={CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1, CW_MIN_IN_BITS-2};
+UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1};
+UCHAR default_sta_aifsn[]={3,7,2,2};
+
+UCHAR MapUserPriorityToAccessCategory[8] = {QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI, QID_AC_VO, QID_AC_VO};
+
+
+
+// Macro for rx indication
+VOID REPORT_ETHERNET_FRAME_TO_LLC(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			p8023hdr,
+	IN	PUCHAR			pData,
+	IN	ULONG			DataSize,
+	IN	struct net_device	*net_dev)
+{
+	struct sk_buff	*pSkb;
+
+#ifdef RTMP_EMBEDDED
+	if ((pSkb = __dev_alloc_skb(DataSize + LENGTH_802_3 + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
+#else
+	if ((pSkb = dev_alloc_skb(DataSize + LENGTH_802_3 + 2)) != NULL)
+#endif
+
+	{
+		pSkb->dev = net_dev;
+		skb_reserve(pSkb, 2);	// 16 byte align the IP header
+		memcpy(skb_put(pSkb, LENGTH_802_3), p8023hdr, LENGTH_802_3);
+		memcpy(skb_put(pSkb, DataSize), pData, DataSize);
+		pSkb->protocol = eth_type_trans(pSkb, net_dev);
+
+		netif_rx(pSkb);
+
+		pAd->net_dev->last_rx = jiffies;
+		pAd->stats.rx_packets++;
+
+		pAd->Counters8023.GoodReceives++;
+	}
+}
+
+// Enqueue this frame to MLME engine
+// We need to enqueue the whole frame because MLME need to pass data type
+// information from 802.11 header
+#define REPORT_MGMT_FRAME_TO_MLME(_pAd, _pFrame, _FrameSize, _Rssi, _PlcpSignal)		\
+{																						\
+	MlmeEnqueueForRecv(_pAd, (UCHAR)_Rssi, _FrameSize, _pFrame, (UCHAR)_PlcpSignal);   \
+}
+
+// NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same
+//		 scatter gather buffer
+NDIS_STATUS Sniff2BytesFromNdisBuffer(
+	IN	struct sk_buff	*pFirstSkb,
+	IN	UCHAR			DesiredOffset,
+	OUT PUCHAR			pByte0,
+	OUT PUCHAR			pByte1)
+{
+	PUCHAR pBufferVA;
+	ULONG  BufferLen, AccumulateBufferLen, BufferBeginOffset;
+
+	pBufferVA = (PVOID)pFirstSkb->data;
+	BufferLen = pFirstSkb->len;
+	BufferBeginOffset	= 0;
+	AccumulateBufferLen = BufferLen;
+
+	*pByte0 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset);
+	*pByte1 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset + 1);
+	return NDIS_STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		This routine classifies outgoing frames into several AC (Access
+		Category) and enqueue them into corresponding s/w waiting queues.
+
+	Arguments:
+		pAd	Pointer	to our adapter
+		pPacket		Pointer to send packet
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPSendPacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb)
+{
+	PUCHAR			pSrcBufVA;
+	UINT			AllowFragSize;
+	UCHAR			NumberOfFrag;
+	UCHAR			RTSRequired;
+	UCHAR			QueIdx, UserPriority;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	struct sk_buff_head	*pTxQueue;
+	UCHAR			PsMode;
+	unsigned long IrqFlags;
+
+	DBGPRINT(RT_DEBUG_INFO, "====> RTMPSendPacket\n");
+
+	// Prepare packet information structure for buffer descriptor
+	pSrcBufVA = (PVOID)pSkb->data;
+
+	// STEP 1. Check for virtual address allocation, it might fail !!!
+	if (pSrcBufVA == NULL)
+	{
+		// Resourece is low, system did not allocate virtual address
+		// return NDIS_STATUS_FAILURE directly to upper layer
+		return NDIS_STATUS_FAILURE;
+	}
+
+	if (pSkb && pAd->PortCfg.BssType == BSS_MONITOR &&
+		   pAd->bAcceptRFMONTx == TRUE)
+	{
+		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE], IrqFlags);
+		skb_queue_tail(&pAd->SendTxWaitQueue[QID_AC_BE], pSkb);
+		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE], IrqFlags);
+		return (NDIS_STATUS_SUCCESS);
+	}
+
+	//
+	// Check for multicast or broadcast (First byte of DA)
+	//
+	if ((*((PUCHAR) pSrcBufVA) & 0x01) != 0)
+	{
+		// For multicast & broadcast, there is no fragment allowed
+		NumberOfFrag = 1;
+	}
+#if 0 //AGGREGATION_SUPPORT
+	else if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED))
+	{
+		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
+	}
+#endif
+	else
+	{
+		// Check for payload allowed for each fragment
+		AllowFragSize = (pAd->PortCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
+
+		// Calculate fragments required
+		NumberOfFrag = ((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) / AllowFragSize) + 1;
+		// Minus 1 if the size just match to allowable fragment size
+		if (((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) % AllowFragSize) == 0)
+		{
+			NumberOfFrag--;
+		}
+	}
+
+	// Save fragment number to Ndis packet reserved field
+	RTMP_SET_PACKET_FRAGMENTS(pSkb, NumberOfFrag);
+
+
+	// STEP 2. Check the requirement of RTS:
+	//	   If multiple fragment required, RTS is required only for the first fragment
+	//	   if the fragment size large than RTS threshold
+
+	if (NumberOfFrag > 1)
+		RTSRequired = (pAd->PortCfg.FragmentThreshold > pAd->PortCfg.RtsThreshold) ? 1 : 0;
+	else
+		RTSRequired = (pSkb->len > pAd->PortCfg.RtsThreshold) ? 1 : 0;
+
+    //
+	// Remove the following lines to avoid confusion.
+	// CTS requirement will not use Flag "RTSRequired", instead moveing the
+	// following lines to RTUSBHardTransmit(..)
+	//
+	// RTS/CTS may also be required in order to protect OFDM frame
+	//if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) &&
+	//	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+	//	RTSRequired = 1;
+
+	// Save RTS requirement to Ndis packet reserved field
+	RTMP_SET_PACKET_RTS(pSkb, RTSRequired);
+	RTMP_SET_PACKET_TXRATE(pSkb, pAd->PortCfg.TxRate);
+
+
+	//
+	// STEP 3. Traffic classification. outcome = <UserPriority, QueIdx>
+	//
+	UserPriority = 0;
+	QueIdx		 = QID_AC_BE;
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+	{
+		USHORT Protocol;
+		UCHAR  LlcSnapLen = 0, Byte0, Byte1;
+		do
+		{
+			// get Ethernet protocol field
+			Protocol = (USHORT)((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
+			if (Protocol <= 1500)
+			{
+				// get Ethernet protocol field from LLC/SNAP
+				if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + 6, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+					break;
+
+				Protocol = (USHORT)((Byte0 << 8) + Byte1);
+				LlcSnapLen = 8;
+			}
+
+			// always AC_BE for non-IP packet
+			if (Protocol != 0x0800)
+				break;
+
+			// get IP header
+			if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + LlcSnapLen, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+				break;
+
+			// return AC_BE if packet is not IPv4
+			if ((Byte0 & 0xf0) != 0x40)
+				break;
+
+			UserPriority = (Byte1 & 0xe0) >> 5;
+			QueIdx = MapUserPriorityToAccessCategory[UserPriority];
+
+			// TODO: have to check ACM bit. apply TSPEC if ACM is ON
+			// TODO: downgrade UP & QueIdx before passing ACM
+			if (pAd->PortCfg.APEdcaParm.bACM[QueIdx])
+			{
+				UserPriority = 0;
+				QueIdx		 = QID_AC_BE;
+			}
+		} while (FALSE);
+	}
+
+	RTMP_SET_PACKET_UP(pSkb, UserPriority);
+
+	// Make sure SendTxWait queue resource won't be used by other threads
+	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+
+	pTxQueue = &pAd->SendTxWaitQueue[QueIdx];
+
+	//
+	// For infrastructure mode, enqueue this frame immediately to sendwaitqueue
+	// For Ad-hoc mode, check the DA power state, then decide which queue to enqueue
+	//
+	if (INFRA_ON(pAd))
+	{
+		// In infrastructure mode, simply enqueue the packet into Tx waiting queue.
+		DBGPRINT(RT_DEBUG_INFO, "Infrastructure -> Enqueue one frame\n");
+
+		// Enqueue Ndis packet to end of Tx wait queue
+		skb_queue_tail(pTxQueue, pSkb);
+		Status = NDIS_STATUS_SUCCESS;
+#ifdef DBG
+        pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;  // TODO: for debug only. to be removed
+#endif
+	}
+	else
+	{
+		// In IBSS mode, power state of destination should be considered.
+		PsMode = PWR_ACTIVE;		// Faked
+		if (PsMode == PWR_ACTIVE)
+		{
+			DBGPRINT(RT_DEBUG_INFO,"Ad-Hoc -> Enqueue one frame\n");
+
+			// Enqueue Ndis packet to end of Tx wait queue
+			skb_queue_tail(pTxQueue, pSkb);
+			Status = NDIS_STATUS_SUCCESS;
+#ifdef DBG
+            pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;   // TODO: for debug only. to be removed
+#endif
+		}
+	}
+
+	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+
+	return (Status);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		SendPackets handler
+
+	Arguments:
+		skb 			point to sk_buf which upper layer transmit
+		net_dev 		point to net_dev
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+INT RTMPSendPackets(
+	IN	struct sk_buff		*pSkb,
+	IN	struct net_device	*net_dev)
+{
+	PRTMP_ADAPTER	pAd = net_dev->priv;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	INT 			Index;
+
+	DBGPRINT(RT_DEBUG_INFO, "===> RTMPSendPackets\n");
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+		RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+	{
+		// Drop send request since hardware is in reset state
+		RTUSBFreeSkbBuffer(pSkb);
+		return 0;
+	}
+	// Drop packets if no associations
+	else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd) && !(pAd->PortCfg.BssType == BSS_MONITOR && pAd->bAcceptRFMONTx == TRUE))
+	{
+		RTUSBFreeSkbBuffer(pSkb);
+		return 0;
+	}
+	else
+	{
+		// initial pSkb->data_len=0, we will use this variable to store data size when fragment(in TKIP)
+		// and pSkb->len is actual data len
+		pSkb->data_len = pSkb->len;
+
+		// Record that orignal packet source is from protocol layer,so that
+		// later on driver knows how to release this skb buffer
+		RTMP_SET_PACKET_SOURCE(pSkb, PKTSRC_NDIS);
+		pAd->RalinkCounters.PendingNdisPacketCount ++;
+
+		Status = RTMPSendPacket(pAd, pSkb);
+		if (Status != NDIS_STATUS_SUCCESS)
+		{
+			// Errors before enqueue stage
+			RELEASE_NDIS_PACKET(pAd, pSkb);
+			DBGPRINT(RT_DEBUG_TRACE,"<---RTUSBSendPackets not dequeue\n");
+			return 0;
+		}
+	}
+
+	// Dequeue one frame from SendTxWait queue and process it
+	// There are two place calling dequeue for TX ring.
+	// 1. Here, right after queueing the frame.
+	// 2. At the end of TxRingTxDone service routine.
+	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+	{
+		for (Index = 0; Index < 4; Index++)
+		{
+			if(!skb_queue_empty(&pAd->SendTxWaitQueue[Index]))
+			{
+				RTMPDeQueuePacket(pAd, Index);
+			}
+		}
+	}
+
+	// Kick bulk out
+	RTUSBKickBulkOut(pAd);
+
+	return 0;
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set
+	appropriate ASIC register to kick hardware encryption before really
+	sent out to air.
+
+	Arguments:
+		pAd				Pointer	to our adapter
+		PNDIS_PACKET	Pointer to outgoing Ndis frame
+		NumberOfFrag	Number of fragment required
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+#ifdef BIG_ENDIAN
+static inline
+#endif
+NDIS_STATUS RTUSBHardTransmit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb,
+	IN	UCHAR			NumberRequired,
+	IN	UCHAR			QueIdx)
+{
+	UINT			LengthQosPAD =0;
+	UINT			BytesCopied;
+	UINT			TxSize;
+	UINT			FreeMpduSize;
+	UINT			SrcRemainingBytes;
+	USHORT			Protocol;
+	UCHAR			FrameGap;
+	HEADER_802_11	Header_802_11;
+	PHEADER_802_11	pHeader80211;
+	PUCHAR			pDest;
+//	PUCHAR			pSrc;
+	PTX_CONTEXT		pTxContext;
+	PTXD_STRUC		pTxD;
+#ifdef BIG_ENDIAN
+	PTXD_STRUC		pDestTxD;
+	TXD_STRUC		TxD;
+#endif
+//	PURB			pUrb;
+	BOOLEAN			StartOfFrame;
+	BOOLEAN			bEAPOLFrame;
+	ULONG			Iv16;
+	ULONG			Iv32;
+	BOOLEAN			MICFrag;
+//	PCIPHER_KEY		pWpaKey = NULL;
+	BOOLEAN			Cipher;
+	ULONG			TransferBufferLength;
+	USHORT			AckDuration = 0;
+	USHORT			EncryptionOverhead = 0;
+	UCHAR			CipherAlg;
+	BOOLEAN			bAckRequired;
+	UCHAR			RetryMode = SHORT_RETRY;
+	UCHAR			UserPriority;
+	UCHAR			MpduRequired, RtsRequired;
+	UCHAR			TxRate;
+	PCIPHER_KEY		pKey = NULL ;
+	PUCHAR			pSrcBufVA = NULL;
+	ULONG			SrcBufLen;
+	PUCHAR			pExtraLlcSnapEncap = NULL; // NULL: no extra LLC/SNAP is required
+	UCHAR			KeyIdx;
+	PUCHAR			pWirelessPacket;
+	ULONG			NextMpduSize;
+	BOOLEAN			bRTS_CTSFrame = FALSE;
+
+    if ((pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
+    {
+        DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit --> radar detect not in normal mode !!!\n");
+        return (NDIS_STATUS_FAILURE);
+    }
+
+	if (pAd->PortCfg.BssType == BSS_MONITOR && pAd->bAcceptRFMONTx == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_INFO,"==>INJECT\n");
+		pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+
+		if (pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"RTUSBHardTransmit: TX RING full\n");
+			//pAd->RalinkCounters.TxRingErrCount++;
+
+			return (NDIS_STATUS_RESOURCES);
+		}
+
+		pTxContext->InUse	= TRUE;
+		pTxContext->LastOne	= TRUE;
+
+		// Increase & maintain Tx Ring Index
+		pAd->NextTxIndex[QueIdx]++;
+		if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
+		{
+			pAd->NextTxIndex[QueIdx] = 0;
+		}
+
+#ifndef BIG_ENDIAN
+		pTxD  = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+#else
+		pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+		TxD = *pDestTxD;
+		pTxD = &TxD;
+		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pWirelessPacket = pTxContext->TransferBuffer->WirelessPacket;
+		memcpy( pWirelessPacket, pSkb->data, pSkb->len );
+		TxSize = pSkb->len;				//+FCS
+
+		/*for (i=0; i<TxSize; i++)
+			DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit --> byte %u is %x\n", i, pWirelessPacket[i]);*/
+
+		RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE /*CipherAlg*/, 0, 0xff /*KeyIdx*/,
+					FALSE /*bAckRequired*/, FALSE, FALSE, 4 /*RetryMode*/,
+					IFS_BACKOFF /*FrameGap*/, RTMP_GET_PACKET_TXRATE(pSkb) /*TxRate*/,
+					TxSize, QueIdx, 0, FALSE /*bRTS_CTSFrame*/);
+
+		TransferBufferLength = TxSize + sizeof(TXD_STRUC);
+
+		if ((TransferBufferLength % 4) == 1)
+			TransferBufferLength  += 3;
+		else if ((TransferBufferLength % 4) == 2)
+			TransferBufferLength  += 2;
+		else if ((TransferBufferLength % 4) == 3)
+			TransferBufferLength  += 1;
+
+		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+			TransferBufferLength += 4;
+
+		pTxContext->BulkOutSize = TransferBufferLength;
+		pTxContext->bWaitingBulkOut = TRUE;
+		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
+
+		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
+		atomic_inc(&pAd->TxCount);
+		RELEASE_NDIS_PACKET(pAd, pSkb);
+
+		return (NDIS_STATUS_SUCCESS);
+	}
+
+	TxRate		 = RTMP_GET_PACKET_TXRATE(pSkb);
+	MpduRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb);
+	RtsRequired  = RTMP_GET_PACKET_RTS(pSkb);
+	UserPriority = RTMP_GET_PACKET_UP(pSkb);
+
+	//
+	// Prepare packet information structure which will be query for buffer descriptor
+	//
+	pSrcBufVA = (PVOID)pSkb->data;
+	SrcBufLen = pSkb->len;
+
+	// Check for virtual address allocation, it might fail !!!
+	if (pSrcBufVA == NULL)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "pSrcBufVA == NULL\n");
+		return(NDIS_STATUS_RESOURCES);
+	}
+	if (SrcBufLen < 14)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "RTUSBHardTransmit --> Skb buffer error !!!\n");
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	//
+	// If DHCP datagram or ARP datagram , we need to send it as Low rates.
+	//
+	if (pAd->PortCfg.Channel <= 14)
+	{
+		//
+		// Case 802.11 b/g
+		// basic channel means that we can use CCKM's low rate as RATE_1.
+		//
+		if ((TxRate != RATE_1) && RTMPCheckDHCPFrame(pAd, pSkb))
+			TxRate = RATE_1;
+	}
+	else
+	{
+		//
+		// Case 802.11a
+		// We must used OFDM's low rate as RATE_6, note RATE_1 is not allow
+		// Only OFDM support on Channel > 14
+		//
+		if ((TxRate != RATE_6) && RTMPCheckDHCPFrame(pAd, pSkb))
+			TxRate = RATE_6;
+	}
+
+	// ------------------------------------------
+	// STEP 0.1 Add 802.1x protocol check.
+	// ------------------------------------------
+	// For non-WPA network, 802.1x message should not encrypt even privacy is on.
+	if (NdisEqualMemory(EAPOL, pSrcBufVA + 12, 2))
+	{
+		bEAPOLFrame = TRUE;
+		if (pAd->PortCfg.MicErrCnt >= 2)
+			pAd->PortCfg.MicErrCnt++;
+	}
+	else
+		bEAPOLFrame = FALSE;
+
+	//
+	// WPA 802.1x secured port control - drop all non-802.1x frame before port secured
+	//
+	if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)	 ||
+		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)	 ||
+		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+#if WPA_SUPPLICANT_SUPPORT
+		  || (pAd->PortCfg.IEEE8021X == TRUE)
+#endif
+         ) &&
+		((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->PortCfg.MicErrCnt >= 2)) &&
+		(bEAPOLFrame == FALSE))
+	{
+		DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBHardTransmit --> Drop packet before port secured !!!\n");
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	if (*pSrcBufVA & 0x01) // Multicast or Broadcast
+	{
+		bAckRequired = FALSE;
+		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+		Cipher = pAd->PortCfg.GroupCipher; // Cipher for Multicast or Broadcast
+	}
+	else
+	{
+		bAckRequired = TRUE;
+		Cipher = pAd->PortCfg.PairCipher; // Cipher for Unicast
+	}
+
+	// 1. traditional TX burst
+	if (pAd->PortCfg.bEnableTxBurst && (pAd->Sequence & 0x7))
+		FrameGap = IFS_SIFS;
+	// 2. frame belonging to AC that has non-zero TXOP
+	else if (pAd->PortCfg.APEdcaParm.bValid && pAd->PortCfg.APEdcaParm.Txop[QueIdx])
+		FrameGap = IFS_SIFS;
+	// 3. otherwise, always BACKOFF before transmission
+	else
+		FrameGap = IFS_BACKOFF;		// Default frame gap mode
+
+	Protocol = *(pSrcBufVA + 12) * 256 + *(pSrcBufVA + 13);
+	// if orginal Ethernet frame contains no LLC/SNAP, then an extra LLC/SNAP encap is required
+	if (Protocol > 1500)
+	{
+		pExtraLlcSnapEncap = SNAP_802_1H;
+		if (NdisEqualMemory(IPX, pSrcBufVA + 12, 2) ||
+			NdisEqualMemory(APPLE_TALK, pSrcBufVA + 12, 2))
+		{
+			pExtraLlcSnapEncap = SNAP_BRIDGE_TUNNEL;
+		}
+	}
+	else
+		pExtraLlcSnapEncap = NULL;
+
+
+    // Update software power save state
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+	pAd->PortCfg.Psm = PWR_ACTIVE;
+
+	// -----------------------------------------------------------------
+	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST.
+	// -----------------------------------------------------------------
+
+	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+	MAKE_802_11_HEADER(pAd, Header_802_11, pSrcBufVA, pAd->Sequence);
+#if 0
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+		Header_802_11.FC.SubType = SUBTYPE_QDATA;
+#endif
+
+	// --------------------------------------------------------
+	// STEP 3. FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM
+	//		Find the WPA key, either Group or Pairwise Key
+	//		LEAP + TKIP also use WPA key.
+	// --------------------------------------------------------
+	// Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst
+	// In Cisco CCX 2.0 Leap Authentication
+	//		   WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
+	//		   Instead of the SharedKey, SharedKey Length may be Zero.
+	KeyIdx = 0xff;
+	if (bEAPOLFrame)
+	{
+        ASSERT(pAd->SharedKey[0].CipherAlg <= CIPHER_CKIP128);
+        if ((pAd->SharedKey[0].CipherAlg) &&
+            (pAd->SharedKey[0].KeyLen) )
+        {
+            CipherAlg = pAd->SharedKey[0].CipherAlg;
+            KeyIdx = 0;
+        }
+    }
+	else if (Cipher == Ndis802_11Encryption1Enabled)
+	{
+			// standard WEP64 or WEP128
+		KeyIdx = pAd->PortCfg.DefaultKeyId;
+	}
+	else if ((Cipher == Ndis802_11Encryption2Enabled) ||
+			 (Cipher == Ndis802_11Encryption3Enabled))
+	{
+		if (Header_802_11.Addr1[0] & 0x01) // multicast
+			KeyIdx = pAd->PortCfg.DefaultKeyId;
+		else if (pAd->SharedKey[0].KeyLen)
+			KeyIdx = 0;
+		else
+			KeyIdx = pAd->PortCfg.DefaultKeyId;
+	}
+
+	if (KeyIdx == 0xff)
+		CipherAlg = CIPHER_NONE;
+	else if (pAd->SharedKey[KeyIdx].KeyLen == 0)
+		CipherAlg = CIPHER_NONE;
+	else
+	{
+		Header_802_11.FC.Wep = 1;
+		CipherAlg = pAd->SharedKey[KeyIdx].CipherAlg;
+		pKey = &pAd->SharedKey[KeyIdx];
+	}
+
+	DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit(bEAP=%d) - %s key#%d, KeyLen=%d\n",
+		bEAPOLFrame, CipherName[CipherAlg], KeyIdx, pAd->SharedKey[KeyIdx].KeyLen);
+
+
+	// STEP 3.1 if TKIP is used and fragmentation is required. Driver has to
+	//			append TKIP MIC at tail of the scatter buffer (This must be the
+	//			ONLY scatter buffer in the skb buffer).
+	//			MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
+	if ((MpduRequired > 1) && (CipherAlg == CIPHER_TKIP))
+	{
+		pSkb->len += 8;
+		CipherAlg = CIPHER_TKIP_NO_MIC;
+	}
+
+	// ----------------------------------------------------------------
+	// STEP 4. Make RTS frame or CTS-to-self frame if required
+	// ----------------------------------------------------------------
+
+	//
+	// calcuate the overhead bytes that encryption algorithm may add. This
+	// affects the calculate of "duration" field
+	//
+	if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128))
+		EncryptionOverhead = 8; //WEP: IV[4] + ICV[4];
+	else if (CipherAlg == CIPHER_TKIP_NO_MIC)
+		EncryptionOverhead = 12;//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
+	else if (CipherAlg == CIPHER_TKIP)
+		EncryptionOverhead = 20;//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
+	else if (CipherAlg == CIPHER_AES)
+		EncryptionOverhead = 16;	// AES: IV[4] + EIV[4] + MIC[8]
+	else
+		EncryptionOverhead = 0;
+
+	// decide how much time an ACK/CTS frame will consume in the air
+	AckDuration = RTMPCalcDuration(pAd, pAd->PortCfg.ExpectedACKRate[TxRate], 14);
+
+	// If fragment required, MPDU size is maximum fragment size
+	// Else, MPDU size should be frame with 802.11 header & CRC
+	if (MpduRequired > 1)
+		NextMpduSize = pAd->PortCfg.FragmentThreshold;
+	else
+	{
+		NextMpduSize = pSkb->len + LENGTH_802_11 + LENGTH_CRC - LENGTH_802_3;
+		if (pExtraLlcSnapEncap)
+			NextMpduSize += LENGTH_802_1_H;
+	}
+
+	if (RtsRequired || OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE))
+	{
+		RTMPSendRTSCTSFrame(pAd,
+							Header_802_11.Addr1,
+							NextMpduSize + EncryptionOverhead,
+							TxRate,
+							pAd->PortCfg.RtsRate,
+							AckDuration,
+							QueIdx,
+							FrameGap,
+							SUBTYPE_RTS);
+
+		// RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
+		RetryMode = LONG_RETRY;
+		FrameGap = IFS_SIFS;
+		bRTS_CTSFrame = TRUE;
+
+		if (RtsRequired)
+			NumberRequired--;
+	}
+	else if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+	{
+		RTMPSendRTSCTSFrame(pAd,
+							Header_802_11.Addr1,
+							NextMpduSize + EncryptionOverhead,
+							TxRate,
+							pAd->PortCfg.RtsRate,
+							AckDuration,
+							QueIdx,
+							FrameGap,
+							SUBTYPE_CTS);
+
+		// RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
+		RetryMode = LONG_RETRY;
+		FrameGap = IFS_SIFS;
+		bRTS_CTSFrame = TRUE;
+	}
+
+	// --------------------------------------------------------
+	// STEP 5. START MAKING MPDU(s)
+	//		Start Copy Ndis Packet into Ring buffer.
+	//		For frame required more than one ring buffer (fragment), all ring buffers
+	//		have to be filled before kicking start tx bit.
+	//		Make sure TX ring resource won't be used by other threads
+	// --------------------------------------------------------
+	SrcRemainingBytes = pSkb->len - LENGTH_802_3;
+	SrcBufLen		 -= LENGTH_802_3;  // skip 802.3 header
+
+
+	StartOfFrame = TRUE;
+	MICFrag = FALSE;	// Flag to indicate MIC shall spread into two MPDUs
+
+	// Start Copy Ndis Packet into Ring buffer.
+	// For frame required more than one ring buffer (fragment), all ring buffers
+	// have to be filled before kicking start tx bit.
+
+	do
+	{
+		//
+		// STEP 5.1 Get the Tx Ring descriptor & Dma Buffer address
+		//
+		pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+
+		if ((pTxContext->bWaitingBulkOut == TRUE) || (pTxContext->InUse == TRUE) ||
+			(pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE))
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"RTUSBHardTransmit: TX RING full\n");
+			//pAd->RalinkCounters.TxRingErrCount++;
+			return (NDIS_STATUS_RESOURCES);
+		}
+		pTxContext->InUse	= TRUE;
+
+		// Increase & maintain Tx Ring Index
+		pAd->NextTxIndex[QueIdx]++;
+		if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
+		{
+			pAd->NextTxIndex[QueIdx] = 0;
+		}
+
+#ifndef BIG_ENDIAN
+		pTxD  = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+#else
+		pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+		TxD = *pDestTxD;
+		pTxD = &TxD;
+		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pWirelessPacket = pTxContext->TransferBuffer->WirelessPacket;
+
+		//
+		// STEP 5.2 PUT IVOFFSET, IV, EIV INTO TXD
+		//
+		pTxD->IvOffset	= LENGTH_802_11;
+
+#if 0
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+			pTxD->IvOffset += 2;  // add QOS CONTROL bytes
+#endif
+
+		if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128))
+		{
+			PUCHAR pTmp;
+			pTmp = (PUCHAR) &pTxD->Iv;
+			*pTmp		= RandomByte(pAd);
+			*(pTmp + 1) = RandomByte(pAd);
+			*(pTmp + 2) = RandomByte(pAd);
+			*(pTmp + 3) = (KeyIdx << 6);
+		}
+		else if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC))
+		{
+			RTMPInitTkipEngine(
+				pAd,
+				pKey->Key,
+				KeyIdx,		// This might cause problem when using peer key
+				Header_802_11.Addr2,
+				pKey->TxMic,
+				pKey->TxTsc,
+				&Iv16,
+				&Iv32);
+
+			memcpy(&pTxD->Iv, &Iv16, 4);   // Copy IV
+			memcpy(&pTxD->Eiv, &Iv32, 4);  // Copy EIV
+			INC_TX_TSC(pKey->TxTsc);			   // Increase TxTsc for next transmission
+		}
+		else if (CipherAlg == CIPHER_AES)
+		{
+			PUCHAR	pTmp;
+			pTmp = (PUCHAR) &Iv16;
+			*pTmp		= pKey->TxTsc[0];
+			*(pTmp + 1) = pKey->TxTsc[1];
+			*(pTmp + 2) = 0;
+			*(pTmp + 3) = (pAd->PortCfg.DefaultKeyId << 6) | 0x20;
+			Iv32 = *(PULONG)(&pKey->TxTsc[2]);
+
+			memcpy(&pTxD->Iv, &Iv16, 4);	// Copy IV
+			memcpy(&pTxD->Eiv, &Iv32, 4);	// Copy EIV
+			INC_TX_TSC(pKey->TxTsc);				// Increase TxTsc for next transmission
+		}
+
+
+		//
+		// STEP 5.3 COPY 802.11 HEADER INTO 1ST DMA BUFFER
+		//
+		pDest = pWirelessPacket;
+		memcpy(pDest, &Header_802_11, sizeof(Header_802_11));
+		pDest		+= sizeof(Header_802_11);
+
+		//
+		// Fragmentation is not allowed on multicast & broadcast
+		// So, we need to used the MAX_FRAG_THRESHOLD instead of pAd->PortCfg.FragmentThreshold
+		// otherwise if pSkb->len > pAd->PortCfg.FragmentThreshold then
+		// packet will be fragment on multicast & broadcast.
+		//
+		// MpduRequired equals to 1 means this could be Aggretaion case.
+		//
+		if ((Header_802_11.Addr1[0] & 0x01) || MpduRequired == 1)
+		{
+			FreeMpduSize = MAX_FRAG_THRESHOLD - sizeof(Header_802_11) - LENGTH_CRC;
+		}
+		else
+		{
+			FreeMpduSize = pAd->PortCfg.FragmentThreshold - sizeof(Header_802_11) - LENGTH_CRC;
+		}
+
+#if 0
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+		{
+			// copy QOS CONTROL bytes
+			*pDest		  =  (UserPriority & 0x0f) | pAd->PortCfg.AckPolicy[QueIdx];
+			*(pDest+1)	  =  0;
+			pDest		  += 2;
+			FreeMpduSize  -= 2;
+			if (pAd->PortCfg.AckPolicy[QueIdx] != NORMAL_ACK)
+			{
+				bAckRequired = FALSE;
+			}
+		}
+#endif
+
+		//
+		// STEP 5.4 COPY LLC/SNAP, CKIP MIC INTO 1ST DMA BUFFER ONLY WHEN THIS
+		//			MPDU IS THE 1ST OR ONLY FRAGMENT
+		//
+		if (Header_802_11.Frag == 0)
+		{
+			if (pExtraLlcSnapEncap)
+			{
+				if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
+				{
+					// Calculate MSDU MIC Value
+					RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
+				}
+
+				// Insert LLC-SNAP encapsulation
+				memcpy(pDest, pExtraLlcSnapEncap, 6);
+				pDest += 6;
+				memcpy(pDest, pSrcBufVA + 12, 2);
+				pDest += 2;
+				pSrcBufVA += LENGTH_802_3;
+				FreeMpduSize -= LENGTH_802_1_H;
+
+			}
+			else
+			{
+				if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
+				{
+					// Calculate MSDU MIC Value
+					RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
+				}
+				pSrcBufVA += LENGTH_802_3;
+			}
+		}
+
+		// Start copying payload
+		BytesCopied = 0;
+		do
+		{
+			if (SrcBufLen >= FreeMpduSize)
+			{
+				// Copy only the free fragment size, and save the pointer
+				// of current buffer descriptor for next fragment buffer.
+				memcpy(pDest, pSrcBufVA, FreeMpduSize);
+				BytesCopied += FreeMpduSize;
+				pSrcBufVA	+= FreeMpduSize;
+				pDest		+= FreeMpduSize;
+				SrcBufLen	-= FreeMpduSize;
+				break;
+			}
+			else
+			{
+				// Copy the rest of this buffer descriptor pointed data
+				// into ring buffer.
+				memcpy(pDest, pSrcBufVA, SrcBufLen);
+				BytesCopied  += SrcBufLen;
+				pDest		 += SrcBufLen;
+				FreeMpduSize -= SrcBufLen;
+			}
+
+			// No more buffer descriptor
+			// Add MIC value if needed
+
+			//if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
+			//	(MICFrag == FALSE) &&
+			//	(pKey != NULL))
+
+			if((CipherAlg == CIPHER_TKIP_NO_MIC) &&
+			   (MICFrag == FALSE) &&
+				(pKey != NULL))
+			{
+				// Fregment and TKIP//
+				INT i;
+
+				SrcBufLen = 8;		// Set length to MIC length
+				DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated TX MIC value =");
+				for (i = 0; i < 8; i++)
+				{
+					DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAd->PrivateInfo.Tx.MIC[i]);
+				}
+					DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
+
+				if (FreeMpduSize >= SrcBufLen)
+				{
+					memcpy(pDest, pAd->PrivateInfo.Tx.MIC, SrcBufLen);
+					BytesCopied  += SrcBufLen;
+					pDest		 += SrcBufLen;
+					FreeMpduSize -= SrcBufLen;
+					SrcBufLen = 0;
+				}
+				else
+				{
+					memcpy(pDest, pAd->PrivateInfo.Tx.MIC, FreeMpduSize);
+					BytesCopied  += FreeMpduSize;
+					pSrcBufVA	  = pAd->PrivateInfo.Tx.MIC + FreeMpduSize;
+					pDest		 += FreeMpduSize;
+					SrcBufLen	 -= FreeMpduSize;
+					MICFrag 	  = TRUE;
+				}
+			}
+		}	while (FALSE); // End of copying payload
+
+		// Real packet size, No 802.1H header for fragments except the first one.
+		if ((StartOfFrame == TRUE) && (pExtraLlcSnapEncap != NULL))
+		{
+			TxSize = BytesCopied + LENGTH_802_11 + LENGTH_802_1_H + LengthQosPAD;
+		}
+		else
+		{
+			TxSize = BytesCopied + LENGTH_802_11 + LengthQosPAD;
+		}
+
+		SrcRemainingBytes -=  BytesCopied;
+
+		//
+		// STEP 5.6 MODIFY MORE_FRAGMENT BIT & DURATION FIELD. WRITE TXD
+		//
+		pHeader80211 = (PHEADER_802_11)pWirelessPacket;
+		if (SrcRemainingBytes > 0) // more fragment is required
+		{
+			 ULONG NextMpduSize;
+
+			 pHeader80211->FC.MoreFrag = 1;
+			 NextMpduSize = min((ULONG)SrcRemainingBytes, (ULONG)pAd->PortCfg.FragmentThreshold);
+
+			 if (NextMpduSize < pAd->PortCfg.FragmentThreshold)
+			 {
+				// In this case, we need to include LENGTH_802_11 and LENGTH_CRC for calculating Duration.
+				pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) +
+									(2 * AckDuration) +
+									RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead + LENGTH_802_11 + LENGTH_CRC);
+			 }
+			 else
+			 {
+				pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) +
+								(2 * AckDuration) +
+								RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead);
+			 }
+
+#ifdef BIG_ENDIAN
+			RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
+			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+			*pDestTxD = TxD;
+			pTxD = pDestTxD;
+#endif
+			RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, 0, KeyIdx, bAckRequired, TRUE, FALSE,
+					RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
+
+			FrameGap = IFS_SIFS;	 // use SIFS for all subsequent fragments
+			Header_802_11.Frag ++;	 // increase Frag #
+		}
+		else
+		{
+			pHeader80211->FC.MoreFrag = 0;
+			if (pHeader80211->Addr1[0] & 0x01) // multicast/broadcast
+				pHeader80211->Duration = 0;
+			else
+				pHeader80211->Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+			if ((bEAPOLFrame) && (TxRate > RATE_6))
+				TxRate = RATE_6;
+
+#ifdef BIG_ENDIAN
+			RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
+			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+			*pDestTxD = TxD;
+			pTxD = pDestTxD;
+#endif
+			RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, 0, KeyIdx, bAckRequired, FALSE, FALSE,
+					RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
+
+			if (skb_queue_len(&pAd->SendTxWaitQueue[QueIdx]) > 1)
+				pTxD->Burst = 1;
+
+		}
+
+		TransferBufferLength = TxSize + sizeof(TXD_STRUC);
+
+		if ((TransferBufferLength % 4) == 1)
+			TransferBufferLength  += 3;
+		else if ((TransferBufferLength % 4) == 2)
+			TransferBufferLength  += 2;
+		else if ((TransferBufferLength % 4) == 3)
+			TransferBufferLength  += 1;
+
+
+		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+			TransferBufferLength += 4;
+
+		pTxContext->BulkOutSize = TransferBufferLength;
+		pTxContext->bWaitingBulkOut = TRUE;
+		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
+
+		// Set frame gap for the rest of fragment burst.
+		// It won't matter if there is only one fragment (single fragment frame).
+		StartOfFrame = FALSE;
+		NumberRequired--;
+		if (NumberRequired == 0)
+		{
+			pTxContext->LastOne = TRUE;
+		}
+		else
+		{
+			pTxContext->LastOne = FALSE;
+		}
+
+		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
+		atomic_inc(&pAd->TxCount);
+
+	}	while (NumberRequired > 0);
+
+
+	//
+	// Check if MIC error twice within 60 seconds and send EAPOL MIC error to TX queue
+	// then we enqueue a message for disasociating with the current AP
+	//
+
+	// Check for EAPOL frame sent after MIC countermeasures
+	if (pAd->PortCfg.MicErrCnt >= 3)
+	{
+		MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+
+		// disassoc from current AP first
+              printk("<0>MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+		DBGPRINT(RT_DEBUG_TRACE, "MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+		DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		pAd->PortCfg.bBlockAssoc = TRUE;
+		printk("<0>bBlockAssoc = %d\n", pAd->PortCfg.bBlockAssoc);
+	}
+
+
+	// release the skb buffer
+	RELEASE_NDIS_PACKET(pAd, pSkb);
+
+	return (NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set
+	appropriate ASIC register to kick hardware transmit function
+
+	Arguments:
+		pAd			Pointer	to our adapter
+		pBuffer		Pointer to	memory of outgoing frame
+		Length		Size of outgoing management frame
+
+	Return Value:
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_PENDING
+		NDIS_STATUS_SUCCESS
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBMlmeHardTransmit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PMGMT_STRUC		pMgmt)
+{
+	PTX_CONTEXT		pMLMEContext;
+	PTXD_STRUC		pTxD;
+#ifdef BIG_ENDIAN
+	PTXD_STRUC		pDestTxD;
+	TXD_STRUC		TxD;
+#endif
+	PUCHAR			pDest;
+	PHEADER_802_11	pHeader_802_11;
+	BOOLEAN 		AckRequired, InsertTimestamp;
+	ULONG			TransferBufferLength;
+	PVOID			pBuffer = pMgmt->pBuffer;
+	ULONG			Length = pMgmt->Length;
+	UCHAR			QueIdx;
+	UCHAR			MlmeRate;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
+
+	pAd->PrioRingTxCnt++;
+
+	pMLMEContext = &pAd->MLMEContext[pAd->NextMLMEIndex];
+	pMLMEContext->InUse = TRUE;
+
+	// Increase & maintain Tx Ring Index
+	pAd->NextMLMEIndex++;
+	if (pAd->NextMLMEIndex >= PRIO_RING_SIZE)
+	{
+		pAd->NextMLMEIndex = 0;
+	}
+
+	pDest = pMLMEContext->TransferBuffer->WirelessPacket;
+
+#ifndef BIG_ENDIAN
+	pTxD = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
+#else
+	pDestTxD  = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
+	TxD = *pDestTxD;
+	pTxD = &TxD;
+	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+	memset(pTxD, 0, sizeof(TXD_STRUC));
+
+	pHeader_802_11 = (PHEADER_802_11) pBuffer;
+
+	// Verify Mlme rate for a / g bands.
+    if (pHeader_802_11->Addr1[0] & 0x01)
+	{
+		MlmeRate = pAd->PortCfg.BasicMlmeRate;
+	}
+	else
+	{
+		MlmeRate = pAd->PortCfg.MlmeRate;
+	}
+
+	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
+		MlmeRate = RATE_6;
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeRate %d	Channel %d\n",MlmeRate, pAd->LatchRfRegs.Channel );
+
+
+
+    // Before radar detection done, mgmt frame can not be sent but probe req
+	// Because we need to use probe req to trigger driver to send probe req in passive scan
+	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ) && (pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "RTUSBMlmeHardTransmit --> radar detect not in normal mode !!!\n");
+		return;
+	}
+
+
+	if (pHeader_802_11->FC.PwrMgmt != PWR_SAVE)
+	{
+		pHeader_802_11->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
+	}
+
+	InsertTimestamp = FALSE;
+	if (pHeader_802_11->FC.Type == BTYPE_CNTL) // must be PS-POLL
+	{
+		AckRequired = FALSE;
+	}
+	else // BTYPE_MGMT or BMGMT_DATA(must be NULL frame)
+	{
+		pAd->Sequence		= ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+		pHeader_802_11->Sequence = pAd->Sequence;
+
+		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
+		{
+			INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+			AckRequired = FALSE;
+			pHeader_802_11->Duration = 0;
+		}
+		else
+		{
+			AckRequired = TRUE;
+			pHeader_802_11->Duration = RTMPCalcDuration(pAd, MlmeRate, 14);
+			if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
+			{
+				InsertTimestamp = TRUE;
+			}
+		}
+	}
+
+	memcpy(pDest, pBuffer, Length);
+
+	// Initialize Priority Descriptor
+	// For inter-frame gap, the number is for this frame and next frame
+	// For MLME rate, we will fix as 2Mb to match other vendor's implement
+
+	QueIdx = QID_AC_BE;
+
+#ifdef BIG_ENDIAN
+	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	*pDestTxD = TxD;
+	pTxD = pDestTxD;
+#endif
+	RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, AckRequired, FALSE, FALSE, SHORT_RETRY,
+			IFS_BACKOFF, MlmeRate, /*Length+4*/ Length, QueIdx, PID_MGMT_FRAME, FALSE);
+
+
+	// Build our URB for USBD
+	TransferBufferLength = sizeof(TXD_STRUC) + Length;
+	if ((TransferBufferLength % 2) == 1)
+		TransferBufferLength++;
+
+
+	if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+		TransferBufferLength += 2;
+
+	pMLMEContext->BulkOutSize = TransferBufferLength;
+	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
+
+	DBGPRINT(RT_DEBUG_INFO, "<---MlmeHardTransmit\n");
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		This subroutine will scan through releative ring descriptor to find
+		out avaliable free ring descriptor and compare with request size.
+
+	Arguments:
+		pAd			Pointer	to our adapter
+		RingType	Selected Ring
+
+	Return Value:
+		NDIS_STATUS_FAILURE		Not enough free descriptor
+		NDIS_STATUS_SUCCESS		Enough free descriptor
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	RTUSBFreeDescriptorRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			RingType,
+	IN	UCHAR			BulkOutPipeId,
+	IN	UCHAR			NumberRequired)
+{
+	UCHAR			FreeNumber = 0;
+	UINT			Index;
+	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
+
+	switch (RingType)
+	{
+		case TX_RING:
+			Index = (pAd->NextTxIndex[BulkOutPipeId] + 1) % TX_RING_SIZE;
+			do
+			{
+				PTX_CONTEXT	pTxD  = &pAd->TxContext[BulkOutPipeId][Index];
+
+				// While Owner bit is NIC, obviously ASIC still need it.
+				// If valid bit is TRUE, indicate that TxDone has not process yet
+				// We should not use it until TxDone finish cleanup job
+				if (pTxD->InUse == FALSE)
+				{
+					// This one is free
+					FreeNumber++;
+				}
+				else
+				{
+					break;
+				}
+				Index = (Index + 1) % TX_RING_SIZE;
+			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+
+			if (FreeNumber >= NumberRequired)
+			{
+				Status = NDIS_STATUS_SUCCESS;
+			}
+
+			break;
+
+		case PRIO_RING:
+			Index = pAd->NextMLMEIndex;
+			do
+			{
+				PTX_CONTEXT	pTxD  = &pAd->MLMEContext[Index];
+
+				// While Owner bit is NIC, obviously ASIC still need it.
+				// If valid bit is TRUE, indicate that TxDone has not process yet
+				// We should not use it until TxDone finish cleanup job
+				if (pTxD->InUse == FALSE)
+				{
+					// This one is free
+					FreeNumber++;
+				}
+				else
+				{
+					break;
+				}
+
+				Index = (Index + 1) % PRIO_RING_SIZE;
+			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+
+			if (FreeNumber >= NumberRequired)
+			{
+				Status = NDIS_STATUS_SUCCESS;
+			}
+			break;
+
+		default:
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "--->RTUSBFreeDescriptorRequest() -----!! \n");
+
+			break;
+	}
+
+	return (Status);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBRejectPendingPackets(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	UCHAR			Index;
+	unsigned long IrqFlags;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
+
+	for (Index = 0; Index < 4; Index++)
+	{
+		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+		skb_queue_purge(&pAd->SendTxWaitQueue[Index]);
+		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculates the duration which is required to transmit out frames
+	with given size and specified rate.
+
+	Arguments:
+		pTxD		Pointer to transmit descriptor
+		Ack			Setting for Ack requirement bit
+		Fragment	Setting for Fragment bit
+		RetryMode	Setting for retry mode
+		Ifs			Setting for IFS gap
+		Rate		Setting for transmit rate
+		Service		Setting for service
+		Length		Frame length
+		TxPreamble	Short or Long preamble when using CCK rates
+		QueIdx - 0-3, according to 802.11e/d4.4 June/2003
+
+	Return Value:
+		None
+
+	========================================================================
+*/
+VOID	RTUSBWriteTxDescriptor(
+	IN	PRTMP_ADAPTER pAd,
+	IN	PTXD_STRUC	pSourceTxD,
+	IN	UCHAR		CipherAlg,
+	IN	UCHAR		KeyTable,
+	IN	UCHAR		KeyIdx,
+	IN	BOOLEAN		Ack,
+	IN	BOOLEAN		Fragment,
+	IN	BOOLEAN 	InsTimestamp,
+	IN	UCHAR		RetryMode,
+	IN	UCHAR		Ifs,
+	IN	UINT		Rate,
+	IN	ULONG		Length,
+	IN	UCHAR		QueIdx,
+	IN	UCHAR		PID,
+	IN	BOOLEAN		bAfterRTSCTS)
+{
+	UINT	Residual;
+
+	PTXD_STRUC		pTxD;
+
+#ifndef BIG_ENDIAN
+	pTxD = pSourceTxD;
+#else
+	TXD_STRUC		TxD;
+
+	TxD = *pSourceTxD;
+	pTxD = &TxD;
+	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+
+
+	pTxD->HostQId	  = QueIdx;
+	pTxD->MoreFrag	  = Fragment;
+	pTxD->ACK		  = Ack;
+	pTxD->Timestamp   = InsTimestamp;
+	pTxD->RetryMd	  = RetryMode;
+	pTxD->Ofdm		  = (Rate < RATE_FIRST_OFDM_RATE)? 0:1;
+	pTxD->IFS		  = Ifs;
+	pTxD->PktId 	  = PID;
+	pTxD->Drop		  = 1;	 // 1:valid, 0:drop
+	pTxD->HwSeq 	  = 1;	  // (QueIdx == QID_MGMT)? 1:0;
+	pTxD->BbpTxPower  = DEFAULT_BBP_TX_POWER; // TODO: to be modified
+	pTxD->DataByteCnt = Length;
+
+	RTMPCckBbpTuning(pAd, Rate);
+
+	// fill encryption related information, if required
+	pTxD->CipherAlg   = CipherAlg;
+	if (CipherAlg != CIPHER_NONE)
+	{
+		pTxD->KeyTable	  = KeyTable;
+		pTxD->KeyIndex	  = KeyIdx;
+		pTxD->TkipMic	  = 1;
+	}
+
+	// In TKIP+fragmentation. TKIP MIC is already appended by driver. MAC needs not generate MIC
+	if (CipherAlg == CIPHER_TKIP_NO_MIC)
+	{
+		pTxD->CipherAlg   = CIPHER_TKIP;
+		pTxD->TkipMic	  = 0;	 // tell MAC need not insert TKIP MIC
+	}
+
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+	{
+		if ((pAd->PortCfg.APEdcaParm.bValid) && (QueIdx <= QID_AC_VO))
+		{
+			pTxD->Cwmin = pAd->PortCfg.APEdcaParm.Cwmin[QueIdx];
+			pTxD->Cwmax = pAd->PortCfg.APEdcaParm.Cwmax[QueIdx];
+			pTxD->Aifsn = pAd->PortCfg.APEdcaParm.Aifsn[QueIdx];
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR," WMM in used but EDCA not valid ERROR !!\n)");
+		}
+	}
+	else
+	{
+        if (bAfterRTSCTS)
+        {
+            // After RTS/CTS frame, data frame should use SIFS time.
+            // To patch this code, add the following code.
+            // Recommended by Jerry 2005/07/25 for WiFi testing with Proxim AP
+            pTxD->Cwmin = 0;
+            pTxD->Cwmax = 0;
+            pTxD->Aifsn = 1;
+            pTxD->IFS = IFS_BACKOFF;
+        }
+        else
+        {
+            pTxD->Cwmin = CW_MIN_IN_BITS;
+            pTxD->Cwmax = CW_MAX_IN_BITS;
+            pTxD->Aifsn = 2;
+	    }
+	}
+
+	// fill up PLCP SIGNAL field
+	pTxD->PlcpSignal = RateIdToPlcpSignal[Rate];
+	if (((Rate == RATE_2) || (Rate == RATE_5_5) || (Rate == RATE_11)) &&
+		(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
+	{
+		pTxD->PlcpSignal |= 0x0008;
+	}
+
+	// fill up PLCP SERVICE field, not used for OFDM rates
+	pTxD->PlcpService = 4; // Service;
+
+	// file up PLCP LENGTH_LOW and LENGTH_HIGH fields
+	Length += LENGTH_CRC;	// CRC length
+	switch (CipherAlg)
+	{
+		case CIPHER_WEP64:		 Length += 8;	 break;  // IV + ICV
+		case CIPHER_WEP128: 	 Length += 8;	 break;  // IV + ICV
+		case CIPHER_TKIP:		 Length += 20;	 break;  // IV + EIV + MIC + ICV
+		case CIPHER_AES:		 Length += 16;	 break;  // IV + EIV + MIC
+		case CIPHER_CKIP64: 	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
+		case CIPHER_CKIP128:	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
+		case CIPHER_TKIP_NO_MIC: Length += 12;	 break;  // IV + EIV + ICV
+		default:								 break;
+	}
+
+	if (Rate < RATE_FIRST_OFDM_RATE)	// 11b - RATE_1, RATE_2, RATE_5_5, RATE_11
+	{
+		if ((Rate == RATE_1) || ( Rate == RATE_2))
+		{
+			Length = Length * 8 / (Rate + 1);
+		}
+		else
+		{
+			Residual = ((Length * 16) % (11 * (1 + Rate - RATE_5_5)));
+			Length = Length * 16 / (11 * (1 + Rate - RATE_5_5));
+			if (Residual != 0)
+			{
+				Length++;
+			}
+			if ((Residual <= (3 * (1 + Rate - RATE_5_5))) && (Residual != 0))
+			{
+				if (Rate == RATE_11)			// Only 11Mbps require length extension bit
+					pTxD->PlcpService |= 0x80; // 11b's PLCP Length extension bit
+			}
+		}
+
+		pTxD->PlcpLengthHigh = Length >> 8; // 256;
+		pTxD->PlcpLengthLow = Length % 256;
+	}
+	else	// OFDM - RATE_6, RATE_9, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54
+	{
+		pTxD->PlcpLengthHigh = Length >> 6; // 64;	// high 6-bit of total byte count
+		pTxD->PlcpLengthLow = Length % 64;	 // low 6-bit of total byte count
+	}
+
+	pTxD->Burst  = Fragment;
+	pTxD->Burst2 = pTxD->Burst;
+
+#ifdef BIG_ENDIAN
+	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	WriteBackToDescriptor((PUCHAR)pSourceTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
+#endif
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		To do the enqueue operation and extract the first item of waiting
+		list. If a number of available shared memory segments could meet
+		the request of extracted item, the extracted item will be fragmented
+		into shared memory segments.
+
+	Arguments:
+		pAd			Pointer	to our adapter
+		pQueue		Pointer to Waiting Queue
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPDeQueuePacket(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			BulkOutPipeId)
+{
+	struct sk_buff	*pSkb;
+	UCHAR			FragmentRequired;
+	NDIS_STATUS		Status;
+	UCHAR			Count = 0;
+	struct sk_buff_head	*pQueue;
+	UCHAR			QueIdx;
+	unsigned long IrqFlags;
+
+	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+	if (pAd->DeQueueRunning[BulkOutPipeId])
+	{
+		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+		return;
+	}
+	else
+	{
+		pAd->DeQueueRunning[BulkOutPipeId] = TRUE;
+		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+	}
+
+	QueIdx = BulkOutPipeId;
+
+	if (pAd->TxRingTotalNumber[BulkOutPipeId])
+		DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d TxRingTotalNumber= %d !!--\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId]);
+
+	// Make sure SendTxWait queue resource won't be used by other threads
+	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+
+	// Select Queue
+	pQueue = &pAd->SendTxWaitQueue[BulkOutPipeId];
+
+	// Check queue before dequeue
+	while (!skb_queue_empty(pQueue) && (Count < MAX_TX_PROCESS))
+	{
+		// Reset is in progress, stop immediately
+		if ( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
+			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"--RTMPDeQueuePacket %d reset-in-progress !!--\n", BulkOutPipeId);
+			break;
+		}
+
+		// Dequeue the first entry from head of queue list
+		pSkb = skb_dequeue(pQueue);
+
+		// RTS or CTS-to-self for B/G protection mode has been set already.
+		// There is no need to re-do it here.
+		// Total fragment required = number of fragment + RST if required
+		FragmentRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb) + RTMP_GET_PACKET_RTS(pSkb);
+
+		if ((RTUSBFreeDescriptorRequest(pAd, TX_RING, BulkOutPipeId, FragmentRequired) == NDIS_STATUS_SUCCESS))
+		{
+			// Avaliable ring descriptors are enough for this frame
+			// Call hard transmit
+			// Nitro mode / Normal mode selection
+			NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+
+			Status = RTUSBHardTransmit(pAd, pSkb, FragmentRequired, QueIdx);
+
+			// Acquire the resource again, snice we may need to process it in this while-loop.
+			NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+
+			if (Status == NDIS_STATUS_FAILURE)
+			{
+				// Packet failed due to various Ndis Packet error
+				RTUSBFreeSkbBuffer(pSkb);
+				break;
+			}
+			else if (Status == NDIS_STATUS_RESOURCES)
+			{
+				// Not enough free tx ring, it might happen due to free descriptor inquery might be not correct
+				// It also might change to NDIS_STATUS_FAILURE to simply drop the frame
+				// Put the frame back into head of queue
+				skb_queue_head(pQueue, pSkb);
+				break;
+			}else if(Status == NDIS_STATUS_RINGFULL){//Thomas add
+				pAd->TxRingTotalNumber[QueIdx]= 0;
+				RTUSBFreeSkbBuffer(pSkb);
+				break;
+			}
+
+			Count++;
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d queue full !! TxRingTotalNumber= %d !! FragmentRequired=%d !!\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId], FragmentRequired);
+			skb_queue_head(pQueue, pSkb);
+		    pAd->PrivateInfo.TxRingFullCnt++;
+
+			break;
+		}
+	}
+
+	// Release TxSwQueue0 resources
+	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId],  IrqFlags);
+
+	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+	pAd->DeQueueRunning[BulkOutPipeId] = FALSE;
+	NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+
+}
+
+/*
+	========================================================================
+	 Description:
+		This is the completion routine for the USB_RxPacket which submits
+		a URB to USBD for a transmission.
+	========================================================================
+*/
+VOID	RTUSBRxPacket(
+	IN	 unsigned long data)
+{
+	purbb_t 			pUrb = (purbb_t)data;
+	PRTMP_ADAPTER		pAd;
+	PRX_CONTEXT 		pRxContext;
+	PRXD_STRUC			pRxD;
+#ifdef BIG_ENDIAN
+	PRXD_STRUC			pDestRxD;
+	RXD_STRUC			RxD;
+#endif
+	PHEADER_802_11		pHeader;
+	PUCHAR				pData;
+	PUCHAR				pDA, pSA;
+	NDIS_STATUS			Status;
+	USHORT				DataSize, Msdu2Size;
+	UCHAR				Header802_3[14];
+	PCIPHER_KEY 		pWpaKey;
+//	  struct sk_buff	  *pSkb;
+	BOOLEAN				EAPOLFrame;
+	struct net_device			*net_dev;
+	wlan_ng_prism2_header	*ph;
+	int				i;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBRxPacket\n");
+
+	pRxContext = (PRX_CONTEXT)pUrb->context;
+	pAd = pRxContext->pAd;
+	net_dev = pAd->net_dev;
+
+	if( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) )
+		return;
+
+	do
+	{
+		DBGPRINT_RAW(RT_DEBUG_INFO, "BulkIn actual length(%d)\n", pRxContext->pUrb->actual_length);
+		if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
+		{
+		pData = pRxContext->TransferBuffer;
+#ifndef BIG_ENDIAN
+		pRxD = (PRXD_STRUC) pData;
+#else
+		pDestRxD = (PRXD_STRUC) pData;
+		RxD = *pDestRxD;
+		pRxD = &RxD;
+		RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);
+#endif
+
+		// Cast to 802.11 header for flags checking
+		pHeader	= (PHEADER_802_11) (pData + sizeof(RXD_STRUC) );
+
+#ifdef BIG_ENDIAN
+		RTMPFrameEndianChange(pAd, (PUCHAR)pHeader, DIR_READ, FALSE);
+#endif
+		if (pRxD->DataByteCnt < 4)
+			Status = NDIS_STATUS_FAILURE;
+		else
+		{
+			// Increase Total receive byte counter after real data received no mater any error or not
+			pAd->RalinkCounters.ReceivedByteCount += (pRxD->DataByteCnt - 4);
+			pAd->RalinkCounters.RxCount ++;
+
+			// Check for all RxD errors
+			Status = RTMPCheckRxDescriptor(pAd, pHeader, pRxD);
+
+		}
+
+		/* Only recieve valid packets in to monitor mode */
+		if (pAd->PortCfg.BssType == BSS_MONITOR && Status == NDIS_STATUS_SUCCESS)
+         	{
+ 	        	struct sk_buff  *skb;
+ 	       		if ((skb = __dev_alloc_skb(2048, GFP_DMA|GFP_ATOMIC)) != NULL)
+ 	        	{
+				if (pAd->bAcceptRFMONTx == TRUE) {
+					if (pAd->ForcePrismHeader != 1)
+						goto rfmontx_80211_receive;
+				} else {
+					if (pAd->ForcePrismHeader == 2)
+						goto rfmontx_80211_receive;
+				}
+					// setup the wlan-ng prismheader
+
+				if (skb_headroom(skb) < sizeof(wlan_ng_prism2_header))
+					pskb_expand_head(skb, sizeof(wlan_ng_prism2_header), 0, GFP_ATOMIC);
+
+				ph = (wlan_ng_prism2_header *)
+					skb_push(skb, sizeof(wlan_ng_prism2_header));
+				memset(ph, 0, sizeof(wlan_ng_prism2_header));
+
+				ph->msgcode	= DIDmsg_lnxind_wlansniffrm;
+				ph->msglen	= sizeof(wlan_ng_prism2_header);
+				strcpy(ph->devname, pAd->net_dev->name);
+
+				ph->hosttime.did	= DIDmsg_lnxind_wlansniffrm_hosttime;
+				ph->mactime.did		= DIDmsg_lnxind_wlansniffrm_mactime;
+				ph->channel.did		= DIDmsg_lnxind_wlansniffrm_channel;
+				ph->rssi.did		= DIDmsg_lnxind_wlansniffrm_rssi;
+				ph->signal.did		= DIDmsg_lnxind_wlansniffrm_signal;
+				ph->noise.did		= DIDmsg_lnxind_wlansniffrm_noise;
+				ph->rate.did		= DIDmsg_lnxind_wlansniffrm_rate;
+				ph->istx.did		= DIDmsg_lnxind_wlansniffrm_istx;
+				ph->frmlen.did		= DIDmsg_lnxind_wlansniffrm_frmlen;
+
+				ph->hosttime.len	= 4;
+				ph->mactime.len		= 4;
+				ph->channel.len		= 4;
+				ph->rssi.len		= 4;
+				ph->signal.len		= 4;
+				ph->noise.len		= 4;
+				ph->rate.len		= 4;
+				ph->istx.len		= 4;
+				ph->frmlen.len		= 4;
+
+				ph->hosttime.data	= jiffies;
+				ph->channel.data	= pAd->PortCfg.Channel;
+				ph->signal.data		= pRxD->PlcpRssi;
+				ph->noise.data		= (pAd->BbpWriteLatch[17] > pAd->BbpTuning.R17UpperBoundG) ?
+									pAd->BbpTuning.R17UpperBoundG : ((ULONG) pAd->BbpWriteLatch[17]);
+				ph->rssi.data		= ph->signal.data - ph->noise.data;
+				ph->frmlen.data		= pRxD->DataByteCnt;
+
+				if (pRxD->Ofdm == 1)
+				{
+					for (i = 4; i < 12; i++)
+						if (pRxD->PlcpSignal == RateIdToPlcpSignal[i])
+							ph->rate.data = _11G_RATES[i] * 2;
+				}
+				else
+					ph->rate.data = pRxD->PlcpSignal / 5;
+
+					// end prismheader setup
+
+			rfmontx_80211_receive:
+      				skb->dev = pAd->net_dev;
+      				memcpy(skb_put(skb, pRxD->DataByteCnt), pHeader, pRxD->DataByteCnt);
+					skb_reset_mac_header(skb);
+      				skb->pkt_type = PACKET_OTHERHOST;
+     				skb->protocol = htons(ETH_P_802_2);
+        			skb->ip_summed = CHECKSUM_NONE;
+	               		netif_rx(skb);
+       			}
+
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+				RTUSBBulkReceive(pAd);
+         			continue;
+		}
+
+		if (Status == NDIS_STATUS_SUCCESS)
+		{
+			// Apply packet filtering rule based on microsoft requirements.
+			Status = RTMPApplyPacketFilter(pAd, pRxD, pHeader);
+		}
+
+		// Add receive counters
+		if (Status == NDIS_STATUS_SUCCESS)
+		{
+			// Increase 802.11 counters & general receive counters
+			INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+		}
+		else
+		{
+			// Increase general counters
+			pAd->Counters.RxErrors++;
+		}
+
+		// Check for retry bit, if this bit is on, search the cache with SA & sequence
+		// as index, if matched, discard this frame, otherwise, update cache
+		// This check only apply to unicast data & management frames
+		if ((pRxD->U2M) && (Status == NDIS_STATUS_SUCCESS) && (pHeader->FC.Type != BTYPE_CNTL))
+		{
+			if (pHeader->FC.Retry)
+			{
+				if (RTMPSearchTupleCache(pAd, pHeader) == TRUE)
+				{
+					// Found retry frame in tuple cache, Discard this frame / fragment
+					// Increase 802.11 counters
+					INC_COUNTER64(pAd->WlanCounters.FrameDuplicateCount);
+					DBGPRINT_RAW(RT_DEBUG_INFO, "duplicate frame %d\n", pHeader->Sequence);
+					Status = NDIS_STATUS_FAILURE;
+				}
+				else
+				{
+					RTMPUpdateTupleCache(pAd, pHeader);
+				}
+			}
+			else	// Update Tuple Cache
+			{
+				RTMPUpdateTupleCache(pAd, pHeader);
+			}
+		}
+
+		if ((pRxD->U2M)	|| ((pHeader->FC.SubType == SUBTYPE_BEACON) && (MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, &pHeader->Addr2))))
+		{
+			if ((pAd->Antenna.field.NumOfAntenna == 2) && (pAd->Antenna.field.TxDefaultAntenna == 0) && (pAd->Antenna.field.RxDefaultAntenna == 0))
+			{
+				COLLECT_RX_ANTENNA_AVERAGE_RSSI(pAd, ConvertToRssi(pAd, (UCHAR)pRxD->PlcpRssi, RSSI_NO_1), 0); //Note: RSSI2 not used on RT73
+				pAd->PortCfg.NumOfAvgRssiSample ++;
+			}
+		}
+
+		//
+		// Do RxD release operation	for	all	failure	frames
+		//
+		if (Status == NDIS_STATUS_SUCCESS)
+		{
+			do
+			{
+				// pData : Pointer skip	the RxD Descriptior and the first 24 bytes,	802.11 HEADER
+				pData += LENGTH_802_11 + sizeof(RXD_STRUC);
+				DataSize = (USHORT) pRxD->DataByteCnt - LENGTH_802_11;
+
+				//
+				// CASE I. receive a DATA frame
+				//
+				if (pHeader->FC.Type == BTYPE_DATA)
+				{
+					// before LINK UP, all DATA frames are rejected
+					if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+					{
+						DBGPRINT(RT_DEBUG_TRACE,"RxDone- drop DATA frame before LINK UP(len=%d)\n",pRxD->DataByteCnt);
+						break;
+					}
+                    pAd->BulkInDataOneSecCount++;
+
+
+					// remove the 2 extra QOS CNTL bytes
+					if (pHeader->FC.SubType & 0x08)
+					{
+						pData += 2;
+						DataSize -= 2;
+					}
+
+					// remove the 2 extra AGGREGATION bytes
+					Msdu2Size = 0;
+					if (pHeader->FC.Order)
+					{
+						Msdu2Size = *pData + (*(pData+1) << 8);
+						if ((Msdu2Size <= 1536) && (Msdu2Size < DataSize))
+						{
+							pData += 2;
+							DataSize -= 2;
+						}
+						else
+							Msdu2Size = 0;
+					}
+
+					// Drop not my BSS frame
+					//
+					// Not drop EAPOL frame, since this have happen on the first time that we link up
+					// And need some more time to set BSSID to asic
+					// So pRxD->MyBss may be 0
+					//
+			        if (RTMPEqualMemory(EAPOL, pData + 6, 2))
+						EAPOLFrame = TRUE;
+					else
+						EAPOLFrame = FALSE;
+
+					if ((pRxD->MyBss == 0) && (EAPOLFrame != TRUE))
+						break; // give up this frame
+
+					// Drop NULL (+CF-POLL) (+CF-ACK) data frame
+					if ((pHeader->FC.SubType & 0x04) == 0x04)
+					{
+						DBGPRINT(RT_DEBUG_TRACE,"RxDone- drop NULL frame(subtype=%d)\n",pHeader->FC.SubType);
+						break;
+					}
+
+
+					// prepare 802.3 header: DA=addr1; SA=addr3 in INFRA mode, DA=addr2 in ADHOC mode
+					pDA = pHeader->Addr1;
+					if (INFRA_ON(pAd))
+						pSA	= pHeader->Addr3;
+					else
+						pSA	= pHeader->Addr2;
+
+					if (pHeader->FC.Wep) // frame received in encrypted format
+					{
+						if (pRxD->CipherAlg == CIPHER_NONE) // unsupported cipher suite
+						{
+							break; // give up this frame
+						}
+						else if (pAd->SharedKey[pRxD->KeyIndex].KeyLen == 0)
+						{
+							break; // give up this frame since the keylen is invalid.
+						}
+					}
+					else
+					{	// frame received in clear text
+						// encryption in-use but receive a non-EAPOL clear text frame, drop it
+						if (((pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
+							(pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+							(pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)) &&
+							(pAd->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
+							(!NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H)))
+						{
+							break; // give up this frame
+						}
+					}
+
+					//
+					// Case I.1  Process Broadcast & Multicast data frame
+					//
+					if (pRxD->Bcast || pRxD->Mcast)
+					{
+						PUCHAR pRemovedLLCSNAP;
+
+						INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+
+						// Drop Mcast/Bcast frame with fragment bit on
+						if (pHeader->FC.MoreFrag)
+						{
+							break; // give up this frame
+						}
+
+						// Filter out Bcast frame which AP relayed for us
+						if (pHeader->FC.FrDs && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress))
+						{
+							break; // give up this frame
+						}
+
+						// build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
+						CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+						REPORT_ETHERNET_FRAME_TO_LLC(pAd,Header802_3, pData, DataSize, pAd->net_dev);
+						DBGPRINT(RT_DEBUG_TRACE, "!!! report BCAST DATA to LLC (len=%d) !!!\n", DataSize);
+					}
+					//
+					// Case I.2  Process unicast-to-me DATA frame
+					//
+					else if	(pRxD->U2M)
+					{
+						RECORD_LATEST_RX_DATA_RATE(pAd, pRxD);
+
+//#if WPA_SUPPLICANT_SUPPORT
+                    if (pAd->PortCfg.WPA_Supplicant == TRUE)
+			{
+					// All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon)
+					// TBD : process fragmented EAPol frames
+					if(NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H))
+					{
+						PUCHAR pRemovedLLCSNAP;
+						int		success = 0;
+
+						// In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable
+						if ( pAd->PortCfg.IEEE8021X == TRUE
+						    && (EAP_CODE_SUCCESS == RTMPCheckWPAframeForEapCode(pAd, pData, DataSize, LENGTH_802_1_H)))
+						{
+								DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
+								pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+
+								success = 1;
+						}
+
+						// build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
+						CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+                    				REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
+						DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPoL DATA to LLC (len=%d) !!!\n", DataSize);
+
+						if(success)
+						{
+							// For static wep mode, need to set wep key to Asic again
+							if(pAd->PortCfg.IEEE8021x_required_keys == 0)
+							{
+							 	int idx;
+
+								idx = pAd->PortCfg.DefaultKeyId;
+								for (idx=0; idx < 4; idx++)
+								{
+									DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
+
+									if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
+									{
+						                union
+						                {
+		                                    char buf[sizeof(NDIS_802_11_WEP)+MAX_LEN_OF_KEY- 1];
+		                                    NDIS_802_11_WEP keyinfo;
+                                        }   WepKey;
+                                        int len;
+
+
+	                                    memset(&WepKey, 0, sizeof(WepKey));
+                                        len =pAd->PortCfg.DesireSharedKey[idx].KeyLen;
+
+			              			    memcpy(WepKey.keyinfo.KeyMaterial,
+			              			                    pAd->PortCfg.DesireSharedKey[idx].Key,
+			              			                    pAd->PortCfg.DesireSharedKey[idx].KeyLen);
+
+                                        WepKey.keyinfo.KeyIndex = 0x80000000 + idx;
+			                            WepKey.keyinfo.KeyLength = len;
+			                            pAd->SharedKey[idx].KeyLen =(UCHAR) (len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN);
+
+		                                // need to enqueue cmd to thread
+			                            RTUSBEnqueueCmdFromNdis(pAd, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey.keyinfo) + len - 1);
+									}
+								}
+							}
+						}
+
+						break;
+					}
+				    }
+			else
+			{
+//#else
+						// Special DATA frame that has to pass to MLME
+						//	 1. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
+						if (NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H) && (pAd->PortCfg.WpaState != SS_NOTUSE))
+						{
+							DataSize += LENGTH_802_11;
+							REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
+							DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
+							break;	// end of processing this frame
+						}
+//#endif
+                    }
+						if (pHeader->Frag == 0) 	// First or Only fragment
+						{
+							PUCHAR pRemovedLLCSNAP;
+
+							CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+							pAd->FragFrame.Flags &= 0xFFFFFFFE;
+
+							// Firt Fragment & LLC/SNAP been removed. Keep the removed LLC/SNAP for later on
+							// TKIP MIC verification.
+							if (pHeader->FC.MoreFrag && pRemovedLLCSNAP)
+							{
+								memcpy(pAd->FragFrame.Header_LLC, pRemovedLLCSNAP, LENGTH_802_1_H);
+								pAd->FragFrame.Flags |= 0x01;
+							}
+
+							// One & The only fragment
+							if (pHeader->FC.MoreFrag == FALSE)
+							{
+								if ((pHeader->FC.Order == 1)  && (Msdu2Size > 0)) // this is an aggregation
+								{
+									USHORT Payload1Size, Payload2Size;
+									PUCHAR pData2;
+
+									pAd->RalinkCounters.OneSecRxAggregationCount ++;
+									Payload1Size = DataSize - Msdu2Size;
+									Payload2Size = Msdu2Size - LENGTH_802_3;
+
+									REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, Payload1Size, pAd->net_dev);
+									DBGPRINT(RT_DEBUG_TRACE, "!!! report segregated MSDU1 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+															LENGTH_802_3+Payload1Size, Header802_3[12], Header802_3[13],
+															*pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));
+
+									pData2 = pData + Payload1Size + LENGTH_802_3;
+									REPORT_ETHERNET_FRAME_TO_LLC(pAd, pData + Payload1Size, pData2, Payload2Size, pAd->net_dev);
+									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report segregated MSDU2 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+															LENGTH_802_3+Payload2Size, *(pData2 -2), *(pData2 - 1),
+															*pData2, *(pData2+1),*(pData2+2),*(pData2+3),*(pData2+4),*(pData2+5),*(pData2+6),*(pData2+7));
+								}
+								else
+								{
+									REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, pAd->net_dev);
+									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report DATA (no frag) to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+															DataSize, Header802_3[12], Header802_3[13],
+															*pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));
+								}
+							}
+							// First fragment - record the 802.3 header and frame body
+							else
+							{
+								memcpy(&pAd->FragFrame.Buffer[LENGTH_802_3], pData, DataSize);
+								memcpy(pAd->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
+								pAd->FragFrame.RxSize	 = DataSize;
+								pAd->FragFrame.Sequence = pHeader->Sequence;
+								pAd->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
+							}
+						} //First or Only fragment
+						// Middle & End of fragment burst fragments
+						else
+						{
+							// No LLC-SNAP header in except the first fragment frame
+							if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
+								(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
+							{
+								// Fragment is not the same sequence or out of fragment number order
+								// Clear Fragment frame contents
+								memset(&pAd->FragFrame, 0, sizeof(FRAGMENT_FRAME));
+								break;
+							}
+							else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
+							{
+								// Fragment frame is too large, it exeeds the maximum frame size.
+								// Clear Fragment frame contents
+								memset(&pAd->FragFrame, 0, sizeof(FRAGMENT_FRAME));
+								break; // give up this frame
+							}
+
+							// concatenate this fragment into the re-assembly buffer
+							memcpy(&pAd->FragFrame.Buffer[LENGTH_802_3 + pAd->FragFrame.RxSize], pData, DataSize);
+							pAd->FragFrame.RxSize	+= DataSize;
+							pAd->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
+
+							// Last fragment
+							if (pHeader->FC.MoreFrag == FALSE)
+							{
+								// For TKIP frame, calculate the MIC value
+								if (pRxD->CipherAlg == CIPHER_TKIP)
+								{
+									pWpaKey = &pAd->SharedKey[pRxD->KeyIndex];
+
+									// Minus MIC length
+									pAd->FragFrame.RxSize -= 8;
+
+									if (pAd->FragFrame.Flags & 0x00000001)
+									{
+										// originally there's an LLC/SNAP field in the first fragment
+										// but been removed in re-assembly buffer. here we have to include
+										// this LLC/SNAP field upon calculating TKIP MIC
+										// pData = pAd->FragFrame.Header_LLC;
+										// Copy LLC data to the position in front of real data for MIC calculation
+										memcpy(&pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H],
+														pAd->FragFrame.Header_LLC,
+														LENGTH_802_1_H);
+										pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H];
+										DataSize = (USHORT)pAd->FragFrame.RxSize + LENGTH_802_1_H;
+									}
+									else
+									{
+										pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3];
+										DataSize = (USHORT)pAd->FragFrame.RxSize;
+									}
+
+									if (RTMPTkipCompareMICValue(
+											pAd,
+											pData,
+											pDA,
+											pSA,
+											pWpaKey->RxMic,
+											DataSize) == FALSE)
+									{
+										DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");
+										RTMPReportMicError(pAd, pWpaKey);
+										break;	// give up this frame
+									}
+								}
+
+								pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
+								REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, pAd->net_dev);
+								DBGPRINT(RT_DEBUG_TRACE, "!!! report DATA (fragmented) to LLC (len=%d) !!!\n", pAd->FragFrame.RxSize);
+							}
+						}
+					}
+				} // FC.Type == BTYPE_DATA
+				//
+				// CASE II. receive a MGMT frame
+				//
+				else if (pHeader->FC.Type == BTYPE_MGMT)
+				{
+					REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pRxD->DataByteCnt, pRxD->PlcpRssi, pRxD->PlcpSignal);
+					break;	// end of processing this frame
+				}
+				//
+				// CASE III. receive a CNTL frame
+				//
+				else if (pHeader->FC.Type == BTYPE_CNTL)
+					break; // give up this frame
+				//
+				// CASE IV. receive a frame of invalid type
+				//
+				else
+					break; // give up this frame
+			} while (FALSE); // ************* exit point *********
+
+		}//if (Status == NDIS_STATUS_SUCCESS)
+
+		else if (Status == NDIS_STATUS_RESET)
+		{
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
+			return;
+		}
+
+#ifdef BIG_ENDIAN
+		RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);
+		WriteBackToDescriptor((PUCHAR)pDestRxD, (PUCHAR)pRxD, FALSE, TYPE_RXD);
+#endif
+	  }//if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
+
+
+		pRxContext->InUse = FALSE;
+
+		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+		{
+			   pAd->rx_bk.data = (unsigned long)pAd;
+			   tasklet_schedule(&pAd->rx_bk);
+		}
+
+	} while (0);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBRxPacket Complete\n");
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBDequeueMLMEPacket(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PMGMT_STRUC		pMgmt;
+	unsigned long IrqFlags;
+
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBDequeueMLMEPacket\n");
+	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	while ((pAd->PopMgmtIndex != pAd->PushMgmtIndex) || (atomic_read(&pAd->MgmtQueueSize) > 0))
+	{
+		pMgmt = &pAd->MgmtRing[pAd->PopMgmtIndex];
+
+		if (RTUSBFreeDescriptorRequest(pAd, PRIO_RING, 0, 1) == NDIS_STATUS_SUCCESS)
+		{
+			atomic_dec(&pAd->MgmtQueueSize);
+			pAd->PopMgmtIndex = (pAd->PopMgmtIndex + 1) % MGMT_RING_SIZE;
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+
+			RTUSBMlmeHardTransmit(pAd, pMgmt);
+
+			MlmeFreeMemory(pAd, pMgmt->pBuffer);
+			pMgmt->pBuffer = NULL;
+			pMgmt->Valid = FALSE;
+
+			NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "not enough space in PrioRing[pAdapter->MgmtQueueSize=%d]\n", atomic_read(&pAd->MgmtQueueSize));
+			DBGPRINT(RT_DEBUG_TRACE, "RTUSBDequeueMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
+			pAd->PrioRingFirstIndex, pAd->PrioRingTxCnt,
+			pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);
+			break;
+		}
+	}
+	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBCleanUpMLMEWaitQueue(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	PMGMT_STRUC		pMgmt;
+	unsigned long IrqFlags;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEWaitQueue\n");
+
+	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	while (pAd->PopMgmtIndex != pAd->PushMgmtIndex)
+	{
+		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PopMgmtIndex];
+		MlmeFreeMemory(pAd, pMgmt->pBuffer);
+		pMgmt->pBuffer = NULL;
+		pMgmt->Valid = FALSE;
+		atomic_dec(&pAd->MgmtQueueSize);
+
+		pAd->PopMgmtIndex++;
+		if (pAd->PopMgmtIndex >= MGMT_RING_SIZE)
+		{
+			pAd->PopMgmtIndex = 0;
+		}
+	}
+	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEWaitQueue\n");
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Suspend MSDU transmission
+
+	Arguments:
+		pAd		Pointer	to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBSuspendMsduTransmission(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	DBGPRINT(RT_DEBUG_TRACE,"SCANNING, suspend MSDU transmission ...\n");
+
+	//
+	// Before BSS_SCAN_IN_PROGRESS, we need to keep Current R17 value and
+	// use Lowbound as R17 value on ScanNextChannel(...)
+	//
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		RTUSBReadBBPRegister(pAd, 17, &pAd->BbpTuning.R17CurrentValue);
+
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Resume MSDU transmission
+
+	Arguments:
+		pAd		Pointer	to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBResumeMsduTransmission(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	INT 	Index;
+
+	DBGPRINT(RT_DEBUG_ERROR,"SCAN done, resume MSDU transmission ...\n");
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+
+	//
+	// After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R17 value
+	//
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17CurrentValue);
+
+	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)))
+	{
+		// Dequeue all Tx software queue, if have been queued.
+		for (Index = 0; Index < 4; Index++)
+		{
+			if(!skb_queue_empty(&pAd->SendTxWaitQueue[Index]))
+			{
+				RTMPDeQueuePacket(pAd, Index);
+			}
+		}
+	}
+
+	// Kick bulk out
+	RTUSBKickBulkOut(pAd);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		API for MLME to transmit management frame to AP (BSS Mode)
+	or station (IBSS Mode)
+
+	Arguments:
+		pAd			Pointer	to our adapter
+		Buffer		Pointer to	memory of outgoing frame
+		Length		Size of outgoing management frame
+
+	Return Value:
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_PENDING
+		NDIS_STATUS_SUCCESS
+
+	Note:
+
+	========================================================================
+*/
+VOID	MiniportMMRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuffer,
+	IN	ULONG			Length)
+{
+	unsigned long IrqFlags;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "---> MiniportMMRequest\n");
+
+	if (pBuffer)
+	{
+		PMGMT_STRUC	pMgmt;
+
+		// Check management ring free avaliability
+		NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PushMgmtIndex];
+		// This management cell has been occupied
+		if (pMgmt->Valid == TRUE)
+		{
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+			MlmeFreeMemory(pAd, pBuffer);
+			pAd->RalinkCounters.MgmtRingFullCount++;
+			DBGPRINT_RAW(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
+		}
+		// Insert this request into software managemnet ring
+		else
+		{
+			pMgmt->pBuffer = pBuffer;
+			pMgmt->Length  = Length;
+			pMgmt->Valid   = TRUE;
+			pAd->PushMgmtIndex++;
+			atomic_inc(&pAd->MgmtQueueSize);
+			if (pAd->PushMgmtIndex >= MGMT_RING_SIZE)
+			{
+				pAd->PushMgmtIndex = 0;
+			}
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+		}
+	}
+	else
+		DBGPRINT(RT_DEBUG_WARN, "MiniportMMRequest (error:: NULL msg)\n");
+
+	RTUSBDequeueMLMEPacket(pAd);
+
+	// If pAd->PrioRingTxCnt is larger than 0, this means that prio_ring have something to transmit.
+	// Then call KickBulkOut to transmit it
+	if (pAd->PrioRingTxCnt > 0)
+	{
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+			AsicForceWakeup(pAd);
+		RTUSBKickBulkOut(pAd);
+	}
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<--- MiniportMMRequest\n");
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Search tuple cache for receive duplicate frame from unicast frames.
+
+	Arguments:
+		pAd				Pointer	to our adapter
+		pHeader			802.11 header of receiving frame
+
+	Return Value:
+		TRUE			found matched tuple cache
+		FALSE			no matched found
+
+	Note:
+
+	========================================================================
+*/
+BOOLEAN	RTMPSearchTupleCache(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader)
+{
+	INT	Index;
+
+	for (Index = 0; Index < MAX_CLIENT; Index++)
+	{
+		if (pAd->TupleCache[Index].Valid == FALSE)
+			continue;
+
+		if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2) &&
+			(pAd->TupleCache[Index].Sequence == pHeader->Sequence) &&
+			(pAd->TupleCache[Index].Frag == pHeader->Frag))
+		{
+//			DBGPRINT(RT_DEBUG_TRACE,"DUPCHECK - duplicate frame hit entry %d\n", Index);
+			return (TRUE);
+		}
+	}
+	return (FALSE);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Update tuple cache for new received unicast frames.
+
+	Arguments:
+		pAd				Pointer	to our adapter
+		pHeader			802.11 header of receiving frame
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPUpdateTupleCache(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader)
+{
+	UCHAR	Index;
+
+	for (Index = 0; Index < MAX_CLIENT; Index++)
+	{
+		if (pAd->TupleCache[Index].Valid == FALSE)
+		{
+			// Add new entry
+			COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
+			pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+			pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+			pAd->TupleCache[Index].Valid	= TRUE;
+			pAd->TupleCacheLastUpdateIndex	= Index;
+			DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - Add Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
+				pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
+				pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
+				pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
+			return;
+		}
+		else if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2))
+		{
+			// Update old entry
+			pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+			pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+			return;
+		}
+	}
+
+	// tuple cache full, replace the first inserted one (even though it may not be
+	// least referenced one)
+	if (Index == MAX_CLIENT)
+	{
+		pAd->TupleCacheLastUpdateIndex ++;
+		if (pAd->TupleCacheLastUpdateIndex >= MAX_CLIENT)
+			pAd->TupleCacheLastUpdateIndex = 0;
+		Index = pAd->TupleCacheLastUpdateIndex;
+
+		// replace with new entry
+		COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
+		pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+		pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+		pAd->TupleCache[Index].Valid	= TRUE;
+		DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - replace Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
+			pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
+			pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
+			pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Apply packet filter policy, return NDIS_STATUS_FAILURE if this frame
+		should be dropped.
+
+	Arguments:
+		pAd		Pointer	to our adapter
+		pRxD			Pointer	to the Rx descriptor
+		pHeader			Pointer to the 802.11 frame header
+
+	Return Value:
+		NDIS_STATUS_SUCCESS		Accept frame
+		NDIS_STATUS_FAILURE		Drop Frame
+
+	Note:
+		Maganement frame should bypass this filtering rule.
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPApplyPacketFilter(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PRXD_STRUC		pRxD,
+	IN	PHEADER_802_11	pHeader)
+{
+	UCHAR	i;
+
+	// 0. Management frame should bypass all these filtering rules.
+	if (pHeader->FC.Type == BTYPE_MGMT)
+		return(NDIS_STATUS_SUCCESS);
+
+	// 0.1	Drop all Rx frames if MIC countermeasures kicks in
+	if (pAd->PortCfg.MicErrCnt >= 2)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"Rx dropped by MIC countermeasure\n");
+		return(NDIS_STATUS_FAILURE);
+	}
+
+	// 1. Drop unicast to me packet if NDIS_PACKET_TYPE_DIRECTED is FALSE
+	if (pRxD->U2M)
+	{
+		if (pAd->bAcceptDirect == FALSE)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"Rx U2M dropped by RX_FILTER\n");
+			return(NDIS_STATUS_FAILURE);
+		}
+	}
+
+	// 2. Drop broadcast packet if NDIS_PACKET_TYPE_BROADCAST is FALSE
+	else if (pRxD->Bcast)
+	{
+		if (pAd->bAcceptBroadcast == FALSE)
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"Rx BCAST dropped by RX_FILTER\n");
+			return(NDIS_STATUS_FAILURE);
+		}
+	}
+
+	// 3. Drop (non-Broadcast) multicast packet if NDIS_PACKET_TYPE_ALL_MULTICAST is false
+	//	  and NDIS_PACKET_TYPE_MULTICAST is false.
+	//	  If NDIS_PACKET_TYPE_MULTICAST is true, but NDIS_PACKET_TYPE_ALL_MULTICAST is false.
+	//	  We have to deal with multicast table lookup & drop not matched packets.
+	else if (pRxD->Mcast)
+	{
+		if (pAd->bAcceptAllMulticast == FALSE)
+		{
+			if (pAd->bAcceptMulticast == FALSE)
+			{
+				DBGPRINT(RT_DEBUG_INFO,"Rx MCAST dropped by RX_FILTER\n");
+				return(NDIS_STATUS_FAILURE);
+			}
+			else
+			{
+				// Selected accept multicast packet based on multicast table
+				for (i = 0; i < pAd->NumberOfMcastAddresses; i++)
+				{
+					if (MAC_ADDR_EQUAL(pHeader->Addr1, pAd->McastTable[i]))
+						break;		// Matched
+				}
+
+				// Not matched
+				if (i == pAd->NumberOfMcastAddresses)
+				{
+					DBGPRINT(RT_DEBUG_INFO,"Rx MCAST %02x:%02x:%02x:%02x:%02x:%02x dropped by RX_FILTER\n",
+						pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2],
+						pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
+					return(NDIS_STATUS_FAILURE);
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_INFO,"Accept multicast %02x:%02x:%02x:%02x:%02x:%02x\n",
+						pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2],
+						pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
+				}
+			}
+		}
+	}
+
+	// 4. Not U2M, not Mcast, not Bcast, must be unicast to other DA.
+	//	  Since we did not implement promiscuous mode, just drop this kind of packet for now.
+	else
+		return(NDIS_STATUS_FAILURE);
+
+	return(NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
+
+	Arguments:
+		pRxD		Pointer	to the Rx descriptor
+
+	Return Value:
+		NDIS_STATUS_SUCCESS		No err
+		NDIS_STATUS_FAILURE		Error
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	RTMPCheckRxDescriptor(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PHEADER_802_11	pHeader,
+	IN	PRXD_STRUC	pRxD)
+{
+	PCIPHER_KEY 	pWpaKey;
+
+	// Phy errors & CRC errors
+	if (/*(pRxD->PhyErr) ||*/ (pRxD->Crc))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->Crc error\n")
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
+	if (pHeader->FC.ToDs && pAd->PortCfg.BssType != BSS_MONITOR)		//Don't drop to_ds frame if in monitor mode
+		return(NDIS_STATUS_FAILURE);
+
+	// Paul 04-03 for OFDM Rx length issue
+	if (pRxD->DataByteCnt > MAX_AGGREGATION_SIZE)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
+	// I am kind of doubting the U2M bit operation
+	// if (pRxD->U2M == 0)
+	//	return(NDIS_STATUS_FAILURE);
+
+	// drop decyption fail frame
+	if (pRxD->CipherErr)
+	{
+		UINT i;
+		PUCHAR ptr = (PUCHAR)pHeader;
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"ERROR: CRC ok but CipherErr %d (len = %d, Mcast=%d, Cipher=%s, KeyId=%d)\n",
+			pRxD->CipherErr,
+			pRxD->DataByteCnt,
+			pRxD->Mcast | pRxD->Bcast,
+			CipherName[pRxD->CipherAlg],
+			pRxD->KeyIndex);
+#if 1
+		for (i=0;i<64; i+=16)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x - %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+				*ptr,*(ptr+1),*(ptr+2),*(ptr+3),*(ptr+4),*(ptr+5),*(ptr+6),*(ptr+7),
+				*(ptr+8),*(ptr+9),*(ptr+10),*(ptr+11),*(ptr+12),*(ptr+13),*(ptr+14),*(ptr+15));
+			ptr += 16;
+		}
+#endif
+
+
+		//
+		// MIC Error
+		//
+		if (pRxD->CipherErr == 2)
+		{
+			pWpaKey = &pAd->SharedKey[pRxD->KeyIndex];
+			RTMPReportMicError(pAd, pWpaKey);
+			DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error\n");
+		}
+
+		if ((pRxD->CipherAlg == CIPHER_AES) &&
+			(pHeader->Sequence == pAd->FragFrame.Sequence))
+		{
+			//
+			// Acceptable since the First FragFrame no CipherErr problem.
+			//
+			return (NDIS_STATUS_FAILURE);
+		}
+
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	return (NDIS_STATUS_SUCCESS);
+}
+
+#if WPA_SUPPLICANT_SUPPORT
+static void ralink_michael_mic_failure(struct net_device *dev, PCIPHER_KEY pWpaKey)
+{
+	union iwreq_data wrqu;
+	char buf[128];
+
+	/* TODO: needed parameters: count, keyid, key type, TSC */
+
+	//Check for Group or Pairwise MIC error
+	if (pWpaKey->Type == PAIRWISE_KEY)
+		sprintf(buf, "MLME-MICHAELMICFAILURE.indication unicast");
+	else
+		sprintf(buf, "MLME-MICHAELMICFAILURE.indication broadcast");
+	memset(&wrqu, 0, sizeof(wrqu));
+	wrqu.data.length = strlen(buf);
+	//send mic error event to wpa_supplicant
+	wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
+}
+#endif
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Process MIC error indication and record MIC error timer.
+
+	Arguments:
+		pAd		Pointer	to our adapter
+		pWpaKey			Pointer	to the WPA key structure
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTMPReportMicError(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PCIPHER_KEY		pWpaKey)
+{
+	unsigned long	Now;
+	struct
+	{
+		NDIS_802_11_STATUS_INDICATION		Status;
+		NDIS_802_11_AUTHENTICATION_REQUEST	Request;
+	}	Report;
+
+#if WPA_SUPPLICANT_SUPPORT
+    if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+        //report mic error to wpa_supplicant
+        ralink_michael_mic_failure(pAd->net_dev, pWpaKey);
+    }
+#endif
+
+	// 0. Set Status to indicate auth error
+	Report.Status.StatusType = Ndis802_11StatusType_Authentication;
+
+	// 1. Check for Group or Pairwise MIC error
+	if (pWpaKey->Type == PAIRWISE_KEY)
+		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
+	else
+		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
+
+	// 2. Copy AP MAC address
+	COPY_MAC_ADDR(Report.Request.Bssid, pWpaKey->BssId);
+
+	// 3. Calculate length
+	Report.Request.Length = sizeof(NDIS_802_11_AUTHENTICATION_REQUEST);
+
+	// 4. Record Last MIC error time and count
+	Now = jiffies;
+	if (pAd->PortCfg.MicErrCnt == 0)
+	{
+		pAd->PortCfg.MicErrCnt++;
+		pAd->PortCfg.LastMicErrorTime = Now;
+	}
+	else if (pAd->PortCfg.MicErrCnt == 1)
+	{
+		if (time_after(Now, pAd->PortCfg.LastMicErrorTime + 60 * 1000))
+		{
+			// Update Last MIC error time, this did not violate two MIC errors within 60 seconds
+			pAd->PortCfg.LastMicErrorTime = Now;
+		}
+		else
+		{
+			pAd->PortCfg.LastMicErrorTime = Now;
+			// Violate MIC error counts, MIC countermeasures kicks in
+			pAd->PortCfg.MicErrCnt++;
+			// We shall block all reception
+			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
+			RTUSBRejectPendingPackets(pAd);
+			RTUSBCleanUpDataBulkOutQueue(pAd);
+		}
+	}
+	else
+	{
+		// MIC error count >= 2
+		// This should not happen
+		;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+		Send out a NULL frame to AP. The prpose is to inform AP this client
+		current PSM bit.
+	NOTE:
+		This routine should only be used in infrastructure mode.
+	==========================================================================
+ */
+VOID	RTMPSendNullFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			TxRate)
+{
+	PTX_CONTEXT		pNullContext;
+	PTXD_STRUC		pTxD;
+#ifdef BIG_ENDIAN
+	PTXD_STRUC		pDestTxD;
+	TXD_STRUC		TxD;
+#endif
+	UCHAR			QueIdx =QID_AC_VO;
+	PHEADER_802_11	pHdr80211;
+	ULONG			TransferBufferLength;
+
+	if(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+	{
+		QueIdx =QID_AC_VO;
+	}
+	else
+	{
+		QueIdx =QID_AC_BE;
+	}
+
+	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		return;
+	}
+
+	// WPA 802.1x secured port control
+	if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+		(pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+#if WPA_SUPPLICANT_SUPPORT
+	    || (pAd->PortCfg.IEEE8021X == TRUE)
+#endif
+        ) &&
+		(pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+	{
+		return;
+	}
+
+	pNullContext = &(pAd->NullContext);
+	if (pNullContext->InUse == FALSE)
+	{
+		// Set the in use bit
+		pNullContext->InUse = TRUE;
+
+		// Fill Null frame body and TxD
+#ifndef BIG_ENDIAN
+		pTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
+#else
+		pDestTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
+		TxD = *pDestTxD;
+		pTxD = &TxD;
+		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+
+		pHdr80211 = (PHEADER_802_11) &pAd->NullContext.TransferBuffer->NullFrame;
+		MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->PortCfg.Bssid, pAd->PortCfg.Bssid);
+		pHdr80211->Duration = RTMPCalcDuration(pAd, TxRate, 14);
+		pHdr80211->FC.Type = BTYPE_DATA;
+		pHdr80211->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
+
+
+#ifdef BIG_ENDIAN
+		RTMPFrameEndianChange(pAd, (PUCHAR)pHdr80211, DIR_WRITE, FALSE);
+		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+		*pDestTxD = TxD;
+		pTxD = pDestTxD;
+#endif
+		RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY,
+			IFS_BACKOFF, TxRate, sizeof(HEADER_802_11), QueIdx, PID_MGMT_FRAME, FALSE);
+
+		DBGPRINT(RT_DEBUG_ERROR, "SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[TxRate]);
+	}
+
+	// Build our URB for USBD
+	TransferBufferLength = sizeof(TXD_STRUC) + sizeof(HEADER_802_11);
+	if ((TransferBufferLength % 2) == 1)
+		TransferBufferLength++;
+	if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+		TransferBufferLength += 2;
+
+	// Fill out frame length information for global Bulk out arbitor
+	pNullContext->BulkOutSize = TransferBufferLength;
+	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
+
+	// Kick bulk out
+	RTUSBKickBulkOut(pAd);
+}
+
+VOID	RTMPSendRTSCTSFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PUCHAR			pDA,
+	IN	ULONG			NextMpduSize,
+	IN	UCHAR			TxRate,
+	IN	UCHAR			RTSRate,
+	IN	USHORT			AckDuration,
+	IN	UCHAR			QueIdx,
+	IN	UCHAR			FrameGap,
+	IN	UCHAR			Type)
+{
+	PTX_CONTEXT 		pTxContext;
+	PTXD_STRUC			pTxD;
+#ifdef BIG_ENDIAN
+	PTXD_STRUC			pDestTxD;
+	TXD_STRUC			TxD;
+#endif
+	PRTS_FRAME			pRtsFrame;
+	PUCHAR				pBuf;
+	ULONG				Length = 0;
+	ULONG				TransferBufferLength = 0;
+
+	if ((Type != SUBTYPE_RTS) && ( Type != SUBTYPE_CTS))
+	{
+		DBGPRINT(RT_DEBUG_WARN, "Making RTS/CTS Frame failed, type not matched!\n");
+		return;
+	}
+	else if ((Type == SUBTYPE_RTS) && ((*pDA) & 0x01))
+	{
+		if ((*pDA) & 0x01)
+		{
+			// should not use RTS/CTS to protect MCAST frame since no one will reply CTS
+			DBGPRINT(RT_DEBUG_INFO,"Not use RTS Frame to proect MCAST frame\n");
+			return;
+		}
+	}
+
+	pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+	if (pTxContext->InUse == FALSE)
+	{
+		pTxContext->InUse	= TRUE;
+		pTxContext->LastOne = FALSE;
+		pAd->NextTxIndex[QueIdx]++;
+		if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
+	    {
+            pAd->NextTxIndex[QueIdx] = 0;
+        }
+
+#ifndef BIG_ENDIAN
+		pTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+#else
+		pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+		TxD = *pDestTxD;
+		pTxD = &TxD;
+		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+
+		pRtsFrame = (PRTS_FRAME) &pTxContext->TransferBuffer->RTSFrame;
+		pBuf = (PUCHAR) pRtsFrame;
+
+		memset(pRtsFrame, 0, sizeof(RTS_FRAME));
+		pRtsFrame->FC.Type	  = BTYPE_CNTL;
+		// CTS-to-self's duration = SIFS + MPDU
+		pRtsFrame->Duration = (2 * pAd->PortCfg.Dsifs) + RTMPCalcDuration(pAd, TxRate, NextMpduSize) + AckDuration;// SIFS + Data + SIFS + ACK
+
+		// Write Tx descriptor
+		// Don't kick tx start until all frames are prepared
+		// RTS has to set more fragment bit for fragment burst
+		// RTS did not encrypt
+		if (Type == SUBTYPE_RTS)
+		{
+			DBGPRINT(RT_DEBUG_INFO,"Making RTS Frame\n");
+
+			pRtsFrame->FC.SubType = SUBTYPE_RTS;
+			COPY_MAC_ADDR(pRtsFrame->Addr1, pDA);
+			COPY_MAC_ADDR(pRtsFrame->Addr2, pAd->CurrentAddress);
+
+			// RTS's duration need to include and extra (SIFS + CTS) time
+			pRtsFrame->Duration += (pAd->PortCfg.Dsifs + RTMPCalcDuration(pAd, RTSRate, 14)); // SIFS + CTS-Duration
+
+			Length = sizeof(RTS_FRAME);
+
+#ifdef BIG_ENDIAN
+			RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
+			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+			*pDestTxD = TxD;
+			pTxD = pDestTxD;
+#endif
+			RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, TRUE, TRUE, FALSE, SHORT_RETRY,
+				FrameGap, RTSRate, Length, QueIdx, 0, FALSE);
+		}
+		else if (Type == SUBTYPE_CTS)
+		{
+			DBGPRINT(RT_DEBUG_INFO,"Making CTS-to-self Frame\n");
+			pRtsFrame->FC.SubType = SUBTYPE_CTS;
+			COPY_MAC_ADDR(pRtsFrame->Addr1, pAd->CurrentAddress);
+
+			Length = 10;  //CTS frame length.
+
+#ifdef BIG_ENDIAN
+			RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
+			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+			*pDestTxD = TxD;
+			pTxD = pDestTxD;
+#endif
+			RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, TRUE, FALSE, SHORT_RETRY,
+				FrameGap, RTSRate, Length, QueIdx, 0, FALSE);
+		}
+
+
+		// Build our URB for USBD
+		TransferBufferLength = sizeof(TXD_STRUC) + Length;
+		if ((TransferBufferLength % 2) == 1)
+			TransferBufferLength++;
+		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+			TransferBufferLength += 2;
+
+		// Fill out frame length information for global Bulk out arbitor
+		pTxContext->BulkOutSize = TransferBufferLength;
+		pTxContext->bWaitingBulkOut = TRUE;
+
+
+        pAd->TxRingTotalNumber[QueIdx]++;  // sync. to TxCount
+		atomic_inc(&pAd->TxCount);
+		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx);
+
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculates the duration which is required to transmit out frames
+	with given size and specified rate.
+
+	Arguments:
+		pAd				Pointer	to our adapter
+		Rate			Transmit rate
+		Size			Frame size in units of byte
+
+	Return Value:
+		Duration number in units of usec
+
+	Note:
+
+	========================================================================
+*/
+USHORT	RTMPCalcDuration(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Rate,
+	IN	ULONG			Size)
+{
+	ULONG	Duration = 0;
+
+	if (Rate < RATE_FIRST_OFDM_RATE) // CCK
+	{
+		if ((Rate > RATE_1) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
+			Duration = 96;	// 72+24 preamble+plcp
+		else
+			Duration = 192; // 144+48 preamble+plcp
+
+		Duration += (USHORT)((Size << 4) / RateIdTo500Kbps[Rate]);
+		if ((Size << 4) % RateIdTo500Kbps[Rate])
+			Duration ++;
+	}
+	else // OFDM rates
+	{
+		Duration = 20 + 6;		// 16+4 preamble+plcp + Signal Extension
+		Duration += 4 * (USHORT)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
+		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
+			Duration += 4;
+	}
+
+	return (USHORT)Duration;
+
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Check the out going frame, if this is an DHCP or ARP datagram
+	will be duplicate another frame at low data rate transmit.
+
+	Arguments:
+		pAd			Pointer	to our adapter
+		pSkb		Pointer to outgoing skb buffer
+
+	Return Value:
+		TRUE		To be transmitted at Low data rate transmit. (1Mbps/6Mbps)
+		FALSE		Do nothing.
+
+	Note:
+
+		MAC header + IP Header + UDP Header
+		  14 Bytes	  20 Bytes
+
+		UDP Header
+		00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|
+						Source Port
+		16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+					Destination Port
+
+		port 0x43 means Bootstrap Protocol, server.
+		Port 0x44 means Bootstrap Protocol, client.
+
+	========================================================================
+*/
+BOOLEAN 	RTMPCheckDHCPFrame(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	struct sk_buff	*pSkb)
+{
+	PUCHAR			pSrc;
+	ULONG			SrcLen = 0;
+
+	pSrc = (PVOID)pSkb->data;
+	SrcLen = pSkb->len;
+
+	// Check ARP packet
+	if (SrcLen >= 13)
+	{
+		if ((pSrc[12] == 0x08) && (pSrc[13] == 0x06))
+		{
+			DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - ARP packet\n");
+			return TRUE;
+		}
+	}
+
+	// Check foe DHCP & BOOTP protocol
+	if (SrcLen >= 37)
+	{
+		if ((pSrc[12] == 0x08) && (pSrc[13] == 0x00) && // It's an IP packet
+		    ((pSrc[14] & 0xf0) == 0x40) && // It's IPv4
+		    (pSrc[23] == 17) && // It's UDP
+		    ((pSrc[36] == 0x00) && ((pSrc[37] == 0x43) || (pSrc[37] == 0x44))) ) // dest port is a DHCP port
+		{
+			DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - DHCP packet\n");
+			return TRUE;
+		}
+		else
+		{
+			#ifdef DBG
+			int is_ip = ((pSrc[12] == 0x08) && (pSrc[13] == 0x00));
+			int is_ipv4 = ((pSrc[14] & 0xf0) == 0x40);
+			int is_udp = (pSrc[23] == 17);
+			int dest_port = (pSrc[36] << 8) | pSrc[37];
+			#endif
+
+			DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - not DHCP, ip %d ipv4 %d udp %d destport %d\n",
+				 is_ip, is_ipv4, is_udp, dest_port );
+		}
+
+	}
+
+	return FALSE;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_io.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_io.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/rtusb_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/rtusb_io.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1132 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	rtusb_io.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Paul Lin	06-25-2004	created
+ *
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+
+/*
+	========================================================================
+
+	Routine Description: NIC initialization complete
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBFirmwareRun(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x01,
+		0x8,
+		0,
+		NULL,
+		0);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Read various length data from RT2573
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiRead(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PVOID			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x7,
+		0,
+		Offset,
+		pData,
+		length);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Write various length data to RT2573
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiWrite(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	PVOID			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x6,
+		0,
+		Offset,
+		pData,
+		length);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Read 32-bit MAC register
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBReadMACRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PULONG			pValue)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x7,
+		0,
+		Offset,
+		pValue,
+		4);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Write 32-bit MAC register
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteMACRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	ULONG			Value)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x6,
+		0x00,
+		Offset,
+		&Value,
+		4);
+
+	return Status;
+}
+
+NTSTATUS	RT73WriteTXRXCSR0(
+	IN	PRTMP_ADAPTER pAd,
+	IN	BOOLEAN 	disableRx,
+	IN	BOOLEAN		dropControl)
+{
+    ULONG val = 0x0046b032;
+
+    if (pAd->PortCfg.BssType != BSS_MONITOR)
+    {
+	val |= 0x00100000;		//Drop promiscuous frames if not in rfmon
+	val |= 0x00200000;		//Drop to_ds (packets from station to access point/distribution system)
+    }
+
+    if (disableRx == TRUE)
+    {
+	val |= 0x00010000;
+    }
+
+    if (dropControl == TRUE)
+    {
+	val |= 0x00080000;
+    }
+
+    return RTUSBWriteMACRegister(pAd, TXRX_CSR0, val);
+}
+
+/*
+	========================================================================
+
+	Routine Description: Write 32-bit MAC register
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS    RTUSBSetLED(
+	IN	PRTMP_ADAPTER		pAd,
+	IN	MCU_LEDCS_STRUC		LedStatus,
+	IN	USHORT				LedIndicatorStrength)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x0a,
+		LedStatus.word,
+		LedIndicatorStrength,
+		NULL,
+		0);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Read 8-bit BBP register
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBReadBBPRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Id,
+	IN	PUCHAR			pValue)
+{
+	PHY_CSR3_STRUC  *PhyCsr3 = kzalloc(sizeof(PHY_CSR3_STRUC), GFP_KERNEL);
+	UINT			i = 0;
+
+	if(!PhyCsr3) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+
+	// Verify the busy condition
+	do
+	{
+		RTUSBReadMACRegister(pAd, PHY_CSR3, &PhyCsr3->word);
+		if (!(PhyCsr3->field.Busy == BUSY))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		//
+		// Read failed then Return Default value.
+		//
+		*pValue = pAd->BbpWriteLatch[Id];
+
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		kfree(PhyCsr3);
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	// Prepare for write material
+	PhyCsr3->word         = 0;
+	PhyCsr3->field.fRead      = 1;
+	PhyCsr3->field.Busy     = 1;
+	PhyCsr3->field.RegNum     = Id;
+	RTUSBWriteMACRegister(pAd, PHY_CSR3, PhyCsr3->word);
+
+	i = 0;
+	// Verify the busy condition
+	do
+	{
+		RTUSBReadMACRegister(pAd, PHY_CSR3, &PhyCsr3->word);
+		if (!(PhyCsr3->field.Busy == BUSY))
+		{
+			*pValue = (UCHAR)PhyCsr3->field.Value;
+			break;
+		}
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		//
+		// Read failed then Return Default value.
+		//
+		*pValue = pAd->BbpWriteLatch[Id];
+
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		kfree(PhyCsr3);
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	kfree(PhyCsr3);
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Write 8-bit BBP register
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteBBPRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	UCHAR			Id,
+	IN	UCHAR			Value)
+{
+	PHY_CSR3_STRUC  *PhyCsr3 = kzalloc(sizeof(PHY_CSR3_STRUC), GFP_KERNEL);
+	UINT			i = 0;
+
+	if(!PhyCsr3) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+	// Verify the busy condition
+	do
+	{
+		RTUSBReadMACRegister(pAd, PHY_CSR3, &PhyCsr3->word);
+		if (!(PhyCsr3->field.Busy == BUSY))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		kfree(PhyCsr3);
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	// Prepare for write material
+	PhyCsr3->word         = 0;
+	PhyCsr3->field.fRead      = 0;
+	PhyCsr3->field.Value      = Value;
+	PhyCsr3->field.Busy     = 1;
+	PhyCsr3->field.RegNum     = Id;
+	RTUSBWriteMACRegister(pAd, PHY_CSR3, PhyCsr3->word);
+	pAd->BbpWriteLatch[Id] = Value;
+
+	kfree(PhyCsr3);
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+
+	Routine Description: Write RF register through MAC
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteRFRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			Value)
+{
+	PHY_CSR4_STRUC  *PhyCsr4 = kzalloc(sizeof(PHY_CSR4_STRUC), GFP_KERNEL);
+	UINT			i = 0;
+
+	if(!PhyCsr4) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+	do
+	{
+		RTUSBReadMACRegister(pAd, PHY_CSR4, &PhyCsr4->word);
+		if (!(PhyCsr4->field.Busy))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		kfree(PhyCsr4);
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	RTUSBWriteMACRegister(pAd, PHY_CSR4, Value);
+
+	kfree(PhyCsr4);
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBReadEEPROM(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	OUT	PVOID			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x9,
+		0,
+		Offset,
+		pData,
+		length);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteEEPROM(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	USHORT			Offset,
+	IN	PVOID			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x8,
+		0,
+		Offset,
+		pData,
+		length);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS RTUSBPutToSleep(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x01,
+		0x07,
+		0,
+		NULL,
+		0);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS RTUSBWakeUp(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAd,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x01,
+		0x09,
+		0,
+		NULL,
+		0);
+
+	return Status;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBInitializeCmdQ(
+	IN	PCmdQ	cmdq)
+{
+	cmdq->head = NULL;
+	cmdq->tail = NULL;
+	cmdq->size = 0;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	NDIS_OID		Oid,
+	IN	BOOLEAN			SetInformation,
+	IN	PVOID			pInformationBuffer,
+	IN	ULONG			InformationBufferLength)
+{
+	PCmdQElmt	cmdqelmt = NULL;
+    PCmdQElmt	Dcmdqelmt = NULL;
+	unsigned long       IrqFlags;
+
+	if (pAd->RTUSBCmdThr_pid < 0)
+		return (NDIS_STATUS_RESOURCES);
+
+    cmdqelmt = (PCmdQElmt) kmalloc(sizeof(CmdQElmt), MEM_ALLOC_FLAG);
+	if (!cmdqelmt)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+		//kfree((PCmdQElmt)cmdqelmt);
+		return NDIS_STATUS_RESOURCES;
+	}
+
+	if ((Oid == RT_OID_MULTI_READ_MAC) ||
+		(Oid == RT_OID_VENDOR_READ_BBP) ||
+#ifdef DBG
+		(Oid == RT_OID_802_11_QUERY_HARDWARE_REGISTER) ||
+#endif
+		(Oid == RT_OID_USB_VENDOR_EEPROM_READ))
+	{
+		cmdqelmt->buffer = pInformationBuffer;
+	}
+	else
+	{
+		cmdqelmt->buffer = NULL;
+		if (pInformationBuffer != NULL)
+		{
+			cmdqelmt->buffer =	kmalloc(InformationBufferLength, MEM_ALLOC_FLAG);
+			if ((!cmdqelmt->buffer) )
+			{
+				//kfree((PVOID)cmdqelmt->buffer);
+				if(cmdqelmt != NULL){
+					kfree((PCmdQElmt)cmdqelmt);
+				}
+				return (NDIS_STATUS_RESOURCES);
+			}
+			else
+			{
+				memcpy(cmdqelmt->buffer, pInformationBuffer, InformationBufferLength);
+				cmdqelmt->bufferlength = InformationBufferLength;
+			}
+		}
+		else
+			cmdqelmt->bufferlength = 0;
+	}
+
+	cmdqelmt->command = Oid;
+	cmdqelmt->CmdFromNdis = TRUE;
+	if (SetInformation == TRUE)
+		cmdqelmt->SetOperation = TRUE;
+	else
+		cmdqelmt->SetOperation = FALSE;
+
+	NdisAcquireSpinLock(&pAd->CmdQLock,  IrqFlags);
+	EnqueueCmd((&pAd->CmdQ), cmdqelmt);
+	NdisReleaseSpinLock(&pAd->CmdQLock,  IrqFlags);
+
+#if 1
+	NdisAcquireSpinLock(&pAd->CmdQLock,  IrqFlags);
+	if( pAd->CmdQ.size > 2048 ){//Thomas add
+		RTUSBDequeueCmd(&pAd->CmdQ, &Dcmdqelmt);
+		if(Dcmdqelmt != NULL){
+			if (Dcmdqelmt->buffer != NULL){
+				kfree(Dcmdqelmt->buffer);
+			}
+			kfree((PCmdQElmt)Dcmdqelmt);
+			Dcmdqelmt=NULL;
+		}
+	}
+	NdisReleaseSpinLock(&pAd->CmdQLock,  IrqFlags);
+#endif
+
+	RTUSBCMDUp(pAd);
+
+	if ((Oid == OID_802_11_BSSID_LIST_SCAN) ||
+		(Oid == RT_OID_802_11_BSSID) ||
+		(Oid == OID_802_11_SSID) ||
+		(Oid == OID_802_11_DISASSOCIATE))
+	{
+		return(NDIS_STATUS_SUCCESS);
+	}
+
+    return(NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBEnqueueInternalCmd(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	NDIS_OID		Oid)
+{
+	PCmdQElmt	cmdqelmt = NULL;
+	unsigned long       IrqFlags;
+
+	if (pAd->RTUSBCmdThr_pid < 0)
+		return;
+
+	switch (Oid)
+	{
+		case RT_OID_CHECK_GPIO:
+			cmdqelmt = &(pAd->CmdQElements[CMD_CHECK_GPIO]);
+			break;
+
+		case RT_OID_PERIODIC_EXECUT:
+			cmdqelmt = &(pAd->CmdQElements[CMD_PERIODIC_EXECUT]);
+			break;
+
+		//For Alpha only
+		case RT_OID_ASICLED_EXECUT:
+			cmdqelmt = &(pAd->CmdQElements[CMD_ASICLED_EXECUT]);
+			break;
+
+		case RT_OID_UPDATE_TX_RATE:
+			cmdqelmt = &(pAd->CmdQElements[CMD_UPDATE_TX_RATE]);
+			break;
+
+		case RT_OID_SET_PSM_BIT_SAVE:
+			cmdqelmt = &(pAd->CmdQElements[CMD_SET_PSM_SAVE]);
+			break;
+
+		case RT_OID_LINK_DOWN:
+			cmdqelmt = &(pAd->CmdQElements[CMD_LINK_DOWN]);
+			break;
+
+		case RT_OID_USB_RESET_BULK_IN:
+			cmdqelmt = &(pAd->CmdQElements[CMD_RESET_BULKIN]);
+			break;
+
+		case RT_OID_USB_RESET_BULK_OUT:
+			cmdqelmt = &(pAd->CmdQElements[CMD_RESET_BULKOUT]);
+			break;
+
+		case RT_OID_RESET_FROM_ERROR:
+			cmdqelmt = &(pAd->CmdQElements[CMD_RESET_FROM_ERROR]);
+			break;
+
+		case RT_OID_RESET_FROM_NDIS:
+			cmdqelmt = &(pAd->CmdQElements[CMD_RESET_FROM_NDIS]);
+			break;
+
+		case RT_PERFORM_SOFT_DIVERSITY:
+			cmdqelmt = &(pAd->CmdQElements[CMD_SOFT_DIVERSITY]);
+			break;
+
+        case RT_OID_FORCE_WAKE_UP:
+            cmdqelmt = &(pAd->CmdQElements[CMD_FORCE_WAKEUP]);
+            break;
+
+        case RT_OID_SET_PSM_BIT_ACTIVE:
+            cmdqelmt = &(pAd->CmdQElements[CMD_SET_PSM_ACTIVE]);
+        break;
+
+		default:
+			break;
+	}
+
+	if ((cmdqelmt != NULL) && (cmdqelmt->InUse == FALSE) && (pAd->RTUSBCmdThr_pid > 0))
+	{
+		cmdqelmt->InUse = TRUE;
+		cmdqelmt->command = Oid;
+
+		NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+		EnqueueCmd((&pAd->CmdQ), cmdqelmt);
+		NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+
+		RTUSBCMDUp(pAd);
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	RTUSBDequeueCmd(
+	IN	PCmdQ		cmdq,
+	OUT	PCmdQElmt	*pcmdqelmt)
+{
+	*pcmdqelmt = cmdq->head;
+
+	if (*pcmdqelmt != NULL)
+	{
+		cmdq->head = cmdq->head->next;
+		cmdq->size--;
+		if (cmdq->size == 0)
+			cmdq->tail = NULL;
+	}
+}
+
+/*
+    ========================================================================
+	  usb_control_msg - Builds a control urb, sends it off and waits for completion
+	  @dev: pointer to the usb device to send the message to
+	  @pipe: endpoint "pipe" to send the message to
+	  @request: USB message request value
+	  @requesttype: USB message request type value
+	  @value: USB message value
+	  @index: USB message index value
+	  @data: pointer to the data to send
+	  @size: length in bytes of the data to send
+	  @timeout: time in jiffies to wait for the message to complete before
+			  timing out (if 0 the wait is forever)
+	  Context: !in_interrupt ()
+
+	  This function sends a simple control message to a specified endpoint
+	  and waits for the message to complete, or timeout.
+	  If successful, it returns the number of bytes transferred, otherwise a negative error number.
+
+	 Don't use this function from within an interrupt context, like a
+	  bottom half handler.	If you need an asynchronous message, or need to send
+	  a message from within interrupt context, use usb_submit_urb()
+	  If a thread in your driver uses this call, make sure your disconnect()
+	  method can wait for it to complete.  Since you don't have a handle on
+	  the URB used, you can't cancel the request.
+
+
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+INT	    RTUSB_VendorRequest(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	ULONG			TransferFlags,
+	IN	UCHAR			RequestType,
+	IN	UCHAR			Request,
+	IN	USHORT			Value,
+	IN	USHORT			Index,
+	IN	PVOID			TransferBuffer,
+	IN	ULONG			TransferBufferLength)
+{
+	int ret;
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"device disconnected\n");
+		return -1;
+	}
+	else if (in_interrupt())
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"in_interrupt, return RTUSB_VendorRequest\n");
+
+		return -1;
+	}
+	else
+	{
+
+		if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
+			ret=usb_control_msg(pAd->pUsb_Dev, usb_sndctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+		else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
+			ret=usb_control_msg(pAd->pUsb_Dev, usb_rcvctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"vendor request direction is failed\n");
+			ret = -1;
+		}
+
+        if (ret < 0)
+			DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d \n",ret);
+
+#if 0
+        // retry
+		if (ret < 0) {
+			int temp_i=0;
+			DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d, \n",ret);
+			ret = 0;
+			do
+			{
+				if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
+					ret=usb_control_msg(pAd->pUsb_Dev, usb_sndctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+				else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
+					ret=usb_control_msg(pAd->pUsb_Dev, usb_rcvctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+				temp_i++;
+			} while( (ret < 0) && (temp_i <= 1) );
+
+			if( ret >= 0)
+				return ret;
+
+		}
+#endif
+
+	}
+	return ret;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+	  Creates an IRP to submite an IOCTL_INTERNAL_USB_RESET_PORT
+	  synchronously. Callers of this function must be running at
+	  PASSIVE LEVEL.
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+NTSTATUS	RTUSB_ResetDevice(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	NTSTATUS		Status = TRUE;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->USB_ResetDevice\n");
+	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+	return Status;
+}
+
+#ifdef DBG
+#define HARDWARE_MAC	0
+#define HARDWARE_BBP	1
+#define HARDWARE_RF		2
+NDIS_STATUS     RTUSBQueryHardWareRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PRT_802_11_HARDWARE_REGISTER	pHardwareRegister;
+	ULONG							Value;
+	USHORT							Offset;
+	UCHAR							bbpValue;
+	UCHAR							bbpID;
+	NDIS_STATUS						Status = NDIS_STATUS_SUCCESS;
+
+	pHardwareRegister = (PRT_802_11_HARDWARE_REGISTER) pBuf;
+
+	if (pHardwareRegister->HardwareType == HARDWARE_MAC)
+	{
+		//Check Offset is valid?
+		if (pHardwareRegister->Offset > 0xF4)
+			Status = NDIS_STATUS_FAILURE;
+
+		Offset = (USHORT) pHardwareRegister->Offset;
+		RTUSBReadMACRegister(pAd, Offset, &Value);
+		pHardwareRegister->Data = Value;
+		DBGPRINT(RT_DEBUG_TRACE, "MAC:Offset[0x%04x]=[0x%04x]\n", Offset, Value);
+	}
+	else if (pHardwareRegister->HardwareType == HARDWARE_BBP)
+	{
+		bbpID = (UCHAR) pHardwareRegister->Offset;
+
+		RTUSBReadBBPRegister(pAd, bbpID, &bbpValue);
+		pHardwareRegister->Data = bbpValue;
+		DBGPRINT(RT_DEBUG_TRACE, "BBP:ID[0x%02x]=[0x%02x]\n", bbpID, bbpValue);
+	}
+	else
+		Status = NDIS_STATUS_FAILURE;
+
+	return Status;
+}
+
+NDIS_STATUS     RTUSBSetHardWareRegister(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PRT_802_11_HARDWARE_REGISTER	pHardwareRegister;
+	ULONG							Value;
+	USHORT							Offset;
+	UCHAR							bbpValue;
+	UCHAR							bbpID;
+	NDIS_STATUS						Status = NDIS_STATUS_SUCCESS;
+
+	pHardwareRegister = (PRT_802_11_HARDWARE_REGISTER) pBuf;
+
+	if (pHardwareRegister->HardwareType == HARDWARE_MAC)
+	{
+		//Check Offset is valid?
+		if (pHardwareRegister->Offset > 0xF4)
+			Status = NDIS_STATUS_FAILURE;
+
+		Offset = (USHORT) pHardwareRegister->Offset;
+		Value = (ULONG) pHardwareRegister->Data;
+		RTUSBWriteMACRegister(pAd, Offset, Value);
+		DBGPRINT(RT_DEBUG_TRACE, "RT_OID_802_11_SET_HARDWARE_REGISTER (MAC offset=0x%08x, data=0x%08x)\n", pHardwareRegister->Offset, pHardwareRegister->Data);
+
+		// 2004-11-08 a special 16-byte on-chip memory is used for RaConfig to pass debugging parameters to driver
+		// for debug-tuning only
+		if ((pHardwareRegister->Offset >= HW_DEBUG_SETTING_BASE) &&
+			(pHardwareRegister->Offset <= HW_DEBUG_SETTING_END))
+		{
+			// 0x2bf0: test power-saving feature
+			if (pHardwareRegister->Offset == HW_DEBUG_SETTING_BASE)
+			{
+#if 0
+				ULONG isr, imr, gimr;
+				USHORT tbtt = 3;
+
+				RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &isr);
+				RTMP_IO_READ32(pAd, MCU_INT_MASK_CSR, &imr);
+				RTMP_IO_READ32(pAd, INT_MASK_CSR, &gimr);
+				DBGPRINT(RT_DEBUG_TRACE, "Sleep %d TBTT, 8051 IMR=%08x, ISR=%08x, MAC IMR=%08x\n", tbtt, imr, isr, gimr);
+				AsicSleepThenAutoWakeup(pAd, tbtt);
+#endif
+			}
+			// 0x2bf4: test H2M_MAILBOX. byte3: Host command, byte2: token, byte1-0: arguments
+			else if (pHardwareRegister->Offset == (HW_DEBUG_SETTING_BASE + 4))
+			{
+				// 0x2bf4: byte0 non-zero: enable R17 tuning, 0: disable R17 tuning
+				if (pHardwareRegister->Data & 0x000000ff)
+				{
+					pAd->BbpTuning.bEnable = TRUE;
+					DBGPRINT(RT_DEBUG_TRACE,"turn on R17 tuning\n");
+				}
+				else
+				{
+					UCHAR R17;
+
+					pAd->BbpTuning.bEnable = FALSE;
+					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+					{
+						if (pAd->PortCfg.Channel > 14)
+							R17 = pAd->BbpTuning.R17LowerBoundA;
+						else
+							R17 = pAd->BbpTuning.R17LowerBoundG;
+						RTUSBWriteBBPRegister(pAd, 17, R17);
+						DBGPRINT(RT_DEBUG_TRACE,"turn off R17 tuning, restore to 0x%02x\n", R17);
+					}
+				}
+			}
+			// 0x2bf8: test ACK policy and QOS format in ADHOC mode
+			else if (pHardwareRegister->Offset == (HW_DEBUG_SETTING_BASE + 8))
+			{
+				PUCHAR pAckStr[4] = {"NORMAL", "NO-ACK", "NO-EXPLICIT-ACK", "BLOCK-ACK"};
+				EDCA_PARM DefaultEdcaParm;
+
+				// byte0 b1-0 means ACK POLICY - 0: normal ACK, 1: no ACK, 2:no explicit ACK, 3:BA
+				pAd->PortCfg.AckPolicy[0] = ((UCHAR)pHardwareRegister->Data & 0x02) << 5;
+				pAd->PortCfg.AckPolicy[1] = ((UCHAR)pHardwareRegister->Data & 0x02) << 5;
+				pAd->PortCfg.AckPolicy[2] = ((UCHAR)pHardwareRegister->Data & 0x02) << 5;
+				pAd->PortCfg.AckPolicy[3] = ((UCHAR)pHardwareRegister->Data & 0x02) << 5;
+				DBGPRINT(RT_DEBUG_TRACE, "ACK policy = %s\n", pAckStr[(UCHAR)pHardwareRegister->Data & 0x02]);
+
+				// any non-ZERO value in byte1 turn on EDCA & QOS format
+				if (pHardwareRegister->Data & 0x0000ff00)
+				{
+					memset(&DefaultEdcaParm, 0, sizeof(EDCA_PARM));
+					DefaultEdcaParm.bValid = TRUE;
+					DefaultEdcaParm.Aifsn[0] = 3;
+					DefaultEdcaParm.Aifsn[1] = 7;
+					DefaultEdcaParm.Aifsn[2] = 2;
+					DefaultEdcaParm.Aifsn[3] = 2;
+
+					DefaultEdcaParm.Cwmin[0] = 4;
+					DefaultEdcaParm.Cwmin[1] = 4;
+					DefaultEdcaParm.Cwmin[2] = 3;
+					DefaultEdcaParm.Cwmin[3] = 2;
+
+					DefaultEdcaParm.Cwmax[0] = 10;
+					DefaultEdcaParm.Cwmax[1] = 10;
+					DefaultEdcaParm.Cwmax[2] = 4;
+					DefaultEdcaParm.Cwmax[3] = 3;
+
+					DefaultEdcaParm.Txop[0]  = 0;
+					DefaultEdcaParm.Txop[1]  = 0;
+					DefaultEdcaParm.Txop[2]  = 96;
+					DefaultEdcaParm.Txop[3]  = 48;
+					AsicSetEdcaParm(pAd, &DefaultEdcaParm);
+				}
+				else
+					AsicSetEdcaParm(pAd, NULL);
+			}
+			// 0x2bfc: turn ON/OFF TX aggregation
+			else if (pHardwareRegister->Offset == (HW_DEBUG_SETTING_BASE + 12))
+			{
+				if (pHardwareRegister->Data)
+					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+				else
+					OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+				DBGPRINT(RT_DEBUG_TRACE, "AGGREGATION = %d\n", OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED));
+			}
+			else
+				Status = NDIS_STATUS_FAILURE;
+		}
+	}
+	else if (pHardwareRegister->HardwareType == HARDWARE_BBP)
+	{
+		bbpID = (UCHAR) pHardwareRegister->Offset;
+		bbpValue = (UCHAR) pHardwareRegister->Data;
+		RTUSBWriteBBPRegister(pAd, bbpID, bbpValue);
+		DBGPRINT(RT_DEBUG_TRACE, "BBP:ID[0x%02x]=[0x%02x]\n", bbpID, bbpValue);
+	}
+
+	return Status;
+}
+#endif
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/sanity.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/sanity.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/sanity.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/sanity.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1402 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	sanity.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	John Chang	2004-09-01	add WMM support
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+#include <net/iw_handler.h>
+
+UCHAR	WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};
+UCHAR	RSN_OUI[] = {0x00, 0x0f, 0xac};
+UCHAR   WME_INFO_ELEM[]  = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
+UCHAR   WME_PARM_ELEM[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+UCHAR   RALINK_OUI[]  = {0x00, 0x0c, 0x43};
+UCHAR   WSC_OUI[] = {0x00, 0x50, 0xf2, 0x04};
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeScanReqSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT UCHAR *pBssType,
+    OUT CHAR Ssid[],
+    OUT UCHAR *pSsidLen,
+    OUT UCHAR *pScanType)
+{
+    MLME_SCAN_REQ_STRUCT *Info;
+
+    Info = (MLME_SCAN_REQ_STRUCT *)(Msg);
+    *pBssType = Info->BssType;
+    *pSsidLen = Info->SsidLen;
+    memcpy(Ssid, Info->Ssid, *pSsidLen);
+    *pScanType = Info->ScanType;
+
+    if ((*pBssType == BSS_INFRA || *pBssType == BSS_ADHOC || *pBssType == BSS_ANY) &&
+       (*pScanType == SCAN_ACTIVE || *pScanType == FAST_SCAN_ACTIVE || *pScanType == SCAN_PASSIVE))
+        return TRUE;
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeScanReqSanity fail - wrong BssType or ScanType\n");
+        return FALSE;
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeStartReqSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT CHAR Ssid[],
+    OUT UCHAR *pSsidLen)
+{
+    MLME_START_REQ_STRUCT *Info;
+
+    Info = (MLME_START_REQ_STRUCT *)(Msg);
+
+    if (Info->SsidLen > MAX_LEN_OF_SSID)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeStartReqSanity fail - wrong SSID length\n");
+        return FALSE;
+    }
+
+    *pSsidLen = Info->SsidLen;
+    memcpy(Ssid, Info->Ssid, *pSsidLen);
+
+    return TRUE;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeAssocReqSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pApAddr,
+    OUT USHORT *pCapabilityInfo,
+    OUT ULONG *pTimeout,
+    OUT USHORT *pListenIntv)
+{
+    MLME_ASSOC_REQ_STRUCT *pInfo;
+
+    pInfo = (MLME_ASSOC_REQ_STRUCT *)Msg;
+    *pTimeout = pInfo->Timeout;                             // timeout
+    COPY_MAC_ADDR(pApAddr, pInfo->Addr);                   // AP address
+    *pCapabilityInfo = pInfo->CapabilityInfo;               // capability info
+    *pListenIntv = pInfo->ListenIntv;
+
+    return TRUE;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeAuthReqSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr,
+    OUT ULONG *pTimeout,
+    OUT USHORT *pAlg)
+{
+    MLME_AUTH_REQ_STRUCT *pInfo;
+
+    pInfo  = (MLME_AUTH_REQ_STRUCT *)Msg;
+    COPY_MAC_ADDR(pAddr, pInfo->Addr);
+    *pTimeout = pInfo->Timeout;
+    *pAlg = pInfo->Alg;
+
+    if (((*pAlg == Ndis802_11AuthModeShared) ||(*pAlg == Ndis802_11AuthModeOpen)) &&
+        ((*pAddr & 0x01) == 0))
+    {
+        return TRUE;
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeAuthReqSanity fail - wrong algorithm\n");
+        return FALSE;
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN PeerAssocRspSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *pMsg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr2,
+    OUT USHORT *pCapabilityInfo,
+    OUT USHORT *pStatus,
+    OUT USHORT *pAid,
+    OUT UCHAR SupRate[],
+    OUT UCHAR *pSupRateLen,
+    OUT UCHAR ExtRate[],
+    OUT UCHAR *pExtRateLen,
+    OUT PEDCA_PARM pEdcaParm)
+{
+    CHAR          IeType, *Ptr;
+    PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
+    PEID_STRUCT   pEid;
+	ULONG		  Length = 0;
+
+    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+    Ptr = pFrame->Octet;
+	Length += LENGTH_802_11;
+
+    memcpy(pCapabilityInfo, &pFrame->Octet[0], 2);
+	Length += 2;
+    memcpy(pStatus,         &pFrame->Octet[2], 2);
+	Length += 2;
+
+    *pExtRateLen = 0;
+    pEdcaParm->bValid = FALSE;
+
+    if (*pStatus != MLME_SUCCESS)
+        return TRUE;
+
+    memcpy(pAid, &pFrame->Octet[4], 2);
+	Length += 2;
+    // 	change Endian in RTMPFrameEndianChange() on big endian platform
+    //*pAid = le2cpu16(*pAid);
+
+    // TODO: check big endian issue &0x3fff
+    *pAid = (*pAid) & 0x3fff; // AID is low 14-bit
+
+    // -- get supported rates from payload and advance the pointer
+    IeType = pFrame->Octet[6];
+    *pSupRateLen = pFrame->Octet[7];
+    if ((IeType != IE_SUPP_RATES) || (*pSupRateLen > MAX_LEN_OF_SUPPORTED_RATES))
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerAssocRspSanity fail - wrong SupportedRates IE\n");
+        return FALSE;
+    }
+    else
+   		memcpy(SupRate, &pFrame->Octet[8], *pSupRateLen);
+
+	Length = Length + 2 + *pSupRateLen;
+
+    // many AP implement proprietary IEs in non-standard order, we'd better
+    // tolerate mis-ordered IEs to get best compatibility
+    pEid = (PEID_STRUCT) &pFrame->Octet[8 + (*pSupRateLen)];
+
+    // get variable fields from payload and advance the pointer
+	while ((Length + 2 + pEid->Len) <= MsgLen)
+    {
+        switch (pEid->Eid)
+        {
+            case IE_EXT_SUPP_RATES:
+                if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
+                {
+                    memcpy(ExtRate, pEid->Octet, pEid->Len);
+                    *pExtRateLen = pEid->Len;
+                }
+                break;
+
+			case IE_VENDOR_SPECIFIC:
+                // handle WME PARAMTER ELEMENT
+                if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6) && (pEid->Len == 24))
+                {
+                    PUCHAR ptr;
+                    int i;
+
+                    // parsing EDCA parameters
+                    pEdcaParm->bValid          = TRUE;
+                    pEdcaParm->bQAck           = FALSE; // pEid->Octet[0] & 0x10;
+                    pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
+                    pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
+                    //pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80;
+                    pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
+                    ptr = &pEid->Octet[8];
+                    for (i=0; i<4; i++)
+                    {
+                        UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
+                        pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);   // b5 is ACM
+                        pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;               // b0~3 is AIFSN
+                        pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;             // b0~4 is Cwmin
+                        pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;               // b5~8 is Cwmax
+                        pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
+                        ptr += 4; // point to next AC
+                    }
+                }
+                break;
+
+#if 0
+            case IE_EDCA_PARAMETER:
+                if (pEid->Len == 18)
+                {
+                    PUCHAR ptr;
+                    int i;
+                    pEdcaParm->bValid          = TRUE;
+                    pEdcaParm->bQAck           = pEid->Octet[0] & 0x10;
+                    pEdcaParm->bQueueRequest   = pEid->Octet[0] & 0x20;
+                    pEdcaParm->bTxopRequest    = pEid->Octet[0] & 0x40;
+//                  pEdcaParm->bMoreDataAck    = pEid->Octet[0] & 0x80;
+                    pEdcaParm->EdcaUpdateCount = pEid->Octet[0] & 0x0f;
+                    ptr = &pEid->Octet[2];
+                    for (i=0; i<4; i++)
+                    {
+                        UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
+                        pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);   // b5 is ACM
+                        pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;               // b0~3 is AIFSN
+                        pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;             // b0~4 is Cwmin
+                        pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;               // b5~8 is Cwmax
+                        pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
+                        ptr += 4; // point to next AC
+                    }
+                }
+                break;
+#endif
+            default:
+                DBGPRINT(RT_DEBUG_TRACE, "PeerAssocRspSanity - ignore unrecognized EID = %d\n", pEid->Eid);
+                break;
+        }
+
+		Length = Length + 2 + pEid->Len;
+        pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);
+    }
+
+    return TRUE;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN PeerDisassocSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr2,
+    OUT USHORT *pReason)
+{
+    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+
+    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+    memcpy(pReason, &pFrame->Octet[0], 2);
+
+    return TRUE;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN PeerDeauthSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr2,
+    OUT USHORT *pReason)
+{
+    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+
+    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+    memcpy(pReason, &pFrame->Octet[0], 2);
+
+    return TRUE;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN PeerAuthSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr,
+    OUT USHORT *pAlg,
+    OUT USHORT *pSeq,
+    OUT USHORT *pStatus,
+    CHAR *pChlgText)
+{
+    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+
+    COPY_MAC_ADDR(pAddr,   pFrame->Hdr.Addr2);
+    memcpy(pAlg,    &pFrame->Octet[0], 2);
+    memcpy(pSeq,    &pFrame->Octet[2], 2);
+    memcpy(pStatus, &pFrame->Octet[4], 2);
+
+    if (*pAlg == Ndis802_11AuthModeOpen)
+    {
+        if (*pSeq == 1 || *pSeq == 2)
+        {
+            return TRUE;
+        }
+        else
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong Seg#\n");
+            return FALSE;
+        }
+    }
+    else if (*pAlg == Ndis802_11AuthModeShared)
+    {
+        if (*pSeq == 1 || *pSeq == 4)
+        {
+            return TRUE;
+        }
+        else if (*pSeq == 2 || *pSeq == 3)
+        {
+            memcpy(pChlgText, &pFrame->Octet[8], CIPHER_TEXT_LEN);
+            return TRUE;
+        }
+        else
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong Seg#\n");
+            return FALSE;
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong algorithm\n");
+        return FALSE;
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN PeerProbeReqSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT PUCHAR pAddr2,
+    OUT CHAR Ssid[],
+    OUT UCHAR *pSsidLen)
+{
+    UCHAR         Idx;
+	UCHAR	      RateLen;
+	CHAR          IeType;
+    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+
+    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+
+    if ((pFrame->Octet[0] != IE_SSID) || (pFrame->Octet[1] > MAX_LEN_OF_SSID))
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerProbeReqSanity fail - wrong SSID IE(Type=%d,Len=%d)\n",pFrame->Octet[0],pFrame->Octet[1]);
+        return FALSE;
+    }
+
+    *pSsidLen = pFrame->Octet[1];
+    memcpy(Ssid, &pFrame->Octet[2], *pSsidLen);
+
+    Idx = *pSsidLen + 2;
+
+	// -- get supported rates from payload and advance the pointer
+	IeType = pFrame->Octet[Idx];
+	RateLen = pFrame->Octet[Idx + 1];
+	if (IeType != IE_SUPP_RATES)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerProbeReqSanity fail - wrong SupportRates IE(Type=%d,Len=%d)\n",pFrame->Octet[Idx],pFrame->Octet[Idx+1]);
+        return FALSE;
+    }
+	else
+	{
+		if ((pAd->PortCfg.AdhocMode == 2) && (RateLen < 8))
+			return (FALSE);
+	}
+
+    return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		MLME message sanity check
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+ */
+BOOLEAN PeerBeaconAndProbeRspSanity(
+	IN PRTMP_ADAPTER pAd,
+	IN VOID *Msg,
+	IN ULONG MsgLen,
+	OUT PUCHAR pAddr2,
+	OUT PUCHAR pBssid,
+	OUT CHAR Ssid[],
+	OUT UCHAR *pSsidLen,
+	OUT UCHAR *pBssType,
+	OUT USHORT *pBeaconPeriod,
+	OUT UCHAR *pChannel,
+	OUT UCHAR *pNewChannel,
+	OUT LARGE_INTEGER *pTimestamp,
+	OUT CF_PARM *pCfParm,
+	OUT USHORT *pAtimWin,
+	OUT USHORT *pCapabilityInfo,
+	OUT UCHAR *pErp,
+	OUT UCHAR *pDtimCount,
+	OUT UCHAR *pDtimPeriod,
+	OUT UCHAR *pBcastFlag,
+	OUT UCHAR *pMessageToMe,
+	OUT UCHAR SupRate[],
+	OUT UCHAR *pSupRateLen,
+	OUT UCHAR ExtRate[],
+	OUT UCHAR *pExtRateLen,
+	OUT	UCHAR *pCkipFlag,
+	OUT	UCHAR *pAironetCellPowerLimit,
+	OUT PEDCA_PARM		 pEdcaParm,
+	OUT PQBSS_LOAD_PARM  pQbssLoad,
+	OUT PQOS_CAPABILITY_PARM pQosCapability,
+	OUT ULONG *pRalinkIe,
+	OUT UCHAR *LengthVIE,
+	OUT	PNDIS_802_11_VARIABLE_IEs pVIE)
+{
+	CHAR				*Ptr, TimLen;
+	PFRAME_802_11		pFrame;
+	PEID_STRUCT 		pEid;
+	UCHAR				SubType;
+	UCHAR				Sanity;
+	ULONG				Length = 0;
+
+	// Add for 3 necessary EID field check
+	Sanity = 0;
+
+	*pAtimWin = 0;
+	*pErp = 0;
+	*pDtimCount = 0;
+	*pDtimPeriod = 0;
+	*pBcastFlag = 0;
+	*pMessageToMe = 0;
+	*pExtRateLen = 0;
+	*pCkipFlag = 0;					// Default of CkipFlag is 0
+	*pAironetCellPowerLimit = 0xFF;  // Default of AironetCellPowerLimit is 0xFF
+	*LengthVIE = 0;					// Set the length of VIE to init value 0
+	*pRalinkIe = 0;
+	*pNewChannel = 0;
+	pCfParm->bValid = FALSE;		// default: no IE_CF found
+	pQbssLoad->bValid = FALSE;		// default: no IE_QBSS_LOAD found
+	pEdcaParm->bValid = FALSE;		// default: no IE_EDCA_PARAMETER found
+	pQosCapability->bValid = FALSE; // default: no IE_QOS_CAPABILITY found
+
+	pFrame = (PFRAME_802_11)Msg;
+
+	// get subtype from header
+	SubType = (UCHAR)pFrame->Hdr.FC.SubType;
+
+	// get Addr2 and BSSID from header
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+	COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
+
+	Ptr = pFrame->Octet;
+	Length += LENGTH_802_11;
+
+	// get timestamp from payload and advance the pointer
+	memcpy(pTimestamp, Ptr, TIMESTAMP_LEN);
+	Ptr += TIMESTAMP_LEN;
+	Length += TIMESTAMP_LEN;
+
+	// get beacon interval from payload and advance the pointer
+	memcpy(pBeaconPeriod, Ptr, 2);
+	Ptr += 2;
+	Length += 2;
+
+	// get capability info from payload and advance the pointer
+	memcpy(pCapabilityInfo, Ptr, 2);
+	Ptr += 2;
+	Length += 2;
+
+	if (CAP_IS_ESS_ON(*pCapabilityInfo))
+		*pBssType = BSS_INFRA;
+	else
+		*pBssType = BSS_ADHOC;
+
+	pEid = (PEID_STRUCT) Ptr;
+
+	// get variable fields from payload and advance the pointer
+	while ((Length + 2 + pEid->Len) <= MsgLen)
+	{
+
+		switch(pEid->Eid)
+		{
+			case IE_SSID:
+				// Already has one SSID EID in this beacon, ignore the second one
+				if (Sanity & 0x1)
+					break;
+				if(pEid->Len <= MAX_LEN_OF_SSID)
+				{
+					memcpy(Ssid, pEid->Octet, pEid->Len);
+					*pSsidLen = pEid->Len;
+					Sanity |= 0x1;
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_SSID (len=%d)\n",pEid->Len);
+					return FALSE;
+				}
+				break;
+
+			case IE_SUPP_RATES:
+				if(pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
+				{
+					Sanity |= 0x2;
+					memcpy(SupRate, pEid->Octet, pEid->Len);
+					*pSupRateLen = pEid->Len;
+
+					// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
+					// from ScanTab. We should report as is. And filter out unsupported
+					// rates in MlmeAux.
+					// Check against the supported rates
+					// RTMPCheckRates(pAd, SupRate, pSupRateLen);
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",pEid->Len);
+					return FALSE;
+				}
+				break;
+
+			case IE_FH_PARM:
+				DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity(IE_FH_PARM) \n");
+				break;
+
+			case IE_DS_PARM:
+				if(pEid->Len == 1)
+				{
+					*pChannel = *pEid->Octet;
+					if (ChannelSanity(pAd, *pChannel) == 0)
+					{
+						DBGPRINT(RT_DEBUG_INFO, "PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (ch=%d)\n",*pChannel);
+						return FALSE;
+					}
+					Sanity |= 0x4;
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (len=%d)\n",pEid->Len);
+					return FALSE;
+				}
+				break;
+
+			case IE_CF_PARM:
+				if(pEid->Len == 6)
+				{
+					pCfParm->bValid = TRUE;
+					pCfParm->CfpCount = pEid->Octet[0];
+					pCfParm->CfpPeriod = pEid->Octet[1];
+					pCfParm->CfpMaxDuration = pEid->Octet[2] + 256 * pEid->Octet[3];
+					pCfParm->CfpDurRemaining = pEid->Octet[4] + 256 * pEid->Octet[5];
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_CF_PARM\n");
+					return FALSE;
+				}
+				break;
+
+			case IE_IBSS_PARM:
+				if(pEid->Len == 2)
+				{
+					memcpy(pAtimWin, pEid->Octet, pEid->Len);
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_IBSS_PARM\n");
+					return FALSE;
+				}
+				break;
+
+			case IE_TIM:
+				if(INFRA_ON(pAd) && SubType == SUBTYPE_BEACON)
+				{
+					GetTimBit((PUCHAR)pEid, pAd->ActiveCfg.Aid, &TimLen, pBcastFlag, pDtimCount, pDtimPeriod, pMessageToMe);
+				}
+				break;
+
+			case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
+				if(pEid->Len == 3)
+				{
+					*pNewChannel = pEid->Octet[1];	//extract new channel number
+				}
+				break;
+
+			// New for WPA
+			// Wifi WMM use the same IE vale, need to parse that too
+			// case IE_WPA:
+			case IE_VENDOR_SPECIFIC:
+				// Check the OUI version, filter out non-standard usage
+				if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3) && (pEid->Len == 7))
+				{
+					*pRalinkIe = pEid->Octet[3];
+				}
+				else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
+				{
+					// Copy to pVIE used by driver, wpa supplicant and ui
+					Ptr = (PUCHAR) pVIE;
+
+					// Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
+                    if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN)
+                    {
+                        DBGPRINT(RT_DEBUG_WARN, "PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
+    					    (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN);
+    			        break;
+                    }
+
+					memcpy(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
+					*LengthVIE += (pEid->Len + 2);
+				}
+				else if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6) && (pEid->Len == 24))
+				{
+					PUCHAR ptr;
+					int i;
+
+					// parsing EDCA parameters
+					pEdcaParm->bValid		   = TRUE;
+					pEdcaParm->bQAck		   = FALSE; // pEid->Octet[0] & 0x10;
+					pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
+					pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
+					pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
+					ptr = &pEid->Octet[8];
+					for (i=0; i<4; i++)
+					{
+						UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
+						pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);	 // b5 is ACM
+						pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;				 // b0~3 is AIFSN
+						pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;			 // b0~4 is Cwmin
+						pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;				 // b5~8 is Cwmax
+						pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
+						ptr += 4; // point to next AC
+					}
+				}
+				else if (NdisEqualMemory(pEid->Octet, WME_INFO_ELEM, 6) && (pEid->Len == 7))
+				{
+					// parsing EDCA parameters
+					pEdcaParm->bValid		   = TRUE;
+					pEdcaParm->bQAck		   = FALSE; // pEid->Octet[0] & 0x10;
+					pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
+					pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
+					pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
+
+					// use default EDCA parameter
+					pEdcaParm->bACM[QID_AC_BE]	= 0;
+					pEdcaParm->Aifsn[QID_AC_BE] = 3;
+					pEdcaParm->Cwmin[QID_AC_BE] = CW_MIN_IN_BITS;
+					pEdcaParm->Cwmax[QID_AC_BE] = CW_MAX_IN_BITS;
+					pEdcaParm->Txop[QID_AC_BE]	= 0;
+
+					pEdcaParm->bACM[QID_AC_BK]	= 0;
+					pEdcaParm->Aifsn[QID_AC_BK] = 7;
+					pEdcaParm->Cwmin[QID_AC_BK] = CW_MIN_IN_BITS;
+					pEdcaParm->Cwmax[QID_AC_BK] = CW_MAX_IN_BITS;
+					pEdcaParm->Txop[QID_AC_BK]	= 0;
+
+					pEdcaParm->bACM[QID_AC_VI]	= 0;
+					pEdcaParm->Aifsn[QID_AC_VI] = 2;
+					pEdcaParm->Cwmin[QID_AC_VI] = CW_MIN_IN_BITS-1;
+					pEdcaParm->Cwmax[QID_AC_VI] = CW_MAX_IN_BITS;
+					pEdcaParm->Txop[QID_AC_VI]	= 96;	// AC_VI: 96*32us ~= 3ms
+
+					pEdcaParm->bACM[QID_AC_VO]	= 0;
+					pEdcaParm->Aifsn[QID_AC_VO] = 2;
+					pEdcaParm->Cwmin[QID_AC_VO] = CW_MIN_IN_BITS-2;
+					pEdcaParm->Cwmax[QID_AC_VO] = CW_MAX_IN_BITS-1;
+					pEdcaParm->Txop[QID_AC_VO]	= 48;	// AC_VO: 48*32us ~= 1.5ms
+				}
+#if WPA_SUPPLICANT_SUPPORT
+				else if (NdisEqualMemory(pEid->Octet, WSC_OUI, 4) && (SubType == SUBTYPE_BEACON) && (pAd->PortCfg.Send_Beacon == TRUE))
+				{
+					union iwreq_data wrqu;
+					char buf[560] = {0};
+
+					pAd->PortCfg.WscIEBeacon.ValueLen = pEid->Len - 4;
+					memcpy(pAd->PortCfg.WscIEBeacon.Value, &pEid->Octet[4], pEid->Len - 4);
+
+
+					//Send WSC beacon to wpa_supplicant
+					memset(&wrqu, 0, sizeof(wrqu));
+					sprintf(buf, "WSCBEACON=<%d>", pAd->PortCfg.WscIEBeacon.ValueLen);
+					wrqu.data.length = strlen(buf);
+					memcpy(&buf[wrqu.data.length], pAd->PortCfg.WscIEBeacon.Value, pAd->PortCfg.WscIEBeacon.ValueLen);
+					wrqu.data.length += pAd->PortCfg.WscIEBeacon.ValueLen;
+					wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, buf);
+					//COPY_MAC_ADDR(pAd->PortCfg.MBSSID[pAd->IoctlIF].WscIEProbRspAddr2, pAddr2);
+					//return FALSE;
+				}
+#endif
+				else
+				{
+					// Gemtek ask us to pass other vendor's IE for their applications
+					Ptr = (PUCHAR) pVIE;
+
+					// Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
+                    if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN)
+                    {
+                        DBGPRINT(RT_DEBUG_WARN, "PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
+    					    (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN);
+    			        break;
+                    }
+
+					memcpy(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
+					*LengthVIE += (pEid->Len + 2);
+				}
+
+				DBGPRINT(RT_DEBUG_INFO, "PeerBeaconAndProbeRspSanity - Receive IE_WPA\n");
+				break;
+
+			case IE_EXT_SUPP_RATES:
+				if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
+				{
+					memcpy(ExtRate, pEid->Octet, pEid->Len);
+					*pExtRateLen = pEid->Len;
+
+					// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
+					// from ScanTab. We should report as is. And filter out unsupported
+					// rates in MlmeAux.
+					// Check against the supported rates
+					// RTMPCheckRates(pAd, ExtRate, pExtRateLen);
+				}
+				break;
+
+			case IE_ERP:
+				if (pEid->Len == 1)
+				{
+					*pErp = (UCHAR)pEid->Octet[0];
+				}
+				break;
+
+			// WPA2 & 802.11i RSN
+			case IE_RSN:
+				// There is no OUI for version anymore, check the group cipher OUI before copying
+				if (RTMPEqualMemory(pEid->Octet + 2, RSN_OUI, 3))
+				{
+					// Copy to pVIE used by driver, wpa supplicant and ui
+					Ptr = (PUCHAR) pVIE;
+
+					// Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
+                    if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN)
+                    {
+                        DBGPRINT(RT_DEBUG_WARN, "PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
+    					    (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN);
+    			        break;
+                    }
+
+					memcpy(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
+					*LengthVIE += (pEid->Len + 2);
+				}
+				DBGPRINT(RT_DEBUG_INFO, "IE_RSN length = %d\n", pEid->Len);
+				break;
+#if 0
+			case IE_QBSS_LOAD:
+				if (pEid->Len == 5)
+				{
+					pQbssLoad->bValid = TRUE;
+					pQbssLoad->StaNum = pEid->Octet[0] + pEid->Octet[1] * 256;
+					pQbssLoad->ChannelUtilization = pEid->Octet[2];
+					pQbssLoad->RemainingAdmissionControl = pEid->Octet[3] + pEid->Octet[4] * 256;
+				}
+				break;
+
+			case IE_EDCA_PARAMETER:
+				if (pEid->Len == 18)
+				{
+					PUCHAR ptr;
+					int i;
+					pEdcaParm->bValid		   = TRUE;
+					pEdcaParm->bQAck		   = pEid->Octet[0] & 0x10;
+					pEdcaParm->bQueueRequest   = pEid->Octet[0] & 0x20;
+					pEdcaParm->bTxopRequest    = pEid->Octet[0] & 0x40;
+//					pEdcaParm->bMoreDataAck    = pEid->Octet[0] & 0x80;
+					pEdcaParm->EdcaUpdateCount = pEid->Octet[0] & 0x0f;
+					ptr = &pEid->Octet[2];
+					for (i=0; i<4; i++)
+					{
+						UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
+						pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);	 // b5 is ACM
+						pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;				 // b0~3 is AIFSN
+						pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;			 // b0~4 is Cwmin
+						pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;				 // b5~8 is Cwmax
+						pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
+						ptr += 4; // point to next AC
+					}
+				}
+				break;
+
+			case IE_QOS_CAPABILITY:
+				// this IE contains redundant information as stated in EDCA_IE
+				if (pEid->Len == 1)
+				{
+					pQosCapability->bValid			= TRUE;
+					pQosCapability->bQAck			= pEid->Octet[0] & 0x01;
+					pQosCapability->bQueueRequest	= pEid->Octet[0] & 0x02;
+					pQosCapability->bTxopRequest	= pEid->Octet[0] & 0x04;
+//					pQosCapability->bMoreDataAck	= pEid->Octet[0] & 0x08;
+					pQosCapability->EdcaUpdateCount = pEid->Octet[0] >> 4;
+				}
+				break;
+#endif
+
+			default:
+				// Unknown IE, do nothing!!!
+				DBGPRINT(RT_DEBUG_INFO, "PeerBeaconAndProbeRspSanity - unrecognized EID = %d\n", pEid->Eid);
+				break;
+		}
+
+		Length = Length + 2 + pEid->Len;  // Eid[1] + Len[1]+ content[Len]
+		pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);
+	}
+
+	// For some 11a AP. it did not have the channel EID, patch here
+	if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x04) == 0))
+	{
+		*pChannel = pAd->LatchRfRegs.Channel;
+		Sanity |= 0x4;
+	}
+
+	if (Sanity != 0x7)
+	{
+		DBGPRINT(RT_DEBUG_WARN, "PeerBeaconAndProbeRspSanity - missing field, Sanity=0x%02x\n", Sanity);
+		return FALSE;
+	}
+	else
+	{
+		return TRUE;
+	}
+
+}
+
+/*
+    ==========================================================================
+    Description:
+
+    ==========================================================================
+ */
+BOOLEAN GetTimBit(
+    IN CHAR *Ptr,
+    IN USHORT Aid,
+    OUT UCHAR *TimLen,
+    OUT UCHAR *BcastFlag,
+    OUT UCHAR *DtimCount,
+    OUT UCHAR *DtimPeriod,
+    OUT UCHAR *MessageToMe)
+{
+    UCHAR          BitCntl, N1, N2, MyByte, MyBit;
+    CHAR          *IdxPtr;
+
+    IdxPtr = Ptr;
+
+    IdxPtr ++;
+    *TimLen = *IdxPtr;
+
+    // get DTIM Count from TIM element
+    IdxPtr ++;
+    *DtimCount = *IdxPtr;
+
+    // get DTIM Period from TIM element
+    IdxPtr++;
+    *DtimPeriod = *IdxPtr;
+
+    // get Bitmap Control from TIM element
+    IdxPtr++;
+    BitCntl = *IdxPtr;
+
+    if ((*DtimCount == 0) && (BitCntl & 0x01))
+        *BcastFlag = TRUE;
+    else
+        *BcastFlag = FALSE;
+
+    // Parse Partial Virtual Bitmap from TIM element
+    N1 = BitCntl & 0xfe;    // N1 is the first bitmap byte#
+    N2 = *TimLen - 4 + N1;  // N2 is the last bitmap byte#
+
+    if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
+        *MessageToMe = FALSE;
+    else
+    {
+        MyByte = (Aid >> 3) - N1;                       // my byte position in the bitmap byte-stream
+        MyBit = Aid % 16 - ((MyByte & 0x01)? 8:0);
+
+        IdxPtr += (MyByte + 1);
+
+        //if (*IdxPtr)
+        //    DBGPRINT(RT_DEBUG_WARN, "TIM bitmap = 0x%02x\n", *IdxPtr);
+
+        if (*IdxPtr & (0x01 << MyBit))
+            *MessageToMe = TRUE;
+        else
+            *MessageToMe = FALSE;
+    }
+
+    return TRUE;
+}
+
+UCHAR ChannelSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN UCHAR channel)
+{
+    int i;
+
+    for (i = 0; i < pAd->ChannelListNum; i ++)
+    {
+        if (channel == pAd->ChannelList[i].Channel)
+            return 1;
+    }
+    return 0;
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Sanity check NetworkType (11b, 11g or 11a)
+
+	Arguments:
+		Channel				Current Channel
+		SupRate				Peer's Supported Rate Buffer
+		SupRateLen			Peer's Supported Rate Length
+		ExtRate				Peer's Extended Rate Buffer
+		ExtRateLen			Peer's Extended Rate Length
+
+	Return Value:
+		Ndis802_11DS .......(11b)
+        Ndis802_11OFDM24....(11bg mixed)
+		Ndis802_11OFDM5.....(11a)
+
+	========================================================================
+*/
+NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
+	IN UCHAR  Channel,
+	IN UCHAR  SupRate[],
+	IN UCHAR  SupRateLen,
+	IN UCHAR  ExtRate[],
+	IN UCHAR  ExtRateLen)
+{
+	NDIS_802_11_NETWORK_TYPE	NetWorkType;
+	UCHAR						Type = 0;
+	//UCHAR						rate, i;
+
+	Type = PeerTxTypeInUseSanity(Channel, SupRate, SupRateLen, ExtRate, ExtRateLen);
+	switch (Type)
+	{
+		case CCK_RATE:
+			NetWorkType = Ndis802_11DS;
+			break;
+		case OFDM_RATE:
+			if (Channel > 14)
+				NetWorkType = Ndis802_11OFDM5;
+			else
+				NetWorkType = Ndis802_11OFDM24;
+			break;
+		case CCKOFDM_RATE:
+			NetWorkType = Ndis802_11OFDM24;
+			break;
+		default:
+			NetWorkType = Ndis802_11DS;
+			break;
+	}
+
+	return NetWorkType;
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Get Peer TX phy mode(CCK or OFDM)
+	Arguments:
+		Channel				Current Channel
+		SupRate				Peer's Supported Rate Buffer
+		SupRateLen			Peer's Supported Rate Length
+		ExtRate				Peer's Extended Rate Buffer
+		ExtRateLen			Peer's Extended Rate Length
+
+	Return Value:
+    		1 - CCK
+    		2 - OFDM
+    		3 - CCK+OFDM
+	========================================================================
+*/
+UCHAR PeerTxTypeInUseSanity(
+	IN UCHAR  Channel,
+	IN UCHAR  SupRate[],
+	IN UCHAR  SupRateLen,
+	IN UCHAR  ExtRate[],
+	IN UCHAR  ExtRateLen)
+{
+	UCHAR						rate, i;
+	UCHAR						Type = 0;
+
+	if (Channel <= 14)
+	{
+		//
+		// First check support Rate.
+		//
+		for (i = 0; i < SupRateLen; i++)
+		{
+			rate = SupRate[i] & 0x7f; // Mask out basic rate set bit
+			if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22))
+			{
+				Type |= 0x01;   //CCK
+				continue;
+			}
+			else
+			{
+				//
+				// Otherwise (even rate > 108) means Ndis802_11OFDM24
+				//
+				Type |= 0x02;   // OFDM
+				break;
+			}
+		}
+
+		//
+		// Second check Extend Rate.
+		// Maybe OFDM rate store on Extend Rate.
+		//
+		if ((Type & 0x02) == 0)
+		{
+			for (i = 0; i < ExtRateLen; i++)
+			{
+				rate = ExtRate[i] & 0x7f; // Mask out basic rate set bit
+				if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22))
+				{
+					continue;
+				}
+				else
+				{
+					//
+					// Otherwise (even rate > 108) means Ndis802_11OFDM24
+					//
+					Type |= 0x02;  //OFDM
+					break;
+				}
+			}
+		}
+	}
+	else
+	{
+		Type |= 0x02;  //OFDM
+	}
+
+	return Type;
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Sanity check pairwise key on Encryption::Ndis802_11Encryption1Enabled
+
+	Arguments:
+		pAd      - Pointer to our adapter
+		pBuf 	 - Pointer to NDIS_802_11_KEY structure
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_FAILURE
+
+	Note:
+		For OID_802_11_ADD_KEY setting, on old wep stuff also need to verify
+		the structure of NIDS_802_11_KEY
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPAWepKeySanity(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_KEY	pKey;
+	ULONG				KeyIdx;
+	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
+	BOOLEAN 			bTxKey; 		// Set the key as transmit key
+	BOOLEAN 			bPairwise;		// Indicate the key is pairwise key
+	//UCHAR			CipherAlg;
+	//UINT			i;
+
+	pKey = (PNDIS_802_11_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0x0fffffff;
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+
+	// 1. Check Group / Pairwise Key
+	if (bPairwise)	// Pairwise Key
+	{
+		// 1. Check KeyIdx
+		// it is a shared key
+		if (KeyIdx > 4)
+			return (NDIS_STATUS_FAILURE);
+
+		// 2. Check bTx, it must be true, otherwise, return NDIS_STATUS_FAILURE
+		if (bTxKey == FALSE)
+			return(NDIS_STATUS_FAILURE);
+
+		// 3. If BSSID is all 0xff, return NDIS_STATUS_FAILURE
+		if (MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR))
+			return(NDIS_STATUS_FAILURE);
+
+		// check key length
+		if ((pKey->KeyLength != 5) && (pKey->KeyLength != 13))
+		    return(NDIS_STATUS_FAILURE);
+
+	}
+	else
+	{
+		// Group Key
+		// 1. Check BSSID, if not current BSSID or Bcast, return NDIS_STATUS_FAILURE
+		if ((! MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR)) &&
+			(! MAC_ADDR_EQUAL(pKey->BSSID, pAd->PortCfg.Bssid)))
+			return(NDIS_STATUS_FAILURE);
+
+		// 2. Check Key index for supported Group Key
+		if (KeyIdx > 4)
+			return(NDIS_STATUS_FAILURE);
+
+	}
+
+	if (pKey->KeyIndex & 0x80000000)
+	{
+		// Default key for tx (shared key)
+		pAd->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+	}
+    //always use BSS0=0
+//	AsicAddSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx, CipherAlg, pAd->SharedKey[KeyIdx].Key, NULL, NULL);
+
+
+     	pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;	//For Test
+
+	return (Status);
+}
+
+NDIS_STATUS	RTMPRemoveKeySanity(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_REMOVE_KEY	pKey;
+	ULONG					KeyIdx;
+	NDIS_STATUS				Status = NDIS_STATUS_FAILURE;
+	BOOLEAN 	bTxKey; 		// Set the key as transmit key
+	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
+	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
+								// Otherwise, it will set by the NIC.
+	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
+	INT 		i;
+
+	DBGPRINT(RT_DEBUG_TRACE,"---> RTMPWPARemoveKeyProc\n");
+
+	pKey = (PNDIS_802_11_REMOVE_KEY) pBuf;
+
+	if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+	{
+		pKey = (PNDIS_802_11_REMOVE_KEY) pBuf;
+		KeyIdx = pKey->KeyIndex & 0xff;
+		// Bit 31 of Add-key, Tx Key
+		bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+		// Bit 30 of Add-key PairwiseKey
+		bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+		// Bit 29 of Add-key KeyRSC
+		bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
+		// Bit 28 of Add-key Authenticator
+		bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
+
+		// 1. If bTx is TRUE, return failure information
+		if (bTxKey == TRUE)
+			return(NDIS_STATUS_FAILURE);
+
+		// 2. Check Pairwise Key
+		if (bPairwise)
+		{
+			// a. If BSSID is broadcast, remove all pairwise keys.
+			// b. If not broadcast, remove the pairwise specified by BSSID
+			for (i = 0; i < SHARE_KEY_NUM; i++)
+			{
+				if (MAC_ADDR_EQUAL(pAd->SharedKey[i].BssId, pKey->BSSID))
+				{
+					DBGPRINT(RT_DEBUG_TRACE,"RTMPWPARemoveKeyProc(KeyIdx=%d)\n", i);
+					pAd->SharedKey[i].KeyLen = 0;
+					pAd->SharedKey[i].CipherAlg = CIPHER_NONE;
+					Status = NDIS_STATUS_SUCCESS;
+					break;
+				}
+			}
+		}
+		// 3. Group Key
+		else
+		{
+			// a. If BSSID is broadcast, remove all group keys indexed
+			// b. If BSSID matched, delete the group key indexed.
+			DBGPRINT(RT_DEBUG_TRACE,"RTMPWPARemoveKeyProc(KeyIdx=%d)\n", KeyIdx);
+			pAd->SharedKey[KeyIdx].KeyLen = 0;
+			pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+			Status = NDIS_STATUS_SUCCESS;
+		}
+	}
+	else
+	{
+		KeyIdx = pKey->KeyIndex;
+
+		if (KeyIdx & 0x80000000)
+		{
+			// Should never set default bit when remove key
+			Status = NDIS_STATUS_FAILURE;
+		}
+		else
+		{
+			KeyIdx = KeyIdx & 0x0fffffff;
+			if (KeyIdx > 4)
+				Status = NDIS_STATUS_FAILURE;
+			else
+			{
+				pAd->SharedKey[KeyIdx].KeyLen = 0;
+				pAd->SharedKey[KeyIdx].CipherAlg = CIPHER_NONE;
+				Status = NDIS_STATUS_SUCCESS;
+			}
+		}
+	}
+
+	return (Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME message sanity check to get config data from AP
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+
+    ==========================================================================
+ */
+BOOLEAN BackDoorProbeRspSanity(
+    IN PRTMP_ADAPTER pAd,
+    IN VOID *Msg,
+    IN ULONG MsgLen,
+    OUT CHAR *pCfgDataBuf)
+{
+    PFRAME_802_11       pFrame = (PFRAME_802_11)Msg;
+    CHAR                *Ptr, CfgData[255] = {0};
+    PEID_STRUCT         eid_ptr;
+    USHORT              cfgDataLen = 0;
+
+    Ptr = pFrame->Octet;
+
+    // timestamp from payload and advance the pointer
+    Ptr += TIMESTAMP_LEN;
+
+    // beacon interval from payload and advance the pointer
+    Ptr += 2;
+
+    // capability info from payload and advance the pointer
+    Ptr += 2;
+
+    eid_ptr = (PEID_STRUCT) Ptr;
+
+    // get variable fields from payload and advance the pointer
+    while(((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((UCHAR*)pFrame + MsgLen))
+    {
+        memset(CfgData, 0, 255);
+        switch(eid_ptr->Eid)
+        {
+	        case IE_VENDOR_SPECIFIC:
+                if (NdisEqualMemory(eid_ptr->Octet, RALINK_OUI, 3))
+                {
+                    if ((eid_ptr->Octet[3] & 0x80) == 0x80)
+                    {
+                        if ( (cfgDataLen + eid_ptr->Len - 4) <= MAX_CFG_BUFFER_LEN)
+                        {
+                            //memcpy((pCfgDataBuf + cfgDataLen), (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
+                            memcpy(CfgData, (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
+                            printk("%s\n", CfgData);
+                            return TRUE;
+                        }
+                        else
+                        {
+                            printk("BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
+                            return FALSE;
+                        }
+                    }
+                    else if ((eid_ptr->Octet[3] & 0x40) == 0x40)
+                    {
+                        //memcpy((pCfgDataBuf + cfgDataLen), (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
+                        cfgDataLen += (eid_ptr->Len - 4);
+                        memcpy(CfgData, (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
+                        if (cfgDataLen > MAX_CFG_BUFFER_LEN)
+                        {
+                            printk("BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
+                            return FALSE;
+                        }
+                        else
+                            printk("%s", CfgData);
+                    }
+                    break;
+                }
+            default:
+                break;
+        }
+        eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+    }
+
+
+    return FALSE;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/sync.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/sync.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/sync.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/sync.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1905 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	sync.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	John Chang	2004-09-01	modified for rt2561/2661
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+// 2.4 Ghz channel plan index in the TxPower arrays.
+#define	BG_BAND_REGION_0_START	0			// 1,2,3,4,5,6,7,8,9,10,11
+#define	BG_BAND_REGION_0_SIZE	11
+#define	BG_BAND_REGION_1_START	0			// 1,2,3,4,5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_1_SIZE	13
+#define	BG_BAND_REGION_2_START	9			// 10,11
+#define	BG_BAND_REGION_2_SIZE	2
+#define	BG_BAND_REGION_3_START	9			// 10,11,12,13
+#define	BG_BAND_REGION_3_SIZE	4
+#define	BG_BAND_REGION_4_START	13			// 14
+#define	BG_BAND_REGION_4_SIZE	1
+#define	BG_BAND_REGION_5_START	0			// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
+#define	BG_BAND_REGION_5_SIZE	14
+#define	BG_BAND_REGION_6_START	2			// 3,4,5,6,7,8,9
+#define	BG_BAND_REGION_6_SIZE	7
+#define	BG_BAND_REGION_7_START	4			// 5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_7_SIZE	9
+
+// 5 Ghz channel plan index in the TxPower arrays.
+UCHAR A_BAND_REGION_0_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165};
+UCHAR A_BAND_REGION_1_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140};
+UCHAR A_BAND_REGION_2_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64};
+UCHAR A_BAND_REGION_3_CHANNEL_LIST[]={52, 56, 60, 64, 149, 153, 157, 161};
+UCHAR A_BAND_REGION_4_CHANNEL_LIST[]={149, 153, 157, 161, 165};
+UCHAR A_BAND_REGION_5_CHANNEL_LIST[]={149, 153, 157, 161};
+UCHAR A_BAND_REGION_6_CHANNEL_LIST[]={36, 40, 44, 48};
+UCHAR A_BAND_REGION_7_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165};
+UCHAR A_BAND_REGION_8_CHANNEL_LIST[]={52, 56, 60, 64};
+UCHAR A_BAND_REGION_9_CHANNEL_LIST[]={34, 38, 42, 46};
+UCHAR A_BAND_REGION_10_CHANNEL_LIST[]={34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64};
+
+/*
+    ==========================================================================
+    Description:
+        The sync state machine,
+    Parameters:
+        Sm - pointer to the state machine
+    Note:
+        the state machine looks like the following
+
+    Column 1-2
+                        SYNC_IDLE                       JOIN_WAIT_BEACON
+    MT2_MLME_SCAN_REQ   mlme_scan_req_action            invalid_state_when_scan
+    MT2_MLME_JOIN_REQ   mlme_join_req_action            invalid_state_when_join
+    MT2_MLME_START_REQ  mlme_start_req_action           invalid_state_when_start
+    MT2_PEER_BEACON     peer_beacon                     peer_beacon_at_join_wait_beacon_action
+    MT2_PEER_PROBE_RSP  peer_beacon                     drop
+    MT2_PEER_ATIM       drop                            drop
+    MT2_SCAN_TIMEOUT    Drop                            Drop
+    MT2_BEACON_TIMEOUT  Drop                            beacon_timeout_at_join_wait_beacon_action
+    MT2_ATIM_TIMEOUT    Drop                            Drop
+    MT2_PEER_PROBE_REQ  ????                            drop
+
+    column 3
+                         SCAN_LISTEN
+    MT2_MLME_SCAN_REQ    invalid_state_when_scan
+    MT2_MLME_JOIN_REQ    invalid_state_when_join
+    MT2_MLME_START_REQ   invalid_state_when_start
+    MT2_PEER_BEACON      peer_beacon_at_scan_action
+    MT2_PEER_PROBE_RSP   peer_probe_rsp_at_scan_action
+    MT2_PEER_ATIM        drop
+    MT2_SCAN_TIMEOUT     scan_timeout_action
+    MT2_BEACON_TIMEOUT   Drop
+    MT2_ATIM_TIMEOUT     Drop
+    MT2_PEER_PROBE_REQ   drop
+    ==========================================================================
+ */
+VOID SyncStateMachineInit(
+    IN PRTMP_ADAPTER pAd,
+    IN STATE_MACHINE *Sm,
+    OUT STATE_MACHINE_FUNC Trans[])
+{
+    StateMachineInit(Sm, (STATE_MACHINE_FUNC*)Trans, MAX_SYNC_STATE, MAX_SYNC_MSG, (STATE_MACHINE_FUNC)Drop, SYNC_IDLE, SYNC_MACHINE_BASE);
+
+    // column 1
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)MlmeScanReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)MlmeJoinReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)MlmeStartReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeacon);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ, (STATE_MACHINE_FUNC)PeerProbeReqAction);
+
+    //column 2
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtJoinAction);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT, (STATE_MACHINE_FUNC)BeaconTimeoutAtJoinAction);
+
+    // column 3
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_PROBE_RSP, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT, (STATE_MACHINE_FUNC)ScanTimeoutAction);
+
+    // timer init
+    RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer, &BeaconTimeout);
+    RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer,   &ScanTimeout);
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        Becaon timeout handler, executed in timer thread
+    ==========================================================================
+ */
+VOID BeaconTimeout(
+    IN  unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+
+    DBGPRINT(RT_DEBUG_TRACE,"SYNC - BeaconTimeout\n");
+    MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_BEACON_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Scan timeout handler, executed in timer thread
+    ==========================================================================
+ */
+VOID ScanTimeout(
+    IN  unsigned long data)
+{
+    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)data;
+
+    DBGPRINT(RT_DEBUG_INFO,"SYNC - Scan Timeout \n");
+    MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL);
+    RTUSBMlmeUp(pAd);
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME SCAN req state machine procedure
+    ==========================================================================
+ */
+VOID MlmeScanReqAction(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	UCHAR           Ssid[MAX_LEN_OF_SSID], SsidLen, ScanType, BssType;
+	ULONG           Now;
+    USHORT          Status;
+    PHEADER_802_11  pHdr80211;
+    PUCHAR          pOutBuffer = NULL;
+    USHORT          NStatus;
+
+    // Increase the scan retry counters.
+	pAd->PortCfg.ScanCnt++;
+
+	// Suspend MSDU transmission here
+	RTUSBSuspendMsduTransmission(pAd);
+
+	// first check the parameter sanity
+	if (MlmeScanReqSanity(pAd,
+                          Elem->Msg,
+                          Elem->MsgLen,
+                          &BssType,
+                          Ssid,
+                          &SsidLen,
+                          &ScanType))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeScanReqAction\n");
+
+        //
+		// To prevent data lost.
+		// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
+		// And should send an NULL data with turned PSM bit off to AP, when scan progress done
+		//
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) && (INFRA_ON(pAd)))
+		{
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+            if (NStatus == NDIS_STATUS_SUCCESS)
+            {
+				pHdr80211 = (PHEADER_802_11) pOutBuffer;
+				MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->PortCfg.Bssid, pAd->PortCfg.Bssid);
+				pHdr80211->Duration = 0;
+				pHdr80211->FC.Type = BTYPE_DATA;
+				pHdr80211->FC.PwrMgmt = PWR_SAVE;
+
+				// Send using priority queue
+				MiniportMMRequest(pAd, pOutBuffer, sizeof(HEADER_802_11));
+				DBGPRINT(RT_DEBUG_TRACE, "MlmeScanReqAction -- Send PSM Data frame for off channel RM\n");
+
+				RTMPusecDelay(5000);
+			}
+		}
+
+		Now = jiffies;
+		pAd->PortCfg.LastScanTime = Now;
+
+		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+        RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+
+		// record desired BSS parameters
+		pAd->MlmeAux.BssType = BssType;
+		pAd->MlmeAux.ScanType = ScanType;
+		pAd->MlmeAux.SsidLen = SsidLen;
+		memcpy(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+
+		// start from the first channel
+		pAd->MlmeAux.Channel = FirstChannel(pAd);
+		ScanNextChannel(pAd);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "SYNC - MlmeScanReqAction() sanity check fail. BUG!!!\n");
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		Status = MLME_INVALID_FORMAT;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME JOIN req state machine procedure
+    ==========================================================================
+ */
+VOID MlmeJoinReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    BSS_ENTRY    *pBss;
+    MLME_JOIN_REQ_STRUCT *Info = (MLME_JOIN_REQ_STRUCT *)(Elem->Msg);
+
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeJoinReqAction(BSS #%d)\n", Info->BssIdx);
+
+    // reset all the timers
+    RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+    RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+
+    pBss = &pAd->MlmeAux.SsidBssTab.BssEntry[Info->BssIdx];
+
+    // record the desired SSID & BSSID we're waiting for
+    COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pBss->Bssid);
+    memcpy(pAd->MlmeAux.Ssid, pBss->Ssid, pBss->SsidLen);
+    pAd->MlmeAux.SsidLen = pBss->SsidLen;
+    pAd->MlmeAux.BssType = pBss->BssType;
+    pAd->MlmeAux.Channel = pBss->Channel;
+
+    // switch channel and waiting for beacon timer
+    AsicSwitchChannel(pAd, pAd->MlmeAux.Channel);
+    AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+
+	RTMPSetTimer(pAd, &pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
+
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - Switch to channel %d, SSID %s \n", pAd->MlmeAux.Channel, pAd->MlmeAux.Ssid);
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - Wait BEACON from %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+        pAd->MlmeAux.Bssid[0], pAd->MlmeAux.Bssid[1],
+        pAd->MlmeAux.Bssid[2], pAd->MlmeAux.Bssid[3],
+        pAd->MlmeAux.Bssid[4], pAd->MlmeAux.Bssid[5]);
+
+
+    pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
+}
+
+/*
+    ==========================================================================
+    Description:
+        MLME START Request state machine procedure, starting an IBSS
+    ==========================================================================
+ */
+VOID MlmeStartReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR         Ssid[MAX_LEN_OF_SSID], SsidLen;
+    USHORT        Status;
+
+	// New for WPA security suites
+	UCHAR						VarIE[MAX_VIE_LEN]; 	// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
+	LARGE_INTEGER				TimeStamp;
+    BOOLEAN Privacy;
+#ifdef	SINGLE_ADHOC_LINKUP
+	ULONG	Bssidx;
+	CF_PARM CfParm;
+    CfParm.bValid = FALSE;
+#endif
+
+	// Init Variable IE structure
+	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+	pVIE->Length = 0;
+	TimeStamp.vv.LowPart  = 0;
+	TimeStamp.vv.HighPart = 0;
+
+    if (MlmeStartReqSanity(pAd, Elem->Msg, Elem->MsgLen, Ssid, &SsidLen))
+    {
+        // reset all the timers
+        RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
+	    RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+
+        //
+        // Start a new IBSS. All IBSS parameters are decided now....
+        //
+        pAd->MlmeAux.BssType           = BSS_ADHOC;
+        memcpy(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+        pAd->MlmeAux.SsidLen           = SsidLen;
+
+        // generate a radom number as BSSID
+        MacAddrRandomBssid(pAd, pAd->MlmeAux.Bssid);
+
+        Privacy = (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
+                  (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+                  (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled);
+
+        pAd->MlmeAux.CapabilityInfo    = CAP_GENERATE(0,1,Privacy, (pAd->PortCfg.TxPreamble == Rt802_11PreambleShort), 1);
+        pAd->MlmeAux.BeaconPeriod      = pAd->PortCfg.BeaconPeriod;
+        pAd->MlmeAux.AtimWin           = pAd->PortCfg.AtimWin;
+        pAd->MlmeAux.Channel           = pAd->PortCfg.Channel;
+
+        pAd->MlmeAux.SupRateLen= pAd->PortCfg.SupRateLen;
+        memcpy(pAd->MlmeAux.SupRate, pAd->PortCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+        RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+        pAd->MlmeAux.ExtRateLen = pAd->PortCfg.ExtRateLen;
+        memcpy(pAd->MlmeAux.ExtRate, pAd->PortCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
+        RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+
+        // temporarily not support QOS in IBSS
+        memset(&pAd->MlmeAux.APEdcaParm, 0, sizeof(EDCA_PARM));
+        memset(&pAd->MlmeAux.APQbssLoad, 0, sizeof(QBSS_LOAD_PARM));
+        memset(&pAd->MlmeAux.APQosCapability, 0, sizeof(QOS_CAPABILITY_PARM));
+
+        AsicSwitchChannel(pAd, pAd->MlmeAux.Channel);
+        AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+
+        DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeStartReqAction(ch= %d,sup rates= %d, ext rates=%d)\n",
+            pAd->MlmeAux.Channel, pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen);
+
+#ifdef	SINGLE_ADHOC_LINKUP
+		// Add itself as the entry within BSS table
+		Bssidx = BssTableSearch(&pAd->ScanTab, pAd->MlmeAux.Bssid, pAd->MlmeAux.Channel);
+		if (Bssidx == BSS_NOT_FOUND)
+		{
+			Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, pAd->MlmeAux.Bssid,
+				Ssid, SsidLen, pAd->MlmeAux.BssType, pAd->MlmeAux.BeaconPeriod,
+				&CfParm, pAd->MlmeAux.AtimWin, pAd->MlmeAux.CapabilityInfo,
+				pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRate, pAd->MlmeAux.ExtRateLen,
+				pAd->MlmeAux.Channel, pAd->BbpRssiToDbmDelta - 30, TimeStamp, 0, NULL, NULL, NULL, 0, pVIE);
+		}
+#endif
+
+        pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        Status = MLME_SUCCESS;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
+    }
+    else
+    {
+        DBGPRINT_ERR("SYNC - MlmeStartReqAction() sanity check fail.\n");
+        pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        Status = MLME_INVALID_FORMAT;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        peer sends beacon back when scanning
+    ==========================================================================
+ */
+VOID PeerBeaconAtScanAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR           Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+    UCHAR           Ssid[MAX_LEN_OF_SSID], BssType, Channel, NewChannel,
+                    SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe;
+    CF_PARM         CfParm;
+    USHORT          BeaconPeriod, AtimWin, CapabilityInfo;
+    PFRAME_802_11   pFrame;
+    LARGE_INTEGER   TimeStamp;
+    UCHAR           Erp;
+	UCHAR         	SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		  	SupRateLen, ExtRateLen;
+	UCHAR			LenVIE;
+	UCHAR			CkipFlag;
+	UCHAR			AironetCellPowerLimit;
+	EDCA_PARM       EdcaParm;
+	QBSS_LOAD_PARM  QbssLoad;
+	QOS_CAPABILITY_PARM QosCapability;
+    ULONG           RalinkIe;
+	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
+
+    // NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00);
+    pFrame = (PFRAME_802_11) Elem->Msg;
+	// Init Variable IE structure
+	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+	pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd,
+                                Elem->Msg,
+                                Elem->MsgLen,
+                                Addr2,
+                                Bssid,
+                                Ssid,
+                                &SsidLen,
+                                &BssType,
+                                &BeaconPeriod,
+                                &Channel,
+                                &NewChannel,
+                                &TimeStamp,
+                                &CfParm,
+                                &AtimWin,
+                                &CapabilityInfo,
+                                &Erp,
+                                &DtimCount,
+                                &DtimPeriod,
+                                &BcastFlag,
+                                &MessageToMe,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+                                &CkipFlag,
+                                &AironetCellPowerLimit,
+                                &EdcaParm,
+                                &QbssLoad,
+                                &QosCapability,
+                                &RalinkIe,
+                                &LenVIE,
+                                pVIE))
+    {
+        ULONG Idx;
+        UCHAR Rssi = 0;
+        CHAR  RealRssi;
+
+        // This correct im-proper RSSI indication during SITE SURVEY issue.
+        // Always report bigger RSSI during SCANNING when receiving multiple BEACONs from the same AP.
+        // This case happens because BEACONs come from adjacent channels, so RSSI become weaker as we
+        // switch to more far away channels.
+		if (Elem->Channel != Channel)
+			return;
+
+        Idx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
+        if (Idx != BSS_NOT_FOUND)
+            Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
+
+
+	    RealRssi = ConvertToRssi(pAd, Elem->Rssi, RSSI_NO_1);
+	    if ((RealRssi + pAd->BbpRssiToDbmDelta) > Rssi)
+	        Rssi = RealRssi + pAd->BbpRssiToDbmDelta;
+
+//        DBGPRINT(RT_DEBUG_TRACE, "SYNC - PeerBeaconAtScanAction (SubType=%d, SsidLen=%d, Ssid=%s)\n", pFrame->Hdr.FC.SubType, SsidLen,Ssid);
+
+        // Back Door Mechanism: Get AP Cfg Data
+        if (pAd->PortCfg.bGetAPConfig)
+	{
+		CHAR CfgData[MAX_CFG_BUFFER_LEN+1] = {0};
+		if (BackDoorProbeRspSanity(pAd, Elem->Msg, Elem->MsgLen, CfgData))
+		{
+			printk("MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n", (int)strlen(CfgData), CfgData);
+			pAd->PortCfg.bGetAPConfig = FALSE;
+		}
+	}
+        Idx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid, SsidLen, BssType,
+                    BeaconPeriod, &CfParm, AtimWin, CapabilityInfo, SupRate,
+                    SupRateLen, ExtRate, ExtRateLen, Channel, Rssi, TimeStamp, CkipFlag,
+                    &EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
+    }
+    // sanity check fail, ignored
+}
+
+/*
+    ==========================================================================
+    Description:
+        When waiting joining the (I)BSS, beacon received from external
+    ==========================================================================
+ */
+VOID PeerBeaconAtJoinAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR         Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+    UCHAR         Ssid[MAX_LEN_OF_SSID], SsidLen, BssType, Channel, MessageToMe,
+                  DtimCount, DtimPeriod, BcastFlag, NewChannel;
+    LARGE_INTEGER TimeStamp;
+    USHORT        BeaconPeriod, AtimWin, CapabilityInfo;
+//    UINT          FrameLen = 0;
+    CF_PARM       Cf;
+    UCHAR         Erp;
+	UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		  SupRateLen, ExtRateLen;
+	UCHAR         CkipFlag;
+	UCHAR		  LenVIE;
+	UCHAR		  AironetCellPowerLimit;
+	EDCA_PARM       EdcaParm;
+	QBSS_LOAD_PARM  QbssLoad;
+	QOS_CAPABILITY_PARM QosCapability;
+    USHORT        Status;
+	CHAR	        RealRssi = -85; //assume -85 dB
+	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
+    ULONG           RalinkIe;
+    ULONG           Idx;
+	UCHAR   		PeerTxType;
+
+
+	// Init Variable IE structure
+	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+	pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd,
+                                Elem->Msg,
+                                Elem->MsgLen,
+                                Addr2,
+                                Bssid,
+                                Ssid,
+                                &SsidLen,
+                                &BssType,
+                                &BeaconPeriod,
+                                &Channel,
+                                &NewChannel,
+                                &TimeStamp,
+                                &Cf,
+                                &AtimWin,
+                                &CapabilityInfo,
+                                &Erp,
+                                &DtimCount,
+                                &DtimPeriod,
+                                &BcastFlag,
+                                &MessageToMe,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+                                &CkipFlag,
+                                &AironetCellPowerLimit,
+                                &EdcaParm,
+                                &QbssLoad,
+                                &QosCapability,
+                                &RalinkIe,
+                                &LenVIE,
+                                pVIE))
+    {
+		// Disqualify 11b only adhoc when we are in 11g only adhoc mode
+		if (BssType == BSS_ADHOC)
+		{
+			PeerTxType = PeerTxTypeInUseSanity(Channel, SupRate, SupRateLen, ExtRate, ExtRateLen);
+			if ((pAd->PortCfg.AdhocMode == ADHOC_11G) && (PeerTxType == CCK_RATE))
+			{
+				return;
+			}
+			else if ((pAd->PortCfg.AdhocMode == ADHOC_11B) && (PeerTxType == OFDM_RATE))
+			{
+			    return;
+			}
+		}
+
+		// BEACON from desired BSS/IBSS found. We should be able to decide most
+		// BSS parameters here.
+		// Q. But what happen if this JOIN doesn't conclude a successful ASSOCIATEION?
+		//    Do we need to receover back all parameters belonging to previous BSS?
+		// A. Should be not. There's no back-door recover to previous AP. It still need
+		//    a new JOIN-AUTH-ASSOC sequence.
+		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid))
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n", Channel);
+
+		    RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
+
+
+	        RealRssi = ConvertToRssi(pAd, Elem->Rssi, RSSI_NO_1);
+	        pAd->PortCfg.LastRssi = RealRssi + pAd->BbpRssiToDbmDelta;
+	        pAd->PortCfg.AvgRssi  = pAd->PortCfg.LastRssi;
+	        pAd->PortCfg.AvgRssiX8 = pAd->PortCfg.AvgRssi << 3;
+
+
+			//
+			// We need to check if SSID only set to any, then we can record the current SSID.
+			// Otherwise will cause hidden SSID association failed.
+			//
+			if (pAd->MlmeAux.SsidLen == 0)
+			{
+	           	memcpy(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+	           	pAd->MlmeAux.SsidLen = SsidLen;
+			}
+			else
+			{
+				Idx = BssSsidTableSearch(&pAd->ScanTab, Bssid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, Channel);
+
+				if (Idx != BSS_NOT_FOUND)
+				{
+					//
+					// Multiple SSID case, used correct CapabilityInfo
+					//
+					CapabilityInfo = pAd->ScanTab.BssEntry[Idx].CapabilityInfo;
+				}
+			}
+
+           	pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+            pAd->MlmeAux.BssType = BssType;
+            pAd->MlmeAux.BeaconPeriod = BeaconPeriod;
+            pAd->MlmeAux.Channel = Channel;
+            pAd->MlmeAux.AtimWin = AtimWin;
+            pAd->MlmeAux.CfpPeriod = Cf.CfpPeriod;
+            pAd->MlmeAux.CfpMaxDuration = Cf.CfpMaxDuration;
+            pAd->MlmeAux.APRalinkIe = RalinkIe;
+
+            // Copy AP's supported rate to MlmeAux for creating assoication request
+            // Also filter out not supported rate
+            pAd->MlmeAux.SupRateLen = SupRateLen;
+            memcpy(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
+			RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+            pAd->MlmeAux.ExtRateLen = ExtRateLen;
+            memcpy(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
+			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+
+			//
+			// Update MlmeRate & RtsRate.
+			// We need to update those rates, for example on Roaming A to B,
+			// MlmeRate will be RATE_6(OFDM) on 11A, but when roam to B.
+			// RATE_6 can't be recognized by 11B AP and vice versa.
+			//
+			PeerTxType = PeerTxTypeInUseSanity(Channel, SupRate, SupRateLen, ExtRate, ExtRateLen);
+			switch (PeerTxType)
+			{
+				case CCK_RATE: //CCK
+				case CCKOFDM_RATE: //CCK + OFDM
+					pAd->PortCfg.MlmeRate = RATE_2;
+					pAd->PortCfg.RtsRate = RATE_2;
+					break;
+				case OFDM_RATE: //OFDM
+					pAd->PortCfg.MlmeRate = RATE_6;
+					pAd->PortCfg.RtsRate = RATE_6;
+					break;
+				default:
+					pAd->PortCfg.MlmeRate = RATE_2;
+					pAd->PortCfg.RtsRate = RATE_2;
+					break;
+			}
+
+            // copy QOS related information
+            if (pAd->PortCfg.bWmmCapable)
+            {
+                memcpy(&pAd->MlmeAux.APEdcaParm, &EdcaParm, sizeof(EDCA_PARM));
+                memcpy(&pAd->MlmeAux.APQbssLoad, &QbssLoad, sizeof(QBSS_LOAD_PARM));
+                memcpy(&pAd->MlmeAux.APQosCapability, &QosCapability, sizeof(QOS_CAPABILITY_PARM));
+            }
+            else
+            {
+                memset(&pAd->MlmeAux.APEdcaParm, 0, sizeof(EDCA_PARM));
+                memset(&pAd->MlmeAux.APQbssLoad, 0, sizeof(QBSS_LOAD_PARM));
+                memset(&pAd->MlmeAux.APQosCapability, 0, sizeof(QOS_CAPABILITY_PARM));
+            }
+
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - after JOIN, SupRateLen=%d, ExtRateLen=%d\n",
+                pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen);
+
+            //Used the default TX Power Percentage.
+		    pAd->PortCfg.TxPowerPercentage = pAd->PortCfg.TxPowerDefault;
+
+            pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+            Status = MLME_SUCCESS;
+            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
+        }
+        // not to me BEACON, ignored
+    }
+    // sanity check fail, ignore this frame
+}
+
+/*
+	==========================================================================
+	Description:
+		receive BEACON from peer
+
+	==========================================================================
+ */
+VOID PeerBeacon(
+	IN PRTMP_ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	UCHAR		  Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+	CHAR		  Ssid[MAX_LEN_OF_SSID];
+	CF_PARM 	  CfParm;
+	UCHAR		  SsidLen, MessageToMe=0, BssType, Channel, NewChannel, index=0;
+	UCHAR		  DtimCount=0, DtimPeriod=0, BcastFlag=0;
+	USHORT		  CapabilityInfo, AtimWin, BeaconPeriod;
+	LARGE_INTEGER TimeStamp;
+	USHORT		  TbttNumToNextWakeUp;
+	UCHAR		  Erp;
+	UCHAR		  SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		  SupRateLen, ExtRateLen;
+	UCHAR		  CkipFlag;
+	UCHAR		  LenVIE;
+	UCHAR		  AironetCellPowerLimit;
+	EDCA_PARM		EdcaParm;
+	QBSS_LOAD_PARM	QbssLoad;
+	QOS_CAPABILITY_PARM QosCapability;
+	ULONG			RalinkIe;
+	// New for WPA security suites
+	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
+
+	if (!INFRA_ON(pAd) && !ADHOC_ON(pAd))
+		return;
+
+	// Init Variable IE structure
+	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+	pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd,
+                                Elem->Msg,
+                                Elem->MsgLen,
+                                Addr2,
+                                Bssid,
+                                Ssid,
+                                &SsidLen,
+                                &BssType,
+                                &BeaconPeriod,
+                                &Channel,
+                                &NewChannel,
+                                &TimeStamp,
+                                &CfParm,
+                                &AtimWin,
+                                &CapabilityInfo,
+                                &Erp,
+                                &DtimCount,
+                                &DtimPeriod,
+                                &BcastFlag,
+                                &MessageToMe,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+                                &CkipFlag,
+                                &AironetCellPowerLimit,
+                                &EdcaParm,
+                                &QbssLoad,
+                                &QosCapability,
+                                &RalinkIe,
+                                &LenVIE,
+                                pVIE))
+	{
+		BOOLEAN is_my_bssid, is_my_ssid;
+		ULONG	Bssidx;
+		unsigned long Now;
+		BSS_ENTRY *pBss;
+		CHAR	RealRssi  = -85; //assume -85 dB
+		UCHAR	PeerTxType;
+
+		// Disqualify 11b only adhoc when we are in 11g only adhoc mode
+		if (BssType == BSS_ADHOC)
+		{
+			PeerTxType = PeerTxTypeInUseSanity(Channel, SupRate, SupRateLen, ExtRate, ExtRateLen);
+			if ((pAd->PortCfg.AdhocMode == ADHOC_11G) && (PeerTxType == CCK_RATE))
+			{
+				return;
+			}
+			else if ((pAd->PortCfg.AdhocMode == ADHOC_11B) && (PeerTxType == OFDM_RATE))
+			{
+				return;
+			}
+		}
+
+		RealRssi = ConvertToRssi(pAd, Elem->Rssi, RSSI_NO_1);
+
+		is_my_bssid = MAC_ADDR_EQUAL(Bssid, pAd->PortCfg.Bssid)? TRUE : FALSE;
+		is_my_ssid = SSID_EQUAL(Ssid, SsidLen, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen)? TRUE:FALSE;
+
+		// ignore BEACON not for my SSID
+		if ((! is_my_ssid) && (! is_my_bssid))
+			return;
+
+		//
+		// Housekeeping "SsidBssTab" table for later-on ROAMing usage.
+		//
+		Bssidx = BssTableSearch(&pAd->MlmeAux.SsidBssTab, Bssid, Channel);
+		if (Bssidx == BSS_NOT_FOUND)
+		{
+			// discover new AP of this network, create BSS entry
+			Bssidx = BssTableSetEntry(pAd, &pAd->MlmeAux.SsidBssTab, Bssid, Ssid, SsidLen,
+						BssType, BeaconPeriod, &CfParm, AtimWin, CapabilityInfo,
+						SupRate, SupRateLen, ExtRate, ExtRateLen, Channel, RealRssi + pAd->BbpRssiToDbmDelta, TimeStamp, CkipFlag,
+						&EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
+
+			if (Bssidx == BSS_NOT_FOUND) // return if BSS table full
+				return;
+
+			DBGPRINT(RT_DEBUG_INFO, "SYNC - New AP added to SsidBssTab[%d], RSSI=%d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n",
+				Bssidx, RealRssi, Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]);
+		}
+
+        if ((pAd->PortCfg.bIEEE80211H == 1) && (NewChannel != 0) && (Channel != NewChannel))
+		{
+			// channel sanity check
+	        for (index = 0 ; index < pAd->ChannelListNum; index++)
+            {
+				if (pAd->ChannelList[index].Channel == NewChannel)
+				{
+					pAd->MlmeAux.SsidBssTab.BssEntry[Bssidx].Channel = NewChannel;
+					pAd->PortCfg.Channel = NewChannel;
+					AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+					AsicLockChannel(pAd, pAd->PortCfg.Channel);
+					LinkDown(pAd, FALSE);
+					RTMPusecDelay(1000000);		// use delay to prevent STA do reassoc
+					DBGPRINT(RT_DEBUG_TRACE, "PeerBeacon - STA receive channel switch announcement IE (New Channel =%d)\n", NewChannel);
+					break;
+				}
+			}
+
+			if (index >= pAd->ChannelListNum)
+			{
+				DBGPRINT_ERR("PeerBeacon(can not find New Channel=%d in ChannelList[%d]\n", pAd->PortCfg.Channel, pAd->ChannelListNum);
+			}
+        }
+
+		// if the ssid matched & bssid unmatched, we should select the bssid with large value.
+		// This might happened when two STA start at the same time
+		if ((! is_my_bssid) && ADHOC_ON(pAd))
+		{
+			INT	i;
+
+			// Add to safe guard adhoc wep status mismatch
+			if (pAd->PortCfg.WepStatus != pAd->MlmeAux.SsidBssTab.BssEntry[Bssidx].WepStatus)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "SYNC - Not matched wep status %d %d\n", pAd->PortCfg.WepStatus, pAd->MlmeAux.SsidBssTab.BssEntry[Bssidx].WepStatus);
+				return;
+			}
+
+			// collapse into the ADHOC network which has bigger BSSID value.
+			for (i = 0; i < 6; i++)
+			{
+				if (Bssid[i] > pAd->PortCfg.Bssid[i])
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - merge to the IBSS with bigger BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
+						Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]);
+					AsicDisableSync(pAd);
+					COPY_MAC_ADDR(pAd->PortCfg.Bssid, Bssid);
+					AsicSetBssid(pAd, pAd->PortCfg.Bssid);
+					MakeIbssBeacon(pAd);		// re-build BEACON frame
+					AsicEnableIbssSync(pAd);	// copy BEACON frame to on-chip memory
+					break;
+				}
+			}
+		}
+
+		DBGPRINT(RT_DEBUG_INFO, "SYNC - PeerBeacon from %02x:%02x:%02x:%02x:%02x:%02x - Dtim=%d/%d, Rssi=%02x\n",
+			Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5],
+			DtimCount, DtimPeriod, RealRssi);
+
+		Now = jiffies;
+		pBss = &pAd->MlmeAux.SsidBssTab.BssEntry[Bssidx];
+		pBss->Rssi = RealRssi + pAd->BbpRssiToDbmDelta; 	  // lastest RSSI
+		pBss->LastBeaconRxTime = Now;	// last RX timestamp
+
+		//
+		// BEACON from my BSSID - either IBSS or INFRA network
+		//
+		if (is_my_bssid)
+		{
+			pAd->PortCfg.LastBeaconRxTime = Now;
+			DBGPRINT(RT_DEBUG_INFO,"Rx My BEACON\n");
+
+			// Used the default TX Power Percentage, that set from UI.
+			pAd->PortCfg.TxPowerPercentage = pAd->PortCfg.TxPowerDefault;
+
+			// at least one 11b peer joined. downgrade the MaxTxRate to 11Mbps
+			// after last 11b peer left for several seconds, we'll auto switch back to 11G rate
+			// in MlmePeriodicExec()
+			if (ADHOC_ON(pAd) && (SupRateLen+ExtRateLen <= 4))
+			{
+				// this timestamp is for MlmePeriodicExec() to check if all 11B peers have left
+				pAd->PortCfg.Last11bBeaconRxTime = Now;
+
+				if (pAd->PortCfg.MaxTxRate > RATE_11)
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - 11b peer joined. down-grade to 11b TX rates \n");
+					memcpy(pAd->ActiveCfg.SupRate, SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+					pAd->ActiveCfg.SupRateLen = SupRateLen;
+					memcpy(pAd->ActiveCfg.ExtRate, ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
+					pAd->ActiveCfg.ExtRateLen = ExtRateLen;
+					MlmeUpdateTxRates(pAd, FALSE);
+					MakeIbssBeacon(pAd);		// re-build BEACON frame
+					AsicEnableIbssSync(pAd);	// copy to on-chip memory
+				}
+			}
+
+			// check if RSSI reaches threshold
+			RealRssi = ConvertToRssi(pAd, Elem->Rssi, RSSI_NO_1);
+			pAd->PortCfg.LastRssi = RealRssi + pAd->BbpRssiToDbmDelta;
+			pAd->PortCfg.AvgRssiX8 = (pAd->PortCfg.AvgRssiX8 - pAd->PortCfg.AvgRssi) + pAd->PortCfg.LastRssi;
+			pAd->PortCfg.AvgRssi  = pAd->PortCfg.AvgRssiX8 >> 3;
+
+
+			if ((pAd->PortCfg.RssiTriggerMode == RSSI_TRIGGERED_UPON_BELOW_THRESHOLD) &&
+				(pAd->PortCfg.LastRssi < pAd->PortCfg.RssiTrigger))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "SYNC - NdisMIndicateStatus *** RSSI %d dBm, less than threshold %d dBm\n",
+					pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta,
+					pAd->PortCfg.RssiTrigger - pAd->BbpRssiToDbmDelta);
+			}
+			else if ((pAd->PortCfg.RssiTriggerMode == RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD) &&
+				(pAd->PortCfg.LastRssi > pAd->PortCfg.RssiTrigger))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "SYNC - NdisMIndicateStatus *** RSSI %d dBm, greater than threshold %d dBm\n",
+					pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta,
+					pAd->PortCfg.RssiTrigger - pAd->BbpRssiToDbmDelta);
+			}
+
+			if (INFRA_ON(pAd)) // && (pAd->PortCfg.PhyMode == PHY_11BG_MIXED))
+			{
+				BOOLEAN bUseShortSlot, bUseBGProtection;
+
+				// decide to use/change to -
+				//		1. long slot (20 us) or short slot (9 us) time
+				//		2. turn on/off RTS/CTS and/or CTS-to-self protection
+				//		3. short preamble
+				bUseShortSlot = pAd->PortCfg.UseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo);
+				if (bUseShortSlot != OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
+					AsicSetSlotTime(pAd, bUseShortSlot);
+
+				bUseBGProtection = (pAd->PortCfg.UseBGProtection == 1) ||	 // always use
+								   ((pAd->PortCfg.UseBGProtection == 0) && ERP_IS_USE_PROTECTION(Erp));
+
+				if (pAd->PortCfg.Channel > 14) // always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP
+					bUseBGProtection = FALSE;
+
+				if (bUseBGProtection != OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+				{
+					if (bUseBGProtection)
+						OPSTATUS_SET_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
+					else
+						OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP changed B/G protection to %d\n", bUseBGProtection);
+				}
+
+				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED) &&
+					ERP_IS_USE_BARKER_PREAMBLE(Erp))
+				{
+					MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP forced to use LONG preamble\n");
+				}
+
+				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)	  &&
+					(EdcaParm.bValid == TRUE)						   &&
+					(EdcaParm.EdcaUpdateCount != pAd->PortCfg.APEdcaParm.EdcaUpdateCount))
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP change EDCA parameters(from %d to %d)\n",
+						pAd->PortCfg.APEdcaParm.EdcaUpdateCount,
+						EdcaParm.EdcaUpdateCount);
+					AsicSetEdcaParm(pAd, &EdcaParm);
+				}
+
+				// copy QOS related information
+				memcpy(&pAd->PortCfg.APQbssLoad, &QbssLoad, sizeof(QBSS_LOAD_PARM));
+				memcpy(&pAd->PortCfg.APQosCapability, &QosCapability, sizeof(QOS_CAPABILITY_PARM));
+
+			}
+
+			// only INFRASTRUCTURE mode support power-saving feature
+			if (INFRA_ON(pAd) && (pAd->PortCfg.Psm == PWR_SAVE))
+			{
+//				UCHAR FreeNumber;
+				//	1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL
+				//	2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE
+				//	3. we have outgoing frames in TxRing or MgmtRing, better stay AWAKE
+				//	4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE
+				//	5. otherwise, put PHY back to sleep to save battery.
+				if (MessageToMe)
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP backlog unicast-to-me, stay AWAKE, send PSPOLL\n");
+					EnqueuePsPoll(pAd);
+				}
+				else if (BcastFlag && (DtimCount == 0) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM))
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP backlog broadcast/multicast, stay AWAKE\n");
+				}
+#if 0
+				else if ((RTUSBFreeTXDRequest(pAd, QID_AC_BE, TX_RING_SIZE, &FreeNumber) != NDIS_STATUS_SUCCESS)  ||
+//						 (RTUSBFreeTXDRequest(pAd, QID_AC_BK, TX_RING_SIZE, &FreeNumber) != NDIS_STATUS_SUCCESS)  ||
+//						 (RTUSBFreeTXDRequest(pAd, QID_AC_VI, TX_RING_SIZE, &FreeNumber) != NDIS_STATUS_SUCCESS)	   ||
+//						 (RTUSBFreeTXDRequest(pAd, QID_AC_VO, TX_RING_SIZE, &FreeNumber) != NDIS_STATUS_SUCCESS)	   ||
+						 (RTUSBFreeTXDRequest(pAd, QID_MGMT, MGMT_RING_SIZE, &FreeNumber) != NDIS_STATUS_SUCCESS))
+				{
+					// TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme
+					// can we cheat here (i.e. just check MGMT & AC_BE) for better performance?
+					DBGPRINT(RT_DEBUG_TRACE, "SYNC - outgoing frame in TxRing/MgmtRing, stay AWAKE\n");
+				}
+#endif
+				else
+				{
+					USHORT NextDtim = DtimCount;
+
+					if (NextDtim == 0)
+						NextDtim = DtimPeriod;
+
+					TbttNumToNextWakeUp = pAd->PortCfg.DefaultListenCount;
+					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM) && (TbttNumToNextWakeUp > NextDtim))
+						TbttNumToNextWakeUp = NextDtim;
+
+					DBGPRINT(RT_DEBUG_INFO, "SYNC - PHY sleeps for %d TBTT, Dtim=%d/%d\n", TbttNumToNextWakeUp, DtimCount, DtimPeriod);
+					AsicSleepThenAutoWakeup(pAd, TbttNumToNextWakeUp);
+				}
+			}
+
+#ifndef	SINGLE_ADHOC_LINKUP
+			// At least another peer in this IBSS, declare MediaState as CONNECTED
+			if (ADHOC_ON(pAd) &&
+				!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			{
+				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+
+				// 2003/03/12 - john
+				// Make sure this entry in "ScanTab" table, thus complies to Microsoft's policy that
+				// "site survey" result should always include the current connected network.
+				//
+				Bssidx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
+				if (Bssidx == BSS_NOT_FOUND)
+				{
+					Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid, SsidLen,
+								BssType, BeaconPeriod, &CfParm, AtimWin, CapabilityInfo,
+								SupRate, SupRateLen, ExtRate, ExtRateLen, Channel, RealRssi + pAd->BbpRssiToDbmDelta, TimeStamp, CkipFlag,
+								&EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
+				}
+			}
+#endif
+		}
+		// not my BSSID, ignore it
+	}
+	// sanity check fail, ignore this frame
+}
+
+/*
+    ==========================================================================
+    Description:
+        Receive PROBE REQ from remote peer when operating in IBSS mode
+    ==========================================================================
+ */
+VOID PeerProbeReqAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    UCHAR         Addr2[MAC_ADDR_LEN];
+    CHAR          Ssid[MAX_LEN_OF_SSID];
+    UCHAR         SsidLen;
+    HEADER_802_11 ProbeRspHdr;
+    PUCHAR        pOutBuffer = NULL;
+    ULONG         FrameLen = 0;
+    LARGE_INTEGER FakeTimestamp;
+    UCHAR         DsLen = 1, IbssLen = 2;
+    UCHAR         LocalErpIe[3] = {IE_ERP, 1, 0};
+    USHORT        NStatus;
+    BOOLEAN       Privacy;
+    USHORT        CapabilityInfo;
+
+    if (! ADHOC_ON(pAd))
+        return;
+
+    if (PeerProbeReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, Ssid, &SsidLen))
+    {
+        if ((SsidLen == 0) || SSID_EQUAL(Ssid, SsidLen, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen))
+        {
+#if 0
+            CSR15_STRUC Csr15;
+
+            // we should respond a ProbeRsp only when we're the last BEACON transmitter
+            // in this ADHOC network.
+            RTMP_IO_READ32(pAd, CSR15, &Csr15.word);
+            if (Csr15.field.BeaconSent == 0)
+            {
+                DBGPRINT(RT_DEBUG_INFO, "SYNC - NOT last BEACON sender, no PROBE_RSP to %02x:%02x:%02x:%02x:%02x:%02x...\n",
+                    Addr2[0],Addr2[1],Addr2[2],Addr2[3],Addr2[4],Addr2[5] );
+                return;
+            }
+#endif
+
+            // allocate and send out ProbeReq frame
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+            if (NStatus != NDIS_STATUS_SUCCESS)
+	            return;
+
+            //pAd->PortCfg.AtimWin = 0;  // ??????
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - Send PROBE_RSP to %02x:%02x:%02x:%02x:%02x:%02x...\n",
+                Addr2[0],Addr2[1],Addr2[2],Addr2[3],Addr2[4],Addr2[5] );
+            MgtMacHeaderInit(pAd, &ProbeRspHdr, SUBTYPE_PROBE_RSP, 0, Addr2, pAd->PortCfg.Bssid);
+
+
+			Privacy = (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
+					  (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+					  (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled);
+			CapabilityInfo = CAP_GENERATE(0, 1, Privacy, (pAd->PortCfg.TxPreamble == Rt802_11PreambleShort), 0);
+
+
+            MakeOutgoingFrame(pOutBuffer,                   &FrameLen,
+                              sizeof(HEADER_802_11),        &ProbeRspHdr,
+                              TIMESTAMP_LEN,                &FakeTimestamp,
+                              2,                            &pAd->PortCfg.BeaconPeriod,
+                              2,                            &CapabilityInfo,
+                              1,                            &SsidIe,
+                              1,                            &pAd->PortCfg.SsidLen,
+                              pAd->PortCfg.SsidLen,         pAd->PortCfg.Ssid,
+                              1,                            &SupRateIe,
+                              1,                            &pAd->ActiveCfg.SupRateLen,
+                              pAd->ActiveCfg.SupRateLen,    pAd->ActiveCfg.SupRate,
+                              1,                            &DsIe,
+                              1,                            &DsLen,
+                              1,                            &pAd->PortCfg.Channel,
+                              1,                            &IbssIe,
+                              1,                            &IbssLen,
+                              2,                            &pAd->ActiveCfg.AtimWin,
+                              END_OF_ARGS);
+
+            if (pAd->ActiveCfg.ExtRateLen)
+            {
+                ULONG tmp;
+                MakeOutgoingFrame(pOutBuffer + FrameLen,        &tmp,
+                                  3,                            LocalErpIe,
+                                  1,                            &ExtRateIe,
+                                  1,                            &pAd->ActiveCfg.ExtRateLen,
+                                  pAd->ActiveCfg.ExtRateLen,    &pAd->ActiveCfg.ExtRate,
+                                  END_OF_ARGS);
+                FrameLen += tmp;
+            }
+
+			// If adhoc secruity is set for WPA-None, append the cipher suite IE
+			if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+			{
+				ULONG	tmp;
+
+				if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) 	// Tkip
+				{
+					MakeOutgoingFrame(pOutBuffer + FrameLen, 		&tmp,
+							          1,						    &WpaIe,
+							          1,							&CipherSuiteWpaNoneTkipLen,
+							          CipherSuiteWpaNoneTkipLen,	&CipherSuiteWpaNoneTkip[0],
+							          END_OF_ARGS);
+					FrameLen += tmp;
+				}
+				else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)	// Aes
+				{
+					MakeOutgoingFrame(pOutBuffer + FrameLen, 		&tmp,
+							          1,						    &WpaIe,
+							          1,							&CipherSuiteWpaNoneAesLen,
+							          CipherSuiteWpaNoneAesLen,	    &CipherSuiteWpaNoneAes[0],
+							          END_OF_ARGS);
+					FrameLen += tmp;
+				}
+			}
+            MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+        }
+    }
+}
+
+VOID BeaconTimeoutAtJoinAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT  Status;
+
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - BeaconTimeoutAtJoinAction\n");
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    Status = MLME_REJ_TIMEOUT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Scan timeout procedure. basically add channel index by 1 and rescan
+    ==========================================================================
+ */
+VOID ScanTimeoutAction(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+//  DBGPRINT(RT_DEBUG_TRACE,"SYNC - ScanTimeoutAction\n");
+    pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
+    ScanNextChannel(pAd); // this routine will stop if pAd->MlmeAux.Channel == 0
+}
+
+/*
+    ==========================================================================
+    Description:
+        Scan next channel
+    ==========================================================================
+ */
+VOID ScanNextChannel(
+	IN PRTMP_ADAPTER pAd)
+{
+    HEADER_802_11   Hdr80211;
+    PUCHAR          pOutBuffer = NULL;
+    ULONG           FrameLen = 0;
+    UCHAR           SsidLen = 0, ScanType = pAd->MlmeAux.ScanType;
+    USHORT          Status;
+    PHEADER_802_11  pHdr80211;
+    USHORT          NStatus;
+    PUCHAR          pSupRate = NULL;
+    UCHAR           SupRateLen;
+    PUCHAR          pExtRate = NULL;
+    UCHAR           ExtRateLen;
+//For A band
+    UCHAR           ASupRate[] = {0x8C, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6C};
+    UCHAR           ASupRateLen = sizeof(ASupRate)/sizeof(UCHAR);
+
+    DBGPRINT(RT_DEBUG_INFO, "ScanNextChannel(ch=%d)\n",pAd->MlmeAux.Channel);
+
+    if (pAd->MlmeAux.Channel == 0)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "SYNC - End of SCAN, restore to channel %d\n",pAd->PortCfg.Channel);
+
+        AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+        AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+        // G band - set BBP_R62 to 0x02 when site survey or rssi<-82
+		// A band - always set BBP_R62 to 0x04
+        if (pAd->PortCfg.Channel <= 14)
+        {
+        	RTUSBWriteBBPRegister(pAd, BBP_R62, 0x02);
+        }
+        else
+        {
+        	RTUSBWriteBBPRegister(pAd, BBP_R62, 0x04);
+        }
+
+		//
+		// To prevent data lost.
+		// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
+		// Now, we need to send an NULL data with turned PSM bit off to AP, when scan progress done
+		//
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) && (INFRA_ON(pAd)))
+		{
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+            if (NStatus == NDIS_STATUS_SUCCESS)
+            {
+				pHdr80211 = (PHEADER_802_11) pOutBuffer;
+				MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->PortCfg.Bssid, pAd->PortCfg.Bssid);
+				pHdr80211->Duration = 0;
+				pHdr80211->FC.Type = BTYPE_DATA;
+				pHdr80211->FC.PwrMgmt = PWR_ACTIVE;
+
+				// Send using priority queue
+				MiniportMMRequest(pAd, pOutBuffer, sizeof(HEADER_802_11));
+				DBGPRINT(RT_DEBUG_TRACE, "MlmeScanReqAction -- Send PSM Data frame\n");
+
+				RTMPusecDelay(5000);
+			}
+		}
+
+        pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        Status = MLME_SUCCESS;
+        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+
+    }
+    else if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+	{
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		Status = MLME_FAIL_NO_RESOURCE;
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+	}
+    else
+    {
+        // BBP and RF are not accessible in PS mode, we has to wake them up first
+        if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+            AsicForceWakeup(pAd);
+
+        // leave PSM during scanning. otherwise we may lost ProbeRsp & BEACON
+        if (pAd->PortCfg.Psm == PWR_SAVE)
+            MlmeSetPsmBit(pAd, PWR_ACTIVE);
+
+        AsicSwitchChannel(pAd, pAd->MlmeAux.Channel);
+        AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+
+        // G band - set BBP_R62 to 0x02 when site survey or rssi<-82
+		// A band - always set BBP_R62 to 0x04
+        if (pAd->MlmeAux.Channel <= 14)
+        {
+		    //
+			// For the high power and False CCA issue.(Gary)
+			//
+			RTUSBWriteBBPRegister(pAd, BBP_R62, 0x04);
+			RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17LowerBoundG);        }
+        else
+        {
+            if ((pAd->PortCfg.bIEEE80211H == 1) && RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
+			    ScanType = SCAN_PASSIVE;
+
+        	RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17LowerBoundA);
+        	RTUSBWriteBBPRegister(pAd, BBP_R62, 0x04);
+        }
+
+
+		// We need to shorten active scan time in order for WZC connect issue
+		// Chnage the channel scan time for CISCO stuff based on its IAPP announcement
+        if (ScanType == FAST_SCAN_ACTIVE)
+        {
+			RTMPSetTimer(pAd, &pAd->MlmeAux.ScanTimer, FAST_ACTIVE_SCAN_TIME);
+        }
+        else // must be SCAN_PASSIVE or SCAN_ACTIVE
+        {
+        	if (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED)
+				RTMPSetTimer(pAd, &pAd->MlmeAux.ScanTimer, MIN_CHANNEL_TIME);
+			else
+			    RTMPSetTimer(pAd, &pAd->MlmeAux.ScanTimer, MAX_CHANNEL_TIME);
+        }
+
+	if ((pAd->MlmeAux.Channel == 34) || (pAd->MlmeAux.Channel == 38) ||
+	    (pAd->MlmeAux.Channel == 42) || (pAd->MlmeAux.Channel == 46))
+	{
+			ScanType = SCAN_PASSIVE;
+	}
+
+        if ((ScanType == SCAN_ACTIVE) || (ScanType == FAST_SCAN_ACTIVE))
+        {
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+            if (NStatus != NDIS_STATUS_SUCCESS)
+            {
+    	        DBGPRINT(RT_DEBUG_TRACE, "SYNC - ScanNextChannel() allocate memory fail\n");
+        	    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        	    Status = MLME_FAIL_NO_RESOURCE;
+                MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+	            return;
+    	    }
+
+    		// There is no need to send broadcast probe request if active scan is in effect.
+            SsidLen = pAd->MlmeAux.SsidLen;
+
+   	if (pAd->MlmeAux.Channel <= 14)
+	{
+		// B&G band use 1,2,5.5,11
+		pSupRate = pAd->PortCfg.SupRate;
+		SupRateLen = pAd->PortCfg.SupRateLen;
+		pExtRate = pAd->PortCfg.ExtRate;
+		ExtRateLen = pAd->PortCfg.ExtRateLen;
+	}
+	else    // A band use OFDM rate
+	{
+		//
+		// Overwrite Support Rate, CCK rate are not allowed
+		//
+		pSupRate = ASupRate;
+		SupRateLen = ASupRateLen;
+		ExtRateLen = 0;
+	}
+
+
+    	    MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, BROADCAST_ADDR, BROADCAST_ADDR);
+            MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                              sizeof(HEADER_802_11),    &Hdr80211,
+                              1,                        &SsidIe,
+                              1,                        &SsidLen,
+                              SsidLen,			pAd->MlmeAux.Ssid,
+                              1,                        &SupRateIe,
+                              1,                        &SupRateLen,
+	                      SupRateLen,  		pSupRate,
+                              END_OF_ARGS);
+
+            if (ExtRateLen)
+            {
+                ULONG Tmp;
+            	MakeOutgoingFrame(pOutBuffer + FrameLen,        &Tmp,
+                                  1,                            &ExtRateIe,
+                                  1,                            &ExtRateLen,
+                                  ExtRateLen,      		pExtRate,
+                                  END_OF_ARGS);
+            	FrameLen += Tmp;
+            }
+
+            // add Simple Config Information Element
+            if (pAd->PortCfg.bWscCapable && pAd->PortCfg.WscIEProbeReq.ValueLen)
+            {
+                ULONG WscTmpLen = 0;
+
+                MakeOutgoingFrame(pOutBuffer+FrameLen,                      &WscTmpLen,
+                                  pAd->PortCfg.WscIEProbeReq.ValueLen,      pAd->PortCfg.WscIEProbeReq.Value,
+                                  END_OF_ARGS);
+                FrameLen += WscTmpLen;
+            }
+
+
+            if (pAd->PortCfg.bGetAPConfig)
+            {
+                UCHAR RalinkSpecificIEForGetCfg[6] = {IE_VENDOR_SPECIFIC, 4, 0x00, 0x0c, 0x43, 0x80};
+                ULONG Tmp = 0;
+                MakeOutgoingFrame(pOutBuffer + FrameLen,        &Tmp,
+                                  6,                            RalinkSpecificIEForGetCfg,
+                                  END_OF_ARGS);
+                FrameLen += Tmp;
+            }
+
+            MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+            DBGPRINT(RT_DEBUG_INFO, "SYNC - send ProbeReq @ channel=%d, Len=%d\n", pAd->MlmeAux.Channel, FrameLen);
+        }
+
+		// For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe reponse
+
+        pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenScan(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT  Status;
+    DBGPRINT(RT_DEBUG_TRACE, "AYNC - InvalidStateWhenScan(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenJoin(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT  Status;
+
+    DBGPRINT(RT_DEBUG_TRACE, "AYNC - InvalidStateWhenJoin(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenStart(
+    IN PRTMP_ADAPTER pAd,
+    IN MLME_QUEUE_ELEM *Elem)
+{
+    USHORT  Status;
+
+    DBGPRINT(RT_DEBUG_TRACE, "AYNC - InvalidStateWhenStart(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    Status = MLME_STATE_MACHINE_REJECT;
+    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
+}
+
+/*
+    ==========================================================================
+    Description:
+
+    ==========================================================================
+ */
+VOID EnqueuePsPoll(
+    IN PRTMP_ADAPTER pAd)
+{
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - send PsPoll ...\n");
+    MiniportMMRequest(pAd, (PUCHAR)&pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
+}
+
+// 2003-04-17 john
+// driver force send out a BEACON frame to cover ADHOC mode BEACON starving issue
+// that is, in ADHOC mode, driver guarantee itself can send out at least a BEACON
+// per a specified duration, even the peer's clock is faster than us and win all the
+// hardware-based BEACON TX oppertunity.
+// we may remove this software feature once 2560 IC fix this problem in ASIC.
+VOID EnqueueBeaconFrame(
+    IN PRTMP_ADAPTER pAd)
+{
+
+    PTXD_STRUC		pTxD;
+#ifdef BIG_ENDIAN
+    PTXD_STRUC      pDestTxD;
+    TXD_STRUC       TxD;
+#endif
+    PCHAR           pBeaconFrame = pAd->BeaconBuf;
+    PUCHAR			pOutBuffer = NULL;
+    LARGE_INTEGER   *Tsf = kzalloc(sizeof(LARGE_INTEGER), GFP_KERNEL);
+    NDIS_STATUS		NStatus;
+
+		if(!Tsf) {
+			DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+			return;
+		}
+#ifndef BIG_ENDIAN
+	pTxD = &pAd->BeaconTxD;
+#else
+    pDestTxD  = &pAd->BeaconTxD;
+    TxD = *pDestTxD;
+    pTxD = &TxD;
+    RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+#endif
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - driver sent BEACON (len=%d)...\n",pTxD->DataByteCnt);
+
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "EnqueueBeaconFrame allocate memory fail\n");
+		kfree(Tsf);
+		return;
+	}
+
+    RTUSBReadMACRegister(pAd, TXRX_CSR13, &Tsf->vv.HighPart);
+    RTUSBReadMACRegister(pAd, TXRX_CSR12, &Tsf->vv.LowPart);
+
+    // TODO: not good if porting to big endian platform - TSF byte order ???
+    memcpy(pBeaconFrame + sizeof(HEADER_802_11), Tsf, TIMESTAMP_LEN);
+	memcpy(pOutBuffer, pBeaconFrame, 256);
+	MiniportMMRequest(pAd, pOutBuffer, pTxD->DataByteCnt);
+
+#ifdef BIG_ENDIAN
+    RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+    WriteBackToDescriptor((PUCHAR)pDestTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
+#endif
+	kfree(Tsf);
+}
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID EnqueueProbeRequest(
+    IN PRTMP_ADAPTER pAd)
+{
+    PUCHAR          pOutBuffer;
+    ULONG           FrameLen = 0;
+    HEADER_802_11   Hdr80211;
+    USHORT          NStatus;
+
+    DBGPRINT(RT_DEBUG_TRACE, "force out a ProbeRequest ...\n");
+
+
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "EnqueueProbeRequest() allocate memory fail\n");
+        return;
+    }
+    else
+    {
+        MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, BROADCAST_ADDR, BROADCAST_ADDR);
+
+		// this ProbeRequest explicitly specify SSID to reduce unwanted ProbeResponse
+        MakeOutgoingFrame(pOutBuffer,                     &FrameLen,
+                          sizeof(HEADER_802_11),          &Hdr80211,
+                          1,                              &SsidIe,
+                          1,                              &pAd->PortCfg.SsidLen,
+                          pAd->PortCfg.SsidLen,		      pAd->PortCfg.Ssid,
+                          1,                              &SupRateIe,
+                          1,                              &pAd->ActiveCfg.SupRateLen,
+                          pAd->ActiveCfg.SupRateLen,      pAd->ActiveCfg.SupRate,
+                          END_OF_ARGS);
+
+        // add Simple Config Information Element
+        if (pAd->PortCfg.bWscCapable && pAd->PortCfg.WscIEProbeReq.ValueLen)
+        {
+            ULONG WscTmpLen = 0;
+
+            MakeOutgoingFrame(pOutBuffer+FrameLen,                   &WscTmpLen,
+        		              pAd->PortCfg.WscIEProbeReq.ValueLen,   pAd->PortCfg.WscIEProbeReq.Value,
+                              END_OF_ARGS);
+            FrameLen += WscTmpLen;
+        }
+
+	    if (pAd->PortCfg.bGetAPConfig)
+	    {
+	 	    UCHAR RalinkSpecificIEForGetCfg[6] = {IE_VENDOR_SPECIFIC, 4, 0x00, 0x0c, 0x43, 0x80};
+		    ULONG Tmp = 0;
+		    MakeOutgoingFrame(pOutBuffer + FrameLen,        &Tmp,
+			                  6,                            RalinkSpecificIEForGetCfg,
+			                  END_OF_ARGS);
+		FrameLen += Tmp;
+	    }
+
+        MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+    }
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        Update PortCfg->ChannelList[] according to 1) Country Region 2) RF IC type,
+        and 3) PHY-mode user selected.
+        The outcome is used by driver when doing site survey.
+    ==========================================================================
+ */
+VOID BuildChannelList(
+	IN PRTMP_ADAPTER pAd)
+{
+    UCHAR i, j, index=0, num=0;
+    PUCHAR	pChannelList=NULL;
+
+    memset(pAd->ChannelList, 0, MAX_NUM_OF_CHANNELS * sizeof(CHANNEL_TX_POWER));
+
+    // if not 11a-only mode, channel list starts from 2.4Ghz band
+    if (pAd->PortCfg.PhyMode != PHY_11A)
+    {
+        switch (pAd->PortCfg.CountryRegion & 0x7f)
+        {
+            case REGION_0_BG_BAND:	// 1 -11
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_0_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_0_SIZE);
+                index += BG_BAND_REGION_0_SIZE;
+                break;
+            case REGION_1_BG_BAND:	// 1 - 13
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_1_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_1_SIZE);
+                index += BG_BAND_REGION_1_SIZE;
+                break;
+            case REGION_2_BG_BAND:	// 10 - 11
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_2_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_2_SIZE);
+                index += BG_BAND_REGION_2_SIZE;
+                break;
+            case REGION_3_BG_BAND:	// 10 - 13
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_3_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_3_SIZE);
+                index += BG_BAND_REGION_3_SIZE;
+                break;
+            case REGION_4_BG_BAND:	// 14
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_4_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_4_SIZE);
+                index += BG_BAND_REGION_4_SIZE;
+                break;
+            case REGION_5_BG_BAND:	// 1 - 14
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_5_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_5_SIZE);
+                index += BG_BAND_REGION_5_SIZE;
+                break;
+            case REGION_6_BG_BAND:	// 3 - 9
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_6_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_6_SIZE);
+                index += BG_BAND_REGION_6_SIZE;
+                break;
+			case REGION_7_BG_BAND:  // 5 - 13
+                memcpy(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_7_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_7_SIZE);
+                index += BG_BAND_REGION_7_SIZE;
+                break;
+            default:                // Error. should never happen
+                break;
+        }
+    }
+
+    if (pAd->PortCfg.PhyMode == PHY_11A || (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED))
+    {
+    	switch (pAd->PortCfg.CountryRegionForABand & 0x7f)
+        {
+            case REGION_0_A_BAND:
+            	num = sizeof(A_BAND_REGION_0_CHANNEL_LIST)/sizeof(UCHAR);
+	            pChannelList = A_BAND_REGION_0_CHANNEL_LIST;
+                break;
+            case REGION_1_A_BAND:
+            	num = sizeof(A_BAND_REGION_1_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_1_CHANNEL_LIST;
+                break;
+            case REGION_2_A_BAND:
+            	num = sizeof(A_BAND_REGION_2_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_2_CHANNEL_LIST;
+                break;
+            case REGION_3_A_BAND:
+            	num = sizeof(A_BAND_REGION_3_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_3_CHANNEL_LIST;
+                break;
+            case REGION_4_A_BAND:
+            	num = sizeof(A_BAND_REGION_4_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_4_CHANNEL_LIST;
+                break;
+            case REGION_5_A_BAND:
+            	num = sizeof(A_BAND_REGION_5_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_5_CHANNEL_LIST;
+                break;
+            case REGION_6_A_BAND:
+            	num = sizeof(A_BAND_REGION_6_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_6_CHANNEL_LIST;
+                break;
+            case REGION_7_A_BAND:
+            	num = sizeof(A_BAND_REGION_7_CHANNEL_LIST)/sizeof(UCHAR);
+            	pChannelList = A_BAND_REGION_7_CHANNEL_LIST;
+                break;
+            case REGION_8_A_BAND:
+				num = sizeof(A_BAND_REGION_8_CHANNEL_LIST)/sizeof(UCHAR);
+				pChannelList = A_BAND_REGION_8_CHANNEL_LIST;
+				break;
+			case REGION_9_A_BAND:
+				num = sizeof(A_BAND_REGION_9_CHANNEL_LIST)/sizeof(UCHAR);
+				pChannelList = A_BAND_REGION_9_CHANNEL_LIST;
+				break;
+			case REGION_10_A_BAND:
+				num = sizeof(A_BAND_REGION_10_CHANNEL_LIST)/sizeof(UCHAR);
+				pChannelList = A_BAND_REGION_10_CHANNEL_LIST;
+				break;
+            default:            // Error. should never happen
+            	DBGPRINT(RT_DEBUG_WARN,"countryregion=%d not support", pAd->PortCfg.CountryRegionForABand);
+                break;
+        }
+
+		if (num != 0)
+		{
+	        for (i=0; i<num; i++)
+	        {
+	        	for (j=0; j<MAX_NUM_OF_CHANNELS; j++)
+	        	{
+	        		if (pChannelList[i] == pAd->TxPower[j].Channel)
+	        		{
+			        	memcpy(&pAd->ChannelList[index+i], &pAd->TxPower[j], sizeof(CHANNEL_TX_POWER));
+	        		}
+	        	}
+	        }
+	        index += num;
+		}
+    }
+
+    pAd->ChannelListNum = index;
+
+
+    if (pAd->PortCfg.BssType == BSS_ADHOC)
+    {
+        if (ChannelSanity(pAd, pAd->PortCfg.AdhocChannel) == TRUE)
+			pAd->PortCfg.Channel = pAd->PortCfg.AdhocChannel;   // sync. to the value of PortCfg.AdhocChannel
+	}
+
+
+    DBGPRINT(RT_DEBUG_TRACE,"country code=%d/%d, RFIC=%d, PHY mode=%d, support %d channels\n",
+        pAd->PortCfg.CountryRegion, pAd->PortCfg.CountryRegionForABand, pAd->RfIcType, pAd->PortCfg.PhyMode, pAd->ChannelListNum);
+    for (i=0;i<index;i++)
+    {
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"channel #%d\n", pAd->ChannelList[i].Channel);
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine returns the next channel number. This routine is called
+        during driver need to start a site survey of all supported channels.
+    Return:
+        next_channel - the next channel number valid in current country code setting.
+    Note:
+        return 0 if no more next channel
+    ==========================================================================
+ */
+UCHAR NextChannel(
+    IN PRTMP_ADAPTER pAd,
+    IN UCHAR channel)
+{
+    int i;
+    UCHAR next_channel = 0;
+
+    for (i = 0; i < (pAd->ChannelListNum - 1); i++)
+        if (channel == pAd->ChannelList[i].Channel)
+        {
+            next_channel = pAd->ChannelList[i+1].Channel;
+			break;
+	}
+    return next_channel;
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine return the first channel number according to the country
+        code selection and RF IC selection (signal band or dual band). It is called
+        whenever driver need to start a site survey of all supported channels.
+    Return:
+        ch - the first channel number of current country code setting
+    ==========================================================================
+ */
+UCHAR FirstChannel(
+    IN PRTMP_ADAPTER pAd)
+{
+	return pAd->ChannelList[0].Channel;
+}
+
+CHAR	ConvertToRssi(
+    IN PRTMP_ADAPTER pAd,
+	IN	UCHAR	Rssi,
+	IN  UCHAR   RssiNumber)
+{
+#ifdef BIG_ENDIAN
+	typedef	union	_LNA_AGC
+	{
+		struct
+		{
+            UCHAR	Rsvd:1;
+            UCHAR	Lna:2;
+			UCHAR	Agc:5;
+		}	field;
+		UCHAR		Byte;
+	}	LNA_AGC;
+#else
+	typedef	union	_LNA_AGC
+	{
+		struct
+		{
+			UCHAR	Agc:5;
+			UCHAR	Lna:2;
+			UCHAR	Rsvd:1;
+		}	field;
+		UCHAR		Byte;
+	}	LNA_AGC;
+#endif
+
+	LNA_AGC	LnaAgc;
+	CHAR	RssiOffset = 0;
+
+	//
+	// Get RSSI Offset.
+	//
+	if (pAd->PortCfg.Channel <= 14)
+	{
+		if (RssiNumber == RSSI_NO_1)
+			RssiOffset = pAd->BGRssiOffset1;
+		else if (RssiNumber == RSSI_NO_2)
+			RssiOffset = pAd->BGRssiOffset2;
+	}
+	else
+	{
+		if (RssiNumber == RSSI_NO_1)
+			RssiOffset = pAd->ARssiOffset1;
+		else if (RssiNumber == RSSI_NO_2)
+			RssiOffset = pAd->ARssiOffset2;
+	}
+
+	LnaAgc.Byte = Rssi;
+	if (pAd->NicConfig2.field.ExternalLNA == 0)
+	{
+		if (LnaAgc.field.Lna == 0x03)
+		{
+			if (pAd->PortCfg.Channel <= 14)
+				return (LnaAgc.field.Agc * 2 - 90 + RssiOffset); //for B/G mode
+			else
+				return (LnaAgc.field.Agc * 2 - 96 + RssiOffset); //for A mode
+		}
+		else if (LnaAgc.field.Lna == 0x02)
+		{
+			if (pAd->PortCfg.Channel <= 14)
+				return (LnaAgc.field.Agc * 2 - 74 + RssiOffset); //for B/G mode
+			else
+				return (LnaAgc.field.Agc * 2 - 82 + RssiOffset); //for A mode
+		}
+		else if (LnaAgc.field.Lna == 0x01)
+		{
+			return (LnaAgc.field.Agc * 2 - 64 + RssiOffset);
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	else
+	{
+		// RSSI needs to be offset when external LNA enable
+		if (LnaAgc.field.Lna == 0x03)
+		{
+			if (pAd->PortCfg.Channel <= 14)
+				return (LnaAgc.field.Agc * 2 - (90 + 14) + RssiOffset); //for B/G mode
+			else
+				return (LnaAgc.field.Agc * 2 - (100 + 14) + RssiOffset); //for A mode
+		}
+		else if (LnaAgc.field.Lna == 0x02)
+		{
+			if (pAd->PortCfg.Channel <= 14)
+				return (LnaAgc.field.Agc * 2 - (74 + 14) + RssiOffset); //for B/G mode
+			else
+				return (LnaAgc.field.Agc * 2 - (86 + 14) + RssiOffset); //for A mode
+		}
+		else if (LnaAgc.field.Lna == 0x01)
+		{
+			return (LnaAgc.field.Agc * 2 - (64 + 14) + RssiOffset);
+		}
+		else
+		{
+			return -1;
+		}
+	}
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/wpa.c linux-2.6.23.1-stm/drivers/net/wireless/rt73/wpa.c
--- linux-2.6.23.1/drivers/net/wireless/rt73/wpa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/wpa.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,2160 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	wpa.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Jan Lee		03-07-22	Initial
+ *	Paul Lin	03-11-28	Modify for supplicant
+ *
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+
+UCHAR	CipherWpaPskTkip[] = {
+		0xDD, 0x16,				// RSN IE
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x02,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x02	// authentication
+		};
+UCHAR	CipherWpaPskTkipLen = (sizeof(CipherWpaPskTkip) / sizeof(UCHAR));
+
+UCHAR	CipherWpaPskAes[] = {
+		0xDD, 0x16, 			// RSN IE
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x04,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x04,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x02	// authentication
+		};
+UCHAR	CipherWpaPskAesLen = (sizeof(CipherWpaPskAes) / sizeof(UCHAR));
+
+extern UCHAR    CipherWpa2Template[];
+extern UCHAR    CipherWpa2TemplateLen;
+
+#define     WPARSNIE    0xdd
+#define     WPA2RSNIE   0x30
+
+
+/*
+	========================================================================
+
+	Routine Description:
+		Classify WPA EAP message type
+
+	Arguments:
+		EAPType		Value of EAP message type
+		MsgType		Internal Message definition for MLME state machine
+
+	Return Value:
+		TRUE		Found appropriate message type
+		FALSE		No appropriate message type
+
+	Note:
+		All these constants are defined in wpa.h
+		For supplicant, there is only EAPOL Key message avaliable
+
+	========================================================================
+*/
+BOOLEAN WpaMsgTypeSubst(
+	IN	UCHAR	EAPType,
+	OUT	ULONG	*MsgType)
+{
+	switch (EAPType)
+	{
+		case EAPPacket:
+			*MsgType = MT2_EAPPacket;
+			break;
+		case EAPOLStart:
+			*MsgType = MT2_EAPOLStart;
+			break;
+		case EAPOLLogoff:
+			*MsgType = MT2_EAPOLLogoff;
+			break;
+		case EAPOLKey:
+			*MsgType = MT2_EAPOLKey;
+			break;
+		case EAPOLASFAlert:
+			*MsgType = MT2_EAPOLASFAlert;
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_INFO, "WpaMsgTypeSubst : return FALSE; \n");
+			return FALSE;
+	}
+	return TRUE;
+}
+
+/*
+	==========================================================================
+	Description:
+		association	state machine init,	including state	transition and timer init
+	Parameters:
+		S -	pointer	to the association state machine
+	==========================================================================
+ */
+VOID    WpaPskStateMachineInit(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	STATE_MACHINE *S,
+	OUT	STATE_MACHINE_FUNC Trans[])
+{
+	StateMachineInit(S,	(STATE_MACHINE_FUNC*)Trans, MAX_WPA_PSK_STATE, MAX_WPA_PSK_MSG, (STATE_MACHINE_FUNC)Drop, WPA_PSK_IDLE, WPA_MACHINE_BASE);
+	StateMachineSetAction(S, WPA_PSK_IDLE, MT2_EAPOLKey, (STATE_MACHINE_FUNC)WpaEAPOLKeyAction);
+}
+
+/*
+	==========================================================================
+	Description:
+		This is	state machine function.
+		When receiving EAPOL packets which is  for 802.1x key management.
+		Use	both in	WPA, and WPAPSK	case.
+		In this	function, further dispatch to different	functions according	to the received	packet.
+		3 categories are :
+		  1.  normal 4-way pairwisekey and 2-way groupkey handshake
+		  2.  MIC error	(Countermeasures attack)  report packet	from STA.
+		  3.  Request for pairwise/group key update	from STA
+	Return:
+	==========================================================================
+*/
+VOID    WpaEAPOLKeyAction(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM	*Elem)
+{
+	INT				MsgType = EAPOL_MSG_INVALID;
+	PKEY_DESCRIPTER	pKeyDesc;
+    PHEADER_802_11  pHeader; //red
+    UCHAR			ZeroReplay[LEN_KEY_DESC_REPLAY];
+
+	DBGPRINT(RT_DEBUG_TRACE, "-----> WpaEAPOLKeyAction\n");
+
+    pHeader = (PHEADER_802_11) Elem->Msg;
+
+	// Get 802.11 header first
+    pKeyDesc = (PKEY_DESCRIPTER) &Elem->Msg[(LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H)];
+
+#ifdef BIG_ENDIAN
+    // pMsg->KeyDesc.KeyInfo and pKeyDesc->KeyInfo both point to the same addr.
+    // Thus, it only needs swap once.
+{
+		USHORT	tmpKeyinfo;
+
+		memcpy(&tmpKeyinfo, &pKeyDesc->KeyInfo, sizeof(USHORT));
+		tmpKeyinfo = SWAP16(tmpKeyinfo);
+		memcpy(&pKeyDesc->KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	    *(USHORT *)((UCHAR *)pKeyDesc+1) = SWAP16(*(USHORT *)((UCHAR *)pKeyDesc+1));
+#endif
+
+	// Sanity check, this should only happen in WPA(2)-PSK mode
+	// 0. Debug print all bit information
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Description Version %d\n", pKeyDesc->KeyInfo.KeyDescVer);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Type %d\n", pKeyDesc->KeyInfo.KeyType);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Index %d\n", pKeyDesc->KeyInfo.KeyIndex);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Install %d\n", pKeyDesc->KeyInfo.Install);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Ack %d\n", pKeyDesc->KeyInfo.KeyAck);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key MIC %d\n", pKeyDesc->KeyInfo.KeyMic);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Secure %d\n", pKeyDesc->KeyInfo.Secure);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Error %d\n", pKeyDesc->KeyInfo.Error);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo Request %d\n", pKeyDesc->KeyInfo.Request);
+	DBGPRINT(RT_DEBUG_INFO, "KeyInfo EKD_DL %d\n", pKeyDesc->KeyInfo.EKD_DL);
+
+	pAd->EAPOLVer = Elem->Msg[LENGTH_802_11+LENGTH_802_1_H];
+	// 1. Check EAPOL frame version and type
+    if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+    {
+        if (((pAd->EAPOLVer != 1) && (pAd->EAPOLVer != 2)) || (pKeyDesc->Type != WPA1_KEY_DESC))
+	    {
+		    DBGPRINT(RT_DEBUG_ERROR, "	 Key descripter	does not match with	WPA1 rule \n");
+		    return;
+	    }
+    }
+    else if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+    {
+        // pass (Version != EAPOL_VER)
+        if (pKeyDesc->Type != WPA2_KEY_DESC)
+        {
+            DBGPRINT(RT_DEBUG_ERROR, "   Key descripter does not match with WPA2 rule \n");
+            return;
+        }
+    }
+
+    // First validate replay counter, only accept message with larger replay counter
+	// Let equal pass, some AP start with all zero replay counter
+	memset(ZeroReplay, 0, LEN_KEY_DESC_REPLAY);
+	if ((RTMPCompareMemory(pKeyDesc->ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1) &&
+		(RTMPCompareMemory(pKeyDesc->ReplayCounter, ZeroReplay, LEN_KEY_DESC_REPLAY) != 0))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "   ReplayCounter not match   \n");
+		return;
+    }
+
+
+/*
+====================================================================
+        WPAPSK2     WPAPSK2         WPAPSK2     WPAPSK2
+======================================================================
+*/
+    if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+    {
+        if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+            (pKeyDesc->KeyInfo.EKD_DL == 0) &&
+            (pKeyDesc->KeyInfo.KeyAck == 1) &&
+            (pKeyDesc->KeyInfo.KeyMic == 0) &&
+            (pKeyDesc->KeyInfo.Secure == 0) &&
+            (pKeyDesc->KeyInfo.Error == 0) &&
+            (pKeyDesc->KeyInfo.Request == 0))
+        {
+            MsgType = EAPOL_PAIR_MSG_1;
+            DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Pairwise Message 1\n");
+        }
+        else if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+                (pKeyDesc->KeyInfo.EKD_DL  == 1) &&
+                (pKeyDesc->KeyInfo.KeyAck == 1) &&
+                (pKeyDesc->KeyInfo.KeyMic == 1) &&
+                (pKeyDesc->KeyInfo.Secure == 1) &&
+                (pKeyDesc->KeyInfo.Error == 0) &&
+                (pKeyDesc->KeyInfo.Request == 0))
+        {
+            MsgType = EAPOL_PAIR_MSG_3;
+            DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Pairwise Message 3\n");
+        }
+        else if ((pKeyDesc->KeyInfo.KeyType == 0) &&
+                (pKeyDesc->KeyInfo.EKD_DL == 1) &&
+                (pKeyDesc->KeyInfo.KeyAck == 1) &&
+                (pKeyDesc->KeyInfo.KeyMic == 1) &&
+                (pKeyDesc->KeyInfo.Secure == 1) &&
+                (pKeyDesc->KeyInfo.Error == 0) &&
+                (pKeyDesc->KeyInfo.Request == 0))
+        {
+            MsgType = EAPOL_GROUP_MSG_1;
+            DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Group Message 1\n");
+        }
+
+#ifdef BIG_ENDIAN
+        // recovery original byte order, before forward Elem to another routine
+{
+        USHORT	tmpKeyinfo;
+
+        memcpy(&tmpKeyinfo, &pKeyDesc->KeyInfo, sizeof(USHORT));
+        tmpKeyinfo = SWAP16(tmpKeyinfo);
+	    memcpy(&pKeyDesc->KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	    *(USHORT *)((UCHAR *)pKeyDesc+1) = SWAP16(*(USHORT *)((UCHAR *)pKeyDesc+1));
+#endif
+
+        // We will assume link is up (assoc suceess and port not secured).
+        // All state has to be able to process message from previous state
+        switch (pAd->PortCfg.WpaState)
+        {
+            case SS_START:
+                if (MsgType == EAPOL_PAIR_MSG_1)
+                {
+                    Wpa2PairMsg1Action(pAd, Elem);
+                    pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+                }
+                break;
+
+			case SS_WAIT_MSG_3:
+			    if (MsgType == EAPOL_PAIR_MSG_1)
+			    {
+			        Wpa2PairMsg1Action(pAd, Elem);
+			        pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+			    }
+			    else if (MsgType == EAPOL_PAIR_MSG_3)
+			    {
+			        Wpa2PairMsg3Action(pAd, Elem);
+			        pAd->PortCfg.WpaState = SS_WAIT_GROUP;
+			    }
+			    break;
+
+			case SS_WAIT_GROUP:     // When doing group key exchange
+			case SS_FINISH:         // This happened when update group key
+			    if (MsgType == EAPOL_PAIR_MSG_1)
+			    {
+			        Wpa2PairMsg1Action(pAd, Elem);
+			        pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+			        // Reset port secured variable
+			        pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+			    }
+			    else if (MsgType == EAPOL_PAIR_MSG_3)
+			    {
+			        Wpa2PairMsg3Action(pAd, Elem);
+			        pAd->PortCfg.WpaState = SS_WAIT_GROUP;
+			        // Reset port secured variable
+			        pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+			    }
+			    else if (MsgType == EAPOL_GROUP_MSG_1)
+			    {
+			        WpaGroupMsg1Action(pAd, Elem);
+			        pAd->PortCfg.WpaState = SS_FINISH;
+			    }
+			    break;
+
+			default:
+			    break;
+        }
+    }
+
+///*
+//====================================================================
+//          WPAPSK          WPAPSK          WPAPSK          WPAPSK
+//======================================================================
+//*/
+	// Classify message Type, either pairwise message 1, 3, or group message 1 for supplicant
+    else if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+    {
+	    if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+		    (pKeyDesc->KeyInfo.KeyIndex == 0) &&
+		    (pKeyDesc->KeyInfo.KeyAck == 1) &&
+		    (pKeyDesc->KeyInfo.KeyMic == 0) &&
+		    (pKeyDesc->KeyInfo.Secure == 0) &&
+		    (pKeyDesc->KeyInfo.Error == 0) &&
+		    (pKeyDesc->KeyInfo.Request == 0))
+	    {
+		    MsgType = EAPOL_PAIR_MSG_1;
+		    DBGPRINT(RT_DEBUG_TRACE, "Receive EAPOL Key Pairwise Message 1\n");
+	    }
+	    else if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+		    (pKeyDesc->KeyInfo.KeyIndex == 0) &&
+		    (pKeyDesc->KeyInfo.KeyAck == 1) &&
+		    (pKeyDesc->KeyInfo.KeyMic == 1) &&
+		    (pKeyDesc->KeyInfo.Secure == 0) &&
+		    (pKeyDesc->KeyInfo.Error == 0) &&
+		    (pKeyDesc->KeyInfo.Request == 0))
+	    {
+		    MsgType = EAPOL_PAIR_MSG_3;
+		    DBGPRINT(RT_DEBUG_TRACE, "Receive EAPOL Key Pairwise Message 3\n");
+	    }
+	    else if ((pKeyDesc->KeyInfo.KeyType == 0) &&
+		    (pKeyDesc->KeyInfo.KeyIndex != 0) &&
+		    (pKeyDesc->KeyInfo.KeyAck == 1) &&
+		    (pKeyDesc->KeyInfo.KeyMic == 1) &&
+		    (pKeyDesc->KeyInfo.Secure == 1) &&
+		    (pKeyDesc->KeyInfo.Error == 0) &&
+		    (pKeyDesc->KeyInfo.Request == 0))
+	    {
+		    MsgType = EAPOL_GROUP_MSG_1;
+		    DBGPRINT(RT_DEBUG_TRACE, "Receive EAPOL Key Group Message 1\n");
+	    }
+
+#ifdef BIG_ENDIAN
+        // recovery original byte order, before forward Elem to another routine
+{
+	    USHORT	tmpKeyinfo;
+
+	    memcpy(&tmpKeyinfo, &pKeyDesc->KeyInfo, sizeof(USHORT));
+	    tmpKeyinfo = SWAP16(tmpKeyinfo);
+	    memcpy(&pKeyDesc->KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	    *(USHORT *)((UCHAR *)pKeyDesc+1) = SWAP16(*(USHORT *)((UCHAR *)pKeyDesc+1));
+#endif
+
+	    // We will assume link is up (assoc suceess and port not secured).
+	    // All state has to be able to process message from previous state
+	    switch (pAd->PortCfg.WpaState)
+	    {
+		    case SS_START:
+			    if (MsgType == EAPOL_PAIR_MSG_1)
+			    {
+				    WpaPairMsg1Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+			    }
+			    break;
+
+		    case SS_WAIT_MSG_3:
+			    if (MsgType == EAPOL_PAIR_MSG_1)
+			    {
+				    WpaPairMsg1Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+			    }
+			    else if (MsgType == EAPOL_PAIR_MSG_3)
+			    {
+				    WpaPairMsg3Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_WAIT_GROUP;
+			    }
+			    break;
+
+		    case SS_WAIT_GROUP:		// When doing group key exchange
+		    case SS_FINISH:			// This happened when update group key
+			    if (MsgType == EAPOL_PAIR_MSG_1)
+			    {
+				    WpaPairMsg1Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_WAIT_MSG_3;
+				    // Reset port secured variable
+				    pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+			    }
+			    else if (MsgType == EAPOL_PAIR_MSG_3)
+			    {
+				    WpaPairMsg3Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_WAIT_GROUP;
+				    // Reset port secured variable
+				    pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+			    }
+			    else if (MsgType == EAPOL_GROUP_MSG_1)
+			    {
+				    WpaGroupMsg1Action(pAd, Elem);
+				    pAd->PortCfg.WpaState = SS_FINISH;
+			    }
+			    break;
+
+		    default:
+			    break;
+	    }
+    }
+
+	DBGPRINT(RT_DEBUG_TRACE, "<----- WpaEAPOLKeyAction\n");
+}
+
+
+/*
+	========================================================================
+
+	Routine Description:
+		Process Pairwise key 4-way handshaking
+
+	Arguments:
+		pAd	Pointer	to our adapter
+		Elem		Message body
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	WpaPairMsg1Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM	*Elem)
+{
+	PHEADER_802_11		pHeader;
+	UCHAR				PTK[80];
+	PUCHAR				pOutBuffer = NULL;
+	HEADER_802_11		Header_802_11;
+	UCHAR				AckRate = RATE_2;
+	USHORT				AckDuration = 0;
+	ULONG				FrameLen = 0;
+	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00,0x88,0x8e};
+	PEAPOL_PACKET		pMsg1;
+	EAPOL_PACKET		Packet;
+	UCHAR				Mic[16];
+	USHORT              NStatus;
+
+	DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg1Action ----->\n");
+
+	pHeader	= (PHEADER_802_11) Elem->Msg;
+
+	// Save Data Length to pDesc for receiving packet, then put in outgoing frame	Data Len fields.
+	pMsg1 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+
+	// Process message 1 from authenticator
+	// Key must be Pairwise key, already verified at callee.
+	// 1. Save Replay counter, it will use to verify message 3 and construct message 2
+	memcpy(pAd->PortCfg.ReplayCounter, pMsg1->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+	// 2. Save ANonce
+	memcpy(pAd->PortCfg.ANonce, pMsg1->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);
+
+	// TSNonce <--- SNonce
+	// Generate random SNonce
+	GenRandom(pAd,	pAd->PortCfg.SNonce);
+
+    // TPTK <--- Calc PTK(ANonce, TSNonce)
+    WpaCountPTK(pAd->PortCfg.PskKey.Key,
+		        pAd->PortCfg.ANonce,
+			    pAd->PortCfg.Bssid,
+			    pAd->PortCfg.SNonce,
+			    pAd->CurrentAddress,
+			    PTK,
+			    LEN_PTK);
+
+	// Save key to PTK entry
+	memcpy(pAd->PortCfg.PTK, PTK, LEN_PTK);
+
+	// =====================================
+	// Use Priority Ring & MiniportMMRequest
+	// =====================================
+	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+	WpaMacHeaderInit(pAd, &Header_802_11, 0, pAd->PortCfg.Bssid);
+
+	// ACK size	is 14 include CRC, and its rate	is based on real time information
+	AckRate = pAd->PortCfg.ExpectedACKRate[pAd->PortCfg.TxRate];
+	AckDuration = RTMPCalcDuration(pAd, AckRate, 14);
+	Header_802_11.Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+	// Zero message 2 body
+	memset(&Packet, 0, sizeof(Packet));
+	Packet.Version = pAd->EAPOLVer;
+	Packet.Type    = EAPOLKey;
+	//
+	// Message 2 as  EAPOL-Key(0,1,0,0,0,P,0,SNonce,MIC,RSN IE)
+	//
+	Packet.KeyDesc.Type = RSN_KEY_DESC;
+	// 1. Key descriptor version and appropriate RSN IE
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
+	}
+	else	// TKIP
+	{
+        Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
+	}
+    Packet.KeyDesc.KeyDataLen[1] = pAd->PortCfg.RSN_IELen;
+    memcpy(Packet.KeyDesc.KeyData, pAd->PortCfg.RSN_IE, pAd->PortCfg.RSN_IELen);
+
+	// Update packet length after decide Key data payload
+	Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE + Packet.KeyDesc.KeyDataLen[1];
+
+	// Update Key length
+	Packet.KeyDesc.KeyLength[0] = pMsg1->KeyDesc.KeyLength[0];
+	Packet.KeyDesc.KeyLength[1] = pMsg1->KeyDesc.KeyLength[1];
+
+	// 2. Key Type PeerKey
+	Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+	// 3. KeyMic field presented
+	Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+	// 4. Fill SNonce
+	memcpy(Packet.KeyDesc.KeyNonce, pAd->PortCfg.SNonce, LEN_KEY_DESC_NONCE);
+
+	// 5. Key Replay Count
+	memcpy(Packet.KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+#ifdef BIG_ENDIAN
+    // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &Packet.KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&Packet.KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	*(USHORT *)(&(Packet.KeyDesc.KeyInfo)) = SWAP16(*(USHORT *)(&(Packet.KeyDesc.KeyInfo)));
+#endif
+
+	// Send EAPOL(0, 1, 0, 0, 0, K, 0, TSNonce, 0, MIC(TPTK), 0)
+	// Out buffer for transmitting message 2
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+		return;
+
+	// Prepare EAPOL frame for MIC calculation
+	// Be careful, only EAPOL frame is counted for MIC calculation
+	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+	// 5. Prepare and Fill MIC value
+	memset(Mic, 0, sizeof(Mic));
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		// AES
+		UCHAR digest[80];
+
+		HMAC_SHA1(pOutBuffer, FrameLen, PTK, LEN_EAP_MICK, digest);
+		memcpy(Mic,	digest,	LEN_KEY_DESC_MIC);
+	}
+	else
+	{
+		INT i;
+		DBGPRINT_RAW(RT_DEBUG_INFO, " PMK = ");
+		for (i = 0; i < 16; i++)
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PskKey.Key[i]);
+
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n PTK = ");
+		for (i = 0; i < 64; i++)
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PTK[i]);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n FrameLen = %d\n", FrameLen);
+
+	    hmac_md5(PTK,  LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
+	}
+	memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;
+	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+	                  sizeof(HEADER_802_11),&Header_802_11,
+		              sizeof(EAPHEAD),      EAPHEAD,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+	// Send using priority queue
+	MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg1Action <-----\n");
+}
+
+VOID    Wpa2PairMsg1Action(
+    IN  PRTMP_ADAPTER   pAd,
+    IN  MLME_QUEUE_ELEM *Elem)
+{
+    PHEADER_802_11      pHeader;
+    UCHAR               PTK[80];
+    PUCHAR              pOutBuffer = NULL;
+    HEADER_802_11       Header_802_11;
+    UCHAR               AckRate = RATE_2;
+    USHORT              AckDuration = 0;
+    ULONG               FrameLen = 0;
+    UCHAR               EAPHEAD[8] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,0x88,0x8e};
+    PEAPOL_PACKET       pMsg1;
+    EAPOL_PACKET        Packet;
+    UCHAR               Mic[16];
+    USHORT              NStatus;
+
+    DBGPRINT(RT_DEBUG_TRACE, "Wpa2PairMsg1Action ----->\n");
+
+    pHeader = (PHEADER_802_11) Elem->Msg;
+
+    // Save Data Length to pDesc for receiving packet, then put in outgoing frame   Data Len fields.
+    pMsg1 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+
+    // Process message 1 from authenticator
+    // Key must be Pairwise key, already verified at callee.
+    // 1. Save Replay counter, it will use to verify message 3 and construct message 2
+    memcpy(pAd->PortCfg.ReplayCounter, pMsg1->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // 2. Save ANonce
+    memcpy(pAd->PortCfg.ANonce, pMsg1->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);
+
+    // TSNonce <--- SNonce
+    // Generate random SNonce
+    GenRandom(pAd, pAd->PortCfg.SNonce);
+
+    if (pMsg1->KeyDesc.KeyDataLen[1] > 0 )
+    {
+        // cached PMKID
+    }
+
+    // TPTK <--- Calc PTK(ANonce, TSNonce)
+    WpaCountPTK(pAd->PortCfg.PskKey.Key,
+        pAd->PortCfg.ANonce,
+        pAd->PortCfg.Bssid,
+        pAd->PortCfg.SNonce,
+        pAd->CurrentAddress,
+        PTK,
+        LEN_PTK);
+
+    // Save key to PTK entry
+    memcpy(pAd->PortCfg.PTK, PTK, LEN_PTK);
+
+    // =====================================
+    // Use Priority Ring & MiniportMMRequest
+    // =====================================
+    pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WpaMacHeaderInit(pAd, &Header_802_11, 0, pAd->PortCfg.Bssid);
+
+    // ACK size is 14 include CRC, and its rate is based on real time information
+    AckRate = pAd->PortCfg.ExpectedACKRate[pAd->PortCfg.TxRate];
+    AckDuration = RTMPCalcDuration(pAd, AckRate, 14);
+    Header_802_11.Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+    // Zero message 2 body
+    memset(&Packet, 0, sizeof(Packet));
+    Packet.Version = pAd->EAPOLVer;
+    Packet.Type    = EAPOLKey;
+    //
+    // Message 2 as  EAPOL-Key(0,1,0,0,0,P,0,SNonce,MIC,RSN IE)
+    //
+    Packet.KeyDesc.Type = WPA2_KEY_DESC;
+    // 1. Key descriptor version and appropriate RSN IE
+    memcpy(Packet.KeyDesc.KeyData, pAd->PortCfg.RSN_IE, pAd->PortCfg.RSN_IELen);
+    Packet.KeyDesc.KeyDataLen[1] = pAd->PortCfg.RSN_IELen;
+
+
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
+    }
+    else    // TKIP
+    {
+        Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
+    }
+    // Update packet length after decide Key data payload
+    Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE + Packet.KeyDesc.KeyDataLen[1];
+
+    // 2. Key Type PeerKey
+    Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+    // 3. KeyMic field presented
+    Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+    // Update Key Length
+    Packet.KeyDesc.KeyLength[0] = 0;
+    Packet.KeyDesc.KeyLength[1] = pMsg1->KeyDesc.KeyLength[1];
+
+    // 4. Fill SNonce
+    memcpy(Packet.KeyDesc.KeyNonce, pAd->PortCfg.SNonce, LEN_KEY_DESC_NONCE);
+
+    // 5. Key Replay Count
+    memcpy(Packet.KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+#ifdef BIG_ENDIAN
+    // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &Packet.KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&Packet.KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // Send EAPOL(0, 1, 0, 0, 0, K, 0, TSNonce, 0, MIC(TPTK), 0)
+    // Out buffer for transmitting message 2
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;
+
+    // Prepare EAPOL frame for MIC calculation
+    // Be careful, only EAPOL frame is counted for MIC calculation
+
+    MakeOutgoingFrame(pOutBuffer,        &FrameLen,
+                      Packet.Len[1] + 4, &Packet,
+                      END_OF_ARGS);
+
+
+    // 5. Prepare and Fill MIC value
+    memset(Mic, 0, sizeof(Mic));
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+
+        HMAC_SHA1(pOutBuffer, FrameLen, PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        hmac_md5(PTK,  LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
+    }
+    memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+
+    FrameLen = 0;
+    // Make  Transmitting frame
+    MakeOutgoingFrame(pOutBuffer,             &FrameLen,
+                      sizeof(HEADER_802_11),  &Header_802_11,
+                      sizeof(EAPHEAD),        EAPHEAD,
+                      Packet.Len[1] + 4,      &Packet,
+                      END_OF_ARGS);
+
+
+    // Send using priority queue
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+    DBGPRINT(RT_DEBUG_TRACE, "Wpa2PairMsg1Action <-----\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Process Pairwise key 4-way handshaking
+
+	Arguments:
+		pAd	Pointer	to our adapter
+		Elem		Message body
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	WpaPairMsg3Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM	*Elem)
+{
+	PHEADER_802_11		pHeader;
+	PUCHAR				pOutBuffer = NULL;
+	HEADER_802_11		Header_802_11;
+	UCHAR				AckRate = RATE_2;
+	USHORT				AckDuration = 0;
+	ULONG				FrameLen = 0;
+	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00,0x88,0x8e};
+	EAPOL_PACKET		Packet;
+	PEAPOL_PACKET		pMsg3;
+	UCHAR				Mic[16], OldMic[16];
+	PNDIS_802_11_KEY	pPeerKey;
+	USHORT              NStatus;
+
+	DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg3Action ----->\n");
+
+	pHeader	= (PHEADER_802_11) Elem->Msg;
+
+	// Process message 3 frame.
+	pMsg3 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)) = SWAP16(*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)));
+#endif
+
+	// 1. Verify RSN IE & cipher type match
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled && (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 2))
+	{
+	    return;
+	}
+	else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled && (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 1))
+	{
+	    return;
+	}
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)) = SWAP16(*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)));
+#endif
+
+	// 2. Check MIC value
+	// Save the MIC and replace with zero
+	memcpy(OldMic, pMsg3->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+	memset(pMsg3->KeyDesc.KeyMic, 0, LEN_KEY_DESC_MIC);
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		// AES
+		UCHAR digest[80];
+
+		HMAC_SHA1((PUCHAR) pMsg3, pMsg3->Len[1] + 4, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+		memcpy(Mic,	digest,	LEN_KEY_DESC_MIC);
+	}
+	else
+	{
+		hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, (PUCHAR) pMsg3, pMsg3->Len[1] + 4, Mic);
+	}
+
+	if (!NdisEqualMemory(OldMic, Mic, LEN_KEY_DESC_MIC))
+	{
+		DBGPRINT(RT_DEBUG_ERROR, " MIC Different in msg 3 of 4-way handshake!!!!!!!!!! \n");
+		return;
+	}
+	else
+		DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in msg 3 of 4-way handshake!!!!!!!!!! \n");
+
+	// 3. Check Replay Counter, it has to be larger than last one. No need to be exact one larger
+	if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1)
+		return;
+
+	// Update new replay counter
+	memcpy(pAd->PortCfg.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+	// 4. Double check ANonce
+	if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))
+		return;
+
+	// 5. Construct Message 4
+	// =====================================
+	// Use Priority Ring & MiniportMMRequest
+	// =====================================
+    pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+	WpaMacHeaderInit(pAd, &Header_802_11, 0, pAd->PortCfg.Bssid);
+
+	// ACK size	is 14 include CRC, and its rate	is based on real time information
+	AckRate = pAd->PortCfg.ExpectedACKRate[pAd->PortCfg.TxRate];
+	AckDuration = RTMPCalcDuration(pAd, AckRate, 14);
+	Header_802_11.Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+	// Zero message 4 body
+	memset(&Packet, 0, sizeof(Packet));
+	Packet.Version = pAd->EAPOLVer;
+	Packet.Type    = EAPOLKey;
+	Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE;		// No data field
+
+	//
+	// Message 4 as  EAPOL-Key(0,1,0,0,0,P,0,0,MIC,0)
+	//
+	Packet.KeyDesc.Type = RSN_KEY_DESC;
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//	*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)) = SWAP16(*(USHORT *)(&(pMsg3->KeyDesc.KeyInfo)));
+#endif
+
+	// Key descriptor version and appropriate RSN IE
+	Packet.KeyDesc.KeyInfo.KeyDescVer = pMsg3->KeyDesc.KeyInfo.KeyDescVer;
+
+	// Update Key Length
+	Packet.KeyDesc.KeyLength[0] = pMsg3->KeyDesc.KeyLength[0];
+	Packet.KeyDesc.KeyLength[1] = pMsg3->KeyDesc.KeyLength[1];
+
+	// Key Type PeerKey
+	Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+	// KeyMic field presented
+	Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+    // In Msg3,  KeyInfo.secure =0 if Group Key HS to come. 1 if no group key HS
+    // Station sends Msg4  KeyInfo.secure should be the same as that in Msg.3
+    Packet.KeyDesc.KeyInfo.Secure= pMsg3->KeyDesc.KeyInfo.Secure;
+
+
+	// Key Replay count
+	memcpy(Packet.KeyDesc.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &Packet.KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&Packet.KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+//    *(USHORT *)&Packet.KeyDesc.KeyInfo = SWAP16(*(USHORT *)&Packet.KeyDesc.KeyInfo);
+#endif
+
+	// Out buffer for transmitting message 4
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+		return;
+
+	// Prepare EAPOL frame for MIC calculation
+	// Be careful, only EAPOL frame is counted for MIC calculation
+	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+	// Prepare and Fill MIC value
+	memset(Mic, 0, sizeof(Mic));
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		// AES
+		UCHAR digest[80];
+
+		HMAC_SHA1(pOutBuffer, FrameLen, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+		memcpy(Mic,	digest,	LEN_KEY_DESC_MIC);
+	}
+	else
+	{
+		hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
+	}
+	memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;
+
+	// Make	 Transmitting frame
+	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+	                  sizeof(HEADER_802_11),&Header_802_11,
+		              sizeof(EAPHEAD),      EAPHEAD,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+
+	// 7. Update PTK
+    pPeerKey = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);  // allocate memory
+    if (pPeerKey == NULL)
+		return;
+
+	memset(pPeerKey, 0, sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY);
+	pPeerKey->Length    = sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY;
+	pPeerKey->KeyIndex  = 0xe0000000;
+	pPeerKey->KeyLength = pMsg3->KeyDesc.KeyLength[0] * 256 + pMsg3->KeyDesc.KeyLength[1];
+
+	COPY_MAC_ADDR(pPeerKey->BSSID, pAd->PortCfg.Bssid);
+	memcpy(&pPeerKey->KeyRSC, pMsg3->KeyDesc.KeyRsc, LEN_KEY_DESC_RSC);
+	memcpy(pPeerKey->KeyMaterial, &pAd->PortCfg.PTK[32], LEN_EAP_KEY);
+	// Call Add peer key function
+	RTMPWPAAddKeyProc(pAd, pPeerKey);
+	if(pPeerKey != NULL){
+		kfree(pPeerKey);
+	}
+	// 6. Send Message 4 to authenticator
+	// Send using priority queue
+	MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg3Action <-----\n");
+}
+
+VOID    Wpa2PairMsg3Action(
+    IN  PRTMP_ADAPTER   pAd,
+    IN  MLME_QUEUE_ELEM *Elem)
+{
+    PHEADER_802_11      pHeader;
+    PUCHAR              pOutBuffer = NULL;
+    HEADER_802_11       Header_802_11;
+    UCHAR               AckRate = RATE_2;
+    USHORT              AckDuration = 0;
+    ULONG               FrameLen = 0;
+    UCHAR               EAPHEAD[8] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,0x88,0x8e};
+    EAPOL_PACKET        Packet;
+    PEAPOL_PACKET       pMsg3;
+    UCHAR               Mic[16], OldMic[16];
+    PNDIS_802_11_KEY    pPeerKey;
+    UCHAR               KEYDATA[512], Key[32];
+    USHORT              NStatus;
+
+    DBGPRINT(RT_DEBUG_TRACE, "Wpa2PairMsg3Action ----->\n");
+
+    pHeader = (PHEADER_802_11) Elem->Msg;
+
+    // Process message 3 frame.
+    pMsg3 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // 1. Verify RSN IE & cipher type match
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled && (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 2))
+    {
+        return;
+    }
+    else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled && (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 1))
+    {
+        return;
+    }
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // 2. Check MIC value
+    // Save the MIC and replace with zero
+    memcpy(OldMic, pMsg3->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+    memset(pMsg3->KeyDesc.KeyMic, 0, LEN_KEY_DESC_MIC);
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+
+        HMAC_SHA1((PUCHAR) pMsg3, pMsg3->Len[1] + 4, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, (PUCHAR) pMsg3, pMsg3->Len[1] + 4, Mic);
+    }
+
+    if (!NdisEqualMemory(OldMic, Mic, LEN_KEY_DESC_MIC))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, " MIC Different in msg 3 of 4-way handshake!!!!!!!!!! \n");
+        return;
+    }
+    else
+        DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in msg 3 of 4-way handshake!!!!!!!!!! \n");
+
+    // 3. Check Replay Counter, it has to be larger than last one. No need to be exact one larger
+    if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1)
+        return;
+
+
+    // Update new replay counter
+    memcpy(pAd->PortCfg.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // 4. Double check ANonce
+    if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))
+        return;
+
+
+    // Obtain GTK
+    // 5. Decrypt GTK from Key Data
+    DBGPRINT_RAW(RT_DEBUG_TRACE, "EKD = %d\n", pMsg3->KeyDesc.KeyInfo.EKD_DL);
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+
+        // Decrypt AES GTK
+        AES_GTK_KEY_UNWRAP(&pAd->PortCfg.PTK[16], KEYDATA, pMsg3->KeyDesc.KeyDataLen[1],pMsg3->KeyDesc.KeyData);
+
+        ParseKeyData(pAd, KEYDATA, pMsg3->KeyDesc.KeyDataLen[1]);
+    }
+    else    // TKIP
+    {
+        INT i;
+        // Decrypt TKIP GTK
+        // Construct 32 bytes RC4 Key
+        memcpy(Key, pMsg3->KeyDesc.KeyIv, 16);
+        memcpy(&Key[16], &pAd->PortCfg.PTK[16], 16);
+        ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key, 32);
+        //discard first 256 bytes
+        for (i = 0; i < 256; i++)
+            ARCFOUR_BYTE(&pAd->PrivateInfo.WEPCONTEXT);
+        // Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
+        ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, KEYDATA, pMsg3->KeyDesc.KeyData, pMsg3->KeyDesc.KeyDataLen[1]);
+
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "KEYDATA = \n");
+        for (i = 0; i < 100; i++)
+        {
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", KEYDATA[i]);
+            if (i%16 == 15)
+                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+        }
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+
+        ParseKeyData(pAd, KEYDATA, pMsg3->KeyDesc.KeyDataLen[1]);
+
+    }
+
+
+    // 6. Construct Message 4
+    // =====================================
+    // Use Priority Ring & MiniportMMRequest
+    // =====================================
+    pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WpaMacHeaderInit(pAd, &Header_802_11, 0, pAd->PortCfg.Bssid);
+
+    // ACK size is 14 include CRC, and its rate is based on real time information
+    AckRate = pAd->PortCfg.ExpectedACKRate[pAd->PortCfg.TxRate];
+    AckDuration = RTMPCalcDuration(pAd, AckRate, 14);
+    Header_802_11.Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+    // Zero message 4 body
+    memset(&Packet, 0, sizeof(Packet));
+    Packet.Version = pAd->EAPOLVer;
+    Packet.Type    = EAPOLKey;
+    Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE;     // No data field
+
+    //
+    // Message 4 as  EAPOL-Key(0,1,0,0,0,P,0,0,MIC,0)
+    //
+    Packet.KeyDesc.Type = RSN_KEY_DESC;
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pMsg3->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pMsg3->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // Key descriptor version and appropriate RSN IE
+    Packet.KeyDesc.KeyInfo.KeyDescVer = pMsg3->KeyDesc.KeyInfo.KeyDescVer;
+
+    // Update Key Length
+	Packet.KeyDesc.KeyLength[0] = pMsg3->KeyDesc.KeyLength[0];
+	Packet.KeyDesc.KeyLength[1] = pMsg3->KeyDesc.KeyLength[1];
+
+    // Key Type PeerKey
+    Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+    // KeyMic field presented
+    Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+    Packet.KeyDesc.KeyInfo.Secure = 1;
+
+    // Key Replay count
+    memcpy(Packet.KeyDesc.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &Packet.KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&Packet.KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // Out buffer for transmitting message 4
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;
+
+    // Prepare EAPOL frame for MIC calculation
+    // Be careful, only EAPOL frame is counted for MIC calculation
+    MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+                      Packet.Len[1] + 4,    &Packet,
+                      END_OF_ARGS);
+
+    // Prepare and Fill MIC value
+    memset(Mic, 0, sizeof(Mic));
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+
+        HMAC_SHA1(pOutBuffer, FrameLen, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
+    }
+    memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;
+
+    // Make  Transmitting frame
+    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
+                      sizeof(HEADER_802_11),    &Header_802_11,
+                      sizeof(EAPHEAD),          EAPHEAD,
+                      Packet.Len[1] + 4,        &Packet,
+                      END_OF_ARGS);
+
+
+    // 7. Update PTK
+    pPeerKey = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);  // allocate memory
+    if (pPeerKey == NULL)
+		return;
+
+    memset(pPeerKey, 0, sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY);
+    pPeerKey->Length    = sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY;
+    pPeerKey->KeyIndex  = 0xe0000000;
+    pPeerKey->KeyLength = pMsg3->KeyDesc.KeyLength[0] * 256 + pMsg3->KeyDesc.KeyLength[1];
+
+    COPY_MAC_ADDR(pPeerKey->BSSID, pAd->PortCfg.Bssid);
+    memcpy(&pPeerKey->KeyRSC, pMsg3->KeyDesc.KeyRsc, LEN_KEY_DESC_RSC);
+    memcpy(pPeerKey->KeyMaterial, &pAd->PortCfg.PTK[32], 32);
+    // Call Add peer key function
+    RTMPWPAAddKeyProc(pAd, pPeerKey);
+    if(pPeerKey != NULL){
+	    kfree(pPeerKey);
+    }
+
+    // 6. Send Message 4 to authenticator
+    // Send using priority queue
+    MiniportMMRequest(pAd, pOutBuffer, FrameLen);
+
+
+    DBGPRINT(RT_DEBUG_ERROR, "Wpa2PairMsg3Action <-----\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Process Group key 2-way handshaking
+
+	Arguments:
+		pAd	Pointer	to our adapter
+		Elem		Message body
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	WpaGroupMsg1Action(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	MLME_QUEUE_ELEM	*Elem)
+{
+	PUCHAR				pOutBuffer = NULL;
+	ULONG				FrameLen = 0;
+	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00,0x88,0x8e};
+	EAPOL_PACKET		Packet;
+	PEAPOL_PACKET		pGroup;
+	UCHAR				Mic[16], OldMic[16];
+	UCHAR				GTK[32], Key[32];
+	PNDIS_802_11_KEY	pGroupKey = NULL;
+//    UCHAR               MSG[MAX_LEN_OF_MLME_BUFFER];
+	UCHAR				*mpool, *MSG, *KEYDATA;
+    UCHAR               Header802_3[14];
+//    UCHAR               KEYDATA[512];
+    USHORT              NStatus;
+
+
+	mpool = kmalloc(2*MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);  // allocate memory
+    if (mpool == NULL)
+        return;
+
+	MSG = (UCHAR *) (((unsigned long)(mpool+3)) & ((unsigned long)~(0x03)));
+	KEYDATA =(UCHAR *) (((unsigned long)(MSG+MAX_LEN_OF_MLME_BUFFER+3)) & ((unsigned long)~(0x03)));
+
+
+    if(NdisEqualMemory(&Elem->Msg[LENGTH_802_11 + 8], EAPHEAD, LENGTH_802_1_H))
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "WpaGroupMsg1Action ----->MsgLen=%d\n",Elem->MsgLen);
+        memcpy(MSG, Elem->Msg, LENGTH_802_11);
+        memcpy(&MSG[LENGTH_802_11], &Elem->Msg[LENGTH_802_11+8], (Elem->MsgLen ));
+    }
+    else
+    {
+	    DBGPRINT(RT_DEBUG_TRACE, "WpaGroupMsg1Action ----->\n");
+        memcpy(MSG, Elem->Msg, Elem->MsgLen);
+    }
+
+	// Process Group message 1 frame.
+	pGroup = (PEAPOL_PACKET) &MSG[LENGTH_802_11 + LENGTH_802_1_H];
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pGroup->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pGroup->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // 0. Verify RSN IE & cipher type match
+    if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled && (pGroup->KeyDesc.KeyInfo.KeyDescVer != 2))
+    {
+	    if(mpool != NULL){
+		    kfree(mpool);
+	    }
+        return;
+    }
+    else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled && (pGroup->KeyDesc.KeyInfo.KeyDescVer != 1))
+    {
+	    if(mpool != NULL){
+		    kfree(mpool);
+	    }
+        return;
+    }
+
+	// 1. Verify Replay counter
+	//    Check Replay Counter, it has to be larger than last one. No need to be exact one larger
+	if (RTMPCompareMemory(pGroup->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1)
+	{
+		if(mpool != NULL){
+			kfree(mpool);
+		}
+		return;
+	}
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pGroup->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pGroup->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+	// Update new replay counter
+	memcpy(pAd->PortCfg.ReplayCounter, pGroup->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+	// 2. Verify MIC is valid
+	// Save the MIC and replace with zero
+	memcpy(OldMic, pGroup->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+	memset(pGroup->KeyDesc.KeyMic, 0, LEN_KEY_DESC_MIC);
+
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		// AES
+		UCHAR digest[80];
+
+		HMAC_SHA1((PUCHAR) pGroup, pGroup->Len[1] + 4, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+		memcpy(Mic,	digest,	LEN_KEY_DESC_MIC);
+	}
+	else
+	{
+		hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, (PUCHAR) pGroup, pGroup->Len[1] + 4, Mic);
+	}
+
+	if (!NdisEqualMemory(OldMic, Mic, LEN_KEY_DESC_MIC))
+	{
+		DBGPRINT(RT_DEBUG_ERROR, " MIC Different in group msg 1 of 2-way handshake!!!!!!!!!! \n");
+		if(mpool != NULL){
+			kfree(mpool);
+		}
+		return;
+	}
+	else
+		DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in group msg 1 of 2-way handshake!!!!!!!!!! \n");
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &pGroup->KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&pGroup->KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+    // 3. Decrypt GTK from Key Data
+    DBGPRINT(RT_DEBUG_TRACE, " Install = %d!!!!EKD_DL = %d!!!!!KeyIndex = %d! \n", pGroup->KeyDesc.KeyInfo.Install, pGroup->KeyDesc.KeyInfo.EKD_DL,
+        pGroup->KeyDesc.KeyInfo.KeyIndex);
+
+
+    pGroupKey = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);  // allocate memory
+    if (pGroupKey == NULL)
+    {
+
+	    if(mpool != NULL){
+		    kfree(mpool);
+	    }
+	    return;
+    }
+
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		INT i;
+        // Decrypt AES GTK
+        memcpy(KEYDATA, pGroup->KeyDesc.KeyData, 32);
+
+        //if (pGroup->KeyDesc.KeyInfo.EKD_DL == 1)
+            AES_GTK_KEY_UNWRAP(&pAd->PortCfg.PTK[16], KEYDATA,  pGroup->KeyDesc.KeyDataLen[1], pGroup->KeyDesc.KeyData);
+
+		// Update GTK
+        memset(pGroupKey, 0, sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY);
+	    pGroupKey->Length    = sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY;
+	    pGroupKey->KeyIndex  = 0x20000000 | pGroup->KeyDesc.KeyInfo.KeyIndex;
+	    pGroupKey->KeyLength = pGroup->KeyDesc.KeyLength[0] * 256 + pGroup->KeyDesc.KeyLength[1];
+
+	    COPY_MAC_ADDR(pGroupKey->BSSID, pAd->PortCfg.Bssid);
+	    memcpy(pGroupKey->KeyMaterial, KEYDATA, 32);
+	    memcpy(GTK, KEYDATA, 32);
+
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "GTK = \n");
+        for (i = 0; i < 32; i++)
+        {
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x ", pGroup->KeyDesc.KeyData[i]);
+            if (i%16 == 15)
+                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+        }
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+
+
+        // Call Add peer key function
+        RTMPWPAAddKeyProc(pAd, pGroupKey);
+	}
+	else	// TKIP
+	{
+		INT	i;
+
+		// Decrypt TKIP GTK
+		// Construct 32 bytes RC4 Key
+		memcpy(Key, pGroup->KeyDesc.KeyIv, 16);
+		memcpy(&Key[16], &pAd->PortCfg.PTK[16], 16);
+		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key, 32);
+        //discard first 256 bytes
+		for (i = 0; i < 256; i++)
+            ARCFOUR_BYTE(&pAd->PrivateInfo.WEPCONTEXT);
+		// Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
+        ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, GTK, pGroup->KeyDesc.KeyData, 32);
+
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "GTK = \n");
+        for (i = 0; i < 32; i++)
+        {
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", GTK[i]);
+            if (i%16 == 15)
+                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+        }
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+
+        //RTMPWPAAddKeyProc(pAd, pGroupKey);
+        //ParseKeyData(pAd, KEYDATA, pGroup->KeyDesc.KeyDataLen[1]);
+
+	}
+
+	// 4. Construct Group Message 2
+    pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WPAMake8023Hdr(pAd, pAd->PortCfg.Bssid, Header802_3);
+
+	// Zero Group message 1 body
+	memset(&Packet, 0, sizeof(Packet));
+	Packet.Version = pAd->EAPOLVer;
+	Packet.Type    = EAPOLKey;
+	Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE;		// No data field
+
+	//
+	// Group Message 2 as  EAPOL-Key(1,0,0,0,G,0,0,MIC,0)
+	//
+	Packet.KeyDesc.Type = RSN_KEY_DESC;
+
+	// Key descriptor version and appropriate RSN IE
+	Packet.KeyDesc.KeyInfo.KeyDescVer = pGroup->KeyDesc.KeyInfo.KeyDescVer;
+
+	// Update Key Length and Key Index
+	Packet.KeyDesc.KeyInfo.KeyIndex = pGroup->KeyDesc.KeyInfo.KeyIndex;
+	Packet.KeyDesc.KeyLength[0] = pGroup->KeyDesc.KeyLength[0];
+	Packet.KeyDesc.KeyLength[1] = pGroup->KeyDesc.KeyLength[1];
+
+	// Key Type Group key
+	Packet.KeyDesc.KeyInfo.KeyType = 0;
+
+	// KeyMic field presented
+	Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+	// Secure bit
+    if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+	    Packet.KeyDesc.KeyInfo.Secure  = 1;
+
+	// Key Replay count
+	memcpy(Packet.KeyDesc.ReplayCounter, pGroup->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+#ifdef BIG_ENDIAN
+   // recovery original byte order, before forward Elem to another routine
+{
+    USHORT	tmpKeyinfo;
+
+    memcpy(&tmpKeyinfo, &Packet.KeyDesc.KeyInfo, sizeof(USHORT));
+    tmpKeyinfo = SWAP16(tmpKeyinfo);
+    memcpy(&Packet.KeyDesc.KeyInfo, &tmpKeyinfo, sizeof(USHORT));
+}
+#endif
+
+	// Out buffer for transmitting group message 2
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+    {
+	    if(mpool != NULL){
+		    kfree(mpool);
+	    }
+		return;
+    }
+
+	// Prepare EAPOL frame for MIC calculation
+	// Be careful, only EAPOL frame is counted for MIC calculation
+	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+	// Prepare and Fill MIC value
+	memset(Mic, 0, sizeof(Mic));
+	if (pAd->PortCfg.WepStatus	== Ndis802_11Encryption3Enabled)
+	{
+		// AES
+		UCHAR digest[80];
+
+		HMAC_SHA1(pOutBuffer, FrameLen, pAd->PortCfg.PTK, LEN_EAP_MICK, digest);
+		memcpy(Mic,	digest,	LEN_KEY_DESC_MIC);
+	}
+	else
+	{
+		INT i;
+
+		DBGPRINT_RAW(RT_DEBUG_INFO, "PTK = ");
+		for (i = 0; i < 64; i++)
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PTK[i]);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n FrameLen = %d\n", FrameLen);
+
+		hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
+	}
+	memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+
+    FrameLen = 0;
+    MakeOutgoingFrame(pOutBuffer,   &FrameLen,
+                      LENGTH_802_3, &Header802_3,
+//                    sizeof(EAPHEAD), EAPHEAD,
+		              Packet.Len[1] + 4,    &Packet,
+		              END_OF_ARGS);
+
+	// 5. Copy frame to Tx ring and prepare for encryption
+    RTMPToWirelessSta(pAd, pOutBuffer, FrameLen);
+
+    // Free allocated memory
+    MlmeFreeMemory(pAd, pOutBuffer);
+
+	// 6. Update GTK
+	memset(pGroupKey, 0, sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY);
+	pGroupKey->Length    = sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY;
+	pGroupKey->KeyIndex  = 0x20000000 | pGroup->KeyDesc.KeyInfo.KeyIndex;
+	pGroupKey->KeyLength = pGroup->KeyDesc.KeyLength[0] * 256 + pGroup->KeyDesc.KeyLength[1];
+
+	COPY_MAC_ADDR(pGroupKey->BSSID, pAd->PortCfg.Bssid);
+	memcpy(pGroupKey->KeyMaterial, GTK, LEN_EAP_KEY);
+	// Call Add peer key function
+	RTMPWPAAddKeyProc(pAd, pGroupKey);
+
+	if(pGroupKey != NULL){
+		kfree(pGroupKey);
+	}
+	if(mpool != NULL){
+		kfree(mpool);
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "WpaGroupMsg1Action <-----\n");
+}
+/*
+	========================================================================
+
+	Routine Description:
+		Init WPA MAC header
+
+	Arguments:
+		pAd	Pointer	to our adapter
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	WpaMacHeaderInit(
+	IN		PRTMP_ADAPTER	pAd,
+	IN OUT	PHEADER_802_11	pHdr80211,
+	IN		UCHAR			wep,
+	IN		PUCHAR		    pAddr1)
+{
+	memset(pHdr80211, 0, sizeof(HEADER_802_11));
+	pHdr80211->FC.Type	= BTYPE_DATA;
+	pHdr80211->FC.ToDs	= 1;
+	if (wep	== 1)
+		pHdr80211->FC.Wep = 1;
+
+	 //	Addr1: DA, Addr2: BSSID, Addr3:	SA
+	COPY_MAC_ADDR(pHdr80211->Addr1, pAddr1);
+	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
+	COPY_MAC_ADDR(pHdr80211->Addr3, pAd->PortCfg.Bssid);
+	pHdr80211->Sequence =	pAd->Sequence;
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		SHA1 function
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+
+	========================================================================
+*/
+VOID	HMAC_SHA1(
+	IN	UCHAR	*text,
+	IN	UINT	text_len,
+	IN	UCHAR	*key,
+	IN	UINT	key_len,
+	IN	UCHAR	*digest)
+{
+	SHA_CTX	context;
+	UCHAR	k_ipad[65]; /* inner padding - key XORd with ipad	*/
+	UCHAR	k_opad[65]; /* outer padding - key XORd with opad	*/
+	INT		i;
+
+	// if key is longer	than 64	bytes reset	it to key=SHA1(key)
+	if (key_len	> 64)
+	{
+		SHA_CTX		 tctx;
+		SHAInit(&tctx);
+		SHAUpdate(&tctx, key, key_len);
+		SHAFinal(&tctx,	key);
+		key_len	= 20;
+	}
+	memset(k_ipad, 0, sizeof(k_ipad));
+	memset(k_opad, 0, sizeof(k_opad));
+	memcpy(k_ipad, key,	key_len);
+	memcpy(k_opad, key,	key_len);
+
+	// XOR key with	ipad and opad values
+	for	(i = 0;	i <	64;	i++)
+	{
+		k_ipad[i] ^= 0x36;
+		k_opad[i] ^= 0x5c;
+	}
+
+	// perform inner SHA1
+	SHAInit(&context); 						/* init context for 1st pass */
+	SHAUpdate(&context,	k_ipad,	64);		/*	start with inner pad */
+	SHAUpdate(&context,	text, text_len);	/*	then text of datagram */
+	SHAFinal(&context, digest);				/* finish up 1st pass */
+
+	//perform outer	SHA1
+	SHAInit(&context);					/* init context for 2nd pass */
+	SHAUpdate(&context,	k_opad,	64);	/*	start with outer pad */
+	SHAUpdate(&context,	digest,	20);	/*	then results of	1st	hash */
+	SHAFinal(&context, digest);			/* finish up 2nd pass */
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+    Parse KEYDATA field.  KEYDATA[] May contain 2 RSN IE and optionally GTK.
+    GTK  is encaptulated in KDE format at  p.83 802.11i D10
+
+    Arguments:
+
+    Return Value:
+
+    Note:
+        802.11i D10
+
+    ========================================================================
+*/
+VOID ParseKeyData(
+    IN  PRTMP_ADAPTER   pAd,
+    IN  PUCHAR          pKeyData,
+    IN  UCHAR           KeyDataLen)
+{
+    PKDE_ENCAP          pKDE = NULL;
+    PNDIS_802_11_KEY    pGroupKey = NULL;
+    PUCHAR              pMyKeyData = pKeyData;
+    UCHAR               KeyDataLength = KeyDataLen;
+    UCHAR               GTKLEN;
+    INT                 i;
+
+    if (!NdisEqualMemory(pKeyData, pAd->PortCfg.RSN_IE, pAd->PortCfg.RSN_IELen))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, " RSN IE mismatched !!!!!!!!!! \n");
+    }
+    else
+        DBGPRINT(RT_DEBUG_TRACE, " RSN IE matched !!!!!!!!!! \n");
+
+    DBGPRINT(RT_DEBUG_ERROR, "KeyDataLen = %d  \n", KeyDataLen);
+
+/*
+====================================================================
+======================================================================
+*/
+    if ((*pKeyData == WPARSNIE) && (*(pKeyData+1) != 0) && (KeyDataLength >= (2 + *(pKeyData+1))))
+    {
+        pMyKeyData = pKeyData + *(pKeyData+1) + 2;
+        KeyDataLength -= (2 + *(pKeyData+1));
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA RSN IE length %d contained in Msg3 = \n", (2 + *(pKeyData+1)));
+    }
+    if ((*pMyKeyData == WPA2RSNIE) && (*(pMyKeyData+1) != 0) && (KeyDataLength >= (2 + *(pMyKeyData+1))))
+    {
+        pMyKeyData += (*(pMyKeyData+1) + 2);
+        KeyDataLength -= (2 + *(pMyKeyData+1));
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA2 RSN IE length %d contained in Msg3 = \n", (2 + *(pMyKeyData+1)));
+    }
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"KeyDataLength %d   \n", KeyDataLength);
+    pKDE = (PKDE_ENCAP) pMyKeyData;//Modified by Thomas:for WPA2 crashed  error.
+
+    if ((KeyDataLength >= 8) && (KeyDataLength <= sizeof(KDE_ENCAP)))
+    {
+	//pKDE = (PKDE_ENCAP) pMyKeyData;
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE = \n");
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->Type %x:", pKDE->Type);
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->Len 0x%x:", pKDE->Len);
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->OUI %x %x %x :", pKDE->OUI[0],pKDE->OUI[1],pKDE->OUI[2] );
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");
+    }
+
+    if (pKDE->GTKEncap.Kid == 0)
+    {
+        DBGPRINT_RAW(RT_DEBUG_ERROR,"GTK Key index zero , error\n");
+        return;
+    }
+
+        GTKLEN = pKDE->Len -6;
+
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"GTK Key[%d] len=%d ", pKDE->GTKEncap.Kid, GTKLEN);
+        for (i = 0; i < GTKLEN; i++)
+        {
+            DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pKDE->GTKEncap.GTK[i]);
+        }
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");
+
+        // Update GTK
+        pGroupKey = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);  // allocate memory
+        if (pGroupKey == NULL)
+		    return;
+
+        memset(pGroupKey, 0, sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY);
+	    pGroupKey->Length    = sizeof(NDIS_802_11_KEY) + LEN_EAP_KEY;
+	    pGroupKey->KeyIndex  = 0x20000000 | pKDE->GTKEncap.Kid;
+	    pGroupKey->KeyLength = GTKLEN;
+
+	    COPY_MAC_ADDR(pGroupKey->BSSID, pAd->PortCfg.Bssid);
+	    memcpy(pGroupKey->KeyMaterial, pKDE->GTKEncap.GTK, 32);
+
+        // Call Add peer key function
+        RTMPWPAAddKeyProc(pAd, pGroupKey);
+
+	if(pGroupKey != NULL){
+		kfree(pGroupKey);
+	}
+
+}
+
+VOID WPAMake8023Hdr(
+    IN PRTMP_ADAPTER    pAd,
+    IN PCHAR            pDAddr,
+    IN OUT PCHAR        pHdr)
+{
+     // Addr1: DA, Addr2: BSSID, Addr3: SA
+    memcpy(pHdr, pDAddr, MAC_ADDR_LEN);
+    memcpy(&pHdr[MAC_ADDR_LEN], pAd->CurrentAddress, MAC_ADDR_LEN);
+    pHdr[2*MAC_ADDR_LEN] = 0x88;
+    pHdr[2*MAC_ADDR_LEN+1] = 0x8e;
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		PRF function
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+		802.1i	Annex F.9
+
+	========================================================================
+*/
+VOID	PRF(
+	IN	UCHAR	*key,
+	IN	INT		key_len,
+	IN	UCHAR	*prefix,
+	IN	INT		prefix_len,
+	IN	UCHAR	*data,
+	IN	INT		data_len,
+	OUT	UCHAR	*output,
+	IN	INT		len)
+{
+	INT		i;
+	UCHAR	input[1024];
+	INT		currentindex = 0;
+
+	INT		total_len;
+
+	memcpy(input, prefix, prefix_len);
+	input[prefix_len] =	0;
+	memcpy(&input[prefix_len + 1], data, data_len);
+	total_len =	prefix_len + 1 + data_len;
+	input[total_len] = 0;
+	total_len++;
+	for	(i = 0;	i <	(len + 19) / 20; i++)
+	{
+		HMAC_SHA1(input, total_len,	key, key_len, &output[currentindex]);
+		currentindex +=	20;
+		input[total_len - 1]++;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Count TPTK from PMK
+
+	Arguments:
+
+	Return Value:
+		Output		Store the TPTK
+
+	Note:
+
+	========================================================================
+*/
+VOID    WpaCountPTK(
+	IN	UCHAR	*PMK,
+	IN	UCHAR	*ANonce,
+	IN	UCHAR	*AA,
+	IN	UCHAR	*SNonce,
+	IN	UCHAR	*SA,
+	OUT	UCHAR	*output,
+	IN	UINT	len)
+{
+	UCHAR	concatenation[76];
+	UINT	CurrPos = 0;
+	UCHAR	temp[32];
+	UCHAR	Prefix[] = {'P', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 'k', 'e', 'y', ' ',
+						'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'};
+
+	memset(temp, 0, sizeof(temp));
+
+    // Get smaller address
+    if (RTMPCompareMemory(SA, AA, 6) == 1)
+	    memcpy(concatenation, AA, 6);
+    else
+        memcpy(concatenation, SA, 6);
+    CurrPos += 6;
+
+    // Get larger address
+    if (RTMPCompareMemory(SA, AA, 6) == 1)
+	    memcpy(&concatenation[CurrPos], SA, 6);
+    else
+	    memcpy(&concatenation[CurrPos], AA, 6);
+    CurrPos += 6;
+
+    // Get smaller address
+    if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
+	    memcpy(&concatenation[CurrPos], SNonce, 32);
+    else
+	    memcpy(&concatenation[CurrPos], ANonce, 32);
+    CurrPos += 32;
+
+    // Get larger address
+    if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
+	    memcpy(&concatenation[CurrPos], ANonce, 32);
+    else
+	    memcpy(&concatenation[CurrPos], SNonce, 32);
+    CurrPos += 32;
+
+    PRF(PMK, LEN_MASTER_KEY, Prefix, 22, concatenation, 76, output, len);
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Misc function to Generate random number
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+		802.1i  Annex F.9
+
+	========================================================================
+*/
+VOID	GenRandom(
+	IN	PRTMP_ADAPTER	pAd,
+	OUT	UCHAR			*random)
+{
+	INT		i, curr;
+	UCHAR	local[80], KeyCounter[32];
+	UCHAR	result[80];
+	unsigned long CurrentTime;
+	UCHAR	prefix[] = {'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r'};
+
+	memset(result, 0, 80);
+	memset(local, 0, 80);
+	memset(KeyCounter, 0, 32);
+	COPY_MAC_ADDR(local, pAd->CurrentAddress);
+
+	for	(i = 0;	i <	32;	i++)
+	{
+		curr =	MAC_ADDR_LEN;
+		CurrentTime = jiffies;
+		COPY_MAC_ADDR(local,  pAd->CurrentAddress);
+		curr +=	MAC_ADDR_LEN;
+		memcpy(&local[curr],  &CurrentTime,	sizeof(CurrentTime));
+		curr +=	sizeof(CurrentTime);
+		memcpy(&local[curr],  result, 32);
+		curr +=	32;
+		memcpy(&local[curr],  &i,  2);
+		curr +=	2;
+		PRF(KeyCounter, 32, prefix,12, local,	curr, result, 32);
+	}
+	memcpy(random, result,	32);
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Misc function to decrypt AES body
+
+    Arguments:
+
+    Return Value:
+
+    Note:
+        This function references to RFC 3394 for aes key unwrap algorithm.
+
+    ========================================================================
+*/
+VOID    AES_GTK_KEY_UNWRAP(
+    IN  UCHAR   *key,
+    OUT UCHAR   *plaintext,
+    IN UCHAR    c_len,
+    IN  UCHAR   *ciphertext)
+{
+    UCHAR       A[8],   BIN[16], BOUT[16];
+    UCHAR       xor;
+    INT         i, j;
+    aes_context aesctx;
+    UCHAR       R[512];
+    INT         num_blocks = c_len/8;   // unit:64bits
+
+    // Initialize
+    memcpy(A, ciphertext, 8);
+    //Input plaintext
+    for (i = 0; i < (c_len-8); i++)
+    {
+        R[ i] = ciphertext[i + 8];
+    }
+
+    aes_set_key(&aesctx, key, 128);
+
+    for (j = 5; j >= 0; j--)
+    {
+        for(i = (num_blocks-1); i > 0; i--)
+        {
+            xor = (num_blocks -1 )* j + i;
+            memcpy(BIN, A, 8);
+            BIN[7] = A[7] ^ xor;
+            memcpy(&BIN[8], &R[(i-1)*8], 8);
+            aes_decrypt(&aesctx, BIN, BOUT);
+            memcpy(A, &BOUT[0], 8);
+            memcpy(&R[(i-1)*8], &BOUT[8], 8);
+        }
+    }
+
+    // OUTPUT
+    for (i = 0; i < c_len; i++)
+    {
+        plaintext[i] = R[i];
+    }
+
+    DBGPRINT_RAW(RT_DEBUG_TRACE, "plaintext = \n");
+    for (i = 0; i < (num_blocks *8); i++)
+    {
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", plaintext[i]);
+        if (i%16 == 15)
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+    }
+    DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+
+
+}
+
+/*
+    ========================================================================
+    Routine Description:
+       Send all EAP frames to wireless station.
+       These frames don't come from normal SendPackets routine, but are EAPPacket, EAPOL,
+
+    Arguments:
+        pRxD        Pointer to the Rx descriptor
+
+    Return Value:
+    None
+    ========================================================================
+*/
+VOID RTMPToWirelessSta(
+    IN  PRTMP_ADAPTER   pAd,
+    IN  PUCHAR          pFrame,
+    IN  UINT            FrameLen)
+{
+    struct sk_buff  *skb;
+    NDIS_STATUS     Status;
+
+    do {
+    	// 1. build a NDIS packet and call RTMPSendPacket();
+     	//    be careful about how/when to release this internal allocated NDIS PACKET buffer
+#ifdef RTMP_EMBEDDED
+   		if ((skb = __dev_alloc_skb(FrameLen + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
+#else
+    	if ((skb = dev_alloc_skb(FrameLen + 2)) != NULL)
+#endif
+        {
+            skb->len = FrameLen;
+            skb->data_len = FrameLen;
+            memcpy((skb->data), pFrame, FrameLen);
+        }
+        else
+        {
+            break;
+        }
+
+
+        // 2. send out the packet
+        Status = RTMPSendPacket(pAd, skb);
+        if (Status == NDIS_STATUS_SUCCESS)
+        {
+            // Dequeue one frame from TxSwQueue0..3 queue and process it
+            // There are three place calling dequeue for TX ring.
+            // 1. Here, right after queueing the frame.
+            // 2. At the end of TxRingTxDone service routine.
+            // 3. Upon NDIS call RTMPSendPackets
+            if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) &&
+                (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)))
+            {
+                RTMPDeQueuePacket(pAd, QID_AC_BE);
+            }
+        }
+        else // free this packet space
+        {
+            RTUSBFreeSkbBuffer(skb);
+        }
+
+        RTUSBKickBulkOut(pAd);
+
+	} while (FALSE);
+
+}
+
+//#if WPA_SUPPLICANT_SUPPORT
+
+// If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)).
+INT	RTMPCheckWPAframeForEapCode(
+	IN PRTMP_ADAPTER   		pAd,
+	IN PUCHAR				pFrame,
+	IN ULONG				FrameLen,
+	IN ULONG				OffSet)
+{
+
+	PUCHAR	pData;
+	INT	result = 0;
+
+	if( FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H )
+		return result;
+
+	pData = pFrame + OffSet; // skip offset bytes
+
+	if(*(pData+1) == EAPPacket) 	// 802.1x header - Packet Type
+	{
+		 result = *(pData+4);		// EAP header - Code
+	}
+
+	return result;
+}
+
+//#endif
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/net/wireless/rt73/wpa.h linux-2.6.23.1-stm/drivers/net/wireless/rt73/wpa.h
--- linux-2.6.23.1/drivers/net/wireless/rt73/wpa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/net/wireless/rt73/wpa.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,213 @@
+/***************************************************************************
+ * RT2x00 SourceForge Project - http://rt2x00.serialmonkey.com             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Licensed under the GNU GPL                                            *
+ *   Original code supplied under license from RaLink Inc, 2004.           *
+ ***************************************************************************/
+
+/***************************************************************************
+ *	Module Name:	wpa.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *
+ ***************************************************************************/
+
+#ifndef __WPA_H__
+#define __WPA_H__
+
+// WpaPsk EAPOL Key descripter frame format related length
+#define LEN_KEY_DESC_NONCE          32
+#define LEN_KEY_DESC_IV             16
+#define LEN_KEY_DESC_RSC            8
+#define LEN_KEY_DESC_ID             8
+#define LEN_KEY_DESC_REPLAY         8
+#define LEN_KEY_DESC_MIC            16
+
+//EPA VERSION
+#define EAPOL_VER                   1
+#define DESC_TYPE_TKIP              1
+#define DESC_TYPE_AES               2
+#define RSN_KEY_DESC                0xfe
+#define WPA1_KEY_DESC		        0xFE
+#define WPA2_KEY_DESC		        0x2
+
+#define LEN_MASTER_KEY              32
+
+// EAPOL EK, MK
+#define LEN_EAP_EK                  16
+#define LEN_EAP_MICK                16
+#define LEN_EAP_KEY                 ((LEN_EAP_EK)+(LEN_EAP_MICK))
+// TKIP key related
+#define LEN_TKIP_EK                 16
+#define LEN_TKIP_RXMICK             8
+#define LEN_TKIP_TXMICK             8
+#define LEN_AES_EK                  16
+#define LEN_AES_KEY                 LEN_AES_EK
+#define LEN_TKIP_KEY                ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+#define TKIP_AP_TXMICK_OFFSET       ((LEN_EAP_KEY)+(LEN_TKIP_EK))
+#define TKIP_AP_RXMICK_OFFSET       (TKIP_AP_TXMICK_OFFSET+LEN_TKIP_TXMICK)
+#define TKIP_GTK_LENGTH             ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+#define LEN_PTK                     ((LEN_EAP_KEY)+(LEN_TKIP_KEY))
+//#define MAX_LEN_OF_RSNIE            48
+
+//EAP Packet Type
+#define EAPPacket       0
+#define EAPOLStart      1
+#define EAPOLLogoff     2
+#define EAPOLKey        3
+#define EAPOLASFAlert   4
+#define EAPTtypeMax     5
+
+#define EAPOL_MSG_INVALID   0
+#define EAPOL_PAIR_MSG_1    1
+#define EAPOL_PAIR_MSG_3    2
+#define EAPOL_GROUP_MSG_1   3
+
+//#if WPA_SUPPLICANT_SUPPORT
+
+/* RFC 3748 - Extensible Authentication Protocol (EAP) */
+
+struct eap_hdr {
+	u8 code;
+	u8 identifier;
+	u16 length; /* including code and identifier; network byte order */
+	/* followed by length-4 octets of data */
+} __attribute__ ((packed));
+
+enum { EAP_CODE_REQUEST = 1, EAP_CODE_RESPONSE = 2, EAP_CODE_SUCCESS = 3,
+       EAP_CODE_FAILURE = 4 };
+
+#define	LENGTH_EAP_H				4
+
+/* EAP Request and Response data begins with one octet Type. Success and
+ * Failure do not have additional data. */
+
+typedef enum {
+	EAP_TYPE_NONE = 0,
+	EAP_TYPE_IDENTITY = 1 /* RFC 3748 */,
+	EAP_TYPE_NOTIFICATION = 2 /* RFC 3748 */,
+	EAP_TYPE_NAK = 3 /* Response only, RFC 3748 */,
+	EAP_TYPE_MD5 = 4, /* RFC 3748 */
+	EAP_TYPE_OTP = 5 /* RFC 3748 */,
+	EAP_TYPE_GTC = 6, /* RFC 3748 */
+	EAP_TYPE_TLS = 13 /* RFC 2716 */,
+	EAP_TYPE_LEAP = 17 /* Cisco proprietary */,
+	EAP_TYPE_SIM = 18 /* draft-haverinen-pppext-eap-sim-12.txt */,
+	EAP_TYPE_TTLS = 21 /* draft-ietf-pppext-eap-ttls-02.txt */,
+	EAP_TYPE_AKA = 23 /* draft-arkko-pppext-eap-aka-12.txt */,
+	EAP_TYPE_PEAP = 25 /* draft-josefsson-pppext-eap-tls-eap-06.txt */,
+	EAP_TYPE_MSCHAPV2 = 26 /* draft-kamath-pppext-eap-mschapv2-00.txt */,
+	EAP_TYPE_TLV = 33 /* draft-josefsson-pppext-eap-tls-eap-07.txt */,
+	EAP_TYPE_FAST = 43 /* draft-cam-winget-eap-fast-00.txt */,
+	EAP_TYPE_PAX = 46, /* draft-clancy-eap-pax-04.txt */
+	EAP_TYPE_EXPANDED_NAK = 254 /* RFC 3748 */,
+	EAP_TYPE_PSK = 255 /* EXPERIMENTAL - type not yet allocated
+			    * draft-bersani-eap-psk-09 */
+} EapType;
+//#endif
+
+// EAPOL Key Information definition within Key descriptor format
+typedef struct PACKED _KEY_INFO
+{
+#ifdef BIG_ENDIAN
+    UCHAR	KeyAck:1;
+    UCHAR	Install:1;
+    UCHAR	KeyIndex:2;
+    UCHAR	KeyType:1;
+    UCHAR	KeyDescVer:3;
+    UCHAR	Rsvd:3;
+    UCHAR	EKD_DL:1;       // EKD for AP; DL for STA
+    UCHAR	Request:1;
+    UCHAR	Error:1;
+    UCHAR	Secure:1;
+    UCHAR	KeyMic:1;
+#else
+    UCHAR   KeyMic:1;
+    UCHAR   Secure:1;
+    UCHAR   Error:1;
+    UCHAR   Request:1;
+    UCHAR   EKD_DL:1;       // EKD for AP; DL for STA
+    UCHAR   Rsvd:3;
+    UCHAR   KeyDescVer:3;
+    UCHAR   KeyType:1;
+    UCHAR   KeyIndex:2;
+    UCHAR   Install:1;
+    UCHAR   KeyAck:1;
+#endif
+}   KEY_INFO, *PKEY_INFO;
+
+// EAPOL Key descriptor format
+typedef struct PACKED _KEY_DESCRIPTER
+{
+    UCHAR       Type;
+    KEY_INFO    KeyInfo;
+    UCHAR       KeyLength[2];
+    UCHAR       ReplayCounter[LEN_KEY_DESC_REPLAY];
+    UCHAR       KeyNonce[LEN_KEY_DESC_NONCE];
+    UCHAR       KeyIv[LEN_KEY_DESC_IV];
+    UCHAR       KeyRsc[LEN_KEY_DESC_RSC];
+    UCHAR       KeyId[LEN_KEY_DESC_ID];
+    UCHAR       KeyMic[LEN_KEY_DESC_MIC];
+    UCHAR       KeyDataLen[2];
+    UCHAR       KeyData[MAX_LEN_OF_RSNIE];
+}   KEY_DESCRIPTER, *PKEY_DESCRIPTER;
+
+typedef struct PACKED _EAPOL_PACKET
+{
+    UCHAR               Version;
+    UCHAR               Type;
+    UCHAR               Len[2];
+    KEY_DESCRIPTER      KeyDesc;
+}   EAPOL_PACKET, *PEAPOL_PACKET;
+
+//802.11i D10 page 83
+typedef struct  _GTK_ENCAP
+{
+    UCHAR               Kid:2;
+    UCHAR               tx:1;
+    UCHAR               rsv:5;
+    UCHAR               rsv1;
+    UCHAR               GTK[32];
+}   GTK_ENCAP, *PGTK_ENCAP;
+
+typedef struct  _KDE_ENCAP
+{
+    UCHAR               Type;
+    UCHAR               Len;
+    UCHAR               OUI[3];
+    UCHAR               DataType;
+    GTK_ENCAP      GTKEncap;
+}   KDE_ENCAP, *PKDE_ENCAP;
+
+// For supplicant state machine states. 802.11i Draft 4.1, p. 97
+// We simplified it
+typedef enum    _WpaState
+{
+    SS_NOTUSE,              // 0
+    SS_START,               // 1
+    SS_WAIT_MSG_3,          // 2
+    SS_WAIT_GROUP,          // 3
+    SS_FINISH,              // 4
+    SS_KEYUPDATE,           // 5
+}   WPA_STATE;
+
+#endif   // __WPA_H__
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/rtc/Kconfig linux-2.6.23.1-stm/drivers/rtc/Kconfig
--- linux-2.6.23.1/drivers/rtc/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/rtc/Kconfig	2007-11-01 12:00:41.000000000 +0000
@@ -206,6 +206,34 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pcf8583.
 
+config  RTC_DRV_M41ST85Y
+	tristate "M41ST85Y (EXPERIMENTAL)"
+	depends on RTC_CLASS && CPU_SUBTYPE_ST40 && (I2C_STM || I2C_ST40_PIO) && EXPERIMENTAL
+	help
+	  Enable this entry to support the external M41ST85Y Real Time Clock
+	  device series roundly fitted on some I2C serial bus interface seeng that
+	  nothing board have one.
+
+config RTC_DRV_M41ST85Y_IRQPIO
+	depends on RTC_DRV_M41ST85Y
+	hex "IRQ PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-IRQ line.
+	  Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x0F represents PIO1[7]. Default is
+	  an invalid value.
+
+config RTC_DRV_M41ST85Y_SQWPIO
+	depends on RTC_DRV_M41ST85Y
+	hex "SQW PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-SQW line.
+	  Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x07 represents PIO0[7]. Default is
+	  an invalid value.
+
 config RTC_DRV_M41T80
 	tristate "ST M41T80 series RTC"
 	help
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/rtc/Makefile linux-2.6.23.1-stm/drivers/rtc/Makefile
--- linux-2.6.23.1/drivers/rtc/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/rtc/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -28,6 +28,7 @@
 obj-$(CONFIG_RTC_DRV_DS1742)	+= rtc-ds1742.o
 obj-$(CONFIG_RTC_DRV_EP93XX)	+= rtc-ep93xx.o
 obj-$(CONFIG_RTC_DRV_ISL1208)	+= rtc-isl1208.o
+obj-$(CONFIG_RTC_DRV_M41ST85Y)	+= rtc-m41st85y.o
 obj-$(CONFIG_RTC_DRV_M41T80)	+= rtc-m41t80.o
 obj-$(CONFIG_RTC_DRV_M48T59)	+= rtc-m48t59.o
 obj-$(CONFIG_RTC_DRV_M48T86)	+= rtc-m48t86.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/rtc/rtc-m41st85y.c linux-2.6.23.1-stm/drivers/rtc/rtc-m41st85y.c
--- linux-2.6.23.1/drivers/rtc/rtc-m41st85y.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/rtc/rtc-m41st85y.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,763 @@
+/* STMicroelectronics
+
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, wrssc to the Free Software
+* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/i2c.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/stm/pio.h>
+#include <linux/delay.h>
+
+/* General debugging */
+#undef M41ST85Y_DEBUG
+#ifdef  M41ST85Y_DEBUG
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define M41ST85Y_NAME		"m41st85y"
+#define M41ST85Y_NREGMAP	0x14	/* no of RTC's registers */
+#define M41ST85Y_ADDR		0x68	/* MY41ST85Y slave address */
+#define M41ST85Y_ISOPEN		0x01	/* means /dev/rtc is in use */
+#define M41ST85Y_RD		0x01	/* read flag for a i2c transfer */
+#define M41ST85Y_WR		0x00	/* write flag for a i2c transfer */
+#define M41ST85Y_INVALID	0xff	/* invalid value */
+#define M41ST85Y_IRQ_LEVEL	0x01	/* default value. 1=High, 0=Low */
+#define M41ST85Y_SQW_LEVEL	0x00	/* default value. 1=High, 0=Low */
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define M41ST85Y_NOBUS		0x03	/* number of I2C busses */
+#else
+#error platform not supported.
+#endif
+
+/*
+ * Addressing compliante to SPI PIO address mechanism
+ * Address = [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+ * Ex: PIO0[7] = 0x07, PIO2[5] = 0x15
+ */
+#define m41st85y_get_pioport(address)	((address >> 0x03) & 0x0f)
+#define m41st85y_get_piopin(address)	(address & 0x07)
+
+/* Addresses to scan: none. This chip cannot be detected. */
+static unsigned short normal_i2c[] = { M41ST85Y_ADDR, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD;
+
+/* private data */
+struct m41st85y_s {
+	struct rtc_device *rtc;
+	struct i2c_adapter *adapter;
+	unsigned long status;
+	unsigned long epoch;	/* default linux epoch 1900 */
+	struct stpio_pin *irqpio;	/* PIO used as RTC-IRQ line */
+	struct stpio_pin *sqwpio;	/* PIO used as RTC-SWQ line */
+	unsigned int cmd;
+} m41st85y;
+
+static __u8 rbuf[M41ST85Y_NREGMAP];
+static __u8 wbuf[M41ST85Y_NREGMAP];
+static __u32 busid = M41ST85Y_NOBUS;
+static __u32 irqpio = CONFIG_RTC_DRV_M41ST85Y_IRQPIO /* Ex: 0x07 */ ,
+    sqwpio = CONFIG_RTC_DRV_M41ST85Y_SQWPIO /* Ex: 0x0F */ ;
+
+/* I2C driver interface */
+static int m41st85y_attach(struct i2c_adapter *adapter);
+static int m41st85y_detach(struct i2c_client *client);
+static int m41st85y_probe(struct i2c_adapter *adapter, int address, int kind);
+
+static int m41st85y_transfer(struct m41st85y_s *instance,
+			     __u8 * buf, __u8 len, __u8 oper, __u8 at_addr)
+{
+	struct i2c_msg msg[2];
+	__u8 n_msg;
+	int err = 0;
+
+	if (oper == M41ST85Y_WR) {
+		/* perform write request */
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = oper;
+		msg[0].len = len;
+		msg[0].buf = buf;
+		n_msg = 1;
+	} else {
+		/* perform read request */
+		rbuf[0] = at_addr;
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = M41ST85Y_WR;
+		msg[0].len = 1;
+		msg[0].buf = rbuf;
+
+		msg[1].addr = M41ST85Y_ADDR;
+		msg[1].flags = M41ST85Y_RD;
+		msg[1].len = len;
+		msg[1].buf = buf;
+		n_msg = 2;
+	}
+
+	if ((err = i2c_transfer(instance->adapter, msg, n_msg)) != n_msg)
+		(oper == M41ST85Y_WR) ?
+		    printk(KERN_ERR "m41st85y: I2C write failed, err %d\n",
+			   err) : printk(KERN_ERR
+					 "m41st85y: I2C read  failed, err %d\n",
+					 err);
+	return err;
+}
+
+static int m41st85y_power_up(void)
+{
+	__u8 RegsMap[M41ST85Y_NREGMAP];
+	int err = 0;
+
+	while (1) {
+		m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0F);
+		if ((rbuf[0] & 0x40) == 0x00)
+			break;
+		printk(KERN_INFO
+		       "m41st85y: There was an alarm during the back-up mode AF 0x%x\n",
+		       rbuf[0]);
+	}
+
+	if ((err = m41st85y_transfer(&m41st85y,
+				     RegsMap + 1, M41ST85Y_NREGMAP - 1,
+				     M41ST85Y_RD, 0x01)) >= 0) {
+		RegsMap[0x00] = 0x01;	/* address offset */
+		RegsMap[0x01] &= ~0x80;	/* ST bit, wake up the oscillator */
+		RegsMap[0x08] = 0x80;	/* IRQ/FT/OUT line is driven low */
+		RegsMap[0x0A] &= ~0x40;	/* Swq disable */
+		RegsMap[0x0C] &= ~0x40;	/* Update the TIMEKEEPER registers */
+		RegsMap[0x13] &= 0x00;	/* Default Square wave output is 1Hz */
+		/* also irq_freq should be setting up 1Hz at init fase */
+		if ((err = m41st85y_transfer(&m41st85y,
+					     RegsMap, M41ST85Y_NREGMAP,
+					     M41ST85Y_WR,
+					     M41ST85Y_INVALID)) >= 0) {
+			/* waiting RTC hardware restart */
+			ssleep(1);
+			return 0;
+		}
+	}
+	return err;
+}
+
+void m41st85y_handler(struct stpio_pin *pin, void *dev)
+{
+	struct m41st85y_s *instance = dev;
+	__u8 skip = 0, events = 0;
+
+	stpio_disable_irq(pin);
+
+	if ((instance->cmd == RTC_PIE_ON) || (instance->cmd == RTC_UIE_ON)) {
+		if (stpio_get_pin(pin) == M41ST85Y_IRQ_LEVEL) {
+			skip = 1;
+			stpio_enable_irq(pin, M41ST85Y_IRQ_LEVEL);
+		} else
+			stpio_enable_irq(pin, !M41ST85Y_IRQ_LEVEL);
+	}
+
+	if (!skip) {
+		events |= RTC_IRQF;
+		rtc_update_irq(&instance->rtc->class_dev, 1, events);
+	}
+}
+
+static int m41st85y_alarmset(unsigned int ioctl_cmd, struct rtc_time *ltime)
+{
+	/* to be sure that incoming ioctl request can be managed
+	   by this */
+	if ((ioctl_cmd != RTC_UIE_ON) && (ioctl_cmd != RTC_ALM_SET))
+		return -1;
+
+	if (ioctl_cmd == RTC_UIE_ON) {
+		rtc_get_rtc_time(ltime);
+
+		/* alarm update */
+		wbuf[0] = 0x0A;
+		wbuf[1] = BIN2BCD(ltime->tm_mon);
+		wbuf[2] = 0xC0 | BIN2BCD(ltime->tm_mday);
+		wbuf[3] = 0x80 | BIN2BCD(ltime->tm_hour);
+		wbuf[4] = 0x80 | BIN2BCD(ltime->tm_min);
+		wbuf[5] = 0x80 | BIN2BCD(ltime->tm_sec + 1);
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 6, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			wbuf[0] = 0x0A;
+			wbuf[1] = (wbuf[1] | 0x80);
+			DPRINTK("enable AFE writing %#x\n", wbuf[1]);
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 2, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	} else {
+		if (m41st85y_transfer(&m41st85y,
+				      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0) {
+			/* alarm update */
+			wbuf[0] = 0x0A;
+			wbuf[1] = (rbuf[0] & 0xE0) | BIN2BCD(ltime->tm_mon);
+			wbuf[2] = (rbuf[1] & 0xC0) | BIN2BCD(ltime->tm_mday);
+			wbuf[3] = (rbuf[2] & 0xC0) | BIN2BCD(ltime->tm_hour);
+			wbuf[4] = (rbuf[3] & 0x80) | BIN2BCD(ltime->tm_min);
+			wbuf[5] = (rbuf[4] & 0x80) | BIN2BCD(ltime->tm_sec);
+			DPRINTK("writing alarm date\n");
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 6, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	}
+	return -EIO;
+}
+
+static int m41st85y_open(struct device *dev)
+{
+	/* locked at top level until the device will be 
+	   release */
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		return -EBUSY;
+	}
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	return 0;
+}
+
+static void m41st85y_release(struct device *dev)
+{
+	m41st85y.status &= ~M41ST85Y_ISOPEN;
+	/* unlocked at top level before to be use it again */
+}
+
+static int m41st85y_read_time(struct device *dev, struct rtc_time *time_read)
+{
+	if (time_read == NULL)
+		return -EIO;
+
+	memset(time_read, 0, sizeof(struct rtc_time));
+
+	if (m41st85y_transfer(&m41st85y, rbuf, 9, M41ST85Y_RD, 0x00) >= 0) {
+		time_read->tm_sec = BCD2BIN(rbuf[1] & 0x7f);
+		time_read->tm_min = BCD2BIN(rbuf[2] & 0x7f);
+		time_read->tm_hour = BCD2BIN(rbuf[3] & 0x3f);
+		time_read->tm_wday = BCD2BIN(rbuf[4] & 0x07);
+		time_read->tm_mday = BCD2BIN(rbuf[5] & 0x3f);
+		time_read->tm_mon = BCD2BIN(rbuf[6] & 0x1f);
+		time_read->tm_year = BCD2BIN(rbuf[7]);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int m41st85y_set_time(struct device *dev, struct rtc_time *time_to_write)
+{
+	int err;
+
+	/* this is already part of mutex area performed at top level */
+	if ((err = m41st85y_transfer(&m41st85y,
+				     rbuf, 8, M41ST85Y_RD, 0x00)) >= 0) {
+		/* time update */
+		wbuf[0] = 0x00;
+		wbuf[1] = 0x00;
+		wbuf[2] = (rbuf[1] & 0x80) | BIN2BCD(time_to_write->tm_sec);
+		wbuf[3] = (rbuf[2] & 0x80) | BIN2BCD(time_to_write->tm_min);
+		wbuf[4] = (rbuf[3] & 0xC0) | BIN2BCD(time_to_write->tm_hour);
+		memcpy(&wbuf[5], &rbuf[4], sizeof(char));
+		wbuf[6] = (rbuf[5] & 0xC0) | BIN2BCD(time_to_write->tm_mday);
+		wbuf[7] = (rbuf[6] & 0xE0) | BIN2BCD(time_to_write->tm_mon);
+		wbuf[8] = BIN2BCD((time_to_write->tm_year - m41st85y.epoch));
+
+		err = m41st85y_transfer(&m41st85y,
+					wbuf, 9, M41ST85Y_WR, M41ST85Y_INVALID);
+	}
+	return err;
+}
+
+static int m41st85y_read_alarm(struct device *dev,
+			       struct rtc_wkalrm *alarm_read)
+{
+	int err = 0;
+
+	if (alarm_read != NULL) {
+		if ((err = m41st85y_transfer(&m41st85y,
+					     rbuf, 6, M41ST85Y_RD, 0x0A)) >= 0)
+		{
+			alarm_read->time.tm_mon = BCD2BIN(rbuf[0] & 0x1f);
+			alarm_read->time.tm_mday = BCD2BIN(rbuf[1] & 0x3f);
+			alarm_read->time.tm_hour = BCD2BIN(rbuf[2] & 0x3f);
+			alarm_read->time.tm_min = BCD2BIN(rbuf[3] & 0x7f);
+			alarm_read->time.tm_sec = BCD2BIN(rbuf[4] & 0x7f);
+		}
+	} else
+		err = -EIO;
+
+	return err;
+}
+
+static int m41st85y_set_alarm(struct device *dev,
+			      struct rtc_wkalrm *alarm_to_write)
+{
+	return m41st85y_alarmset(RTC_ALM_SET, &alarm_to_write->time);
+}
+
+static int m41st85y_ioctl(struct device *dev, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct rtc_time ltime;
+	int err = 0;
+
+	memset(&ltime, 0, sizeof(struct rtc_time));
+	m41st85y.cmd = cmd;
+
+	switch (cmd) {
+	case RTC_UIE_OFF:	/* Mask ints from RTC updates.  */
+	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit    */
+	case RTC_AIE_ON:	/* Allow alarm interrupts.      */
+		{
+			/* reading AFE bits */
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				char n_data = 2;
+
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_AIE_ON) {
+					stpio_enable_irq(m41st85y.irqpio,
+							 M41ST85Y_IRQ_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x80);
+				} else {
+					stpio_disable_irq(m41st85y.irqpio);
+					m41st85y.cmd = 0;	/* disable status */
+					n_data = 6;
+					wbuf[1] = (rbuf[0] & ~0xA0);	/* disabling AFE flag bit */
+					wbuf[2] = wbuf[3] = wbuf[4] = wbuf[5] = 0x00;	/* disabling RPT5-RPT1 */
+				}
+
+				DPRINTK("writing AFE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, n_data, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0) {
+					return 0;
+				}
+			}
+			return -EIO;
+		}
+	case RTC_PIE_OFF:	/* Mask periodic int. enab. bit */
+	case RTC_PIE_ON:	/* Allow periodic ints          */
+		{
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_PIE_OFF) {
+					stpio_disable_irq(m41st85y.sqwpio);
+					wbuf[1] = (rbuf[0] & ~0x40);
+				} else {
+					stpio_enable_irq(m41st85y.sqwpio,
+							 M41ST85Y_SQW_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x40);
+				}
+
+				DPRINTK("writing on SWQE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, 2, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0)
+					return 0;
+			}
+			return -EIO;
+		}
+	case RTC_UIE_ON:	/* Allow ints for RTC updates. (one per second) */
+		{
+			stpio_enable_irq(m41st85y.irqpio, M41ST85Y_IRQ_LEVEL);
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_ALM_READ:	/* Read the present alarm time */
+		{
+			struct rtc_wkalrm alarm_read;
+
+			if ((err = m41st85y_read_alarm(NULL, &alarm_read)) >= 0)
+				return copy_to_user((void __user *)arg,
+						    &alarm_read.time,
+						    sizeof alarm_read.
+						    time) ? -EFAULT : 0;
+			return err;
+		}
+	case RTC_ALM_SET:	/* Store a time into the alarm */
+		{
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_RD_TIME:	/* Read the time/date from RTC  */
+		{
+			rtc_get_rtc_time(&ltime);
+			return copy_to_user((void __user *)arg,
+					    &ltime, sizeof ltime) ? -EFAULT : 0;
+		}
+	case RTC_SET_TIME:	/* Set the RTC */
+		{
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+
+			return m41st85y_set_time(dev, &ltime);
+		}
+	case RTC_IRQP_READ:	/* Read the periodic IRQ rate.  */
+		{
+			return put_user(m41st85y.rtc->irq_freq,
+					(unsigned long __user *)arg);
+		}
+	case RTC_IRQP_SET:	/* Set periodic IRQ rate.       */
+		{
+			wbuf[0] = 0x13;
+			switch (arg) {
+			case 0:
+				wbuf[1] = 0x00;
+				break;
+			case 1:
+				wbuf[1] = 0xF0;
+				break;
+			case 2:
+				wbuf[1] = 0xE0;
+				break;
+			case 4:
+				wbuf[1] = 0xD0;
+				break;
+			case 8:
+				wbuf[1] = 0xC0;
+				break;
+			case 16:
+				wbuf[1] = 0xB0;
+				break;
+			case 32:
+				wbuf[1] = 0xA0;
+				break;
+			case 64:
+				wbuf[1] = 0x90;
+				break;
+			case 128:
+				wbuf[1] = 0x80;
+				break;
+			case 256:
+				wbuf[1] = 0x70;
+				break;
+			case 512:
+				wbuf[1] = 0x60;
+				break;
+			case 1024:
+				wbuf[1] = 0x50;
+				break;
+			case 2048:
+				wbuf[1] = 0x40;
+				break;
+			case 4096:
+				wbuf[1] = 0x30;
+				break;
+			case 8192:
+				wbuf[1] = 0x20;
+				break;
+			default:
+				return -ENOTSUPP;
+			}
+
+			if ((err = m41st85y_transfer(&m41st85y,
+						     wbuf, 2, M41ST85Y_WR,
+						     M41ST85Y_INVALID)) >= 0) {
+				m41st85y.rtc->irq_freq = arg;
+				return 0;
+			}
+
+			return err;
+		}
+	case RTC_EPOCH_READ:	/* Read the epoch.      */
+		{
+			return put_user(m41st85y.epoch,
+					(unsigned long __user *)arg);
+		}
+	case RTC_EPOCH_SET:	/* Set the epoch.       */
+		{
+			copy_from_user(&m41st85y.epoch, (void *)arg,
+				       sizeof(long));
+			return 0;
+		}
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int m41st85y_read_callback(struct device *dev, int data)
+{
+	if (data & RTC_IRQF) {
+		if ((m41st85y.cmd == RTC_AIE_ON)
+		    || (m41st85y.cmd == RTC_UIE_ON)) {
+			while (1) {
+				m41st85y_transfer(&m41st85y,
+						  rbuf, 1, M41ST85Y_RD, 0x0F);
+
+				DPRINTK("AF 0x%x\n", rbuf[0]);
+				if ((rbuf[0] & 0x40) == 0x00)
+					break;
+			}
+		}
+	}
+	return data;
+}
+
+static int m41st85y_irq_set_state(struct device *dev, int enabled)
+{
+	if (enabled)
+		return m41st85y_ioctl(dev, RTC_PIE_ON, 0);
+	else
+		return m41st85y_ioctl(dev, RTC_PIE_OFF, 0);
+}
+
+static int m41st85y_irq_set_freq(struct device *dev, int freq)
+{
+	return m41st85y_ioctl(dev, RTC_IRQP_SET, freq);
+}
+
+static struct rtc_class_ops m41st85y_rtc_ops = {
+	.open = m41st85y_open,
+	.release = m41st85y_release,
+	.ioctl = m41st85y_ioctl,
+	.read_time = m41st85y_read_time,
+	.set_time = m41st85y_set_time,
+	.read_alarm = m41st85y_read_alarm,
+	.set_alarm = m41st85y_set_alarm,
+	.irq_set_state = m41st85y_irq_set_state,
+	.irq_set_freq = m41st85y_irq_set_freq,
+	.read_callback = m41st85y_read_callback,
+
+};
+
+static struct i2c_driver m41st85y_driver = {
+	.driver = {
+		   .name = "m41st85y",
+		   },
+	.attach_adapter = &m41st85y_attach,
+	.detach_client = &m41st85y_detach,
+};
+
+static int m41st85y_attach(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, m41st85y_probe);
+}
+
+static int m41st85y_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	int err = 0;
+	struct i2c_client *client;
+	struct rtc_device *rtc_dev;
+
+	m41st85y.adapter = adapter;
+
+	if (m41st85y_power_up() >= 0) {
+
+		if (!(client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+			err = -ENOMEM;
+			goto exit_err;
+		}
+
+		/* I2C client */
+		client->addr = address;
+		client->driver = &m41st85y_driver;
+		client->adapter = adapter;
+
+		strlcpy(client->name, m41st85y_driver.driver.name,
+			I2C_NAME_SIZE);
+
+		/* Inform the i2c layer */
+		if ((err = i2c_attach_client(client))) {
+			goto exit_kfree;
+		}
+
+		rtc_dev =
+		    rtc_device_register(m41st85y_driver.driver.name,
+					&client->dev, &m41st85y_rtc_ops,
+					THIS_MODULE);
+		if (IS_ERR(rtc_dev)) {
+			err = PTR_ERR(rtc_dev);
+			goto exit_detach;
+		}
+
+		i2c_set_clientdata(client, rtc_dev);
+
+		m41st85y.rtc = rtc_dev;
+		m41st85y.cmd = 0;	/* none */
+		m41st85y.epoch = 1900;	/* default value on Linux */
+		m41st85y.rtc->irq_freq = 1;	/* default square ware 1Hz */
+		printk(KERN_INFO
+		       "m41st85y: IRQ line plugged on PIO%d[%d]\n",
+		       m41st85y_get_pioport(irqpio),
+		       m41st85y_get_piopin(irqpio));
+		printk(KERN_INFO
+		       "m41st85y: SQW line plugged on PIO%d[%d]\n",
+		       m41st85y_get_pioport(sqwpio),
+		       m41st85y_get_piopin(sqwpio));
+
+		if ((m41st85y.irqpio =
+		     stpio_request_pin(m41st85y_get_pioport(irqpio),
+				       m41st85y_get_piopin(irqpio),
+				       M41ST85Y_NAME,
+				       STPIO_BIDIR_Z1)) != NULL) {
+			if ((m41st85y.sqwpio =
+			     stpio_request_pin(m41st85y_get_pioport(sqwpio),
+					       m41st85y_get_piopin(sqwpio),
+					       M41ST85Y_NAME,
+					       STPIO_IN)) != NULL) {
+				stpio_request_irq(m41st85y.irqpio,
+						  M41ST85Y_IRQ_LEVEL,
+						  m41st85y_handler,
+						  (void *)&m41st85y);
+				stpio_request_irq(m41st85y.sqwpio,
+						  M41ST85Y_SQW_LEVEL,
+						  m41st85y_handler,
+						  (void *)&m41st85y);
+				printk(KERN_INFO
+				       "m41st85y: STMicroelectronics M41ST85Y RTC Driver registered\n");
+				return 0;
+			} else
+				stpio_free_pin(m41st85y.irqpio);
+		}
+		printk(KERN_ERR
+		       "m41st85y: STMicroelectronics M41ST85Y RTC Driver unregistered\n");
+		goto exit_detach;
+	}
+
+	return 0;
+      exit_detach:
+	i2c_detach_client(client);
+      exit_kfree:
+	kfree(client);
+      exit_err:
+	return err;
+}
+
+static int m41st85y_detach(struct i2c_client *client)
+{
+	int err;
+	struct rtc_device *rtc_dev = i2c_get_clientdata(client);
+
+	stpio_free_irq(m41st85y.irqpio);
+	stpio_free_irq(m41st85y.sqwpio);
+
+	if (rtc_dev)
+		rtc_device_unregister(rtc_dev);
+
+	if ((err = i2c_detach_client(client)))
+		return err;
+
+	kfree(client);
+	return 0;
+}
+
+static __init int m41st85y_init(void)
+{
+	return i2c_add_driver(&m41st85y_driver);
+}
+
+static __exit void m41st85y_exit(void)
+{
+	i2c_del_driver(&m41st85y_driver);
+}
+
+EXPORT_SYMBOL(rtc_register);
+EXPORT_SYMBOL(rtc_unregister);
+EXPORT_SYMBOL(rtc_control);
+
+int rtc_register(rtc_task_t * task)
+{
+	if (task == NULL || task->func == NULL)
+		return -EINVAL;
+	spin_lock_irq(&m41st85y.rtc->irq_lock);
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -EBUSY;
+	}
+	spin_lock(&m41st85y.rtc->irq_task_lock);
+	if (m41st85y.rtc->irq_task) {
+		spin_unlock(&m41st85y.rtc->irq_task_lock);
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -EBUSY;
+	}
+
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	m41st85y.rtc->irq_task = task;
+	spin_unlock(&m41st85y.rtc->irq_task_lock);
+	spin_unlock_irq(&m41st85y.rtc->irq_lock);
+	return 0;
+}
+
+int rtc_control(rtc_task_t * task, unsigned int cmd, unsigned long arg)
+{
+	spin_lock_irq(&m41st85y.rtc->irq_task_lock);
+	if (m41st85y.rtc->irq_task != task) {
+		spin_unlock_irq(&m41st85y.rtc->irq_task_lock);
+		return -ENXIO;
+	}
+	spin_unlock_irq(&m41st85y.rtc->irq_task_lock);
+	return m41st85y_ioctl(NULL, cmd, arg);
+}
+
+int rtc_unregister(rtc_task_t * task)
+{
+	spin_lock_irq(&m41st85y.rtc->irq_lock);
+	spin_lock(&m41st85y.rtc->irq_task_lock);
+
+	if (m41st85y.rtc->irq_task != task) {
+		spin_unlock(&m41st85y.rtc->irq_task_lock);
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -ENXIO;
+	}
+	m41st85y.rtc->irq_task = NULL;
+
+	/* diasbilng the RTC's AIE, UIE and PIE control */
+	if (m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0A) >= 0) {
+		wbuf[0] = 0x0A;
+		wbuf[1] = rbuf[0] & ~0xC0;
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 2, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			m41st85y.status &= ~M41ST85Y_ISOPEN;
+			spin_unlock(&m41st85y.rtc->irq_task_lock);
+			spin_unlock_irq(&m41st85y.rtc->irq_lock);
+			return 0;
+		}
+	}
+
+	spin_unlock(&m41st85y.rtc->irq_task_lock);
+	spin_unlock_irq(&m41st85y.rtc->irq_lock);
+	return -EIO;
+}
+
+void rtc_get_rtc_time(struct rtc_time *ltime)
+{
+	m41st85y_read_time(NULL, ltime);
+}
+
+module_param(busid, uint, 0644);
+module_param(irqpio, uint, 0644);
+module_param(sqwpio, uint, 0644);
+module_init(m41st85y_init);
+module_exit(m41st85y_exit);
+MODULE_AUTHOR("angelo castello <angelo.castello@st.com>");
+MODULE_PARM_DESC(busid, "I2C bus ID");
+MODULE_PARM_DESC(irqpio, "PIO port/pin for RTC-IRQ line");
+MODULE_PARM_DESC(busid, "PIO port/pin for RTC-SWQ line");
+MODULE_DESCRIPTION("External RTC upon I2C");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/Kconfig linux-2.6.23.1-stm/drivers/serial/Kconfig
--- linux-2.6.23.1/drivers/serial/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/serial/Kconfig	2007-11-01 12:00:41.000000000 +0000
@@ -1259,4 +1259,24 @@
 	  Currently, only 8250 compatible ports are supported, but
 	  others can easily be added.
 
+config SERIAL_ST_ASC
+	tristate "ST ASC serial port support"
+	depends on CPU_SUBTYPE_ST40
+	select SERIAL_CORE
+	help
+	  This driver is for the on-chip Asychronous Serial Controller on
+	  some STMicroelectronics system-on-chip devices.
+
+config SERIAL_ST_ASC_CONSOLE
+	bool "Support for console on ST ASC"
+	depends on SERIAL_ST_ASC=y
+	select SERIAL_CORE_CONSOLE
+
+config SERIAL_ST_ASC_DMA
+	bool "Support for 710x FDMA on ST ASC"
+	depends on SERIAL_ST_ASC && STM_DMA
+	help
+	  This enables 710x on-chip FDMA to be used with the Asychronous Serial
+	  Controller on STMicroelectronics 710x system-on-chip devices.
+
 endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/Makefile linux-2.6.23.1-stm/drivers/serial/Makefile
--- linux-2.6.23.1/drivers/serial/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/serial/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -64,3 +64,5 @@
 obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM) += of_serial.o
 obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
+obj-$(CONFIG_SERIAL_ST_ASC) += stasc.o
+obj-$(CONFIG_SERIAL_ST_ASC_DMA) += stasc-dma.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/sh-sci.h linux-2.6.23.1-stm/drivers/serial/sh-sci.h
--- linux-2.6.23.1/drivers/serial/sh-sci.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/drivers/serial/sh-sci.h	2007-11-01 12:00:39.000000000 +0000
@@ -102,7 +102,7 @@
 # define SCIF_ORER 0x0001   /* overrun error bit */
 # define SCSCR_INIT(port) 0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
 # define SCIF_ONLY
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
 # define SCSPTR1 0xffe00020 /* 16 bit SCIF */
 # define SCSPTR2 0xffe80020 /* 16 bit SCIF */
 # define SCIF_ORER 0x0001   /* overrun error bit */
@@ -577,7 +577,7 @@
 		return ctrl_inb(SCPDR0) & 0x0001 ? 1 : 0; /* SCIF0 */
 	return 1;
 }
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
 static inline int sci_rxd_in(struct uart_port *port)
 {
 	if (port->mapbase == 0xffe00000)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/stasc-dma.c linux-2.6.23.1-stm/drivers/serial/stasc-dma.c
--- linux-2.6.23.1/drivers/serial/stasc-dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/serial/stasc-dma.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,629 @@
+/*
+ * STMicroelectronics Asynchronous Serial Controller (ASC) driver
+ * FDMA extension
+ *
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Nigel Hathaway <nigel.hathaway@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/stm/fdma-reqs.h>
+#include <linux/timer.h>
+#include <linux/stm/stm-dma.h>
+#include <asm/cacheflush.h>
+
+#include "stasc.h"
+
+/* Key running performance parameters */
+#ifdef CONFIG_STM_DMA
+#define DMA_RXBUFSIZE 1024
+#define DMA_RXBUFERS 8 /* must be power of 2 */
+#define DMA_TXBUFSIZE 2048
+#define DMA_TXBUFERS 4 /* must be power of 2 */
+#define RXPOLL_PERIOD (50 * HZ /1000)
+#endif
+
+struct asc_dma_port
+{
+	int rxdma_running;
+	int txdma_running;
+	int rxdma_chid;
+	int txdma_chid;
+	struct stm_dma_params rxdmap;
+	struct stm_dma_params txdmap;
+	struct stm_dma_req *rx_dma_req;
+	struct stm_dma_req *tx_dma_req;
+	unsigned char *rxdmabuf[DMA_RXBUFERS];
+	int rxdmabuf_count[DMA_RXBUFERS];
+	unsigned char *txdmabuf[DMA_TXBUFERS];
+	int txdmabuf_count[DMA_TXBUFERS];
+	int rxdmabuf_head;
+	int rxdmabuf_tail;
+	int txdmabuf_head;
+	int txdmabuf_tail;
+	int last_residue;
+	struct timer_list rxpoll_timer;
+};
+
+static unsigned long FDMA_RXREQ[ASC_MAX_PORTS];
+static unsigned long FDMA_TXREQ[ASC_MAX_PORTS];
+static struct asc_dma_port asc_dma_ports[ASC_MAX_PORTS];
+
+void asc_fdma_setreq(void)
+{
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define SYSCONF_BASE		0xb9001000
+#define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
+
+	u32 devid = ctrl_inl(SYSCONF_DEVICEID);
+	u32 cpu_subtype = (((devid >> 12) & 0x3ff) == 0x02c) ? 7109 : 7100;
+
+	if (cpu_subtype == 7100)
+	{
+		FDMA_RXREQ[0] = STB7100_FDMA_REQ_UART_2_RX;
+		FDMA_RXREQ[1] = STB7100_FDMA_REQ_UART_3_RX;
+		FDMA_TXREQ[0] = STB7100_FDMA_REQ_UART_2_TX;
+		FDMA_TXREQ[1] = STB7100_FDMA_REQ_UART_3_TX;
+	}
+	else
+	{
+		FDMA_RXREQ[0] = STB7109_FDMA_REQ_UART_2_RX;
+		FDMA_RXREQ[1] = STB7109_FDMA_REQ_UART_3_RX;
+		FDMA_TXREQ[0] = STB7109_FDMA_REQ_UART_2_TX;
+		FDMA_TXREQ[1] = STB7109_FDMA_REQ_UART_3_TX;
+	}
+#elif defined(CONFIG_CPU_SUBTYPE_STX7200)
+	FDMA_RXREQ[0] = STB7200_FDMA_REQ_UART_2_RX;
+	FDMA_RXREQ[1] = STB7200_FDMA_REQ_UART_3_RX;
+	FDMA_TXREQ[0] = STB7200_FDMA_REQ_UART_2_TX;
+	FDMA_TXREQ[1] = STB7200_FDMA_REQ_UART_3_TX;
+#else
+#error Unknown CPU
+#endif
+}
+
+static int asc_dma_rxflush_one_buffer(struct asc_port *ascport,
+      struct asc_dma_port *ascdmaport,  struct tty_struct *tty, int space)
+{
+	unsigned char *buffer = ascdmaport->rxdmabuf[ascdmaport->rxdmabuf_tail];
+	int count = ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_tail];
+
+	/* Copy as much data as possibly to the tty receive buffer */
+	tty->ldisc.receive_buf(tty, buffer, NULL, min(count, space));
+
+	/* If we didn't use up all the data in the buffer */
+	if (count > space) {
+		/* Keep the bit we didn't use */
+		int residue = count - space;
+		ascport->port.icount.rx += space;
+		memmove (buffer, buffer + space, residue);
+		ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_tail] = residue;
+		space = 0;
+	} else {
+		/* Otherwise move on to the next buffer */
+		ascport->port.icount.rx += count;
+		space = tty->receive_room;
+		ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_tail] = 0;
+		if (ascdmaport->rxdmabuf_head != ascdmaport->rxdmabuf_tail)
+			ascdmaport->rxdmabuf_tail = (ascdmaport->rxdmabuf_tail + 1) & (DMA_RXBUFERS - 1);
+	}
+
+	return space;
+}
+
+static void asc_dma_rxflush(struct uart_port *port)
+{
+	struct asc_port *ascport = &asc_ports[port->line];
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	struct tty_struct *tty = port->info->tty;
+	int space = tty->receive_room;
+	int err=0;
+
+	/* Make space to start new DMA on new block, if necessary */
+	if (ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_head] != 0) {
+		if (((ascdmaport->rxdmabuf_head + 1) & (DMA_RXBUFERS - 1)) == ascdmaport->rxdmabuf_tail) {
+			space = asc_dma_rxflush_one_buffer(ascport, ascdmaport, tty, space);
+			if (((ascdmaport->rxdmabuf_head + 1) & (DMA_RXBUFERS - 1)) == ascdmaport->rxdmabuf_tail) {
+/*				printk(KERN_WARNING "ASC RX FDMA overflow on buffer#%d\n", ascdmaport->rxdmabuf_head); */
+				return;
+			}
+		}
+		
+		/* Use next free block to receive into */
+		ascdmaport->rxdmabuf_head = (ascdmaport->rxdmabuf_head + 1) & (DMA_RXBUFERS - 1);
+	}
+	
+	/* Try to set RX DMA going again */
+	dma_params_addrs(&ascdmaport->rxdmap,
+			 ascdmaport->rxdmap.sar,
+			 virt_to_phys(ascdmaport->rxdmabuf[ascdmaport->rxdmabuf_head]),
+			 ascdmaport->rxdmap.node_bytes);
+
+	dma_params_DIM_0_x_1(&ascdmaport->rxdmap);
+
+	if((err = dma_compile_list(ascdmaport->rxdma_chid, &ascdmaport->rxdmap, GFP_KERNEL)) < 0) {
+		printk(KERN_ERR "ASC RX FDMA failed to reconfigure, error %d\n", err);
+		return;
+	}
+
+	dma_cache_wback_inv(ascdmaport->rxdmabuf[ascdmaport->rxdmabuf_head], DMA_RXBUFSIZE);
+
+	if((err = dma_xfer_list(ascdmaport->rxdma_chid,&ascdmaport->rxdmap)) < 0) {
+		printk(KERN_ERR "ASC RX FDMA failed to start, error %d\n", err);
+		return;
+	}
+	ascdmaport->rxdma_running = 1;
+
+	/* Transfer as many buffers as possible to the tty receive buffer */
+	while (space > 0 && ascdmaport->rxdmabuf_head != ascdmaport->rxdmabuf_tail) {
+		space = asc_dma_rxflush_one_buffer(ascport, ascdmaport, tty, space);
+	}
+}
+
+static void asc_rxfmda_done(unsigned long param)
+{
+	struct uart_port *port = (struct uart_port *)param;
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	struct tty_struct *tty = port->info->tty;
+	int overrun = asc_in(port, STA) & ASC_STA_OE;
+	int residue, count;
+
+	/* If stopping, do no more */
+	if (!ascdmaport->rxdma_running)
+		return;
+
+	/* Report any overrun errors */
+	if (overrun) {
+		unsigned char n = '\0';
+		char o = TTY_OVERRUN;
+		port->icount.overrun++;
+		tty->ldisc.receive_buf(tty, &n, &o, 1);
+	}
+
+	/* Determine if the DMA was stopped */
+	ascdmaport->rxdma_running = 0;
+	residue = get_dma_residue(ascdmaport->rxdma_chid);
+	count = DMA_RXBUFSIZE - residue;
+
+	/* If it was stopped, remove any data from the ASC FIFO */
+	if (residue) {
+		int i;
+		unsigned char *buffer = ascdmaport->rxdmabuf[ascdmaport->rxdmabuf_head] + count;
+		residue = min(FIFO_SIZE/2, residue);
+
+		/* FIFO will be maximum half full */
+		for (i=0; i<residue; i++) {
+			if (asc_in(port, STA) & ASC_STA_RBF) {
+				count++;
+				*buffer++ = (unsigned char)asc_in(port, RXBUF);
+			} else
+				break;
+		}
+	}
+
+	/* Flush the data to the tty buffer and set DMA going again */
+	ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_head] = count;
+	asc_dma_rxflush(port);
+}
+
+static void asc_rxfmda_error(unsigned long param)
+{
+	printk(KERN_ERR "ASC RX FDMA error\n");
+}
+
+void asc_fdma_start_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	int newtail, count, to_send = 0;
+	unsigned char *insert;
+
+	/* Don't do anything if nothing left to send */
+	if (uart_tx_stopped(port) || (uart_circ_empty(xmit) && !port->x_char))
+		return;
+
+	/* Also do nothing if no buffer space left */
+	if (ascdmaport->txdmabuf_tail == ((ascdmaport->txdmabuf_head + 1) & (DMA_TXBUFERS-1)))
+		return;
+
+	/* Work out where to put the new data to send */
+	newtail = (ascdmaport->txdmabuf_tail - 1) & (DMA_TXBUFERS-1);
+	insert = ascdmaport->txdmabuf[newtail];
+	count = uart_circ_chars_pending(xmit);
+	if (count > DMA_TXBUFSIZE)
+		count = DMA_TXBUFSIZE;
+
+	/* Handle xon/xoff character if required */
+	if (port->x_char) {
+		*insert++ = port->x_char;
+		port->icount.tx++;
+		to_send++;
+		if (count == DMA_TXBUFSIZE)
+			count--;
+
+		/* Corner case: must send at least 4 bytes */
+		while (to_send + count < 4) {
+			*insert++ = port->x_char;
+			to_send++;
+		}
+
+		port->x_char = 0;
+	}
+	to_send += count;
+
+	/* Ensure that a multiple of 4 bytes is sent */
+	if (to_send > 4) {
+		while (to_send % 4) {
+			to_send--;
+			count--;
+		}
+	}
+
+	/* Fill up the buffer with the data to send */
+	if (count > 0 && to_send >= 4) {
+		int bytes_to_end = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+
+		/* If the circular buffer wraps round */
+		if (count > bytes_to_end) {
+			/* Copy up to the end of the buffer */
+			memcpy(insert, xmit->buf + xmit->tail, bytes_to_end);
+			xmit->tail = (xmit->tail + bytes_to_end) & (UART_XMIT_SIZE - 1);
+			count -= bytes_to_end;
+			insert += bytes_to_end;
+			port->icount.tx += bytes_to_end;
+
+			/* Copy remainder at the beginning */
+			memcpy(insert, xmit->buf + xmit->tail, count);
+			xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
+			port->icount.tx += count;
+		} else {
+			/* Just copy to fill up the remaining bytes */
+			memcpy(insert, xmit->buf + xmit->tail, count);
+			xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
+			port->icount.tx += count;
+		}
+	}
+
+	/* Send any data */
+	if (to_send >= 4) {
+		/* Post the buffer to send */
+		ascdmaport->txdmabuf_count[newtail] = to_send;
+		ascdmaport->txdmabuf_tail = newtail;
+
+		/* Start the transfer going if DMA is not running */
+		if (!ascdmaport->txdma_running) {
+			int err;
+			ascdmaport->txdmabuf_head = ascdmaport->txdmabuf_tail;
+			ascdmaport->txdma_running = 1;
+
+			dma_params_addrs(&ascdmaport->txdmap,
+					virt_to_phys(ascdmaport->txdmabuf[newtail]),
+					virt_to_phys((void*)(port->mapbase + ASC_TXBUF)),
+					to_send);
+
+			dma_params_DIM_1_x_0(&ascdmaport->txdmap);
+
+			err = dma_compile_list(ascdmaport->txdma_chid, &ascdmaport->txdmap, GFP_KERNEL);
+
+			dma_cache_wback(ascdmaport->txdmabuf[newtail], DMA_TXBUFSIZE);
+
+			if(err==0)
+				dma_xfer_list(ascdmaport->txdma_chid,&ascdmaport->txdmap);
+			else
+				printk(KERN_ERR "ASC TX FDMA failed to configure, error %d\n",err);
+		}
+	} else if (to_send > 0 && !uart_circ_empty(xmit) && !ascdmaport->txdma_running) {
+
+		/* Feed out last little bit if stopped */
+		while(!uart_circ_empty(xmit)) {
+			asc_out (port, TXBUF, xmit->buf[xmit->tail]);
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+		}
+	}
+
+	/* Wake up UART driver if necessary */
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+static void asc_txfmda_done(unsigned long param)
+{
+	struct uart_port *port = (struct uart_port *)param;
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+
+	/* If on a stop request, do no more */
+	if (!ascdmaport->txdma_running)
+		return;
+
+	ascdmaport->txdmabuf_count[ascdmaport->txdmabuf_head] = 0;
+
+	/* If completed, tidy up */
+	if (ascdmaport->txdmabuf_tail == ascdmaport->txdmabuf_head) {
+		struct circ_buf *xmit = &port->info->xmit;
+		int count = uart_circ_chars_pending(xmit);
+		ascdmaport->txdma_running = 0;
+
+		/* Feed out any odd bytes left over */
+		if (count < 4) {
+			while(!uart_circ_empty(xmit)) {
+				asc_out (port, TXBUF, xmit->buf[xmit->tail]);
+				xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+				port->icount.tx++;
+			}
+		}
+	} else {
+		/* Otherwise start the new block going */
+		int newhead = (ascdmaport->txdmabuf_head - 1) & (DMA_TXBUFERS - 1);
+		ascdmaport->txdmabuf_head = newhead;
+		if (ascdmaport->txdmabuf_count[newhead] != 0) {
+			int err;
+
+			dma_params_addrs(&ascdmaport->txdmap,
+					virt_to_phys(ascdmaport->txdmabuf[newhead]),
+					ascdmaport->txdmap.dar,
+					ascdmaport->txdmabuf_count[newhead]);
+			dma_params_DIM_1_x_0(&ascdmaport->txdmap);
+
+			if((err=dma_compile_list(ascdmaport->txdma_chid, &ascdmaport->txdmap, GFP_KERNEL))<0) {
+				printk(KERN_ERR "ASC TX FDMA  failed to reconfigure, error %d\n",err);
+				return;
+			}
+
+			dma_cache_wback(ascdmaport->txdmabuf[newhead], DMA_TXBUFSIZE);
+
+			if((err=dma_xfer_list(ascdmaport->txdma_chid,&ascdmaport->txdmap))<0) {
+				printk(KERN_ERR "ASC TX FDMA  failed to restart, error %d\n",err);
+				return;
+			}
+			asc_fdma_start_tx(port);
+		} else
+			ascdmaport->txdma_running = 0;
+	}
+}
+
+static void asc_txfmda_error(unsigned long param)
+{
+	printk(KERN_ERR "ASC TX FDMA error\n");
+}
+
+static void asc_rxtimer_fn(unsigned long param)
+{
+	struct uart_port *port = (struct uart_port *)param;
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	int residue;
+
+	/* If not running, process and try to run */
+	if (!ascdmaport->rxdma_running) {
+		asc_dma_rxflush(port);
+	} else {
+		/* If receive has paused with data, stop so as to flush all received so far */
+		residue = get_dma_residue(ascdmaport->rxdma_chid);
+		if (residue == ascdmaport->last_residue && (residue != DMA_RXBUFSIZE || 
+                       ascdmaport->rxdmabuf_count[ascdmaport->rxdmabuf_tail] != 0)) {
+			dma_stop_channel(ascdmaport->rxdma_chid);
+			ascdmaport->last_residue = 0;
+		}
+		else
+			ascdmaport->last_residue = residue;
+	}
+
+	/* Reschedule the timer */
+	mod_timer(&ascdmaport->rxpoll_timer, jiffies + RXPOLL_PERIOD);
+}
+
+void asc_fdma_stop_tx(struct uart_port *port)
+{
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+
+	if (ascdmaport->txdma_running) {
+		int i;
+		ascdmaport->txdma_running = 0;
+		for (i=0; i<DMA_TXBUFERS; i++)
+			ascdmaport->txdmabuf_count[i] = 0;
+		ascdmaport->txdmabuf_head = ascdmaport->txdmabuf_tail = 0;
+		dma_stop_channel(ascdmaport->txdma_chid);
+		dma_wait_for_completion(ascdmaport->txdma_chid);
+	}
+}
+
+void asc_fdma_stop_rx(struct uart_port *port)
+{
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	int i;
+
+	del_timer_sync(&ascdmaport->rxpoll_timer);
+
+	if (ascdmaport->rxdma_running) {
+		ascdmaport->rxdma_running = 0;
+		dma_stop_channel(ascdmaport->rxdma_chid);
+	}
+
+	for (i=0; i<DMA_RXBUFERS; i++)
+		ascdmaport->rxdmabuf_count[i] = 0;
+	ascdmaport->rxdmabuf_head = ascdmaport->rxdmabuf_tail = 0;
+}
+
+static struct stm_dma_req_config rx_dma_req_config = {
+	.rw		= REQ_CONFIG_READ,
+	.opcode		= REQ_CONFIG_OPCODE_1,
+	.count		= 4,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 1,
+};
+
+static struct stm_dma_req_config tx_dma_req_config = {
+	.rw		= REQ_CONFIG_WRITE,
+	.opcode		= REQ_CONFIG_OPCODE_1,
+	.count		= 1,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 1,
+};
+
+int asc_enable_fdma(struct uart_port *port)
+{
+	struct asc_port *ascport = &asc_ports[port->line];
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+	const char * fdmac_id =STM_DMAC_ID;
+	const char * lb_cap_channel = STM_DMA_CAP_LOW_BW;
+	/* Allocate the 2 DMA channels */
+
+	if (!ascport->dma_enabled) {
+		int i, err=0;
+		ascdmaport->rxdma_chid = request_dma_bycap(&fdmac_id,&lb_cap_channel, "ASC_RX");
+		if (ascdmaport->rxdma_chid < 0) {
+			return -EBUSY;
+		}
+
+		ascdmaport->txdma_chid = request_dma_bycap(&fdmac_id,&lb_cap_channel, "ASC_TX");
+		if (ascdmaport->txdma_chid < 0) {
+			free_dma(ascdmaport->rxdma_chid);
+			return -EBUSY;
+		}
+
+		/* Allocate tx/rx DMA buffers and get the DMA channels */
+		for (i=0; i<DMA_RXBUFERS; i++) {
+			ascdmaport->rxdmabuf[i] = kmalloc(DMA_RXBUFSIZE, __GFP_DMA | GFP_KERNEL);
+			ascdmaport->rxdmabuf_count[i] = 0;
+		}
+		for (i=0; i<DMA_TXBUFERS; i++) {
+			ascdmaport->txdmabuf[i] = kmalloc(DMA_TXBUFSIZE, __GFP_DMA | GFP_KERNEL);
+			ascdmaport->txdmabuf_count[i] = 0;
+		}
+
+		ascdmaport->rxdmabuf_head = 0;
+		ascdmaport->rxdmabuf_tail = 0;
+		ascdmaport->txdmabuf_head = 0;
+		ascdmaport->txdmabuf_tail = 0;
+
+		ascdmaport->rxdma_running = 0;
+
+		/* Set up the rx DMA parameters */
+		dma_params_init(&ascdmaport->rxdmap,
+			       MODE_PACED,
+			       STM_DMA_LIST_OPEN);
+
+		//dma_params_interrupts(&ascdmaport->rxdmap,STM_DMA_LIST_COMP_INT);
+
+		dma_params_comp_cb(&ascdmaport->rxdmap,
+				   asc_rxfmda_done,
+				   (unsigned long)port,
+				   STM_DMA_CB_CONTEXT_TASKLET);
+
+		dma_params_err_cb(&ascdmaport->rxdmap,
+				  asc_rxfmda_error,
+				  (unsigned long)port,
+				  STM_DMA_CB_CONTEXT_TASKLET);
+
+		dma_params_addrs(&ascdmaport->rxdmap,
+				virt_to_phys((void*)(port->mapbase + ASC_RXBUF)),
+				virt_to_phys(ascdmaport->rxdmabuf[0]),
+				DMA_RXBUFSIZE);
+
+		ascdmaport->rx_dma_req = dma_req_config(ascdmaport->rxdma_chid,
+					    FDMA_RXREQ[port->line],
+					    &rx_dma_req_config);
+		if (ascdmaport->rx_dma_req == NULL) {
+			printk(KERN_ERR "%s DMA req line %ld not available\n",
+			       __FUNCTION__, FDMA_RXREQ[port->line]);
+			return -EBUSY;
+		}
+
+		dma_params_req(&ascdmaport->rxdmap, ascdmaport->rx_dma_req);
+
+		dma_params_DIM_0_x_1(&ascdmaport->rxdmap);
+
+		if((err=dma_compile_list(ascdmaport->rxdma_chid, &ascdmaport->rxdmap, GFP_KERNEL)) < 0) {
+			printk(KERN_ERR "%s RX failed, err %d\n",__FUNCTION__,err);
+			return -ENODEV;
+		}
+
+		/* Set up the tx DMA parameters */
+		ascdmaport->txdma_running = 0;
+
+		dma_params_init(&ascdmaport->txdmap,
+				  MODE_PACED,
+				  STM_DMA_LIST_OPEN);
+
+		//dma_params_interrupts(&ascdmaport->txdmap,STM_DMA_LIST_COMP_INT);
+
+		dma_params_comp_cb(&ascdmaport->txdmap,
+				  asc_txfmda_done,
+				  (unsigned long)port,
+				  STM_DMA_CB_CONTEXT_TASKLET);
+
+		dma_params_err_cb(&ascdmaport->txdmap,
+				 asc_txfmda_error,
+				 (unsigned long)port,
+				 STM_DMA_CB_CONTEXT_TASKLET);
+
+		ascdmaport->tx_dma_req = dma_req_config(ascdmaport->txdma_chid,
+					    FDMA_TXREQ[port->line],
+					    &tx_dma_req_config);
+		if (ascdmaport->tx_dma_req == NULL) {
+			printk(KERN_ERR "%s DMA req line %ld not available\n",
+			       __FUNCTION__, FDMA_TXREQ[port->line]);
+			return -EBUSY;
+		}
+
+		dma_params_req(&ascdmaport->txdmap, ascdmaport->tx_dma_req);
+
+		/* We can delay compilation of the transmit descriptor until
+		 * we know which port we are on*/
+
+		/* Disable rx/tx interrupts */
+		asc_out(port, INTEN, asc_in(port, INTEN) & ~(ASC_INTEN_THE | ASC_INTEN_RBE));
+		ascport->dma_enabled = 1;
+
+		/* Start reception going */
+		ascdmaport->last_residue = 0;
+		dma_cache_wback_inv(ascdmaport->rxdmabuf[0], DMA_RXBUFSIZE);
+		if ((err = dma_xfer_list(ascdmaport->rxdma_chid,&ascdmaport->rxdmap)) < 0)
+			printk(KERN_ERR "ASC RX FDMA failed to start - error %d\n",err);
+		else
+			ascdmaport->rxdma_running = 1;
+
+		/* Start reception poll timer going */
+		init_timer(&ascdmaport->rxpoll_timer);
+		ascdmaport->rxpoll_timer.function = asc_rxtimer_fn;
+		ascdmaport->rxpoll_timer.data = (unsigned long)port;
+		ascdmaport->rxpoll_timer.expires = jiffies + RXPOLL_PERIOD;
+		add_timer(&ascdmaport->rxpoll_timer);
+	}
+
+	return 0;
+}
+
+void asc_disable_fdma(struct uart_port *port)
+{
+	struct asc_port *ascport = &asc_ports[port->line];
+	struct asc_dma_port *ascdmaport = &asc_dma_ports[port->line];
+
+	if (ascport->dma_enabled) {
+		int i;
+
+		/* Stop and release DMA and buffer resources */
+		asc_fdma_stop_rx(port);
+		asc_fdma_stop_tx(port);
+		free_dma(ascdmaport->rxdma_chid);
+		free_dma(ascdmaport->txdma_chid);
+		dma_params_free(&ascdmaport->rxdmap);
+		dma_params_free(&ascdmaport->txdmap);
+		memset(&ascdmaport->rxdmap,0,sizeof(struct stm_dma_params));
+		memset(&ascdmaport->txdmap,0,sizeof(struct stm_dma_params));
+
+		for (i=0; i<DMA_RXBUFERS; i++) {
+			kfree(ascdmaport->rxdmabuf[i]);
+			ascdmaport->rxdmabuf[i] = NULL;
+		}
+		for (i=0; i<DMA_TXBUFERS; i++) {
+			kfree(ascdmaport->txdmabuf[i]);
+			ascdmaport->txdmabuf[i] = NULL;
+		}
+		ascport->dma_enabled = 0;
+	}
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/stasc.c linux-2.6.23.1-stm/drivers/serial/stasc.c
--- linux-2.6.23.1/drivers/serial/stasc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/serial/stasc.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1055 @@
+/*
+ *  drivers/serial/stasc.c
+ *  Asynchronous serial controller (ASC) driver
+ */
+
+#if defined(CONFIG_SERIAL_ST_ASC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/sysrq.h>
+#include <linux/serial.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/stm/pio.h>
+#include <linux/generic_serial.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/clock.h>
+
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+#endif
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+#include <asm/sh_bios.h>
+#endif
+
+#include "stasc.h"
+
+#define DRIVER_NAME "stasc"
+
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+/* This is used as a system console, set by serial_console_setup */
+static struct console asc_console;
+#endif
+
+struct asc_port asc_ports[ASC_MAX_PORTS];
+
+/*---- Forward function declarations---------------------------*/
+static int  asc_request_irq(struct uart_port *);
+static void asc_free_irq(struct uart_port *);
+static void asc_transmit_chars(struct uart_port *);
+static int asc_remap_port(struct asc_port *ascport, int req);
+void        asc_set_termios_cflag (struct asc_port *, int ,int);
+static inline void asc_receive_chars(struct uart_port *);
+
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+static void asc_console_write (struct console *, const char *,
+				  unsigned );
+static int __init asc_console_setup (struct console *, char *);
+#endif
+
+#ifdef CONFIG_SH_KGDB
+int kgdb_asc_setup(void);
+static void kgdb_put_char(struct uart_port *port, char c);
+static struct asc_port *kgdb_asc_port;
+#ifdef CONFIG_SH_KGDB_CONSOLE
+static struct console kgdb_console;
+static struct tty_driver *kgdb_console_device(struct console *, int *);
+static int __init kgdb_console_setup(struct console *, char *);
+#endif
+#endif
+
+/*---- Inline function definitions ---------------------------*/
+
+/* Some simple utility functions to enable and disable interrupts.
+ * Note that these need to be called with interrupts disabled.
+ */
+static inline void asc_disable_tx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Clear TE (Transmitter empty) interrupt enable in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable &= ~ASC_INTEN_THE;
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_enable_tx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Set TE (Transmitter empty) interrupt enable in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable |= ASC_INTEN_THE;
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_disable_rx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Clear RBE (Receive Buffer Full Interrupt Enable) bit in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable &= ~ASC_INTEN_RBE;
+	asc_out(port, INTEN, intenable);
+}
+
+
+static inline void asc_enable_rx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Set RBE (Receive Buffer Full Interrupt Enable) bit in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable |= ASC_INTEN_RBE;
+	asc_out(port, INTEN, intenable);
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * UART Functions
+ */
+
+static unsigned int asc_tx_empty(struct uart_port *port)
+{
+	unsigned long status;
+
+	status = asc_in(port, STA);
+	if (status & ASC_STA_TE)
+		return TIOCSER_TEMT;
+	return 0;
+}
+
+static void asc_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* This routine is used for seting signals of: DTR, DCD, CTS/RTS
+	 * We use ASC's hardware for CTS/RTS, so don't need any for that.
+	 * Some boards have DTR and DCD implemented using PIO pins,
+	 * code to do this should be hooked in here.
+	 */
+}
+
+static unsigned int asc_get_mctrl(struct uart_port *port)
+{
+	/* This routine is used for geting signals of: DTR, DCD, DSR, RI,
+	   and CTS/RTS */
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+/*
+ * There are probably characters waiting to be transmitted.
+ * Start doing so.
+ * The port lock is held and interrupts are disabled.
+ */
+static void asc_start_tx(struct uart_port *port)
+{
+	if (asc_dma_enabled(port))
+		asc_fdma_start_tx(port);
+	else
+		asc_transmit_chars(port);
+}
+
+/*
+ * Transmit stop - interrupts disabled on entry
+ */
+static void asc_stop_tx(struct uart_port *port)
+{
+	if (asc_dma_enabled(port))
+		asc_fdma_stop_tx(port);
+	else
+		asc_disable_tx_interrupts(port);
+}
+
+/*
+ * Receive stop - interrupts still enabled on entry
+ */
+static void asc_stop_rx(struct uart_port *port)
+{
+	if (asc_dma_enabled(port))
+		asc_fdma_stop_rx(port);
+	else
+		asc_disable_rx_interrupts(port);
+}
+
+/*
+ * Force modem status interrupts on - no-op for us
+ */
+static void asc_enable_ms(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+/*
+ * Handle breaks - ignored by us
+ */
+static void asc_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Nothing here yet .. */
+}
+
+/*
+ * Enable port for reception.
+ * port_sem held and interrupts disabled
+ */
+static int asc_startup(struct uart_port *port)
+{
+	asc_request_irq(port);
+	asc_transmit_chars(port);
+	asc_enable_rx_interrupts(port);
+
+	return 0;
+}
+
+static void asc_shutdown(struct uart_port *port)
+{
+	if (asc_dma_enabled(port))
+		asc_disable_fdma(port);
+	asc_disable_tx_interrupts(port);
+	asc_disable_rx_interrupts(port);
+	asc_free_irq(port);
+}
+
+static void asc_set_termios(struct uart_port *port, struct ktermios *termios,
+			    struct ktermios *old)
+{
+	struct asc_port *ascport = container_of(port, struct asc_port, port);
+	unsigned int baud;
+
+	baud = uart_get_baud_rate(port, termios, old, 0,
+				  port->uartclk/16);
+
+	asc_set_termios_cflag(ascport, termios->c_cflag, baud);
+}
+static const char *asc_type(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	return pdev->name;
+}
+
+static void asc_release_port(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	release_mem_region(port->mapbase, size);
+
+	if (port->flags & UPF_IOREMAP) {
+		iounmap(port->membase);
+		port->membase = NULL;
+	}
+}
+
+static int asc_request_port(struct uart_port *port)
+{
+	struct asc_port *ascport = container_of(port, struct asc_port, port);
+
+	return asc_remap_port(ascport, 1);
+}
+
+/* Called when the port is opened, and UPF_BOOT_AUTOCONF flag is set */
+/* Set type field if successful */
+static void asc_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_ASC;
+		asc_request_port(port);
+	}
+}
+
+static int
+asc_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	/* No user changeable parameters */
+	return -EINVAL;
+}
+
+/*---------------------------------------------------------------------*/
+
+static struct uart_ops asc_uart_ops = {
+	.tx_empty	= asc_tx_empty,
+	.set_mctrl	= asc_set_mctrl,
+	.get_mctrl	= asc_get_mctrl,
+	.start_tx	= asc_start_tx,
+	.stop_tx	= asc_stop_tx,
+	.stop_rx	= asc_stop_rx,
+	.enable_ms	= asc_enable_ms,
+	.break_ctl	= asc_break_ctl,
+	.startup	= asc_startup,
+	.shutdown	= asc_shutdown,
+	.set_termios	= asc_set_termios,
+	.type		= asc_type,
+	.release_port	= asc_release_port,
+	.request_port	= asc_request_port,
+	.config_port	= asc_config_port,
+	.verify_port	= asc_verify_port,
+};
+
+static void __devinit asc_init_port(struct asc_port *ascport,
+				    struct platform_device *pdev)
+{
+	struct uart_port *port = &ascport->port;
+	struct stasc_uart_data *data = pdev->dev.platform_data;
+	struct clk *clk;
+	unsigned long rate;
+	int i;
+
+	port->iotype	= UPIO_MEM;
+	port->flags	= UPF_BOOT_AUTOCONF;
+	port->ops	= &asc_uart_ops,
+	port->fifosize	= FIFO_SIZE;
+	port->line	= pdev->id;
+	port->dev	= &pdev->dev;
+
+	port->mapbase	= pdev->resource[0].start;
+	port->irq	= pdev->resource[1].start;
+
+	/* Assume that we can always use ioremap */
+	port->flags	|= UPF_IOREMAP;
+	port->membase	= NULL;
+
+	clk = clk_get(NULL, "comms_clk");
+	if (IS_ERR(clk)) clk = clk_get(NULL, "bus_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+
+	ascport->port.uartclk = rate;
+
+	ascport->pio_port = data->pio_port;
+	for (i=0; i<4; i++)
+		ascport->pio_pin[i] = data->pio_pin[i];
+}
+
+static struct uart_driver asc_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRIVER_NAME,
+	.dev_name	= "ttyAS",
+	.major		= ASC_MAJOR,
+	.minor		= ASC_MINOR_START,
+	.nr		= ASC_MAX_PORTS,
+	.cons		= &asc_console,
+};
+
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+static struct console asc_console = {
+	.name		= "ttyAS",
+	.device		= uart_console_device,
+	.write		= asc_console_write,
+	.setup		= asc_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &asc_uart_driver,
+};
+
+/*
+ * Early console initialization.
+ */
+static int __init asc_console_init(void)
+{
+	if (asc_default_console_device) {
+		add_preferred_console("ttyAS", asc_default_console_device->id,
+				      NULL);
+		asc_init_port(&asc_ports[asc_default_console_device->id],
+			      asc_default_console_device);
+		register_console(&asc_console);
+        }
+
+        return 0;
+}
+console_initcall(asc_console_init);
+
+/*
+ * Late console initialization.
+ */
+static int __init asc_late_console_init(void)
+{
+	if (asc_default_console_device && !(asc_console.flags & CON_ENABLED))
+		register_console(&asc_console);
+
+        return 0;
+}
+core_initcall(asc_late_console_init);
+#endif
+
+static int __devinit asc_serial_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct asc_port *ascport = &asc_ports[pdev->id];
+
+	asc_init_port(ascport, pdev);
+
+	ret = uart_add_one_port(&asc_uart_driver, &ascport->port);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, &ascport->port);
+        }
+
+	return ret;
+}
+
+static int __devexit asc_serial_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+
+        platform_set_drvdata(pdev, NULL);
+	return uart_remove_one_port(&asc_uart_driver, port);
+}
+
+static struct platform_driver asc_serial_driver = {
+	.probe		= asc_serial_probe,
+	.remove		= __devexit_p(asc_serial_remove),
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init asc_init(void)
+{
+	int ret;
+	static char banner[] __initdata =
+		KERN_INFO "STMicroelectronics ASC driver initialized\n";
+
+	printk(banner);
+
+	asc_fdma_setreq();
+
+	ret = uart_register_driver(&asc_uart_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&asc_serial_driver);
+	if (ret)
+		uart_unregister_driver(&asc_uart_driver);
+
+	return ret;
+}
+
+static void __exit asc_exit(void)
+{
+	platform_driver_unregister(&asc_serial_driver);
+	uart_unregister_driver(&asc_uart_driver);
+}
+
+module_init(asc_init);
+module_exit(asc_exit);
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ASC serial port driver");
+MODULE_LICENSE("GPL");
+
+/*----------------------------------------------------------------------*/
+
+/* This sections contains code to support the use of the ASC as a
+ * generic serial port.
+ */
+
+static int asc_remap_port(struct asc_port *ascport, int req)
+{
+	struct uart_port *port = &ascport->port;
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	int i;
+	static int pio_dirs[4] = {
+		STPIO_ALT_OUT,	/* Tx */
+		STPIO_IN,	/* Rx */
+		STPIO_IN,	/* CTS */
+		STPIO_ALT_OUT	/* RTS */
+	};
+
+	if (req && !request_mem_region(port->mapbase, size, pdev->name))
+		return -EBUSY;
+
+	/* We have already been remapped for the console */
+	if (port->membase)
+		return 0;
+
+	if (port->flags & UPF_IOREMAP) {
+		port->membase = ioremap(port->mapbase, size);
+		if (port->membase == NULL) {
+			release_mem_region(port->mapbase, size);
+			return -ENOMEM;
+		}
+	}
+
+	for (i=0; i<4; i++) {
+		ascport->pios[i] = stpio_request_pin(ascport->pio_port,
+			ascport->pio_pin[0], DRIVER_NAME, pio_dirs[i]);
+	}
+
+	return 0;
+}
+
+static int asc_set_baud (struct uart_port *port, int baud)
+{
+	unsigned int t;
+	unsigned long rate;
+
+	rate = port->uartclk;
+
+	if (baud < 19200) {
+		t = BAUDRATE_VAL_M0(baud, rate);
+		asc_out (port, BAUDRATE, t);
+		return 0;
+	} else {
+		t = BAUDRATE_VAL_M1(baud, rate);
+		asc_out (port, BAUDRATE, t);
+		return ASC_CTL_BAUDMODE;
+	}
+}
+
+void
+asc_set_termios_cflag (struct asc_port *ascport, int cflag, int baud)
+{
+	struct uart_port *port = &ascport->port;
+	unsigned int ctrl_val;
+	unsigned long flags;
+
+	/* wait for end of current transmission */
+	while (!asc_tx_empty(port)){};
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* read control register */
+	ctrl_val = asc_in (port, CTL);
+
+	/* stop serial port and reset value */
+	asc_out (port, CTL, (ctrl_val & ~ASC_CTL_RUN));
+	ctrl_val = ASC_CTL_RXENABLE | ASC_CTL_FIFOENABLE;
+
+	/* reset fifo rx & tx */
+	asc_out (port, TXRESET, 1);
+	asc_out (port, RXRESET, 1);
+
+	/* set character length */
+	if ((cflag & CSIZE) == CS7)
+		ctrl_val |= ASC_CTL_MODE_7BIT_PAR;
+	else {
+		if (cflag & PARENB)
+			ctrl_val |= ASC_CTL_MODE_8BIT_PAR;
+		else
+			ctrl_val |= ASC_CTL_MODE_8BIT;
+	}
+
+	/* set stop bit */
+	if (cflag & CSTOPB)
+		ctrl_val |= ASC_CTL_STOP_2BIT;
+	else
+		ctrl_val |= ASC_CTL_STOP_1BIT;
+
+	/* odd parity */
+	if (cflag & PARODD)
+		ctrl_val |= ASC_CTL_PARITYODD;
+
+	/* hardware flow control */
+	if (cflag & CRTSCTS)
+		ctrl_val |= ASC_CTL_CTSENABLE;
+
+	/* hardware flow control */
+	if (cflag & CRTSCTS)
+		ctrl_val |= ASC_CTL_CTSENABLE;
+
+	/* set speed and baud generator mode */
+	ctrl_val |= asc_set_baud (port, baud);
+	uart_update_timeout(port, cflag, baud);
+
+	/* Undocumented feature: use max possible baud */
+	if (cflag & 0020000)
+		asc_out (port, BAUDRATE, 0x0000ffff);
+
+	/* Undocumented feature: use DMA */
+	if (cflag & 0040000)
+		asc_enable_fdma(port);
+	else
+		asc_disable_fdma(port);
+
+	/* Undocumented feature: use local loopback */
+	if (cflag & 0100000)
+		ctrl_val |= ASC_CTL_LOOPBACK;
+
+	/* Set the timeout */
+	asc_out(port, TIMEOUT, 16);
+
+	/* write final value and enable port */
+	asc_out (port, CTL, (ctrl_val | ASC_CTL_RUN));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+
+static inline unsigned asc_hw_txroom(struct uart_port* port)
+{
+	unsigned long status;
+
+	status = asc_in(port, STA);
+	if (status & ASC_STA_THE) {
+		return FIFO_SIZE/2;
+	} else if (! (status & ASC_STA_TF)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * Start transmitting chars.
+ * This is called from both interrupt and task level.
+ * Either way interrupts are disabled.
+ */
+static void asc_transmit_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int txroom;
+	unsigned long intenable;
+	unsigned char c;
+
+	txroom = asc_hw_txroom(port);
+
+	if ((txroom != 0) && port->x_char) {
+		c = port->x_char;
+		port->x_char = 0;
+		asc_out (port, TXBUF, c);
+		port->icount.tx++;
+		txroom = asc_hw_txroom(port);
+	}
+
+	while (txroom > 0) {
+		if (uart_tx_stopped(port) || uart_circ_empty(xmit)) {
+			break;
+		}
+
+		do {
+			c = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			asc_out (port, TXBUF, c);
+			port->icount.tx++;
+			txroom--;
+		} while ((txroom > 0) && (!uart_circ_empty(xmit)));
+
+		txroom = asc_hw_txroom(port);
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(port);
+	}
+
+	intenable = asc_in(port, INTEN);
+	if (port->x_char || (!uart_circ_empty(xmit))) {
+		intenable |= ASC_INTEN_THE;
+	} else {
+		intenable &= ~ASC_INTEN_THE;
+	}
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_receive_chars(struct uart_port *port)
+{
+	int count;
+	struct tty_struct *tty = port->info->tty;
+	int copied=0;
+	unsigned long status;
+	unsigned long c = 0;
+	char flag;
+	int overrun;
+
+	while (1) {
+		status = asc_in(port, STA);
+		if (status & ASC_STA_RHF) {
+			count = FIFO_SIZE / 2;
+		} else if (status & ASC_STA_RBF) {
+			count = 1;
+		} else {
+			count = 0;
+		}
+
+		/* Check for overrun before reading any data from the
+		 * RX FIFO, as this clears the overflow error condition. */
+		overrun = status & ASC_STA_OE;
+
+		/* Don't copy more bytes than there are room for in the buffer */
+		count = tty_buffer_request_room(tty, count);
+
+		/* If for any reason we can't copy more data, we're done! */
+		if (count == 0)
+			break;
+
+		for ( ; count != 0; count--) {
+			c = asc_in(port, RXBUF);
+			flag = TTY_NORMAL;
+			port->icount.rx++;
+
+			if (unlikely(c & ASC_RXBUF_FE)) {
+				if (c == ASC_RXBUF_FE) {
+					port->icount.brk++;
+					if (uart_handle_break(port))
+						continue;
+					flag = TTY_BREAK;
+				} else {
+					port->icount.frame++;
+					flag = TTY_FRAME;
+				}
+			} else if (unlikely(c & ASC_RXBUF_PE)) {
+				port->icount.parity++;
+				flag = TTY_PARITY;
+			}
+
+			if (uart_handle_sysrq_char(port, c))
+				continue;
+			tty_insert_flip_char(tty, c & 0xff, flag);
+		}
+
+		if (overrun) {
+			port->icount.overrun++;
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
+
+		copied=1;
+	}
+
+	if (copied) {
+		/* Tell the rest of the system the news. New characters! */
+		tty_flip_buffer_push(tty);
+	}
+}
+
+static irqreturn_t asc_interrupt(int irq, void *ptr)
+{
+	struct uart_port *port = ptr;
+	unsigned long status;
+
+	spin_lock(&port->lock);
+
+	status = asc_in (port, STA);
+	if (status & ASC_STA_RBF) {
+		/* Receive FIFO not empty */
+		asc_receive_chars(port);
+	}
+
+	if ((status & ASC_STA_THE) && (asc_in(port, INTEN) & ASC_INTEN_THE)) {
+		/* Transmitter FIFO at least half empty */
+		asc_transmit_chars(port);
+	}
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int asc_request_irq(struct uart_port *port)
+{
+        struct platform_device *pdev = to_platform_device(port->dev);
+
+	if (request_irq(port->irq, asc_interrupt, 0,
+			pdev->name, port)) {
+		printk(KERN_ERR "stasc: cannot allocate irq.\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void asc_free_irq(struct uart_port *port)
+{
+	free_irq(port->irq, port);
+}
+
+/*----------------------------------------------------------------------*/
+
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+
+static int get_char(struct uart_port *port)
+{
+        int c;
+	unsigned long status;
+
+	do {
+		status = asc_in(port, STA);
+	} while (! (status & ASC_STA_RBF));
+
+	c = asc_in(port, RXBUF);
+
+        return c;
+}
+
+/* Taken from sh-stub.c of GDB 4.18 */
+static const char hexchars[] = "0123456789abcdef";
+
+static __inline__ char highhex(int  x)
+{
+	return hexchars[(x >> 4) & 0xf];
+}
+
+static __inline__ char lowhex(int  x)
+{
+	return hexchars[x & 0xf];
+}
+#endif
+
+static void
+put_char (struct uart_port *port, char c)
+{
+	unsigned long flags;
+	unsigned long status;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	do {
+		status = asc_in (port, STA);
+	} while (status & ASC_STA_TF);
+
+	asc_out (port, TXBUF, c);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Send the packet in buffer.  The host gets one chance to read it.
+ * This routine does not wait for a positive acknowledge.
+ */
+
+static void
+put_string (struct uart_port *port, const char *buffer, int count)
+{
+	int i;
+	const unsigned char *p = buffer;
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+	int checksum;
+	int usegdb=0;
+
+    	/* This call only does a trap the first time it is
+	 * called, and so is safe to do here unconditionally
+	 */
+	usegdb |= sh_bios_in_gdb_mode();
+#ifdef CONFIG_SH_KGDB
+	usegdb |= (kgdb_in_gdb_mode && (port == &kgdb_asc_port->port));
+#endif
+
+	if (usegdb) {
+	    /*  $<packet info>#<checksum>. */
+	    do {
+		unsigned char c;
+		put_char(port, '$');
+		put_char(port, 'O'); /* 'O'utput to console */
+		checksum = 'O';
+
+		for (i=0; i<count; i++) { /* Don't use run length encoding */
+			int h, l;
+
+			c = *p++;
+			h = highhex(c);
+			l = lowhex(c);
+			put_char(port, h);
+			put_char(port, l);
+			checksum += h + l;
+		}
+		put_char(port, '#');
+		put_char(port, highhex(checksum));
+		put_char(port, lowhex(checksum));
+	    } while  (get_char(port) != '+');
+	} else
+#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+
+	for (i = 0; i < count; i++) {
+		if (*p == 10)
+			put_char (port, '\r');
+		put_char (port, *p++);
+	}
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ *  Setup initial baud/bits/parity. We do two things here:
+ *	- construct a cflag setting for the first rs_open()
+ *	- initialize the serial port
+ *  Return non-zero if we didn't find a serial port.
+ */
+
+static int __init
+asc_console_setup (struct console *co, char *options)
+{
+	struct asc_port *ascport = &asc_ports[co->index];
+	int     baud = 9600;
+	int     bits = 8;
+	int     parity = 'n';
+	int     flow = 'n';
+	int ret;
+
+#if 0
+	if (ascport->port.membase == 0)	/* Port not initialized yet - delay setup */
+		return -ENODEV;
+#endif
+
+	if ((ret = asc_remap_port(ascport, 0)) != 0)
+		return ret;
+
+	if (options) {
+                uart_parse_options(options, &baud, &parity, &bits, &flow);
+	}
+
+	return uart_set_options(&ascport->port, co, baud, parity, bits, flow);
+}
+
+/*
+ *  Print a string to the serial port trying not to disturb
+ *  any possible real use of the port...
+ */
+
+static void
+asc_console_write (struct console *co, const char *s, unsigned count)
+{
+	struct uart_port *port = &asc_ports[co->index].port;
+
+	put_string(port, s, count);
+}
+
+/*----------------------------------------------------------------------*/
+/* KGDB ASC functions */
+
+#ifdef CONFIG_SH_KGDB
+/* write a char */
+static void kgdb_put_char(struct uart_port *port, char c)
+{
+	unsigned long flags;
+	unsigned long status;
+
+	local_irq_save(flags);
+
+	do {
+		status = asc_in (port, STA);
+	} while (status & ASC_STA_TF);
+
+	asc_out (port, TXBUF, c);
+
+	local_irq_restore(flags);
+}
+
+/* Called from stub to put a character */
+static void kgdb_asc_putchar(int c)
+{
+        kgdb_put_char(&kgdb_asc_port->port, c);
+}
+
+/* Called from stub to get a character, i.e. is blocking */
+static int kgdb_asc_getchar(void)
+{
+	return get_char(&kgdb_asc_port->port);
+}
+
+/* Initialise the KGDB serial port.
+   Called from stub to setup the debug port
+*/
+int kgdb_asc_setup(void)
+{
+	int cflag = CREAD | HUPCL | CLOCAL | CSTOPB;
+
+	if ((kgdb_portnum < 0) || (kgdb_portnum >= ASC_NPORTS))
+	{
+		printk (KERN_ERR "stasc: invalid ASC port number\n");
+		return -1;
+	}
+
+        kgdb_asc_port = &asc_ports[kgdb_portnum];
+
+	switch (kgdb_baud) {
+        case 115200:
+                cflag |= B115200;
+                break;
+	case 57600:
+                cflag |= B57600;
+                break;
+        case 38400:
+                cflag |= B38400;
+                break;
+        case 19200:
+                cflag |= B19200;
+                break;
+	case 9600:
+		cflag = B9600;
+		break;
+        default:
+                cflag |= B115200;
+                kgdb_baud = 115200;
+		printk (KERN_WARNING "stasc: force the kgdb baud as %d\n",
+			kgdb_baud);
+                break;
+        }
+
+	switch (kgdb_bits) {
+        case '7':
+                cflag |= CS7;
+                break;
+        default:
+        case '8':
+                cflag |= CS8;
+                break;
+        }
+
+        switch (kgdb_parity) {
+        case 'O':
+                cflag |= PARODD;
+                break;
+        case 'E':
+                cflag |= PARENB;
+                break;
+        }
+        kgdb_cflag = cflag;
+        asc_set_termios_cflag(kgdb_asc_port, kgdb_cflag, kgdb_baud);
+
+	/* Setup complete: initialize function pointers */
+	kgdb_getchar = kgdb_asc_getchar;
+	kgdb_putchar = kgdb_asc_putchar;
+
+        return 0;
+}
+
+#ifdef CONFIG_SH_KGDB_CONSOLE
+/* Create a console device */
+static struct tty_driver *kgdb_console_device(struct console *co, int *index)
+{
+	struct uart_driver *p = co->data;
+	*index = co->index;
+	return p->tty_driver;
+}
+
+/* Set up the KGDB console */
+static int __init kgdb_console_setup(struct console *co, char *options)
+{
+        /* NB we ignore 'options' because we've already done the setup */
+        co->cflag = kgdb_cflag;
+        return 0;
+}
+
+/* The console structure for KGDB */
+static struct console kgdb_console= {
+	.name		= "ttyAS",
+	.device		= kgdb_console_device,
+	.write		= kgdb_console_write,
+	.setup		= kgdb_console_setup,
+	.flags		= CON_PRINTBUFFER | CON_ENABLED,
+	.index		= -1,
+	.data		= &asc_uart_driver,
+};
+
+#ifdef CONFIG_KGDB_DEFTYPE_ASC
+/* Register the KGDB console so we get messages (d'oh!) */
+int __init kgdb_console_init(void)
+{
+        register_console(&kgdb_console);
+	return 0;
+}
+console_initcall(kgdb_console_init);
+#endif
+#endif /* CONFIG_SH_KGDB_CONSOLE */
+#endif /* CONFIG_SH_KGDB */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/serial/stasc.h linux-2.6.23.1-stm/drivers/serial/stasc.h
--- linux-2.6.23.1/drivers/serial/stasc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/serial/stasc.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,203 @@
+/*
+ *  drivers/char/stasc.h
+ *
+ *  ST40 Asynchronous serial controller (ASC) driver
+ *  Derived from sh-sci.h
+ *  Copyright (c) STMicroelectronics Limited
+ *  Author: Andrea Cisternino (March 2003)
+ *
+ *  Documentation for the Asynchronous Serial Controller in the STm8000 SoC
+ *  can be found in the following documents:
+ *
+ *    1) DVD Platform Architecture Volume 4: I/O Devices (ADCS: 7402381)
+ *    2) STm8000 Datasheet (ADCS: 7323276)
+ */
+
+#include <linux/serial_core.h>
+
+struct asc_port
+{
+	struct uart_port port;
+	unsigned char pio_port;
+	unsigned char pio_pin[4]; /* Tx, Rx, CTS, RTS */
+	struct stpio_pin *pios[4];
+	int     break_flag;
+	int dma_enabled;
+};
+
+#define ASC_MAJOR		204
+#define ASC_MINOR_START		40
+
+/* Generic serial flags */
+#define ASC_RX_THROTTLE		0x0000001
+
+#define FIFO_SIZE		16
+
+#define ASC_MAX_PORTS		4
+
+/*---- Global variables ---------------------------------------*/
+
+extern struct asc_port asc_ports[ASC_MAX_PORTS];
+
+/*---- UART Register definitions ------------------------------*/
+
+/* Register offsets */
+
+#define ASC_BAUDRATE			0x00
+#define ASC_TXBUF			0x04
+#define ASC_RXBUF			0x08
+#define ASC_CTL				0x0C
+#define ASC_INTEN			0x10
+#define ASC_STA				0x14
+#define ASC_GUARDTIME			0x18
+#define ASC_TIMEOUT			0x1C
+#define ASC_TXRESET			0x20
+#define ASC_RXRESET			0x24
+#define ASC_RETRIES			0x28
+
+/* ASC_RXBUF */
+#define ASC_RXBUF_PE			0x100
+#define ASC_RXBUF_FE			0x200
+
+/* ASC_CTL */
+
+#define ASC_CTL_MODE_MSK		0x0007
+#define  ASC_CTL_MODE_8BIT		0x0001
+#define  ASC_CTL_MODE_7BIT_PAR		0x0003
+#define  ASC_CTL_MODE_9BIT		0x0004
+#define  ASC_CTL_MODE_8BIT_WKUP		0x0005
+#define  ASC_CTL_MODE_8BIT_PAR		0x0007
+#define ASC_CTL_STOP_MSK		0x0018
+#define  ASC_CTL_STOP_HALFBIT		0x0000
+#define  ASC_CTL_STOP_1BIT		0x0008
+#define  ASC_CTL_STOP_1_HALFBIT		0x0010
+#define  ASC_CTL_STOP_2BIT		0x0018
+#define ASC_CTL_PARITYODD		0x0020
+#define ASC_CTL_LOOPBACK		0x0040
+#define ASC_CTL_RUN			0x0080
+#define ASC_CTL_RXENABLE		0x0100
+#define ASC_CTL_SCENABLE		0x0200
+#define ASC_CTL_FIFOENABLE		0x0400
+#define ASC_CTL_CTSENABLE		0x0800
+#define ASC_CTL_BAUDMODE		0x1000
+
+/* ASC_GUARDTIME */
+
+#define ASC_GUARDTIME_MSK		0x00FF
+
+/* ASC_INTEN */
+
+#define ASC_INTEN_RBE			0x0001
+#define ASC_INTEN_TE			0x0002
+#define ASC_INTEN_THE			0x0004
+#define ASC_INTEN_PE			0x0008
+#define ASC_INTEN_FE			0x0010
+#define ASC_INTEN_OE			0x0020
+#define ASC_INTEN_TNE			0x0040
+#define ASC_INTEN_TOI			0x0080
+#define ASC_INTEN_RHF			0x0100
+
+/* ASC_RETRIES */
+
+#define ASC_RETRIES_MSK			0x00FF
+
+/* ASC_RXBUF */
+
+#define ASC_RXBUF_MSK			0x03FF
+
+/* ASC_STA */
+
+#define ASC_STA_RBF			0x0001
+#define ASC_STA_TE			0x0002
+#define ASC_STA_THE			0x0004
+#define ASC_STA_PE			0x0008
+#define ASC_STA_FE			0x0010
+#define ASC_STA_OE			0x0020
+#define ASC_STA_TNE			0x0040
+#define ASC_STA_TOI			0x0080
+#define ASC_STA_RHF			0x0100
+#define ASC_STA_TF			0x0200
+#define ASC_STA_NKD			0x0400
+
+/* ASC_TIMEOUT */
+
+#define ASC_TIMEOUT_MSK			0x00FF
+
+/* ASC_TXBUF */
+
+#define ASC_TXBUF_MSK			0x01FF
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+/*
+ * MODE 0
+ * recommended for low bit rates (below 19.2K)
+ *
+ *                       ICCLK
+ * ASCBaudRate =   ----------------
+ *                   baudrate * 16
+ *
+ * MODE 1
+ * recommended for high bit rates (above 19.2K)
+ *
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------
+ *                          ICCLK
+ */
+
+#define ADJ 1
+#define BAUDRATE_VAL_M0(bps, clk)	((clk) / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps, clk)	( ((bps * (1 << 14)) / ((clk) / (1 << 6)) ) + ADJ )
+
+/*---- Access macros ------------------------------------------*/
+
+#define ASC_FUNC(name, offset)		\
+  static inline unsigned int asc_ ## name ## _in (struct uart_port* port)	\
+  {										\
+    return (readl(port->membase + (offset)));					\
+  }										\
+  static inline void asc_ ## name ## _out (struct uart_port* port, unsigned int value)	\
+  {										\
+    writel(value, port->membase + (offset));					\
+  }
+
+ASC_FUNC(BAUDRATE,  ASC_BAUDRATE)
+ASC_FUNC(TXBUF,     ASC_TXBUF)
+ASC_FUNC(RXBUF,     ASC_RXBUF)
+ASC_FUNC(CTL,       ASC_CTL)
+ASC_FUNC(INTEN,     ASC_INTEN)
+ASC_FUNC(STA,       ASC_STA)
+ASC_FUNC(GUARDTIME, ASC_GUARDTIME)
+ASC_FUNC(TIMEOUT,   ASC_TIMEOUT)
+ASC_FUNC(TXRESET,   ASC_TXRESET)
+ASC_FUNC(RXRESET,   ASC_RXRESET)
+ASC_FUNC(RETRIES,   ASC_RETRIES)
+
+#define asc_in(port, reg)		asc_ ## reg ## _in (port)
+#define asc_out(port, reg, value)	asc_ ## reg ## _out ((port), (value))
+
+/*---- DMA interface ------------------------------------------*/
+
+#ifdef CONFIG_SERIAL_ST_ASC_DMA
+static int inline asc_dma_enabled(struct uart_port* port)
+{
+	struct asc_port *ascport = &asc_ports[port->line];
+	return ascport->dma_enabled;
+}
+void asc_fdma_setreq(void);
+int asc_enable_fdma(struct uart_port *port);
+void asc_disable_fdma(struct uart_port *port);
+#else
+static int inline asc_dma_enabled(struct uart_port* ascport)
+{
+	return 0;
+}
+static void inline asc_fdma_setreq(void) { }
+static int inline asc_enable_fdma(struct uart_port *port) { return -ENOSYS; }
+static void inline asc_disable_fdma(struct uart_port *port) { }
+#endif
+
+void asc_fdma_setreq(void);
+void asc_fdma_start_tx(struct uart_port *port);
+void asc_fdma_stop_tx(struct uart_port *port);
+void asc_fdma_stop_rx(struct uart_port *port);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/710x_fdma2.c linux-2.6.23.1-stm/drivers/stm/710x_fdma2.c
--- linux-2.6.23.1/drivers/stm/710x_fdma2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/710x_fdma2.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,1379 @@
+/*
+ * Copyright (C) 2005,7 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/dmapool.h>
+#include <linux/stm/fdma-plat.h>
+#include <linux/stm/stm-dma.h>
+
+#include "fdma.h"
+
+static int setup_freerunning_node(struct stm_dma_params *params,
+				  struct fdma_llu_entry* llu)
+{
+	memset(llu, 0, sizeof(*llu));
+
+	if (params->node_pause)
+		llu->control |=  SET_NODE_COMP_PAUSE | SET_NODE_COMP_IRQ;
+
+	if (params->node_interrupt)
+		llu->control |= SET_NODE_COMP_IRQ;
+
+	if (DIM_SRC(params->dim) == 0) {
+		llu->control |= NODE_ADDR_STATIC <<SOURCE_ADDR;
+	} else {
+		llu->control |= NODE_ADDR_INCR <<SOURCE_ADDR;
+	}
+
+	if (DIM_DST(params->dim) == 0) {
+		llu->control |= NODE_ADDR_STATIC <<DEST_ADDR;
+	} else {
+		llu->control |= NODE_ADDR_INCR <<DEST_ADDR;
+	}
+
+	llu->line_len		= params->line_len;
+	llu->sstride 		= params->sstride;
+	llu->dstride 		= params->dstride;
+	return 0;
+}
+
+static int setup_paced_node(struct stm_dma_params *params,
+			    fdma_llu_entry* llu)
+
+{
+	memset(llu, 0, sizeof(*llu));
+
+	/* Moved this into the extrapolate functions so that we can
+	 * change channel in the same way as address. Yech */
+	/* llu->control= params->req_line; */
+	llu->size_bytes= params->node_bytes;
+	llu->line_len = params->node_bytes;
+
+	if (params->node_pause)
+		/* In order to recieve the pause interrupt
+		 * we must also enable end of node interrupts. */
+		llu->control |=  SET_NODE_COMP_PAUSE | SET_NODE_COMP_IRQ;
+
+	if (params->node_interrupt)
+		llu->control |= SET_NODE_COMP_IRQ;
+
+	if (DIM_SRC(params->dim) == 0) {
+		llu->control |= NODE_ADDR_STATIC <<SOURCE_ADDR;
+	} else {
+		llu->control |= NODE_ADDR_INCR <<SOURCE_ADDR;
+	}
+
+	if (DIM_DST(params->dim) == 0) {
+		llu->control |= NODE_ADDR_STATIC <<DEST_ADDR;
+	} else {
+		llu->control |= NODE_ADDR_INCR <<DEST_ADDR;
+	}
+
+	return 0;
+}
+
+static struct llu_node* extrapolate_simple(
+	struct stm_dma_params *params,
+	struct dma_xfer_descriptor *desc,
+	struct llu_node* llu_node)
+{
+	struct fdma_llu_entry* dest_llu = llu_node->virt_addr;
+
+	dest_llu->control	= desc->template_llu.control |
+		(params->req ? params->req->local_req_line : 0);
+	dest_llu->size_bytes	= params->node_bytes;
+	dest_llu->saddr		= params->sar;
+	dest_llu->daddr		= params->dar;
+	if (desc->extrapolate_line_len)
+		dest_llu->line_len = params->node_bytes;
+	else
+		dest_llu->line_len = desc->template_llu.line_len;
+	dest_llu->sstride	= desc->template_llu.sstride;
+	dest_llu->dstride	= desc->template_llu.dstride;
+
+	return llu_node;
+}
+
+static struct llu_node* extrapolate_sg_src(
+	struct stm_dma_params *params,
+	struct dma_xfer_descriptor *desc,
+	struct llu_node* llu_node)
+{
+	int i;
+	struct scatterlist * sg = params->srcsg;
+	struct llu_node* last_llu_node = llu_node;
+
+	for (i=0; i<params->sglen; i++) {
+		struct fdma_llu_entry* dest_llu = llu_node->virt_addr;
+
+		dest_llu->control	= desc->template_llu.control;
+		dest_llu->size_bytes	= sg_dma_len(sg);
+		dest_llu->saddr		= sg_dma_address(sg);
+		dest_llu->daddr		= params->dar;
+		if (desc->extrapolate_line_len)
+			dest_llu->line_len = sg_dma_len(sg);
+		else
+			dest_llu->line_len = desc->template_llu.line_len;
+		dest_llu->sstride	= desc->template_llu.sstride;
+		dest_llu->dstride	= 0;
+
+		last_llu_node = llu_node++;
+		dest_llu->next_item	= llu_node->dma_addr;
+		sg++;
+	}
+
+	return last_llu_node;
+}
+
+static struct llu_node* extrapolate_sg_dst(
+	struct stm_dma_params *params,
+	struct dma_xfer_descriptor *desc,
+	struct llu_node* llu_node)
+{
+	int i;
+	struct scatterlist * sg = params->dstsg;
+	struct llu_node* last_llu_node = llu_node;
+
+	for (i=0; i<params->sglen; i++) {
+		struct fdma_llu_entry* dest_llu = llu_node->virt_addr;
+
+		dest_llu->control	= desc->template_llu.control;
+		dest_llu->size_bytes	= sg_dma_len(sg);
+		dest_llu->saddr		= params->sar;
+		dest_llu->daddr		= sg_dma_address(sg);
+		if (desc->extrapolate_line_len)
+			dest_llu->line_len = sg_dma_len(sg);
+		else
+			dest_llu->line_len = desc->template_llu.line_len;
+		dest_llu->sstride	= 0;
+		dest_llu->dstride	= desc->template_llu.dstride;
+
+		last_llu_node = llu_node++;
+		dest_llu->next_item	= llu_node->dma_addr;
+		sg++;
+	}
+
+	return last_llu_node;
+}
+
+static int resize_nodelist_mem(struct fdma_dev * fd,
+			       struct dma_xfer_descriptor *desc,
+			       unsigned int new_nnodes, gfp_t context)
+{
+	int old_list_size, new_list_size;
+	unsigned int cur_nnodes;
+	struct llu_node* new_nodes;
+
+	/* This holds the number of allocated nodes, which may differ
+	 * from the old or new size. It must be maintained so that
+	 * free_list works. */
+	cur_nnodes = desc->alloced_nodes;
+
+	/* The only resize down we need to support is freeing everything. */
+	if (new_nnodes == 0) {
+		goto free_list;
+	}
+
+	old_list_size = sizeof(struct llu_node)*desc->alloced_nodes;
+	new_list_size = sizeof(struct llu_node)*new_nnodes;
+	new_nodes = kmalloc(new_list_size, context);
+	if (new_nodes == NULL)
+		goto free_list;
+
+	if (old_list_size > 0) {
+		memcpy(new_nodes, desc->llu_nodes, old_list_size);
+		kfree(desc->llu_nodes);
+	}
+
+	desc->llu_nodes = new_nodes;
+
+	for (new_nodes += desc->alloced_nodes;
+	     cur_nnodes < new_nnodes;
+	     cur_nnodes++, new_nodes++) {
+		new_nodes->virt_addr = dma_pool_alloc(
+					fd->llu_pool,
+					context,
+					&new_nodes->dma_addr);
+		if (new_nodes->virt_addr == NULL)
+			goto free_list;
+	}
+
+	desc->alloced_nodes = new_nnodes;
+	return 0;
+
+free_list:
+	new_nodes = desc->llu_nodes;
+	for( ; cur_nnodes; cur_nnodes--, new_nodes++) {
+		dma_pool_free(fd->llu_pool,
+			      new_nodes->virt_addr,
+			      new_nodes->dma_addr);
+	}
+	if (desc->llu_nodes)
+		kfree(desc->llu_nodes);
+
+	desc->llu_nodes = NULL;
+	desc->alloced_nodes = 0;
+
+	return -ENOMEM;
+}
+
+static void fdma_start_channel(struct fdma_dev * fd,
+			      int ch_num,
+			      unsigned long start_addr)
+{
+	u32 cmd_sta_value = (start_addr  | CMDSTAT_FDMA_START_CHANNEL);
+
+	writel(cmd_sta_value,CMD_STAT_REG(ch_num));
+	writel(MBOX_STR_CMD(ch_num),fd->io_base +fd->regs.fdma_cmd_set);
+}
+
+static int stb710x_get_engine_status(struct fdma_dev * fd,int channel)
+{
+	return readl(CMD_STAT_REG(channel))&3;
+}
+
+static inline void __handle_fdma_err_irq(struct fdma_dev * fd,int chan_num)
+{
+	struct channel_status *chan = &fd->channel[chan_num];
+	void (*err_cb)(unsigned long) = chan->params->err_cb;
+	unsigned long err_cb_parm = chan->params->err_cb_parm;
+
+	spin_lock(&fd->channel_lock);
+
+	printk("%s ERROR CH_%d err %d\n",
+		__FUNCTION__,
+		chan_num,
+		(int)( readl(CMD_STAT_REG(chan_num))& 0x1c) >>2);
+			/*err is bits 2-4*/
+	/*clearing the channel interface here will stop further
+	 * transactions after the err and reset the channel*/
+	writel(0,CMD_STAT_REG(chan_num));
+	writel(readl(fd->io_base + fd->regs.fdma_cmd_sta),
+	       fd->io_base + fd->regs.fdma_cmd_clr);
+	chan->sw_state = FDMA_IDLE;
+
+	spin_unlock(&fd->channel_lock);
+
+//printk("%s: wake_up %x\n", __FUNCTION__, &chan->cur_cfg->wait_queue);
+	wake_up(&chan->cur_cfg->wait_queue);
+	if (err_cb) {
+		if (chan->params->err_cb_isr)
+			err_cb(err_cb_parm);
+		else
+			tasklet_schedule(&chan->fdma_error);
+	}
+}
+
+static inline void __handle_fdma_completion_irq(struct fdma_dev *fd,int chan_num)
+{
+	struct channel_status *chan = &fd->channel[chan_num];
+	void (*comp_cb)(unsigned long) = chan->params->comp_cb;
+	unsigned long comp_cb_parm = chan->params->comp_cb_parm;
+
+	spin_lock(&fd->channel_lock);
+
+	switch(stb710x_get_engine_status(fd,chan_num)){
+	case FDMA_CHANNEL_PAUSED:
+		switch (chan->sw_state) {
+		case FDMA_RUNNING:	/* Hit a pause node */
+		case FDMA_PAUSING:
+			chan->sw_state = FDMA_PAUSED;
+			break;
+		case FDMA_STOPPING:
+			writel(0, CMD_STAT_REG(chan_num));
+			chan->sw_state = FDMA_IDLE;
+			break;
+		default:
+			BUG();
+		}
+		break;
+	case FDMA_CHANNEL_IDLE:
+		switch (chan->sw_state) {
+		case FDMA_RUNNING:
+		case FDMA_PAUSING:
+		case FDMA_STOPPING:
+			chan->sw_state = FDMA_IDLE;
+			break;
+		default:
+			BUG();
+		}
+		break;
+	case FDMA_CHANNEL_RUNNING:
+		break;
+	default:
+		fdma_dbg(fd, "ERR::FDMA2 unknown interrupt status \n");
+	}
+
+	spin_unlock(&fd->channel_lock);
+
+	wake_up(&chan->cur_cfg->wait_queue);
+	if (comp_cb) {
+		if (chan->params->comp_cb_isr)
+			comp_cb(comp_cb_parm);
+		else
+			tasklet_schedule(&chan->fdma_complete);
+	}
+}
+
+static irqreturn_t fdma_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct fdma_dev * fd = (struct fdma_dev *)dev_id;
+	int chan_num;
+	u32 int_stat_val = readl(fd->io_base + fd->regs.fdma_int_sta);
+	u32 cur_val = int_stat_val & fd->ch_status_mask;
+
+	writel(cur_val, fd->io_base +fd->regs.fdma_int_clr);
+	for (cur_val >>= fd->ch_min * 2, chan_num=fd->ch_min;
+	     cur_val != 0;
+	     cur_val >>= 2, chan_num++) {
+		/*error interrupts will raise boths bits, so check
+		 * the err bit first*/
+		if(unlikely(cur_val & 2))
+			__handle_fdma_err_irq(fd,chan_num);
+		else if (cur_val & 1)
+			__handle_fdma_completion_irq(fd, chan_num);
+	}
+
+	/*here we check to see if there is still pending ints for the other dmac, if so
+	 * rely on it to signal IRQ_HANDLED once all vectors are cleared, we return IRQ_NONE.
+	 * otherwise we have handled everything so we can now safely returnd IRQ_HANDLED
+	 * to lower the IRQ.*/
+	return IRQ_RETVAL( !(cur_val & (~fd->ch_status_mask)) );
+}
+
+/* Paced channel handling */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+
+static struct stm_dma_req fdma_reqs[STB7100_REQ_LINES];
+
+/* This is the dummy xbar for 710x devices */
+static int xbar_local_req(int req_line,
+			  struct channel_status *chan)
+{
+	return req_line;
+}
+
+static int __init xbar_init(void)
+{
+	return 0;
+}
+module_init(xbar_init)
+
+#else
+
+/* Real xbar device */
+
+static struct stm_dma_req fdma_reqs[STB7200_REQ_LINES];
+
+struct xbar_dev {
+	struct resource *phys_mem;
+	void* io_base;
+};
+
+/* Gross hack, we use a global static so the FDMA code can find the
+ * xbar. */
+static struct xbar_dev* xbar_dev;
+
+/* Needs to be called with both the channel and xbar locks taken. */
+static int xbar_local_req(int req_line,
+			  struct channel_status *chan)
+{
+	struct fdma_dev *fd = chan->fd;
+	int local_req_line;
+	void* xbar_addr;
+	unsigned long xbar_val;
+
+	if (fd->req_lines_inuse == ~0UL)
+		return -1;
+
+	local_req_line = ffz(fd->req_lines_inuse);
+	fd->req_lines_inuse |= 1<<local_req_line;
+
+	xbar_addr = xbar_dev->io_base + (req_line >> 2);
+	xbar_val = readl(xbar_addr);
+	xbar_val &= ~(0xff << (req_line & 3));
+	xbar_val |= ((fd->fdma_num << 5) | local_req_line) <<
+		((req_line & 3) * 8);
+	writel(xbar_val, xbar_addr);
+
+	return req_line;
+}
+
+static int __init xbar_driver_probe(struct platform_device *pdev)
+{
+	struct xbar_dev *xd;
+	struct resource *mem_res;
+	unsigned long phys_base, phys_size;
+
+	xd = kzalloc(sizeof(struct xbar_dev), GFP_KERNEL);
+	if (xd == NULL) {
+		return -ENOMEM;
+	}
+
+	mem_res = platform_get_resource(pdev,IORESOURCE_MEM,0);
+        phys_base = mem_res->start;
+        phys_size = mem_res->end - mem_res->start + 1;
+
+        xd->phys_mem = request_mem_region(phys_base, phys_size, "xbar");
+	if (xd->phys_mem == NULL) {
+		kfree(xd);
+                return -EBUSY;
+	}
+
+	xd->io_base = ioremap_nocache(phys_base, phys_size);
+	if (xd->io_base == NULL) {
+		release_resource(xd->phys_mem);
+		kfree(xd);
+	}
+
+	platform_set_drvdata(pdev, xd);
+	xbar_dev = xd;
+
+       	return 0;
+}
+
+static int xbar_driver_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver xbar_driver = {
+	.driver = {
+		.name = "fdma-xbar",
+	},
+	.probe = xbar_driver_probe,
+	.remove = xbar_driver_remove,
+};
+
+static int __init xbar_init(void)
+{
+	return platform_driver_register(&xbar_driver);
+}
+
+static void __exit xbar_exit(void)
+{
+	platform_driver_unregister(&xbar_driver);
+}
+
+module_init(xbar_init)
+module_exit(xbar_exit)
+
+#endif
+
+static spinlock_t fdma_req_lock = SPIN_LOCK_UNLOCKED;
+
+struct stm_dma_req *fdma_req_allocate(unsigned int req_line, struct channel_status *chan)
+{
+	struct stm_dma_req* req = NULL;
+	int local_req_line;
+
+	if ((req_line < 0) || (req_line >= ARRAY_SIZE(fdma_reqs)))
+		return NULL;
+
+	spin_lock(&fdma_req_lock);
+	if (fdma_reqs[req_line].chan != NULL) {
+		goto out;
+	}
+
+	req = &fdma_reqs[req_line];
+
+	local_req_line = xbar_local_req(req_line, chan);
+	if (local_req_line == -1) {
+		goto out;
+	}
+
+	req->chan = chan;
+	req->local_req_line = local_req_line;
+out:
+	spin_unlock(&fdma_req_lock);
+	return req;
+}
+
+/* Note that this may be called multiple times for the same req, for
+ * example linked list of params with the same req line in each.
+ * Maybe we should have an explicit free as there is an explicit
+ * allocate via stb710x_configure_pace_channel() ? */
+static void fdma_req_free(struct stm_dma_req *req)
+{
+	req->chan = NULL;
+}
+
+/*---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ * FIRMWARE DOWNLOAD & ENGINE INIT
+ *---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*/
+
+static void fdma_initialise(struct fdma_dev * fd)
+{
+/*These pokes come from the current STAPI tree.
+ * The three magic vals are pokes to undocumented regs so
+ * we don't know what they mean.
+ *
+ * The effect is to turn on and initialise the clocks
+ * and set all channels off*/
+
+	/*clear the status regs MBOX & IRQ*/
+	writel(CLEAR_WORD, fd->io_base+fd->regs.fdma_int_clr);
+	writel(CLEAR_WORD, fd->io_base+fd->regs.fdma_cmd_clr);
+
+	/* Enable the FDMA block */
+	writel(1,fd->io_base+fd->regs.fdma_sync_reg);
+	writel(5,fd->io_base+fd->regs.fdma_clk_gate);
+	writel(0,fd->io_base+fd->regs.fdma_clk_gate);
+
+}
+/*this function enables messaging and intr generation for all channels &
+ * starts the fdma running*/
+static int fdma_enable_all_channels(struct fdma_dev * fd)
+{
+	writel(CLEAR_WORD,fd->io_base + fd->regs.fdma_int_mask);
+	writel(CLEAR_WORD,fd->io_base + fd->regs.fdma_cmd_mask);
+	writel(1,fd->io_base +fd->regs.fdma_en);
+	return (readl(fd->io_base + fd->regs.fdma_en) &1);
+}
+static int fdma_disable_all_channels(struct fdma_dev * fd)
+{
+	writel(0x00,fd->io_base + fd->regs.fdma_int_mask);
+	writel(0x00,fd->io_base + fd->regs.fdma_cmd_mask);
+	writel(0,fd->io_base + fd->regs.fdma_en);
+	return (readl(fd->io_base + fd->regs.fdma_en) &~1);
+}
+
+static void fdma_reset_channels(struct fdma_dev * fd)
+{
+	int channel=0;
+	for(;channel <(fd->ch_max-1);channel++)
+		writel(0,CMD_STAT_REG(0));
+}
+
+static struct stm_dma_req *stb710x_configure_pace_channel(struct fdma_dev *fd,
+	struct dma_channel *channel,
+	struct stm_dma_req_config *req_config)
+{
+	struct channel_status *chan = FDMA_CHAN(channel);
+	void __iomem *req_base_reg = fd->io_base+fd->regs.fdma_req_ctln;
+	struct stm_dma_req *fdma_req;
+	u32 req_ctl;
+
+	fdma_req = fdma_req_allocate(req_config->req_line, chan);
+	if (fdma_req == NULL) {
+		return NULL;
+	}
+
+	req_ctl = 0;
+	req_ctl |= (req_config->hold_off	& 0x0f) <<  0;/*Bits 3.0*/
+	req_ctl |= (req_config->opcode		& 0x0f) <<  4;/*7..4*/
+	req_ctl |= (req_config->rw		& 0x01) << 14;/*14*/
+	req_ctl |= (req_config->initiator	& 0x03) << 22;/*23..22*/
+	req_ctl |= ((req_config->count-1)	& 0x1F) << 24;/*28..24*/
+	req_ctl |= (req_config->increment	& 0x01) << 29;/*29*/
+
+	writel(req_ctl, req_base_reg + (fdma_req->local_req_line * CMD_STAT_OFFSET));
+
+	return fdma_req;
+}
+
+static int fdma_register_caps(struct fdma_dev * fd)
+{
+	int channel = fd->ch_min;
+	int res=0;
+	int num_caps = fd->ch_max - fd->ch_min + 1;
+	struct dma_chan_caps  dmac_caps[num_caps];
+	static const char* hb_caps[] = {STM_DMA_CAP_HIGH_BW,NULL};
+	static const char* lb_caps[] = {STM_DMA_CAP_LOW_BW,NULL};
+	static const char* eth_caps[] = {STM_DMA_CAP_ETH_BUF,NULL};
+
+	for (;channel <= fd->ch_max;channel++) {
+		dmac_caps[channel-fd->ch_min].ch_num = channel;
+		switch (channel) {
+		case 0 ... 3:
+			dmac_caps[channel-fd->ch_min].caplist = hb_caps;
+			break;
+		case 11:
+			dmac_caps[channel-fd->ch_min].caplist = eth_caps;
+			break;
+		default:
+			dmac_caps[channel-fd->ch_min].caplist = lb_caps;
+			break;
+		}
+	}
+	res= register_chan_caps(fd->name, &dmac_caps[0]);
+
+	if(res!=0){
+		fdma_dbg(fd, "%s %s failed to register capabilities err-%d\n",
+			__FUNCTION__, fd->name, res);
+		return -ENODEV;
+	}
+	else return 0;
+}
+
+static int fdma_run_initialise_sequence(struct fdma_dev *fd)
+{
+	fd->llu_pool = dma_pool_create(fd->name, NULL,
+					sizeof(struct fdma_llu_entry),32,0);
+	if (fd->llu_pool == NULL) {
+		fdma_dbg(fd, "%s Can't allocate dma_pool memory",__FUNCTION__);
+		return -ENOMEM;
+	}
+	fdma_initialise(fd);
+	fdma_reset_channels(fd);
+
+	if(!fdma_enable_all_channels(fd))
+		return -ENODEV;
+	else return  0;
+}
+
+/*---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ * FIRMWARE DOWNLOAD & ENGINE INIT
+ *---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*/
+
+static void fdma_get_fw_revision(struct fdma_dev * fd, int *major, int *minor)
+{
+	int reg = readl(fd->io_base + fd->regs.fdma_dmem_region);
+	*major  = (reg & 0xff00) >>8;
+	*minor  = reg & 0xff;
+}
+
+static void fdma_get_hw_revision(struct fdma_dev * fd, int *major, int *minor)
+{
+	*major = readl(fd->io_base + fd->regs.fdma_id);
+	*minor = readl(fd->io_base + fd->regs.fdma_ver);
+}
+
+#if  defined(CONFIG_STM_DMA_FW_KERNEL)
+
+static int fdma_do_bootload(struct fdma_dev * fd)
+{
+	device_t* ptr=0;
+	struct fdma_fw fw=fd->fw;
+	unsigned long unused_ibytes;
+	unsigned long unused_dbytes;
+	unsigned long irqflags;
+	void * addr =(char*)fd->io_base;
+
+	fdma_dbg(fd, "FDMA: Loading Firmware...");
+	unused_ibytes= fw.imem_len - fw.imem_fw_sz;
+	unused_dbytes= fw.dmem_len - fw.dmem_fw_sz;
+
+	spin_lock_irqsave(&fd->channel_lock,irqflags);
+	ptr = (device_t*) ((char*) addr +fd->regs.fdma_dmem_region);
+	memcpy((void*)ptr,&fw.data_reg[0],fw.dmem_fw_sz * sizeof(u32));
+	if(unused_dbytes){
+		ptr =(device_t*) ((char*)addr +fd->regs.fdma_dmem_region
+				  +(fw.dmem_fw_sz*sizeof(u32)));
+		memset((void*)ptr ,0, unused_dbytes);
+	}
+
+	ptr = (device_t*) ((char*) addr +fd->regs.fdma_imem_region);
+	memcpy((void*)ptr,&fw.imem_reg[0],fw.imem_fw_sz* sizeof(u32));
+	if(unused_ibytes){
+		ptr =(device_t*) ((char*)addr +fd->regs.fdma_imem_region
+				  +(fw.imem_fw_sz*sizeof(u32)));
+		memset((void*)ptr,0, unused_ibytes);
+	}
+	spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+
+	fd->firmware_loaded=1;
+	wake_up(&fd->fw_load_q);
+
+	return 0;
+}
+#elif defined(CONFIG_STM_DMA_FW_USERSPACE)
+
+/* Awkwardly the current FDMA elf instruction section is stored with
+ * 3 byte words. The Slim requires the following - fmt(0x00nnnnnn).
+ * where - 	0 - appended 0 byte
+ * 	 	n value read from elf
+ *
+ * So we must manually insert these word by word from the elf,
+ * This also means the size parameter is incorrect
+ * - Grrrr.
+*/
+static void build_elf_imem(	struct fdma_dev * fd,
+				struct elf32_shdr * sect_hd,
+				struct firmware * slimcore_elf)
+{
+	int pos=0;
+	char * file_off=0;
+	int imem_sz = sect_hd->sh_size+ (sect_hd->sh_size /3);
+	u8 * imem_st=  kmalloc(imem_sz,GFP_KERNEL);
+	u8 * imem_ptr =imem_st;
+	char * imem_sect = (char*)fd->io_base + fd->regs.fdma_imem_region;
+
+	file_off =(u8*) &slimcore_elf->data[sect_hd->sh_offset];
+
+	do{
+		memcpy(imem_ptr,file_off,sizeof(char)*3);
+		imem_ptr+=3;
+		file_off+=3;
+		*imem_ptr=0x00;
+		imem_ptr++;
+	}while((pos+=3)< sect_hd->sh_size);
+
+	memcpy(imem_sect,imem_st ,imem_sz);
+	kfree(imem_ptr);
+}
+
+static void build_elf_dmem(	struct fdma_dev * fd,
+				struct elf32_shdr * sect_hd,
+				struct firmware * slimcore_elf)
+{
+	char * dmem_sect = (char*)fd->io_base + fd->regs.fdma_dmem_region;
+	char * file_off=0;
+
+	file_off = (char*)&slimcore_elf->data[sect_hd->sh_offset];
+	memcpy(dmem_sect,(char*)file_off ,sect_hd->sh_size);
+}
+
+
+static int fdma_do_bootload(struct fdma_dev * fd)
+{
+	int err=0;
+	int i=0,imem_loaded=0,dmem_loaded=0;
+	char fw_revision[20];
+	char hw_revision[20];
+	int major=0,minor=0;
+	struct firmware *slimcore_elf={0};
+	struct elf32_hdr hdr;
+
+	fdma_dbg(fd, "FDMA: Loading Firmware ELF...");
+
+	err = request_firmware((const struct firmware **)&slimcore_elf,
+				fd->fw_name,&fdma_device_list[fd->hwid]);
+	if(err != 0 ){
+		fdma_dbg(fd, "%s Can't Locate/Load Firmware %s\n",
+		       __FUNCTION__, fd->fw_name);
+		return -ENOENT;
+	}
+
+	memcpy(&hdr,slimcore_elf->data,sizeof(struct elf32_hdr));
+
+
+	// build the section header tbl
+	for(i=0;i < hdr.e_shnum;i++){
+		struct elf32_shdr sect_hdr;
+		char* sh_addr = (char*)&slimcore_elf->data[hdr.e_shoff + (i * sizeof(struct elf32_shdr))];
+		memcpy(&sect_hdr,(char*)sh_addr ,sizeof(struct elf32_shdr));
+
+		if(SHT_PROGBITS== sect_hdr.sh_type){
+			if(sect_hdr.sh_flags & SHF_ALLOC){
+
+				if((sect_hdr.sh_flags & SHF_EXECINSTR) == SHF_EXECINSTR){
+					build_elf_imem(fd,&sect_hdr,slimcore_elf);
+					imem_loaded=1;
+				}
+				else if((sect_hdr.sh_flags & SHF_WRITE) == SHF_WRITE){
+					build_elf_dmem(fd,&sect_hdr,slimcore_elf);
+					dmem_loaded=1;
+				}
+			}
+			if(dmem_loaded && imem_loaded){
+				/*we can discard the remainder of the elf now*/
+				break;
+			}
+		}
+	}
+	release_firmware(slimcore_elf);
+	if(dmem_loaded && imem_loaded){
+		fd->firmware_loaded=1;
+		wake_up(&fd->fw_load_q);
+	}
+	else return -ENODEV;
+
+	fdma_get_fw_revision(fd,&fw_revision[0],major,minor);
+	fdma_get_hw_revision(fd,&hw_revision[0],major,minor);
+	fdma_dbg(fd, "STB_%dC%d %s %s OK\n",
+		 fd->cpu_subtype,fd->cpu_rev,hw_revision,fw_revision);
+	return 0;
+}
+#endif
+
+static int fdma_load_firmware(struct fdma_dev * fd)
+{
+	unsigned long irqflags=0;
+	int hw_major, hw_minor;
+	int fw_major, fw_minor;
+	spin_lock_irqsave(&fd->channel_lock,irqflags);
+	switch ( fd->firmware_loaded ) {
+		case 0:
+			fd->firmware_loaded = -1;
+			spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+			if (fdma_do_bootload(fd)!=0){
+				fd->firmware_loaded=0;
+				return  -ENOMEM;
+			}
+			fdma_get_hw_revision(fd, &hw_major, &hw_minor);
+			fdma_get_fw_revision(fd, &fw_major, &fw_minor);
+			fdma_info(fd, "SLIM hw %d.%d, FDMA fw %d.%d\n",
+				  hw_major, hw_minor, fw_major, fw_minor);
+
+			if(fdma_run_initialise_sequence(fd)!=0)
+				return -ENODEV;
+
+			return (fd->firmware_loaded==1) ? 0:-ENODEV;
+		case 1:
+			spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+			return 0;
+		default:
+		case -1:
+			spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+			wait_event_interruptible(fd->fw_load_q,(fd->firmware_loaded==1));
+			if(!fd->firmware_loaded)
+				return -ENODEV;
+			else return 0;
+	}
+	return 0;
+}
+
+static int fdma_check_firmware_state(struct fdma_dev * fd)
+{
+	return (fd->firmware_loaded) ? 0:fdma_load_firmware(fd);
+}
+
+/*---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ * Linux -SH DMA API hooks
+ *---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*/
+
+/*returns the number of bytes left to transfer for the current node*/
+static  int stb710x_fdma_get_residue(struct dma_channel *chan)
+{
+	struct fdma_dev *fd = FDMA_DEV(chan);
+	void __iomem *chan_base = fd->io_base + (chan->chan * NODE_DATA_OFFSET);
+	unsigned long irqflags;
+	unsigned long total = 0,count=0;
+	void *first_ptr=0;
+	fdma_llu_entry *cur_ptr;
+
+	spin_lock_irqsave(&fd->channel_lock, irqflags);
+	count = readl(chan_base +fd->regs.fdma_cntn);
+	/*first read the current node data*/
+	first_ptr = (void *) readl(chan_base + fd->regs.fdma_ptrn);
+	if(! first_ptr)
+		goto list_complete;
+
+	first_ptr = phys_to_virt(first_ptr);
+	/* Accumulate the bytes remaining in the list */
+	cur_ptr = first_ptr;
+	do {
+		if(first_ptr >=(void*)phys_to_virt(cur_ptr->next_item)
+		   || cur_ptr->next_item ==0)
+			goto list_complete;
+
+		total += cur_ptr->size_bytes;
+	} while ((cur_ptr = phys_to_virt((fdma_llu_entry *) cur_ptr->next_item))!=0);
+list_complete:
+	spin_unlock_irqrestore(&fd->channel_lock, irqflags);
+	total+= count;
+	return total;
+}
+
+/*must only be called when channel is in pasued state*/
+static int stb710x_fdma_unpause(struct fdma_dev * fd,struct dma_channel * channel)
+{
+	struct channel_status *chan = FDMA_CHAN(channel);
+	unsigned long irqflags=0;
+
+	spin_lock_irqsave(&fd->channel_lock,irqflags);
+	if (chan->sw_state != FDMA_PAUSED) {
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+		return -EBUSY;
+	}
+
+	writel(MBOX_CMD_START_CHANNEL << (channel->chan*2),
+	       fd->io_base + fd->regs.fdma_cmd_set);
+	chan->sw_state = FDMA_RUNNING;
+	spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+	return 0;
+}
+
+static int stb710x_fdma_pause(struct fdma_dev * fd,struct dma_channel * channel)
+{
+	struct channel_status *chan = FDMA_CHAN(channel);
+	unsigned long irqflags=0;
+
+	spin_lock_irqsave(&fd->channel_lock,irqflags);
+	switch (chan->sw_state) {
+	case FDMA_IDLE:
+	case FDMA_CONFIGURED:
+		/* Hardware isn't set up yet, so treat this as an error */
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+		return -EBUSY;
+	case FDMA_PAUSED:
+		/* Hardware is already paused */
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+		return 0;
+	case FDMA_RUNNING:
+		/* Hardware is running, send the command */
+		writel(MBOX_CMD_PAUSE_CHANNEL << (channel->chan*2),
+		       fd->io_base + fd->regs.fdma_cmd_set);
+		/* Fall through */
+	case FDMA_PAUSING:
+	case FDMA_STOPPING:
+		/* Hardware is pausing already, wait for interrupt */
+		chan->sw_state = FDMA_PAUSING;
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+#if 0
+		/* In some cases this is called from a context which cannot
+		 * block, so disable the wait at the moment. */
+		wait_event(chan->cur_cfg->wait_queue,
+			   chan->sw_state == FDMA_PAUSED);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static int stb710x_fdma_request(struct dma_channel *channel)
+{
+	struct fdma_dev *fd = FDMA_DEV(channel);
+
+	if(fdma_check_firmware_state(fd)==0){
+		return 0;
+	}
+
+	return ENOSYS;
+}
+
+static int stb710x_fdma_stop(struct fdma_dev * fd,struct dma_channel *channel)
+{
+	struct channel_status *chan = FDMA_CHAN(channel);
+	unsigned long cmd_val = (MBOX_CMD_PAUSE_CHANNEL << (channel->chan*2));
+	unsigned long irqflags=0;
+
+	spin_lock_irqsave(&fd->channel_lock,irqflags);
+	switch (chan->sw_state) {
+	case FDMA_IDLE:
+	case FDMA_CONFIGURED:
+	case FDMA_PAUSED:
+		/* Hardware is already idle, simply change state */
+		chan->sw_state = FDMA_IDLE;
+		writel(0,CMD_STAT_REG(channel->chan));
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+		break;
+	case FDMA_RUNNING:
+		/* Hardware is running, send the command */
+		writel(cmd_val,(fd->io_base +fd->regs.fdma_cmd_set));
+		/* Fall through */
+	case FDMA_PAUSING:
+	case FDMA_STOPPING:
+		/* Hardware is pausing already, wait for interrupt */
+		chan->sw_state = FDMA_STOPPING;
+		spin_unlock_irqrestore(&fd->channel_lock,irqflags);
+#if 0
+		/* In some cases this is called from a context which cannot
+		 * block, so disable the wait at the moment. */
+		wait_event(chan->cur_cfg->wait_queue,
+			   chan->sw_state == FDMA_IDLE);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static int stb710x_fdma_free_params(struct stm_dma_params *params)
+{
+	struct fdma_dev * fd = params->params_ops_priv;
+	struct stm_dma_params *this;
+
+	for (this = params; this; this = this->next) {
+		struct dma_xfer_descriptor *desc = (struct dma_xfer_descriptor*)this->priv;
+		if (desc) {
+			resize_nodelist_mem(fd, desc, 0, 0);
+			kfree(desc);
+		}
+
+		if (this->req) {
+			fdma_req_free(this->req);
+		}
+	}
+
+	return 0;
+}
+
+static struct params_ops fdma_params_ops = {
+	.free_params	= stb710x_fdma_free_params
+};
+
+/* Compile params part 1: generate template nodes */
+static int _compile1(struct fdma_dev * fd,struct stm_dma_params *params)
+{
+	struct stm_dma_params *this;
+
+	for (this = params; this; this = this->next) {
+		struct dma_xfer_descriptor *desc;
+
+		desc = (struct dma_xfer_descriptor*)this->priv;
+		if (desc != NULL)
+			continue;
+
+		desc = kzalloc(sizeof(struct dma_xfer_descriptor), params->context);
+		if (desc == NULL)
+			return -ENOMEM;
+		this->priv = desc;
+
+		if (IS_TRANSFER_SG(this)){
+			if(MODE_SRC_SCATTER==this->mode)
+				desc->extrapolate_fn = extrapolate_sg_src;
+			else if(MODE_DST_SCATTER==this->mode)
+				desc->extrapolate_fn = extrapolate_sg_dst;
+			else return -EINVAL;
+		} else {
+			desc->extrapolate_fn = extrapolate_simple;
+		}
+
+		if(this->mode == MODE_PACED){
+			setup_paced_node(this, &desc->template_llu);
+		} else {
+			setup_freerunning_node(this, &desc->template_llu);
+		}
+
+		/* For any 1D transfers, line_len = nbytes */
+		desc->extrapolate_line_len =
+			!((DIM_SRC(this->dim) == 2) || (DIM_DST(this->dim) == 2));
+	}
+
+	return 0;
+}
+
+/* Compile params part 2: allocate node list */
+static int _compile2(struct fdma_dev * fd,struct stm_dma_params *params)
+{
+	struct stm_dma_params *this;
+	int numnodes = 0;
+	struct dma_xfer_descriptor *desc;
+
+	for (this = params; this; this = this->next) {
+		if (IS_TRANSFER_SG(this))
+			numnodes += this->sglen;
+		else
+			numnodes++;
+	}
+
+	desc = (struct dma_xfer_descriptor*)params->priv;
+	if (desc->alloced_nodes < numnodes) {
+		int res;
+		res = resize_nodelist_mem(fd, desc, numnodes, params->context);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+/* Compile params part 3: extrapolate */
+static int _compile3(struct fdma_dev * fd,struct stm_dma_params *params)
+{
+	struct stm_dma_params *this;
+	struct dma_xfer_descriptor *this_desc;
+	struct llu_node *first_node, *last_node, *node;
+
+	this = params;
+	this_desc = (struct dma_xfer_descriptor*)this->priv;
+	first_node = this_desc->llu_nodes;
+
+	node = first_node;
+	while (1) {
+
+		last_node = this_desc->extrapolate_fn(this, this_desc, node);
+
+		this = this->next;
+		if (this == NULL)
+			break;
+
+		this_desc = (struct dma_xfer_descriptor*)this->priv;
+		node = last_node + 1;
+		last_node->virt_addr->next_item = node->dma_addr;
+	}
+
+	if(params->circular_llu)
+		last_node->virt_addr->next_item = first_node->dma_addr;
+	else
+		last_node->virt_addr->next_item = 0;
+
+	return 0;
+}
+
+static int stb710x_fdma_compile_params(struct fdma_dev * fd,struct stm_dma_params *params)
+{
+	int res;
+
+	res = _compile1(fd, params);
+	if (res)
+		return res;
+
+	res = _compile2(fd, params);
+	if (res)
+		return res;
+
+	res = _compile3(fd, params);
+	if (res == 0) {
+		params->params_ops = &fdma_params_ops;
+		params->params_ops_priv = fd;
+	}
+
+	return res;
+}
+
+static void stb710x_fdma_free(struct dma_channel *channel)
+{
+	struct fdma_dev *fd = FDMA_DEV(channel);
+	struct channel_status *chan = FDMA_CHAN(channel);
+	unsigned long irq_flags=0;
+
+	spin_lock_irqsave(&fd->channel_lock,irq_flags);
+
+	if (chan->sw_state != FDMA_IDLE) {
+		spin_unlock_irqrestore(&fd->channel_lock,irq_flags);
+		fdma_dbg(fd, "%s channel not idle\n",__FUNCTION__);
+		return;
+	}
+
+	BUG_ON(!(IS_CHANNEL_IDLE(fd,channel->chan)));
+
+	spin_unlock_irqrestore(&fd->channel_lock,irq_flags);
+}
+
+/* Note although this returns an int, the dma-api code throws this away. */
+static int stb710x_fdma_configure(	struct dma_channel *channel,
+				  	unsigned long flags)
+{
+	struct fdma_dev *fd = FDMA_DEV(channel);
+	struct channel_status *chan = FDMA_CHAN(channel);
+	struct stm_dma_params * params;
+	unsigned long irq_flags=0;
+
+	spin_lock_irqsave(&fd->channel_lock,irq_flags);
+	if (chan->sw_state != FDMA_IDLE) {
+		spin_unlock_irqrestore(&fd->channel_lock,irq_flags);
+		fdma_dbg(fd, "%s channel not idle\n",__FUNCTION__);
+		return -EBUSY;
+	}
+
+	params = (struct stm_dma_params *)flags;
+	if(!((struct dma_xfer_descriptor*)(params->priv))->llu_nodes){
+		fdma_dbg(fd, "%s no nodelist alloced\n",__FUNCTION__);
+		spin_unlock_irqrestore(&fd->channel_lock,irq_flags);
+		return -ENOMEM;
+	}
+
+	/* Now we are associating the compiled transfer llu & params to the channel*/
+	chan->params = params;
+	tasklet_init(&chan->fdma_complete,
+		     params->comp_cb, (unsigned long)params->comp_cb_parm);
+	tasklet_init(&chan->fdma_error,
+		     params->err_cb, (unsigned long)params->err_cb_parm);
+	chan->sw_state = FDMA_CONFIGURED;
+
+	spin_unlock_irqrestore(&fd->channel_lock,irq_flags);
+
+	return 0;
+}
+
+static int stb710x_fdma_xfer(
+				struct dma_channel *channel,
+				unsigned long sar,
+			     	unsigned long dar,
+			     	size_t count,
+			     	unsigned int mode)
+{
+	struct fdma_dev *fd = FDMA_DEV(channel);
+	struct channel_status *chan = FDMA_CHAN(channel);
+	struct dma_xfer_descriptor *desc;
+	unsigned long irqflags=0;
+
+	/*we need to check that the compile has been completed*/
+	spin_lock_irqsave(&fd->channel_lock, irqflags);
+
+	if (chan->sw_state != FDMA_CONFIGURED) {
+		spin_unlock_irqrestore(&fd->channel_lock, irqflags);
+		return -EINVAL;
+	}
+
+	desc = (struct dma_xfer_descriptor*)chan->params->priv;
+
+	BUG_ON(!(IS_CHANNEL_IDLE(fd,channel->chan)));
+
+	fdma_start_channel(fd,channel->chan, desc->llu_nodes->dma_addr);
+	chan->sw_state = FDMA_RUNNING;
+
+	spin_unlock_irqrestore(&fd->channel_lock, irqflags);
+
+	return 0;
+}
+
+static int stb710x_fdma_extended_op(struct dma_channel *  ch,
+				    unsigned long opcode,
+				    void * parm)
+{
+	struct fdma_dev *fd = FDMA_DEV(ch);
+	switch(opcode){
+		case STM_DMA_OP_PAUSE:
+			return stb710x_fdma_pause(fd,ch);
+		case STM_DMA_OP_UNPAUSE:
+			return  stb710x_fdma_unpause(fd,ch);
+		case STM_DMA_OP_STOP:
+			return stb710x_fdma_stop(fd,ch);
+		case STM_DMA_OP_COMPILE:
+			return stb710x_fdma_compile_params(fd, (struct stm_dma_params*)parm);
+		case STM_DMA_OP_STATUS:
+			return stb710x_get_engine_status(fd,ch->chan);
+		case STM_DMA_OP_PACING:
+			return (int)stb710x_configure_pace_channel(fd, ch, (struct stm_dma_req_config*)parm);
+		default:
+			return -ENOSYS;
+	}
+}
+
+/*---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ * MODULE INIT & REGISTRATION
+ *---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*/
+
+static struct dma_ops stb710x_fdma_ops = {
+	.request		= stb710x_fdma_request,
+	.free			= stb710x_fdma_free,
+	.get_residue		= stb710x_fdma_get_residue,
+	.xfer			= stb710x_fdma_xfer,
+	.configure		= stb710x_fdma_configure,
+	.extend			= stb710x_fdma_extended_op,
+};
+
+static int __init fdma_driver_probe(struct platform_device *pdev)
+{
+	struct fdma_platform_device_data * plat_data;
+	struct fdma_dev *fd=NULL;
+	struct resource *res;
+	int i=0;
+	int err=0;
+
+	plat_data = pdev->dev.platform_data;
+
+	fd = kzalloc(sizeof(struct fdma_dev), GFP_KERNEL);
+	if (fd == NULL) {
+		return -ENOMEM;
+	};
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		return -ENODEV;
+	}
+
+	fd->phys_mem = request_mem_region(res->start, res->end - res->start + 1,
+					  pdev->name);
+	if (fd->phys_mem == NULL) {
+		return -EBUSY;
+	};
+
+	fd->io_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (fd->io_base == NULL) {
+		return -EINVAL;
+	}
+
+	fd->ch_min = plat_data->min_ch_num;
+	fd->ch_max = plat_data->max_ch_num;
+	fd->fdma_num = pdev->id;
+	fd->ch_status_mask =
+		((1ULL << (fd->ch_max*2)) - 1ULL) ^
+		((1    << (fd->ch_min*2)) - 1);
+
+	memcpy(&fd->regs,(u32*)plat_data->registers_ptr,sizeof(struct fdma_regs));
+	fd->fw_name = plat_data->fw_device_name;
+	fd->fw = plat_data->fw;
+
+	spin_lock_init(&(fd)->channel_lock);
+	init_waitqueue_head(&(fd)->fw_load_q);
+
+	fd->dma_info.nr_channels = (fd->ch_max+1) - fd->ch_min;
+	fd->dma_info.ops	= &stb710x_fdma_ops;
+	fd->dma_info.flags	= DMAC_CHANNELS_TEI_CAPABLE;
+	strlcpy(fd->name, STM_DMAC_ID, FDMA_NAME_LEN);
+	if (pdev->id != -1) {
+		int len=strlen(fd->name);
+		snprintf(fd->name+len, FDMA_NAME_LEN-len, ".%d", pdev->id);
+	}
+	fd->dma_info.name = fd->name;
+
+	if(register_dmac(&fd->dma_info)!=0)
+		printk("%s Error Registering DMAC\n",__FUNCTION__);
+	/*must take account of CH 0*/
+
+	for (i=fd->ch_min; i<=fd->ch_max; i++) {
+		struct dma_channel *channel;
+		channel = get_dma_channel(i);
+		channel->priv_data = &fd->channel[i];
+		fd->channel[i].cur_cfg = channel;
+		fd->channel[i].fd = fd;
+	}
+
+	err =request_irq(platform_get_irq(pdev, 0),
+			 fdma_irq,
+			 SA_INTERRUPT | SA_SHIRQ,
+			 fd->name,
+			 fd);
+	if(err <0)
+		panic(" Cant Register irq %d for FDMA engine err %d\n",
+					fd->irq_val,err);
+
+
+	fdma_register_caps(fd);
+
+	fdma_check_firmware_state(fd);
+
+	platform_set_drvdata(pdev, fd);
+
+	return 0;
+}
+
+static int fdma_driver_remove(struct platform_device *pdev)
+{
+	struct fdma_dev *fd = platform_get_drvdata(pdev);
+
+	fdma_disable_all_channels(fd);
+	iounmap(fd->io_base);
+	dma_pool_destroy(fd->llu_pool);
+	free_irq(fd->irq_val, fd);
+	unregister_dmac(&fd->dma_info);
+	release_resource(fd->phys_mem);
+	kfree(fd);
+
+	return 0;
+}
+
+static struct platform_driver fdma_driver = {
+	.driver = {
+		.name = "stmfdma",
+	},
+	.probe = fdma_driver_probe,
+	.remove = fdma_driver_remove,
+};
+
+static int __init fdma_init(void)
+{
+	return platform_driver_register(&fdma_driver);
+}
+
+static void __exit fdma_exit(void)
+{
+	platform_driver_unregister(&fdma_driver);
+}
+
+module_init(fdma_init)
+module_exit(fdma_exit)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/Kconfig linux-2.6.23.1-stm/drivers/stm/Kconfig
--- linux-2.6.23.1/drivers/stm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,158 @@
+#
+# STM specific device configuration
+#
+
+config STM_DRIVERS
+	boolean
+	default y if CPU_SUBTYPE_ST40
+	default n
+
+menu "STM specific devices"
+        depends on STM_DRIVERS
+
+config STM_PIO
+	tristate "STMicroelectronics PIO Support"
+	depends on CPU_SUBTYPE_ST40
+	default y
+	help
+	  Driver for the PIO pins on STMicroelectronics ST40 and ST200
+	  based parts.
+
+config STM_DMA
+	bool "STMicroelectronics DMA API"
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200
+	select SH_DMA_API
+	default y
+	---help---
+	  Selecting this option will provide support for STMicroelectronics'
+	  custom DMA API. This API provides support for data transfers of
+	  various dimensions and complex linked list operations. In addition
+	  to these free-running operations it also allows management of the
+	  paced-transfer peripherals on recent STM parts.
+
+	  On STb710x and STx7200 DMA support is vital for the correct operation of the
+	  sound system.
+
+	  If you have a device from STMicroelectronics, then say Y here.
+	  Otherwise say N.
+
+config MIN_STM_DMA_CHANNEL_NR
+	depends on STM_DMA
+	int "Lowest STM-FDMAC channel"
+	default "0"
+	help
+	  This allows you to specify the low boundary FDMA channel number to
+	  use with STM-DMA
+
+config MAX_STM_DMA_CHANNEL_NR
+	depends on STM_DMA
+	int "Highest STM-FDMAC channel"
+	default "15"
+	help
+	  This allows you to specify the high boundary FDMA channel number to
+	  use with STM-DMA
+
+config STM_DMA_DEBUG
+	bool "STMicroelectronics DMA Debug"
+	depends on STM_DMA
+	default n
+
+choice
+	prompt "FDMA firmware loading strategy"
+	depends on STM_DMA
+	default STM_DMA_FW_KERNEL
+
+config  STM_DMA_FW_USERSPACE
+	depends on EXPERIMENTAL
+	bool "Use hotplug firmware loading framework (EXPERIMENTAL)"
+
+config STM_DMA_FW_KERNEL
+	bool "Use firmware linked into the kernel image"
+
+endchoice
+
+config STM_SSC
+       bool "STM Synchronous Serial Controller"
+       default y
+       ---help---
+         This driver is required to support the I2C and the SPI
+         Protocol on STM SOCs
+
+config  STM_SSC_DEBUG
+	bool "STM SSC Debug"
+	depends on STM_SSC
+	default n
+	---help---
+	  Enable this option to print out information on STM SSC device driver
+
+config STM_SPI
+	bool "STM Serial Peripheral Interface"
+	select STM_SSC
+	---help---
+	  This driver is required to support the SPI Protocol
+
+config  STM_SPI_DEBUG
+        bool "STM SPI Debug"
+        depends on STM_SPI
+        default n
+        ---help---
+        Enable this option to print out information on STM SPI device driver
+
+config STM_SPI_CHAR_DEV
+	bool "STM SPI: add char device interface"
+	depends on STM_SPI
+	---help---
+	Enable this option to add the device file interface
+
+config STM_SPI_HW_FIFO
+	bool "STM SPI: hardware Fifo support"
+	depends on STM_SPI
+	---help---
+	Enable this option to add the ssc-hardware fifo support
+
+
+choice
+	prompt "STMicroelectronics coprocessor support"
+        depends on CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STB7100
+	default STM_COPROCESSOR
+        ---help---
+        Many of the ST system-on-chip devices have multiple CPUs, where a
+        master CPU running Linux has control over a number of slave CPUs,
+        which are usually used to run dedicated algorithms.
+        Enabling this option will add support to the Linux kernel to
+        control these slave CPUs, reserve memory for them, and thus allow
+        code to be downloaded onto them and executed.
+        Adding in the command line the following string:
+        coprocessor_mem=[offset]:size0[,size1][,size2]...
+        where:
+        offset defines where the co-processors region starts.
+               It's an offset from ST40 RAM start.
+        size{n} defines the region size for the n.th slave core (max 16M).
+
+        Example: coprocessor_mem=32m:16m,16m
+
+config  STM_COPROCESSOR
+	bool "STM coprocessor support"
+	help
+	  Select this option to enable support for the slave coprocessors
+	  found on many ST system-on-chip devices.
+
+config  STM_COPROCESSOR_FRMW
+	depends on CPU_SUBTYPE_STB7100
+	bool "The new STM coprocessor firmware support "
+	select FW_LOADER
+	help
+	  Select this option to enable support for the slave coprocessors
+	  found on many ST system-on-chip devices.
+
+endchoice
+
+config  COPROCESSOR_DEBUG
+        depends on STM_COPROCESSOR || STM_COPROCESSOR_FRMW
+        bool "STM coprocessor debug"
+        default n
+        ---help---
+        Enable this option to print out information about the slave CPUs
+        addresses and operations you are using for coprocessor.
+
+endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/Makefile linux-2.6.23.1-stm/drivers/stm/Makefile
--- linux-2.6.23.1/drivers/stm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/Makefile	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,17 @@
+#
+# Makefile for the STMicroelectronics device drivers.
+#
+
+obj-y				+= sysconf.o
+obj-$(CONFIG_STM_DMA)		+= 710x_fdma2.o
+obj-$(CONFIG_STM_PIO)		+= pio.o
+obj-$(CONFIG_STM_SSC)		+= stm_ssc.o
+obj-$(CONFIG_STM_SPI)		+= stm_spi.o
+ifneq ($(CONFIG_32BIT),y)
+obj-$(CONFIG_STM_COPROCESSOR)	+= stm-coprocessor.o
+obj-$(CONFIG_STM_COPROCESSOR_FRMW)   += stm-coprocessor_frmw.o
+ifneq ($(CONFIG_STM_COPROCESSOR)$(CONFIG_STM_COPROCESSOR_FRMW),nn)
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= copro-stb7100.o
+endif
+endif
+obj-y				+= emi.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/copro-stb7100.c linux-2.6.23.1-stm/drivers/stm/copro-stb7100.c
--- linux-2.6.23.1/drivers/stm/copro-stb7100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/copro-stb7100.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,109 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/stm/coprocessor.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/coproc.h>
+#include <asm/sections.h>
+#include <asm/addrspace.h>
+
+struct coproc_board_info coproc_info = {
+	.name = "st231",
+	.max_coprs = N_COPROC,
+};
+
+coproc_t coproc[N_COPROC];
+
+int coproc_cpu_open(coproc_t * cop)
+{
+	return (0);
+}
+
+int coproc_cpu_init(coproc_t * cop)
+{
+	BUG_ON(cop->id >= N_COPROC);
+
+	/*
+	 * define for the STb7100 the ST231 view of the LMI base address
+	 */
+	return (0);
+}
+
+int coproc_cpu_grant(coproc_t * cop, unsigned long arg)
+{
+	u_long bootAddr;
+	u_long cpu = cop->id;
+
+	BUG_ON(cpu >= N_COPROC);
+
+	if (arg == 0)
+		bootAddr = COPR_ADDR(cop, 0);
+	else
+		bootAddr = arg;
+
+	/* Now set the less meaningful bit to trigger the ST231 start */
+	bootAddr |= 1;
+	DPRINTK(">>> %s: ST231-%ld start from 0x%lx...\n",
+		xstring(PLATFORM), cpu, bootAddr);
+
+	/* stick it into the System configuration and... good luck! */
+	writel((readl(SYSCFG_09) | 0x08000000), SYSCFG_09);
+	writel(bootAddr, SYSCFG_BOOT_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) | 0x1), SYSCFG_RESET_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) & ~0x1), SYSCFG_RESET_REG(cpu));
+
+	msleep(10);
+
+	writel((readl(SYSCFG_09) & ~0x18000000), SYSCFG_09);
+
+	cop->control |= COPROC_RUNNING;
+	return (0);
+}
+
+int coproc_cpu_release(coproc_t * cop)
+{
+	/* do nothing! */
+	return (0);
+}
+
+int coproc_cpu_reset(coproc_t * cop)
+{
+	u_long cpu = cop->id;
+
+	/* Enable the ST231 CPUs to be resetted */
+	writel((readl(SYSCFG_09) | 0x08000000), SYSCFG_09);
+
+	writel((readl(SYSCFG_RESET_REG(cpu)) | 0x1), SYSCFG_RESET_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) & ~0x1), SYSCFG_RESET_REG(cpu));
+
+	msleep(10);
+
+	/* Disable the ST231 CPUs to be resetted */
+	writel((readl(SYSCFG_09) & ~0x18000000), SYSCFG_09);
+
+	return 0;
+}
+
+void coproc_proc_other_info(coproc_t * cop_dump, struct seq_file *s_file)
+{
+	return;			/* Do nothing, doesn't delete it */
+}
+
+int coproc_check_area(u_long addr, u_long size, int i, coproc_t * coproc)
+{
+#if 0
+        if (((addr >= CONFIG_MEMORY_START) && (addr < PHYSADDR(_end))) || \
+                (((addr + size) > CONFIG_MEMORY_START) && \
+		(addr < CONFIG_MEMORY_START)))
+        {
+                coproc[i].ram_offset = coproc[i].ram_size = 0;
+                return 1;
+        }
+#endif
+        return 0;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/emi.c linux-2.6.23.1-stm/drivers/stm/emi.c
--- linux-2.6.23.1/drivers/stm/emi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/emi.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/stm/emi.h>
+
+static unsigned long emi_memory_base;
+static void __iomem *emi_control;
+
+#define BANK_BASEADDRESS(b)		(0x800 + (0x10*b))
+#define BANK_EMICONFIGDATA(b, r)	(0x100 + (0x40*b) + (8*r))
+
+int __init emi_init(unsigned long memory_base, unsigned long control_base)
+{
+	if (!request_mem_region(control_base, 0x864, "EMI"))
+		return -EBUSY;
+
+	emi_control = ioremap(control_base, 0x864);
+	if (emi_control == NULL)
+		return -ENOMEM;
+
+	emi_memory_base = memory_base;
+
+	return 0;
+}
+
+unsigned long __init emi_bank_base(int bank)
+{
+	unsigned long reg = readl(emi_control + BANK_BASEADDRESS(bank));
+	return emi_memory_base + (reg << 22);
+}
+
+/*
+               ______________________________
+FMIADDR    ___/                              \________
+              \______________________________/
+
+
+(The cycle time specified in nano seconds)
+
+               |-----------------------------| cycle_time
+                ______________                ___________
+CYCLE_TIME     /              \______________/
+
+
+(IORD_start the number of nano seconds after the start of the cycle the
+RD strobe is asserted
+ IORD_end   the number of nano seconds before the end of the cycle the
+RD strob is de-asserted.)
+                  _______________________
+IORD       ______/                       \________
+
+              |--|                       |---|
+                ^--- IORD_start            ^----- IORD_end
+
+(RD_latch the number of nano seconds at the end of the cycle the read
+data is latched)
+                                 __
+RD_LATCH  ______________________/__\________
+
+                                |------------|
+                                     ^---------- RD_latch
+
+(IOWR_start the number of nano seconds after the start of the cycle the
+WR strobe is asserted
+ IOWR_end   the number of nano seconds before the end of the cycle the
+WR strob is de-asserted.)
+                  _______________________
+IOWR       ______/                       \________
+
+              |--|                       |---|
+                ^--- IOWR_start            ^----- IOWR_end
+
+
+
+*/
+
+/* NOTE: these calculations assume a 100MHZ clock */
+
+static void __init set_read_timings(int bank, int cycle_time,int IORD_start,
+				    int IORD_end,int RD_latch)
+{
+	cycle_time = cycle_time / 10;
+	IORD_start = IORD_start / 5 ;
+	IORD_end   = IORD_end / 5 ;
+	RD_latch   = RD_latch / 10;
+
+	writel((cycle_time << 24) | (IORD_start << 8) | (IORD_end << 12),
+	       emi_control+BANK_EMICONFIGDATA(bank,1));
+	writel(0x791 | (RD_latch << 20),
+	       emi_control+BANK_EMICONFIGDATA(bank,0));
+}
+
+static void __init set_write_timings(int bank, int cycle_time,int IOWR_start,
+				     int IOWR_end)
+{
+	cycle_time = cycle_time / 10;
+	IOWR_start = IOWR_start / 5 ;
+	IOWR_end   = IOWR_end / 5 ;
+
+	writel((cycle_time << 24) | (IOWR_start << 8) | (IOWR_end << 12),
+	       emi_control+BANK_EMICONFIGDATA(bank,2));
+}
+
+void __init emi_config_pata(int bank)
+{
+	/* Set timings for PIO4 */
+	set_read_timings(bank, 120,35,30,20);
+	set_write_timings(bank, 120,35,30);
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/fdma.h linux-2.6.23.1-stm/drivers/stm/fdma.h
--- linux-2.6.23.1/drivers/stm/fdma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/fdma.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2005,7 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#ifndef STB7100_FDMA_H
+#define STB7100_FDMA_H
+
+#define CHAN_ALL_ENABLE 				3
+
+/**cmd stat vals*/
+#define SET_NODE_COMP_PAUSE		    		1 <<30
+#define SET_NODE_COMP_IRQ				1 <<31
+#define NODE_ADDR_STATIC 				0x01
+#define NODE_ADDR_INCR	 				0x02
+
+#define SOURCE_ADDR 					0x05
+#define DEST_ADDR   					0x07
+
+#define CMDSTAT_FDMA_START_CHANNEL  			1
+#define CMDSTAT_FDMA_PAUSE_CHANNEL  			3
+
+
+#define STB7100_FDMA_CHANS              		16
+#define STB7109_FDMA_CHANS              		STB7100_FDMA_CHANS
+#define STB7200_FDMA_CHANS				32
+#define STB7100_REQ_LINES				32
+#define STB7200_REQ_LINES				64
+
+/*******************************/
+/*MBOX SETUP VALUES*/
+
+#define MBOX_CMD_PAUSE_CHANNEL		 		2
+#define MBOX_CMD_START_CHANNEL       			1
+#define CLEAR_WORD					0XFFFFFFFF
+
+#define IS_PACED_CHANNEL_SET(flags)(flags & 0x1f)
+#define ASSERT_NODE_BUS_ADDR(addr)( (((PXSEG(addr) == P0SEG) && addr))?1:0)
+#define IS_CHANNEL_PAUSED(fd,ch)(stb710x_get_engine_status(fd,ch)== FDMA_CHANNEL_PAUSED ?1:0)
+#define IS_CHANNEL_RUNNING(fd,ch)(stb710x_get_engine_status(fd,ch)== FDMA_CHANNEL_RUNNING ?1:0)
+#define IS_CHANNEL_IDLE(fd,ch)(stb710x_get_engine_status(fd,ch)== FDMA_CHANNEL_IDLE ?1:0)
+#define IS_TRANSFER_SG(parms)((MODE_SRC_SCATTER==parms->mode)||(MODE_DST_SCATTER==parms->mode )?1:0)
+#define MBOX_STR_CMD(ch) (MBOX_CMD_START_CHANNEL << (ch*2))
+#define CMD_STAT_REG(ch)(fd->io_base + fd->regs.fdma_cmd_statn + (ch * CMD_STAT_OFFSET))
+#define CH_PTR_REG(ch)(fd->io_base + fd->regs.fdma_ptrn  + (ch * CMD_STAT_OFFSET))
+
+#define IS_NODE_MALLOCED(priv)((priv.node!=0))
+
+
+#define IS_NODELIST_EQUAL(priv)((priv.sublist_nents == priv.alloced_nents))
+#define FDMA_CHAN(channel) ((struct channel_status*)(channel->priv_data))
+#define FDMA_DEV(channel) (FDMA_CHAN(channel)->fd)
+struct fdma_dev;
+
+typedef void (*pf)(void * data);
+
+#define CHANNEL_ERR_IRQ 		3
+#define CHANNEL_IRQ     		1
+
+#define FDMA_CHANNEL_IDLE 		0
+#define FDMA_CHANNEL_RUNNING 		2
+#define FDMA_CHANNEL_PAUSED 		3
+
+/*FDMA Channel FLAGS*/
+/*values below D28 are reserved for REQ_LINE parameter*/
+#define REQ_LINE_MASK 	0x1f
+
+#define CHAN_NUM(chan) ((chan) - chip.channel)
+
+typedef struct fdma_llu_entry {
+	u32 next_item;
+	u32 control;
+	u32 size_bytes;
+	u32 saddr;
+	u32 daddr;
+	u32 line_len;
+	u32 sstride;
+	u32 dstride;
+}fdma_llu_entry;
+
+
+struct llu_node{
+	struct fdma_llu_entry * virt_addr;
+	dma_addr_t dma_addr;
+};
+
+
+typedef struct dma_xfer_descriptor {
+	struct llu_node* (*extrapolate_fn)(struct stm_dma_params *xfer,
+					   struct dma_xfer_descriptor *desc,
+					   struct llu_node* nodes);
+	int	extrapolate_line_len;
+	struct fdma_llu_entry template_llu;
+
+	/* only used when this is the first parameter in a list */
+	struct 	llu_node *llu_nodes;
+	int 	alloced_nodes;
+}dma_xfer_descriptor;
+
+
+enum fdma_state {
+	FDMA_IDLE,
+	FDMA_CONFIGURED,
+	FDMA_RUNNING,
+	FDMA_STOPPING,
+	FDMA_PAUSING,
+	FDMA_PAUSED,
+};
+
+struct channel_status {
+	struct fdma_dev *fd;
+	enum fdma_state sw_state;
+	struct dma_channel * cur_cfg;
+	struct stm_dma_params *params;
+	struct tasklet_struct fdma_complete;
+	struct tasklet_struct fdma_error;
+};
+
+#define FDMA_NAME_LEN 20
+
+struct fdma_dev {
+	char				name[FDMA_NAME_LEN];
+	struct dma_info 		dma_info;
+	struct channel_status		channel[STB7100_FDMA_CHANS];
+	spinlock_t 			channel_lock;
+	struct resource *		phys_mem;
+	void __iomem			*io_base;
+	u32				firmware_loaded;
+	u8				ch_min;
+	u8 				ch_max;
+	u8				irq_val;
+	u8				fdma_num;
+	u32				ch_status_mask;
+	struct dma_pool 		*llu_pool;
+	wait_queue_head_t		fw_load_q;
+
+	struct fdma_regs		regs;
+
+	char *				fw_name;
+	struct fdma_fw			fw;
+	int				comp_ch;
+
+	/* This is used with the xbar to allocate the next available req line */
+	unsigned long 			req_lines_inuse;
+};
+
+typedef volatile unsigned long device_t;
+
+#define fdma_printk(level, fd, format, arg...)	\
+	dev_printk(level, &fd->dma_info.pdev->dev, format, ## arg);
+#define fdma_info(fd, format, arg...)		\
+	fdma_printk(KERN_INFO, fd, format, ## arg)
+
+#if defined(CONFIG_STM_DMA_DEBUG)
+#define fdma_dbg(fd, format, arg...)		\
+	fdma_printk(KERN_DEBUG, fd, format, ## arg)
+#else
+#define fdma_dbg(fd, format, arg...)		do { } while (0)
+#endif
+
+struct stm_dma_req {
+	struct channel_status *chan;
+	int local_req_line;
+};
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/pio.c linux-2.6.23.1-stm/drivers/stm/pio.c
--- linux-2.6.23.1/drivers/stm/pio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/pio.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,411 @@
+/*
+ * drivers/stm/pio.c
+ *
+ * (c) 2001 Stuart Menefy <stuart.menefy@st.com>
+ * based on hd64465_gpio.c:
+ * by Greg Banks <gbanks@pocketpenguins.com>
+ * (c) 2000 PocketPenguins Inc
+ *
+ * PIO pin support for ST40 devices.
+ *
+ * History:
+ * 	9/3/2006
+ * 	Added stpio_enable_irq and stpio_disable_irq
+ * 		Angelo Castello <angelo.castello@st.com>
+ * 	13/3/2006
+ * 	Added stpio_request_set_pin and /proc support
+ * 	  	 Marek Skuczynski <mareksk@easymail.pl>
+ *	13/3/2006
+ *	Integrated patches above and tidied up STPIO_PIN_DETAILS
+ *	macro to stop code duplication
+ *		Carl Shaw <carl.shaw@st.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/stm/pio.h>
+#include <linux/platform_device.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq-ilc.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/kallsyms.h>
+#endif
+
+#define STPIO_POUT_OFFSET	0x00
+#define STPIO_PIN_OFFSET	0x10
+#define STPIO_PC0_OFFSET	0x20
+#define STPIO_PC1_OFFSET	0x30
+#define STPIO_PC2_OFFSET	0x40
+#define STPIO_PCOMP_OFFSET	0x50
+#define STPIO_PMASK_OFFSET	0x60
+
+#define STPIO_SET_OFFSET	0x4
+#define STPIO_CLEAR_OFFSET	0x8
+
+#define DRIVER_NAME "stpio"
+#define STPIO_MAX_PORTS	8
+
+struct stpio_port {
+	void __iomem *base;
+};
+
+struct stpio_pin {
+	const char* name;
+	void (*func)(struct stpio_pin *pin, void *dev);
+	void *dev;
+#ifdef CONFIG_PROC_FS
+	int  direction;
+#endif
+};
+
+static struct stpio_port stpio_port_confs[STPIO_MAX_PORTS];
+static int stpio_numports = STPIO_MAX_PORTS;
+static struct stpio_pin stpio_pin_conf[STPIO_MAX_PORTS*8];
+static spinlock_t stpio_lock = SPIN_LOCK_UNLOCKED;
+
+#define STPIO_PIN_DETAILS(pin, port, pinno)		\
+	unsigned int pinno;				\
+	const struct stpio_port *port;			\
+	do {						\
+		unsigned offset = pin - stpio_pin_conf;	\
+		port = &stpio_port_confs[offset >> 3];	\
+		pinno = offset & 7;			\
+	} while (0)
+
+void stpio_configure_pin(struct stpio_pin* pin, int direction)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+#ifdef CONFIG_PROC_FS
+	pin->direction = direction;
+#endif
+
+	writel(1<<pinno, port->base + STPIO_PC0_OFFSET +
+	       ((direction & (1<<0)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+	writel(1<<pinno, port->base + STPIO_PC1_OFFSET +
+	       ((direction & (1<<1)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+	writel(1<<pinno, port->base + STPIO_PC2_OFFSET +
+	       ((direction & (1<<2)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+}
+
+struct stpio_pin* stpio_request_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction)
+{
+	struct stpio_pin *pin = NULL;
+
+	spin_lock(&stpio_lock);
+
+	if ((portno < stpio_numports) && (pinno < 8) &&
+	    (stpio_pin_conf[portno*8 + pinno].name == NULL)) {
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		stpio_configure_pin(pin, direction);
+		pin->name = name;
+	}
+
+	spin_unlock(&stpio_lock);
+
+	return pin;
+}
+
+struct stpio_pin* stpio_request_set_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction, unsigned int value)
+{
+	struct stpio_pin *pin = NULL;
+
+	spin_lock(&stpio_lock);
+
+	if ((portno < stpio_numports) && (pinno < 8)) {
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		if( (pin->name == NULL) ) {
+		    stpio_set_pin(pin, value);
+		    stpio_configure_pin(pin, direction);
+		    pin->name = name;
+		} else {
+		    pin = NULL;
+		}
+	}
+
+	spin_unlock(&stpio_lock);
+
+	return pin;
+}
+
+void stpio_free_pin(struct stpio_pin* pin)
+{
+	stpio_configure_pin(pin, STPIO_IN);
+	pin->name = NULL;
+	pin->func = 0;
+	pin->dev  = 0;
+}
+
+void stpio_set_pin(struct stpio_pin* pin, unsigned int value)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	writel(1<<pinno, port->base + STPIO_POUT_OFFSET +
+	       (value ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+}
+
+unsigned int stpio_get_pin(struct stpio_pin* pin)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	return (readl(port->base + STPIO_PIN_OFFSET) & (1<<pinno)) ? 1 : 0;
+}
+
+static irqreturn_t stpio_interrupt(int irq, void *dev)
+{
+	const struct stpio_port *port = dev;
+	unsigned portno = port - stpio_port_confs;
+    	unsigned long in, mask, comp;
+	unsigned int pinno;
+
+	in   = readl(port->base + STPIO_PIN_OFFSET);
+	mask = readl(port->base + STPIO_PMASK_OFFSET);
+	comp = readl(port->base + STPIO_PCOMP_OFFSET);
+
+	mask &= in ^ comp;
+
+	while ((pinno = ffs(mask)) != 0) {
+		struct stpio_pin *pin;
+		pinno--;
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		if (pin->func != 0)
+			pin->func(pin, pin->dev);
+		else
+			printk(KERN_NOTICE "unexpected PIO interrupt, PIO%d[%d]\n",
+			       portno, pinno);
+		mask &= ~(1<<pinno);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void stpio_enable_irq(struct stpio_pin* pin, int comp)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	writel(1<<pinno, port->base + STPIO_PCOMP_OFFSET +
+	       (comp ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+	writel(1<<pinno, port->base + STPIO_PMASK_OFFSET + STPIO_SET_OFFSET);
+}
+
+void stpio_disable_irq(struct stpio_pin* pin)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	writel(1<<pinno, port->base + STPIO_PMASK_OFFSET + STPIO_CLEAR_OFFSET);
+}
+
+void stpio_request_irq(struct stpio_pin* pin, int comp,
+		       void (*handler)(struct stpio_pin *pin, void *dev),
+		       void *dev)
+{
+	unsigned long flags;
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	spin_lock_irqsave(&stpio_lock, flags);
+
+	pin->func = handler;
+	pin->dev = dev;
+
+	stpio_enable_irq(pin, comp);
+
+	spin_unlock_irqrestore(&stpio_lock, flags);
+}
+
+void stpio_free_irq(struct stpio_pin* pin)
+{
+	unsigned long flags;
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	spin_lock_irqsave(&stpio_lock, flags);
+
+	stpio_disable_irq(pin);
+	pin->func = 0;
+	pin->dev = 0;
+
+	spin_unlock_irqrestore(&stpio_lock, flags);
+}
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_stpio;
+
+static const char *stpio_dir_name[] =
+{
+    "IN  (pull-up)      ",
+    "BI  (open-drain)   ",
+    "OUT (push-pull)    ",
+    "forbidden          ",
+    "IN  (Hi-Z)         ",
+    "forbidden          ",
+    "Alt-OUT (push-pull)",
+    "Alt-BI (open-drain)"
+};
+
+static const char *stpio_get_handler_name(unsigned long addr)
+{
+    static char sym_name[KSYM_NAME_LEN+1];
+    char *modname;
+    unsigned long symbolsize, offset;
+    const char *symb;
+
+    symb = kallsyms_lookup(addr, &symbolsize, &offset, &modname, sym_name);
+    return ( symb ? symb : "");
+}
+
+static inline int stpio_proc_info (char *buf, int port, int pin)
+{
+/*
+    PIO port.pin name mode handler_name mask
+*/
+    struct stpio_pin *pin_ptr = &stpio_pin_conf[port*8 + pin];
+
+    return sprintf(buf, "PIO %d.%d [%-10s] [%s] [%s]\n",
+	port, pin,
+	(pin_ptr->name ? pin_ptr->name : "     "),
+	stpio_dir_name[pin_ptr->direction & 0x7],
+	(pin_ptr->func ? stpio_get_handler_name((unsigned long)pin_ptr->func) : "")
+	);
+}
+
+static int stpio_read_proc (char *page, char **start, off_t off, int count,
+			  int *eof, void *data_unused)
+{
+	int len, l, i, j;
+        off_t   begin = 0;
+
+	spin_lock(&stpio_lock);
+
+	len = sprintf(page, "  port      name          direction\n");
+        for (i=0; i< stpio_numports; i++)
+	{
+	    for(j=0; j < 8; j++ )
+	    {
+                l = stpio_proc_info(page + len, i, j);
+                len += l;
+                if (len+begin > off+count)
+                        goto done;
+                if (len+begin < off) {
+                        begin += len;
+                        len = 0;
+                }
+	    }
+        }
+
+        *eof = 1;
+
+done:
+	spin_unlock(&stpio_lock);
+        if (off >= len+begin)
+                return 0;
+        *start = page + (off-begin);
+        return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+#endif /* CONFIG_PROC_FS */
+
+/* This is called early to allow board start up code to use PIO
+ * (in particular console devices). */
+void __init stpio_early_init(struct platform_device* pdev, int num)
+{
+	int i;
+
+	for (i=0; i<num; i++, pdev++) {
+		struct stpio_port *port = &stpio_port_confs[i];
+		int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+		port->base = ioremap(pdev->resource[0].start, size);
+	}
+}
+
+static int __devinit stpio_probe(struct platform_device *pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	struct stpio_port *port = &stpio_port_confs[pdev->id];
+
+	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+		return -EBUSY;
+
+	if (!port->base) {
+		port->base = ioremap(pdev->resource[0].start, size);
+		if (! port->base) {
+			release_mem_region(pdev->resource[0].start, size);
+			return -ENOMEM;
+		}
+	}
+
+	request_irq(pdev->resource[1].start, stpio_interrupt,
+		    0, pdev->name, (void*)port);
+
+	return 0;
+}
+
+static int __devexit stpio_remove(struct platform_device *pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	struct stpio_port *port = &stpio_port_confs[pdev->id];
+
+	iounmap(port->base);
+	release_mem_region(pdev->resource[0].start, size);
+	free_irq(pdev->resource[1].start, port);
+
+	return 0;
+}
+
+static struct platform_driver stpio_driver = {
+	.probe		= stpio_probe,
+	.remove		= __devexit_p(stpio_remove),
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init stpio_init(void)
+{
+#ifdef CONFIG_PROC_FS
+	if ((proc_stpio = create_proc_entry("stpio", 0, NULL)) != NULL)
+		proc_stpio->read_proc = stpio_read_proc;
+#endif
+
+	return platform_driver_register(&stpio_driver);
+}
+
+static void __exit stpio_exit(void)
+{
+#ifdef CONFIG_PROC_FS
+	if (proc_stpio)
+		remove_proc_entry("stpio", NULL);
+#endif
+
+	platform_driver_unregister(&stpio_driver);
+}
+
+module_init(stpio_init);
+module_exit(stpio_exit);
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics PIO driver");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(stpio_configure_pin);
+EXPORT_SYMBOL(stpio_request_pin);
+EXPORT_SYMBOL(stpio_request_set_pin);
+EXPORT_SYMBOL(stpio_free_pin);
+EXPORT_SYMBOL(stpio_get_pin);
+EXPORT_SYMBOL(stpio_set_pin);
+EXPORT_SYMBOL(stpio_request_irq);
+EXPORT_SYMBOL(stpio_free_irq);
+EXPORT_SYMBOL(stpio_disable_irq);
+EXPORT_SYMBOL(stpio_enable_irq);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm-coprocessor.c linux-2.6.23.1-stm/drivers/stm/stm-coprocessor.c
--- linux-2.6.23.1/drivers/stm/stm-coprocessor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm-coprocessor.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,734 @@
+/*
+ * Copyright (C) 2003-2004 Giuseppe Cavallaro (peppe.cavallaro@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interfaces (where required) the co-processors on ST platforms based
+ * on multiprocessor architecture, for embedded products like Set-top-Box
+ * DVD, etc...
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/stm/coprocessor.h>
+#include <linux/platform_device.h>
+#include <asm/types.h>
+#include <asm/uaccess.h>
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int __init proc_st_coproc_init(void);
+#endif
+
+/* ---------------------------------------------------------------------------
+ *     Local (declared out of order) functions
+ * ------------------------------------------------------------------------ */
+
+static int __init parse_coproc_mem(char *from);
+
+/* ---------------------------------------------------------------------------
+ *    Exported and Imported
+ * ------------------------------------------------------------------------ */
+extern unsigned long memory_start, memory_end;
+
+/* ---------------------------------------------------------------------------
+ * 		Co-processor: Hardware dependent support
+ * This includes:
+ *    - per platform device and memory addresses
+ *    - platform dependent macros
+ *    - HW dependent actions required by the generic APIs: Init,
+ *      Open, Release, Ioctl (to reset, trigger the start (grant),
+ *      peek and poke, etc...) functions
+ * ------------------------------------------------------------------------ */
+
+extern struct coproc_board_info coproc_info;
+
+/* ---------------------------------------------------------------------------
+ *    Local data structure
+ * ------------------------------------------------------------------------ */
+
+extern coproc_t coproc[];	/* The maximum number of copro-  */
+					   /* cessors depends on platform   */
+					   /* type                          */
+
+#ifdef CONFIG_DEVFS_FS
+static devfs_handle_t devfs_reset_hdl;
+#endif
+
+#if defined(CONFIG_COPROCESSOR_DEBUG)
+/* -------------------------------------------------------------------------
+ * 			Co-processor DEBUG Suppor26t
+ *
+ *  Currently we do not expect to receive asynchronous events from the
+ *  slave processor. This routine as well as the IRQ definition has been
+ *  foreseen and used for debug purposes.
+ *  Once a slave is started the standard and supported way of communicating
+ *  with the host processor is to rely on the RPC service.
+ */
+
+static int irq_count = 0;
+static void mbx_irq_handle(int irq, void *cop, struct pt_regs *regs)
+{
+	/* avoid a noisy loop if possible! */
+	irq_count++;
+	if ((irq_count % 100) == 0)
+		printk("st-coprocessor: unexpected interrupt %d from %s.%u\n",
+		       irq, ((coproc_t *) cop)->pdev.name,((coproc_t *) cop)->pdev.id);
+
+	(void)&mbx_irq_handle;	/* warning suppression */
+}
+
+#endif				/* CONFIG_COPROCESSOR_DEBUG */
+
+static void __debug(coproc_t * cop, const char *fnc)
+{
+
+	/* Print the coprocessor control structure */
+	printk("%s.%u Coprocessor -------------------------------------------\n",
+	       cop->pdev.name,cop->pdev.id);
+	if (cop->control == 0 || cop->ram_size == 0) {
+		printk("    not configured!\n");
+		goto skip_debug;
+	} else {
+		printk
+		    ("    flags %04x RAM start at 0x%08lx  size      0x%08x\n",
+		     cop->control, HOST_ADDR(cop, 0), cop->ram_size);
+		printk("                  cop. addr 0x%08lx\n",
+		       COPR_ADDR(cop, 0));
+	}
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	if (cop->h2c_port)
+		printk
+		    ("    Channels : h->c 0x%08x (%08lx)    c->h 0x%08x (%08lx)\n",
+		     cop->h2c_port, readl(cop->h2c_port), cop->c2h_port,
+		     readl(cop->c2h_port));
+	else
+#endif
+		printk("    Channels : Not defined\n");
+
+	if (cop->irq)
+		printk("    IRQ      : %d\n", cop->irq);
+	else
+		printk("    IRQ      : not used\n");
+
+      skip_debug:
+	printk
+	    ("---------------------------------------------------------------\n");
+
+}
+
+/* ---------------------------------------------------------------------------
+ * 			Co-processor driver APIs
+ * ------------------------------------------------------------------------ */
+
+static int st_coproc_open(struct inode *inode, struct file *file)
+{
+	/*
+	 ** use minor number (ID) to access the current coproc. descriptor
+	 */
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	DPRINTK(">>> %s: %s-%u, cop->control = %d, cop->ram_size = %d\n",
+		__FUNCTION__, cop->pdev.name,cop->pdev.id, cop->control, cop->ram_size);
+
+	if (((cop - coproc) / sizeof(coproc_t)) >= coproc_info.max_coprs)
+		return (-ENODEV);
+	if (cop->ram_size == 0)
+		return (-ENOSPC);
+	if (cop->control & COPROC_IN_USE)
+		return (-EBUSY);
+	cop->control |= COPROC_IN_USE;
+
+	/* Now call the platform dependent open stage */
+	coproc_cpu_open(cop);
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	__debug(cop, __FUNCTION__);
+#endif
+	return 0;
+}
+
+static int st_coproc_release(struct inode *inode, struct file *file)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	coproc_cpu_release(cop);
+	cop->control &= ~COPROC_IN_USE;
+
+	return 0;
+}
+
+static int st_coproc_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+	int res = 0;
+
+	switch (cmd) {
+	case STCOP_RESET:
+		res = coproc_cpu_reset(cop);
+		break;
+	case STCOP_GRANT:
+		/* Release the Slave CPU from reset (do not wait) */
+		res = coproc_cpu_grant(cop, arg);
+		break;
+
+/* Peek and poke 32 bit cell:  for debug only
+ * ------------------------------------------
+ * Not generally available, not documented and not supported.
+ * Simple and perhaps not reliable way for writing and reading a 32 bit
+ * value using the <stslave> application.
+ * PAY ATTENTION: the code doesn't make any validity check hence the use
+ *                of a wrong address may have undesired effects!
+ */
+#define PAIRS(p) (p)[0]		/* Number of couple:  addr./value */
+#define PORT(p)  (p)[1]		/* the address (port)             */
+#define VALUE(p) (p)[2]		/* the 32 bit value               */
+
+	case STCOP_PEEK:
+		{
+			u_long peek[3];
+			res = -EINVAL;
+
+			/* so far we need to peek only a single 32 bit cell */
+			if ((res = copy_from_user(peek, arg, sizeof(peek))) < 0)
+				break;
+			if (PAIRS(peek) != 1)
+				break;
+
+			/* make the addr 32 bit aligned  and peek the value */
+			PORT(peek) &= ~0x3;
+			VALUE(peek) = peek_l(PORT(peek));
+
+			DPRINTK(">>> %s: %s.%u;  peek[%ld] @0x%08lx = 0x%08lx\n",
+				__FUNCTION__, cop->pdev.name,cop->pdev.id,
+				PAIRS(peek), PORT(peek), VALUE(peek));
+
+			/* don't mind wich data, make it availbale to the user */
+			res = copy_to_user((void *)arg, peek, sizeof(peek));
+			break;
+		}
+
+	case STCOP_POKE:
+		{
+			u_long poke[3];
+			res = -EINVAL;
+
+			/* so far we need to peek only a single 32 bit cell */
+			if ((res = copy_from_user(poke, arg, sizeof(poke))) < 0)
+				break;
+			if (PAIRS(poke) != 1)
+				break;
+
+			/* make the addr 32 bit aligned  and poke the value */
+			PORT(poke) &= ~0x3;
+			poke_l(VALUE(poke), PORT(poke));
+
+			DPRINTK(">>> %s: %s.%u;  poke[%ld] @0x%08lx = 0x%08lx\n",
+				__FUNCTION__, cop->pdev.name,cop->pdev.id,
+				PAIRS(poke), PORT(poke), VALUE(poke));
+			res = 0;
+			break;
+		}
+
+	case STCOP_GET_PROPERTIES:
+		{
+			cop_properties_t clayout;
+
+//			strncpy(clayout.name, cop->pdev.name,
+//				sizeof(clayout.name));
+			sprintf(clayout.name,"%s-%u",cop->pdev.name,cop->pdev.id);
+			clayout.flags = cop->control;
+
+			clayout.ram_start = HOST_ADDR(cop, 0);
+			clayout.ram_size = cop->ram_size;
+			clayout.cp_ram_start = COPR_ADDR(cop, 0);
+
+			res =
+			    copy_to_user((void *)arg, &clayout,
+					 sizeof(cop_properties_t));
+			break;
+		}
+
+	case STCOP_SET_PROPERTIES:
+		{
+			/* Not yet supported! */
+			printk(KERN_INFO
+			       "%s.%u: setting properties not yet available\n",
+			       cop->pdev.name,cop->pdev.id);
+			res = -ENOSYS;
+			break;
+		}
+
+	default:
+		res = -EINVAL;
+	}
+	return (res);
+}
+
+static ssize_t st_coproc_read(struct file *file, char *buf,
+			      size_t count, loff_t * ppos)
+{
+	coproc_t *cop;
+	u_long from;
+	ssize_t bytes;
+	u_int offset = *ppos;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/*
+	 * File position assumes the Coprocessor RAM base addr.
+	 * normalaized to 0
+	 */
+	if (offset >= cop->ram_size)
+		return (0);
+
+	from = (u_long) HOST_ADDR(cop, offset);
+	bytes = min(count, (cop->ram_size - offset));
+
+	DPRINTK(">>> %s: from 0x%08lx to 0x%08x len 0x%x(%d)\n",
+		__FUNCTION__, from, (u_int) buf, bytes, bytes);
+
+	if (copy_to_user(buf, from, bytes))
+		return (-EFAULT);
+
+	*ppos += bytes;
+
+	return (bytes);
+}
+
+static ssize_t st_coproc_write(struct file *file, const char *buf,
+			       size_t count, loff_t * ppos)
+{
+	coproc_t *cop;
+	u_long to;
+	ssize_t bytes;
+	u_int offset = (u_int) * ppos;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/* File position assumes the RAM base addr. normalaized to 0 */
+	if (offset >= (u_long) cop->ram_size)
+		return (-EFBIG);
+
+	to = (u_long) HOST_ADDR(cop, offset);
+	bytes = min(count, (cop->ram_size - offset));
+
+	DPRINTK(">>> %s: from 0x%08x to 0x%08lx len 0x%x(%d)\n",
+		__FUNCTION__, (u_int) buf, to, bytes, bytes);
+
+	if (copy_from_user(to, buf, bytes))
+		return (-EFAULT);
+
+	*ppos += bytes;
+	return (bytes);
+}
+
+static loff_t st_coproc_llseek(struct file *file, loff_t fpos, int orig)
+{
+	coproc_t *cop;
+	u_long offset = fpos;
+	u_long base;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/*
+	 * fpos  can be a real offset within the coprocessor region or a
+	 * direct host address in the region (coming from application in
+	 * case of mmap).  This code assumes to be an address if it abs.
+	 * value > COPR_ADDR, a normal offset otherwyse.
+	 */
+	base = HOST_ADDR(cop, 0);
+
+	DPRINTK
+	    (">>> %s: seek to: 0x%08lx ->  fpos = offset 0x%lx + base 0x%lx\n",
+	     __FUNCTION__, (u_long) fpos, offset, HOST_ADDR(cop, 0));
+
+	switch (orig) {
+	case 0:
+		file->f_pos = offset;
+		break;		/* SEEK_SET */
+	case 1:
+		file->f_pos += offset;
+		break;		/* SEEK_CUR */
+	case 2:
+		file->f_pos = cop->ram_size + offset;
+		break;		/* SEEK_END */
+	default:
+		return -EINVAL;
+	}
+
+	if (file->f_pos >= cop->ram_size)
+		file->f_pos = cop->ram_size - 1;
+
+	return (file->f_pos);
+
+}
+
+static int st_coproc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned int vsize = vma->vm_end - vma->vm_start;
+	unsigned int psize = cop->ram_size - offset;
+
+	DPRINTK(">>> %s: vm_start=0x%lx, vm_end=0x%lx, vm_pgoff=0x%lx\n",
+		__FUNCTION__, vma->vm_start, vma->vm_end, vma->vm_pgoff);
+
+	if (vsize > psize)
+		return (-ENOSPC);
+
+	/*
+	 * Call the remap_pfn_range(...) function to map in user space the
+	 * coprocessor memory region. Uses ST40 no cache region
+	 */
+	vma->vm_flags |= VM_IO;
+	/* TODO: double check this. was a call
+	 *       to remap_page_range but without the >> PAGE_SHIFT
+	 */
+	if (remap_pfn_range(vma, vma->vm_start, cop->ram_offset
+			    >> PAGE_SHIFT, vsize, vma->vm_page_prot)) {
+		DPRINTK(">>> %s: remap_page_range(...) failed\n", __FUNCTION__);
+		return (-EAGAIN);
+	}
+
+	DPRINTK(">>> %s: ... done: 0x%08lx len 0x%x --> 0x%08lx\n",
+		__FUNCTION__, (unsigned long)HOST_ADDR(cop, 0), vsize,
+		vma->vm_start);
+	return (0);
+}
+
+static struct file_operations coproc_fops = {
+      llseek:st_coproc_llseek,
+      read:st_coproc_read,
+      write:st_coproc_write,
+      ioctl:st_coproc_ioctl,
+      mmap:st_coproc_mmap,
+      open:st_coproc_open,
+      release:st_coproc_release
+};
+
+/* Start: ST-Coprocessor Device Attribute on SysFs*/
+static ssize_t st_copro_show_running(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "%d", cop->control & COPROC_IN_USE);
+}
+
+static DEVICE_ATTR(running, S_IRUGO, st_copro_show_running, NULL);
+
+static ssize_t st_copro_show_mem_size(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "0x%x", cop->ram_size);
+}
+
+static DEVICE_ATTR(mem_size, S_IRUGO, st_copro_show_mem_size, NULL);
+
+static ssize_t st_copro_show_mem_base(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "0x%x", (int)cop->ram_offset);
+}
+
+static DEVICE_ATTR(mem_base, S_IRUGO, st_copro_show_mem_base, NULL);
+/* End: ST-Coprocessor Device Attribute SysFs*/
+
+static int st_coproc_driver_probe(struct platform_device *dev)
+{
+	if (!strncmp("st2", dev->name, 3))
+		return 1;
+	if (!strncmp("lx2", dev->name, 3))
+		return 1;
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+static int st_coproc_suspend(struct platform_device * dev, pm_message_t state)
+{
+	printk("st_coproc_suspend: %s.%u down\n",dev->name,dev->id);
+	return 0;
+}
+static int st_coproc_resume(struct platform_device * dev)
+{
+	printk("st_coproc_resume: %s.%u up\n",dev->name,dev->id);
+	return 0;
+}
+#endif
+
+static struct platform_driver st_coproc_driver = {
+	.driver.name = "st-copro",
+	.driver.owner = THIS_MODULE,
+	.probe = st_coproc_driver_probe,
+#if defined(CONFIG_PM)
+	.suspend =st_coproc_suspend,
+	.resume = st_coproc_resume,
+#endif
+};
+
+static int __init st_coproc_init(void)
+{
+	int i;
+	coproc_t *cop;
+	struct platform_device *pdev;
+
+	printk("STMicroelectronics - Coprocessors %s Init\n", coproc_info.name);
+
+	if (platform_driver_register(&st_coproc_driver)){
+		printk(KERN_ERR
+		       "Error on ST-Coprocessor device driver registration\n");
+		return (-EAGAIN);
+	}
+
+	if (register_chrdev(COPROCESSOR_MAJOR, coproc_info.name, &coproc_fops)) {
+		printk("Can't allocate major %d for ST Coprocessor Devices\n",
+		       COPROCESSOR_MAJOR);
+		return (-EAGAIN);
+	}
+
+	for (cop = &coproc[0], i = 0; i < coproc_info.max_coprs; i++, cop++) {
+		cop->id = i;
+
+		if (!cop->ram_offset) {
+			printk("st-coprocessor-%d: No RAM reserved\n", cop->id);
+			cop->control &= ~COPROC_SPACE_ALLOCATE;
+		} else {
+			cop->control |= COPROC_SPACE_ALLOCATE;
+			cop->vma_address =
+				ioremap_nocache((unsigned long)cop->ram_offset, cop->ram_size);
+		}
+		/*
+		 ** Nodes:
+		 **    STm8000/ST220Eval: /dev/st220-0    c   63   0
+		 **                       /dev/st220-1    c   63   1
+		 **                       /dev/st220-2    c   63   2
+		 **    STb7100          : /dev/st231-0    c   63   0
+		 **                    : /dev/st231-1    c   63   1
+		 ** if the device file system support is configured the above
+		 ** devices are autonatically generated
+		 */
+		pdev = &(cop->pdev);
+		memset(pdev, 0, sizeof(struct platform_device));
+		pdev->name = coproc_info.name;
+		pdev->id   = i;
+		pdev->dev.driver = &st_coproc_driver.driver;
+
+		if (platform_device_register(pdev)<0)
+			printk(KERN_ERR
+			       "Error on ST-Coprocessor device registration\n");
+		else {
+			/* Add the attributes on the device */
+			device_create_file(&pdev->dev, &dev_attr_mem_base);
+			device_create_file(&pdev->dev, &dev_attr_mem_size);
+			device_create_file(&pdev->dev, &dev_attr_running);
+		}
+
+		/* Now complete with the platform dependent init stage */
+#if defined(CONFIG_COPROCESSOR_DEBUG) && defined(RPC_DEBUG)
+		{
+			/* just to debug on STi5528 application using the RPC 2.1,
+			 * install a fake interrupt hadler
+			 */
+			int res;
+
+			cop->irq = EMBX_IRQ + i;
+			if ((res = request_irq(cop->irq, &mbx_irq_handle, 0,
+					       coproc_info.name, cop)) != 0) {
+				printk
+				    ("st-coprocessor: Error %d booking IRQ %d for %s\n",
+				     res, cop->irq, cop->name);
+				cop->irq = 0;
+			}
+		}
+#endif
+		__debug(cop, __FUNCTION__);
+	}
+
+#ifdef CONFIG_PROC_FS
+	proc_st_coproc_init();
+#endif
+
+	return (0);
+}
+
+static void __exit st_coproc_exit(void)
+{
+	DPRINTK("Release coprocessor module...\n");
+}
+
+/*
+ * Parse the optional kernel argument:
+ *
+ * ... coprocessor_mem=size_0@phis_address_0, size_1@phis_address_1
+ *
+ * It seems to be reasonable to assume that in a "staically partitioned
+ * RAM layout", the regions of RAM assigned to each slave processor are
+ * not scattered in memory!
+ */
+static int __init parse_coproc_mem(char *from)
+{
+	char *cmdl = (from);	/* start scan from '=' char */
+	u_long size, addr;
+	int i = 0;
+	char *error_msg;
+	static char size_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing size\n";
+	static char addr_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing address\n";
+	static char too_many_warn[] __initdata =
+		KERN_WARNING "st-coprocessor: More regions than coprocessors\n";
+	static char alloc_error[] __initdata =
+		KERN_ERR "st-coprocessor: Failed to reserve memory at 0x%08x\n";
+
+	while (*cmdl && (i < coproc_info.max_coprs)) {
+		size = memparse(cmdl, &cmdl);
+		if (*cmdl != '@') {
+			error_msg = size_error;
+			goto args_error;
+		}
+		addr = memparse(cmdl+1, &cmdl);
+		if (*cmdl) {
+			if (*cmdl++ != ',') {
+				error_msg = addr_error;
+				goto args_error;
+			}
+		}
+		coproc[i].ram_offset = addr;
+		coproc[i].ram_size = size;
+		++i;
+	}
+
+	if (*cmdl) {
+		printk(too_many_warn);
+	}
+
+	for (i = 0; i < coproc_info.max_coprs; ++i) {
+		if (coproc[i].ram_size) {
+			void* mem;
+			addr = coproc[i].ram_offset;
+			size = coproc[i].ram_size;
+			/* Switch to __alloc_bootmem_nopanic or
+			 * __alloc_bootmem_core when we update the kernel. */
+			mem = __alloc_bootmem(size, PAGE_SIZE, addr);
+			if (mem != __va(addr)) {
+				if (mem) {
+					free_bootmem(virt_to_phys(mem), size);
+				}
+				/* At this point, if addr overlaps kernel
+				 * memory, coprocessor won't be allocated.
+				 */
+				if (coproc_check_area(addr, size, i, coproc))
+					printk(alloc_error, addr);
+			}
+		}
+	}
+
+	return 1;
+
+args_error:
+	printk(error_msg);
+	return 1;
+}
+
+__setup("coprocessor_mem=", parse_coproc_mem);
+
+MODULE_DESCRIPTION("Co-processor manager for multi-core devices");
+MODULE_AUTHOR("STMicroelectronics Limited");
+MODULE_VERSION("0.3");
+MODULE_LICENSE("GPL");
+
+module_init(st_coproc_init);
+module_exit(st_coproc_exit);
+
+#ifdef CONFIG_PROC_FS
+
+static int show_st_coproc(struct seq_file *m, void *v)
+{
+	int i;
+	coproc_t *cop;
+	seq_printf(m, "Coprocessors: %d  %s\n",
+		   coproc_info.max_coprs, coproc_info.name);
+	seq_printf(m,
+		   "  CPU (dev)        Host addr.     Copr. addr.     Size\n");
+	seq_printf(m,
+		   "  -------------------------------------------------------------------\n");
+	for (i = 0, cop = &coproc[0]; i < coproc_info.max_coprs; i++, cop++) {
+		seq_printf(m, "  /dev/%s-%u    ", cop->pdev.name,cop->pdev.id);
+		if (cop->ram_size == 0)
+			seq_printf(m, "not allocated!\n");
+		else
+			seq_printf(m,
+				   "0x%08lx     0x%08lx      0x%08x (%2d Mb)\n",
+				   HOST_ADDR(cop, 0), COPR_ADDR(cop, 0),
+				   cop->ram_size, (cop->ram_size / MEGA));
+	}
+	seq_printf(m, "\n");
+
+	coproc_proc_other_info(cop, m);
+	return (0);
+}
+
+static void *st_coproc_seq_start(struct seq_file *m, loff_t * pos)
+{
+	return (void *)(*pos == 0);
+}
+
+static void *st_coproc_seq_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	return NULL;
+}
+
+static void st_coproc_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+static struct seq_operations proc_st_coproc_op = {
+      start:st_coproc_seq_start,
+      next:st_coproc_seq_next,
+      stop:st_coproc_seq_stop,
+      show:show_st_coproc,
+};
+
+static int proc_st_coproc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &proc_st_coproc_op);
+}
+
+static struct file_operations proc_st_coproc_operations = {
+      open:proc_st_coproc_open,
+      read:seq_read,
+      llseek:seq_lseek,
+      release:seq_release,
+};
+
+static int __init proc_st_coproc_init(void)
+{
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry("coprocessor", 0, NULL);
+	if (entry != NULL) {
+		entry->proc_fops = &proc_st_coproc_operations;
+	}
+
+	return 0;
+}
+
+#endif				/* CONFIG_PROC_FS */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm-coprocessor_frmw.c linux-2.6.23.1-stm/drivers/stm/stm-coprocessor_frmw.c
--- linux-2.6.23.1/drivers/stm/stm-coprocessor_frmw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm-coprocessor_frmw.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,458 @@
+/*
+ * Copyright (C) 2006 STMicroelectronics
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interfaces (where required) the co-processors on ST platforms based
+ * on multiprocessor architecture, for embedded products like Set-top-Box
+ * DVD, etc...
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/stm/coprocessor.h>
+#include <asm/types.h>
+#include <asm/sections.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int __init proc_st_coproc_init(void);
+#endif
+
+/* ---------------------------------------------------------------------------
+ *     Local (declared out of order) functions
+ * ------------------------------------------------------------------------ */
+
+static int __init parse_coproc_mem(char *from);
+
+#undef dbg_print
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+#define dbg_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dbg_print(fmt, args...)
+#endif
+
+/* ---------------------------------------------------------------------------
+ *    Exported and Imported
+ * ------------------------------------------------------------------------ */
+
+extern unsigned long memory_start, memory_end;
+
+/* ---------------------------------------------------------------------------
+ * 		Co-processor: Hardware dependent support
+ * This includes:
+ *    - per platform device and memory addresses
+ *    - platform dependent macros
+ *    - HW dependent actions required by the generic APIs: Init,
+ *      Open, Release, Ioctl (to reset, trigger the start (grant),
+ *      peek and poke, etc...) functions
+ * ------------------------------------------------------------------------ */
+
+extern struct coproc_board_info coproc_info;
+
+/* ---------------------------------------------------------------------------
+ *    Local data structure
+ * ------------------------------------------------------------------------ */
+
+extern coproc_t coproc[];	/* The maximum number of coprocessors
+				 * depends on platform type  */
+
+/* ---------------------------------------------------------------------------
+ * 			Co-processor driver APIs
+ * ---------------------------------------------------------------------------
+ */
+#define minor_2_firmware(min)  ( (min) & 0x3f      )
+#define minor_2_device(min)    ( ((min) >> 6) & 0x3)
+
+static int st_coproc_open(struct inode *inode, struct file *file)
+{
+	/*
+	 ** use minor number (ID) to access the current coproc. descriptor
+	 */
+	char firm_file[FIRMWARE_NAME_MAX];
+	char number[10];
+	unsigned long minor = MINOR((file)->f_dentry->d_inode->i_rdev);
+	unsigned long id_device = minor_2_device(minor);
+	unsigned long id_firmware = minor_2_firmware(minor);
+	struct firmware *fw = NULL;
+	int res;
+
+	coproc_t *cop = &coproc[id_device];
+
+	if (cop->control & COPROC_IN_USE)
+		return -EBUSY;
+	/* Now call the platform dependent open stage */
+	coproc_cpu_open(cop);
+/* Build the firmware file name.
+ * We use the standard name: "st_firmware_XX_XX.elf"
+ * to specify the device number and the firmware number
+ */
+
+	strcpy(firm_file, "st_firmware_");
+	sprintf(number, "%ld", id_device);
+	strcat(firm_file, number);
+	strcat(firm_file, "_");
+	sprintf(number, "%ld", id_firmware);
+	strcat(firm_file, number);
+	strcat(firm_file, ".elf");
+
+	dbg_print("Asking the file %s for %s.%u\n", firm_file, cop->pdev.name,cop->pdev.id);
+	if (request_firmware(&fw, firm_file, &(cop->pdev.dev)) == 0) {
+		unsigned long boot_address;
+
+		cop->control |= COPROC_IN_USE;
+		/* move the firmware in the coprocessor memory */
+		dbg_print("Received firmware size %d bytes\n", fw->size - 4);
+		dbg_print("cop->ram_size    = 0x%x\n", cop->ram_size);
+		dbg_print("cop->ram_offset  = 0x%x\n", cop->ram_offset);
+		/*
+		 * The last 4 bytes in the fw->data buffer
+		 * aren't code.
+		 * They are the boot vma (relocated) address!
+		 */
+		memcpy(&boot_address, (fw->data) + (fw->size - 4), 4);
+		dbg_print("boot address     = 0x%x\n", boot_address);
+		memcpy(cop->vma_address, fw->data, fw->size - 4);
+		release_firmware(fw);
+		dbg_print("Run the Firmware code\n");
+		coproc_cpu_grant(cop, boot_address);	//7100 only...
+		res = 0;
+	} else {
+		dbg_print("Error on Firmware Download\n");
+		res = -EINVAL;
+	}
+	return res;
+}
+
+static int st_coproc_release(struct inode *inode, struct file *file)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	coproc_cpu_release(cop);
+	cop->control &= ~COPROC_IN_USE;
+
+	return 0;
+}
+
+static struct file_operations coproc_fops = {
+      open:st_coproc_open,
+      release:st_coproc_release
+};
+
+/* Start: ST-Coprocessor Device Attribute on SysFs*/
+static ssize_t st_copro_show_running(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "%d", cop->control & COPROC_IN_USE);
+}
+
+static DEVICE_ATTR(running, S_IRUGO, st_copro_show_running, NULL);
+
+static ssize_t st_copro_show_mem_size(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "0x%x", cop->ram_size);
+}
+
+static DEVICE_ATTR(mem_size, S_IRUGO, st_copro_show_mem_size, NULL);
+
+static ssize_t st_copro_show_mem_base(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, pdev.dev);
+	return sprintf(buf, "0x%x", (int)COPR_ADDR(cop, 0));
+}
+
+static DEVICE_ATTR(mem_base, S_IRUGO, st_copro_show_mem_base, NULL);
+/* End: ST-Coprocessor Device Attribute SysFs*/
+
+static int st_coproc_driver_probe(struct platform_device *dev)
+{
+	if (!strncmp("st2", dev->name, 3))
+		return 1;
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+static int st_coproc_suspend(struct platform_device * dev, pm_message_t state)
+{
+	printk("st_coproc_suspend: %s.%u down\n",dev->name,dev->id);
+/*
+ *	
+ */
+	return 0;
+}
+
+static int st_coproc_resume(struct platform_device * dev)
+{
+	printk("st_coproc_resume: %s.%u up\n",dev->name,dev->id);
+/*
+ *
+ */
+	return 0;
+}
+#endif
+
+static struct platform_driver st_coproc_driver = {
+	.driver.name = "st-copro",
+	.driver.owner = THIS_MODULE,
+	.probe = st_coproc_driver_probe,
+#if defined(CONFIG_PM)
+	.suspend =st_coproc_suspend,
+	.resume = st_coproc_resume,
+#endif
+};
+
+static int __init st_coproc_init(void)
+{
+	int i;
+	coproc_t *cop;
+	struct platform_device *pdev;
+
+	printk("STMicroelectronics - Coprocessors %s Init\n", coproc_info.name);
+
+	if (platform_driver_register(&st_coproc_driver)) {
+		printk(KERN_ERR
+		       "Error on ST-Coprocessor device driver registration\n");
+		return (-EAGAIN);
+	}
+
+	if (register_chrdev(COPROCESSOR_MAJOR, coproc_info.name, &coproc_fops)) {
+		printk("Can't allocate major %d for ST Coprocessor Devices\n",
+		       COPROCESSOR_MAJOR);
+		platform_driver_unregister(&st_coproc_driver);
+		return (-EAGAIN);
+	}
+
+	for (cop = &coproc[0], i = 0; i < coproc_info.max_coprs; i++, cop++) {
+       /**
+        ** Nodes:
+        **    STm8000/ST220Eval: /dev/st220-0    c   63   0
+        **                       /dev/st220-1    c   63   1
+        **                       /dev/st220-2    c   63   2
+        **    STb7100          : /dev/st231-0    c   63   0
+        **                       /dev/st231-1    c   63   1
+        **/
+		cop->id = i;
+		if (!cop->ram_offset) {
+			printk("st-coprocessor-%d: No RAM reserved\n", cop->id);
+			cop->control &= ~COPROC_SPACE_ALLOCATE;
+		} else {
+			cop->control |= COPROC_SPACE_ALLOCATE;
+			cop->vma_address =
+			    (int)ioremap_nocache(cop->ram_offset, cop->ram_size);
+		}
+		/*
+		 * Setup and Add the device entries in the SysFS
+		 */
+		pdev = &(cop->pdev);
+		memset(pdev, 0, sizeof(struct platform_device));
+//		sprintf(cop->dev.bus_id, "%s-%d", coproc_info.name, i);
+		pdev->name = coproc_info.name;
+		pdev->id   = i;
+		pdev->dev.driver = &st_coproc_driver.driver;
+//		dev->parent = &platform_bus;
+//		dev->bus = &platform_bus_type;
+		if (platform_device_register(pdev))
+			printk(KERN_ERR
+			       "Error on ST-Coprocessor device registration\n");
+		else {
+			/* Add the attributes on the device */
+			device_create_file(&pdev->dev, &dev_attr_mem_base);
+			device_create_file(&pdev->dev, &dev_attr_mem_size);
+			device_create_file(&pdev->dev, &dev_attr_running);
+		}
+
+		/* Now complete with the platform dependent init stage */
+		if (coproc_cpu_init(cop)) {
+			printk(KERN_ERR
+			       "CPU %d : HW dep. initialization failed!\n", i);
+			return (1);
+		}
+	}
+
+#ifdef CONFIG_PROC_FS
+	proc_st_coproc_init();
+#endif
+
+	return (0);
+}
+
+static void __exit st_coproc_exit(void)
+{
+	dbg_print("Release coprocessor module...\n");
+}
+
+/*
+ * Parse the optional kernel argument:
+ *
+ * ... coprocessor_mem=size_0@phis_address_0, size_1@phis_address_1
+ *
+ * It seems to be reasonable to assume that in a "staically partitioned
+ * RAM layout", the regions of RAM assigned to each slave processor are
+ * not scattered in memory!
+ */
+static int __init parse_coproc_mem(char *from)
+{
+	char *cmdl = (from);    /* start scan from '=' char */
+	u_long size, addr;
+	int i = 0;
+	char *error_msg;
+	static char size_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing size\n";
+	static char addr_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing address\n";
+	static char too_many_warn[] __initdata =
+		KERN_WARNING "st-coprocessor: More regions than coprocessors\n";
+	static char alloc_error[] __initdata =
+		KERN_ERR "st-coprocessor: Failed to reserve memoryat 0x%08x\n";
+
+	while (*cmdl && (i < coproc_info.max_coprs)) {
+		size = memparse(cmdl, &cmdl);
+		if (*cmdl != '@') {
+			error_msg = size_error;
+			goto args_error;
+		}
+		addr = memparse(cmdl+1, &cmdl);
+		if (*cmdl) {
+			if (*cmdl++ != ',') {
+				error_msg = addr_error;
+				goto args_error;
+			}
+		}
+		coproc[i].ram_offset = addr;
+		coproc[i].ram_size = size;
+		++i;
+	}
+
+	if (*cmdl) {
+		printk(too_many_warn);
+	}
+
+	for (i = 0; i < coproc_info.max_coprs; ++i) {
+		if (coproc[i].ram_size) {
+			void* mem;
+			addr = coproc[i].ram_offset;
+			size = coproc[i].ram_size;
+			/* Switch to __alloc_bootmem_nopanic or
+			 * __alloc_bootmem_core when we update thekernel. */
+			mem = __alloc_bootmem(size, PAGE_SIZE, addr);
+			if (mem != __va(addr)) {
+				if (mem) {
+					free_bootmem(virt_to_phys(mem), size);
+				}
+				/* At this point, if addr overlaps kernel
+				 * memory, coprocessor won't be allocated.
+                                 */
+				if (coproc_check_area(addr, size, i, coproc))
+                                        printk(alloc_error, addr);
+                        }
+		}
+	}
+
+	return 1;
+
+args_error:
+	printk(error_msg);
+	return 1;
+}
+
+__setup("coprocessor_mem=", parse_coproc_mem);
+
+MODULE_DESCRIPTION("Co-processor manager for multi-core devices");
+MODULE_AUTHOR("STMicroelectronics Limited");
+MODULE_VERSION("0.3");
+MODULE_LICENSE("GPL");
+
+module_init(st_coproc_init);
+module_exit(st_coproc_exit);
+
+#ifdef CONFIG_PROC_FS
+
+static int show_st_coproc(struct seq_file *m, void *v)
+{
+	int i;
+	coproc_t *cop;
+
+	seq_printf(m, "Coprocessors: %d  %s\n", coproc_info.max_coprs,
+		   coproc_info.name);
+	seq_printf(m,
+		   "  CPU (dev)        Host addr.     Copr. addr.     Size\n");
+	seq_printf(m,
+		   "  -----------------------------------------------------------		--------\n");
+	for (i = 0, cop = &coproc[0]; i < coproc_info.max_coprs; i++, cop++) {
+		seq_printf(m, "  /dev/%s-%u    ", cop->pdev.name,cop->pdev.id);
+		if (cop->ram_size == 0)
+			seq_printf(m, "not allocated!\n");
+		else
+			seq_printf(m,
+				   "0x%08lx     0x%08lx      0x%08x (%2d Mb)\n",
+				   (HOST_ADDR(cop, 0)), COPR_ADDR(cop, 0),
+				   cop->ram_size, (cop->ram_size / MEGA));
+	}
+	seq_printf(m, "\n");
+
+	coproc_proc_other_info(cop, m);
+	return (0);
+}
+
+static void *st_coproc_seq_start(struct seq_file *m, loff_t * pos)
+{
+	return (void *)(*pos == 0);
+}
+
+static void *st_coproc_seq_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	return NULL;
+}
+
+static void st_coproc_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+static struct seq_operations proc_st_coproc_op = {
+      start:st_coproc_seq_start,
+      next:st_coproc_seq_next,
+      stop:st_coproc_seq_stop,
+      show:show_st_coproc,
+};
+
+static int proc_st_coproc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &proc_st_coproc_op);
+}
+
+static struct file_operations proc_st_coproc_operations = {
+      open:proc_st_coproc_open,
+      read:seq_read,
+      llseek:seq_lseek,
+      release:seq_release,
+};
+
+static int __init proc_st_coproc_init(void)
+{
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry("coprocessor", 0, NULL);
+	if (entry != NULL) {
+		entry->proc_fops = &proc_st_coproc_operations;
+	}
+
+	return 0;
+}
+
+#endif				/* CONFIG_PROC_FS */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm_spi.c linux-2.6.23.1-stm/drivers/stm/stm_spi.c
--- linux-2.6.23.1/drivers/stm/stm_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm_spi.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,936 @@
+/*
+   -------------------------------------------------------------------------
+   stm_spi.c
+   -------------------------------------------------------------------------
+   STMicroelectronics
+   Version: 2.0 (1 April 2007)
+   ----------------------------------------------------------------------------
+   May be copied or modified under the terms of the GNU General Public
+   License.  See linux/COPYING for more information.
+
+   ------------------------------------------------------------------------- */
+
+#include "stm_spi.h"
+#include <linux/stm/pio.h>
+#include <asm/semaphore.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/param.h>		/* for HZ */
+
+#undef dgb_print
+
+#ifdef  CONFIG_STM_SPI_DEBUG
+#define SPI_LOOP_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NANOSEC_PER_SEC         1000000000
+
+#define SPI_LINE_SHIFT      0x0
+#define SPI_BANK_SHIFT      0x3
+#define SPI_MODE_SHIFT      0x7
+
+#define SPI_LINE_MASK       0x7
+#define SPI_BANK_MASK       0xf
+#define SPI_MODE_MASK       0x1
+#define SPI_DEVICE_MASK     0xff
+
+#define spi_get_mode(address)       ( (address >> SPI_MODE_SHIFT) & SPI_MODE_MASK )
+#define spi_get_bank(address)       ( (address >> SPI_BANK_SHIFT) & SPI_BANK_MASK )
+#define spi_get_line(address)       ( (address >> SPI_LINE_SHIFT) & SPI_LINE_MASK )
+#define spi_get_device(address)     (  address & SPI_DEVICE_MASK )
+
+enum spi_state_machine_e {
+	SPI_FSM_VOID = 0,
+	SPI_FSM_PREPARE,
+	SPI_FSM_RUNNING,
+	SPI_FSM_STOP,
+	SPI_FSM_COMPLETE,
+	SPI_FSM_ABORT
+};
+
+#define SPI_PHASE_MASK            0x01
+#define SPI_PHASE_HIGH            0x01
+#define SPI_PHASE_LOW             0x00
+
+#define SPI_POLARITY_MASK         0x02
+#define SPI_POLARITY_HIGH         0x02
+#define SPI_POLARITY_LOW          0x00
+
+#define SPI_MSB_MASK              0x04
+#define SPI_MSB                   0x04
+#define SPI_LSB                   0x00
+
+#define SPI_FULLDUPLEX_MASK       0x08
+#define SPI_FULLDUPLEX            0x08
+#define SPI_HALFDUPLEX            0x00
+
+#define SPI_WIDE_MASK             0x10
+#define SPI_WIDE_16BITS           0x10
+#define SPI_WIDE_8BITS            0x00
+
+#define SPI_CSACTIVE_MASK         0x20
+#define SPI_CSACTIVE_HIGH         0x20
+#define SPI_CSACTIVE_LOW          0x00
+
+#define SPI_BAUDRATE_MASK         0xffff0000
+#define SPI_BAUDRATE_SHIFT        0x10
+
+/*
+ *  * Virtual Configuration *
+ *
+ *  [  0: POLARITY  :0]
+ *  [  1: PHASE     :1]
+ *  [  2: MSB       :2]
+ *  [  3: FULL/HALF :3]
+ *  [  4: WIDE      :4]
+ *  [  5: CS_ACTIVE :5]
+ *  [ 15: FREE      :6]
+ *  [ 31: BAUDRATE  :16]
+ *
+ */
+
+struct spi_transaction_t {
+	struct spi_client_t *client;	/* the transaction's owner */
+	enum spi_state_machine_e state;
+	enum spi_state_machine_e next_state;
+	unsigned int msg_length;
+	unsigned int idx_write;
+	unsigned int idx_read;
+};
+
+/*
+ *  In this way i can manage no more than 5 bus spi
+ *  but 5 it's enough for our platform
+ */
+#define MAX_NUMBER_SPI_BUSSES 5
+/*
+ *  This array is used to speed up the
+ *  open device file
+ */
+struct spi_device_t *spi_busses_array[MAX_NUMBER_SPI_BUSSES];
+//static LIST_HEAD(spi_busses);
+/*
+ * In this way the spi bus will be available
+ * with the spi_busses_array array
+ * or the spi_busses list
+ */
+
+#define jump_on_fsm_complete(trsc)	{ (trsc)->state = SPI_FSM_COMPLETE;	\
+					 goto be_fsm_complete;}
+
+#define jump_on_fsm_abort(trsc)		{ (trsc)->state = SPI_FSM_ABORT;	\
+					 goto be_fsm_abort;}
+
+void spi_state_machine(struct spi_transaction_t *transaction)
+{
+	struct spi_client_t *client = transaction->client;
+	struct ssc_t *ssc_bus = container_of(client->dev->dev.parent, struct ssc_t,pdev.dev);
+	unsigned short status;
+	short tx_fifo_status;
+	short rx_fifo_status;
+	unsigned int config = client->config;
+	unsigned int phase, polarity;
+	unsigned int hb;
+	unsigned int wide_frame = (config & SPI_WIDE_MASK) ? 1 : 0;
+
+	union {
+		char bytes[2];
+		short word;
+	} tmp = {.word = 0,};
+
+	transaction->state = transaction->next_state;
+
+	switch (transaction->state) {
+	case SPI_FSM_PREPARE:
+		dgb_print("-SPI_FSM_PREPARE\n");
+		phase    = ((config & SPI_PHASE_MASK) ? 1 : 0);
+		polarity = ((config & SPI_POLARITY_MASK) ? 1 : 0);
+		hb       = ((config & SPI_MSB_MASK) ? 1 : 0);
+		wide_frame = ((config & SPI_WIDE_MASK) ? 1 : 0) * 0x8 + 0x7;
+
+		stpio_set_pin(ssc_bus->pio_clk, STPIO_OUT);
+		stpio_set_pin(ssc_bus->pio_data, STPIO_OUT);
+		stpio_set_pin(ssc_bus->pio_data, STPIO_IN);
+
+		ssc_store16(ssc_bus, SSC_BRG,
+			    (config & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
+
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR | 0x1);
+		ssc_store16(ssc_bus, SSC_I2C, 0x0);
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+			    (SSC_CTL_PO * polarity) |
+			    (SSC_CTL_PH * phase) | (SSC_CTL_HB * hb) |
+#ifdef SPI_LOOP_DEBUG
+			    SSC_CTL_LPB |
+#endif
+#ifdef CONFIG_STM_SPI_HW_FIFO
+			    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO |
+#endif
+			    wide_frame);
+
+		transaction->next_state = SPI_FSM_RUNNING;
+		ssc_load16(ssc_bus, SSC_RBUF);	/* only to clear the status register */
+#ifdef CONFIG_STM_SPI_HW_FIFO
+		for (tx_fifo_status = 0;
+		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
+		     transaction->idx_write < transaction->msg_length;
+		     ++tx_fifo_status)
+#endif
+		{
+			if (wide_frame > 0x7) {
+				dgb_print(" Writing %c %c\n",
+					  client->wr_buf[transaction->
+							 idx_write * 2],
+					  client->wr_buf[transaction->
+							 idx_write * 2 + 1]);
+				tmp.bytes[1] =
+				    client->wr_buf[transaction->idx_write * 2];
+				tmp.bytes[0] =
+				    client->wr_buf[transaction->idx_write * 2 +
+						   1];
+			} else {
+				dgb_print(" Writing %c\n",
+					  client->wr_buf[transaction->
+							 idx_write]);
+				tmp.bytes[0] =
+				    client->wr_buf[transaction->idx_write];
+			}
+			++transaction->idx_write;
+			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
+		}
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_RIEN);
+		break;
+
+	case SPI_FSM_RUNNING:
+		status = ssc_load16(ssc_bus, SSC_STA);
+		dgb_print(" SPI_FSM_RUNNING 0x%x\n", status);
+#ifndef CONFIG_STM_SPI_HW_FIFO
+		if ((status & SSC_STA_RIR) &&
+		    transaction->idx_read < transaction->msg_length) {
+#else
+		for (rx_fifo_status = ssc_load16(ssc_bus, SSC_RX_FSTAT);
+		     rx_fifo_status &&
+		     transaction->idx_read < transaction->msg_length;
+		     --rx_fifo_status) {
+#endif
+			tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+			if (wide_frame) {
+				client->rd_buf[transaction->idx_read * 2] =
+				    tmp.bytes[1];
+				client->rd_buf[transaction->idx_read * 2 + 1] =
+				    tmp.bytes[0];
+				dgb_print(" Reading: %c %c\n", tmp.bytes[1],
+					  tmp.bytes[0]);
+			} else {
+				client->rd_buf[transaction->idx_read] =
+				    tmp.bytes[0];
+				dgb_print(" Reading: %c\n", tmp.bytes[0]);
+			}
+			++transaction->idx_read;
+		}
+#ifndef CONFIG_STM_SPI_HW_FIFO
+		if ((status & SSC_STA_TIR)
+		    && transaction->idx_write < transaction->msg_length) {
+#else
+		for (tx_fifo_status = ssc_load16(ssc_bus, SSC_TX_FSTAT);
+		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
+		     transaction->idx_write < transaction->msg_length;
+		     ++tx_fifo_status) {
+#endif
+			if (wide_frame) {
+				dgb_print(" Writing %c %c\n",
+					  client->wr_buf[transaction->
+							 idx_write * 2],
+					  client->wr_buf[transaction->
+							 idx_write * 2 + 1]);
+				tmp.bytes[1] =
+				    client->wr_buf[transaction->idx_write * 2];
+				tmp.bytes[0] =
+				    client->wr_buf[transaction->idx_write * 2 +
+						   1];
+			} else {
+				dgb_print(" Writing %c\n",
+					  client->wr_buf[transaction->
+							 idx_write]);
+				tmp.bytes[0] =
+				    client->wr_buf[transaction->idx_write];
+			}
+			++transaction->idx_write;
+			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
+		}
+
+		if (transaction->idx_write >= transaction->msg_length &&
+		    transaction->idx_read >= transaction->msg_length)
+			jump_on_fsm_complete(transaction);
+		break;
+	case SPI_FSM_COMPLETE:
+	      be_fsm_complete:
+		dgb_print(" SPI_FSM_COMPLETE\n");
+		ssc_store16(ssc_bus, SSC_IEN, 0x0);
+		wake_up(&(ssc_bus->wait_queue));
+		break;
+
+	case SPI_FSM_VOID:
+	default:
+		;
+	}
+	return;
+}
+
+#define chip_asserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
+			     stpio_set_pin((client)->pio_chip, 0x1);		\
+			else stpio_set_pin((client)->pio_chip, 0x0);
+
+#define chip_deasserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
+			       stpio_set_pin((client)->pio_chip, 0x0);		\
+			  else stpio_set_pin((client)->pio_chip, 0x1);
+
+int spi_write(struct spi_client_t *client, char *wr_buffer, size_t count)
+{
+	unsigned long flag;
+	int timeout;
+	int result = (int)count;
+	struct ssc_t *ssc_bus =
+		container_of(client->dev->dev.parent, struct ssc_t, pdev.dev);
+	struct spi_transaction_t transaction = {.client = client,
+		.msg_length = count,
+		.next_state = SPI_FSM_PREPARE,
+		.idx_write = 0,
+		.idx_read = 0,
+	};
+	dgb_print("\n");
+
+	if (client->pio_chip == NULL)
+		return -ENODATA;
+
+	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
+	chip_asserted(client);
+
+	client->rd_buf = kmalloc(count, GFP_KERNEL);
+	client->wr_buf = wr_buffer;
+	if (client->config & SPI_WIDE_MASK)
+		transaction.msg_length >>= 1;
+
+	spi_state_machine(&transaction);
+	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
+						   (transaction.state == SPI_FSM_COMPLETE),
+						   client->timeout * HZ);
+	if (timeout <= 0) {
+		/* Terminate transaction */
+		local_irq_save(flag);
+		transaction.next_state = SPI_FSM_COMPLETE;
+		spi_state_machine(&transaction);
+		local_irq_restore(flag);
+
+		if (!timeout) {
+			printk(KERN_ERR "stm_spi: timeout during SPI write\n");
+			result = -ETIMEDOUT;
+		} else {
+			dgb_print
+			    ("stm_spi: interrupt or error in wait event\n");
+			result = timeout;
+		}
+	}
+
+	chip_deasserted(client);
+	ssc_release_bus(ssc_bus);
+	kfree(client->rd_buf);
+	client->rd_buf = NULL;
+	client->wr_buf = NULL;
+	return result;
+}
+
+int spi_read(struct spi_client_t *client, char *rd_buffer, size_t count)
+{
+	unsigned long flag;
+	int timeout;
+	int result = (int)count;
+	struct ssc_t *ssc_bus =
+		container_of(client->dev->dev.parent, struct ssc_t, pdev.dev);
+	unsigned int wide_frame =
+	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
+	struct spi_transaction_t transaction = {.client = client,
+		.msg_length = count,
+		.next_state = SPI_FSM_PREPARE,
+		.idx_write = 0,
+		.idx_read = 0,
+	};
+	/*
+	 * the first step is request the bus access
+	 */
+	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
+
+	chip_asserted(client);
+
+#ifdef SPI_LOOP_DEBUG
+#define DUMMY   "dummy_string_only_for_test"
+	count = strlen(DUMMY);
+#endif
+
+	client->rd_buf = rd_buffer;
+	client->wr_buf = (char *)kmalloc(count, GFP_KERNEL);
+
+#ifdef SPI_LOOP_DEBUG
+	strcpy(client->wr_buf, DUMMY);
+#endif
+
+/*
+ *  When the data frame is 16 bits long
+ *  then msg_length must be %2=0
+ *
+ */
+	if (wide_frame)
+		transaction.msg_length >>= 1;	// frame oriented
+
+	spi_state_machine(&transaction);
+	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
+						   (transaction.state == SPI_FSM_COMPLETE),
+						   client->timeout * HZ);
+
+	if (timeout <= 0) {
+		/* Terminate transaction */
+		local_irq_save(flag);
+		transaction.next_state = SPI_FSM_COMPLETE;
+		spi_state_machine(&transaction);
+		local_irq_restore(flag);
+
+		if (!timeout) {
+			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
+			result = -ETIMEDOUT;
+		} else {
+			dgb_print
+			    ("stm_spi: interrupt or error in read wait event\n");
+			result = timeout;
+		}
+	}
+
+	chip_deasserted(client);
+
+	ssc_release_bus(ssc_bus);
+	kfree(client->wr_buf);
+	client->rd_buf = NULL;
+	client->wr_buf = NULL;
+	return result;
+}
+
+int spi_write_then_read(struct spi_client_t *client, char *wr_buffer,
+			char *rd_buffer, size_t count)
+{
+	unsigned long flag;
+	int timeout;
+	int result = (int)count;
+	struct ssc_t *ssc_bus =
+		container_of(client->dev->dev.parent, struct ssc_t, pdev.dev);
+	struct spi_transaction_t transaction = {.client = client,
+		.msg_length = count,
+		.next_state = SPI_FSM_PREPARE,
+		.idx_write = 0,
+		.idx_read = 0,
+	};
+	dgb_print("\n");
+
+	if (client->pio_chip == NULL)
+		return -ENODATA;
+
+	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
+
+	chip_asserted(client);
+
+	client->rd_buf = rd_buffer;
+	client->wr_buf = wr_buffer;
+
+	if (client->config & SPI_WIDE_MASK)
+		transaction.msg_length >>= 1;	// frame oriented...
+
+	spi_state_machine(&transaction);
+	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
+						  (transaction.state == SPI_FSM_COMPLETE),
+						  client->timeout * HZ);
+	if (timeout <= 0) {
+		/* Terminate transaction */
+		local_irq_save(flag);
+		transaction.next_state = SPI_FSM_COMPLETE;
+		spi_state_machine(&transaction);
+		local_irq_restore(flag);
+
+		if (!timeout) {
+			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
+			result = -ETIMEDOUT;
+		} else {
+			dgb_print
+			    ("stm_spi: interrupt or error in read wait event\n");
+			result = timeout;
+		}
+	}
+
+	chip_deasserted(client);
+	ssc_release_bus(ssc_bus);
+
+	return count;
+}
+
+struct spi_client_t *spi_create_client(int bus_number)
+{
+	struct spi_client_t *client;
+
+	dgb_print("\n");
+
+	if (bus_number >= MAX_NUMBER_SPI_BUSSES)
+		return NULL;
+	if (!spi_busses_array[bus_number])
+		return NULL;
+	client =
+	    (struct spi_client_t *)kzalloc(sizeof(struct spi_client_t),
+					   GFP_KERNEL);
+	if (!client)
+		return NULL;
+	client->dev = spi_busses_array[bus_number];
+	client->timeout = 5;	/* 5 seconds */
+/*
+ *  1 Phase
+ *  1 Polarity
+ *  1 Heading
+ *  - Full/Half
+ *  1 Wide (16bits)
+ *  0 CSActive
+ *  1 MHz (at 100MHz of common clock)
+ */
+	client->config = 0x420017;
+
+	return client;
+}
+
+int spi_client_release(struct spi_client_t *client)
+{
+	dgb_print("\n");
+	if (!client)
+		return 0;
+	if (client->pio_chip != NULL) {
+		stpio_free_pin(client->pio_chip);
+		client->pio_chip = NULL;
+	}
+	dgb_print("PIO-chip released\n");
+	if (client->rd_buf != NULL)
+		kfree(client->rd_buf);
+	kfree(client);
+	return 1;
+}
+
+int spi_client_addressing(struct spi_client_t *client, unsigned int slave_address)
+{
+	unsigned int spi_device;
+
+	spi_device = spi_get_device(slave_address);
+
+	dgb_print("Spi opening Slave 0x%x (%d)\n", spi_device, spi_device);
+
+/* 1. release the Pio of previous addressing*/
+	if (client->pio_chip)
+		stpio_free_pin(client->pio_chip);
+	client->pio_chip = NULL;
+// 2. check if the pio[BANK][LINE] used for chip_selector is free
+	client->pio_chip =
+	    stpio_request_pin(spi_get_bank(slave_address),
+			      spi_get_line(slave_address), "spi-chip-selector",
+			      STPIO_OUT);
+
+	if (!(client->pio_chip)) {
+/*
+ * Somebody already requested the PIO[bank][line]
+ * therefore we abort the addressing
+ */
+		dgb_print("Error Pio locked or not-exist\n");
+		return -ENOSYS;
+	}
+	dgb_print("->with PIO [%d][%d]\n", spi_get_bank(slave_address),
+		  spi_get_line(slave_address));
+
+	client->config &= ~SPI_FULLDUPLEX;
+	dgb_print("->with FULLDUPLEX = 0x%x\n", spi_get_mode(slave_address));
+	client->config |= ( SPI_FULLDUPLEX * spi_get_mode(slave_address));
+/*
+ *  Free the data of prev addressing
+ */
+	if (client->rd_buf != NULL)
+		kfree(client->rd_buf);
+
+	client->rd_buf = NULL;
+	chip_deasserted(client);
+
+	return 0;
+
+}
+
+int spi_client_control(struct spi_client_t *client, int cmd, int arg)
+{
+	dgb_print("\n");
+	switch (cmd) {
+	case SPI_IOCTL_WIDEFRAME:
+		client->config &= ~SPI_WIDE_MASK;
+		if (arg)
+			client->config |= SPI_WIDE_16BITS;
+		break;
+	case SPI_IOCTL_POLARITY:
+		client->config &=  ~SPI_POLARITY_MASK;
+		if (arg)
+			client->config |= SPI_POLARITY_HIGH;
+		break;
+	case SPI_IOCTL_PHASE:
+		client->config &= ~SPI_PHASE_MASK;
+		if (arg)
+			client->config |= SPI_PHASE_HIGH;
+		break;
+	case SPI_IOCTL_HEADING:
+		client->config &= ~SPI_MSB_MASK;
+		if (arg)
+			client->config |= SPI_MSB;
+		break;
+	case SPI_IOCTL_BUADRATE:
+		{
+			unsigned long baudrate;
+			baudrate = ssc_get_clock() / (2 * arg);
+			client->config &= ~SPI_BAUDRATE_MASK;
+			client->config |= (baudrate << SPI_BAUDRATE_SHIFT);
+		}
+		break;
+	case SPI_IOCTL_CSACTIVE:
+		client->config &= ~SPI_CSACTIVE_MASK;
+		if (arg)
+			client->config |= SPI_CSACTIVE_HIGH;
+		break;
+	case SPI_IOCTL_ADDRESS:
+		if (spi_client_addressing(client, (unsigned int)arg) != 0)
+			return -1;
+		break;
+	case SPI_IOCTL_TIMEOUT:
+		client->timeout = arg;
+		break;
+	default:
+		;
+	}
+#ifdef SPI_STM_DEBUG
+	{
+		unsigned int conf = client->config;
+		dgb_print("SPI - Virtual Config:\n");
+		dgb_print(" - PHASE:    0x%x\n", (conf & SPI_PHASE_MASK) != 0);
+		dgb_print(" - POLARITY: 0x%x\n",
+			  (conf & SPI_POLARITY_MASK) != 0);
+		dgb_print(" - HEADING:  0x%x\n", (conf & SPI_MSB_MASK) != 0);
+		dgb_print(" - FULLDUP:  0x%x\n",
+			  (conf & SPI_FULLDUPLEX_MASK) != 0);
+		dgb_print(" - WIDE:     0x%x\n", (conf & SPI_WIDE_MASK) != 0);
+		dgb_print(" - CSACTIVE: 0x%x\n",
+			  (conf & SPI_CSACTIVE_MASK) != 0);
+		dgb_print(" - BUADRATE: 0x%x\n",
+			  (conf & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
+	}
+#endif
+
+}
+
+#ifdef CONFIG_STM_SPI_CHAR_DEV
+#define SPI_MAJOR 153
+static struct class *spi_dev_class;
+static struct cdev spi_cdev;
+
+static ssize_t spi_cdev_read(struct file *filp,
+			     char __user * buff, size_t count, loff_t * offp)
+{
+	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
+	unsigned int wide_frame =
+	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
+	char *read_buffer;
+
+	if (client->pio_chip == NULL)
+		return -ENODATA;
+
+	if (client->config & SPI_FULLDUPLEX_MASK) {
+/*
+ * In FullDuplex Mode
+ * The Datas are already ready...
+ */
+		if (!client->rd_buf)
+			return 0;
+		dgb_print("Reading in FullD\n");
+		if (wide_frame)
+			count &= ~0x1;
+		copy_to_user(buff, client->rd_buf, count);
+		kfree(client->rd_buf);
+		client->rd_buf = NULL;
+		return count;
+	}
+
+	dgb_print("Reading in Half/D %d bytes\n", count);
+	read_buffer = (char *)kmalloc(count, GFP_KERNEL);
+	spi_read(client, read_buffer, count);
+	copy_to_user(buff, read_buffer, count);
+	kfree(read_buffer);
+	return count;
+}
+
+static ssize_t spi_cdev_write(struct file *filp,
+			      const char __user * buff,
+			      size_t count, loff_t * offp)
+{
+	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
+	char *wr_buffer;
+	char *rd_buffer;
+	int result;
+	dgb_print("\n");
+
+	wr_buffer = kmalloc(count, GFP_KERNEL);
+	rd_buffer = kmalloc(count, GFP_KERNEL);
+
+	copy_from_user(wr_buffer, buff, count);
+
+	result = spi_write_then_read(client, wr_buffer, rd_buffer, count);
+
+	if (result >= 0)
+		result = count;
+
+	if (!(client->config & SPI_FULLDUPLEX)) {
+#ifdef SPI_LOOP_DEBUG
+		dgb_print("Read: %s\n", rd_buffer);
+#endif
+		kfree(rd_buffer);
+		client->rd_buf = NULL;
+	}
+
+	return result;
+}
+
+static int spi_cdev_ioctl(struct inode *inode,
+			  struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	dgb_print("\n");
+	spi_client_control((struct spi_client_t *)filp->private_data, cmd, arg);
+	return 0;
+}
+
+static int spi_cdev_open(struct inode *inode, struct file *filp)
+{
+	unsigned int minor;
+	struct spi_client_t *client;
+
+	dgb_print("\n");
+	minor = iminor(inode);
+	client = spi_create_client(minor);
+	filp->private_data = client;
+	if (client)
+		return 0;
+	else
+		return -ENODEV;
+}
+
+static int spi_cdev_release(struct inode *inode, struct file *filp)
+{
+	dgb_print("\n");
+	spi_client_release((struct spi_client_t *)filp->private_data);
+	filp->private_data = NULL;
+	return 0;
+}
+
+struct file_operations spi_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = spi_cdev_open,
+	.release = spi_cdev_release,
+	.read = spi_cdev_read,
+	.write = spi_cdev_write,
+	.ioctl = spi_cdev_ioctl
+};
+#endif
+
+static int spi_stm_match(struct device *dev, struct device_driver *drv)
+{
+	dgb_print("\n");
+	if (dev == NULL || drv == NULL)
+		return 0;
+	return !strncmp(dev->bus_id, drv->name, 3);
+}
+
+struct bus_type spi_bus_type = {
+	.name = "spi",
+	.match = spi_stm_match,
+};
+
+void spi_del_adapter(struct spi_device_t *spi_dev)
+{
+	dgb_print("\n");
+	spi_busses_array[spi_dev->idx_dev] = 0;
+#ifdef CONFIG_STM_SPI_CHAR_DEV
+	class_device_destroy(spi_dev_class, MKDEV(SPI_MAJOR, spi_dev->idx_dev));
+#endif
+	kfree(spi_dev);
+	return;
+}
+
+static int spi_bus_driver_probe(struct device *dev)
+{
+	struct spi_device_t *spi_dev;
+
+	dgb_print("\n");
+	spi_dev = container_of(dev, struct spi_device_t, dev);
+
+	return spi_dev->dev_type == SPI_DEV_BUS_ADAPTER;
+};
+
+static void spi_bus_driver_remove(struct device *dev)
+{
+	struct spi_device_t *spi_dev;
+	spi_dev = container_of(dev, struct spi_device_t, dev);
+	dgb_print("\n");
+//   spi_del_adapter(spi_dev);
+//   dgb_print("..\n");
+	return;
+}
+static void spi_bus_driver_shutdown(struct device *dev)
+{
+	struct spi_device_t *spi_dev;
+	spi_dev = container_of(dev, struct spi_device_t, dev);
+	dgb_print("\n");
+	spi_del_adapter(spi_dev);
+	return;
+}
+static struct device_driver spi_bus_drv = {
+	.owner = THIS_MODULE,
+	.name = "spi_bus_drv",
+	.bus = &spi_bus_type,
+	.probe = spi_bus_driver_probe,
+	.shutdown = spi_bus_driver_shutdown,
+	.remove = spi_bus_driver_remove,
+};
+
+int spi_add_adapter(struct spi_device_t *spi_dev)
+{
+	unsigned int ret;
+	unsigned int idx_dev = spi_dev->idx_dev;
+	struct device *dev;
+
+	dgb_print("\n");
+	spi_dev->dev_type = SPI_DEV_BUS_ADAPTER;
+	spi_dev->dev.bus = &(spi_bus_type);
+	sprintf(spi_dev->dev.bus_id, "spi-%d", idx_dev);
+	spi_dev->dev.release = spi_del_adapter;
+	spi_dev->dev.driver = &spi_bus_drv;
+	ret = device_register(&spi_dev->dev);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register %s bus\n",
+		       spi_dev->dev.bus_id);
+		kfree(spi_dev);
+	} else
+		spi_busses_array[idx_dev] = spi_dev;
+#ifdef CONFIG_STM_SPI_CHAR_DEV
+	dev = spi_dev->dev.parent;
+	spi_dev->class_dev = class_device_create(spi_dev_class, NULL,
+						 MKDEV(SPI_MAJOR,
+						 spi_dev->idx_dev), dev,
+						 "spi-%d", spi_dev->idx_dev);
+#endif
+	return ret;
+}
+
+static int spi_adapter_detect()
+{
+	unsigned int idx;
+	unsigned int num_ssc_bus = ssc_device_available();
+	unsigned int num_spi_bus;
+	struct spi_device_t *spi_dev;
+	struct ssc_t **ssc_busses;
+	dgb_print("\n");
+/*
+ *  Check the ssc on the platform
+ */
+	ssc_busses = (struct ssc_t **)kmalloc(num_ssc_bus *
+					      sizeof(struct ssc_t *),
+					      GFP_KERNEL);
+	for (idx = 0, num_spi_bus = 0; idx < num_ssc_bus; ++idx)
+		if ((ssc_capability(idx) & SSC_SPI_CAPABILITY))
+			ssc_busses[num_spi_bus++] = ssc_device_request(idx);
+
+	for (idx = 0; idx < num_spi_bus; ++idx) {
+		spi_dev = (struct spi_device_t *)
+		    kmalloc(sizeof(struct spi_device_t), GFP_KERNEL);
+		memset(&spi_dev->dev, 0, sizeof(struct device));
+		spi_dev->dev.parent = &(ssc_busses[idx]->pdev.dev);
+		spi_dev->idx_dev = idx;
+		spi_add_adapter(spi_dev);
+	};
+	kfree(ssc_busses);
+	return 0;
+}
+
+static void __init spi_core_init(void)
+{
+	unsigned int ret;
+	dgb_print("\n");
+	ret = bus_register(&spi_bus_type);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register spi bus\n");
+		return ;
+	}
+	ret = driver_register(&spi_bus_drv);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register spi driver\n");
+		return ;
+        }
+        printk(KERN_INFO "spi layer initialized\n");
+}
+
+#ifdef CONFIG_STM_SPI_CHAR_DEV
+static void __init spi_cdev_init(void)
+{
+	dev_t ch_device;
+	dgb_print("\n");
+
+	spi_dev_class = class_create(THIS_MODULE, "spi-dev");
+	if (IS_ERR(spi_dev_class))
+		return 0;
+
+	ch_device = MKDEV(SPI_MAJOR, 0);
+	register_chrdev_region(ch_device, 255, "spi");
+	cdev_init(&(spi_cdev), &(spi_fops));
+	cdev_add(&(spi_cdev), ch_device, 255);
+	printk(KERN_INFO "spi /dev layer initialized\n");
+	return 0;
+}
+device_initcall(spi_cdev_init);
+#endif
+
+static int __init spi_late_init(void)
+{
+	dgb_print("\n");
+	spi_adapter_detect();
+	return 0;
+}
+
+static int __exit spi_exit(void)
+{
+	dev_t ch_device;
+
+	dgb_print("\n");
+#ifdef CONFIG_STM_SPI_CHAR_DEV
+	ch_device = MKDEV(SPI_MAJOR, 0);
+	cdev_del(&(spi_cdev));
+	unregister_chrdev_region(ch_device, 255);
+#endif
+
+	driver_unregister(&spi_bus_drv);
+	bus_unregister(&spi_bus_type);
+	return 0;
+}
+
+subsys_initcall(spi_core_init);
+late_initcall(spi_late_init);
+module_exit(spi_exit);
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("Module for stm spi device");
+MODULE_LICENSE("GPL");
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm_spi.h linux-2.6.23.1-stm/drivers/stm/stm_spi.h
--- linux-2.6.23.1/drivers/stm/stm_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm_spi.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,103 @@
+/*
+   --------------------------------------------------------------------
+
+   stm_spi.h
+   define and struct for SPI device driver
+   based on STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+#ifndef STM_SPI
+#define STM_SPI
+
+#define SPI_IOCTL_WIDEFRAME     0x01
+#define SPI_ARG_WIDE_16BITS     0x01
+#define SPI_ARG_WIDE_8BITS      0x00
+
+#define SPI_IOCTL_PHASE         0x02
+#define SPI_ARG_PHASE_HIGH      0x01
+#define SPI_ARG_PHASE_LOW       0x00
+
+#define SPI_IOCTL_POLARITY      0x04
+#define SPI_ARG_POLARITY_HIGH   0x01
+#define SPI_ARG_POLARIT_LOWY    0x00
+
+#define SPI_IOCTL_HEADING       0x08
+#define SPI_ARG_HEADING_MSB     0x01
+#define SPI_ARG_HEADING_LSB     0x00
+
+#define SPI_IOCTL_CSACTIVE      0x10
+#define SPI_ARG_CSACTIVE_HIGH   0x01
+#define SPI_ARG_CSACTIVE_LOW    0x00
+
+#define SPI_IOCTL_BUADRATE      0x20
+
+#define SPI_IOCTL_ADDRESS       0x40
+
+#define SPI_IOCTL_TIMEOUT       0x80
+
+/*#define SPI_IOCTL_NOSELECTION   0x100*/
+
+
+#ifdef __KERNEL__
+#include "stm_ssc.h"
+#include <linux/device.h>
+
+extern struct bus_type spi_bus_type;
+
+#define SPI_DEV_BUS_ADAPTER      0x01
+#define SPI_DEV_CLIENT_ADAPTER   0x02
+
+struct spi_device_t {
+	unsigned int idx_dev;
+        unsigned int dev_type; /* SPI_DEV_BUS_ADAPTER xor SPI_DEV_CLIENT_ADAPTER*/
+	struct device dev;
+	struct class_device *class_dev;
+};
+
+struct spi_client_t {
+	struct spi_device_t *dev;       /* the bus device used */
+	struct stpio_pin *pio_chip;
+	char *wr_buf;
+	char *rd_buf;
+	unsigned long config;		/* the clinet configuration */
+	unsigned long timeout;
+};
+
+struct spi_client_t* spi_create_client(int bus_number);
+
+int spi_client_release(struct spi_client_t* spi);
+
+int spi_client_control(struct spi_client_t* spi, int cmd, int arg);
+
+int spi_write(struct spi_client_t* spi, char *wr_buffer, size_t count);
+
+int spi_read(struct spi_client_t* spi, char *rd_buffer, size_t count);
+
+int spi_write_then_read(struct spi_client_t* spi,char *wr_buffer,
+			char *rd_buffer, size_t count);
+
+#endif
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm_ssc.c linux-2.6.23.1-stm/drivers/stm/stm_ssc.c
--- linux-2.6.23.1/drivers/stm/stm_ssc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm_ssc.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,393 @@
+/*
+   -------------------------------------------------------------------------
+   stm_ssc.c
+   -------------------------------------------------------------------------
+   STMicroelectronics
+   -------------------------------------------------------------------------
+ *  Copyright (C) 2006  Virlinzi Francesco
+ *                   <francesco.virlinzi@st.com>
+ *
+ * 23 August 2006 - Modified to support the 2.6.17 kernel version
+ *      Virlinzi Francesco <francesco.virlinzi@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "stm_ssc.h"
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/semaphore.h>
+#include <asm/clock.h>
+#include <linux/stm/soc.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+#undef dgb_print
+
+#ifdef  CONFIG_STM_SSC_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528) ||  defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+#define NR_SSC_BUSSES 2
+
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(ARCH_ST200)
+
+#define NR_SSC_BUSSES 3
+
+#elif defined(CONFIG_CPU_SUBTYPE_STX7200)
+
+#define NR_SSC_BUSSES 5
+
+#else
+#error Need to configure the right SSC number devices on this chip
+#endif
+
+
+/*
+ *  Here we alloc the right number of busses
+ */
+static struct ssc_t ssc_device[NR_SSC_BUSSES];
+
+static struct platform_device *ssc_device_data;
+static unsigned long nr_ssc_busses;
+
+unsigned int ssc_device_available()
+{
+	dgb_print("\n");
+	return nr_ssc_busses;
+}
+
+unsigned int ssc_get_clock()
+{
+	return clk_get_rate(clk_get(NULL, "comms_clk"));
+}
+
+struct ssc_t *ssc_device_request(unsigned int device_id)
+{
+	dgb_print("\n");
+	if (device_id >= nr_ssc_busses)
+		return NULL;
+
+	return &(ssc_device[device_id]);
+}
+
+unsigned int ssc_capability(unsigned int ssc_id)
+{
+	struct plat_ssc_data *info;
+	dgb_print("\n");
+
+	if (ssc_id >= nr_ssc_busses)
+		return 0;
+
+	info = (struct plat_ssc_data *)
+	    (ssc_device_data->dev.platform_data);
+	return (info->capability >> (2 * ssc_id)) &
+	    (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY);
+}
+
+void ssc_request_bus(struct ssc_t *ssc_bus, void (*irq_function) (void *),
+		     void *irq_data)
+{
+	dgb_print("\n");
+	mutex_lock(&(ssc_bus->mutex_bus));
+	ssc_bus->irq_function = irq_function;
+	ssc_bus->irq_private_data = irq_data;
+}
+
+void ssc_release_bus(struct ssc_t *ssc_bus)
+{
+   dgb_print("\n");
+	ssc_bus->irq_function = NULL;
+	ssc_bus->irq_private_data = NULL;
+	mutex_unlock(&(ssc_bus->mutex_bus));
+}
+
+static irqreturn_t ssc_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ssc_t *ssc_bus = (struct ssc *)dev_id;
+	if (ssc_bus->irq_function != NULL)
+		ssc_bus->irq_function(ssc_bus->irq_private_data);
+	return IRQ_HANDLED;
+}
+
+static int __init stm_ssc_probe(struct platform_device *dev)
+{
+	dgb_print("\n");
+	ssc_device_data = dev;
+	if (!ssc_device_data){
+		printk(KERN_ERR
+		       "Device probe failed.  Check your kernel SoC config!!\n");
+		}
+	return 0;
+}
+
+static void stm_ssc_shutdown(struct platform_device *dev)
+{
+    dgb_print("\n");
+    return;
+}
+
+#ifdef CONFIG_PM
+static unsigned long pm_ssc_ctl[NR_SSC_BUSSES];
+static int stm_ssc_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct ssc_t *ssc=container_of(dev,struct ssc_t,pdev);
+	dgb_print("%s.%u\n",dev->name,dev->id);
+	ssc_request_bus(ssc,NULL,NULL);
+	pm_ssc_ctl[ssc->pdev.id]=ssc_load16(ssc,SSC_CTL);
+	ssc_store16(ssc,SSC_CTL,0);
+	return 0;
+}
+
+static int stm_ssc_resume(struct platform_device *dev)
+{
+	struct ssc_t *ssc=container_of(dev,struct ssc_t,pdev);
+	dgb_print("%s.%u\n",dev->name,dev->id);
+	ssc_store16(ssc,SSC_CTL,pm_ssc_ctl[ssc->pdev.id]);
+	ssc_release_bus(ssc);
+	return 0;
+}
+#endif
+
+static struct platform_driver ssc_driver = {
+	.driver.name = "ssc",
+	.driver.owner = THIS_MODULE,
+	.probe = stm_ssc_probe,
+	.shutdown = stm_ssc_shutdown,
+#ifdef CONFIG_PM
+	.suspend = stm_ssc_suspend,
+	.resume  = stm_ssc_resume,
+#endif
+};
+
+/*
+ * Request the IO memory
+ * Remap   the IO memory
+ * Request the right PIO pins
+ * Request the interrupt line.
+ */
+static int ssc_hw_resrc_init(struct ssc_t *ssc_data)
+{
+	struct resource *res;
+	struct plat_ssc_data *info;
+	struct plat_ssc_pio_t *pio_info;
+	unsigned char pio_bank;
+	unsigned char pio_line;
+
+	dgb_print("\n");
+
+	info = (struct plat_ssc_data *)
+	    (ssc_device_data->dev.platform_data);
+	pio_info = info->pio;
+/*1.    IO Mem*/
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->pdev.id);
+	if (!res) {
+		printk(KERN_ERR
+		       "Error on platform_get_resource mem settings\n");
+		return -ENODEV;
+	}
+	if (!request_mem_region(res->start, res->end - res->start, "ssc")) {
+		printk(KERN_ERR "ERROR: ssc %d Request MEM Region NOT Done\n",
+		       ssc_data->pdev.id);
+		return -ENODEV;
+	}
+	dgb_print("ssc bus %d Request MEM Region Done\n", ssc_data->pdev.id);
+	ssc_data->base = ioremap(res->start, res->end - res->start);
+
+	dgb_print("ssc bus %d Request MEM Region Remapping Done\n",
+		ssc_data->pdev.id);
+/* 2.   Request of PIO pins */
+
+/* 2.1  Pio clock */
+	pio_bank = pio_info[ssc_data->pdev.id].sclbank;
+	pio_line = pio_info[ssc_data->pdev.id].sclpin;
+
+	ssc_data->pio_clk = stpio_request_pin(pio_bank, pio_line,
+					      "ssc clock", STPIO_ALT_BIDIR);
+	if (!ssc_data->pio_clk) {
+		printk(KERN_ERR
+		       "ERROR: ssc bus %d Request PIO clock pins not Done\n",
+		       ssc_data->pdev.id);
+		goto release_mem_region;
+	}
+	dgb_print("ssc bus %d Request Clock: Pin%d[%d] Done\n", ssc_data->pdev.id,
+		pio_bank, pio_line);
+/* 2.2  Pio Data out */
+	pio_bank = pio_info[ssc_data->pdev.id].sdoutbank;
+	pio_line = pio_info[ssc_data->pdev.id].sdoutpin;
+
+	ssc_data->pio_data = stpio_request_pin(pio_bank, pio_line,
+					       "ssc data", STPIO_ALT_BIDIR);
+	if (!ssc_data->pio_data) {
+		printk(KERN_ERR
+		       "ERROR: ssc bus %d Request PIO Data pins not Done\n",
+		       ssc_data->pdev.id);
+		goto release_pio_clk;
+	}
+	dgb_print("ssc bus %d Request Data: Pin%d[%d] Done\n",
+		ssc_data->pdev.id, pio_bank, pio_line);
+
+/* 2.3 Pio Data in */
+	ssc_data->pio_data_in = NULL;
+
+	pio_bank = pio_info[ssc_data->pdev.id].sdinbank;
+	pio_line = pio_info[ssc_data->pdev.id].sdinpin;
+
+	if (pio_bank != 0xff) {
+		ssc_data->pio_data_in =
+		    stpio_request_pin(pio_bank,
+				      pio_line, "ssc data in", STPIO_ALT_BIDIR);
+		if (ssc_data->pio_data_in == NULL) {
+			printk(KERN_ERR
+			       "ERROR: ssc %d Request PIO DataIN pins not Done\n",
+			       ssc_data->pdev.id);
+			goto release_pio_data;
+		}
+		dgb_print("ssc bus %d Request DataIN Pin%d[%d] Done\n",
+			ssc_data->pdev.id, pio_bank, pio_line);
+	}
+	/* 3.  Request of IRQ */
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_IRQ,
+				  ssc_data->pdev.id);
+	if (!res) {
+		printk(KERN_ERR
+		       "Error on platform_get_resource irq settings\n");
+		goto release_pio_data_in;
+	}
+	if (request_irq(res->start, ssc_handler, SA_INTERRUPT, "ssc",
+			ssc_data) < 0) {
+		printk(KERN_ERR "ERROR: ssc bus %d Request IRQ NOT Done\n",
+		       ssc_data->pdev.id);
+		goto release_pio_data_in;
+	}
+	dgb_print("ssc bus %d Request IRQ %d Done\n",
+		ssc_data->pdev.id, res->start);
+/*
+ *	Already done in the platform_device_register(..) ... 
+ *	ssc_data->pdev.dev.parent = &platform_bus ;
+ *	ssc_data->pdev.dev.bus    = &platform_bus_type ;
+ */
+	
+	ssc_data->pdev.name = ssc_device_data->name;
+        ssc_data->pdev.dev.driver = &ssc_driver.driver;
+ 
+	if ( platform_device_register(&ssc_data->pdev)<0){
+           printk(KERN_ERR "ERROR: Incapable to register ssc device\n");
+           goto release_irq;
+        }
+	return 0;
+      release_irq:
+        free_irq(res->start, ssc_handler);
+      release_pio_data_in:
+	if (ssc_data->pio_data_in != NULL)
+		stpio_free_pin(ssc_data->pio_data_in);
+      release_pio_data:
+	stpio_free_pin(ssc_data->pio_data);
+      release_pio_clk:
+	stpio_free_pin(ssc_data->pio_clk);
+      release_mem_region:
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->pdev.id);
+
+	release_mem_region(res->start, res->end - res->start);
+
+	return -ENODEV;
+}
+
+static void ssc_hw_release(struct ssc_t *ssc_data)
+{
+	struct resource *res;
+	dgb_print("\n");
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->pdev.id);
+
+	release_mem_region(res->start, res->end - res->start);
+
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_IRQ,
+				  ssc_data->pdev.id);
+	free_irq(res->start, ssc_data);
+
+	stpio_free_pin(ssc_data->pio_data);
+	stpio_free_pin(ssc_data->pio_clk);
+	if (!(ssc_data->pio_data_in))
+		stpio_free_pin(ssc_data->pio_data_in);
+}
+
+static int __init ssc_bus_init(void)
+{
+	unsigned int index;
+	struct ssc_t *pssc_bus;
+        dgb_print("\n");
+	platform_driver_register(&ssc_driver);
+	dgb_print("ssc driver registered\n");
+	if (!ssc_device_data) {
+		printk(KERN_ERR "Error on ssc platform settings\n");
+		return -ENODEV;
+	}
+/*
+ *      The ssc_device_data is removed from platform devices
+ *      to avoid problem with suspend/resume...
+ *      in any case it will be used as data base...
+ */
+	platform_device_del(ssc_device_data);
+
+	nr_ssc_busses=ssc_device_data->num_resources/2;
+
+	for (index = 0; index < nr_ssc_busses; ++index) {
+		pssc_bus = &(ssc_device[index]);
+		pssc_bus->pdev.id = index;
+		mutex_init(&(pssc_bus->mutex_bus));
+		init_waitqueue_head(&(pssc_bus->wait_queue));
+		ssc_hw_resrc_init(pssc_bus);
+	}
+
+	printk(KERN_INFO "stssc layer initialized\n");
+	return 0;
+}
+
+static void __exit ssc_bus_exit(void)
+{
+	unsigned int index;
+
+	dgb_print("\n");
+
+	if (!ssc_device_data)
+		return;
+	for (index = 0; index < NR_SSC_BUSSES; ++index) {
+		ssc_hw_release(&(ssc_device[index]));
+	}
+}
+
+/*
+ * If modules is NOT defined when this file is compiled, then the MODULE_*
+ * macros will resolve to nothing
+ */
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("stssc bus adapter routines for ssc device");
+MODULE_LICENSE("GPL");
+
+/* Called when module is loaded or when kernel is initialized.
+ * If MODULES is defined when this file is compiled, then this function will
+ * resolve to init_module (the function called when insmod is invoked for a
+ * module).  Otherwise, this function is called early in the boot, when the
+ * kernel is intialized
+ */
+
+module_init(ssc_bus_init);
+
+module_exit(ssc_bus_exit);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/stm_ssc.h linux-2.6.23.1-stm/drivers/stm/stm_ssc.h
--- linux-2.6.23.1/drivers/stm/stm_ssc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/stm_ssc.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,229 @@
+/*
+   --------------------------------------------------------------------
+
+   stm_ssc.h
+   define and struct for STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef STM_SSC_H
+#define STM_SSC_H 1
+
+#include <linux/platform_device.h>
+#include <linux/wait.h>
+#include <linux/stm/pio.h>
+#include <linux/mutex.h>
+#include <asm/io.h>
+
+
+/* SSC Baud Rate generator */
+#define SSC_BRG                  0x0
+/* SSC Transmitter Buffer  */
+#define SSC_TBUF                 0x4
+/* SSC Receive Buffer      */
+#define SSC_RBUF                 0x8
+/*SSC Control              */
+#define SSC_CTL                  0xC
+#define SSC_CTL_DATA_WIDTH_9     0x8
+#define SSC_CTL_BM               0xf
+#define SSC_CTL_HB               0x10
+#define SSC_CTL_PH               0x20
+#define SSC_CTL_PO		 0x40
+#define SSC_CTL_SR		 0x80
+#define SSC_CTL_MS		 0x100
+#define SSC_CTL_EN		 0x200
+#define SSC_CTL_LPB		 0x400
+#define SSC_CTL_EN_TX_FIFO       0x800
+#define SSC_CTL_EN_RX_FIFO       0x1000
+#define SSC_CTL_EN_CLST_RX       0x2000
+
+/* SSC Interrupt Enable */
+#define SSC_IEN               	0x10
+#define SSC_IEN_RIEN		0x1
+#define SSC_IEN_TIEN		0x2
+#define SSC_IEN_TEEN		0x4
+#define SSC_IEN_REEN		0x8
+#define SSC_IEN_PEEN		0x10
+#define SSC_IEN_AASEN		0x40
+#define SSC_IEN_STOPEN		0x80
+#define SSC_IEN_ARBLEN		0x100
+#define SSC_IEN_NACKEN		0x400
+#define SSC_IEN_REPSTRTEN	0x800
+#define SSC_IEN_TX_FIFO_HALF	0x1000
+#define SSC_IEN_RX_FIFO_HALF_FULL	0x4000
+
+/* SSC Status */
+#define SSC_STA                   0x14
+#define SSC_STA_RIR		  0x1
+#define SSC_STA_TIR		  0x2
+#define SSC_STA_TE		  0x4
+#define SSC_STA_RE		  0x8
+#define SSC_STA_PE		 0x10
+#define SSC_STA_CLST		 0x20
+#define SSC_STA_AAS		 0x40
+#define SSC_STA_STOP		 0x80
+#define SSC_STA_ARBL		0x100
+#define SSC_STA_BUSY		0x200
+#define SSC_STA_NACK		0x400
+#define SSC_STA_REPSTRT		0x800
+#define SSC_STA_TX_FIFO_HALF	0x1000
+#define SSC_STA_TX_FIFO_FULL    0x2000
+#define SSC_STA_RX_FIFO_HALF    0x4000
+
+/*SSC I2C Control */
+#define SSC_I2C               	0x18
+#define SSC_I2C_I2CM		0x1
+#define SSC_I2C_STRTG		0x2
+#define SSC_I2C_STOPG		0x4
+#define SSC_I2C_ACKG		0x8
+#define SSC_I2C_AD10		0x10
+#define SSC_I2C_TXENB		0x20
+#define SSC_I2C_REPSTRTG	0x800
+#define SSC_I2C_I2CFSMODE	0x1000
+/* SSC Slave Address */
+#define SSC_SLAD              	0x1C
+/* SSC I2C bus repeated start hold time */
+#define SSC_REP_START_HOLD    	0x20
+/* SSC I2C bus start hold time */
+#define SSC_START_HOLD        	0x24
+/* SSC I2C bus repeated start setup time */
+#define SSC_REP_START_SETUP   	 0x28
+/* SSC I2C bus repeated stop setup time */
+#define SSC_DATA_SETUP		0x2C
+/* SSC I2C bus stop setup time */
+#define SSC_STOP_SETUP		0x30
+/* SSC I2C bus free time */
+#define SSC_BUS_FREE		0x34
+
+/* SSC Tx FIFO Status */
+#define SSC_TX_FSTAT            0x38
+#define SSC_TX_FSTAT_STATUS     0x07
+
+/* SSC Rx FIFO Status */
+#define SSC_RX_FSTAT            0x3C
+#define SSC_RX_FSTAT_STATUS     0x07
+
+/* SSC Prescaler value value for clock */
+#define SSC_PRE_SCALER_BRG      0x40
+
+/* SSC Clear bit operation */
+#define SSC_CLR			0x80
+#define SSC_CLR_SSCAAS 		0x40
+#define SSC_CLR_SSCSTOP 	0x80
+#define SSC_CLR_SSCARBL 	0x100
+#define SSC_CLR_NACK    	0x400
+#define SSC_CLR_REPSTRT     	0x800
+
+/* SSC Noise suppression Width */
+#define SSC_AGFR		0x100
+/* SSC Clock Prescaler */
+#define SSC_PRSC		0x104
+#define SSC_PRSC_VALUE          0x0f
+
+/* SSC Max delay width*/
+#define SSC_MAX_DELAY		0x108
+
+/* SSC Prescaler for delay in dataout */
+#define SSC_PRSC_DATAOUT	0x10c
+
+#define SSC_TXFIFO_SIZE         0x8
+#define SSC_RXFIFO_SIZE         0x8
+/*
+ * The I2C timing register could be ready
+ * for normal or fast rate
+ */
+#define SSC_I2C_READY_NORMAL    0x0
+#define SSC_I2C_READY_FAST      0x1
+struct ssc_t {
+	struct stpio_pin *pio_clk;
+	struct stpio_pin *pio_data;
+	struct stpio_pin *pio_data_in;
+	wait_queue_head_t wait_queue;
+	struct mutex	  mutex_bus;
+	void *base;
+	void (*irq_function) (void *);
+	void *irq_private_data;
+        unsigned char    i2c_timing;
+        struct platform_device pdev;
+};
+
+struct ssc_t *ssc_device_request(unsigned int ssc_id);
+
+/*
+ *  How many ssc device are available on this platform
+ */
+unsigned int ssc_device_available(void);
+
+/*
+ *  The input clock for each SSC device
+ */
+
+unsigned int ssc_get_clock(void);
+
+/*
+ *  To say if the ssc_is ssc can support I2C and/or SPI protocol
+ */
+
+#define SSC_I2C_CAPABILITY  0x1
+#define SSC_SPI_CAPABILITY  0x2
+
+unsigned int ssc_capability(unsigned int ssc_id);
+/*
+ *   To request the bus access
+ *   The user registers also the function and the data that
+ *   they want use in the IRQ_Function
+ */
+void ssc_request_bus(struct ssc_t *, void (*irq_function) (void *),
+		     void *irq_data);
+
+/*
+ *   To release the bus
+ */
+void ssc_release_bus(struct ssc_t *);
+
+/*
+   we have to use the following macro
+   to access the SSC I/O Memory
+*/
+#define ssc_store16(ssc , offset, value) iowrite16(value,ssc->base+offset)
+#define ssc_store8( ssc , offset, value) iowrite8( value,ssc->base+offset)
+
+#define ssc_load16( ssc,offset)          ioread16(ssc->base+offset)
+#define ssc_load8(  ssc,offset)	         ioread8( ssc->base+offset)
+
+/*
+ *   This macro could be used to built the capability field
+ *   of struct plat_ssc_data for each SoC
+ */
+#define ssc_ability(idx_ssc, cap)  \
+         ( cap & (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY ) ) << (idx_ssc*2)
+
+#define ssc0_ability(cap)  ssc_ability(0,cap)
+#define ssc1_ability(cap)  ssc_ability(1,cap)
+#define ssc2_ability(cap)  ssc_ability(2,cap)
+#define ssc3_ability(cap)  ssc_ability(3,cap)
+#define ssc4_ability(cap)  ssc_ability(4,cap)
+
+#endif				/* STM_SSC_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/stm/sysconf.c linux-2.6.23.1-stm/drivers/stm/sysconf.c
--- linux-2.6.23.1/drivers/stm/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/stm/sysconf.c	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/sysconf.h>
+
+#include <asm/io.h>
+
+#define DRIVER_NAME "sysconf"
+
+struct sysconf_field {
+	u16 offset;
+	u8 lsb, msb;
+};
+
+static void __iomem *sysconf_base;
+static int sysconf_offsets[3];
+static DEFINE_SPINLOCK(sysconf_lock);
+
+/* We need a small stash of allocations before kmalloc becomes available */
+#define NUM_EARLY_FIELDS 10
+static struct sysconf_field early_fields[NUM_EARLY_FIELDS];
+static int next_early_field = 0;
+
+static struct sysconf_field* field_alloc(void)
+{
+	if (next_early_field < NUM_EARLY_FIELDS)
+		return &early_fields[next_early_field++];
+
+	return kzalloc(sizeof(struct sysconf_field), GFP_KERNEL);
+}
+
+struct sysconf_field* sysconf_claim(int regtype, int regnum, int lsb, int msb,
+				    const char *dev)
+{
+	struct sysconf_field *field;
+
+	field = field_alloc();
+	if (!field)
+		return NULL;
+
+	field->offset = sysconf_offsets[regtype] + (regnum * 4);
+	field->lsb = lsb;
+	field->msb = msb;
+
+	return field;
+}
+
+void sysconf_write(struct sysconf_field *field, u64 value)
+{
+	void __iomem *reg;
+	int field_bits;	/* Actually number of bits -1 */
+
+	reg = sysconf_base + field->offset;
+	field_bits = field->msb - field->lsb;
+
+	if (field_bits == 31) {
+		/* Operating on the whole register, nice and easy */
+		writel(value, reg);
+	} else {
+		u32 reg_mask;
+		u32 tmp;
+
+		reg_mask = ~(((1 << field_bits) -1) << field->lsb);
+		spin_lock(&sysconf_lock);
+		tmp = readl(reg);
+		tmp &= reg_mask;
+		tmp |= value << field->lsb;
+		writel(tmp, reg);
+		spin_unlock(&sysconf_lock);
+	}
+}
+
+u64 sysconf_read(struct sysconf_field *field)
+{
+	void __iomem *reg;
+	int field_bits;	/* Actually number of bits -1 */
+	u32 tmp;
+
+	reg = sysconf_base + field->offset;
+	tmp = readl(reg);
+	field_bits = field->msb - field->lsb;
+
+	if (field_bits != 31) {
+		tmp >>= field->lsb;
+		tmp &= (1 << field_bits) -1;
+	}
+
+	return (u64)tmp;
+}
+
+/* This is called early to allow board start up code to use sysconf
+ * registers (in particular console devices). */
+void __init sysconf_early_init(struct platform_device* pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+	struct plat_sysconf_data *data = pdev->dev.platform_data;
+
+#if 1
+	sysconf_base = ioremap(pdev->resource[0].start, size);
+
+	/* I don't like panicing here, but it we failed to ioremap, we
+	 * probably don't have any way to report things have gone
+	 * wrong. So a panic here at least gives some hope of being able to
+	 * debug the problem.
+	 */
+	if (!sysconf_base)
+		panic("Unable to ioremap sysconf registers");
+#else
+	set_fixmap_nocache(FIX_SYSCONF, pdev->resource[0].start);
+	sysconf_base = fix_to_virt(FIX_SYSCONF);
+#endif
+
+	sysconf_offsets[SYS_DEV] = data->sys_device_offset;
+	sysconf_offsets[SYS_STA] = data->sys_sta_offset;
+	sysconf_offsets[SYS_CFG] = data->sys_cfg_offset;
+}
+
+static int __init sysconf_probe(struct platform_device *pdev)
+{
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(pdev->resource[0].start, size, pdev->name))
+		return -EBUSY;
+
+	/* Have we already been set up through sysconf_init? */
+	if (sysconf_base)
+		return 0;
+
+#if 1
+	sysconf_early_init(pdev);
+#else
+	sysconf_base = ioremap(pdev->resource[0].start, size);
+	if (!sysconf_base)
+		return -ENOMEM;
+#endif
+
+	return 0;
+}
+
+static struct platform_driver sysconf_driver = {
+	.probe		= sysconf_probe,
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init sysconf_init(void)
+{
+	return platform_driver_register(&sysconf_driver);
+}
+
+arch_initcall(sysconf_init);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/Kconfig linux-2.6.23.1-stm/drivers/usb/Kconfig
--- linux-2.6.23.1/drivers/usb/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -41,6 +41,9 @@
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
+	# SH
+	default y if CPU_SUBTYPE_STB7100
+	default y if CPU_SUBTYPE_STX7200
 	# more:
 	default PCI
 
@@ -49,6 +52,8 @@
 	boolean
 	default y if PPC_83xx
 	default y if SOC_AU1200
+	default y if CPU_SUBTYPE_STB7100
+	default y if CPU_SUBTYPE_STX7200
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/Makefile linux-2.6.23.1-stm/drivers/usb/host/Makefile
--- linux-2.6.23.1/drivers/usb/host/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/Makefile	2007-11-01 12:00:42.000000000 +0000
@@ -16,4 +16,5 @@
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
-
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= stb7100-common.o
+obj-$(CONFIG_CPU_SUBTYPE_STX7200)	+= stb7100-common.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/ehci-hcd.c linux-2.6.23.1-stm/drivers/usb/host/ehci-hcd.c
--- linux-2.6.23.1/drivers/usb/host/ehci-hcd.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/ehci-hcd.c	2007-11-01 12:00:42.000000000 +0000
@@ -939,6 +939,11 @@
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7200)
+#include "ehci-stcore.c"
+#define	PLATFORM_DRIVER		ehci_hcd_st40_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/ehci-stcore.c linux-2.6.23.1-stm/drivers/usb/host/ehci-stcore.c
--- linux-2.6.23.1/drivers/usb/host/ehci-stcore.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/ehci-stcore.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,179 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * Bus Glue for STMicroelectronics STx710x devices.
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#include "stb7100-common.h"
+
+#ifdef	CONFIG_PM
+static int ehci_st40_suspend(struct usb_hcd *hcd, pm_message_t message)
+{
+	/* Needs implementation! Look at ehci-pci as guide */
+	return 0;
+}
+
+static int ehci_st40_resume(struct usb_hcd *hcd)
+{
+	/* Needs implementation! Look at ehci-pci as guide */
+	return 0;
+}
+#endif
+
+static irqreturn_t ehci_st40_irq(struct usb_hcd *hcd)
+{
+	irqreturn_t retval;
+
+	usb_hcd_st40_wait_irq();
+	retval = ehci_irq(hcd);
+
+	return retval;
+}
+
+static int ehci_st40_reset(struct usb_hcd *hcd)
+{
+	writel(AHB2STBUS_INOUT_THRESHOLD,
+	       hcd->regs + AHB2STBUS_INSREG01_OFFSET);
+	return ehci_init(hcd);
+}
+
+static const struct hc_driver ehci_st40_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "ST EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_st40_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_st40_reset,
+	.start = ehci_run,
+#ifdef	CONFIG_PM
+	.suspend = ehci_st40_suspend,
+	.resume = ehci_st40_resume,
+#endif
+	.stop = ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+};
+
+static void ehci_hcd_st40_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static int ehci_hcd_st40_probe(const struct hc_driver *driver,
+			       struct usb_hcd **hcd_out,
+			       struct platform_device *dev)
+{
+	int retval = 0;
+	struct usb_hcd *hcd;
+        struct ehci_hcd *ehci;
+
+	retval = ST40_start_host_control(dev);
+	if (retval)
+		return retval;
+
+	hcd = usb_create_hcd(driver, &dev->dev, "STB7100_EHCI");
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize device reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	retval=usb_add_hcd(hcd, dev->resource[1].start, SA_SHIRQ);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	return retval;
+}
+
+static int ehci_hcd_st40_driver_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = ehci_hcd_st40_probe(&ehci_st40_hc_driver, &hcd, pdev);
+	return ret;
+}
+
+static int ehci_hcd_st40_driver_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	ehci_hcd_st40_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ehci_hcd_st40_driver = {
+	.probe = ehci_hcd_st40_driver_probe,
+	.remove = ehci_hcd_st40_driver_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "ST40-ehci",
+		.bus = &platform_bus_type
+	}
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/ohci-hcd.c linux-2.6.23.1-stm/drivers/usb/host/ohci-hcd.c
--- linux-2.6.23.1/drivers/usb/host/ohci-hcd.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/ohci-hcd.c	2007-11-01 12:00:42.000000000 +0000
@@ -915,6 +915,12 @@
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || \
+	defined(CONFIG_CPU_SUBTYPE_STX7200)
+#include "ohci-stcore.c"
+#define PLATFORM_DRIVER		ohci_hcd_stm_driver
+#endif
+
 
 #ifdef CONFIG_USB_OHCI_HCD_PPC_OF
 #include "ohci-ppc-of.c"
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/ohci-stcore.c linux-2.6.23.1-stm/drivers/usb/host/ohci-stcore.c
--- linux-2.6.23.1/drivers/usb/host/ohci-stcore.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/ohci-stcore.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,167 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2005
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * STMicroelectronics on-chip USB host controller Bus Glue.
+ * Based on the StrongArm ohci-sa1111.c file
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/platform_device.h>
+#include "ohci-stcore.h"
+
+extern int usb_disabled(void);
+
+#define DEVICE_NAME "STB7100 OHCI"
+#include "stb7100-common.h"
+
+static irqreturn_t ohci_st40_irq(struct usb_hcd *hcd)
+{
+	irqreturn_t retval;
+
+	usb_hcd_st40_wait_irq();
+	retval = ohci_irq(hcd);
+
+	return retval;
+}
+
+static int
+ohci_st40_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret = 0;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int
+ohci_st40_suspend(struct usb_hcd *hcd, pm_message_t message)
+{
+	return 0;
+}
+
+static int
+ohci_st40_resume(struct usb_hcd *hcd)
+{
+	return 0;
+}
+
+static const struct hc_driver ohci_st40_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		DEVICE_NAME,
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/* generic hardware linkage */
+	.irq =			ohci_st40_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/* basic lifecycle operations */
+	.start =		ohci_st40_start,
+#ifdef	CONFIG_PM
+	.suspend =		ohci_st40_suspend,
+	.resume =		ohci_st40_resume,
+#endif
+	.stop =			ohci_stop,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number =	ohci_get_frame,
+
+	/* root hub support */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_USB_SUSPEND
+/* note we don't export these funcs for our ohci*/
+/*	.hub_suspend =		ohci_hub_suspend,*/
+/*	.hub_resume =		ohci_hub_resume,*/
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+static int ohci_hcd_stm_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	const struct hc_driver *driver = &ohci_st40_hc_driver;
+	int retval;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	retval = ST40_start_host_control(pdev);
+	if (retval)
+		return retval;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, DEVICE_NAME);
+	if (!hcd) {
+		pr_debug("hcd_create_hcd failed");
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,	hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, SA_INTERRUPT);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	return retval;
+}
+
+static int ohci_hcd_stm_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_stm_driver = {
+	.driver = {
+		.name = "stm-ohci",
+	},
+	.probe = ohci_hcd_stm_probe,
+	.remove = ohci_hcd_stm_remove,
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/ohci-stcore.h linux-2.6.23.1-stm/drivers/usb/host/ohci-stcore.h
--- linux-2.6.23.1/drivers/usb/host/ohci-stcore.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/ohci-stcore.h	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,49 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2005
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * STMicroelectronics on-chip USB host controller Bus Glue.
+ * Based on the StrongArm ohci-sa1111.c file
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#ifndef ST40_ASSIST_H
+#define ST40_ASSIST_H
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+
+	#define CFG_BASE_ADDRESS         0xb9162000
+	#define USB_OHCI_0_BASE          0xb9141000
+	#define USB_OHCI_1_BASE          0xb9142000
+
+	#define STBUS_USB_0_STATUS_REG   (USB_OHCI_0_BASE + 0x58)
+	#define STBUS_USB_1_STATUS_REG   (USB_OHCI_1_BASE + 0x58)
+	#define STBUS_USB_0_MASK_REG     (USB_OHCI_0_BASE + 0x5c)
+	#define STBUS_USB_1_MASK_REG     (USB_OHCI_1_BASE + 0x5c)
+
+	#define SYSTEM_CONFIG10          (CFG_BASE_ADDRESS + 0x58)
+
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+	#define USB_OHCI_0_BASE         0xb4400000
+	#define FS_B_BASE              (0xb0420000)
+	#define FS_CONFIG_CLK_3        (FS_B_BASE + 0x18)
+	#define FS_CONFIG_GENERIC_INFO (FS_B_BASE + 0x00)
+
+	#define STBUS_USB_STATUS_REG    (USB_OHCI_0_BASE + 0x58)
+	#define STBUS_USB_MASK_REG      (USB_OHCI_0_BASE + 0x5c)
+#endif
+
+#define INT_RMT_WAKEUP			0x01
+#define INT_BUF_ACCESS			0x02
+#define INT_NEW_FRAME			0x04
+#define INT_GENERAL			0x08
+#define STBUS_USB_MASK_DEFAULT  (INT_RMT_WAKEUP | INT_BUF_ACCESS | INT_GENERAL)
+#define USB_POWER_ENABLE 		((  1 <<4) | ( 1 <<11)) /*power enable usb blk 1/2*/
+
+#endif
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/stb7100-common.c linux-2.6.23.1-stm/drivers/usb/host/stb7100-common.c
--- linux-2.6.23.1/drivers/usb/host/stb7100-common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/stb7100-common.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,114 @@
+/*
+ * STb7100 common OHCI/EHCI controller functions.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/stm/soc.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <asm/io.h>
+#include "stb7100-common.h"
+
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#define STRAP_MODE	0 /* 8 bit */
+#define MSGSIZE		AHB2STBUS_MSGSIZE_4
+#define CHUNKSIZE	AHB2STBUS_CHUNKSIZE_4
+#else
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+#define MSGSIZE		AHB2STBUS_MSGSIZE_64
+#define CHUNKSIZE	AHB2STBUS_CHUNKSIZE_64
+#endif
+
+#define RESOURCE_NAME "USB wrapper"
+
+static DEFINE_MUTEX(wraper_mutex);
+
+/*
+ * Set up the USB hardware wrapper
+ */
+int ST40_start_host_control(struct platform_device *pdev)
+{
+	struct plat_usb_data *usb_wrapper = pdev->dev.platform_data;
+	unsigned long ahb2stbus_wrapper_glue_base =
+		usb_wrapper->ahb2stbus_wrapper_glue_base;
+	unsigned long ahb2stbus_protocol_base =
+		usb_wrapper->ahb2stbus_protocol_base;
+	unsigned long reg;
+	int retval;
+	void *wrapper_base;
+	void *protocol_base;
+
+	mutex_lock(&wraper_mutex);
+
+	if (usb_wrapper->initialised)
+		goto success;
+
+	retval = -EBUSY;
+
+	if (!request_mem_region(ahb2stbus_wrapper_glue_base, 0x100,
+				RESOURCE_NAME))
+		goto err1;
+
+	if (!request_mem_region(ahb2stbus_protocol_base, 0x100,
+				RESOURCE_NAME))
+		goto err2;
+
+	retval = -ENOMEM;
+
+	wrapper_base = ioremap(ahb2stbus_wrapper_glue_base, 0x100);
+	if (!wrapper_base)
+		goto err3;
+
+	protocol_base = ioremap(ahb2stbus_protocol_base, 0x100);
+	if (!protocol_base)
+		goto err4;
+
+	/* Set strap mode */
+	reg = readl(wrapper_base + AHB2STBUS_STRAP_OFFSET);
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+	reg |= STRAP_MODE;
+	writel(reg, wrapper_base + AHB2STBUS_STRAP_OFFSET);
+
+	/* Start PLL */
+	reg = readl(wrapper_base + AHB2STBUS_STRAP_OFFSET);
+	writel(reg | AHB2STBUS_STRAP_PLL,
+	       wrapper_base + AHB2STBUS_STRAP_OFFSET);
+	mdelay(100);
+	writel(reg & (~AHB2STBUS_STRAP_PLL),
+	       wrapper_base + AHB2STBUS_STRAP_OFFSET);
+	mdelay(100);
+
+	/* Set the STBus Opcode Config for load/store 32 */
+	writel(AHB2STBUS_STBUS_OPC_32BIT,
+	       protocol_base + AHB2STBUS_STBUS_OPC_OFFSET);
+
+	/* Set the Message Size Config to n packets per message */
+	writel(MSGSIZE,
+	       protocol_base + AHB2STBUS_MSGSIZE_OFFSET);
+
+	writel(CHUNKSIZE,
+	       protocol_base + AHB2STBUS_CHUNKSIZE_OFFSET);
+
+	usb_wrapper->power_up(pdev);
+
+	usb_wrapper->initialised = 1;
+
+success:
+	mutex_unlock(&wraper_mutex);
+	return 0;
+
+err4:
+	iounmap(wrapper_base);
+err3:
+	release_mem_region(ahb2stbus_protocol_base, 0x100);
+err2:
+	release_mem_region(ahb2stbus_wrapper_glue_base, 0x100);
+err1:
+	mutex_unlock(&wraper_mutex);
+	return retval;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/usb/host/stb7100-common.h linux-2.6.23.1-stm/drivers/usb/host/stb7100-common.h
--- linux-2.6.23.1/drivers/usb/host/stb7100-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/usb/host/stb7100-common.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,106 @@
+/*
+ * STb7100 common OHCI/EHCI controller functions.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+/*
+ * Some of these register are described in ADCS 7518758.
+ */
+
+/* The transaction opcode is programmed in this register */
+#define AHB2STBUS_STBUS_OPC_OFFSET	0x00	/* From AHB2STBUS_PROTOCOL_BASE */
+#define AHB2STBUS_STBUS_OPC_4BIT	0x00
+#define AHB2STBUS_STBUS_OPC_8BIT	0x01
+#define AHB2STBUS_STBUS_OPC_16BIT	0x02
+#define AHB2STBUS_STBUS_OPC_32BIT	0x03
+#define AHB2STBUS_STBUS_OPC_64BIT	0x04
+
+/* The message length in number of packets is programmed in this register. */
+#define AHB2STBUS_MSGSIZE_OFFSET	0x04	/* From AHB2STBUS_PROTOCOL_BASE */
+#define AHB2STBUS_MSGSIZE_DISABLE	0x0
+#define AHB2STBUS_MSGSIZE_2		0x1
+#define AHB2STBUS_MSGSIZE_4		0x2
+#define AHB2STBUS_MSGSIZE_8		0x3
+#define AHB2STBUS_MSGSIZE_16		0x4
+#define AHB2STBUS_MSGSIZE_32		0x5
+#define AHB2STBUS_MSGSIZE_64		0x6
+
+/* The chunk size in number of packets is programmed in this register */
+#define AHB2STBUS_CHUNKSIZE_OFFSET	0x08	/* From AHB2STBUS_PROTOCOL_BASE */
+#define AHB2STBUS_CHUNKSIZE_DISABLE	0x0
+#define AHB2STBUS_CHUNKSIZE_2		0x1
+#define AHB2STBUS_CHUNKSIZE_4		0x2
+#define AHB2STBUS_CHUNKSIZE_8		0x3
+#define AHB2STBUS_CHUNKSIZE_16		0x4
+#define AHB2STBUS_CHUNKSIZE_32		0x5
+#define AHB2STBUS_CHUNKSIZE_64		0x6
+
+/* This register holds the timeout value in number of STBus clock cycles */
+#define AHB2STBUS_REQ_TIMEOUT		(AHB2STBUS_PROTOCOL_BASE + 0x0c)
+
+/* Undocumented */
+#define AHB2STBUS_PC_STATUS		(AHB2STBUS_PROTOCOL_BASE + 0x10)
+#define AHB2STBUS_PC_STATUS_IDLE	1
+
+
+/* This register implements interrupt status for the OHCI controller */
+#define AHB2STBUS_OHCI_INT_STS		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x08)
+
+/* This register implements interrupt mask for the OHCI controller */
+#define AHB2STBUS_OHCI_INT_MASK		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x0c)
+
+/* This register implements interrupt status for the EHCI controller */
+#define AHB2STBUS_EHCI_INT_STS		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x10)
+
+
+#define AHB2STBUS_STRAP_OFFSET		0x14	/* From AHB2STBUS_WRAPPER_GLUE_BASE */
+#define AHB2STBUS_STRAP_PLL		0x08	/* undocumented */
+#define AHB2STBUS_STRAP_16_BIT		0x04	/* ss_word_if */
+
+/* Define a bus wrapper IN/OUT threshold of 128 */
+#define AHB2STBUS_INSREG01_OFFSET	(0x10 + 0x84) /* From AHB2STBUS_EHCI_BASE */
+#define AHB2STBUS_INOUT_THRESHOLD	0x00800080
+
+static inline void usb_hcd_st40_wait_irq(void)
+{
+#if 0
+	/*
+	 * Fix required to work around a problem which causes controller
+	 * memory writes to be overtaken by interrupt requests.
+	 *
+	 * From the document:
+	 * STBus USB Host 2.0 Controller
+	 * Known Problems and Workaround
+	 *
+	 * 2.1 Interrupt Generation not linked with completed read/write
+	 * on STBUS
+	 *
+	 * This limitation occurs because any writes issued by the AHB
+	 *Master of the Synopsys Controller to the AHB Slave of the
+	 * protocol converter is acknowledged by the STBUS target
+	 * immediately to the AHB Master, before the transfer is
+	 * completed by the STBUS Inititator.This causes the OHCI
+	 * Interrupt to be generated before the transfer is completed
+	 * on the STBUS. This may cause problems when the OHCI ISR
+	 * successfully reads the memory location before the completion
+	 * of the write by the STBUS Initiator of the DUT.
+	 *
+	 * This problems has also been observed in the EHCI controller.
+	 */
+	int count = 0;
+
+	while ((readl(AHB2STBUS_PC_STATUS) & AHB2STBUS_PC_STATUS_IDLE) == 0) {
+		count++;
+		if (count == 100) {
+			warn("OHCI AHB interrupt sync looped too many times");
+			break;
+		}
+	}
+#endif
+}
+
+int ST40_start_host_control(struct platform_device *dev);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/Kconfig linux-2.6.23.1-stm/drivers/video/Kconfig
--- linux-2.6.23.1/drivers/video/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/Kconfig	2007-11-01 12:00:41.000000000 +0000
@@ -148,6 +148,17 @@
 	  Common utility functions useful to fbdev drivers of VGA-based
 	  cards.
 
+config FB_SOFTWARE_DRAWING_HELPERS
+	tristate "Enable Software Drawing Helpers"
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	default n
+	---help---
+	  This enables the software (CFB) framebuffer drawing helpers
+	  for use by external framebuffer drivers.
+
 config FB_MACMODES
        tristate
        depends on FB
@@ -1074,7 +1085,6 @@
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
-	select FB_TILEBLITTING
 	select FB_MACMODES if PPC_PMAC
 	---help---
 	  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
@@ -1868,5 +1878,15 @@
 	source "drivers/video/logo/Kconfig"
 endif
 
-endmenu
+config FB_SPLASH
+	bool "Support for the framebuffer splash"
+	depends on FRAMEBUFFER_CONSOLE=y && !FB_TILEBLITTING
+	default n
+	---help---
+	  This option enables support for the Linux boot-up splash screen and
+	  graphical backgrounds on consoles. Note that you will need userspace
+	  splash utilities in order to take advantage of these features. Refer 
+	  to Documentation/fb/splash.txt for more information.
 
+	  If unsure, say N.
+endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/Makefile linux-2.6.23.1-stm/drivers/video/Makefile
--- linux-2.6.23.1/drivers/video/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -13,6 +13,7 @@
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
+obj-$(CONFIG_FB_SPLASH)           += fbsplash.o cfbsplash.o
 obj-y				  += backlight/ display/
 
 obj-$(CONFIG_FB_CFB_FILLRECT)  += cfbfillrect.o
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/cfbsplash.c linux-2.6.23.1-stm/drivers/video/cfbsplash.c
--- linux-2.6.23.1/drivers/video/cfbsplash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/cfbsplash.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,471 @@
+/*
+ *  linux/drivers/video/cfbsplash.c -- Framebuffer splash render functions
+ *  
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ *  Code based upon "Bootsplash" (C) 2001-2003 
+ *       Volker Poplawski <volker@poplawski.de>,
+ *       Stefan Reinauer <stepan@suse.de>,
+ *       Steffen Winterfeldt <snwint@suse.de>,
+ *       Michael Schroeder <mls@suse.de>,
+ *       Ken Wimer <wimer@suse.de>.
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */ 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/selection.h>
+#include <linux/vt_kern.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "console/fbcon.h"
+#include "fbsplash.h"
+
+#define parse_pixel(shift,bpp,type)						\
+	do {									\
+		if (d & (0x80 >> (shift)))					\
+			dd2[(shift)] = fgx;					\
+		else								\
+			dd2[(shift)] = transparent ? *(type *)splash_src : bgx;	\
+		splash_src += (bpp);						\
+	} while (0)								\
+
+extern int get_color(struct vc_data *vc, struct fb_info *info,
+		     u16 c, int is_fg);
+
+void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc)
+{
+	int i, j, k;
+	int minlen = min(min(info->var.red.length, info->var.green.length), 
+			     info->var.blue.length);
+	u32 col;
+	
+	for (j = i = 0; i < 16; i++) {
+		k = color_table[i];
+                      
+		col = ((vc->vc_palette[j++]  >> (8-minlen)) 
+			<< info->var.red.offset);
+		col |= ((vc->vc_palette[j++] >> (8-minlen)) 
+			<< info->var.green.offset);
+		col |= ((vc->vc_palette[j++] >> (8-minlen)) 
+			<< info->var.blue.offset);
+			((u32 *)info->pseudo_palette)[k] = col;
+	}
+}
+				
+void fbsplash_renderc(struct fb_info *info, int ypos, int xpos, int height, 
+		      int width, u8* src, u32 fgx, u32 bgx, u8 transparent)
+{	
+	unsigned int x, y;
+	u32 dd;
+	int bytespp = ((info->var.bits_per_pixel + 7) >> 3);
+	unsigned int d = ypos * info->fix.line_length + xpos * bytespp;
+	unsigned int ds = (ypos * info->var.xres + xpos) * bytespp;
+	u16 dd2[4];
+
+	u8* splash_src = (u8 *)(info->splash.data + ds);
+	u8* dst = (u8 *)(info->screen_base + d);
+
+	if ((ypos + height) > info->var.yres || (xpos + width) > info->var.xres)
+		return;
+	
+	for (y = 0; y < height; y++) {
+		switch (info->var.bits_per_pixel) {
+	
+		case 32:
+			for (x = 0; x < width; x++) {
+
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ? 
+					     *(u32 *)splash_src : bgx;
+				
+				d <<= 1;
+				splash_src += 4;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+		case 24:
+			for (x = 0; x < width; x++) {
+
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ? 
+					     (*(u32 *)splash_src & 0xffffff) : bgx;
+				
+				d <<= 1;
+				splash_src += 3;
+#ifdef __LITTLE_ENDIAN
+				fb_writew(dd & 0xffff, dst);
+				dst += 2;
+				fb_writeb((dd >> 16), dst);
+#else
+				fb_writew(dd >> 8, dst);
+				dst += 2;
+				fb_writeb(dd & 0xff, dst);
+#endif
+				dst++;
+			}
+			break;
+		case 16:
+			for (x = 0; x < width; x += 2) {
+		    		if ((x & 7) == 0)
+					d = *src++;
+
+				parse_pixel(0, 2, u16);
+				parse_pixel(1, 2, u16);
+#ifdef __LITTLE_ENDIAN
+				dd = dd2[0] | (dd2[1] << 16);
+#else
+				dd = dd2[1] | (dd2[0] << 16);
+#endif
+				d <<= 2;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+
+		case 8:
+			for (x = 0; x < width; x += 4) {
+				if ((x & 7) == 0)
+					d = *src++;
+	
+				parse_pixel(0, 1, u8);
+				parse_pixel(1, 1, u8);
+				parse_pixel(2, 1, u8);
+				parse_pixel(3, 1, u8);
+		
+#ifdef __LITTLE_ENDIAN
+				dd = dd2[0] | (dd2[1] << 8) | (dd2[2] << 16) | (dd2[3] << 24);
+#else
+				dd = dd2[3] | (dd2[2] << 8) | (dd2[1] << 16) | (dd2[0] << 24);
+#endif
+				d <<= 4;
+				fb_writel(dd, dst);
+				dst += 4;
+			}		
+		}
+
+		dst += info->fix.line_length - width * bytespp;
+		splash_src += (info->var.xres - width) * bytespp;
+    	}
+}
+
+#define cc2cx(a) 						\
+	((info->fix.visual == FB_VISUAL_TRUECOLOR || 		\
+	  info->fix.visual == FB_VISUAL_DIRECTCOLOR) ? 		\
+	 ((u32*)info->pseudo_palette)[a] : a)
+
+void fbsplash_putcs(struct vc_data *vc, struct fb_info *info,
+		   const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	struct fbcon_ops *ops = info->fbcon_par;
+	int fg_color, bg_color, transparent;
+	u8 *src;
+	u32 bgx, fgx;
+	u16 c = scr_readw(s);
+
+	fg_color = get_color(vc, info, c, 1);
+        bg_color = get_color(vc, info, c, 0);
+	
+	/* Don't paint the background image if console is blanked */
+	transparent = ops->blank_state ? 0 : 
+		(vc->vc_splash.bg_color == bg_color);
+
+	xx = xx * vc->vc_font.width + vc->vc_splash.tx;
+	yy = yy * vc->vc_font.height + vc->vc_splash.ty;
+
+	fgx = cc2cx(fg_color);
+	bgx = cc2cx(bg_color);
+
+	while (count--) {
+		c = scr_readw(s++);
+		src = vc->vc_font.data + (c & charmask) * vc->vc_font.height *
+		      ((vc->vc_font.width + 7) >> 3);
+
+		fbsplash_renderc(info, yy, xx, vc->vc_font.height, 
+			       vc->vc_font.width, src, fgx, bgx, transparent);
+		xx += vc->vc_font.width;
+	}
+}
+
+void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	int i;
+	unsigned int dsize, s_pitch;
+	struct fbcon_ops *ops = info->fbcon_par;
+	struct vc_data* vc;	
+	u8 *src;
+
+	/* we really don't need any cursors while the console is blanked */
+	if (info->state != FBINFO_STATE_RUNNING || ops->blank_state)
+		return;
+
+	vc = vc_cons[ops->currcon].d;
+
+	src = kmalloc(64 + sizeof(struct fb_image), GFP_ATOMIC);
+	if (!src)
+		return;
+
+	s_pitch = (cursor->image.width + 7) >> 3;
+	dsize = s_pitch * cursor->image.height;
+	if (cursor->enable) {	
+		switch (cursor->rop) {
+		case ROP_XOR:
+			for (i = 0; i < dsize; i++)
+				src[i] = cursor->image.data[i] ^ cursor->mask[i];
+                        break;
+		case ROP_COPY:
+		default:
+			for (i = 0; i < dsize; i++)
+				src[i] = cursor->image.data[i] & cursor->mask[i];
+			break;
+		}
+	} else
+		memcpy(src, cursor->image.data, dsize);
+
+	fbsplash_renderc(info,
+			cursor->image.dy + vc->vc_splash.ty,
+			cursor->image.dx + vc->vc_splash.tx,
+			cursor->image.height,
+			cursor->image.width,
+			(u8*)src,
+			cc2cx(cursor->image.fg_color),
+			cc2cx(cursor->image.bg_color),
+			cursor->image.bg_color == vc->vc_splash.bg_color);
+
+	kfree(src);
+}
+
+static void splashset(u8 *dst, int height, int width, int dstbytes, 
+		        u32 bgx, int bpp)
+{
+	int i;
+	
+	if (bpp == 8)
+		bgx |= bgx << 8;
+	if (bpp == 16 || bpp == 8)
+		bgx |= bgx << 16;
+	
+	while (height-- > 0) {
+		u8 *p = dst;
+		
+		switch (bpp) {
+		
+		case 32:
+			for (i=0; i < width; i++) {
+				fb_writel(bgx, p); p += 4;
+			}
+			break;
+		case 24:	
+			for (i=0; i < width; i++) {
+#ifdef __LITTLE_ENDIAN
+				fb_writew((bgx & 0xffff),(u16*)p); p += 2;
+				fb_writeb((bgx >> 16),p++);
+#else
+				fb_writew((bgx >> 8),(u16*)p); p += 2;
+				fb_writeb((bgx & 0xff),p++);
+#endif
+			}
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(bgx,p); p += 4;
+				fb_writel(bgx,p); p += 4;
+			}
+			if (width & 2) {
+				fb_writel(bgx,p); p += 4;
+			}
+			if (width & 1)
+				fb_writew(bgx,(u16*)p);
+			break;
+		case 8:
+			for (i=0; i < width/4; i++) {
+				fb_writel(bgx,p); p += 4;
+			}
+			
+			if (width & 2) {
+				fb_writew(bgx,p); p += 2;
+			}
+			if (width & 1)
+				fb_writeb(bgx,(u8*)p);
+			break;
+
+		}		
+		dst += dstbytes;
+	}
+}
+
+void fbsplash_copy(u8 *dst, u8 *src, int height, int width, int linebytes, 
+		   int srclinebytes, int bpp)
+{
+	int i;
+
+	while (height-- > 0) {
+		u32 *p = (u32 *)dst;
+		u32 *q = (u32 *)src;
+
+		switch (bpp) {
+	
+		case 32:
+			for (i=0; i < width; i++)
+				fb_writel(*q++, p++);
+			break;	
+		case 24:	
+			for (i=0; i < (width*3/4); i++)
+				fb_writel(*q++, p++);
+			if ((width*3) % 4) {
+				if (width & 2) {
+					fb_writeb(*(u8*)q, (u8*)p);
+				} else if (width & 1) {
+					fb_writew(*(u16*)q, (u16*)p);
+					fb_writeb(*(u8*)((u16*)q+1),(u8*)((u16*)p+2));
+				}
+			}
+			break;
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(*q++, p++);
+				fb_writel(*q++, p++);
+			}
+			if (width & 2)
+				fb_writel(*q++, p++);
+			if (width & 1)
+				fb_writew(*(u16*)q, (u16*)p);
+			break;
+		case 8:
+			for (i=0; i < width/4; i++) 
+				fb_writel(*q++, p++);
+				
+			if (width & 2) {
+				fb_writew(*(u16*)q, (u16*)p); 
+				q = (u32*) ((u16*)q + 1);
+				p = (u32*) ((u16*)p + 1);
+			}
+			if (width & 1)
+				fb_writeb(*(u8*)q, (u8*)p);
+			break;
+		}
+
+		dst += linebytes;
+		src += srclinebytes;
+	}
+}
+
+static void splashfill(struct fb_info *info, int sy, int sx, int height, 
+		       int width) 
+{
+	int bytespp = ((info->var.bits_per_pixel + 7) >> 3);
+	int d  = sy * info->fix.line_length + sx * bytespp;
+	int ds = (sy * info->var.xres + sx) * bytespp;
+
+	fbsplash_copy((u8 *)(info->screen_base + d), (u8 *)(info->splash.data + ds),
+		    height, width, info->fix.line_length, info->var.xres * bytespp,
+		    info->var.bits_per_pixel);
+}
+
+void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx, 
+		    int height, int width)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int bg_color = attr_bgcol_ec(bgshift, vc);
+	int transparent = vc->vc_splash.bg_color == bg_color;
+	struct fbcon_ops *ops = info->fbcon_par;
+	u8 *dst;
+
+	sy = sy * vc->vc_font.height + vc->vc_splash.ty;
+	sx = sx * vc->vc_font.width + vc->vc_splash.tx;
+	height *= vc->vc_font.height;
+	width *= vc->vc_font.width;
+
+	/* Don't paint the background image if console is blanked */
+	if (transparent && !ops->blank_state) {
+		splashfill(info, sy, sx, height, width);
+	} else {
+		dst = (u8 *)(info->screen_base + sy * info->fix.line_length + 
+			     sx * ((info->var.bits_per_pixel + 7) >> 3));
+		splashset(dst, height, width, info->fix.line_length, cc2cx(bg_color), 
+			  info->var.bits_per_pixel);
+	}
+}
+
+void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info, 
+			    int bottom_only)
+{
+	unsigned int tw = vc->vc_cols*vc->vc_font.width;
+	unsigned int th = vc->vc_rows*vc->vc_font.height;
+
+	if (!bottom_only) {
+		/* top margin */
+		splashfill(info, 0, 0, vc->vc_splash.ty, info->var.xres);
+		/* left margin */
+		splashfill(info, vc->vc_splash.ty, 0, th, vc->vc_splash.tx);
+		/* right margin */
+		splashfill(info, vc->vc_splash.ty, vc->vc_splash.tx + tw, th, 
+			   info->var.xres - vc->vc_splash.tx - tw);
+	}
+	splashfill(info, vc->vc_splash.ty + th, 0, 
+		   info->var.yres - vc->vc_splash.ty - th, info->var.xres);
+}
+
+void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y, 
+			   int sx, int dx, int width)
+{
+	u16 *d = (u16 *) (vc->vc_origin + vc->vc_size_row * y + dx * 2);
+	u16 *s = d + (dx - sx);
+	u16 *start = d;
+	u16 *ls = d;
+	u16 *le = d + width;
+	u16 c;
+	int x = dx;
+	u16 attr = 1;
+
+	do {
+		c = scr_readw(d);
+		if (attr != (c & 0xff00)) {
+			attr = c & 0xff00;
+			if (d > start) {
+				fbsplash_putcs(vc, info, start, d - start, y, x);
+				x += d - start;
+				start = d;
+			}
+		}
+		if (s >= ls && s < le && c == scr_readw(s)) {
+			if (d > start) {
+				fbsplash_putcs(vc, info, start, d - start, y, x);
+				x += d - start + 1;
+				start = d + 1;
+			} else {
+				x++;
+				start++;
+			}
+		}
+		s++;
+		d++;
+	} while (d < le);
+	if (d > start)
+		fbsplash_putcs(vc, info, start, d - start, y, x);
+}
+
+void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank)
+{
+	if (blank) {
+		splashset((u8 *)info->screen_base, info->var.yres, info->var.xres,
+			  info->fix.line_length, 0, info->var.bits_per_pixel);
+	} else {
+		update_screen(vc);
+		fbsplash_clear_margins(vc, info, 0);
+	}
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/console/bitblit.c linux-2.6.23.1-stm/drivers/video/console/bitblit.c
--- linux-2.6.23.1/drivers/video/console/bitblit.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/console/bitblit.c	2007-11-01 12:00:41.000000000 +0000
@@ -17,6 +17,7 @@
 #include <linux/console.h>
 #include <asm/types.h>
 #include "fbcon.h"
+#include "../fbsplash.h"
 
 /*
  * Accelerated handlers.
@@ -54,6 +55,13 @@
 	area.height = height * vc->vc_font.height;
 	area.width = width * vc->vc_font.width;
 
+	if (fbsplash_active(info, vc)) {
+ 		area.sx += vc->vc_splash.tx;
+ 		area.sy += vc->vc_splash.ty;
+ 		area.dx += vc->vc_splash.tx;
+ 		area.dy += vc->vc_splash.ty;
+ 	}
+
 	info->fbops->fb_copyarea(info, &area);
 }
 
@@ -379,11 +387,15 @@
 	cursor.image.depth = 1;
 	cursor.rop = ROP_XOR;
 
-	if (info->fbops->fb_cursor)
-		err = info->fbops->fb_cursor(info, &cursor);
+	if (fbsplash_active(info, vc)) {
+		fbsplash_cursor(info, &cursor);
+	} else {
+		if (info->fbops->fb_cursor)
+			err = info->fbops->fb_cursor(info, &cursor);
 
-	if (err)
-		soft_cursor(info, &cursor);
+		if (err)
+			soft_cursor(info, &cursor);
+	}
 
 	ops->cursor_reset = 0;
 }
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/console/fbcon.c linux-2.6.23.1-stm/drivers/video/console/fbcon.c
--- linux-2.6.23.1/drivers/video/console/fbcon.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/console/fbcon.c	2007-11-01 12:00:41.000000000 +0000
@@ -91,6 +91,7 @@
 #endif
 
 #include "fbcon.h"
+#include "../fbsplash.h"
 
 #ifdef FBCONDEBUG
 #  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
@@ -106,7 +107,7 @@
 
 static struct display fb_display[MAX_NR_CONSOLES];
 
-static signed char con2fb_map[MAX_NR_CONSOLES];
+signed char con2fb_map[MAX_NR_CONSOLES];
 static signed char con2fb_map_boot[MAX_NR_CONSOLES];
 #ifndef MODULE
 static int logo_height;
@@ -316,7 +317,7 @@
 		vc->vc_mode != KD_TEXT || ops->graphics);
 }
 
-static inline int get_color(struct vc_data *vc, struct fb_info *info,
+inline int get_color(struct vc_data *vc, struct fb_info *info,
 	      u16 c, int is_fg)
 {
 	int depth = fb_get_color_depth(&info->var, &info->fix);
@@ -424,6 +425,7 @@
 		CM_ERASE : CM_DRAW;
 	ops->cursor(vc, info, mode, softback_lines, get_color(vc, info, c, 1),
 		    get_color(vc, info, c, 0));
+	
 	release_console_sem();
 }
 
@@ -594,6 +596,8 @@
 		info_idx = -1;
 	}
 
+	fbsplash_init();
+
 	return err;
 }
 
@@ -1035,6 +1039,12 @@
 	rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
 	cols /= vc->vc_font.width;
 	rows /= vc->vc_font.height;
+
+	if (fbsplash_active(info, vc)) {
+		cols = vc->vc_splash.twidth / vc->vc_font.width;
+		rows = vc->vc_splash.theight / vc->vc_font.height;
+	}
+
 	vc_resize(vc, cols, rows);
 
 	DPRINTK("mode:   %s\n", info->fix.id);
@@ -1118,7 +1128,7 @@
 	cap = info->flags;
 
 	if (vc != svc || logo_shown == FBCON_LOGO_DONTSHOW ||
-	    (info->fix.type == FB_TYPE_TEXT))
+	    (info->fix.type == FB_TYPE_TEXT) || fbsplash_active(info, vc))
 		logo = 0;
 
 	if (var_to_display(p, &info->var, info))
@@ -1317,6 +1327,11 @@
 	if (!height || !width)
 		return;
 
+ 	if (fbsplash_active(info, vc)) {
+ 		fbsplash_clear(vc, info, sy, sx, height, width);
+ 		return;
+ 	}
+ 	
 	/* Split blits that cross physical y_wrap boundary */
 
 	y_break = p->vrows - p->yscroll;
@@ -1336,10 +1351,15 @@
 	struct display *p = &fb_display[vc->vc_num];
 	struct fbcon_ops *ops = info->fbcon_par;
 
-	if (!fbcon_is_inactive(vc, info))
-		ops->putcs(vc, info, s, count, real_y(p, ypos), xpos,
-			   get_color(vc, info, scr_readw(s), 1),
-			   get_color(vc, info, scr_readw(s), 0));
+	if (!fbcon_is_inactive(vc, info)) {
+		
+		if (fbsplash_active(info, vc))
+			fbsplash_putcs(vc, info, s, count, ypos, xpos);
+		else
+			ops->putcs(vc, info, s, count, real_y(p, ypos), xpos,
+				   get_color(vc, info, scr_readw(s), 1),
+				   get_color(vc, info, scr_readw(s), 0));
+	}
 }
 
 static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
@@ -1355,8 +1375,13 @@
 	struct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];
 	struct fbcon_ops *ops = info->fbcon_par;
 
-	if (!fbcon_is_inactive(vc, info))
-		ops->clear_margins(vc, info, bottom_only);
+	if (!fbcon_is_inactive(vc, info)) {
+	 	if (fbsplash_active(info, vc)) {
+	 		fbsplash_clear_margins(vc, info, bottom_only);
+ 		} else {
+			ops->clear_margins(vc, info, bottom_only);
+		}
+	}
 }
 
 static void fbcon_cursor(struct vc_data *vc, int mode)
@@ -1876,7 +1901,7 @@
 			count = vc->vc_rows;
 		if (softback_top)
 			fbcon_softback_note(vc, t, count);
-		if (logo_shown >= 0)
+		if (logo_shown >= 0 || fbsplash_active(info, vc))
 			goto redraw_up;
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
@@ -1969,6 +1994,8 @@
 			count = vc->vc_rows;
 		if (logo_shown >= 0)
 			goto redraw_down;
+		if (fbsplash_active(info, vc))
+			goto redraw_down;
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			fbcon_redraw_blit(vc, info, p, b - 1, b - t - count,
@@ -2117,6 +2144,13 @@
 		}
 		return;
 	}
+
+	if (fbsplash_active(info, vc) && sy == dy && height == 1) {
+ 		/* must use slower redraw bmove to keep background pic intact */
+ 		fbsplash_bmove_redraw(vc, info, sy, sx, dx, width);
+ 		return;
+ 	}
+	
 	ops->bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,
 		   height, width);
 }
@@ -2187,8 +2221,9 @@
 	var.yres = virt_h * virt_fh;
 	x_diff = info->var.xres - var.xres;
 	y_diff = info->var.yres - var.yres;
-	if (x_diff < 0 || x_diff > virt_fw ||
-	    y_diff < 0 || y_diff > virt_fh) {
+
+	if ((x_diff < 0 || x_diff > virt_fw ||
+	    y_diff < 0 || y_diff > virt_fh) && !vc->vc_splash.state) {
 		const struct fb_videomode *mode;
 
 		DPRINTK("attempting resize %ix%i\n", var.xres, var.yres);
@@ -2224,6 +2259,25 @@
 
 	info = registered_fb[con2fb_map[vc->vc_num]];
 	ops = info->fbcon_par;
+	prev_console = ops->currcon;
+	if (prev_console != -1)
+		old_info = registered_fb[con2fb_map[prev_console]];
+
+	if (fbsplash_active_vc(vc)) {
+		struct vc_data *vc_curr = vc_cons[prev_console].d;
+		if (!vc_curr->vc_splash.theme || strcmp(vc->vc_splash.theme, vc_curr->vc_splash.theme)) {
+			if (fbsplash_call_helper("getpic", vc->vc_num))
+				fbsplash_disable(vc, 0);
+		}
+	} else if (info->fix.visual == FB_VISUAL_DIRECTCOLOR) { 
+		struct vc_data *vc_curr = vc_cons[prev_console].d;
+		if (vc_curr && fbsplash_active_vc(vc_curr)) {
+			/* Clear the screen to avoid displaying funky colors during
+			 * palette updates. */ 
+			memset((u8*)info->screen_base + info->fix.line_length * info->var.yoffset,
+			       0, info->var.yres * info->fix.line_length);
+		}
+	}
 
 	if (softback_top) {
 		if (softback_lines)
@@ -2242,9 +2296,6 @@
 		logo_shown = FBCON_LOGO_CANSHOW;
 	}
 
-	prev_console = ops->currcon;
-	if (prev_console != -1)
-		old_info = registered_fb[con2fb_map[prev_console]];
 	/*
 	 * FIXME: If we have multiple fbdev's loaded, we need to
 	 * update all info->currcon.  Perhaps, we can place this
@@ -2269,9 +2320,9 @@
 	 * in fb_set_var()
 	 */
 	info->var.activate = var.activate;
-	var.yoffset = info->var.yoffset;
-	var.xoffset = info->var.xoffset;
-	var.vmode = info->var.vmode;
+	var.yoffset = 0;
+	var.xoffset = 0;
+	var.vmode   = (info->var.vmode & ~FB_VMODE_MASK) | (var.vmode & FB_VMODE_MASK);
 	fb_set_var(info, &var);
 	ops->var = info->var;
 
@@ -2283,6 +2334,11 @@
 		if (old_info != info)
 			fbcon_del_cursor_timer(old_info);
 	}
+	
+	if (fbsplash_active_nores(info, vc) && !fbsplash_active(info, vc)) {
+		if (fbsplash_call_helper("modechange", vc->vc_num))
+			fbsplash_disable(vc, 0);
+	}
 
 	if (fbcon_is_inactive(vc, info) ||
 	    ops->blank_state != FB_BLANK_UNBLANK)
@@ -2398,8 +2454,12 @@
 			fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
 			ops->cursor_flash = (!blank);
 
-			if (fb_blank(info, blank))
-				fbcon_generic_blank(vc, info, blank);
+			if (fb_blank(info, blank)) {
+				if (fbsplash_active(info, vc))
+					fbsplash_blank(vc, info, blank);
+				else 
+					fbcon_generic_blank(vc, info, blank);
+			}
 		}
 
 		if (!blank)
@@ -2550,13 +2610,22 @@
 	}
 
 	if (resize) {
+		/* reset wrap/pan */
 		int cols, rows;
 
 		cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);
 		rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
+
+ 		info->var.xoffset = info->var.yoffset = p->yscroll = 0;
+		if (fbsplash_active(info, vc)) {
+			cols = vc->vc_splash.twidth;
+			rows = vc->vc_splash.theight;
+		}
 		cols /= w;
 		rows /= h;
+
 		vc_resize(vc, cols, rows);
+
 		if (CON_IS_VISIBLE(vc) && softback_buf)
 			fbcon_update_softback(vc);
 	} else if (CON_IS_VISIBLE(vc)
@@ -2685,7 +2754,7 @@
 	int i, j, k, depth;
 	u8 val;
 
-	if (fbcon_is_inactive(vc, info))
+	if (fbcon_is_inactive(vc, info) || vc->vc_num != fg_console)
 		return -EINVAL;
 
 	if (!CON_IS_VISIBLE(vc))
@@ -2711,7 +2780,49 @@
 	} else
 		fb_copy_cmap(fb_default_cmap(1 << depth), &palette_cmap);
 
-	return fb_set_cmap(&palette_cmap, info);
+	if (fbsplash_active(info, vc_cons[fg_console].d) &&
+	    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+
+		u16 *red, *green, *blue;
+		int minlen = min(min(info->var.red.length, info->var.green.length), 
+				     info->var.blue.length);
+		int h;
+
+		struct fb_cmap cmap = {
+			.start = 0,
+			.len = (1 << minlen),
+			.red = NULL,
+			.green = NULL,
+			.blue = NULL,
+			.transp = NULL
+		};
+
+		red = kmalloc(256 * sizeof(u16) * 3, GFP_KERNEL);
+	
+		if (!red)
+			goto out;		
+	
+		green = red + 256;
+		blue = green + 256;
+		cmap.red = red;
+		cmap.green = green;
+		cmap.blue = blue;
+		
+		for (i = 0; i < cmap.len; i++) {
+			red[i] = green[i] = blue[i] = (0xffff * i)/(cmap.len-1);
+		}
+
+		h = fb_set_cmap(&cmap, info);
+		fbsplash_fix_pseudo_pal(info, vc_cons[fg_console].d);
+		kfree(red);
+		
+		return h;
+		
+	} else if (fbsplash_active(info, vc_cons[fg_console].d) && 
+		   info->var.bits_per_pixel == 8 && info->splash.cmap.red != NULL) 
+		fb_set_cmap(&info->splash.cmap, info);
+		
+out:	return fb_set_cmap(&palette_cmap, info);
 }
 
 static u16 *fbcon_screen_pos(struct vc_data *vc, int offset)
@@ -2937,7 +3048,14 @@
 		rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
 		cols /= vc->vc_font.width;
 		rows /= vc->vc_font.height;
-		vc_resize(vc, cols, rows);
+				
+		if (!fbsplash_active_nores(info, vc)) {
+			vc_resize(vc, cols, rows);
+		} else {
+			if (fbsplash_call_helper("modechange", vc->vc_num))
+				fbsplash_disable(vc, 0);
+		}
+
 		updatescrollmode(p, info, vc);
 		scrollback_max = 0;
 		scrollback_current = 0;
@@ -3565,6 +3683,7 @@
 		}
 	}
 
+	fbsplash_exit();
 	fbcon_has_exited = 1;
 }
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/fbcmap.c linux-2.6.23.1-stm/drivers/video/fbcmap.c
--- linux-2.6.23.1/drivers/video/fbcmap.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/fbcmap.c	2007-11-01 12:00:41.000000000 +0000
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/fb.h>
 #include <linux/slab.h>
+#include "fbsplash.h"
 
 #include <asm/uaccess.h>
 
@@ -235,14 +236,17 @@
 			if (transp)
 				htransp = *transp++;
 			if (info->fbops->fb_setcolreg(start++,
-						      hred, hgreen, hblue,
+						      hred, hgreen, hblue, 
 						      htransp, info))
 				break;
 		}
 	}
-	if (rc == 0)
+	if (rc == 0) {
 		fb_copy_cmap(cmap, &info->cmap);
-
+		if (fbsplash_active(info, vc_cons[fg_console].d) &&
+		    info->fix.visual == FB_VISUAL_DIRECTCOLOR)
+			fbsplash_fix_pseudo_pal(info, vc_cons[fg_console].d);
+	}
 	return rc;
 }
 
@@ -250,7 +254,7 @@
 {
 	int rc, size = cmap->len * sizeof(u16);
 	struct fb_cmap umap;
-
+	
 	if (cmap->start < 0 || (!info->fbops->fb_setcolreg &&
 			        !info->fbops->fb_setcmap))
 		return -EINVAL;
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/fbmem.c linux-2.6.23.1-stm/drivers/video/fbmem.c
--- linux-2.6.23.1/drivers/video/fbmem.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/fbmem.c	2007-11-01 12:00:40.000000000 +0000
@@ -926,6 +926,8 @@
 
 		if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
 			struct fb_videomode mode;
+			struct fb_var_screeninfo oldvar = info->var;
+			int err = 0;
 
 			if (info->fbops->fb_get_caps) {
 				ret = fb_check_caps(info, var, activate);
@@ -936,8 +938,12 @@
 
 			info->var = *var;
 
-			if (info->fbops->fb_set_par)
-				info->fbops->fb_set_par(info);
+			if (info->fbops->fb_set_par) {
+				if((err = info->fbops->fb_set_par(info))) {
+					info->var = oldvar;
+					return err;
+				}
+			}
 
 			fb_pan_display(info, &info->var);
 			fb_set_cmap(&info->cmap, info);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/fbsplash.c linux-2.6.23.1-stm/drivers/video/fbsplash.c
--- linux-2.6.23.1/drivers/video/fbsplash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/fbsplash.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,424 @@
+/* 
+ *  linux/drivers/video/fbsplash.c -- Framebuffer splash routines
+ *
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ *  Code based upon "Bootsplash" (C) 2001-2003 
+ *       Volker Poplawski <volker@poplawski.de>,
+ *       Stefan Reinauer <stepan@suse.de>,
+ *       Steffen Winterfeldt <snwint@suse.de>,
+ *       Michael Schroeder <mls@suse.de>,
+ *       Ken Wimer <wimer@suse.de>.
+ *
+ *  Splash render routines are located in /linux/drivers/video/cfbsplash.c
+ * 
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ * 
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <linux/vmalloc.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/workqueue.h>
+#include <linux/kmod.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "console/fbcon.h"
+#include "fbsplash.h"
+
+#define SPLASH_VERSION 		"0.9.2"
+
+extern signed char con2fb_map[];
+static int fbsplash_enable(struct vc_data *vc);
+char fbsplash_path[KMOD_PATH_LEN] = "/sbin/splash_helper";
+static int initialized = 0;
+
+int fbsplash_call_helper(char* cmd, unsigned short vc)
+{
+	char *envp[] = {
+		"HOME=/",
+		"PATH=/sbin:/bin",
+		NULL
+	};
+
+	char tfb[5];
+	char tcons[5];
+	unsigned char fb = (int) con2fb_map[vc];
+
+	char *argv[] = {
+		fbsplash_path,
+		"2",
+		cmd,
+		tcons,
+		tfb,
+		vc_cons[vc].d->vc_splash.theme,
+		NULL
+	};
+
+	snprintf(tfb,5,"%d",fb);
+	snprintf(tcons,5,"%d",vc);
+
+	return call_usermodehelper(fbsplash_path, argv, envp, 1);
+}
+
+/* Disables fbsplash on a virtual console; called with console sem held. */
+int fbsplash_disable(struct vc_data *vc, unsigned char redraw)
+{
+	struct fb_info* info;
+
+	if (!vc->vc_splash.state)
+		return -EINVAL;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (info == NULL)
+		return -EINVAL;
+
+	vc->vc_splash.state = 0; 
+	vc_resize(vc, info->var.xres / vc->vc_font.width, 
+		  info->var.yres / vc->vc_font.height);
+
+	if (fg_console == vc->vc_num && redraw) {
+		redraw_screen(vc, 0);
+		update_region(vc, vc->vc_origin + 
+			      vc->vc_size_row * vc->vc_top, 
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+	}
+
+	printk(KERN_INFO "fbsplash: switched splash state to 'off' on console %d\n", 
+			 vc->vc_num);
+
+	return 0;
+}
+
+/* Enables fbsplash on a virtual console; called with console sem held. */
+static int fbsplash_enable(struct vc_data *vc)
+{
+	struct fb_info* info;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+		
+	if (vc->vc_splash.twidth == 0 || vc->vc_splash.theight == 0 || 
+	    info == NULL || vc->vc_splash.state || (!info->splash.data &&
+	    vc->vc_num == fg_console))
+		return -EINVAL;
+	
+	vc->vc_splash.state = 1;
+	vc_resize(vc, vc->vc_splash.twidth / vc->vc_font.width, 
+		  vc->vc_splash.theight / vc->vc_font.height);
+
+	if (fg_console == vc->vc_num) {
+		redraw_screen(vc, 0);
+		update_region(vc, vc->vc_origin + 
+			      vc->vc_size_row * vc->vc_top, 
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+		fbsplash_clear_margins(vc, info, 0);
+	}
+
+	printk(KERN_INFO "fbsplash: switched splash state to 'on' on console %d\n", 
+			 vc->vc_num);
+
+	return 0;
+}
+
+static inline int fbsplash_ioctl_dosetstate(struct vc_data *vc, unsigned int __user* state, unsigned char origin)
+{
+	int tmp, ret;
+
+	if (get_user(tmp, state))
+		return -EFAULT;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		acquire_console_sem();
+	if (!tmp)
+		ret = fbsplash_disable(vc, 1);
+	else
+		ret = fbsplash_enable(vc);
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	return ret;
+}
+
+static inline int fbsplash_ioctl_dogetstate(struct vc_data *vc, unsigned int __user *state)
+{
+	return put_user(vc->vc_splash.state, (unsigned int __user*) state);
+}
+
+static int fbsplash_ioctl_dosetcfg(struct vc_data *vc, struct vc_splash __user *arg, unsigned char origin)
+{
+	struct vc_splash cfg;
+	struct fb_info *info;
+	int len;
+	char *tmp;
+	
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (copy_from_user(&cfg, arg, sizeof(struct vc_splash)))
+		return -EFAULT;
+	if (info == NULL || !cfg.twidth || !cfg.theight || 
+	    cfg.tx + cfg.twidth  > info->var.xres ||
+	    cfg.ty + cfg.theight > info->var.yres)
+		return -EINVAL;
+
+	len = strlen_user(cfg.theme);
+	if (!len || len > FB_SPLASH_THEME_LEN)
+		return -EINVAL;
+	tmp = kmalloc(len, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	if (copy_from_user(tmp, (void __user *)cfg.theme, len))
+		return -EFAULT;
+	cfg.theme = tmp;
+	cfg.state = 0;
+
+	/* If this ioctl is a response to a request from kernel, the console sem
+	 * is already held; we also don't need to disable splash because either the
+	 * new config and background picture will be successfully loaded, and the 
+	 * splash will stay on, or in case of a failure it'll be turned off in fbcon. */
+	if (origin == FB_SPLASH_IO_ORIG_USER) {
+		acquire_console_sem();
+		if (vc->vc_splash.state)
+			fbsplash_disable(vc, 1);
+	}
+
+	if (vc->vc_splash.theme)
+		kfree(vc->vc_splash.theme);
+
+	vc->vc_splash = cfg;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	printk(KERN_INFO "fbsplash: console %d using theme '%s'\n", 
+			 vc->vc_num, vc->vc_splash.theme);
+	return 0;	
+}
+
+static int fbsplash_ioctl_dogetcfg(struct vc_data *vc, struct vc_splash __user *arg)
+{
+	struct vc_splash splash;
+	char __user *tmp;
+
+	if (get_user(tmp, &arg->theme))
+		return -EFAULT;
+	
+	splash = vc->vc_splash;
+	splash.theme = tmp;
+
+	if (vc->vc_splash.theme) {
+		if (copy_to_user(tmp, vc->vc_splash.theme, strlen(vc->vc_splash.theme) + 1))
+			return -EFAULT;
+	} else
+		if (put_user(0, tmp))
+			return -EFAULT;
+
+	if (copy_to_user(arg, &splash, sizeof(struct vc_splash)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int fbsplash_ioctl_dosetpic(struct vc_data *vc, struct fb_image __user *arg, unsigned char origin)
+{
+	struct fb_image img;
+	struct fb_info *info;
+	int len;
+	u8 *tmp;
+	
+	if (vc->vc_num != fg_console) 
+		return -EINVAL;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	
+	if (info == NULL)
+		return -EINVAL;
+	
+	if (copy_from_user(&img, arg, sizeof(struct fb_image)))
+		return -EFAULT;
+	
+	if (img.width != info->var.xres || img.height != info->var.yres) {
+		printk(KERN_ERR "fbsplash: picture dimensions mismatch\n");
+		return -EINVAL;
+	}
+
+	if (img.depth != info->var.bits_per_pixel) {
+		printk(KERN_ERR "fbsplash: picture depth mismatch\n");
+		return -EINVAL;
+	}
+		
+	if (img.depth == 8) {
+		if (!img.cmap.len || !img.cmap.red || !img.cmap.green || 
+		    !img.cmap.blue)
+			return -EINVAL;
+		
+		tmp = vmalloc(img.cmap.len * 3 * 2);
+		if (!tmp)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, (void __user*)img.cmap.red, img.cmap.len * 2) ||
+		    copy_from_user(tmp + (img.cmap.len << 1),
+			    	   (void __user*)img.cmap.green, (img.cmap.len << 1)) ||
+		    copy_from_user(tmp + (img.cmap.len << 2),
+			    	   (void __user*)img.cmap.blue, (img.cmap.len << 1))) {
+			vfree(tmp);
+			return -EFAULT;
+		}
+			
+		img.cmap.transp = NULL;
+		img.cmap.red = (u16*)tmp;
+		img.cmap.green = img.cmap.red + img.cmap.len;
+		img.cmap.blue = img.cmap.green + img.cmap.len;
+	} else {
+		img.cmap.red = NULL;
+	}
+		
+	len = ((img.depth + 7) >> 3) * img.width * img.height;
+	tmp = vmalloc(len);
+
+	if (!tmp)
+		goto out;
+
+	if (copy_from_user(tmp, (void __user*)img.data, len))
+		goto out;
+		
+	img.data = tmp;
+
+	/* If this ioctl is a response to a request from kernel, the console sem
+	 * is already held. */
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		acquire_console_sem();
+	
+	if (info->splash.data)
+		vfree((u8*)info->splash.data);
+	if (info->splash.cmap.red)
+		vfree(info->splash.cmap.red);
+	
+	info->splash = img;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	return 0;
+
+out:	if (img.cmap.red)
+		vfree(img.cmap.red);
+	if (tmp)
+		vfree(tmp);
+	return -ENOMEM;
+}
+
+static int splash_ioctl(struct inode * inode, struct file *filp, u_int cmd, 
+			u_long arg)
+{
+	struct fb_splash_iowrapper __user *wrapper = (void __user*) arg;
+	struct vc_data *vc = NULL;
+	unsigned short vc_num = 0;
+	unsigned char origin = 0;
+	void __user *data = NULL;
+	
+	if (!access_ok(VERIFY_READ, wrapper, 
+			sizeof(struct fb_splash_iowrapper)))
+		return -EFAULT;
+	
+	__get_user(vc_num, &wrapper->vc);
+	__get_user(origin, &wrapper->origin);
+	__get_user(data, &wrapper->data);
+		
+	if (!vc_cons_allocated(vc_num))
+		return -EINVAL;
+
+	vc = vc_cons[vc_num].d;
+	
+	switch (cmd) {
+	case FBIOSPLASH_SETPIC:
+		return fbsplash_ioctl_dosetpic(vc, (struct fb_image __user*)data, origin);
+	case FBIOSPLASH_SETCFG:
+		return fbsplash_ioctl_dosetcfg(vc, (struct vc_splash*)data, origin);
+	case FBIOSPLASH_GETCFG:
+		return fbsplash_ioctl_dogetcfg(vc, (struct vc_splash*)data);
+	case FBIOSPLASH_SETSTATE:
+		return fbsplash_ioctl_dosetstate(vc, (unsigned int *)data, origin);
+	case FBIOSPLASH_GETSTATE:
+		return fbsplash_ioctl_dogetstate(vc, (unsigned int *)data);
+	default:
+		return -ENOIOCTLCMD;
+	}	
+}
+
+static struct file_operations splash_ops = {
+	.owner = THIS_MODULE,
+	.ioctl = splash_ioctl
+};
+
+static struct miscdevice splash_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "fbsplash",
+	.fops = &splash_ops
+};
+
+void fbsplash_reset(void)
+{
+	struct fb_info *info;
+	struct vc_data *vc;
+	int i;
+
+	vc = vc_cons[0].d;
+	info = registered_fb[0];
+
+	for (i = 0; i < num_registered_fb; i++) {
+		registered_fb[i]->splash.data = NULL;
+		registered_fb[i]->splash.cmap.red = NULL;
+	}
+
+	for (i = 0; i < MAX_NR_CONSOLES && vc_cons[i].d; i++) {
+		vc_cons[i].d->vc_splash.state = vc_cons[i].d->vc_splash.twidth = 
+						vc_cons[i].d->vc_splash.theight = 0;
+		vc_cons[i].d->vc_splash.theme = NULL;
+	}
+
+	return;
+}
+
+int fbsplash_init(void)
+{
+	int i;
+
+	fbsplash_reset();
+
+	if (initialized)
+		return 0;
+
+	i = misc_register(&splash_dev);
+	if (i) {
+		printk(KERN_ERR "fbsplash: failed to register device\n");
+		return i;
+	}
+
+	fbsplash_call_helper("init", 0);
+	initialized = 1;
+	return 0;
+}
+
+int fbsplash_exit(void)
+{
+	fbsplash_reset();
+	return 0;
+}
+
+EXPORT_SYMBOL(fbsplash_path);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/drivers/video/fbsplash.h linux-2.6.23.1-stm/drivers/video/fbsplash.h
--- linux-2.6.23.1/drivers/video/fbsplash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/drivers/video/fbsplash.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,78 @@
+/* 
+ *  linux/drivers/video/fbsplash.h -- Framebuffer splash headers
+ *
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ */
+
+#ifndef __FB_SPLASH_H
+#define __FB_SPLASH_H
+
+#ifndef _LINUX_FB_H
+#include <linux/fb.h>
+#endif
+
+/* This is needed for vc_cons in fbcmap.c */
+#include <linux/vt_kern.h>
+
+struct fb_cursor;
+struct fb_info;
+struct vc_data;
+
+#ifdef CONFIG_FB_SPLASH
+/* fbsplash.c */
+int fbsplash_init(void);
+int fbsplash_exit(void);
+int fbsplash_call_helper(char* cmd, unsigned short cons);
+int fbsplash_disable(struct vc_data *vc, unsigned char redraw);
+
+/* cfbsplash.c */
+void fbsplash_putcs(struct vc_data *vc, struct fb_info *info, const unsigned short *s, int count, int yy, int xx);
+void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor);
+void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx, int height, int width);
+void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info, int bottom_only);
+void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank);
+void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width);
+void fbsplash_copy(u8 *dst, u8 *src, int height, int width, int linebytes, int srclinesbytes, int bpp);
+void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc);
+
+/* vt.c */
+void acquire_console_sem(void);
+void release_console_sem(void);
+void do_unblank_screen(int entering_gfx);
+
+/* struct vc_data *y */
+#define fbsplash_active_vc(y) (y->vc_splash.state && y->vc_splash.theme) 
+
+/* struct fb_info *x, struct vc_data *y */
+#define fbsplash_active_nores(x,y) (x->splash.data && fbsplash_active_vc(y))
+
+/* struct fb_info *x, struct vc_data *y */
+#define fbsplash_active(x,y) (fbsplash_active_nores(x,y) &&		\
+			      x->splash.width == x->var.xres && 	\
+			      x->splash.height == x->var.yres &&	\
+			      x->splash.depth == x->var.bits_per_pixel)
+
+
+#else /* CONFIG_FB_SPLASH */
+
+static inline void fbsplash_putcs(struct vc_data *vc, struct fb_info *info, const unsigned short *s, int count, int yy, int xx) {}
+static inline void fbsplash_putc(struct vc_data *vc, struct fb_info *info, int c, int ypos, int xpos) {}
+static inline void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor) {}
+static inline void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx, int height, int width) {}
+static inline void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info, int bottom_only) {}
+static inline void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank) {}
+static inline void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width) {}
+static inline void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc) {}
+static inline int fbsplash_call_helper(char* cmd, unsigned short cons) { return 0; }
+static inline int fbsplash_init(void) { return 0; }
+static inline int fbsplash_exit(void) { return 0; }
+static inline int fbsplash_disable(struct vc_data *vc, unsigned char redraw) { return 0; }
+
+#define fbsplash_active_vc(y) (0)
+#define fbsplash_active_nores(x,y) (0)
+#define fbsplash_active(x,y) (0)
+
+#endif /* CONFIG_FB_SPLASH */
+
+#endif /* __FB_SPLASH_H */
diff -x .gitignore -Nurp linux-2.6.23/fs/Kconfig linux-2.6.23-squashfs3.3/fs/Kconfig
--- linux-2.6.23/fs/Kconfig	2007-10-09 21:31:38.000000000 +0100
+++ linux-2.6.23-squashfs3.3/fs/Kconfig	2007-11-01 05:06:25.000000000 +0000
@@ -1364,6 +1364,56 @@ config CRAMFS
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 3.3 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFS 3.3 (a Compressed
+	  Read-Only File System).  Squashfs is a highly compressed read-only
+	  filesystem for Linux.  It uses zlib compression to compress both
+	  files, inodes and directories.  Inodes in the system are very small
+	  and all blocks are packed to minimise data overhead. Block sizes
+	  greater than 4K are supported up to a maximum of 1 Mbytes (default
+	  block size 128K).  SquashFS 3.3 supports 64 bit filesystems and files
+	  (larger than 4GB), full uid/gid information, hard links and timestamps.  
+
+	  Squashfs is intended for general read-only filesystem use, for
+	  archival use (i.e. in cases where a .tar.gz file may be used), and in
+	  embedded systems where low overhead is needed.  Further information
+	  and filesystem tools are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
+config SQUASHFS_EMBEDDED
+
+	bool "Additional option for memory-constrained systems" 
+	depends on SQUASHFS
+	default n
+	help
+	  Saying Y here allows you to specify cache size.
+
+	  If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+	int "Number of fragments cached" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default "3"
+	help
+	  By default SquashFS caches the last 3 fragments read from
+	  the filesystem.  Increasing this amount may mean SquashFS
+	  has to re-read fragments less often from disk, at the expense
+	  of extra system memory.  Decreasing this amount will mean
+	  SquashFS uses less memory at the expense of extra reads from disk.
+
+	  Note there must be at least one cached fragment.  Anything
+	  much more than three will probably not make much difference.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	depends on BLOCK
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/fs/Makefile linux-2.6.23.1-stm/fs/Makefile
--- linux-2.6.23.1/fs/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/fs/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -72,6 +72,7 @@
 obj-$(CONFIG_JBD2)		+= jbd2/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
diff -x .gitignore -Nurp linux-2.6.23/fs/squashfs/inode.c linux-2.6.23-squashfs3.3/fs/squashfs/inode.c
--- linux-2.6.23/fs/squashfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/fs/squashfs/inode.c	2007-11-01 03:09:05.000000000 +0000
@@ -0,0 +1,2192 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+#include <linux/exportfs.h>
+
+#include "squashfs.h"
+
+int squashfs_cached_blks;
+
+static void vfs_read_inode(struct inode *i);
+static struct dentry *squashfs_get_parent(struct dentry *child);
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode);
+static int squashfs_statfs(struct dentry *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static int squashfs_remount(struct super_block *s, int *flags, char *data);
+static void squashfs_put_super(struct super_block *);
+static int squashfs_get_sb(struct file_system_type *,int, const char *, void *,
+				struct vfsmount *);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+};
+
+static const unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.remount_fs = squashfs_remount
+};
+
+static struct super_operations squashfs_export_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.read_inode = vfs_read_inode
+};
+
+static struct export_operations squashfs_export_ops = {
+	.get_parent = squashfs_get_parent
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+static const struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static struct buffer_head *get_block_length(struct super_block *s,
+				int *cur_index, int *offset, int *c_byte)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if (!(bh = sb_bread(s, *cur_index)))
+		goto out;
+
+	if (msblk->devblksize - *offset == 1) {
+		if (msblk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+		brelse(bh);
+		if (!(bh = sb_bread(s, ++(*cur_index))))
+			goto out;
+		if (msblk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				bh->b_data); 
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				bh->b_data); 
+		*c_byte = temp;
+		*offset = 1;
+	} else {
+		if (msblk->swap) {
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		} else {
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		}
+		*c_byte = temp;
+		*offset += 2;
+	}
+
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (*offset == msblk->devblksize) {
+			brelse(bh);
+			if (!(bh = sb_bread(s, ++(*cur_index))))
+				goto out;
+			*offset = 0;
+		}
+		if (*((unsigned char *) (bh->b_data + *offset)) !=
+						SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n",
+						*cur_index);
+			brelse(bh);
+			goto out;
+		}
+		(*offset)++;
+	}
+	return bh;
+
+out:
+	return NULL;
+}
+
+
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index, int srclength)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	struct buffer_head **bh;
+	unsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k = 0;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	bh = kmalloc(((sblk->block_size >> msblk->devblksize_log2) + 1) *
+								sizeof(struct buffer_head *), GFP_KERNEL);
+	if (bh == NULL)
+		goto read_failure;
+
+	if (c_byte) {
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d, src size %d\n", index,
+					compressed ? "" : "un", (unsigned int) c_byte, srclength);
+
+		if (c_byte > srclength || index < 0 || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		bh[0] = sb_getblk(s, cur_index);
+		if (bh[0] == NULL)
+			goto block_release;
+
+		for (b = 1; bytes < c_byte; b++) {
+			bh[b] = sb_getblk(s, ++cur_index);
+			if (bh[b] == NULL)
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if (index < 0 || (index + 2) > sblk->bytes_used)
+			goto read_failure;
+
+		bh[0] = get_block_length(s, &cur_index, &offset, &c_byte);
+		if (bh[0] == NULL)
+			goto read_failure;
+
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		if (c_byte > srclength || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		for (b = 1; bytes < c_byte; b++) {
+			bh[b] = sb_getblk(s, ++cur_index);
+			if (bh[b] == NULL)
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if (compressed) {
+		int zlib_err = 0;
+
+		/*
+	 	* uncompress block
+	 	*/
+
+		mutex_lock(&msblk->read_data_mutex);
+
+		msblk->stream.next_out = buffer;
+		msblk->stream.avail_out = srclength;
+
+		for (bytes = 0; k < b; k++) {
+			avail_bytes = min(c_byte - bytes, msblk->devblksize - offset);
+
+			wait_on_buffer(bh[k]);
+			if (!buffer_uptodate(bh[k]))
+				goto release_mutex;
+
+			msblk->stream.next_in = bh[k]->b_data + offset;
+			msblk->stream.avail_in = avail_bytes;
+
+			if (k == 0) {
+				zlib_err = zlib_inflateInit(&msblk->stream);
+				if (zlib_err != Z_OK) {
+					ERROR("zlib_inflateInit returned unexpected result 0x%x,"
+						" srclength %d\n", zlib_err, srclength);
+					goto release_mutex;
+				}
+
+				if (avail_bytes == 0) {
+					offset = 0;
+					brelse(bh[k]);
+					continue;
+				}
+			}
+
+			zlib_err = zlib_inflate(&msblk->stream, Z_NO_FLUSH);
+			if (zlib_err != Z_OK && zlib_err != Z_STREAM_END) {
+				ERROR("zlib_inflate returned unexpected result 0x%x,"
+					" srclength %d, avail_in %d, avail_out %d\n", zlib_err,
+					srclength, msblk->stream.avail_in, msblk->stream.avail_out);
+				goto release_mutex;
+			}
+
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+		}
+
+		if (zlib_err != Z_STREAM_END)
+			goto release_mutex;
+
+		zlib_err = zlib_inflateEnd(&msblk->stream);
+		if (zlib_err != Z_OK) {
+			ERROR("zlib_inflateEnd returned unexpected result 0x%x,"
+				" srclength %d\n", zlib_err, srclength);
+			goto release_mutex;
+		}
+		bytes = msblk->stream.total_out;
+		mutex_unlock(&msblk->read_data_mutex);
+	} else {
+		int i;
+
+		for(i = 0; i < b; i++) {
+			wait_on_buffer(bh[i]);
+			if (!buffer_uptodate(bh[i]))
+				goto block_release;
+		}
+
+		for (bytes = 0; k < b; k++) {
+			avail_bytes = min(c_byte - bytes, msblk->devblksize - offset);
+
+			memcpy(buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+		}
+	}
+
+	if (next_index)
+		*next_index = index + c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags) ? 3 : 2));
+
+	kfree(bh);
+	return bytes;
+
+release_mutex:
+	mutex_unlock(&msblk->read_data_mutex);
+
+block_release:
+	for (; k < b; k++)
+		brelse(bh[k]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	kfree(bh);
+	return 0;
+}
+
+
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	long long next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
+
+	while (1) {
+		for (i = 0; i < squashfs_cached_blks; i++) 
+			if (msblk->block_cache[i].block == block)
+				break; 
+		
+		mutex_lock(&msblk->block_cache_mutex);
+
+		if (i == squashfs_cached_blks) {
+			/* read inode header block */
+			if (msblk->unused_cache_blks == 0) {
+				mutex_unlock(&msblk->block_cache_mutex);
+				wait_event(msblk->waitq, msblk->unused_cache_blks);
+				continue;
+			}
+
+			i = msblk->next_cache;
+			for (n = 0; n < squashfs_cached_blks; n++) {
+				if (msblk->block_cache[i].block != SQUASHFS_USED_BLK)
+					break;
+				i = (i + 1) % squashfs_cached_blks;
+			}
+
+			msblk->next_cache = (i + 1) % squashfs_cached_blks;
+
+			if (msblk->block_cache[i].block == SQUASHFS_INVALID_BLK) {
+				msblk->block_cache[i].data = vmalloc(SQUASHFS_METADATA_SIZE);
+				if (msblk->block_cache[i].data == NULL) {
+					ERROR("Failed to allocate cache block\n");
+					mutex_unlock(&msblk->block_cache_mutex);
+					goto out;
+				}
+			}
+	
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			msblk->unused_cache_blks --;
+			mutex_unlock(&msblk->block_cache_mutex);
+
+			msblk->block_cache[i].length = squashfs_read_data(s,
+				msblk->block_cache[i].data, block, 0, &next_index,
+				SQUASHFS_METADATA_SIZE);
+
+			if (msblk->block_cache[i].length == 0) {
+				ERROR("Unable to read cache block [%llx:%x]\n", block, offset);
+				mutex_lock(&msblk->block_cache_mutex);
+				msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+				msblk->unused_cache_blks ++;
+				smp_mb();
+				vfree(msblk->block_cache[i].data);
+				wake_up(&msblk->waitq);
+				mutex_unlock(&msblk->block_cache_mutex);
+				goto out;
+			}
+
+			mutex_lock(&msblk->block_cache_mutex);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			msblk->unused_cache_blks ++;
+			smp_mb();
+			wake_up(&msblk->waitq);
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
+		}
+
+		if (msblk->block_cache[i].block != block) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			continue;
+		}
+
+		bytes = msblk->block_cache[i].length - offset;
+
+		if (bytes < 1) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto out;
+		} else if (bytes >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data + offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto finish;
+		} else {
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data + offset, bytes);
+				buffer = (char *) buffer + bytes;
+			}
+			block = msblk->block_cache[i].next_index;
+			mutex_unlock(&msblk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+
+finish:
+	return return_length;
+out:
+	return 0;
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	struct squashfs_fragment_entry fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, &sfragment_entry, start_block, offset,
+					 sizeof(sfragment_entry), &start_block, &offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, &fragment_entry, start_block, offset,
+					 sizeof(fragment_entry), &start_block, &offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk,
+				struct squashfs_fragment_cache *fragment)
+{
+	mutex_lock(&msblk->fragment_mutex);
+	fragment->locked --;
+	if (fragment->locked == 0) {
+		msblk->unused_frag_blks ++;
+		smp_mb();
+		wake_up(&msblk->fragment_wait_queue);
+	}
+	mutex_unlock(&msblk->fragment_mutex);
+}
+
+
+SQSH_EXTERN
+struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s,
+				long long start_block, int length)
+{
+	int i, n;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	while (1) {
+		mutex_lock(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
+
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			if (msblk->unused_frag_blks == 0) {
+				mutex_unlock(&msblk->fragment_mutex);
+				wait_event(msblk->fragment_wait_queue, msblk->unused_frag_blks);
+				continue;
+			}
+
+			i = msblk->next_fragment;
+			for (n = 0; n < SQUASHFS_CACHED_FRAGMENTS; n++) {
+				if (msblk->fragment[i].locked == 0)
+					break;
+				i = (i + 1) % SQUASHFS_CACHED_FRAGMENTS;
+			}
+
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+			
+			if (msblk->fragment[i].data == NULL) {
+				msblk->fragment[i].data = vmalloc(sblk->block_size);
+				if (msblk->fragment[i].data == NULL) {
+					ERROR("Failed to allocate fragment cache block\n");
+					mutex_unlock(&msblk->fragment_mutex);
+					goto out;
+				}
+			}
+
+			msblk->unused_frag_blks --;
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			mutex_unlock(&msblk->fragment_mutex);
+
+			msblk->fragment[i].length = squashfs_read_data(s,
+				msblk->fragment[i].data, start_block, length, NULL,
+				sblk->block_size);
+
+			if (msblk->fragment[i].length == 0) {
+				ERROR("Unable to read fragment cache block [%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				msblk->unused_frag_blks ++;
+				smp_mb();
+				wake_up(&msblk->fragment_wait_queue);
+				goto out;
+			}
+
+			mutex_lock(&msblk->fragment_mutex);
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+				i, msblk->fragment[i].block, msblk->fragment[i].locked);
+			mutex_unlock(&msblk->fragment_mutex);
+			break;
+		}
+
+		if (msblk->fragment[i].locked == 0)
+			msblk->unused_frag_blks --;
+		msblk->fragment[i].locked++;
+		mutex_unlock(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+			msblk->fragment[i].block, msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+				struct squashfs_base_inode_header *inodeb)
+{
+	i->i_ino = inodeb->inode_number;
+	i->i_mtime.tv_sec = inodeb->mtime;
+	i->i_atime.tv_sec = inodeb->mtime;
+	i->i_ctime.tv_sec = inodeb->mtime;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_size = 0;
+
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static squashfs_inode_t squashfs_inode_lookup(struct super_block *s, int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start = msblk->inode_lookup_table[SQUASHFS_LOOKUP_BLOCK(ino - 1)];
+	int offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino - 1);
+	squashfs_inode_t inode;
+
+	TRACE("Entered squashfs_inode_lookup, inode_number = %d\n", ino);
+
+	if (msblk->swap) {
+		squashfs_inode_t sinode;
+
+		if (!squashfs_get_cached_block(s, &sinode, start, offset,
+					sizeof(sinode), &start, &offset))
+			goto out;
+		SQUASHFS_SWAP_INODE_T((&inode), &sinode);
+	} else if (!squashfs_get_cached_block(s, &inode, start, offset,
+					sizeof(inode), &start, &offset))
+			goto out;
+
+	TRACE("squashfs_inode_lookup, inode = 0x%llx\n", inode);
+
+	return inode;
+
+out:
+	return SQUASHFS_INVALID_BLK;
+}
+	
+
+static void vfs_read_inode(struct inode *i)
+{
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	squashfs_inode_t inode = squashfs_inode_lookup(i->i_sb, i->i_ino);
+
+	TRACE("Entered vfs_read_inode\n");
+
+	if(inode != SQUASHFS_INVALID_BLK)
+		(msblk->read_inode)(i, inode);
+}
+
+
+static struct dentry *squashfs_get_parent(struct dentry *child)
+{
+	struct inode *i = child->d_inode;
+	struct inode *parent = iget(i->i_sb, SQUASHFS_I(i)->u.s2.parent_inode);
+	struct dentry *rv;
+
+	TRACE("Entered squashfs_get_parent\n");
+
+	if(parent == NULL) {
+		rv = ERR_PTR(-EACCES);
+		goto out;
+	}
+
+	rv = d_alloc_anon(parent);
+	if(rv == NULL)
+		rv = ERR_PTR(-ENOMEM);
+
+out:
+	return rv;
+}
+
+	
+SQSH_EXTERN struct inode *squashfs_iget(struct super_block *s,
+				squashfs_inode_t inode, unsigned int inode_number)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = iget_locked(s, inode_number);
+
+	TRACE("Entered squashfs_iget\n");
+
+	if(i && (i->i_state & I_NEW)) {
+		(msblk->read_inode)(i, inode);
+		unlock_new_inode(i);
+	}
+
+	return i;
+}
+
+
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) + sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base, *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, sinodeb, block, offset,
+					sizeof(*sinodeb), &next_block, &next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb, sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, inodeb, block, offset,
+					sizeof(*inodeb), &next_block, &next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+					if(!get_fragment_location(s, inodep->fragment, &frag_blk,
+												&frag_size))
+						goto failed_read;
+				
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+				if (!get_fragment_location(s, inodep->fragment, &frag_blk,
+												 &frag_size))
+					goto failed_read;
+				
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset = next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inodep = &id.symlink;
+			struct squashfs_symlink_inode_header *sinodep = &sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_CHRDEV_TYPE) ?
+					S_IFCHR : S_IFBLK;
+			init_special_inode(i, i->i_mode, old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset, inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	make_bad_inode(i);
+	return 0;
+}
+
+
+static int read_inode_lookup_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(sblk->inodes);
+
+	TRACE("In read_inode_lookup_table, length %d\n", length);
+
+	/* Allocate inode lookup table */
+	msblk->inode_lookup_table = kmalloc(length, GFP_KERNEL);
+	if (msblk->inode_lookup_table == NULL) {
+		ERROR("Failed to allocate inode lookup table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->inode_lookup_table,
+			sblk->lookup_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read inode lookup table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long block;
+
+		for (i = 0; i < SQUASHFS_LOOKUP_BLOCKS(sblk->inodes); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_LOOKUP_BLOCKS((&block),
+						&msblk->inode_lookup_table[i], 1);
+			msblk->inode_lookup_table[i] = block;
+		}
+	}
+
+	return 1;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments);
+
+	if(length == 0)
+		return 1;
+
+	/* Allocate fragment index table */
+	msblk->fragment_index = kmalloc(length, GFP_KERNEL);
+	if (msblk->fragment_index == NULL) {
+		ERROR("Failed to allocate fragment index table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->fragment_index,
+			sblk->fragment_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int readahead_metadata(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int i;
+
+	squashfs_cached_blks = SQUASHFS_CACHED_BLKS;
+
+	/* Init inode_table block pointer array */
+	msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					squashfs_cached_blks, GFP_KERNEL);
+	if (msblk->block_cache == NULL) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed;
+	}
+
+	for (i = 0; i < squashfs_cached_blks; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+	msblk->unused_cache_blks = squashfs_cached_blks;
+
+	return 1;
+
+failed:
+	return 0;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >
+			SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
+	int i;
+	char b[BDEVNAME_SIZE];
+	struct inode *root;
+
+	TRACE("Entered squashfs_fill_superblock\n");
+
+	s->s_fs_info = kzalloc(sizeof(struct squashfs_sb_info), GFP_KERNEL);
+	if (s->s_fs_info == NULL) {
+		ERROR("Failed to allocate superblock\n");
+		goto failure;
+	}
+	msblk = s->s_fs_info;
+
+	msblk->stream.workspace = vmalloc(zlib_inflate_workspacesize());
+	if (msblk->stream.workspace == NULL) {
+		ERROR("Failed to allocate zlib workspace\n");
+		goto failure;
+	}
+	sblk = &msblk->sblk;
+	
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	mutex_init(&msblk->read_data_mutex);
+	mutex_init(&msblk->read_page_mutex);
+	mutex_init(&msblk->block_cache_mutex);
+	mutex_init(&msblk->fragment_mutex);
+	mutex_init(&msblk->meta_index_mutex);
+	
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	/* sblk->bytes_used is checked in squashfs_read_data to ensure reads are not
+ 	 * beyond filesystem end.  As we're using squashfs_read_data to read sblk here,
+ 	 * first set sblk->bytes_used to a useful value */
+	sblk->bytes_used = sizeof(struct squashfs_super_block);
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, sizeof(struct squashfs_super_block))) {
+		SERROR("unable to read superblock\n");
+		goto failed_mount;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	if ((s->s_magic = sblk->s_magic) != SQUASHFS_MAGIC) {
+		if (sblk->s_magic == SQUASHFS_MAGIC_SWAP) {
+			struct squashfs_super_block ssblk;
+
+			WARNING("Mounting a different endian SQUASHFS filesystem on %s\n",
+				bdevname(s->s_bdev, b));
+
+			SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+			memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+			msblk->swap = 1;
+		} else  {
+			SERROR("Can't find a SQUASHFS superblock on %s\n",
+							bdevname(s->s_bdev, b));
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(!supported_squashfs_filesystem(msblk, silent))
+		goto failed_mount;
+
+	/* Check the filesystem does not extend beyond the end of the
+	   block device */
+	if(sblk->bytes_used < 0 || sblk->bytes_used > i_size_read(s->s_bdev->bd_inode))
+		goto failed_mount;
+
+	/* Check the root inode for sanity */
+	if (SQUASHFS_INODE_OFFSET(sblk->root_inode) > SQUASHFS_METADATA_SIZE)
+		goto failed_mount;
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sblk->flags)
+					? "un" : "");
+	TRACE("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %spresent in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?  "" : "not ");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n", sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	s->s_maxbytes = MAX_LFS_FILESIZE;
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_super_ops;
+
+	if (readahead_metadata(s) == 0)
+		goto failed_mount;
+
+	/* Allocate read_page block */
+	msblk->read_page = vmalloc(sblk->block_size);
+	if (msblk->read_page == NULL) {
+		ERROR("Failed to allocate read_page block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate uid and gid tables */
+	msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL);
+	if (msblk->uid == NULL) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount;
+	}
+	msblk->guid = msblk->uid + sblk->no_uids;
+   
+	if (msblk->swap) {
+		unsigned int suid[sblk->no_uids + sblk->no_guids];
+
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
+	} else
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
+		goto allocate_root;
+
+	msblk->fragment = kzalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL);
+	if (msblk->fragment == NULL) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+	}
+
+	msblk->next_fragment = 0;
+	msblk->unused_frag_blks = SQUASHFS_CACHED_FRAGMENTS;
+
+	/* Allocate and read fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto failed_mount;
+
+	if(sblk->s_major < 3 || sblk->lookup_table_start == SQUASHFS_INVALID_BLK)
+		goto allocate_root;
+
+	/* Allocate and read inode lookup table */
+	if (read_inode_lookup_table(s) == 0)
+		goto failed_mount;
+
+	s->s_op = &squashfs_export_super_ops;
+	s->s_export_op = &squashfs_export_ops;
+
+allocate_root:
+	root = new_inode(s);
+	if ((msblk->read_inode)(root, sblk->root_inode) == 0)
+		goto failed_mount;
+	insert_inode_hash(root);
+
+	s->s_root = d_alloc_root(root);
+	if (s->s_root == NULL) {
+		ERROR("Root inode create failed\n");
+		iput(root);
+		goto failed_mount;
+	}
+
+	TRACE("Leaving squashfs_fill_super\n");
+	return 0;
+
+failed_mount:
+	kfree(msblk->inode_lookup_table);
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment);
+	kfree(msblk->uid);
+	vfree(msblk->read_page);
+	kfree(msblk->block_cache);
+	kfree(msblk->fragment_index_2);
+	vfree(msblk->stream.workspace);
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+	return -EINVAL;
+
+failure:
+	return -ENOMEM;
+}
+
+
+static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	TRACE("Entered squashfs_statfs\n");
+
+	buf->f_type = SQUASHFS_MAGIC;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sblk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes, avail_bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		bytes = squashfs_get_cached_block(inode->i_sb, NULL, block,
+				offset, PAGE_CACHE_SIZE, &block, &offset);
+		if (bytes == 0) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+			goto skip_read;
+		}
+	}
+
+	if (length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	avail_bytes = min_t(int, i_size_read(inode) - length, PAGE_CACHE_SIZE);
+
+	bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset,
+		avail_bytes, &block, &offset);
+	if (bytes == 0)
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if (msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++) {
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
+	}
+
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	mutex_unlock(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if (msblk->meta_index == NULL) {
+		msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL);
+		if (msblk->meta_index == NULL) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
+		}
+		for (i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
+		}
+		msblk->next_meta_index = 0;
+	}
+
+	for (i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if (i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	mutex_unlock(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+	smp_mb();
+}
+
+
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+				long long *start_block, int *offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned int *block_listp;
+	int block = 0;
+	
+	if (msblk->swap) {
+		char sblock_list[blocks << 2];
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			goto failure;
+		}
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+	} else {
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			goto failure;
+		}
+	}
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
+		block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+
+	return block;
+
+failure:
+	return -1;
+}
+
+
+#define SIZE 256
+
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
+
+
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
+ 
+	index /= SQUASHFS_META_INDEXES * skip;
+
+	while (offset < index) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			meta = empty_meta_index(inode, offset + 1, skip);
+			if (meta == NULL)
+				goto all_done;
+		} else {
+			if(meta->entries == 0)
+				goto failed;
+			/* XXX */
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			/* XXX */
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset, meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
+		}
+
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
+
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) : blocks;
+				int res = read_block_index(inode->i_sb, block, block_list,
+					&cur_index_block, &cur_offset);
+
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
+			}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
+		}
+
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
+
+		release_meta_index(inode, meta);
+	}
+
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
+
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
+}
+
+
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
+{
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
+
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset, block);
+
+	if(res == -1)
+		goto failure;
+
+	index -= res;
+
+	while (index) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
+	}
+
+	if (read_block_index(inode->i_sb, 1, block_list, &block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
+
+failure:
+	return 0;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list = NULL;
+	long long block;
+	unsigned int bsize, i;
+	int bytes;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
+	
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+	int file_end = i_size_read(inode) >> sblk->block_log;
+	int sparse = 0;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index, SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto out;
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		block_list = kmalloc(SIZE, GFP_KERNEL);
+		if (block_list == NULL) {
+			ERROR("Failed to allocate block_list\n");
+			goto error_out;
+		}
+
+		block = (msblk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize);
+		if (block == 0)
+			goto error_out;
+
+		if (bsize == 0) { /* hole */
+			bytes = index == file_end ?
+				(i_size_read(inode) & (sblk->block_size - 1)) : sblk->block_size;
+			sparse = 1;
+		} else {
+			mutex_lock(&msblk->read_page_mutex);
+		
+			bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+				bsize, NULL, sblk->block_size);
+
+			if (bytes == 0) {
+				ERROR("Unable to read page, block %llx, size %x\n", block, bsize);
+				mutex_unlock(&msblk->read_page_mutex);
+				goto error_out;
+			}
+		}
+	} else {
+		fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)-> u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size);
+
+		if (fragment == NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->u.s1.fragment_size);
+			goto error_out;
+		}
+		bytes = i_size_read(inode) & (sblk->block_size - 1);
+		data_ptr = fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset;
+	}
+
+	for (i = start_index; i <= end_index && bytes > 0; i++,
+						bytes -= PAGE_CACHE_SIZE, data_ptr += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int avail = sparse ? 0 : min_t(unsigned int, bytes, PAGE_CACHE_SIZE);
+
+		TRACE("bytes %d, i %d, available_bytes %d\n", bytes, i, avail);
+
+		push_page = (i == page->index) ? page :
+			grab_cache_page_nowait(page->mapping, i);
+
+		if (!push_page)
+			continue;
+
+		if (PageUptodate(push_page))
+			goto skip_page;
+
+ 		pageaddr = kmap_atomic(push_page, KM_USER0);
+		memcpy(pageaddr, data_ptr, avail);
+		memset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);
+		kunmap_atomic(pageaddr, KM_USER0);
+		flush_dcache_page(push_page);
+		SetPageUptodate(push_page);
+skip_page:
+		unlock_page(push_page);
+		if(i != page->index)
+			page_cache_release(push_page);
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		if (!sparse)
+			mutex_unlock(&msblk->read_page_mutex);
+		kfree(block_list);
+	} else
+		release_cached_fragment(msblk, fragment);
+
+	return 0;
+
+error_out:
+	SetPageError(page);
+out:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr, 0, PAGE_CACHE_SIZE);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	if (!PageError(page))
+		SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
+					sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, &index, index_start, index_offset,
+					sizeof(index), &index_start, &index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start, &index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length + 3;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL);
+	if (str == NULL) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
+				sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, index, index_start, index_offset,
+				sizeof(struct squashfs_dir_index), &index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start, index_offset,
+					index->size + 1, &index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+
+failure:
+	return length + 3;
+}
+
+		
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino, squashfs_filetype_table[1]);
+
+		if (filldir(dirent, name, size, file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+			goto finish;
+		}
+		file->f_pos += size;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
+					 next_offset, sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
+					next_offset, sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
+						next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
+						next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+						next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name, dire->size + 1,
+					(int) file->f_pos, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1, file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_lookup;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_lookup;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name, len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
+					 next_offset, sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
+					next_offset, sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
+						next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
+						next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+					next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (name[0] < dire->name[0])
+				goto exit_lookup;
+
+			if ((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
+				squashfs_inode_t ino = SQUASHFS_MKINODE(dirh.start_block,
+								dire->offset);
+
+				TRACE("calling squashfs_iget for directory entry %s, inode"
+					"  %x:%x, %d\n", name, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
+
+				inode = squashfs_iget(i->i_sb, ino, dirh.inode_number + dire->inode_number);
+
+				goto exit_lookup;
+			}
+		}
+	}
+
+exit_lookup:
+	kfree(dire);
+	if (inode)
+		return d_splice_alias(inode, dentry);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_lookup;
+}
+
+
+static int squashfs_remount(struct super_block *s, int *flags, char *data)
+{
+	*flags |= MS_RDONLY;
+	return 0;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < squashfs_cached_blks; i++)
+				if (sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)
+					vfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
+				vfree(sbi->fragment[i].data);
+		kfree(sbi->fragment);
+		kfree(sbi->block_cache);
+		vfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		vfree(sbi->stream.workspace);
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static int squashfs_get_sb(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super,
+				mnt);
+}
+
+
+static int __init init_squashfs_fs(void)
+{
+	int err = init_inodecache();
+	if (err)
+		goto out;
+
+	printk(KERN_INFO "squashfs: version 3.3 (2007/10/31) "
+		"Phillip Lougher\n");
+
+	err = register_filesystem(&squashfs_fs_type);
+	if (err)
+		destroy_inodecache();
+
+out:
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	unregister_filesystem(&squashfs_fs_type);
+	destroy_inodecache();
+}
+
+
+static struct kmem_cache * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);
+	return ei ? &ei->vfs_inode : NULL;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(void * foo, struct kmem_cache * cachep, unsigned long flags)
+{
+	struct squashfs_inode_info *ei = foo;
+
+	inode_init_once(&ei->vfs_inode);
+}
+ 
+
+static int __init init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+	    sizeof(struct squashfs_inode_info), 0,
+		SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	kmem_cache_destroy(squashfs_inode_cachep);
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs 3.2-r2-CVS, a compressed read-only filesystem");
+MODULE_AUTHOR("Phillip Lougher <phillip@lougher.demon.co.uk>");
+MODULE_LICENSE("GPL");
diff -x .gitignore -Nurp linux-2.6.23/fs/squashfs/Makefile linux-2.6.23-squashfs3.3/fs/squashfs/Makefile
--- linux-2.6.23/fs/squashfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/fs/squashfs/Makefile	2005-11-20 14:31:00.000000000 +0000
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+squashfs-y += inode.o
+squashfs-y += squashfs2_0.o
diff -x .gitignore -Nurp linux-2.6.23/fs/squashfs/squashfs2_0.c linux-2.6.23-squashfs3.3/fs/squashfs/squashfs2_0.c
--- linux-2.6.23/fs/squashfs/squashfs2_0.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/fs/squashfs/squashfs2_0.c	2007-10-25 00:43:59.000000000 +0100
@@ -0,0 +1,740 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments))) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	i->i_ino = ino;
+	i->i_mtime.tv_sec = sblk->mkfs_time;
+	i->i_atime.tv_sec = sblk->mkfs_time;
+	i->i_ctime.tv_sec = sblk->mkfs_time;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_nlink = 1;
+	i->i_size = 0;
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static int squashfs_read_inode_2(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = SQUASHFS_MK_VFS_INODE(block -
+		sblk->inode_table_start, offset);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode_2\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb, ino);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size = 0;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length;
+}
+
+		
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+				unsigned int inode_number = SQUASHFS_MK_VFS_INODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = squashfs_iget(i->i_sb, ino, inode_number);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
diff -x .gitignore -Nurp linux-2.6.23/fs/squashfs/squashfs.h linux-2.6.23-squashfs3.3/fs/squashfs/squashfs.h
--- linux-2.6.23/fs/squashfs/squashfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/fs/squashfs/squashfs.h	2007-08-19 04:23:16.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index, int srclength);
+extern int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number);
+extern const struct address_space_operations squashfs_symlink_aops;
+extern const struct address_space_operations squashfs_aops;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/addrspace.h linux-2.6.23.1-stm/include/asm-sh/addrspace.h
--- linux-2.6.23.1/include/asm-sh/addrspace.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/addrspace.h	2007-11-01 12:00:43.000000000 +0000
@@ -31,6 +31,7 @@
 /* Returns the privileged segment base of a given address  */
 #define PXSEG(a)	(((unsigned long)(a)) & 0xe0000000)
 
+#ifndef CONFIG_32BIT
 /* Returns the physical address of a PnSEG (n=1,2) address   */
 #define PHYSADDR(a)	(((unsigned long)(a)) & 0x1fffffff)
 
@@ -41,6 +42,10 @@
 #define P2SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P2SEG))
 #define P3SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P3SEG))
 #define P4SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P4SEG))
+#endif
+
+/* Check if an address can be reached in 29 bits */
+#define IS_29BIT(a)	(((unsigned long)(a)) < 0x20000000)
 
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_ADDRSPACE_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/atomic-grb.h linux-2.6.23.1-stm/include/asm-sh/atomic-grb.h
--- linux-2.6.23.1/include/asm-sh/atomic-grb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/atomic-grb.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,114 @@
+#ifndef __ASM_SH_ATOMIC_GRB_H
+#define __ASM_SH_ATOMIC_GRB_H
+
+static __inline__ void atomic_add(int i, atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+		"   mov    r15,   r1      \n\t"  // r1 = saved sp
+                "   mov    #-6,   r15     \n\t"  // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t"  // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (i)        // 2
+                : "memory" , "r0", "r1" );
+}
+
+static inline void atomic_sub(int i, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+		"   mov     r15,  r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   sub     %2,   %0      \n\t" // sub
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (i)        // 2
+                : "memory" , "r0", "r1");
+}
+
+static inline int atomic_add_return(int i, atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+		"   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (i)        // 2
+                : "memory" , "r0", "r1");
+        return tmp;
+}
+
+static inline int atomic_sub_return(int i, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   sub     %2,   %0      \n\t" // sub
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (i)        // 2
+                : "memory", "r0", "r1" );
+        return tmp;
+}
+
+static inline void atomic_clear_mask(unsigned int mask, atomic_t *v)
+{
+       int tmp;
+       unsigned int _mask = ~mask;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   and     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (_mask)    // 2
+                : "memory" , "r0", "r1" );
+}
+
+static inline void atomic_set_mask(unsigned int mask, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   or      %2,   %0      \n\t" // or
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (v)        // 1
+                : "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+#endif /* __ASM_SH_ATOMIC_GRB_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/atomic.h linux-2.6.23.1-stm/include/asm-sh/atomic.h
--- linux-2.6.23.1/include/asm-sh/atomic.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/atomic.h	2007-11-01 12:00:40.000000000 +0000
@@ -19,6 +19,8 @@
 
 #ifdef CONFIG_CPU_SH4A
 #include <asm/atomic-llsc.h>
+#elif defined(CONFIG_SH_GRB)
+#include <asm/atomic-grb.h>
 #else
 #include <asm/atomic-irq.h>
 #endif
@@ -44,6 +46,62 @@
 #define atomic_inc(v) atomic_add(1,(v))
 #define atomic_dec(v) atomic_sub(1,(v))
 
+#if defined(CONFIG_SH_GRB)
+static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
+{
+	int ret;
+/*
+	ret = v->counter;
+	if (likely(ret == old))
+		v->counter = new;
+*/
+	asm volatile(
+		"   .align 2		\n\t"
+		"   mova     1f,  r0	\n\t"
+		"   nop			\n\t"
+		"   mov     r15,  r1	\n\t"
+		"   mov    #-8,  r15	\n\t"
+		"   mov.l   @%1,  %0	\n\t"
+		"   cmp/eq   %2,  %0	\n\t"
+		"   bf	     1f		\n\t"
+		"   mov.l    %3, @%1	\n\t"
+		"1: mov      r1,  r15	\n\t"
+		: "=&r" (ret)
+		: "r" (v), "r" (old), "r" (new)
+		: "memory" , "r0", "r1" , "t" );
+
+	return ret;
+}
+
+static inline int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	int ret;
+	unsigned long tmp;
+/*
+	ret = v->counter;
+	if (ret != u)
+		v->counter += a;
+*/
+	asm volatile(
+		"   .align 2		\n\t"
+		"   mova    1f,   r0	\n\t"
+		"   nop			\n\t"
+		"   mov    r15,   r1	\n\t"
+		"   mov    #-12,  r15	\n\t"
+		"   mov.l  @%2,   %1	\n\t"
+		"   mov	    %1,   %0    \n\t"
+		"   cmp/eq  %4,   %0	\n\t"
+		"   bt/s    1f		\n\t"
+		"    add    %3,   %1	\n\t"
+		"   mov.l   %1,  @%2	\n\t"
+		"1: mov     r1,   r15	\n\t"
+		: "=&r" (ret), "=&r" (tmp)
+		: "r" (v), "r" (a), "r" (u)
+		: "memory" , "r0", "r1" , "t" );
+
+	return ret != u;
+}
+#else
 static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
 {
 	int ret;
@@ -58,8 +116,6 @@
 	return ret;
 }
 
-#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
-
 static inline int atomic_add_unless(atomic_t *v, int a, int u)
 {
 	int ret;
@@ -73,6 +129,9 @@
 
 	return ret != u;
 }
+#endif
+
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
 /* Atomic operations are already serializing on SH */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/bitops-grb.h linux-2.6.23.1-stm/include/asm-sh/bitops-grb.h
--- linux-2.6.23.1/include/asm-sh/bitops-grb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/bitops-grb.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,176 @@
+#ifndef __ASM_SH_BITOPS_GRB_H
+#define __ASM_SH_BITOPS_GRB_H
+
+static inline void set_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   or      %2,   %0      \n\t" // or
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (a)        // 1
+                : "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+
+static inline void clear_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+	a += nr >> 5;
+        mask = ~(1 << (nr & 0x1f));
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   and     %2,   %0      \n\t" // and
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (a)        // 1
+                : "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+
+static inline void change_bit(int nr, volatile void * addr)
+{
+        int     mask;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   xor     %2,   %0      \n\t" // xor
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "+r"  (a)        // 1
+                : "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+
+static inline int test_and_set_bit(int nr, volatile void * addr)
+{
+        int     mask, retval;
+	volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a |= mask;
+*/
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov   #-14,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" //
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+                "   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   or      %3,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+                "1: mov     r1,  r15      \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "=&r" (retval),  // 1
+                  "+r"  (a)        // 2
+                : "r"   (mask)     // 3
+                : "memory" , "r0", "r1" ,"t");
+
+        return retval;
+}
+
+static inline int test_and_clear_bit(int nr, volatile void * addr)
+{
+        int     mask, retval,not_mask;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a &= ~mask;
+*/
+	not_mask = ~mask;
+
+        asm volatile(
+                "   .align 2              \n\t"
+		"   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+		"   mov   #-14,   r15     \n\t" // LOGIN
+		"   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" // %1     = *a
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+		"   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   and     %4,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+		"1: mov     r1,   r15     \n\t" // LOGOUT
+		: "=&r" (tmp),     // 0
+		  "=&r" (retval),  // 1
+		  "+r"  (a)        // 2
+		: "r"   (mask),    // 3
+		  "r"   (not_mask) // 4
+		: "memory" , "r0", "r1", "t" );
+
+        return retval;
+}
+
+static inline int test_and_change_bit(int nr, volatile void * addr)
+{
+        int     mask, retval;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a ^= mask;
+*/
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov   #-14,   r15     \n\t" // LOGIN
+                "   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" // %1     = *a
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+                "   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   xor     %3,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "=&r" (retval),  // 1
+                  "+r"  (a)        // 2
+                : "r"   (mask)     // 3
+                : "memory" , "r0", "r1", "t" );
+        return retval;
+}
+#endif /* __ASM_SH_BITOPS_GRB_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/bitops-irq.h linux-2.6.23.1-stm/include/asm-sh/bitops-irq.h
--- linux-2.6.23.1/include/asm-sh/bitops-irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/bitops-irq.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,91 @@
+#ifndef __ASM_SH_BITOPS_IRQ_H
+#define __ASM_SH_BITOPS_IRQ_H
+
+static inline void set_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	*a |= mask;
+	local_irq_restore(flags);
+}
+
+static inline void clear_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	*a &= ~mask;
+	local_irq_restore(flags);
+}
+
+static inline void change_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	*a ^= mask;
+	local_irq_restore(flags);
+}
+
+static inline int test_and_set_bit(int nr, volatile void * addr)
+{
+	int	mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+static inline int test_and_clear_bit(int nr, volatile void * addr)
+{
+	int	mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+static inline int test_and_change_bit(int nr, volatile void * addr)
+{
+	int	mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+#endif /* __ASM_SH_BITOPS_IRQ_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/bitops.h linux-2.6.23.1-stm/include/asm-sh/bitops.h
--- linux-2.6.23.1/include/asm-sh/bitops.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/bitops.h	2007-11-01 12:00:40.000000000 +0000
@@ -6,97 +6,18 @@
 /* For __swab32 */
 #include <asm/byteorder.h>
 
-static inline void set_bit(int nr, volatile void * addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	*a |= mask;
-	local_irq_restore(flags);
-}
+#ifdef CONFIG_CPU_GRB
+#include <asm/bitops-grb.h>
+#else
+#include <asm/bitops-irq.h>
+#endif
+
 
 /*
  * clear_bit() doesn't provide any barrier for the compiler.
  */
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
-static inline void clear_bit(int nr, volatile void * addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	*a &= ~mask;
-	local_irq_restore(flags);
-}
-
-static inline void change_bit(int nr, volatile void * addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	*a ^= mask;
-	local_irq_restore(flags);
-}
-
-static inline int test_and_set_bit(int nr, volatile void * addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	retval = (mask & *a) != 0;
-	*a |= mask;
-	local_irq_restore(flags);
-
-	return retval;
-}
-
-static inline int test_and_clear_bit(int nr, volatile void * addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	retval = (mask & *a) != 0;
-	*a &= ~mask;
-	local_irq_restore(flags);
-
-	return retval;
-}
-
-static inline int test_and_change_bit(int nr, volatile void * addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long flags;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-	local_irq_save(flags);
-	retval = (mask & *a) != 0;
-	*a ^= mask;
-	local_irq_restore(flags);
-
-	return retval;
-}
 
 #include <asm-generic/bitops/non-atomic.h>
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/cachectl.h linux-2.6.23.1-stm/include/asm-sh/cachectl.h
--- linux-2.6.23.1/include/asm-sh/cachectl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/cachectl.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,12 @@
+#ifndef _SH_CACHECTL_H
+#define _SH_CACHECTL_H
+
+/* Definitions for the cacheflush system call.  */
+
+#define CACHEFLUSH_D_INVAL	0x1	/* invalidate (without write back) */
+#define CACHEFLUSH_D_WB		0x2	/* write back (without invalidate) */
+#define CACHEFLUSH_D_PURGE	0x3	/* writeback and invalidate */
+
+#define CACHEFLUSH_I		0x4
+
+#endif /* _SH_CACHECTL_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/cpu-sh4/cacheflush.h linux-2.6.23.1-stm/include/asm-sh/cpu-sh4/cacheflush.h
--- linux-2.6.23.1/include/asm-sh/cpu-sh4/cacheflush.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/cpu-sh4/cacheflush.h	2007-11-01 12:00:43.000000000 +0000
@@ -39,6 +39,6 @@
 /* Initialization of P3 area for copy_user_page */
 void p3_cache_init(void);
 
-#define PG_mapped	PG_arch_1
+#define PG_dcache_dirty			PG_arch_1
 
 #endif /* __ASM_CPU_SH4_CACHEFLUSH_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/cpu-sh4/mmu_context.h linux-2.6.23.1-stm/include/asm-sh/cpu-sh4/mmu_context.h
--- linux-2.6.23.1/include/asm-sh/cpu-sh4/mmu_context.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/cpu-sh4/mmu_context.h	2007-11-01 12:00:43.000000000 +0000
@@ -34,6 +34,10 @@
 #define MMUCR_SQMD		(0)
 #endif
 
+#ifdef CONFIG_32BIT // and ST40-20x
+#define MMUCR_SE		(1<<4)
+#endif
+
 #define MMU_NTLB_ENTRIES	64
 #define MMU_CONTROL_INIT	(0x05|MMUCR_SQMD|MMUCR_ME)
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/dma.h linux-2.6.23.1-stm/include/asm-sh/dma.h
--- linux-2.6.23.1/include/asm-sh/dma.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/dma.h	2007-11-01 12:00:41.000000000 +0000
@@ -22,7 +22,7 @@
    occurrence should be flagged as an error.  */
 /* But... */
 /* XXX: This is not applicable to SuperH, just needed for alloc_bootmem */
-#define MAX_DMA_ADDRESS		(PAGE_OFFSET+0x10000000)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET+0x1fffffff)
 
 #ifdef CONFIG_NR_DMA_CHANNELS
 #  define MAX_DMA_CHANNELS	(CONFIG_NR_DMA_CHANNELS)
@@ -71,14 +71,19 @@
 	void (*free)(struct dma_channel *chan);
 
 	int (*get_residue)(struct dma_channel *chan);
-	int (*xfer)(struct dma_channel *chan);
+	int (*xfer)(struct dma_channel *chan, unsigned long sar,
+		    unsigned long dar, size_t count, unsigned int mode);
 	int (*configure)(struct dma_channel *chan, unsigned long flags);
 	int (*extend)(struct dma_channel *chan, unsigned long op, void *param);
 };
 
+struct dma_info;
+
 struct dma_channel {
 	char dev_id[16];		/* unique name per DMAC of channel */
 
+	struct dma_info *info;	/* SIM: can this be simply dma_ops? */
+
 	unsigned int chan;		/* DMAC channel number */
 	unsigned int vchan;		/* Virtual channel number */
 
@@ -162,5 +167,9 @@
 #define isa_dma_bridge_buggy	(0)
 #endif
 
+#ifdef CONFIG_STM_DMA
+#define DMA_REQ_ANY_CHANNEL 0xf0f0f0f0
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_DMA_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/fixmap.h linux-2.6.23.1-stm/include/asm-sh/fixmap.h
--- linux-2.6.23.1/include/asm-sh/fixmap.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/fixmap.h	2007-11-01 12:00:43.000000000 +0000
@@ -46,13 +46,13 @@
  * fix-mapped?
  */
 enum fixed_addresses {
-#define FIX_N_COLOURS 16
-	FIX_CMAP_BEGIN,
-	FIX_CMAP_END = FIX_CMAP_BEGIN + FIX_N_COLOURS,
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
 	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
 #endif
+	FIX_UNCACHED_CODE,
+	FIX_SYSCONF,
+	FIX_ASC,
 	__end_of_fixed_addresses
 };
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/hms1/coproc.h linux-2.6.23.1-stm/include/asm-sh/hms1/coproc.h
--- linux-2.6.23.1/include/asm-sh/hms1/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/hms1/coproc.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/hms1/st40_ide.h linux-2.6.23.1-stm/include/asm-sh/hms1/st40_ide.h
--- linux-2.6.23.1/include/asm-sh/hms1/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/hms1/st40_ide.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+ * include/asm-sh/hms1/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on HMS1.
+ * This uses the IDE EMI in bank 3.
+ */
+
+/* On the HMS1 is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET	0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number */
+#define ATA_IRQ		IRL1_IRQ
+
+/* ide_enable does nothing because there is no external hardware to configure */
+#define ide_enable()
+
+/* These do nothing because the STb7100 doesn't have an HDDI i/f */
+#define hddi_reset()
+#define hddi_set_pio_timings(rate)
+#define hddi_setup_dma(interface, address, offset)
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/ide.h linux-2.6.23.1-stm/include/asm-sh/ide.h
--- linux-2.6.23.1/include/asm-sh/ide.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/ide.h	2007-11-01 12:00:40.000000000 +0000
@@ -19,6 +19,60 @@
 
 #include <asm-generic/ide_iops.h>
 
+/* IDE code reads and writes directly to user space buffers via
+ * kernel logical addresses, with no explicit cache synchronization.
+ * Insert explicit cache flushes as required.
+ * This uses the same technique as the Sparc64.
+ */
+#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SH_CACHE_DISABLE)
+
+#ifdef insl
+#undef insl
+#endif
+#ifdef outsl
+#undef outsl
+#endif
+#ifdef insw
+#undef insw
+#endif
+#ifdef outsw
+#undef outsw
+#endif
+
+#define wrap_in(op)					\
+static __inline__ void sh_ide_##op(unsigned long port,	\
+				void *buffer,		\
+				unsigned long count,	\
+				unsigned long nbytes)	\
+{							\
+	__##op(port, buffer, count);			\
+	__flush_wback_region(buffer, nbytes);		\
+}
+
+wrap_in(insw)
+wrap_in(insl)
+#define insw(port, buffer, count) sh_ide_insw((port), (buffer), (count), (count)<<1)
+#define insl(port, buffer, count) sh_ide_insl((port), (buffer), (count), (count)<<2)
+#undef wrap_in
+
+#define wrap_out(op)					\
+static __inline__ void sh_ide_##op(unsigned long port,	\
+				void *buffer,		\
+				unsigned long count,	\
+				unsigned long nbytes)	\
+{							\
+	__##op(port, buffer, count);			\
+	/* __flush_wback_region(buffer, nbytes); */		\
+}
+
+wrap_out(outsw)
+wrap_out(outsl)
+#define outsw(port, buffer, count) sh_ide_outsw((port), (buffer), (count), (count)<<1)
+#define outsl(port, buffer, count) sh_ide_outsl((port), (buffer), (count), (count)<<2)
+#undef wrap_out
+
+#endif /* CONFIG_CPU_SH4 && !CONFIG_SH_CACHE_DISABLE */
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASM_SH_IDE_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/io.h linux-2.6.23.1-stm/include/asm-sh/io.h
--- linux-2.6.23.1/include/asm-sh/io.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/io.h	2007-11-01 12:00:43.000000000 +0000
@@ -107,8 +107,12 @@
 #define __raw_writew(v, a)	__writew(v, (void __iomem *)(a))
 #define __raw_writel(v, a)	__writel(v, (void __iomem *)(a))
 
-void __raw_writesl(unsigned long addr, const void *data, int longlen);
-void __raw_readsl(unsigned long addr, void *data, int longlen);
+void __raw_readsb(const void __iomem *port, void *data, int longlen);
+void __raw_readsw(const void __iomem *port, void *data, int longlen);
+void __raw_readsl(const void __iomem *port, void *data, int longlen);
+void __raw_writesb(void __iomem *port, const void *data, int longlen);
+void __raw_writesw(void __iomem *port, const void *data, int longlen);
+void __raw_writesl(void __iomem *port, const void *data, int longlen);
 
 /*
  * The platform header files may define some of these macros to use
@@ -181,13 +185,13 @@
 #define iowrite32(v,a)		writel((v),(a))
 #define iowrite32be(v,a)	__raw_writel(cpu_to_be32((v)),(a))
 
-#define ioread8_rep(a,d,c)	insb((a),(d),(c))
-#define ioread16_rep(a,d,c)	insw((a),(d),(c))
-#define ioread32_rep(a,d,c)	insl((a),(d),(c))
-
-#define iowrite8_rep(a,s,c)	outsb((a),(s),(c))
-#define iowrite16_rep(a,s,c)	outsw((a),(s),(c))
-#define iowrite32_rep(a,s,c)	outsl((a),(s),(c))
+#define ioread8_rep(p,d,c)	__raw_readsb(p,d,c)
+#define ioread16_rep(p,d,c)	__raw_readsw(p,d,c)
+#define ioread32_rep(p,d,c)	__raw_readsl(p,d,c)
+
+#define iowrite8_rep(p,s,c)	__raw_writesb(p,s,c)
+#define iowrite16_rep(p,s,c)	__raw_writesw(p,s,c)
+#define iowrite32_rep(p,s,c)	__raw_writesl(p,s,c)
 
 #define mmiowb()	wmb()	/* synco on SH-4A, otherwise a nop */
 
@@ -210,34 +214,48 @@
 extern void memcpy_toio(volatile void __iomem *, const void *, unsigned long);
 extern void memset_io(volatile void __iomem *, int, unsigned long);
 
+extern void ctrl_fn_using_non_p3_address(void);
+#define CTRL_ADDR_CHECK(addr)						\
+	if (__builtin_constant_p(addr) && (PXSEG(addr) != P4SEG))	\
+		ctrl_fn_using_non_p3_address();				\
+	else if (PXSEG(addr) != P4SEG)					\
+		pr_debug("ctrl fn using non-p4 address at %s:%u\n",	\
+			__FILE__, __LINE__);
+
 /* SuperH on-chip I/O functions */
 static inline unsigned char ctrl_inb(unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
 	return *(volatile unsigned char*)addr;
 }
 
 static inline unsigned short ctrl_inw(unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
 	return *(volatile unsigned short*)addr;
 }
 
 static inline unsigned int ctrl_inl(unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
 	return *(volatile unsigned long*)addr;
 }
 
 static inline void ctrl_outb(unsigned char b, unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
 	*(volatile unsigned char*)addr = b;
 }
 
 static inline void ctrl_outw(unsigned short b, unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
 	*(volatile unsigned short*)addr = b;
 }
 
 static inline void ctrl_outl(unsigned int b, unsigned long addr)
 {
+	CTRL_ADDR_CHECK(addr);
         *(volatile unsigned long*)addr = b;
 }
 
@@ -255,12 +273,12 @@
  */
 static inline unsigned long virt_to_phys(volatile void *address)
 {
-	return PHYSADDR(address);
+	return __pa(address);
 }
 
 static inline void *phys_to_virt(unsigned long address)
 {
-	return (void *)P1SEGADDR(address);
+	return __va(address);
 }
 #else
 #define phys_to_virt(address)	((void *)(address))
@@ -286,25 +304,18 @@
  * the drivers to handle caching properly.
  */
 #ifdef CONFIG_MMU
-void __iomem *__ioremap(unsigned long offset, unsigned long size,
-			unsigned long flags);
+void __iomem *__ioremap_mode(unsigned long offset, unsigned long size,
+			     unsigned long flags);
+void __iomem *__ioremap_prot(unsigned long offset, unsigned long size,
+			     pgprot_t prot);
 void __iounmap(void __iomem *addr);
 #else
-#define __ioremap(offset, size, flags)	((void __iomem *)(offset))
 #define __iounmap(addr)			do { } while (0)
-#endif /* CONFIG_MMU */
-
 static inline void __iomem *
 __ioremap_mode(unsigned long offset, unsigned long size, unsigned long flags)
 {
 	unsigned long last_addr = offset + size - 1;
 
-	/*
-	 * For P1 and P2 space this is trivial, as everything is already
-	 * mapped. Uncached access for P1 addresses are done through P2.
-	 * In the P3 case or for addresses outside of the 29-bit space,
-	 * mapping must be done by the PMB or by using page tables.
-	 */
 	if (likely(PXSEG(offset) < P3SEG && PXSEG(last_addr) < P3SEG)) {
 		if (unlikely(flags & _PAGE_CACHABLE))
 			return (void __iomem *)P1SEGADDR(offset);
@@ -312,8 +323,9 @@
 		return (void __iomem *)P2SEGADDR(offset);
 	}
 
-	return __ioremap(offset, size, flags);
+	return ((void __iomem *)(offset));
 }
+#endif /* CONFIG_MMU */
 
 #define ioremap(offset, size)				\
 	__ioremap_mode((offset), (size), 0)
@@ -321,8 +333,8 @@
 	__ioremap_mode((offset), (size), 0)
 #define ioremap_cache(offset, size)			\
 	__ioremap_mode((offset), (size), _PAGE_CACHABLE)
-#define p3_ioremap(offset, size, flags)			\
-	__ioremap((offset), (size), (flags))
+#define p3_ioremap(offset, size, prot)			\
+	__ioremap_prot((offset), (size), (prot))
 #define iounmap(addr)					\
 	__iounmap((addr))
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/irl.h linux-2.6.23.1-stm/include/asm-sh/irl.h
--- linux-2.6.23.1/include/asm-sh/irl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/irl.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,21 @@
+/*
+ * include/asm-sh/irl.h
+ *
+ * Copyright (c) STMicroelectronics 2007
+ *
+ * IRL interrupt lines
+ */
+
+#ifndef _ASM_SH_IRL_H
+#define _ASM_SH_IRL_H
+
+/*
+ * Interrupts which are generated by IRL lines when in individual interrupt
+ * mode. See plat_irq_setup_pins().
+ */
+#define IRL0_IRQ	2
+#define IRL1_IRQ	5
+#define IRL2_IRQ	8
+#define IRL3_IRQ	11
+
+#endif /* _ASM_SH_IRL_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/irq-ilc.h linux-2.6.23.1-stm/include/asm-sh/irq-ilc.h
--- linux-2.6.23.1/include/asm-sh/irq-ilc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/irq-ilc.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,7 @@
+#define ILC_FIRST_IRQ	44
+#define ILC_NR_IRQS	150
+#define ILC_IRQ(x) (ILC_FIRST_IRQ + (x))
+
+void __init ilc_early_init(struct platform_device* pdev);
+void __init ilc_stx7200_init(void);
+void ilc_irq_demux(unsigned int irq, struct irq_desc *desc);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/irq-stb7100.h linux-2.6.23.1-stm/include/asm-sh/irq-stb7100.h
--- linux-2.6.23.1/include/asm-sh/irq-stb7100.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/irq-stb7100.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,9 @@
+void ilc_route_external(int ilc_irq, int ext_out, int invert);
+#define ILC_EXT_IRQ0   64
+#define ILC_EXT_IRQ1   65
+#define ILC_EXT_IRQ2   66
+#define ILC_EXT_IRQ3   67
+#define ILC_EXT_IRB_WAKEUP	68
+#define ILC_EXT_NMI		69
+#define ILC_EXT_MDINT		70
+#define ILC_EXT_LOWPOWEROUT	71
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/irq.h linux-2.6.23.1-stm/include/asm-sh/irq.h
--- linux-2.6.23.1/include/asm-sh/irq.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/irq.h	2007-11-01 12:00:42.000000000 +0000
@@ -33,13 +33,7 @@
 void init_IRQ_pint(void);
 void make_imask_irq(unsigned int irq);
 
-static inline int generic_irq_demux(int irq)
-{
-	return irq;
-}
-
 #define irq_canonicalize(irq)	(irq)
-#define irq_demux(irq)		sh_mv.mv_irq_demux(irq)
 
 #ifdef CONFIG_4KSTACKS
 extern void irq_ctx_init(int cpu);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/machvec.h linux-2.6.23.1-stm/include/asm-sh/machvec.h
--- linux-2.6.23.1/include/asm-sh/machvec.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/machvec.h	2007-11-01 12:00:42.000000000 +0000
@@ -49,8 +49,6 @@
 	void (*mv_writew)(u16, void __iomem *);
 	void (*mv_writel)(u32, void __iomem *);
 
-	int (*mv_irq_demux)(int irq);
-
 	void (*mv_init_irq)(void);
 	void (*mv_init_pci)(void);
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb360/harp.h linux-2.6.23.1-stm/include/asm-sh/mb360/harp.h
--- linux-2.6.23.1/include/asm-sh/mb360/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb360/harp.h	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40RA Eval board.
+ */
+
+#define EPLD_BASE		0xa6000000
+#define EPLD_SIZE		0x40
+
+#define EPLD_REVID_PLD		(EPLD_BASE+0x00000000)
+#define EPLD_REVID_BOARD	(EPLD_BASE+0x00000004)
+#define EPLD_GPCR		(EPLD_BASE+0x00000018)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x00000020)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00000024)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00000028)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x0000002c)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x00000030)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00000034)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00000038)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x0000003c)
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+	return 1;
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb374/harp.h linux-2.6.23.1-stm/include/asm-sh/mb374/harp.h
--- linux-2.6.23.1/include/asm-sh/mb374/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb374/harp.h	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40RA Starter Board.
+ */
+
+#define EPLD_BASE		0xa7000000
+#define EPLD_SIZE		0x34
+
+#define EPLD_REVID		(EPLD_BASE+0x00000000)
+#define EPLD_RESET		(EPLD_BASE+0x00000004)
+#define EPLD_LED_SET		(EPLD_BASE+0x00000008)
+#define EPLD_LED_CLR		(EPLD_BASE+0x0000000c)
+#define EPLD_VPP		(EPLD_BASE+0x00000010)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00000014)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x00000018)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x0000001c)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00000020)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00000024)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x00000028)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x0000002c)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00000030)
+
+#define EPLD_LED_ON   1
+#define EPLD_LED_OFF  0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+	return 1;
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	ctrl_outl(1, EPLD_VPP);
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	ctrl_outl(0, EPLD_VPP);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb411/coproc.h linux-2.6.23.1-stm/include/asm-sh/mb411/coproc.h
--- linux-2.6.23.1/include/asm-sh/mb411/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb411/coproc.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb411/harp.h linux-2.6.23.1-stm/include/asm-sh/mb411/harp.h
--- linux-2.6.23.1/include/asm-sh/mb411/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb411/harp.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics STb7100 Validation board.
+ */
+
+#define epld_out(val,addr) ctrl_outb(val,addr)
+#define epld_in(addr)      ctrl_inb(addr)
+
+#define EPLD_BASE		0xa3000000
+#define EPLD_EPLDVER		(EPLD_BASE + 0x000000)
+#define EPLD_PCBVER		(EPLD_BASE + 0x020000)
+#define EPLD_STEM		(EPLD_BASE + 0x040000)
+#define EPLD_DRIVER		(EPLD_BASE + 0x060000)
+#define EPLD_RESET		(EPLD_BASE + 0x080000)
+#define EPLD_INTSTAT0		(EPLD_BASE + 0x0a0000)
+#define EPLD_INTSTAT1		(EPLD_BASE + 0x0c0000)
+#define EPLD_INTMASK0		(EPLD_BASE + 0x0e0000)
+#define EPLD_INTMASK0SET	(EPLD_BASE + 0x100000)
+#define EPLD_INTMASK0CLR	(EPLD_BASE + 0x120000)
+#define EPLD_INTMASK1		(EPLD_BASE + 0x140000)
+#define EPLD_INTMASK1SET	(EPLD_BASE + 0x160000)
+#define EPLD_INTMASK1CLR	(EPLD_BASE + 0x180000)
+#define EPLD_TEST		(EPLD_BASE + 0x1e0000)
+
+#define EPLD_FLASH		(EPLD_BASE + 0x400000)
+
+/* Some registers are also available in the POD EPLD */
+#define EPLD_POD_BASE		0xa2100000
+#define EPLD_POD_REVID		(EPLD_POD_BASE + 0x00)
+#define EPLD_POD_LED		(EPLD_POD_BASE + 0x10)
+#define EPLD_POD_DEVID		(EPLD_POD_BASE + 0x1c)
+
+#define EPLD_LED_ON     1
+#define EPLD_LED_OFF    0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+        return 1;
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	epld_out(3, EPLD_FLASH);	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	epld_out(2, EPLD_FLASH);	/* Leave ON only RESET		*/
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb442/coproc.h linux-2.6.23.1-stm/include/asm-sh/mb442/coproc.h
--- linux-2.6.23.1/include/asm-sh/mb442/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb442/coproc.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb442/st40_ide.h linux-2.6.23.1-stm/include/asm-sh/mb442/st40_ide.h
--- linux-2.6.23.1/include/asm-sh/mb442/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb442/st40_ide.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+ * include/asm-sh/mb442/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on mb442 board.
+ * IDE is mapped into EMI bank3.
+ */
+
+/* STb7100 only has one hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. This is the base of EMI bank 3. */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET		0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number */
+#define ATA_IRQ			IRL1_IRQ
+
+/* ide_enable does nothing because there is no external hardware to configure */
+#define ide_enable()
+
+/* hddi_reset does nothing for stb7100, because it does not have a HDDI interface. */
+#define hddi_reset()
+
+/* hddi_set_pio_timings does nothing for mb411, because it has not an HDDI
+ * interface and PIO timings are setted into the EMI bank3 (PIO4).
+ */
+#define hddi_set_pio_timings(rate)
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
+
+/* DMA in not supported for mb411 board, so hddi_setup_dma does nothing. */
+#define hddi_setup_dma(interface, address, offset)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb448/coproc.h linux-2.6.23.1-stm/include/asm-sh/mb448/coproc.h
--- linux-2.6.23.1/include/asm-sh/mb448/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb448/coproc.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mb448/st40_ide.h linux-2.6.23.1-stm/include/asm-sh/mb448/st40_ide.h
--- linux-2.6.23.1/include/asm-sh/mb448/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mb448/st40_ide.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+ * include/asm-sh/mb448/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on STb7109E Reference Board.
+ * IDE is mapped into EMI bank 4.
+ */
+
+/* STb7109 only has one hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. This is the base of EMI bank 3. */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET		0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number */
+#define ATA_IRQ			IRL2_IRQ
+
+/* ide_enable does nothing because there is no external hardware to configure */
+#define ide_enable()
+
+/* hddi_reset does nothing for stb7109, because it does not have a HDDI interface. */
+#define hddi_reset()
+
+/* hddi_set_pio_timings does nothing for mb448, because it has not an HDDI
+ * interface and PIO timings are setted into the EMI bank 4 (PIO4).
+ */
+#define hddi_set_pio_timings(rate)
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
+
+/* DMA in not supported for mb448 board, so hddi_setup_dma does nothing. */
+#define hddi_setup_dma(interface, address, offset)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mmu.h linux-2.6.23.1-stm/include/asm-sh/mmu.h
--- linux-2.6.23.1/include/asm-sh/mmu.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mmu.h	2007-11-01 12:00:43.000000000 +0000
@@ -38,35 +38,11 @@
 
 #define PMB_NO_ENTRY		(-1)
 
-struct pmb_entry;
-
-struct pmb_entry {
-	unsigned long vpn;
-	unsigned long ppn;
-	unsigned long flags;
-
-	/*
-	 * 0 .. NR_PMB_ENTRIES for specific entry selection, or
-	 * PMB_NO_ENTRY to search for a free one
-	 */
-	int entry;
-
-	struct pmb_entry *next;
-	/* Adjacent entry link for contiguous multi-entry mappings */
-	struct pmb_entry *link;
-};
 
 /* arch/sh/mm/pmb.c */
-int __set_pmb_entry(unsigned long vpn, unsigned long ppn,
-		    unsigned long flags, int *entry);
-int set_pmb_entry(struct pmb_entry *pmbe);
-void clear_pmb_entry(struct pmb_entry *pmbe);
-struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
-			    unsigned long flags);
-void pmb_free(struct pmb_entry *pmbe);
-long pmb_remap(unsigned long virt, unsigned long phys,
-	       unsigned long size, unsigned long flags);
+long pmb_remap(unsigned long phys, unsigned long size, unsigned long flags);
 void pmb_unmap(unsigned long addr);
+void pmb_init(void);
 
 #endif /* __MMU_H */
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/mmu_context.h linux-2.6.23.1-stm/include/asm-sh/mmu_context.h
--- linux-2.6.23.1/include/asm-sh/mmu_context.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/mmu_context.h	2007-11-01 12:00:43.000000000 +0000
@@ -187,9 +187,15 @@
 static inline void enable_mmu(void)
 {
 	unsigned int cpu = smp_processor_id();
+	unsigned long mmucr_init = MMU_CONTROL_INIT;
 
 	/* Enable MMU */
-	ctrl_outl(MMU_CONTROL_INIT, MMUCR);
+#ifdef CONFIG_32BIT
+	if (1) /* SH4-202 and SE */
+		mmucr_init |= MMUCR_SE;
+#endif
+
+	ctrl_outl(mmucr_init, MMUCR);
 	ctrl_barrier();
 
 	if (asid_cache(cpu) == NO_CONTEXT)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/page.h linux-2.6.23.1-stm/include/asm-sh/page.h
--- linux-2.6.23.1/include/asm-sh/page.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/page.h	2007-11-01 12:00:43.000000000 +0000
@@ -1,17 +1,11 @@
-#ifndef __ASM_SH_PAGE_H
-#define __ASM_SH_PAGE_H
-
 /*
  * Copyright (C) 1999  Niibe Yutaka
  */
 
-/*
-   [ P0/U0 (virtual) ]		0x00000000     <------ User space
-   [ P1 (fixed)   cached ]	0x80000000     <------ Kernel space
-   [ P2 (fixed)  non-cachable]	0xA0000000     <------ Physical access
-   [ P3 (virtual) cached]	0xC0000000     <------ vmalloced area
-   [ P4 control   ]		0xE0000000
- */
+#ifndef __ASM_SH_PAGE_H
+#define __ASM_SH_PAGE_H
+
+#include <linux/const.h>
 
 #ifdef __KERNEL__
 
@@ -26,12 +20,7 @@
 # error "Bogus kernel page size?"
 #endif
 
-#ifdef __ASSEMBLY__
-#define PAGE_SIZE	(1 << PAGE_SHIFT)
-#else
-#define PAGE_SIZE	(1UL << PAGE_SHIFT)
-#endif
-
+#define PAGE_SIZE	(_AC(1, UL) << PAGE_SHIFT)
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 #define PTE_MASK	PAGE_MASK
 
@@ -113,25 +102,42 @@
 #define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
 
 /*
- * IF YOU CHANGE THIS, PLEASE ALSO CHANGE
- *
- *	arch/sh/kernel/vmlinux.lds.S
- *
- * which has the same constant encoded..
+ * __MEMORY_START and SIZE are the physical addresses and size of RAM.
  */
-
 #define __MEMORY_START		CONFIG_MEMORY_START
 #define __MEMORY_SIZE		CONFIG_MEMORY_SIZE
 
+/*
+ * PAGE_OFFSET is the virtual address of the start of kernel address
+ * space.
+ */
 #define PAGE_OFFSET		CONFIG_PAGE_OFFSET
-#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
-#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
-#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 
-#define phys_to_page(phys)	(pfn_to_page(phys >> PAGE_SHIFT))
+/*
+ * Virtual to physical RAM address translation.
+ * In 29 bit mode, the physical offset of RAM from address 0 is visible in
+ * the kernel virtual address space, and thus we don't have to take
+ * this into account when translating. However in 32 bit mode this offset
+ * is not visible (it is part of the PMB mapping) and so needs to be
+ * added or subtracted as required.
+ */
+#ifdef CONFIG_32BIT
+#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET+__MEMORY_START)
+#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET-__MEMORY_START))
+#else
+#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET+__MEMORY_START)
+#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET-__MEMORY_START))
+#endif
+
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 #define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
 
-/* PFN start number, because of __MEMORY_START */
+/*
+ * PFN = physical frame number (ie PFN 0 == physical address 0)
+ * PFN_START is the PFN of the first page of RAM. By defining this we
+ * don't have struct page entries for the portion of address space
+ * between physical address 0 and the start of RAM.
+ */
 #define PFN_START		(__MEMORY_START >> PAGE_SHIFT)
 #define ARCH_PFN_OFFSET		(PFN_START)
 #define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
@@ -154,8 +160,12 @@
 /*
  * Slub defaults to 8-byte alignment, we're only interested in 4.
  * Slab defaults to BYTES_PER_WORD, which ends up being the same anyways.
+ *
+ * However some drivers need to perform DMA into kmalloc'ed buffers
+ * and so we have to increase the alignment for this.
  */
-#define ARCH_KMALLOC_MINALIGN	4
+/* #define ARCH_KMALLOC_MINALIGN	4 */
+#define ARCH_KMALLOC_MINALIGN	L1_CACHE_BYTES
 #define ARCH_SLAB_MINALIGN	4
 
 #endif /* __KERNEL__ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/param.h linux-2.6.23.1-stm/include/asm-sh/param.h
--- linux-2.6.23.1/include/asm-sh/param.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/param.h	2007-11-01 12:00:40.000000000 +0000
@@ -2,8 +2,8 @@
 #define __ASM_SH_PARAM_H
 
 #ifdef __KERNEL__
-# ifdef CONFIG_SH_WDT
-#  define HZ		1000		/* Needed for high-res WOVF */
+# ifdef CONFIG_SH_FAST_HZ
+#  define HZ		1000
 # else
 #  define HZ		CONFIG_HZ
 # endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/pci.h linux-2.6.23.1-stm/include/asm-sh/pci.h
--- linux-2.6.23.1/include/asm-sh/pci.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/pci.h	2007-11-01 12:00:39.000000000 +0000
@@ -35,6 +35,8 @@
 /*
  * I/O routine helpers
  */
+#ifndef CONFIG_CPU_SUBTYPE_ST40
+
 #if defined(CONFIG_CPU_SUBTYPE_SH7780) || defined(CONFIG_CPU_SUBTYPE_SH7785)
 #define PCI_IO_AREA		0xFE400000
 #define PCI_IO_SIZE		0x00400000
@@ -48,7 +50,9 @@
 #define SH4_PCIIOBR_MASK	0xFFFC0000
 #define pci_ioaddr(addr)	(PCI_IO_AREA + (addr & ~SH4_PCIIOBR_MASK))
 
-#if defined(CONFIG_PCI)
+#endif
+
+#if defined(CONFIG_PCI) && defined(PCI_IO_SIZE)
 #define is_pci_ioaddr(port)		\
 	(((port) >= PCIBIOS_MIN_IO) &&	\
 	 ((port) < (PCIBIOS_MIN_IO + PCI_IO_SIZE)))
@@ -121,7 +125,7 @@
 #endif
 
 /* Board-specific fixup routines. */
-void pcibios_fixup(void);
+// void pcibios_fixup(void); is this still needed? SIM
 int pcibios_init_platform(void);
 int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin);
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/pgtable.h linux-2.6.23.1-stm/include/asm-sh/pgtable.h
--- linux-2.6.23.1/include/asm-sh/pgtable.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/pgtable.h	2007-11-01 12:00:43.000000000 +0000
@@ -42,19 +42,29 @@
 
 /* PGD bits */
 #define PGDIR_SHIFT	(PTE_SHIFT + PTE_BITS)
-#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_SIZE	(1 << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
 /* Entries per level */
 #define PTRS_PER_PTE	(PAGE_SIZE / (1 << PTE_MAGNITUDE))
-#define PTRS_PER_PGD	(PAGE_SIZE / sizeof(pgd_t))
+#define PTRS_PER_PGD	(PAGE_SIZE / 4)
 
 #define USER_PTRS_PER_PGD	(TASK_SIZE/PGDIR_SIZE)
 #define FIRST_USER_ADDRESS	0
 
-#define PTE_PHYS_MASK		(0x20000000 - PAGE_SIZE)
+#ifdef CONFIG_32BIT
+#define PHYS_ADDR_MASK		0xffffffff
+#else
+#define PHYS_ADDR_MASK		0x1fffffff
+#endif
+
+#define PTE_PHYS_MASK		(PHYS_ADDR_MASK & PAGE_MASK)
 
-#define VMALLOC_START	(P3SEG)
+/*
+ * First 1MB map is used by fixed purpose.
+ * Currently only 4-entry (16kB) is used (see arch/sh/mm/cache.c)
+ */
+#define VMALLOC_START  (P3SEG+0x00100000)
 #define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
 
 /*
@@ -78,8 +88,8 @@
  * - Bits 10 and 11 are low bits of the PPN that are reserved on >= 4K pages.
  *   Bit 10 is used for _PAGE_ACCESSED, bit 11 remains unused.
  *
- * - Bits 31, 30, and 29 remain unused by everyone and can be used for future
- *   software flags, although care must be taken to update _PAGE_CLEAR_FLAGS.
+ * - On 29 bit platforms, bits 31 to 29 are used for the space attributes
+ *   and timing control which (together with bit 0) are moved into PTEA.
  *
  * XXX: Leave the _PAGE_FILE and _PAGE_WT overhaul for a rainy day.
  *
@@ -128,6 +138,7 @@
 /* Wrapper for extended mode pgprot twiddling */
 #define _PAGE_EXT(x)		((unsigned long long)(x) << 32)
 
+#ifndef CONFIG_32BIT
 /* software: moves to PTEA.TC (Timing Control) */
 #define _PAGE_PCC_AREA5	0x00000000	/* use BSC registers for area5 */
 #define _PAGE_PCC_AREA6	0x80000000	/* use BSC registers for area6 */
@@ -140,6 +151,7 @@
 #define _PAGE_PCC_COM16	0x40000001	/* Common Memory space, 16 bit bus */
 #define _PAGE_PCC_ATR8	0x60000000	/* Attribute Memory space, 8 bit bus */
 #define _PAGE_PCC_ATR16	0x60000001	/* Attribute Memory space, 6 bit bus */
+#endif
 
 /* Mask which drops unused bits from the PTEL value */
 #if defined(CONFIG_CPU_SH3)
@@ -154,7 +166,7 @@
 #define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED | _PAGE_FILE)
 #endif
 
-#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS))
+#define _PAGE_FLAGS_HARDWARE_MASK	(PHYS_ADDR_MASK & ~(_PAGE_CLEAR_FLAGS))
 
 /* Hardware flags, page size encoding */
 #if defined(CONFIG_X2TLB)
@@ -399,7 +411,7 @@
 #define	pmd_bad(x)	(pmd_val(x) & ~PAGE_MASK)
 
 #define pages_to_mb(x)	((x) >> (20-PAGE_SHIFT))
-#define pte_page(x)	phys_to_page(pte_val(x)&PTE_PHYS_MASK)
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
 
 /*
  * The following only work if pte_present() is true.
@@ -447,12 +459,7 @@
 
 #define pgprot_noncached	 pgprot_writecombine
 
-/*
- * Conversion functions: convert a page and protection to a page entry,
- * and a page entry and page directory to the page they refer to.
- *
- * extern pte_t mk_pte(struct page *page, pgprot_t pgprot)
- */
+/* Convert a page and protection to a page entry */
 #define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
 
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
@@ -575,12 +582,6 @@
 extern unsigned int kobjsize(const void *objp);
 #endif /* !CONFIG_MMU */
 
-#if !defined(CONFIG_CACHE_OFF) && (defined(CONFIG_CPU_SH4) || \
-	defined(CONFIG_SH7705_CACHE_32KB))
-#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
-extern pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep);
-#endif
-
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 extern void paging_init(void);
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/processor.h linux-2.6.23.1-stm/include/asm-sh/processor.h
--- linux-2.6.23.1/include/asm-sh/processor.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/processor.h	2007-11-01 12:00:42.000000000 +0000
@@ -49,7 +49,8 @@
 
 	/* SH-4 types */
 	CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
-	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_SH4_202, CPU_SH4_501,
+	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_STI5528, CPU_STM8000,
+	CPU_STB7100, CPU_STX7200, CPU_SH4_202, CPU_SH4_501,
 
 	/* SH-4A types */
 	CPU_SH7770, CPU_SH7780, CPU_SH7781, CPU_SH7785, CPU_SHX3,
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/setup.h linux-2.6.23.1-stm/include/asm-sh/setup.h
--- linux-2.6.23.1/include/asm-sh/setup.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/setup.h	2007-11-01 12:00:39.000000000 +0000
@@ -1,7 +1,7 @@
 #ifndef _SH_SETUP_H
 #define _SH_SETUP_H
 
-#define COMMAND_LINE_SIZE 256
+#define COMMAND_LINE_SIZE 512
 
 #ifdef __KERNEL__
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/system.h linux-2.6.23.1-stm/include/asm-sh/system.h
--- linux-2.6.23.1/include/asm-sh/system.h	2007-11-01 12:05:13.000000000 +0000
+++ linux-2.6.23.1-stm/include/asm-sh/system.h	2007-11-01 12:00:43.000000000 +0000
@@ -28,6 +28,7 @@
  register unsigned long *__ts6 __asm__ ("r6") = &next->thread.sp;	\
  register unsigned long __ts7 __asm__ ("r7") = next->thread.pc;		\
  __asm__ __volatile__ (".balign 4\n\t" 					\
+		       "__switch_to_begin:\n\t"				\
 		       "stc.l	gbr, @-r15\n\t" 			\
 		       "sts.l	pr, @-r15\n\t" 				\
 		       "mov.l	r8, @-r15\n\t" 				\
@@ -57,6 +58,7 @@
 		       "mov.l	@r15+, r8\n\t"				\
 		       "lds.l	@r15+, pr\n\t"				\
 		       "ldc.l	@r15+, gbr\n\t"				\
+		       "__switch_to_end:\n\t"				\
 		       : "=z" (__last)					\
 		       : "r" (__ts1), "r" (__ts2), "r" (__ts4), 	\
 			 "r" (__ts5), "r" (__ts6), "r" (__ts7) 		\
@@ -118,29 +120,30 @@
 
 #define set_mb(var, value) do { (void)xchg(&var, value); } while (0)
 
+extern unsigned long cached_to_uncached;
+
 /*
- * Jump to P2 area.
- * When handling TLB or caches, we need to do it from P2 area.
+ * Jump to uncached area.
+ * When handling TLB or caches, we need to do it from an uncached area.
  */
-#define jump_to_P2()			\
-do {					\
-	unsigned long __dummy;		\
-	__asm__ __volatile__(		\
-		"mov.l	1f, %0\n\t"	\
-		"or	%1, %0\n\t"	\
-		"jmp	@%0\n\t"	\
-		" nop\n\t" 		\
-		".balign 4\n"		\
-		"1:	.long 2f\n"	\
-		"2:"			\
-		: "=&r" (__dummy)	\
-		: "r" (0x20000000));	\
+#define jump_to_uncached()			\
+do {						\
+	unsigned long __dummy;			\
+	__asm__ __volatile__(			\
+		"mova	1f, %0\n\t"		\
+		"add	%1, %0\n\t"		\
+		"jmp	@%0\n\t"		\
+		" nop\n\t" 			\
+		".balign 4\n"			\
+		"1:"				\
+		: "=&z" (__dummy)		\
+		: "r" (cached_to_uncached));	\
 } while (0)
 
 /*
- * Back to P1 area.
+ * Back to cached area.
  */
-#define back_to_P1()					\
+#define back_to_cached()				\
 do {							\
 	unsigned long __dummy;				\
 	ctrl_barrier();					\
@@ -154,6 +157,50 @@
 		: "=&r" (__dummy));			\
 } while (0)
 
+#define __uses_jump_to_uncached __attribute__ ((__section__ (".uncached")))
+
+#if defined(CONFIG_SH_GRB)
+static inline unsigned long xchg_u32(volatile u32 * m, unsigned long val)
+{
+       unsigned long retval;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   nop                   \n\t"
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-4,   r15     \n\t" // LOGIN
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   mov.l   %2,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval),  // 0
+                  "+r"  (m)        // 1
+                : "r"   (val)      // 2
+                : "memory", "r0", "r1" );
+
+        return retval;
+}
+
+static inline unsigned long xchg_u8(volatile u8 * m, unsigned long
+ val)
+{
+       unsigned long retval;
+
+        asm volatile(
+	       "   .align  2             \n\t"
+               "   mova    1f,   r0      \n\t" // r0 = end point
+	       "   mov    r15,   r1      \n\t" // r1 = saved sp
+               "   mov    #-6,   r15     \n\t" // LOGIN
+               "   mov.b  @%1,   %0      \n\t" // load  old value
+               "   extu.b  %0,   %0      \n\t" // extend as unsigned
+               "   mov.b   %2,   @%1     \n\t" // store new value
+               "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval), // 0
+                  "+r"  (m)       // 1
+                : "r"   (val)     // 2
+                : "memory" , "r0", "r1");
+        return retval ;
+}
+#else
 static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
 {
 	unsigned long flags, retval;
@@ -175,6 +222,7 @@
 	local_irq_restore(flags);
 	return retval;
 }
+#endif
 
 extern void __xchg_called_with_bad_pointer(void);
 
@@ -201,6 +249,29 @@
 #define xchg(ptr,x)	\
 	((__typeof__(*(ptr)))__xchg((ptr),(unsigned long)(x), sizeof(*(ptr))))
 
+#if defined(CONFIG_SH_GRB)
+static inline unsigned long __cmpxchg_u32(volatile u32 * m, unsigned long old,
+        unsigned long new)
+{
+       unsigned long retval;
+        asm volatile(
+               "   .align  2             \n\t"
+               "   mova    1f,   r0      \n\t" // r0 = end point
+               "   nop                   \n\t"
+               "   mov    r15,   r1      \n\t" // r1 = saved sp
+               "   mov    #-8,   r15     \n\t" // LOGIN
+               "   mov.l  @%1,   %0      \n\t" // load  old value
+               "   cmp/eq  %0,   %2      \n\t" //
+               "   bf            1f      \n\t" // if not equal
+               "   mov.l   %2,   @%1     \n\t" // store new value
+               "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval),  // 0
+                  "+r"  (m)        // 1
+                : "r"   (new)      // 2
+                : "memory" , "r0", "r1", "t");
+        return retval;
+}
+#else
 static inline unsigned long __cmpxchg_u32(volatile int * m, unsigned long old,
 	unsigned long new)
 {
@@ -214,6 +285,7 @@
 	local_irq_restore(flags);       /* implies memory barrier  */
 	return retval;
 }
+#endif
 
 /* This function doesn't exist, so you'll get a linker error
  * if something tries to do an invalid cmpxchg(). */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/uaccess.h linux-2.6.23.1-stm/include/asm-sh/uaccess.h
--- linux-2.6.23.1/include/asm-sh/uaccess.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/uaccess.h	2007-11-01 12:00:42.000000000 +0000
@@ -73,37 +73,24 @@
 /*
  * __access_ok: Check if address with size is OK or not.
  *
- * We do three checks:
- * (1) is it user space?
- * (2) addr + size --> carry?
- * (3) addr + size >= 0x80000000  (PAGE_OFFSET)
- *
- * (1) (2) (3) | RESULT
- *  0   0   0  |  ok
- *  0   0   1  |  ok
- *  0   1   0  |  bad
- *  0   1   1  |  bad
- *  1   0   0  |  ok
- *  1   0   1  |  bad
- *  1   1   0  |  bad
- *  1   1   1  |  bad
+ * Uhhuh, this needs 33-bit arithmetic. We have a carry..
+ *
+ * sum := addr + size;  carry? --> flag = true;
+ * if (sum >= addr_limit) flag = true;
  */
 static inline int __access_ok(unsigned long addr, unsigned long size)
 {
-	unsigned long flag, tmp;
-
-	__asm__("stc	r7_bank, %0\n\t"
-		"mov.l	@(8,%0), %0\n\t"
-		"clrt\n\t"
-		"addc	%2, %1\n\t"
-		"and	%1, %0\n\t"
-		"rotcl	%0\n\t"
-		"rotcl	%0\n\t"
-		"and	#3, %0"
-		: "=&z" (flag), "=r" (tmp)
-		: "r" (addr), "1" (size)
-		: "t");
+	unsigned long flag, sum;
 
+	__asm__("clrt\n\t"
+		"addc	%3, %1\n\t"
+		"movt	%0\n\t"
+		"cmp/hi	%4, %1\n\t"
+		"rotcl	%0"
+		:"=&r" (flag), "=r" (sum)
+		:"1" (addr), "r" (size),
+		 "r" (current_thread_info()->addr_limit.seg)
+		:"t");
 	return flag == 0;
 }
 #endif /* CONFIG_MMU */
@@ -170,130 +157,40 @@
 	__gu_err;						\
 })
 
-#ifdef CONFIG_MMU
-#define __get_user_check(x,ptr,size)				\
-({								\
-	long __gu_err, __gu_val;				\
-	__chk_user_ptr(ptr);					\
-	switch (size) {						\
-	case 1:							\
-		__get_user_1(__gu_val, (ptr), __gu_err);	\
-		break;						\
-	case 2:							\
-		__get_user_2(__gu_val, (ptr), __gu_err);	\
-		break;						\
-	case 4:							\
-		__get_user_4(__gu_val, (ptr), __gu_err);	\
-		break;						\
-	default:						\
-		__get_user_unknown();				\
-		break;						\
-	}							\
-								\
-	(x) = (__typeof__(*(ptr)))__gu_val;			\
-	__gu_err;						\
-})
-
-#define __get_user_1(x,addr,err) ({		\
-__asm__("stc	r7_bank, %1\n\t"		\
-	"mov.l	@(8,%1), %1\n\t"		\
-	"and	%2, %1\n\t"			\
-	"cmp/pz	%1\n\t"				\
-	"bt/s	1f\n\t"				\
-	" mov	#0, %0\n\t"			\
-	"0:\n"					\
-	"mov	#-14, %0\n\t"			\
-	"bra	2f\n\t"				\
-	" mov	#0, %1\n"			\
-	"1:\n\t"				\
-	"mov.b	@%2, %1\n\t"			\
-	"extu.b	%1, %1\n"			\
-	"2:\n"					\
-	".section	__ex_table,\"a\"\n\t"	\
-	".long	1b, 0b\n\t"			\
-	".previous"				\
-	: "=&r" (err), "=&r" (x)		\
-	: "r" (addr)				\
-	: "t");					\
-})
-
-#define __get_user_2(x,addr,err) ({		\
-__asm__("stc	r7_bank, %1\n\t"		\
-	"mov.l	@(8,%1), %1\n\t"		\
-	"and	%2, %1\n\t"			\
-	"cmp/pz	%1\n\t"				\
-	"bt/s	1f\n\t"				\
-	" mov	#0, %0\n\t"			\
-	"0:\n"					\
-	"mov	#-14, %0\n\t"			\
-	"bra	2f\n\t"				\
-	" mov	#0, %1\n"			\
-	"1:\n\t"				\
-	"mov.w	@%2, %1\n\t"			\
-	"extu.w	%1, %1\n"			\
-	"2:\n"					\
-	".section	__ex_table,\"a\"\n\t"	\
-	".long	1b, 0b\n\t"			\
-	".previous"				\
-	: "=&r" (err), "=&r" (x)		\
-	: "r" (addr)				\
-	: "t");					\
-})
-
-#define __get_user_4(x,addr,err) ({		\
-__asm__("stc	r7_bank, %1\n\t"		\
-	"mov.l	@(8,%1), %1\n\t"		\
-	"and	%2, %1\n\t"			\
-	"cmp/pz	%1\n\t"				\
-	"bt/s	1f\n\t"				\
-	" mov	#0, %0\n\t"			\
-	"0:\n"					\
-	"mov	#-14, %0\n\t"			\
-	"bra	2f\n\t"				\
-	" mov	#0, %1\n"			\
-	"1:\n\t"				\
-	"mov.l	@%2, %1\n\t"			\
-	"2:\n"					\
-	".section	__ex_table,\"a\"\n\t"	\
-	".long	1b, 0b\n\t"			\
-	".previous"				\
-	: "=&r" (err), "=&r" (x)		\
-	: "r" (addr)				\
-	: "t");					\
-})
-#else /* CONFIG_MMU */
 #define __get_user_check(x,ptr,size)					\
 ({									\
 	long __gu_err, __gu_val;					\
-	if (__access_ok((unsigned long)(ptr), (size))) {		\
+	__chk_user_ptr(ptr);						\
+	if (likely(__addr_ok((unsigned long)(ptr)))) {			\
 		__get_user_size(__gu_val, (ptr), (size), __gu_err);	\
-		(x) = (__typeof__(*(ptr)))__gu_val;			\
-	} else								\
+	} else {							\
 		__gu_err = -EFAULT;					\
+		__gu_val = 0;						\
+	}								\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
 	__gu_err;							\
 })
-#endif
 
 #define __get_user_asm(x, addr, err, insn) \
 ({ \
 __asm__ __volatile__( \
 	"1:\n\t" \
 	"mov." insn "	%2, %1\n\t" \
-	"mov	#0, %0\n" \
 	"2:\n" \
 	".section	.fixup,\"ax\"\n" \
 	"3:\n\t" \
 	"mov	#0, %1\n\t" \
 	"mov.l	4f, %0\n\t" \
 	"jmp	@%0\n\t" \
-	" mov	%3, %0\n" \
+	" mov	%3, %0\n\t" \
+	".balign	4\n" \
 	"4:	.long	2b\n\t" \
 	".previous\n" \
 	".section	__ex_table,\"a\"\n\t" \
 	".long	1b, 3b\n\t" \
 	".previous" \
 	:"=&r" (err), "=&r" (x) \
-	:"m" (__m(addr)), "i" (-EFAULT)); })
+	:"m" (__m(addr)), "i" (-EFAULT), "0" (err)); })
 
 extern void __get_user_unknown(void);
 
@@ -328,11 +225,13 @@
 
 #define __put_user_check(x,ptr,size)				\
 ({								\
-	long __pu_err = -EFAULT;				\
+	long __pu_err;						\
 	__typeof__(*(ptr)) __user *__pu_addr = (ptr);		\
 								\
-	if (__access_ok((unsigned long)__pu_addr,size))		\
+	if (likely(__addr_ok((unsigned long)__pu_addr)))	\
 		__put_user_size((x),__pu_addr,(size),__pu_err);	\
+	else							\
+		__pu_err = -EFAULT;				\
 	__pu_err;						\
 })
 
@@ -341,21 +240,20 @@
 __asm__ __volatile__( \
 	"1:\n\t" \
 	"mov." insn "	%1, %2\n\t" \
-	"mov	#0, %0\n" \
 	"2:\n" \
 	".section	.fixup,\"ax\"\n" \
 	"3:\n\t" \
-	"nop\n\t" \
 	"mov.l	4f, %0\n\t" \
 	"jmp	@%0\n\t" \
-	"mov	%3, %0\n" \
+	" mov	%3, %0\n\t" \
+	".balign	4\n" \
 	"4:	.long	2b\n\t" \
 	".previous\n" \
 	".section	__ex_table,\"a\"\n\t" \
 	".long	1b, 3b\n\t" \
 	".previous" \
 	:"=&r" (err) \
-	:"r" (x), "m" (__m(addr)), "i" (-EFAULT) \
+	:"r" (x), "m" (__m(addr)), "i" (-EFAULT), "0" (err)	\
         :"memory"); })
 
 #if defined(__LITTLE_ENDIAN__)
@@ -365,21 +263,20 @@
 	"1:\n\t" \
 	"mov.l	%R1,%2\n\t" \
 	"mov.l	%S1,%T2\n\t" \
-	"mov	#0,%0\n" \
 	"2:\n" \
 	".section	.fixup,\"ax\"\n" \
 	"3:\n\t" \
-	"nop\n\t" \
 	"mov.l	4f,%0\n\t" \
 	"jmp	@%0\n\t" \
-	" mov	%3,%0\n" \
+	" mov	%3,%0\n\t" \
+	".balign	4\n" \
 	"4:	.long	2b\n\t" \
 	".previous\n" \
 	".section	__ex_table,\"a\"\n\t" \
 	".long	1b, 3b\n\t" \
 	".previous" \
 	: "=r" (retval) \
-	: "r" (val), "m" (__m(addr)), "i" (-EFAULT) \
+	: "r" (val), "m" (__m(addr)), "i" (-EFAULT), "0" (retval) \
         : "memory"); })
 #else
 #define __put_user_u64(val,addr,retval) \
@@ -388,21 +285,20 @@
 	"1:\n\t" \
 	"mov.l	%S1,%2\n\t" \
 	"mov.l	%R1,%T2\n\t" \
-	"mov	#0,%0\n" \
 	"2:\n" \
 	".section	.fixup,\"ax\"\n" \
 	"3:\n\t" \
-	"nop\n\t" \
 	"mov.l	4f,%0\n\t" \
 	"jmp	@%0\n\t" \
-	" mov	%3,%0\n" \
+	" mov	%3,%0\n\t" \
+	".balign	4\n" \
 	"4:	.long	2b\n\t" \
 	".previous\n" \
 	".section	__ex_table,\"a\"\n\t" \
 	".long	1b, 3b\n\t" \
 	".previous" \
 	: "=r" (retval) \
-	: "r" (val), "m" (__m(addr)), "i" (-EFAULT) \
+	: "r" (val), "m" (__m(addr)), "i" (-EFAULT), "0" (retval) \
         : "memory"); })
 #endif
 
@@ -463,7 +359,7 @@
 __strncpy_from_user(unsigned long __dest, unsigned long __user __src, int __count)
 {
 	__kernel_size_t res;
-	unsigned long __dummy, _d, _s;
+	unsigned long __dummy, _d, _s, _c;
 
 	__asm__ __volatile__(
 		"9:\n"
@@ -472,17 +368,17 @@
 		"bt/s	2f\n"
 		"1:\n"
 		"mov.b	%1, @%3\n\t"
-		"dt	%7\n\t"
+		"dt	%4\n\t"
 		"bf/s	9b\n\t"
 		" add	#1, %3\n\t"
 		"2:\n\t"
-		"sub	%7, %0\n"
+		"sub	%4, %0\n"
 		"3:\n"
 		".section .fixup,\"ax\"\n"
 		"4:\n\t"
 		"mov.l	5f, %1\n\t"
 		"jmp	@%1\n\t"
-		" mov	%8, %0\n\t"
+		" mov	%9, %0\n\t"
 		".balign 4\n"
 		"5:	.long 3b\n"
 		".previous\n"
@@ -490,14 +386,32 @@
 		"	.balign 4\n"
 		"	.long 9b,4b\n"
 		".previous"
-		: "=r" (res), "=&z" (__dummy), "=r" (_s), "=r" (_d)
-		: "0" (__count), "2" (__src), "3" (__dest), "r" (__count),
+		: "=r" (res), "=&z" (__dummy), "=r" (_s), "=r" (_d), "=r"(_c)
+		: "0" (__count), "2" (__src), "3" (__dest), "4" (__count),
 		  "i" (-EFAULT)
 		: "memory", "t");
 
 	return res;
 }
 
+/**
+ * strncpy_from_user: - Copy a NUL terminated string from userspace.
+ * @dst:   Destination address, in kernel space.  This buffer must be at
+ *         least @count bytes long.
+ * @src:   Source address, in user space.
+ * @count: Maximum number of bytes to copy, including the trailing NUL.
+ *
+ * Copies a NUL-terminated string from userspace to kernel space.
+ *
+ * On success, returns the length of the string (not including the trailing
+ * NUL).
+ *
+ * If access to userspace fails, returns -EFAULT (some data may have been
+ * copied).
+ *
+ * If @count is smaller than the length of the string, copies @count bytes
+ * and returns @count.
+ */
 #define strncpy_from_user(dest,src,count) ({ \
 unsigned long __sfu_src = (unsigned long) (src); \
 int __sfu_count = (int) (count); \
@@ -507,7 +421,8 @@
 } __sfu_res; })
 
 /*
- * Return the size of a string (including the ending 0!)
+ * Return the size of a string (including the ending 0 even when we have
+ * exceeded the maximum string length).
  */
 static __inline__ long __strnlen_user(const char __user *__s, long __n)
 {
@@ -515,14 +430,13 @@
 	unsigned long __dummy;
 
 	__asm__ __volatile__(
-		"9:\n"
-		"cmp/eq	%4, %0\n\t"
-		"bt	2f\n"
 		"1:\t"
 		"mov.b	@(%0,%3), %1\n\t"
+		"cmp/eq	%4, %0\n\t"
+		"bt/s	2f\n\t"
+		" add	#1, %0\n\t"
 		"tst	%1, %1\n\t"
-		"bf/s	9b\n\t"
-		" add	#1, %0\n"
+		"bf	1b\n\t"
 		"2:\n"
 		".section .fixup,\"ax\"\n"
 		"3:\n\t"
@@ -542,6 +456,19 @@
 	return res;
 }
 
+/**
+ * strnlen_user: - Get the size of a string in user space.
+ * @s: The string to measure.
+ * @n: The maximum valid length
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Get the size of a NUL-terminated string in user space.
+ *
+ * Returns the size of the string INCLUDING the terminating NUL.
+ * On exception, returns 0.
+ * If the string is too long, returns a value greater than @n.
+ */
 static __inline__ long strnlen_user(const char __user *s, long n)
 {
 	if (!__addr_ok(s))
@@ -550,6 +477,20 @@
 		return __strnlen_user(s, n);
 }
 
+/**
+ * strlen_user: - Get the size of a string in user space.
+ * @str: The string to measure.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Get the size of a NUL-terminated string in user space.
+ *
+ * Returns the size of the string INCLUDING the terminating NUL.
+ * On exception, returns 0.
+ *
+ * If there is a limit on the length of a valid string, you may wish to
+ * consider using strnlen_user() instead.
+ */
 #define strlen_user(str)	strnlen_user(str, ~0UL >> 1)
 
 /*
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/asm-sh/unistd.h linux-2.6.23.1-stm/include/asm-sh/unistd.h
--- linux-2.6.23.1/include/asm-sh/unistd.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/asm-sh/unistd.h	2007-11-01 12:00:40.000000000 +0000
@@ -132,7 +132,7 @@
 #define __NR_clone		120
 #define __NR_setdomainname	121
 #define __NR_uname		122
-#define __NR_modify_ldt		123
+#define __NR_cacheflush		123
 #define __NR_adjtimex		124
 #define __NR_mprotect		125
 #define __NR_sigprocmask	126
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/bpa2.h linux-2.6.23.1-stm/include/linux/bpa2.h
--- linux-2.6.23.1/include/linux/bpa2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/bpa2.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Derived from mm/bigphysarea.c which was:
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?)
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ */
+
+#ifndef __LINUX_BPA2_H
+#define __LINUX_BPA2_H
+
+#include <linux/types.h>
+
+struct bpa2_partition_desc {
+	const char* name;
+	unsigned long start;
+	unsigned long size;
+	unsigned long flags;
+	const char** aka;
+};
+
+struct bpa2_part;
+
+void bpa2_init(struct bpa2_partition_desc* partdescs, int nparts);
+struct bpa2_part* bpa2_find_part(const char* name);
+int bpa2_low_part(struct bpa2_part* part);
+unsigned long bpa2_alloc_pages(struct bpa2_part *part, int count, int align, int priority);
+void bpa2_free_pages(struct bpa2_part *part, unsigned long base);
+
+/* Backward compatibility APIs */
+
+/* original interface */
+caddr_t	bigphysarea_alloc(int size);
+void	bigphysarea_free(caddr_t addr, int size);
+
+/* new interface */
+caddr_t	bigphysarea_alloc_pages(int count, int align, int priority);
+void	bigphysarea_free_pages(caddr_t base);
+
+/* low level interface */
+void     bigphysarea_memory(unsigned long *base, unsigned long *size);
+
+#endif /* __LINUX_BPA2_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/cdrom.h linux-2.6.23.1-stm/include/linux/cdrom.h
--- linux-2.6.23.1/include/linux/cdrom.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/cdrom.h	2007-11-01 12:00:41.000000000 +0000
@@ -1008,8 +1008,12 @@
 extern int cdrom_mode_sense(struct cdrom_device_info *cdi,
 			    struct packet_command *cgc,
 			    int page_code, int page_control);
-extern void init_cdrom_command(struct packet_command *cgc,
-			       void *buffer, int len, int type);
+extern int init_cdrom_command(struct packet_command *cgc,
+			      int len, int type);
+extern void cleanup_cdrom_command(struct packet_command *cgc);
+#define DECLARE_PACKET_COMMAND(cgc) \
+	struct packet_command cgc __attribute__((cleanup(cleanup_cdrom_command))) = \
+	{ .buffer = NULL }
 
 /* The SCSI spec says there could be 256 slots. */
 #define CDROM_MAX_SLOTS	256
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/console_splash.h linux-2.6.23.1-stm/include/linux/console_splash.h
--- linux-2.6.23.1/include/linux/console_splash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/console_splash.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,13 @@
+#ifndef _LINUX_CONSOLE_SPLASH_H_
+#define _LINUX_CONSOLE_SPLASH_H_ 1
+
+/* A structure used by the framebuffer splash code (drivers/video/fbsplash.c) */
+struct vc_splash {
+	__u8 bg_color;				/* The color that is to be treated as transparent */
+	__u8 state;				/* Current splash state: 0 = off, 1 = on */
+	__u16 tx, ty;				/* Top left corner coordinates of the text field */
+	__u16 twidth, theight;			/* Width and height of the text field */
+	char* theme;
+};
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/console_struct.h linux-2.6.23.1-stm/include/linux/console_struct.h
--- linux-2.6.23.1/include/linux/console_struct.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/console_struct.h	2007-11-01 12:00:41.000000000 +0000
@@ -19,6 +19,7 @@
 struct vt_struct;
 
 #define NPAR 16
+#include <linux/console_splash.h>
 
 struct vc_data {
 	unsigned short	vc_num;			/* Console number */
@@ -105,6 +106,8 @@
 	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
 	unsigned long	vc_uni_pagedir;
 	unsigned long	*vc_uni_pagedir_loc;  /* [!] Location of uni_pagedir variable for this console */
+
+	struct vc_splash vc_splash;
 	/* additional information is in vt_kern.h */
 };
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/fb.h linux-2.6.23.1-stm/include/linux/fb.h
--- linux-2.6.23.1/include/linux/fb.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/fb.h	2007-11-01 12:00:41.000000000 +0000
@@ -11,6 +11,13 @@
 #define FB_MAJOR		29
 #define FB_MAX			32	/* sufficient for now */
 
+struct fb_splash_iowrapper
+{
+	unsigned short vc;		/* Virtual console */
+	unsigned char origin;		/* Point of origin of the request */
+	void *data;
+};
+
 /* ioctls
    0x46 is 'F'								*/
 #define FBIOGET_VSCREENINFO	0x4600
@@ -38,7 +45,15 @@
 #define FBIOGET_HWCINFO         0x4616
 #define FBIOPUT_MODEINFO        0x4617
 #define FBIOGET_DISPINFO        0x4618
-
+#define FBIOSPLASH_SETCFG	_IOWR('F', 0x19, struct fb_splash_iowrapper)
+#define FBIOSPLASH_GETCFG	_IOR('F', 0x1A, struct fb_splash_iowrapper)
+#define FBIOSPLASH_SETSTATE	_IOWR('F', 0x1B, struct fb_splash_iowrapper)
+#define FBIOSPLASH_GETSTATE	_IOR('F', 0x1C, struct fb_splash_iowrapper)
+#define FBIOSPLASH_SETPIC 	_IOWR('F', 0x1D, struct fb_splash_iowrapper)
+
+#define FB_SPLASH_THEME_LEN		128	/* Maximum lenght of a theme name */
+#define FB_SPLASH_IO_ORIG_KERNEL	0	/* Kernel ioctl origin */
+#define FB_SPLASH_IO_ORIG_USER		1 	/* User ioctl origin */
 
 #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
 #define FB_TYPE_PLANES			1	/* Non interleaved planes */
@@ -831,6 +846,9 @@
 #define FBINFO_STATE_SUSPENDED	1
 	u32 state;			/* Hardware state i.e suspend */
 	void *fbcon_par;                /* fbcon use-only private area */
+
+	struct fb_image splash;
+
 	/* From here on everything is device dependent */
 	void *par;	
 };
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/i2c-id.h linux-2.6.23.1-stm/include/linux/i2c-id.h
--- linux-2.6.23.1/include/linux/i2c-id.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/i2c-id.h	2007-11-01 12:00:43.000000000 +0000
@@ -196,6 +196,7 @@
 #define I2C_HW_B_EM28XX		0x01001f /* em28xx video capture cards */
 #define I2C_HW_B_CX2341X	0x010020 /* Conexant CX2341X MPEG encoder cards */
 #define I2C_HW_B_INTELFB	0x010021 /* intel framebuffer driver */
+#define I2C_HW_B_ST40_PIO	0x010022 /* STMicroelectronics ST40 parts */
 
 /* --- PCF 8584 based algorithms					*/
 #define I2C_HW_P_LP		0x020000 /* Parallel port interface */
@@ -263,6 +264,7 @@
 /* --- Embedded adapters */
 #define I2C_HW_MV64XXX		0x190000
 #define I2C_HW_BLACKFIN		0x190001 /* ADI Blackfin I2C TWI driver */
+#define	I2C_HW_STM_SSC		0x190002 /* STMicroelectronics Synchronous Serial Ctrlr */
 
 /* --- Miscellaneous adapters */
 #define I2C_HW_SAA7146		0x060000 /* SAA7146 video decoder bus */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/libata.h linux-2.6.23.1-stm/include/linux/libata.h
--- linux-2.6.23.1/include/linux/libata.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/libata.h	2007-11-01 12:00:40.000000000 +0000
@@ -641,6 +641,11 @@
 
 	void (*bmdma_stop) (struct ata_queued_cmd *qc);
 	u8   (*bmdma_status) (struct ata_port *ap);
+
+	unsigned char (*readb)(const volatile void __iomem *addr);
+	unsigned short (*readw)(const volatile void __iomem *addr);
+	void (*writeb)(unsigned char b, volatile void __iomem *addr);
+	void (*writew)(unsigned short b, volatile void __iomem *addr);
 };
 
 struct ata_port_info {
@@ -689,6 +694,58 @@
 	return ap->ops == &ata_dummy_port_ops;
 }
 
+static inline u8 sata_readb(struct ata_port *ap,
+			    const volatile void __iomem *addr)
+{
+	u8 r;
+	if (ap->ops->readb)
+		r = (ap->ops->readb)(addr);
+	else
+		r = readb(addr);
+
+	return r;
+}
+
+static inline u16 sata_readw(struct ata_port *ap,
+			     const volatile void __iomem *addr)
+{
+	u16 r;
+	if (ap->ops->readw)
+		r = (ap->ops->readw)(addr);
+	else
+		r = readw(addr);
+
+	return r;
+}
+
+static inline void sata_writeb(struct ata_port *ap,
+			       u8 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writeb)
+		(ap->ops->writeb)(b, addr);
+	else
+		writeb(b, addr);
+}
+
+static inline void sata_writew(struct ata_port *ap,
+			       u16 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writew)
+		(ap->ops->writew)(b, addr);
+	else
+		writew(b, addr);
+}
+
+#undef readb
+#define readb(a_)	sata_readb(ap, a_)
+#undef writeb
+#define writeb(v_,a_)	sata_writeb(ap, v_, a_)
+#undef readw
+#define readw(a_)	sata_readw(ap, a_)
+#undef writew
+#define writew(v_,a_)	sata_writew(ap, v_, a_)
+
+
 extern void sata_print_link_status(struct ata_port *ap);
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/lirc.h linux-2.6.23.1-stm/include/linux/lirc.h
--- linux-2.6.23.1/include/linux/lirc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/lirc.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,109 @@
+/*      $Id: lirc.h,v 5.12 2007/04/14 15:57:21 lirc Exp $      */
+
+#ifndef _LINUX_LIRC_H
+#define _LINUX_LIRC_H
+
+#if defined (__linux__)
+#include <asm/types.h>
+#include <linux/ioctl.h>
+#else
+#include <sys/types.h>
+#if defined (__NetBSD__)
+#include <sys/ioctl.h>
+#endif
+typedef u_int32_t __u32;
+#endif
+
+#define PULSE_BIT  0x01000000
+#define PULSE_MASK 0x00FFFFFF
+
+typedef int lirc_t;
+
+/*
+ * lirc compatible hardware features
+ */
+
+
+#define LIRC_MODE2SEND(x) (x)
+#define LIRC_SEND2MODE(x) (x)
+#define LIRC_MODE2REC(x) ((x) << 16)
+#define LIRC_REC2MODE(x) ((x) >> 16)
+
+#define LIRC_MODE_RAW                  0x00000001
+#define LIRC_MODE_PULSE                0x00000002
+#define LIRC_MODE_MODE2                0x00000004
+#define LIRC_MODE_CODE                 0x00000008
+#define LIRC_MODE_LIRCCODE             0x00000010
+#define LIRC_MODE_STRING               0x00000020
+
+
+#define LIRC_CAN_SEND_RAW              LIRC_MODE2SEND(LIRC_MODE_RAW)
+#define LIRC_CAN_SEND_PULSE            LIRC_MODE2SEND(LIRC_MODE_PULSE)
+#define LIRC_CAN_SEND_MODE2            LIRC_MODE2SEND(LIRC_MODE_MODE2)
+#define LIRC_CAN_SEND_CODE             LIRC_MODE2SEND(LIRC_MODE_CODE)
+#define LIRC_CAN_SEND_LIRCCODE         LIRC_MODE2SEND(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_SEND_STRING           LIRC_MODE2SEND(LIRC_MODE_STRING)
+
+#define LIRC_CAN_SEND_MASK             0x0000003f
+
+#define LIRC_CAN_SET_SEND_CARRIER      0x00000100
+#define LIRC_CAN_SET_SEND_DUTY_CYCLE   0x00000200
+#define LIRC_CAN_SET_TRANSMITTER_MASK  0x00000400
+
+#define LIRC_CAN_REC_RAW               LIRC_MODE2REC(LIRC_MODE_RAW)
+#define LIRC_CAN_REC_PULSE             LIRC_MODE2REC(LIRC_MODE_PULSE)
+#define LIRC_CAN_REC_MODE2             LIRC_MODE2REC(LIRC_MODE_MODE2)
+#define LIRC_CAN_REC_CODE              LIRC_MODE2REC(LIRC_MODE_CODE)
+#define LIRC_CAN_REC_LIRCCODE          LIRC_MODE2REC(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_REC_STRING            LIRC_MODE2REC(LIRC_MODE_STRING)
+
+#define LIRC_CAN_REC_MASK              LIRC_MODE2REC(LIRC_CAN_SEND_MASK)
+
+#define LIRC_CAN_SET_REC_CARRIER       (LIRC_CAN_SET_SEND_CARRIER << 16)
+#define LIRC_CAN_SET_REC_DUTY_CYCLE    (LIRC_CAN_SET_SEND_DUTY_CYCLE << 16)
+
+#define LIRC_CAN_SET_REC_DUTY_CYCLE_RANGE 0x40000000
+#define LIRC_CAN_SET_REC_CARRIER_RANGE    0x80000000
+
+#define LIRC_CAN_SEND(x) ((x)&LIRC_CAN_SEND_MASK)
+#define LIRC_CAN_REC(x) ((x)&LIRC_CAN_REC_MASK)
+
+#define LIRC_CAN_NOTIFY_DECODE            0x01000000
+
+/*
+ * IOCTL commands for lirc driver
+ */
+
+#define LIRC_GET_FEATURES              _IOR('i', 0x00000000, __u32)
+
+#define LIRC_GET_SEND_MODE             _IOR('i', 0x00000001, __u32)
+#define LIRC_GET_REC_MODE              _IOR('i', 0x00000002, __u32)
+#define LIRC_GET_SEND_CARRIER          _IOR('i', 0x00000003, __u32)
+#define LIRC_GET_REC_CARRIER           _IOR('i', 0x00000004, __u32)
+#define LIRC_GET_SEND_DUTY_CYCLE       _IOR('i', 0x00000005, __u32)
+#define LIRC_GET_REC_DUTY_CYCLE        _IOR('i', 0x00000006, __u32)
+#define LIRC_GET_REC_RESOLUTION        _IOR('i', 0x00000007, __u32)
+
+/* code length in bits, currently only for LIRC_MODE_LIRCCODE */
+#define LIRC_GET_LENGTH                _IOR('i', 0x0000000f, __u32)
+
+#define LIRC_SET_SEND_MODE             _IOW('i', 0x00000011, __u32)
+#define LIRC_SET_REC_MODE              _IOW('i', 0x00000012, __u32)
+/* Note: these can reset the according pulse_width */
+#define LIRC_SET_SEND_CARRIER          _IOW('i', 0x00000013, __u32)
+#define LIRC_SET_REC_CARRIER           _IOW('i', 0x00000014, __u32)
+#define LIRC_SET_SEND_DUTY_CYCLE       _IOW('i', 0x00000015, __u32)
+#define LIRC_SET_REC_DUTY_CYCLE        _IOW('i', 0x00000016, __u32)
+#define LIRC_SET_TRANSMITTER_MASK      _IOW('i', 0x00000017, __u32)
+
+/* to set a range use
+   LIRC_SET_REC_DUTY_CYCLE_RANGE/LIRC_SET_REC_CARRIER_RANGE with the
+   lower bound first and later
+   LIRC_SET_REC_DUTY_CYCLE/LIRC_SET_REC_CARRIER with the upper bound */
+
+#define LIRC_SET_REC_DUTY_CYCLE_RANGE  _IOW('i', 0x0000001e, __u32)
+#define LIRC_SET_REC_CARRIER_RANGE     _IOW('i', 0x0000001f, __u32)
+
+#define LIRC_NOTIFY_DECODE             _IO('i', 0x00000020)
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/serial_core.h linux-2.6.23.1-stm/include/linux/serial_core.h
--- linux-2.6.23.1/include/linux/serial_core.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/serial_core.h	2007-11-01 12:00:39.000000000 +0000
@@ -147,6 +147,9 @@
 #define PORT_SB1250_DUART	77
 
 
+/* ST ASC type numbers */
+#define PORT_ASC	78
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
diff -x .gitignore -Nurp linux-2.6.23/include/linux/squashfs_fs.h linux-2.6.23-squashfs3.3/include/linux/squashfs_fs.h
--- linux-2.6.23/include/linux/squashfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/include/linux/squashfs_fs.h	2007-11-01 03:50:57.000000000 +0000
@@ -0,0 +1,935 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			1
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		131072
+#define SQUASHFS_FILE_LOG		17
+
+#define SQUASHFS_FILE_MAX_SIZE		1048576
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_EXPORT			7
+
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_EXPORT)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking, exortable)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6) | (exportable << 7))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+		(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)	(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* inode lookup table defines */
+#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode_t))
+
+#define SQUASHFS_LOOKUP_BLOCK(A)		(SQUASHFS_LOOKUP_BYTES(A) / \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_OFFSET(A)		(SQUASHFS_LOOKUP_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCKS(A)	((SQUASHFS_LOOKUP_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_BYTES(A)	(SQUASHFS_LOOKUP_BLOCKS(A) *\
+					sizeof(long long))
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
+
+struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode_t	root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		lookup_table_start;
+} __attribute__ ((packed));
+
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		i_count:16;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
+	
+struct squashfs_dir_entry {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	int			inode_number:16;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_header {
+	unsigned int		count:8;
+	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
+	unsigned int		size;
+	unsigned int		pending;
+} __attribute__ ((packed));
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 888, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_INODE_T(s, d) SQUASHFS_SWAP_LONG_LONGS(s, d, 1)
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+
+struct squashfs_base_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+union squashfs_inode_header_1 {
+	struct squashfs_base_inode_header_1	base;
+	struct squashfs_dev_inode_header_1	dev;
+	struct squashfs_symlink_inode_header_1	symlink;
+	struct squashfs_reg_inode_header_1	reg;
+	struct squashfs_dir_inode_header_1	dir;
+	struct squashfs_ipc_inode_header_1	ipc;
+};
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
+ */
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
+#endif
+#endif
diff -x .gitignore -Nurp linux-2.6.23/include/linux/squashfs_fs_i.h linux-2.6.23-squashfs3.3/include/linux/squashfs_fs_i.h
--- linux-2.6.23/include/linux/squashfs_fs_i.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/include/linux/squashfs_fs_i.h	2007-08-19 04:24:08.000000000 +0100
@@ -0,0 +1,45 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+struct squashfs_inode_info {
+	long long	start_block;
+	unsigned int	offset;
+	union {
+		struct {
+			long long	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+			long long	block_list_start;
+		} s1;
+		struct {
+			long long	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+};
+#endif
diff -x .gitignore -Nurp linux-2.6.23/include/linux/squashfs_fs_sb.h linux-2.6.23-squashfs3.3/include/linux/squashfs_fs_sb.h
--- linux-2.6.23/include/linux/squashfs_fs_sb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-squashfs3.3/include/linux/squashfs_fs_sb.h	2007-08-19 04:24:26.000000000 +0100
@@ -0,0 +1,76 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+struct squashfs_cache {
+	long long	block;
+	int		length;
+	long long	next_index;
+	char		*data;
+};
+
+struct squashfs_fragment_cache {
+	long long	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+};
+
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	struct squashfs_cache	*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
+	char			*read_page;
+	struct mutex		read_data_mutex;
+	struct mutex		read_page_mutex;
+	struct mutex		block_cache_mutex;
+	struct mutex		fragment_mutex;
+	struct mutex		meta_index_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct meta_index	*meta_index;
+	z_stream		stream;
+	long long		*inode_lookup_table;
+	int			unused_cache_blks;
+	int			unused_frag_blks;
+	int			(*read_inode)(struct inode *i,  squashfs_inode_t \
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int \
+				index, int readahead_blks, char *block_list, \
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+};
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/7100_fdma2_firmware.h linux-2.6.23.1-stm/include/linux/stm/7100_fdma2_firmware.h
--- linux-2.6.23.1/include/linux/stm/7100_fdma2_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/7100_fdma2_firmware.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,729 @@
+/*
+ *  STb710x FDMA Driver
+ *  Copyright (c) 2006 STMicroelectronics Limited.
+ *  Author: Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+
+#ifndef FDMA_7100_FIRMWARE
+#define FDMA_7100_FIRMWARE
+/*This firmware version 2.9*/
+
+static unsigned long STB7100_DMEM_REGION[]=
+{
+  0x02030209, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x23104052, 0x00000000, 0x00000000, 0x21100051, 0x00000000,
+  0x020001ad, 0x020301b0, 0x020601b3, 0x020901b6, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x0000031e, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x0000007e, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000fe, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000241b, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00002424,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x0000242d, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00002436, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000243f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001448, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000144d, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001452,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001457, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000145c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001061,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00004065, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001475, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000147a,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x0000147f, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001484, 0xadd0add0, 0xadd0add0, 0xadd0add0, 0xadd0add0,
+  0xadd0add0, 0xadd0add0, 0xadd0add0, 0xadd0add0, 0xadd0add0, 0xadd0add0,
+  0xadd0add0, 0xadd0add0, 0xadd0add0, 0xadd0add0, 0x00002212, 0x05800580,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xadd1add1, 0xadd1add1,
+  0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1,
+  0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1, 0xadd1add1,
+  0x00002212, 0x05a005a0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2,
+  0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2, 0xadd2add2,
+  0xadd2add2, 0xadd2add2, 0x00002212, 0x05c005c0, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0xadd3add3, 0xadd3add3, 0xadd3add3, 0xadd3add3,
+  0xadd3add3, 0xadd3add3, 0xadd3add3, 0xadd3add3, 0x000000c0, 0x00000000,
+  0xadd3add3, 0xadd3add3, 0xadd3add3, 0xadd3add3, 0x00002212, 0x05e005e0,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
+
+static unsigned long STB7100_IMEM_REGION[]=
+{
+  0x00f51000, 0x00ef0013, 0x00e10001, 0x00ee0080, 0x00b010ea, 0x00f01000,
+  0x00ef0013, 0x00ed000a, 0x009b32f9, 0x00d00090, 0x00a300e0, 0x00aa000b,
+  0x00433a00, 0x009c1504, 0x009a2247, 0x00d00090, 0x00a70005, 0x00177030,
+  0x009c1227, 0x00d00090, 0x00a70004, 0x009c178d, 0x00d00090, 0x00a70021,
+  0x009c184f, 0x00d00090, 0x00a00006, 0x009c146f, 0x00d00090, 0x00a70002,
+  0x009c15f2, 0x00d00090, 0x00a90003, 0x009c1037, 0x00d00090, 0x00a20001,
+  0x009c145d, 0x00d00090, 0x00d00017, 0x00452003, 0x00461003, 0x00355600,
+  0x00755461, 0x00a6040e, 0x00555001, 0x00765080, 0x00d00090, 0x00b0640e,
+  0x00755c23, 0x00761c62, 0x00266500, 0x007564ca, 0x00d00090, 0x00b0540b,
+  0x00840d00, 0x00b0deff, 0x003ee001, 0x00799e00, 0x00d19040, 0x00ea0460,
+  0x00721484, 0x00222a00, 0x00f00000, 0x00aa020e, 0x00ac020f, 0x00a50a0c,
+  0x00ab0a0e, 0x00b050e9, 0x00d0b070, 0x009c106d, 0x00d00090, 0x00a70a0d,
+  0x00a40003, 0x0074003f, 0x00840700, 0x00a50a04, 0x00b04003, 0x00d7c070,
+  0x0098106d, 0x0044507f, 0x009c10a9, 0x00d7c070, 0x00177002, 0x0098106d,
+  0x00407080, 0x00981124, 0x00ed0061, 0x008c812a, 0x009c812a, 0x00e70020,
+  0x00af0007, 0x005f0500, 0x00a82c00, 0x005f0800, 0x00b080eb, 0x00255004,
+  0x009a80e4, 0x00377001, 0x008c305c, 0x00a600e9, 0x00b0c20f, 0x00a80a02,
+  0x00a70a05, 0x00605800, 0x009c106a, 0x0005073c, 0x00b06a0c, 0x00b05a04,
+  0x00b0ba0e, 0x00a70a01, 0x0098111f, 0x00d00090, 0x00a50a00, 0x00d6b070,
+  0x00881090, 0x0099109d, 0x00d00090, 0x00a40201, 0x00ef4042, 0x00744d10,
+  0x00144008, 0x004f50f0, 0x00a32b00, 0x009c2083, 0x00d00090, 0x005f4001,
+  0x00a72b00, 0x00af2b00, 0x004f3001, 0x000f073c, 0x00d00817, 0x005f0400,
+  0x00af2b00, 0x000f033c, 0x005f0000, 0x00a70a01, 0x00255010, 0x00377010,
+  0x00b05a00, 0x00b07a01, 0x0098311f, 0x00d0b070, 0x009c1073, 0x00d00090,
+  0x00a00003, 0x00b0ba0e, 0x00982047, 0x00d00090, 0x00a00202, 0x0098109d,
+  0x00e30027, 0x00d0c370, 0x009c212a, 0x00d00090, 0x00a60003, 0x00b00003,
+  0x00b06002, 0x00b0ba0e, 0x00d4b070, 0x00d7c070, 0x00544700, 0x008c112a,
+  0x00d00090, 0x00a70202, 0x009c112a, 0x00ed00a7, 0x008c04b2, 0x00b00003,
+  0x00d0121a, 0x0099112a, 0x00ed00ca, 0x00d7c070, 0x00177002, 0x0098106d,
+  0x00d00090, 0x00a00202, 0x009810b3, 0x00307020, 0x00982090, 0x0044501f,
+  0x00234700, 0x004030e0, 0x009810b8, 0x00e30020, 0x00333001, 0x003734ff,
+  0x007430a8, 0x00ef4252, 0x005f0400, 0x004f50e0, 0x00764c62, 0x009810c5,
+  0x005f0000, 0x00366001, 0x009c30c0, 0x00d00090, 0x00d00090, 0x00a82c00,
+  0x005f0800, 0x00b080eb, 0x00255004, 0x009a80e4, 0x00377004, 0x009c30c5,
+  0x00764ca8, 0x00d00090, 0x003606e1, 0x0016603e, 0x009810d5, 0x005f0000,
+  0x00366001, 0x009c30d1, 0x00d00090, 0x00b0c20f, 0x00a600e9, 0x00a80a02,
+  0x00a70a05, 0x00605800, 0x009c10dc, 0x0005073c, 0x00b06a0c, 0x00b05a04,
+  0x00b0ba0e, 0x00d4c070, 0x0098106d, 0x0044507f, 0x009c10a9, 0x00d0061d,
+  0x00a30a00, 0x00433001, 0x00941d00, 0x00d00090, 0x00b06eff, 0x00b07efe,
+  0x00b08efd, 0x00b09efc, 0x00b0cefb, 0x003ee005, 0x00a60a07, 0x00a70a08,
+  0x00a800e9, 0x00ec0000, 0x00788d00, 0x00106001, 0x009c2103, 0x00796d08,
+  0x003c9800, 0x00796d00, 0x00398900, 0x005cc900, 0x006cc600, 0x009c2103,
+  0x007c6c3d, 0x007cc43e, 0x00666c00, 0x007c7c3d, 0x007cc43e, 0x00577c00,
+  0x00d01112, 0x00107001, 0x009c2119, 0x00797d08, 0x003c9800, 0x00797d00,
+  0x00398900, 0x005cc900, 0x006cc700, 0x009c2119, 0x007c7c3d, 0x007cc43e,
+  0x00677c00, 0x007c6c3d, 0x007cc43e, 0x00566c00, 0x00a900e9, 0x00b06a07,
+  0x00b07a08, 0x00799c48, 0x002995fc, 0x00b28b00, 0x00b29b00, 0x00ac1e01,
+  0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00840d00, 0x00a40a00,
+  0x00544001, 0x007b0210, 0x00b04a00, 0x00d00910, 0x00a30202, 0x009810a9,
+  0x00d00090, 0x00a60003, 0x00b00003, 0x00b06002, 0x00ad1e01, 0x00d00213,
+  0x00a50a04, 0x00b04003, 0x00d7c070, 0x0098106d, 0x0044507f, 0x009c1150,
+  0x00d7c070, 0x00177002, 0x0098106d, 0x00407080, 0x009811e7, 0x00ed0142,
+  0x008c81ed, 0x009c81ed, 0x00e70020, 0x00af0007, 0x005f0500, 0x00a82c00,
+  0x005f0800, 0x00b080eb, 0x00255004, 0x009a818a, 0x00377001, 0x008c313d,
+  0x00a600e9, 0x00b0c20f, 0x00a80a02, 0x00a70a05, 0x00605800, 0x009c114b,
+  0x0005073c, 0x00b06a0c, 0x00b05a04, 0x00b0ba0e, 0x008c006d, 0x008c0090,
+  0x009911ed, 0x00ed0171, 0x00d7c070, 0x00177002, 0x0098106d, 0x00d00090,
+  0x00a00202, 0x0098115a, 0x00307020, 0x00982090, 0x0044501f, 0x00234700,
+  0x004030e0, 0x0098115f, 0x00e30020, 0x00333001, 0x003734ff, 0x007430a8,
+  0x00ef4252, 0x005f0400, 0x004f50e0, 0x00764c62, 0x0098116c, 0x005f0000,
+  0x00366001, 0x009c3167, 0x00d00090, 0x00d00090, 0x00a82c00, 0x005f0800,
+  0x00b080eb, 0x00255004, 0x009a818a, 0x00377004, 0x009c316c, 0x00764ca8,
+  0x00d00090, 0x003606e1, 0x0016603e, 0x0098117c, 0x005f0000, 0x00366001,
+  0x009c3178, 0x00d00090, 0x00b0c20f, 0x00a600e9, 0x00a80a02, 0x00a70a05,
+  0x00605800, 0x009c1183, 0x0005073c, 0x00b06a0c, 0x00b05a04, 0x00d4c070,
+  0x0098106d, 0x0044507f, 0x009c1150, 0x00d0061d, 0x00a30a00, 0x00433001,
+  0x00941d00, 0x00d00090, 0x00b08a10, 0x00b01eff, 0x00b04efe, 0x00b07efd,
+  0x00b08efc, 0x00b09efb, 0x00b0cefa, 0x003ee006, 0x00a900e9, 0x00789d00,
+  0x00ac0e00, 0x00778ca0, 0x00799c48, 0x0003093c, 0x002995fc, 0x00e44400,
+  0x00144710, 0x009c21c8, 0x00d00090, 0x00d0c070, 0x009c11a8, 0x00d00090,
+  0x00e401ef, 0x00b09a11, 0x00b04a0d, 0x00d01d1b, 0x00a7030c, 0x00777e00,
+  0x00a42c00, 0x00a10a10, 0x00840700, 0x00714100, 0x00011001, 0x00d01b17,
+  0x00714200, 0x00011002, 0x00d01b17, 0x00714300, 0x00011003, 0x00d01b17,
+  0x0001043c, 0x00011040, 0x00d41040, 0x00ac0a12, 0x003404e1, 0x00111400,
+  0x002404e1, 0x00111400, 0x00311001, 0x00301c00, 0x00b01a12, 0x009831d4,
+  0x00d00090, 0x00a10a08, 0x00211001, 0x00d00090, 0x00b01a08, 0x00d01d1b,
+  0x00e40270, 0x00144710, 0x009821d4, 0x00c080b4, 0x009811cf, 0x00780327,
+  0x008c01d0, 0x00780308, 0x00d00090, 0x00b28b00, 0x00b29b00, 0x00d01d1b,
+  0x00ac0a08, 0x002cc001, 0x0078c308, 0x00780027, 0x00b00a08, 0x00b28b00,
+  0x00b29b00, 0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a41e01,
+  0x00a11e01, 0x00840d00, 0x00a40a00, 0x00544001, 0x007b0210, 0x00b04a00,
+  0x00d00910, 0x00a30202, 0x00981150, 0x00d00090, 0x00a60003, 0x00b00003,
+  0x00b06002, 0x00ad1e01, 0x00d00213, 0x00b01eff, 0x00b02efe, 0x00b03efd,
+  0x00b04efc, 0x00b0cefb, 0x003ee005, 0x00e2012c, 0x00a32c00, 0x00b02a0d,
+  0x00a20a0c, 0x00742c48, 0x00d00090, 0x00a4040c, 0x00744e10, 0x00a10a10,
+  0x00d00090, 0x00840400, 0x00713100, 0x00011001, 0x00d0201a, 0x00713200,
+  0x00011002, 0x00d0201a, 0x00713300, 0x00011003, 0x00d0201a, 0x0001033c,
+  0x00011040, 0x00d41040, 0x00a30a12, 0x003404e1, 0x00111400, 0x002404e1,
+  0x00111400, 0x00311001, 0x00a40a08, 0x00b01a12, 0x00244001, 0x00301300,
+  0x0098321a, 0x00d00090, 0x00b04a08, 0x00d02211, 0x00a10a0c, 0x00b00a08,
+  0x00714308, 0x00710027, 0x00a30a11, 0x00b21b00, 0x00b23b00, 0x00ac1e01,
+  0x00a41e01, 0x00a31e01, 0x00a21e01, 0x00a11e01, 0x00d0121c, 0x00f00000,
+  0x00d87040, 0x00982242, 0x00e10460, 0x00198004, 0x00299100, 0x00e10000,
+  0x00aa0900, 0x00ed0231, 0x008c0499, 0x00981242, 0x00e40329, 0x007445f0,
+  0x00544850, 0x00a1000a, 0x00b04300, 0x005f1200, 0x004fa0e0, 0x00ea0001,
+  0x00ab090f, 0x001aa800, 0x007b01f0, 0x00677a00, 0x00e10040, 0x00b0b90f,
+  0x00b0190b, 0x00d02218, 0x00aa0005, 0x007a7210, 0x00d00090, 0x00b0a005,
+  0x00d00114, 0x00ac00f0, 0x00a80005, 0x00d1c040, 0x009822f7, 0x0011103f,
+  0x001a1001, 0x00320a00, 0x0013c200, 0x00193a00, 0x00e20257, 0x00222300,
+  0x006cc900, 0x00eb0460, 0x0005013c, 0x00155004, 0x00255b00, 0x00840200,
+  0x00d02919, 0x00d00090, 0x00a2050b, 0x00722d00, 0x009c1249, 0x00e20001,
+  0x00122100, 0x00ab0022, 0x004bb200, 0x009c1249, 0x00588200, 0x00a40501,
+  0x00eb0001, 0x007a4ca0, 0x001bba00, 0x004bb0fe, 0x00981275, 0x009c2270,
+  0x007a4d00, 0x00c0a03f, 0x009c1275, 0x007a4ca8, 0x00eb0001, 0x001bba00,
+  0x00a3000b, 0x006bb0ff, 0x00433b00, 0x00d00090, 0x00b0300b, 0x00ab050b,
+  0x007bbd00, 0x009c1249, 0x00722210, 0x006220ff, 0x00ab0001, 0x00a40002,
+  0x004bb200, 0x00444200, 0x00b0b001, 0x00ab0006, 0x00b04002, 0x00a40004,
+  0x004bb200, 0x00444200, 0x00488200, 0x00b0b006, 0x00b04004, 0x00a40021,
+  0x00444200, 0x00eb0003, 0x00b04021, 0x00a40110, 0x0074b0a0, 0x00a300f4,
+  0x001b1001, 0x00e20001, 0x00122b00, 0x00402300, 0x00981295, 0x00122001,
+  0x00740062, 0x00b020f5, 0x00b04110, 0x00b090f2, 0x00d02419, 0x00e40001,
+  0x00144100, 0x006440ff, 0x00488400, 0x00a60110, 0x0042601f, 0x004660e0,
+  0x00566002, 0x00c02000, 0x00b06110, 0x009812aa, 0x00e20001, 0x00122110,
+  0x00588200, 0x00b06500, 0x00b090f2, 0x00d02419, 0x00a00502, 0x009c12b3,
+  0x0002053c, 0x00b08eff, 0x003ee001, 0x00ed02b1, 0x008c04b2, 0x00a81e01,
+  0x00d02419, 0x00a40501, 0x00b06110, 0x0042401f, 0x009812d1, 0x0042403f,
+  0x00c0201f, 0x009812d8, 0x00c0203f, 0x009812df, 0x00e605e0, 0x0042401f,
+  0x00e40001, 0x00144200, 0x00a3000b, 0x00533400, 0x00266200, 0x00b0300b,
+  0x00a20600, 0x00721088, 0x00742c2e, 0x00b02600, 0x00144004, 0x00244100,
+  0x00e60001, 0x00166400, 0x00a20006, 0x00522600, 0x00b090f2, 0x00b02006,
+  0x00d02419, 0x00a20001, 0x00eb0001, 0x001bb100, 0x00522b00, 0x00b090f2,
+  0x00b02001, 0x00d02419, 0x00a20002, 0x00eb0001, 0x001bb100, 0x00522b00,
+  0x00b090f2, 0x00b02002, 0x00d02419, 0x00724ca8, 0x00eb0001, 0x001bb200,
+  0x00a3000b, 0x00533b00, 0x00a20004, 0x00b0300b, 0x00704c2d, 0x009812ea,
+  0x00d00090, 0x00a20021, 0x00eb0001, 0x001bb100, 0x00522b00, 0x00b090f2,
+  0x00704c2d, 0x009c12f2, 0x00d00090, 0x00b02004, 0x00704c2d, 0x009812f6,
+  0x00d00090, 0x00b02021, 0x00d02419, 0x00b08005, 0x00d00110, 0x00b01eff,
+  0x00b02efe, 0x00b03efd, 0x00b04efc, 0x00b05efb, 0x00b06efa, 0x00b07ef9,
+  0x00b08ef8, 0x00b09ef7, 0x00b0aef6, 0x00b0bef5, 0x00b0cef4, 0x00b0def3,
+  0x003ee00d, 0x00d80050, 0x00788c4c, 0x009c131a, 0x00d00090, 0x00d00090,
+  0x00ad1e01, 0x00ac1e01, 0x00ab1e01, 0x00aa1e01, 0x00a91e01, 0x00a81e01,
+  0x00a71e01, 0x00a61e01, 0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a21e01,
+  0x00a11e01, 0x00840d00, 0x00da8040, 0x00e60080, 0x0076a023, 0x00a70aec,
+  0x00767060, 0x00d00090, 0x00a10600, 0x00b06009, 0x00731c80, 0x00741df0,
+  0x00751c64, 0x00e20460, 0x00793484, 0x00299200, 0x00840400, 0x00f00000,
+  0x0007093c, 0x00d00090, 0x00d00008, 0x00b1f701, 0x00a00902, 0x00981451,
+  0x00d00090, 0x00a60901, 0x0040601f, 0x0098133a, 0x0047603f, 0x00c0701f,
+  0x00981351, 0x00c0703f, 0x00981373, 0x00d0431b, 0x00e70001, 0x00d00008,
+  0x00400f00, 0x00a60001, 0x00177300, 0x00566700, 0x00d00090, 0x00b06001,
+  0x00a60905, 0x00a70902, 0x00307600, 0x008c2347, 0x0006073c, 0x00a10903,
+  0x00b0690c, 0x00b0690d, 0x00a20904, 0x00b01909, 0x00b0290a, 0x0004093c,
+  0x00ed0350, 0x008c0027, 0x00d04517, 0x00d00008, 0x00400f00, 0x00a70002,
+  0x00e20001, 0x00122300, 0x00577200, 0x007a6c88, 0x001aa005, 0x00e20560,
+  0x002aa200, 0x00b07002, 0x00b0a90e, 0x00b0090b, 0x00a00a0d, 0x008c1457,
+  0x00a60a0e, 0x00760210, 0x00a20a0f, 0x00b06a0e, 0x00722a10, 0x00e60001,
+  0x00b02a0f, 0x00a2090f, 0x00e7004b, 0x00a60a07, 0x00706c3c, 0x0088136e,
+  0x00e7012c, 0x00b00a08, 0x00720210, 0x00b07a0d, 0x00b0290f, 0x00b00a13,
+  0x00d04517, 0x00706c2d, 0x009c140e, 0x00eb05c0, 0x00ac090f, 0x007c0210,
+  0x00a00b09, 0x00b0c90f, 0x00981394, 0x00d00090, 0x00ad0903, 0x007ddc62,
+  0x00a2090e, 0x00522001, 0x00762c23, 0x002dd600, 0x00b0290e, 0x001dd00a,
+  0x00d00008, 0x00500f00, 0x00b0d90b, 0x00ad0902, 0x00a20901, 0x00702c3d,
+  0x0098138e, 0x00d00090, 0x00b0d90c, 0x00d03a1a, 0x00ed0001, 0x0072d03c,
+  0x00b0090c, 0x00b02901, 0x00ed0000, 0x00d03a1a, 0x0028b004, 0x00a10903,
+  0x00d00004, 0x00b1f801, 0x00d00004, 0x00500f00, 0x00a20904, 0x0004093c,
+  0x00ed039e, 0x008c0027, 0x00ad0902, 0x00a20901, 0x00b0d90c, 0x00702c3d,
+  0x009c13aa, 0x00d00090, 0x0002093c, 0x00b00900, 0x0001033c, 0x00ed03a9,
+  0x008c04b2, 0x00d04517, 0x002dd003, 0x001dd03e, 0x001dd003, 0x00d00090,
+  0x00b0d90d, 0x00b0d902, 0x00a00b09, 0x009c13f6, 0x00d00090, 0x00ad0907,
+  0x003dd002, 0x00a20b07, 0x00b0db09, 0x00782c44, 0x0042200f, 0x00188002,
+  0x00b02b07, 0x00b08909, 0x00a20b05, 0x00762c44, 0x0042200f, 0x00166002,
+  0x00b02b05, 0x00b06908, 0x00a50b08, 0x009c13cd, 0x00e500c0, 0x00a20b05,
+  0x00ad0b07, 0x00b02b01, 0x00b0db03, 0x00a20b06, 0x00ad0b04, 0x00b02b02,
+  0x00b0db00, 0x00355002, 0x00a70905, 0x00b05b08, 0x000d073c, 0x00a50b00,
+  0x007d6200, 0x007d5021, 0x0015503f, 0x00b2dc00, 0x00a40b02, 0x001d7010,
+  0x007d8200, 0x007d4021, 0x0014403f, 0x00b2dc00, 0x00a70906, 0x000d073c,
+  0x007d6200, 0x007d5021, 0x0015503f, 0x00b2dc00, 0x001d7010, 0x007d8200,
+  0x007d4021, 0x0014403f, 0x00b2dc00, 0x00ad0b01, 0x0075d21e, 0x001dd03e,
+  0x00b05b00, 0x00b0db01, 0x00a20b03, 0x0074221e, 0x0012203e, 0x00ad090d,
+  0x002dd010, 0x00b04b02, 0x00b02b03, 0x00b0d90d, 0x00b0d902, 0x00b0c90f,
+  0x00ad0901, 0x0072dca8, 0x00e80001, 0x00a00900, 0x009c13fc, 0x007d803c,
+  0x00168200, 0x00a5000b, 0x00555600, 0x00148300, 0x00b0500b, 0x00b0d901,
+  0x00b04004, 0x00ed05e0, 0x002dd200, 0x00a60310, 0x00ab0d00, 0x007b3088,
+  0x004660e0, 0x00566002, 0x00b0bd00, 0x00b06310, 0x00010a3c, 0x00d04517,
+  0x00eb05c0, 0x00ac090f, 0x007c0210, 0x00b0090b, 0x0028b004, 0x00b0c90f,
+  0x00d00004, 0x00b1f801, 0x00d00004, 0x00500f00, 0x00a10902, 0x00a20b07,
+  0x00b0190c, 0x00b0190d, 0x00782c49, 0x00722d20, 0x00188002, 0x00b02b07,
+  0x00b08909, 0x00a20b05, 0x00762c49, 0x00722d20, 0x00166002, 0x00b02b05,
+  0x00b06908, 0x00a10901, 0x00721ca8, 0x00e80001, 0x00168200, 0x00a5000b,
+  0x00555600, 0x00148300, 0x00b0500b, 0x00b04021, 0x00e105e0, 0x00211200,
+  0x00a60310, 0x00ab0100, 0x007b3088, 0x004660e0, 0x00566002, 0x00b0b100,
+  0x00b06310, 0x00010a3c, 0x00d04517, 0x00d00008, 0x00400f00, 0x00e805e0,
+  0x004a601f, 0x00268a00, 0x00a2000b, 0x00a70600, 0x00e50001, 0x00773088,
+  0x00155a00, 0x00b07600, 0x00777c2e, 0x00177004, 0x00233700, 0x00e70001,
+  0x00177300, 0x00aa0006, 0x00522500, 0x005aa700, 0x00b0200b, 0x00b0a006,
+  0x00d03412, 0x0001033c, 0x0002093c, 0x00d00008, 0x00500f00, 0x00ed0457,
+  0x008c04b2, 0x00a20009, 0x00712c23, 0x00722c60, 0x00ed045c, 0x008c04a9,
+  0x00d03017, 0x00142030, 0x008c1460, 0x00722210, 0x00d12040, 0x00e30001,
+  0x00133100, 0x00622300, 0x00311010, 0x00b02001, 0x00ec0000, 0x00b01eff,
+  0x003ee001, 0x00ed046b, 0x008c0883, 0x00a11e01, 0x00ed046e, 0x008c08f4,
+  0x00d00216, 0x00a20006, 0x00722e10, 0x009c1473, 0x00d04815, 0x00ecf0f0,
+  0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 0x00b01eff, 0x00b02efe,
+  0x00b0defd, 0x003ee003, 0x00ed047e, 0x008c0883, 0x00ad1e01, 0x00a21e01,
+  0x00a11e01, 0x00ec0000, 0x00500200, 0x009c1473, 0x00d00090, 0x00a20006,
+  0x00722e00, 0x009c1489, 0x00d0011d, 0x00d12040, 0x00e30001, 0x00133100,
+  0x00622300, 0x00b01eff, 0x00b02efe, 0x00b0defd, 0x003ee003, 0x00ed0493,
+  0x008c08f4, 0x00ad1e01, 0x00a21e01, 0x00a11e01, 0x00500200, 0x009c1489,
+  0x00d0011d, 0x00e30080, 0x00731023, 0x00e40001, 0x00a10300, 0x00d21040,
+  0x009c34a1, 0x00422000, 0x00840d00, 0x00144200, 0x00611400, 0x00742c22,
+  0x00b01300, 0x00533200, 0x0072244c, 0x0072403e, 0x00840d00, 0x00e30080,
+  0x00731023, 0x00e40001, 0x00144200, 0x00a10300, 0x00511400, 0x00d00090,
+  0x00b01300, 0x00840d00, 0x00a30201, 0x0007033c, 0x0077005e, 0x00ea05e0,
+  0x00b07201, 0x00773d00, 0x00c0703f, 0x009c14bc, 0x00773ca8, 0x00d04c10,
+  0x0047301f, 0x00c0701f, 0x009c14c0, 0x00e70000, 0x00a9000b, 0x00e80001,
+  0x00188700, 0x0078003f, 0x00780020, 0x006880ff, 0x00499800, 0x00a40110,
+  0x00b0900b, 0x00a60005, 0x00e70001, 0x00177100, 0x00777210, 0x006770ff,
+  0x00a80001, 0x00a90002, 0x00aa0006, 0x00488700, 0x00499700, 0x004aa700,
+  0x00b08001, 0x00a80004, 0x00b09002, 0x00488700, 0x00a90021, 0x00b0a006,
+  0x00499700, 0x00b08004, 0x00b09021, 0x00a00200, 0x00d50050, 0x00455001,
+  0x00773c3f, 0x00555700, 0x009814ef, 0x00d00090, 0x00a80128, 0x00288001,
+  0x00d00090, 0x00b08128, 0x00a700f4, 0x00181001, 0x00155800, 0x00407500,
+  0x009814ef, 0x00155001, 0x00740062, 0x00a70200, 0x009814f8, 0x00773c3e,
+  0x009814f8, 0x00177100, 0x00566700, 0x00e70003, 0x00747040, 0x00d05010,
+  0x00a70200, 0x009c14fc, 0x00740040, 0x00d05010, 0x00547002, 0x00e70001,
+  0x00177110, 0x00566700, 0x00b04110, 0x00b06005, 0x00b050f5, 0x00840d00,
+  0x00ec0001, 0x00da3040, 0x008c2508, 0x00d0001e, 0x0016ca00, 0x00eb05e0,
+  0x00633600, 0x002bba00, 0x00e40460, 0x00ab0b00, 0x0079bc88, 0x00169004,
+  0x00244600, 0x0076bc2e, 0x009c155b, 0x00d00090, 0x00a7040b, 0x00a1040e,
+  0x00401001, 0x009c151a, 0x00500700, 0x009c1505, 0x004110fe, 0x0076bc84,
+  0x00a8040c, 0x00b0140e, 0x00981505, 0x0075bcb8, 0x00255001, 0x00a1040f,
+  0x0016563e, 0x009c1525, 0x00e60001, 0x00751cc9, 0x00155002, 0x00d11070,
+  0x00211001, 0x00355100, 0x00305600, 0x00982505, 0x000a043c, 0x00b03eff,
+  0x003ee001, 0x0071bc56, 0x00981534, 0x00f40000, 0x00992539, 0x00d05316,
+  0x00f00000, 0x00991539, 0x00ed0538, 0x008c0499, 0x009c153d, 0x00d00090,
+  0x00d00090, 0x00a31e01, 0x00d05015, 0x0075bc84, 0x00e409a2, 0x007445f0,
+  0x00544900, 0x00745064, 0x00725084, 0x00b04300, 0x0071bcb8, 0x00981548,
+  0x007210b8, 0x0072c034, 0x00211001, 0x00111500, 0x0075bc3d, 0x0072503d,
+  0x005f2c00, 0x00a20a03, 0x005f0200, 0x0075bc3d, 0x00981552, 0x00222100,
+  0x00a80a0c, 0x00388100, 0x009c2556, 0x0008003c, 0x00b02a03, 0x00b01a0b,
+  0x00b08a0c, 0x00a31e01, 0x00d05015, 0x00a8040d, 0x009835d4, 0x0008093c,
+  0x00a70402, 0x009835d4, 0x0077bc84, 0x0075bcb8, 0x00255001, 0x00a9040f,
+  0x0016573e, 0x00d59670, 0x00982505, 0x00307002, 0x009c256c, 0x00e60004,
+  0x00370700, 0x00166700, 0x0007043c, 0x00b03eff, 0x003ee001, 0x0071bc56,
+  0x00981573, 0x00f50000, 0x00d05714, 0x00f00000, 0x00ed0576, 0x008c0499,
+  0x009c157b, 0x00d00090, 0x00d00090, 0x00a31e01, 0x00d05015, 0x00306010,
+  0x00983580, 0x008c8585, 0x009c8585, 0x00d05819, 0x0071bc56, 0x00981584,
+  0x009d2589, 0x00d05815, 0x009d1589, 0x00ed057b, 0x009b32f9, 0x00d00090,
+  0x00840d00, 0x00f00000, 0x0075bc56, 0x0098158d, 0x00f50000, 0x0075bc84,
+  0x00e40827, 0x007445f0, 0x00544800, 0x00745064, 0x00746127, 0x0015c800,
+  0x00b04300, 0x00a80022, 0x00588500, 0x0004073c, 0x00b08022, 0x0070bc65,
+  0x009815d5, 0x00e54002, 0x0071bcb8, 0x009815a0, 0x007510b8, 0x0075c034,
+  0x0071bc84, 0x007510a4, 0x0071bc3d, 0x0075103d, 0x00a9040f, 0x005f2500,
+  0x00a20404, 0x0005063c, 0x005f0200, 0x00af2900, 0x00355001, 0x009835ad,
+  0x00d05a19, 0x00156002, 0x0070bc3d, 0x008815b1, 0x00222500, 0x00a70402,
+  0x00a8040d, 0x00377500, 0x00388500, 0x009c35ca, 0x00d00090, 0x00a80405,
+  0x00308700, 0x009825bb, 0x0008073c, 0x00a50401, 0x00b0840c, 0x00705c26,
+  0x009815ca, 0x0079022f, 0x00a50406, 0x00a10409, 0x00211500, 0x00b0deff,
+  0x003ee001, 0x00b01409, 0x00b01403, 0x00ed05c9, 0x008c0027, 0x00ad1e01,
+  0x00a1000b, 0x0016ca00, 0x00611600, 0x00b02404, 0x00b0100b, 0x00b0840d,
+  0x00b0940f, 0x00b07402, 0x00a31e01, 0x00d05015, 0x00d05015, 0x0071bc84,
+  0x00c01000, 0x009c15e6, 0x00e14102, 0x00e50310, 0x00715210, 0x005f2100,
+  0x00a20404, 0x00efeeee, 0x005f0200, 0x00a12900, 0x001f1000, 0x001f1038,
+  0x001f1030, 0x001f1028, 0x00e50004, 0x00d05a1e, 0x00e14112, 0x00e50110,
+  0x00715210, 0x005f2100, 0x00a20404, 0x00efffcc, 0x005f0200, 0x00a12900,
+  0x001f1000, 0x001f1030, 0x00e50004, 0x00d05a1e, 0x00d87040, 0x00982615,
+  0x00e20001, 0x00122800, 0x0009083c, 0x00199004, 0x00e20460, 0x00299200,
+  0x00677200, 0x00a0090b, 0x009c1615, 0x00f00000, 0x00aa0903, 0x00ab0902,
+  0x00991615, 0x009835f2, 0x00e10087, 0x00e20616, 0x00a00100, 0x009c1020,
+  0x00548050, 0x00742210, 0x00e26310, 0x00b04100, 0x00e33051, 0x00732210,
+  0x005f0300, 0x005f0a00, 0x00e20080, 0x002aa200, 0x0013203e, 0x003bb200,
+  0x00b0a903, 0x00b0390b, 0x00b0b902, 0x00d00210, 0x00ad090e, 0x00ab090b,
+  0x00ac090f, 0x00fa1000, 0x00a40d0a, 0x00a80d09, 0x00b040e9, 0x007f8c61,
+  0x00fa3000, 0x004f8080, 0x00b0e008, 0x00ae0d0f, 0x00a20d0b, 0x00981630,
+  0x00d00090, 0x00d00090, 0x00ad1e01, 0x00aa1e01, 0x00a81e01, 0x00a71e01,
+  0x00a61e01, 0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a11e01, 0x00840200,
+  0x00e20635, 0x00a400ec, 0x00c04007, 0x009c1703, 0x00d00090, 0x00d00090,
+  0x00080f3c, 0x003bb001, 0x00b080eb, 0x00d00090, 0x009a8647, 0x00d00090,
+  0x00a00d13, 0x009c2643, 0x00d00090, 0x00d00090, 0x00b2ac00, 0x000a083c,
+  0x00d06311, 0x00e4ffff, 0x000a083c, 0x00b04d13, 0x00d06311, 0x00a50d06,
+  0x00105001, 0x009c263c, 0x00d00090, 0x00a100e9, 0x00745d08, 0x00b01d0a,
+  0x00761d00, 0x00374600, 0x00745d00, 0x00366400, 0x00577600, 0x00677500,
+  0x008c263c, 0x00a70d09, 0x00b000e9, 0x00711c48, 0x00777c41, 0x003771fb,
+  0x00fa1000, 0x00a40d09, 0x00747041, 0x004f7003, 0x00b04d09, 0x00307004,
+  0x009c2669, 0x00d00090, 0x00a400ec, 0x00e20667, 0x00c04007, 0x009c1703,
+  0x00d00090, 0x003bb001, 0x00000f3c, 0x00307007, 0x00983673, 0x00fa2000,
+  0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 0x00fa3000, 0x000f083c,
+  0x00d0671a, 0x00a400ec, 0x00e20677, 0x00c04007, 0x009c1703, 0x00d00090,
+  0x003bb001, 0x00080f3c, 0x00b0c90f, 0x00738d10, 0x00333001, 0x00705c3d,
+  0x009816a1, 0x00303004, 0x009826a1, 0x00708610, 0x009c26a1, 0x00d00090,
+  0x00a400ec, 0x00e20688, 0x00c04007, 0x009c1703, 0x003bb001, 0x00333004,
+  0x00040f3c, 0x00044040, 0x00744201, 0x00748859, 0x001440be, 0x00788c5a,
+  0x00588001, 0x001880bf, 0x00a5090f, 0x00a20d0e, 0x00d55070, 0x00155002,
+  0x00255101, 0x00a00d13, 0x0098269a, 0x00355004, 0x00d00090, 0x00b28200,
+  0x00a80d04, 0x00255800, 0x00b24200, 0x00b25200, 0x00b02d0e, 0x00c01003,
+  0x009c16ad, 0x00d00090, 0x00a40d13, 0x009826a7, 0x00d06a1a, 0x00444001,
+  0x00b2ac00, 0x00b04d13, 0x00e5fffc, 0x00e1ffff, 0x00d06a1f, 0x002510fd,
+  0x00d00090, 0x00303504, 0x009826ba, 0x00d00090, 0x00a400ec, 0x00e206b6,
+  0x00c04007, 0x009c1703, 0x003bb001, 0x00333004, 0x00080f3c, 0x00d06a1f,
+  0x00477003, 0x00357300, 0x00255101, 0x00fa1000, 0x00a40d09, 0x00745041,
+  0x004f5003, 0x00b04d09, 0x00301303, 0x009816f0, 0x00c05004, 0x009c16e5,
+  0x00fa2000, 0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 0x00fa3000,
+  0x000f083c, 0x00d06f10, 0x00fa2000, 0x00d00090, 0x00d00090, 0x00d00090,
+  0x00040f3c, 0x00fa3000, 0x000f043c, 0x00155003, 0x00144500, 0x0015503d,
+  0x00330300, 0x009c26db, 0x00e30000, 0x00357500, 0x00355004, 0x00155003,
+  0x00144500, 0x00350500, 0x00144500, 0x00355020, 0x00188500, 0x00588400,
+  0x00d06f10, 0x00455003, 0x00305700, 0x009826ce, 0x00e206ed, 0x00a400ec,
+  0x00c04007, 0x009c1703, 0x00d00090, 0x003bb001, 0x00080f3c, 0x00d00090,
+  0x00500100, 0x009c26f3, 0x00ea0000, 0x00211001, 0x00111003, 0x00310100,
+  0x00188100, 0x00211020, 0x001aa100, 0x00310100, 0x001aa100, 0x00211020,
+  0x00188100, 0x00e40001, 0x00588a00, 0x00b04d13, 0x00b080eb, 0x00e20631,
+  0x00d0631a, 0x00b0c90f, 0x00b02d0b, 0x00b0b90b, 0x00fa2000, 0x00b01eff,
+  0x00b03efe, 0x00b04efd, 0x00b05efc, 0x00b06efb, 0x00b07efa, 0x00b08ef9,
+  0x00b0aef8, 0x00b0def7, 0x003ee009, 0x00a100e9, 0x00a40d09, 0x00b01d0a,
+  0x00b0ed0f, 0x00050f3c, 0x00754100, 0x00ae0008, 0x00b05d09, 0x00a0090b,
+  0x009c1307, 0x00e40087, 0x00e80001, 0x00b00400, 0x00a10002, 0x0071803f,
+  0x00b00002, 0x00b01003, 0x00d03017, 0x00a7090e, 0x00ff1000, 0x007f7c61,
+  0x00ff3000, 0x005f0700, 0x00500a00, 0x009c172b, 0x00fa0000, 0x00ec05c0,
+  0x00ed0008, 0x00a4090b, 0x00a6090f, 0x00754cca, 0x00881735, 0x003dd500,
+  0x00500f00, 0x00355001, 0x009c3732, 0x00407001, 0x009c1739, 0x00757c41,
+  0x00244500, 0x00724cc2, 0x003dd200, 0x00122002, 0x00a0090c, 0x008c173f,
+  0x00724d00, 0x0005023c, 0x00222003, 0x0012203e, 0x00a10c09, 0x00ab0c00,
+  0x00311200, 0x00a20c01, 0x00b01c09, 0x00a40c02, 0x00a10c03, 0x00aa0909,
+  0x00a80908, 0x002505fc, 0x009c275a, 0x00255004, 0x00983776, 0x002505fc,
+  0x00777c41, 0x00377504, 0x009c2781, 0x00370500, 0x003dd001, 0x00177003,
+  0x0013f700, 0x00155003, 0x00133500, 0x00d0751b, 0x00530f00, 0x00b05eff,
+  0x003ee001, 0x00a50c08, 0x009c1764, 0x00e500c0, 0x00ab0c04, 0x00a20c05,
+  0x00a40c06, 0x00a10c07, 0x00355001, 0x00d00090, 0x00b05c08, 0x00a51e01,
+  0x00783210, 0x0078b021, 0x001bb03f, 0x007b203f, 0x0012203f, 0x00133030,
+  0x007a3210, 0x007a4021, 0x0014403f, 0x0074103f, 0x0011103f, 0x00b28600,
+  0x00b2a600, 0x00d0741b, 0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03,
+  0x00e7ffff, 0x003dd001, 0x00982781, 0x00d00090, 0x00d00090, 0x00500f00,
+  0x00d0771b, 0x00fa2000, 0x0000073c, 0x009c2755, 0x00d00090, 0x00a7090e,
+  0x0047700e, 0x00b0090b, 0x0042f080, 0x00577200, 0x00b0690f, 0x00b0790e,
+  0x00d04517, 0x00d77040, 0x00e90460, 0x007c7484, 0x002cc900, 0x00e90036,
+  0x00a50c0b, 0x00705d00, 0x009c17f3, 0x00d00090, 0x00ab0c0c, 0x008c37cf,
+  0x00a20c01, 0x00702c3c, 0x009817f3, 0x00eb05c0, 0x00a90c0f, 0x00a30c0d,
+  0x00a80b09, 0x009817ce, 0x00e20036, 0x00a40b00, 0x00a50b01, 0x00a60b02,
+  0x00a70b03, 0x00d09270, 0x009c27ce, 0x00e20008, 0x00308008, 0x009c27ab,
+  0x0002083c, 0x00aa0b08, 0x009c17b2, 0x00ea00c0, 0x00a50b05, 0x00a40b04,
+  0x00a60b06, 0x00a70b07, 0x003aa001, 0x00d00090, 0x00b0ab08, 0x00aa0c08,
+  0x007a4021, 0x0014403f, 0x0074503f, 0x0015503f, 0x00b2a900, 0x00aa0c09,
+  0x007a6021, 0x0016603f, 0x0076703f, 0x0017703f, 0x00b2a900, 0x00233008,
+  0x00388001, 0x00322001, 0x009c37ab, 0x00d00090, 0x00b04b00, 0x00b05b01,
+  0x00b06b02, 0x00b07b03, 0x00b03c02, 0x00b03c0d, 0x00b08b09, 0x00b09c0f,
+  0x00d07f13, 0x00aa0c0f, 0x00a10c01, 0x009d17d6, 0x00ed07d1, 0x009b32f9,
+  0x00d00090, 0x00840d00, 0x00711c3b, 0x009817da, 0x00f40000, 0x00d07d1b,
+  0x00f00000, 0x00d0a970, 0x009c27f3, 0x00d00090, 0x00ed07e0, 0x008c0499,
+  0x009817f3, 0x00e40723, 0x007445f0, 0x00544750, 0x00a90c03, 0x00b04300,
+  0x005f2051, 0x0046901f, 0x004f90e0, 0x003606e0, 0x00306b00, 0x009837ed,
+  0x00060b3c, 0x00756100, 0x003bb600, 0x00299600, 0x00b0bc0c, 0x00b09c03,
+  0x00b05c0b, 0x00d00117, 0x00f50000, 0x00500a00, 0x009c17f8, 0x00f00000,
+  0x00ec05c0, 0x00a7090b, 0x00a50c0a, 0x007d7ca3, 0x00ab0c00, 0x00a20c01,
+  0x00a40c02, 0x00a10c03, 0x00a70c08, 0x009c380b, 0x00e700c0, 0x00ab0c04,
+  0x00a20c05, 0x00a40c06, 0x00a10c07, 0x00b0bc00, 0x00b02c01, 0x00b04c02,
+  0x00b01c03, 0x00377001, 0x00a30908, 0x00a60909, 0x00b07c08, 0x0048f500,
+  0x004af500, 0x00783880, 0x007a6880, 0x0078b021, 0x007a4021, 0x001bb03f,
+  0x0014403f, 0x007b203f, 0x0074103f, 0x00a6090f, 0x0011103f, 0x0012203f,
+  0x00b28600, 0x00b2a600, 0x003dd001, 0x00b0690f, 0x008c1800, 0x00b0bc00,
+  0x00b02c01, 0x00b04c02, 0x00b01c03, 0x00b0090b, 0x00d04517, 0x00f50000,
+  0x00500a00, 0x009c182b, 0x00f00000, 0x00781d27, 0x00a40901, 0x00a20aec,
+  0x00307200, 0x009c184b, 0x00d00090, 0x00d00090, 0x00000f3c, 0x00388001,
+  0x009c182d, 0x00724ca0, 0x0030201f, 0x009c1839, 0x00724ca8, 0x00e60001,
+  0x00a8000b, 0x001b6200, 0x00568b00, 0x00e80001, 0x00b0600b, 0x00ab0022,
+  0x00188300, 0x006bb800, 0x00a70902, 0x00b0b022, 0x009c384a, 0x0001033c,
+  0x0002093c, 0x00b00902, 0x00ed084a, 0x008c04b2, 0x00d04517, 0x00718127,
+  0x00d00090, 0x00b01600, 0x00d03017, 0x00d77040, 0x00e10460, 0x007b7484,
+  0x002bb100, 0x00d00090, 0x00a40b0b, 0x009c1882, 0x00d00090, 0x00a10b0f,
+  0x00a80b03, 0x00d91070, 0x00a50b01, 0x002009c0, 0x009c2882, 0x00d00090,
+  0x00ea0004, 0x00a90b0c, 0x00883882, 0x00329020, 0x008c2864, 0x007a9c43,
+  0x009d1869, 0x00ed0864, 0x009b32f9, 0x00d00090, 0x00840d00, 0x00715c3b,
+  0x0098186d, 0x00f40000, 0x00d0861e, 0x00f00000, 0x00ed0870, 0x008c0499,
+  0x00981882, 0x00e407f4, 0x007445f0, 0x00544730, 0x00e10000, 0x00b04300,
+  0x00a30b06, 0x005f2031, 0x004f80f8, 0x00211008, 0x00288300, 0x003aa001,
+  0x008c3877, 0x00399100, 0x00741500, 0x00b09b0c, 0x00b08b03, 0x00b04b0b,
+  0x00d0011a, 0x00b0deff, 0x003ee001, 0x00771484, 0x00e50460, 0x00277500,
+  0x0005013c, 0x00ab0701, 0x00000c3c, 0x009c2891, 0x009d1891, 0x00ed088c,
+  0x009b32f9, 0x00d00090, 0x00840d00, 0x0071bc3b, 0x00981898, 0x00f40000,
+  0x00000c3c, 0x00982897, 0x009928cc, 0x00d0891d, 0x00f00000, 0x00000c3c,
+  0x0098289c, 0x009918cc, 0x00d00090, 0x00a90703, 0x00a3070b, 0x00a8070f,
+  0x00a4070e, 0x00404001, 0x009c18a6, 0x00500300, 0x009c18cc, 0x00d00090,
+  0x00aa070c, 0x009818cc, 0x00738d07, 0x004330fc, 0x00303022, 0x009828d5,
+  0x0040a080, 0x009818d5, 0x0040907f, 0x009c18d5, 0x00d48070, 0x00d00090,
+  0x00303421, 0x009838d0, 0x00ed08b6, 0x008c0499, 0x009818cc, 0x00e409a2,
+  0x007445f0, 0x00544550, 0x00a10007, 0x00611003, 0x0071002e, 0x00b04300,
+  0x005f1200, 0x005f0900, 0x00a4070e, 0x00740020, 0x00a30701, 0x00b0470e,
+  0x00733c26, 0x00133007, 0x00299300, 0x00e30080, 0x003aa300, 0x00b09703,
+  0x00b0a70c, 0x00b0370b, 0x00ad1e01, 0x00d00090, 0x00d00090, 0x00840d00,
+  0x007bbca0, 0x00e40001, 0x0074403f, 0x00144b00, 0x009828cc, 0x00d48070,
+  0x003043f6, 0x009c28cc, 0x00ed08da, 0x008c0499, 0x009818cc, 0x00e4096c,
+  0x007445f0, 0x00544550, 0x005f2051, 0x004f90e0, 0x00b04300, 0x00a4070e,
+  0x00740020, 0x0043901f, 0x00b0470e, 0x00a40701, 0x00744c26, 0x009818e9,
+  0x003993e0, 0x003403e0, 0x003aa400, 0x009c28ed, 0x000a003c, 0x00a3070b,
+  0x00743cca, 0x00d00090, 0x003304f8, 0x00133002, 0x007340ca, 0x00d08c19,
+  0x00741484, 0x00e70460, 0x00244700, 0x00e20020, 0x00a70401, 0x00707c3a,
+  0x009c18fe, 0x00f00000, 0x00991942, 0x00d09010, 0x00f50000, 0x00992942,
+  0x00d00090, 0x00a6040f, 0x00a7040d, 0x00a50404, 0x0043501f, 0x009c1943,
+  0x00207080, 0x00982943, 0x00d76270, 0x00982943, 0x008c8942, 0x009c8942,
+  0x00e20080, 0x00d00090, 0x00af0007, 0x005f0500, 0x00d02000, 0x00af2600,
+  0x00a70402, 0x00b0640f, 0x00255200, 0x00377200, 0x00b05404, 0x00b07402,
+  0x009c3922, 0x00d00090, 0x00b00402, 0x0002043c, 0x00b0deff, 0x003ee001,
+  0x00ed0920, 0x008c04b2, 0x00ad1e01, 0x00d09412, 0x00a3040d, 0x00333200,
+  0x009c1941, 0x00d00090, 0x00a20405, 0x00760210, 0x00302700, 0x0088292b,
+  0x0002073c, 0x00b0640f, 0x00b0240c, 0x00b0240d, 0x00b07402, 0x00a2040a,
+  0x00a70409, 0x00a30407, 0x00a50406, 0x00222300, 0x00277500, 0x00b0240a,
+  0x00b07409, 0x00b02404, 0x00b07403, 0x0003013c, 0x0001073c, 0x00b0deff,
+  0x003ee001, 0x00ed093f, 0x008c0027, 0x00ad1e01, 0x00d09412, 0x00b0340d,
+  0x00840d00, 0x00a2040d, 0x00a0040b, 0x009c1942, 0x00222300, 0x00d86070,
+  0x00981942, 0x00188002, 0x00288300, 0x004880fc, 0x00308020, 0x0098394f,
+  0x00e80020, 0x00308200, 0x00982954, 0x00392001, 0x0008023c, 0x00d09515,
+  0x00398001, 0x00ef4252, 0x000f9337, 0x004f50e0, 0x004a30fc, 0x003b8a00,
+  0x00500a00, 0x00981961, 0x005f0000, 0x003aa004, 0x009c395c, 0x00d00090,
+  0x00d00090, 0x00af2600, 0x003bb004, 0x009c3961, 0x003a08e0, 0x004aa0fc,
+  0x0098196a, 0x005f0000, 0x003aa004, 0x009c3967, 0x00328300, 0x00d09112,
+  0x00a2090e, 0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00,
+  0x009c1974, 0x00fa0000, 0x00ab090b, 0x004220fe, 0x00a8090f, 0x00b0290e,
+  0x0075bcca, 0x0098197f, 0x00d00090, 0x00d00090, 0x00500f00, 0x00355001,
+  0x008c397c, 0x0075bcc2, 0x00981986, 0x00d00090, 0x00d00090, 0x00b2f800,
+  0x00355001, 0x008c3983, 0x00b0090b, 0x0002073c, 0x00010a3c, 0x00ed098b,
+  0x008c04a9, 0x00a5090e, 0x009819a0, 0x00ff2000, 0x0045500f, 0x00d00090,
+  0x00d00090, 0x004bf080, 0x00555b00, 0x00a4090c, 0x00981998, 0x00d00090,
+  0x00b0590e, 0x00d09a10, 0x00755c41, 0x00d00090, 0x003505fc, 0x00155003,
+  0x00350500, 0x001bb500, 0x00d00090, 0x00b2b800, 0x00b0890f, 0x00d03017,
+  0x00a2090e, 0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00,
+  0x009c19aa, 0x00fa0000, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x00eb09b3,
+  0x007c1c64, 0x002ccb00, 0x00ab090b, 0x00a20908, 0x00840c00, 0x00d09d14,
+  0x00d09c1b, 0x00d09c17, 0x00d09c12, 0x00d09b1d, 0x00ec09b9, 0x00d00008,
+  0x00b2f800, 0x003bb020, 0x00d09d1d, 0x00ec09be, 0x00d00004, 0x00b2f800,
+  0x003bb010, 0x00d09d1d, 0x00ec09c3, 0x00d00002, 0x00b2f800, 0x003bb008,
+  0x00d09d1d, 0x00ec09c8, 0x00b2f800, 0x003bb004, 0x00d09d1d, 0x00ec09cc,
+  0x00122030, 0x0072f210, 0x003bb002, 0x008c19dd, 0x00d00090, 0x00d00090,
+  0x00b22800, 0x00d09d1d, 0x00ec09d5, 0x00122038, 0x0072f118, 0x003bb001,
+  0x008c19dd, 0x00d00090, 0x00d00090, 0x00b22800, 0x00d09d1d, 0x00a50aec,
+  0x00355700, 0x00801c00, 0x00b02908, 0x00b0b90b, 0x00500b00, 0x009c19e8,
+  0x0002073c, 0x00010a3c, 0x00ed09e8, 0x008c04a9, 0x00a5090e, 0x009819fd,
+  0x00ff2000, 0x00d00090, 0x00d00090, 0x0045500f, 0x004bf080, 0x00a4090c,
+  0x009819f5, 0x00555b00, 0x00d00090, 0x00b0590e, 0x00d09f1d, 0x00755c41,
+  0x00d00090, 0x003505fc, 0x00155003, 0x00350500, 0x001bb500, 0x00d00090,
+  0x00b2b800, 0x00b0890f, 0x00d03017
+};
+
+#define TABLE_LENGTH(x) (sizeof(x)/sizeof(*(x)))
+#define STB7100_IMEM_REGION_LENGTH  0xa00
+
+#define STB7100_DMEM_REGION_LENGTH  0x600
+
+#define STB7100_IMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7100_IMEM_REGION)
+#define STB7100_DMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7100_DMEM_REGION)
+
+#endif
+
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/7109_cut2_fdma2_firmware.h linux-2.6.23.1-stm/include/linux/stm/7109_cut2_fdma2_firmware.h
--- linux-2.6.23.1/include/linux/stm/7109_cut2_fdma2_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/7109_cut2_fdma2_firmware.h	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,708 @@
+/*  STb710x FDMA Driver
+ *  Copyright (c) 2006 STMicroelectronics Limited.
+ *  Author: Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef FDMA_7109C2_FIRMWARE
+#define FDMA_7109C2_FIRMWARE
+
+#define TABLE_LEN(x) (sizeof(x)/sizeof(*(x)))
+
+static unsigned long STB7109_C2_DMEM_REGION[]=
+{
+  0x00060208, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x23104052, 0x23100051, 0x00000000, 0x00000000, 0x00000000,
+  0x21100051, 0x01770133, 0x017a0136, 0x017d0139, 0x0180013c, 0x63103051,
+  0x003f001f, 0x000001c2, 0x000001c4, 0x000001c6, 0x000001d2, 0x00000398,
+  0x00000396, 0x00000393, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000fe, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x0000007e, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00002416, 0x04a004a0, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00002416, 0x04c004c0,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00002416, 0x04e004e0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000241f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001428, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000142d, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001432,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001437, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000143c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001441,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001446, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000144b, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001450,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001455, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000145a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000145f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001464, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001469, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000146e
+};
+
+static unsigned long STB7109_C2_IMEM_REGION[]=
+{
+  0x00e1ffff, 0x00e200ff, 0x00f51000, 0x00b010f9, 0x00b020fa, 0x00ef0013,
+  0x00e10001, 0x00ee00a0, 0x00b010ea, 0x00f01000, 0x00ef0013, 0x00a300f8,
+  0x00aa000b, 0x00433a00, 0x009c1504, 0x009b332e, 0x009a223b, 0x00d00090,
+  0x00a70005, 0x00177030, 0x009c121b, 0x00d00090, 0x00a70006, 0x00a2001c,
+  0x00672700, 0x009c1470, 0x00d00090, 0x00a70002, 0x009c15f6, 0x00d00090,
+  0x00a70004, 0x009c178d, 0x00d00090, 0x00a90003, 0x009c1038, 0x00d00090,
+  0x00a20001, 0x009c145f, 0x00d00090, 0x00d0001b, 0x00452003, 0x00461003,
+  0x00355600, 0x00755461, 0x00a6040e, 0x00555001, 0x00765080, 0x00d00090,
+  0x00b0640e, 0x00755c23, 0x00761c62, 0x00266500, 0x007564ca, 0x00d00090,
+  0x00b0540b, 0x00840d00, 0x00e20500, 0x00d00090, 0x00aa020e, 0x00f50000,
+  0x00ab0a0e, 0x00a10a0d, 0x00d0b070, 0x009c10a9, 0x00d00090, 0x00a4020f,
+  0x00a70201, 0x00a30a04, 0x00d54070, 0x00305020, 0x0098207a, 0x007c3ce0,
+  0x009c107e, 0x00e80020, 0x00ed0054, 0x00a50007, 0x00777c2f, 0x00757037,
+  0x005f0500, 0x005f0300, 0x00a50a0c, 0x00a70a14, 0x00b050e9, 0x00941700,
+  0x00d00090, 0x00ed005b, 0x00a92400, 0x00233004, 0x00b090eb, 0x005f0900,
+  0x00928100, 0x00388001, 0x008c3056, 0x00a50a02, 0x0006033c, 0x00605300,
+  0x008c1062, 0x00a60a05, 0x00a500e9, 0x00b06a04, 0x00b0420f, 0x00b05a0c,
+  0x00d0b070, 0x009c10a9, 0x00d00090, 0x00e60026, 0x00d54070, 0x00306500,
+  0x00982024, 0x00d00090, 0x00a50202, 0x009c1076, 0x00d04070, 0x009c1024,
+  0x00e10000, 0x00b00003, 0x00ed0024, 0x008c04b1, 0x00e10001, 0x00b00003,
+  0x00b01002, 0x008c0024, 0x00a00202, 0x009c1076, 0x00d04070, 0x00981072,
+  0x004c301f, 0x00155002, 0x00265c00, 0x004060e0, 0x00981084, 0x00e60020,
+  0x00366001, 0x00166008, 0x00ed0099, 0x00777c2f, 0x00e54252, 0x00757037,
+  0x000f053c, 0x005f6c00, 0x004f30e0, 0x0018c03e, 0x00981092, 0x000f003c,
+  0x00388001, 0x008c308f, 0x00a50a0c, 0x00166038, 0x00386cff, 0x0018803e,
+  0x00a70a14, 0x00b050e9, 0x00941700, 0x00d00090, 0x00ed00a0, 0x00a92400,
+  0x00233004, 0x00b090eb, 0x005f0900, 0x00928100, 0x00388001, 0x008c309b,
+  0x003806e1, 0x0098105d, 0x000f003c, 0x00388004, 0x008c30a4, 0x008c005d,
+  0x008c00a8, 0x00a30a00, 0x00a80a01, 0x009810cd, 0x00d00090, 0x00a50201,
+  0x00775c2f, 0x00777437, 0x00055035, 0x00e64042, 0x005f6700, 0x004f30f0,
+  0x00a62b00, 0x009c20bd, 0x00d00090, 0x005f5001, 0x00ac2b00, 0x00af2b00,
+  0x004f6001, 0x000f0c3c, 0x008c00c1, 0x000f053c, 0x00af2b00, 0x000f063c,
+  0x000f003c, 0x00233010, 0x00388010, 0x009810cb, 0x00d0b070, 0x009c10b1,
+  0x00d00090, 0x00b08a01, 0x00b03a00, 0x00b0ba0e, 0x008c0024, 0x00d0b070,
+  0x009810c7, 0x00533001, 0x007b0210, 0x0008003c, 0x008c00c7, 0x00a50a00,
+  0x00455001, 0x00941d00, 0x00d00090, 0x00b06eff, 0x00b07efe, 0x00b08efd,
+  0x00b09efc, 0x00b0cefb, 0x003ee005, 0x00a60a07, 0x00a70a08, 0x00a800e9,
+  0x00ec0000, 0x00788d00, 0x00106001, 0x009c20f0, 0x00796d08, 0x003c9800,
+  0x00796d00, 0x00398900, 0x005cc900, 0x006cc600, 0x009c20f0, 0x007c6c3d,
+  0x007cc43e, 0x00666c00, 0x007c7c3d, 0x007cc43e, 0x00577c00, 0x00d00f1f,
+  0x00107001, 0x009c2106, 0x00797d08, 0x003c9800, 0x00797d00, 0x00398900,
+  0x005cc900, 0x006cc700, 0x009c2106, 0x007c7c3d, 0x007cc43e, 0x00677c00,
+  0x007c6c3d, 0x007cc43e, 0x00566c00, 0x00a900e9, 0x00b06a07, 0x00b07a08,
+  0x00799c48, 0x002993fc, 0x00b28b00, 0x00b29b00, 0x00ac1e01, 0x00a91e01,
+  0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00840d00, 0x00a50a00, 0x00455001,
+  0x00941d00, 0x00d00090, 0x00b09a10, 0x00b01eff, 0x00b02efe, 0x00b06efd,
+  0x00b07efc, 0x00b08efb, 0x00b09efa, 0x00b0cef9, 0x00b04ef8, 0x003ee008,
+  0x00a800e9, 0x00788d00, 0x0047801f, 0x00a40e00, 0x00a900e9, 0x00778ca0,
+  0x00799c48, 0x0002093c, 0x002993fc, 0x00e54400, 0x00155710, 0x009c214e,
+  0x00d00090, 0x00d04070, 0x009c112e, 0x00d00090, 0x00e50167, 0x00b09a11,
+  0x00b05a14, 0x00d0151e, 0x00a7020d, 0x00777e00, 0x00a52400, 0x00a60a10,
+  0x00840700, 0x00765100, 0x00066001, 0x00d0131d, 0x00765200, 0x00066002,
+  0x00d0131d, 0x00765300, 0x00066003, 0x00d0131d, 0x0006053c, 0x00066040,
+  0x00d56040, 0x00a40a12, 0x003505e1, 0x00166500, 0x002505e1, 0x00166500,
+  0x00366001, 0x00306400, 0x00b06a12, 0x00983156, 0x00d00090, 0x00a60a08,
+  0x00266001, 0x00d00090, 0x00b06a08, 0x00d0151e, 0x00e50270, 0x00155710,
+  0x00982156, 0x00780327, 0x00d00090, 0x00b28b00, 0x00b29b00, 0x00d0151e,
+  0x00ac0a08, 0x00b00a08, 0x002cc001, 0x0078c308, 0x00780027, 0x00d00090,
+  0x00b28b00, 0x00b29b00, 0x00a41e01, 0x00ac1e01, 0x00a91e01, 0x00a81e01,
+  0x00a71e01, 0x00a61e01, 0x00a21e01, 0x00a11e01, 0x00840d00, 0x00b01eff,
+  0x00b02efe, 0x00b03efd, 0x00b04efc, 0x00b05efb, 0x00b0befa, 0x003ee006,
+  0x00a20a11, 0x00752c40, 0x00a32400, 0x00b00a14, 0x00a5050d, 0x00755e10,
+  0x00a10a10, 0x00d00090, 0x00840500, 0x00713100, 0x00011001, 0x00d01811,
+  0x00713200, 0x00011002, 0x00d01811, 0x00713300, 0x00011003, 0x00d01811,
+  0x0001033c, 0x00011040, 0x00d51040, 0x00a30a12, 0x003505e1, 0x00111500,
+  0x002505e1, 0x00111500, 0x00311001, 0x00a50a08, 0x00b01a12, 0x00255001,
+  0x00301300, 0x00983191, 0x00d00090, 0x00b05a08, 0x00d01919, 0x00a10a0c,
+  0x00a30a11, 0x00b00a08, 0x00715308, 0x00710027, 0x00d00090, 0x00b21b00,
+  0x00b23b00, 0x00a01e01, 0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a21e01,
+  0x00a11e01, 0x00840d00, 0x00a50a00, 0x00455001, 0x00941d00, 0x00d00090,
+  0x00b09a10, 0x00b01eff, 0x00b06efe, 0x00b07efd, 0x00b08efc, 0x00b09efb,
+  0x00b0cefa, 0x00b04ef9, 0x003ee007, 0x00a100e9, 0x00701c65, 0x009c11e3,
+  0x00781c48, 0x00a60012, 0x0041101f, 0x00106100, 0x009c21e3, 0x0005083c,
+  0x002883fc, 0x00c0100b, 0x009811be, 0x00d00090, 0x00d00090, 0x00b21b00,
+  0x00b28b00, 0x00d01e13, 0x00a60513, 0x00d00090, 0x00d00090, 0x00840600,
+  0x00779e08, 0x00d01d1d, 0x00779e10, 0x00d01d1d, 0x00e601ed, 0x00d04070,
+  0x009c11cc, 0x00d00090, 0x00b06a14, 0x00d01e1b, 0x0006043c, 0x00779d18,
+  0x00d00090, 0x00a62600, 0x00776108, 0x00d01d1d, 0x00e60205, 0x00d04070,
+  0x009c11d8, 0x00d00090, 0x00b06a14, 0x00d01e1b, 0x0006043c, 0x00d00090,
+  0x00d00090, 0x00a72600, 0x00d01d1d, 0x00077040, 0x00777d37, 0x00717128,
+  0x00d00090, 0x00b21b00, 0x00b28b00, 0x00a41e01, 0x00ac1e01, 0x00a91e01,
+  0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00a11e01, 0x00840d00, 0x00b08a11,
+  0x00d01e13, 0x00a90a00, 0x00499001, 0x00941d00, 0x00d00090, 0x00b06eff,
+  0x00b08efe, 0x00b04efd, 0x003ee003, 0x00a90a10, 0x00a80a11, 0x00a62400,
+  0x00166008, 0x00769918, 0x00066040, 0x00766d37, 0x00799d10, 0x00796128,
+  0x00b00a14, 0x00b29b00, 0x00b28b00, 0x00a41e01, 0x00a81e01, 0x00a61e01,
+  0x00840d00, 0x00a90a00, 0x00499001, 0x00941d00, 0x00d00090, 0x00b06eff,
+  0x00b08efe, 0x00b04efd, 0x003ee003, 0x00a90a10, 0x00a80a11, 0x00a62400,
+  0x00799d18, 0x00066040, 0x00766d37, 0x00796128, 0x00b00a14, 0x00b29b00,
+  0x00b28b00, 0x00a41e01, 0x00a81e01, 0x00a61e01, 0x00840d00, 0x00f40000,
+  0x00d87040, 0x00982235, 0x00e10500, 0x00198004, 0x00299100, 0x00e10001,
+  0x00aa0900, 0x00ed0225, 0x008c0498, 0x00981235, 0x00e40340, 0x007445f0,
+  0x00544850, 0x00a1000c, 0x00b04300, 0x005f1200, 0x004fa0e0, 0x00ea0001,
+  0x00ab090f, 0x001aa800, 0x007b01f0, 0x00677a00, 0x00b0b90f, 0x00b0b90b,
+  0x00d0211c, 0x00aa0005, 0x00d00090, 0x007a7210, 0x00d00090, 0x00b0a005,
+  0x00d00116, 0x00ac00f0, 0x00a80005, 0x00d1c040, 0x0098232c, 0x0011103f,
+  0x00ed0450, 0x001a1001, 0x002dd100, 0x00320a00, 0x0013c200, 0x00193a00,
+  0x00e2024d, 0x00222300, 0x006cc900, 0x00eb0500, 0x0005013c, 0x00155004,
+  0x00255b00, 0x00840200, 0x00d02d16, 0x00d02914, 0x00a40501, 0x00724ca0,
+  0x00981294, 0x00e40460, 0x00244200, 0x00c0201f, 0x00981294, 0x00eb0001,
+  0x00a20400, 0x00702c2e, 0x009c1294, 0x001bb100, 0x00a2001c, 0x00522b00,
+  0x00588b00, 0x00b0201c, 0x00a2050f, 0x00aa050c, 0x00ab050b, 0x0070bd00,
+  0x009c123d, 0x00d22070, 0x0098129d, 0x00f50000, 0x0099123d, 0x00122002,
+  0x00b0050c, 0x00ab050d, 0x0030b200, 0x009c226f, 0x00020b3c, 0x003bb200,
+  0x00b0250d, 0x00b0deff, 0x00b01efe, 0x00b05efd, 0x00b0befc, 0x00b0aefb,
+  0x00b08efa, 0x003ee006, 0x00ed027a, 0x008c0885, 0x00a81e01, 0x00aa1e01,
+  0x00ab1e01, 0x00a51e01, 0x00a11e01, 0x00ad1e01, 0x00a2050d, 0x00b0a50c,
+  0x00981287, 0x002bb200, 0x00d00090, 0x00b0b50d, 0x00d0231d, 0x00b0deff,
+  0x00b05efe, 0x00b01efd, 0x003ee003, 0x00b0b50d, 0x00ed028f, 0x00000b3c,
+  0x009818c2, 0x00d00090, 0x00d00090, 0x00a11e01, 0x00a51e01, 0x00ad1e01,
+  0x00a2050b, 0x00702d00, 0x009c123d, 0x00e20001, 0x00122100, 0x00ab001b,
+  0x004bb200, 0x009c123d, 0x00588200, 0x00a40501, 0x00eb0001, 0x007a4ca0,
+  0x001bba00, 0x004bb0fe, 0x009812af, 0x009c22aa, 0x007a4d00, 0x00c0a03f,
+  0x009c12af, 0x007a4ca8, 0x00eb0001, 0x001bba00, 0x00a3000b, 0x006bb0ff,
+  0x00433b00, 0x00d00090, 0x00b0300b, 0x00ab050b, 0x0070bd00, 0x009c123d,
+  0x00722210, 0x006220ff, 0x00ab0001, 0x00a40002, 0x004bb200, 0x00444200,
+  0x00b0b001, 0x00ab0006, 0x00b04002, 0x00a40004, 0x004bb200, 0x00444200,
+  0x00488200, 0x00b0b006, 0x00b04004, 0x00ab001c, 0x004bb200, 0x00a4001a,
+  0x00b0b01c, 0x00444200, 0x00eb0003, 0x00b0401a, 0x00a40d00, 0x0074b0a0,
+  0x00a300f4, 0x001b1001, 0x00e20001, 0x00122b00, 0x00402300, 0x009812d2,
+  0x00122001, 0x00740062, 0x00b020f5, 0x00b04d00, 0x00b090f2, 0x00d0231d,
+  0x00e40001, 0x00144100, 0x006440ff, 0x00488400, 0x00a60d00, 0x0042601f,
+  0x004660e0, 0x00566002, 0x00c02000, 0x00b06d00, 0x009812e7, 0x00e20001,
+  0x00122110, 0x00588200, 0x00b06500, 0x00b090f2, 0x00d0231d, 0x00a00502,
+  0x009c12f2, 0x0002053c, 0x00b0ceff, 0x00b08efe, 0x003ee002, 0x00ed02ef,
+  0x008c04b1, 0x00a81e01, 0x00ac1e01, 0x00d0231d, 0x00a40501, 0x00b06d00,
+  0x0042401f, 0x00981310, 0x0042403f, 0x00c0201f, 0x00981317, 0x00c0203f,
+  0x0098131e, 0x00e60460, 0x0042401f, 0x00e40001, 0x00144200, 0x00a3000b,
+  0x00533400, 0x00266200, 0x00b0300b, 0x00a20600, 0x00721088, 0x00742c2e,
+  0x00b02600, 0x00144004, 0x00244100, 0x00e60001, 0x00166400, 0x00a20006,
+  0x00522600, 0x00b090f2, 0x00b02006, 0x00d0231d, 0x00a20001, 0x00eb0001,
+  0x001bb100, 0x00522b00, 0x00b090f2, 0x00b02001, 0x00d0231d, 0x00a20002,
+  0x00eb0001, 0x001bb100, 0x00522b00, 0x00b090f2, 0x00b02002, 0x00d0231d,
+  0x00eb0001, 0x001bb100, 0x00a2001a, 0x00704c2d, 0x00981327, 0x00522b00,
+  0x00b090f2, 0x00b0201a, 0x00d0231d, 0x00a20004, 0x00522b00, 0x00b090f2,
+  0x00b02004, 0x00d0231d, 0x00b08005, 0x00d00112, 0x00d80050, 0x00788c4c,
+  0x00981010, 0x00da8040, 0x00e600a0, 0x0076a023, 0x00a70aec, 0x00767060,
+  0x00d00090, 0x00a10600, 0x00b0600a, 0x00731c80, 0x00741df0, 0x00751c64,
+  0x00e20500, 0x00793484, 0x00299200, 0x00840400, 0x00f50000, 0x0007093c,
+  0x00d00090, 0x00d00008, 0x00b1f701, 0x00a00902, 0x00981453, 0x00d00090,
+  0x00a70903, 0x00a20904, 0x00a60901, 0x007b7c5e, 0x007b283f, 0x006bb003,
+  0x0076b05a, 0x00ebffff, 0x00ed035c, 0x0041603f, 0x00c0101f, 0x009c199e,
+  0x007a6c88, 0x001aa005, 0x00e20480, 0x002aa200, 0x00ed037c, 0x00ab0a04,
+  0x00a20a00, 0x008c099e, 0x0040601f, 0x00b06901, 0x00981362, 0x00c0103f,
+  0x0098139f, 0x00d0431d, 0x00e70001, 0x00d00008, 0x00400f00, 0x00a20001,
+  0x00177300, 0x00522700, 0x00a10903, 0x00b02001, 0x00a20905, 0x00a70902,
+  0x00307200, 0x008c236f, 0x0002073c, 0x00a10903, 0x00b0290c, 0x00b0290d,
+  0x00a20904, 0x00b01909, 0x00b0290a, 0x0004093c, 0x00b0deff, 0x003ee001,
+  0x00ed037a, 0x008c0028, 0x00ad1e01, 0x00d04519, 0x00d00008, 0x00400f00,
+  0x00a70002, 0x00eb0001, 0x0012b300, 0x00577200, 0x00b0a90e, 0x00b07002,
+  0x00b0090b, 0x00b06901, 0x00a00a0d, 0x008c1459, 0x00a60a0e, 0x00760210,
+  0x00a20a0f, 0x00ab0a07, 0x00722a10, 0x007bbc5b, 0x00b02a0f, 0x00a20b17,
+  0x00b00a14, 0x00b06a0e, 0x00840200, 0x00e6010c, 0x00b00a08, 0x00d03919,
+  0x00e601a0, 0x00d03919, 0x00e600d1, 0x00a2090f, 0x00b06a0d, 0x00720210,
+  0x00b00a13, 0x00b0290f, 0x00d04519, 0x00706c2d, 0x009c143d, 0x00d00090,
+  0x00ac090f, 0x00ed0450, 0x007c0210, 0x002dd300, 0x00eb04e0, 0x00b0c90f,
+  0x00a00b09, 0x009813c3, 0x00d00090, 0x00a10903, 0x00711c62, 0x00a2090e,
+  0x00522001, 0x00762c23, 0x00211600, 0x00b0290e, 0x0011100a, 0x00d00008,
+  0x00500f00, 0x00b0190b, 0x00a10902, 0x00a20901, 0x00702c3d, 0x009813bd,
+  0x00d00090, 0x00b0190c, 0x00d03d1c, 0x00e10001, 0x0072103c, 0x00b0090c,
+  0x00b02901, 0x00e10000, 0x00d03d1c, 0x00080b3c, 0x00a10903, 0x00d00004,
+  0x00b1f801, 0x00d00004, 0x00500f00, 0x00a20904, 0x0004093c, 0x00ed03cd,
+  0x008c0028, 0x00a10902, 0x00a20901, 0x00b0190c, 0x00702c3d, 0x009c13dc,
+  0x00d00090, 0x00a10d00, 0x004110e0, 0x0002093c, 0x00b01d00, 0x00b00900,
+  0x0001033c, 0x00ed03db, 0x008c04b1, 0x00d04519, 0x00211003, 0x0011103e,
+  0x00111003, 0x00d00090, 0x00b0190d, 0x00b01902, 0x00a00b09, 0x009c1425,
+  0x00d00090, 0x00a10907, 0x00311002, 0x00a20b03, 0x00b01b09, 0x00782c44,
+  0x0042200f, 0x00188002, 0x00b02b03, 0x00b08909, 0x00a20b01, 0x00762c44,
+  0x0042200f, 0x00166002, 0x00b02b01, 0x00b06908, 0x00a10b00, 0x00a20b02,
+  0x00b01b04, 0x00b02b06, 0x00a10b01, 0x00a20b03, 0x00b01b05, 0x00e100be,
+  0x00b02b07, 0x00b01b08, 0x00a50b00, 0x00a70905, 0x0001073c, 0x00716200,
+  0x00715021, 0x0015503f, 0x00b21c00, 0x00a40b02, 0x00117010, 0x00718200,
+  0x00714021, 0x0014403f, 0x00b21c00, 0x00a70906, 0x0001073c, 0x00716200,
+  0x00715021, 0x0015503f, 0x00b21c00, 0x00117010, 0x00718200, 0x00714021,
+  0x0014403f, 0x00b21c00, 0x00a10b01, 0x0075121e, 0x0011103e, 0x00b05b00,
+  0x00b01b01, 0x00a20b03, 0x0074221e, 0x0012203e, 0x00a1090d, 0x00211010,
+  0x00b04b02, 0x00b02b03, 0x00b0190d, 0x00b01902, 0x00b0c90f, 0x00a10901,
+  0x00721ca8, 0x00e80001, 0x00a00900, 0x009c142b, 0x0071803c, 0x00168200,
+  0x00a5000b, 0x00555600, 0x00148300, 0x00b0500b, 0x00b01901, 0x00b04004,
+  0x00e10460, 0x00211200, 0x00a60d00, 0x00ab0100, 0x007b3088, 0x004660e0,
+  0x00566002, 0x00b0b100, 0x00b06d00, 0x00010a3c, 0x00d04519, 0x00d00008,
+  0x00400f00, 0x00e80460, 0x004a601f, 0x00218a00, 0x00a2000b, 0x00a70100,
+  0x00e50001, 0x00773088, 0x00155a00, 0x00b07100, 0x00777c2e, 0x00aa0006,
+  0x00177004, 0x00233700, 0x00e70001, 0x00177300, 0x00522500, 0x005aa700,
+  0x00b0200b, 0x00b0a006, 0x00d0361a, 0x0001033c, 0x0002093c, 0x00d00008,
+  0x00500f00, 0x00ed0459, 0x008c04b1, 0x00a2000a, 0x00712c23, 0x00722c60,
+  0x00ed045e, 0x008c04a8, 0x00d0321e, 0x00142030, 0x008c1462, 0x00722210,
+  0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 0x00311010, 0x00b02001,
+  0x00b01eff, 0x003ee001, 0x00ed046c, 0x008c081b, 0x00a11e01, 0x00ed046f,
+  0x008c0885, 0x00d00217, 0x00a20006, 0x00722e10, 0x009c1474, 0x00d04814,
+  0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 0x00b01eff, 0x00b02efe,
+  0x00b0defd, 0x003ee003, 0x00ed047e, 0x008c081b, 0x00ad1e01, 0x00a21e01,
+  0x00a11e01, 0x00500200, 0x009c1474, 0x00d00090, 0x00a20006, 0x00722e00,
+  0x009c1488, 0x00d0011b, 0x00d12040, 0x00e30001, 0x00133100, 0x00622300,
+  0x00b01eff, 0x00b02efe, 0x00b0defd, 0x003ee003, 0x00ed0492, 0x008c0885,
+  0x00ad1e01, 0x00a21e01, 0x00a11e01, 0x00500200, 0x009c1488, 0x00d0011b,
+  0x00e300a0, 0x00731023, 0x00e40001, 0x00a10300, 0x00d21040, 0x009c34a0,
+  0x00422000, 0x00840d00, 0x00144200, 0x00611400, 0x00742c22, 0x00b01300,
+  0x00533200, 0x0072244c, 0x0072403e, 0x00840d00, 0x00e300a0, 0x00731023,
+  0x00e40001, 0x00144200, 0x00a10300, 0x00511400, 0x00d00090, 0x00b01300,
+  0x00840d00, 0x00a30201, 0x0007033c, 0x0077005e, 0x00eb0450, 0x00ea0460,
+  0x002bb100, 0x00b07201, 0x00773d00, 0x00c0703f, 0x009c14bd, 0x00773ca8,
+  0x00d04c11, 0x0047301f, 0x00c0701f, 0x009c14c1, 0x00e70000, 0x00a9000b,
+  0x00e80001, 0x00188700, 0x0078003f, 0x00780020, 0x006880ff, 0x00499800,
+  0x00a40b00, 0x00b0900b, 0x00a60005, 0x00e70001, 0x00177100, 0x00777210,
+  0x006770ff, 0x00a80001, 0x00a90002, 0x00aa0006, 0x00488700, 0x00499700,
+  0x004aa700, 0x00b08001, 0x00a80004, 0x00b09002, 0x00488700, 0x00a9001a,
+  0x00499700, 0x00b0a006, 0x00b0901a, 0x00aa001c, 0x004aa700, 0x00b08004,
+  0x00b0a01c, 0x00a00200, 0x00d50050, 0x00455001, 0x00773c3f, 0x00555700,
+  0x009814ef, 0x00d00090, 0x00a700f4, 0x00181001, 0x00155800, 0x00407500,
+  0x009814ef, 0x00155001, 0x00740062, 0x00a70200, 0x009814f8, 0x00773c3e,
+  0x009814f8, 0x00177100, 0x00566700, 0x00e70003, 0x00747040, 0x00d05010,
+  0x00a70200, 0x009c14fc, 0x00740040, 0x00d05010, 0x00547002, 0x00e70001,
+  0x00177110, 0x00566700, 0x00b04b00, 0x00b06005, 0x00b050f5, 0x00840d00,
+  0x00ec0001, 0x00da3040, 0x008c2508, 0x00d0001f, 0x0016ca00, 0x00eb0460,
+  0x00633600, 0x002bba00, 0x00e40500, 0x00ab0b00, 0x0079bc88, 0x00169004,
+  0x00244600, 0x0076bc2e, 0x009c156b, 0x00d00090, 0x0017c900, 0x00a1001c,
+  0x00411700, 0x009c1505, 0x00d00090, 0x00a7040b, 0x00a1040e, 0x00401001,
+  0x009c151f, 0x00500700, 0x009c1505, 0x004110fe, 0x0076bc84, 0x00a8040c,
+  0x00b0140e, 0x00981505, 0x0075bcb8, 0x00255001, 0x00a1040f, 0x0016563e,
+  0x009c152a, 0x00e60001, 0x00751cc9, 0x00155002, 0x00d11070, 0x00211001,
+  0x00355100, 0x00305600, 0x00982505, 0x0006043c, 0x00b01eff, 0x00b02efe,
+  0x00b03efd, 0x00b04efc, 0x003ee004, 0x0071bc56, 0x0098153c, 0x00f40000,
+  0x00992541, 0x00d0531e, 0x00f00000, 0x00991541, 0x00ed0540, 0x008c0498,
+  0x009c1548, 0x00d00090, 0x00d00090, 0x00a41e01, 0x00a31e01, 0x00a21e01,
+  0x00a11e01, 0x00d05015, 0x0075bc84, 0x00e40941, 0x007445f0, 0x00544900,
+  0x00745064, 0x00725084, 0x00b04300, 0x0071bcb8, 0x00981553, 0x007210b8,
+  0x0072c034, 0x00211001, 0x00111500, 0x0075bc3d, 0x0072503d, 0x005f2c00,
+  0x00a20603, 0x005f0200, 0x0075bc3d, 0x0098155d, 0x00222100, 0x0075bc60,
+  0x00a8060c, 0x00388100, 0x009c2562, 0x0008003c, 0x00b05ac0, 0x00b02603,
+  0x00b0160b, 0x00b0860c, 0x00a41e01, 0x00a31e01, 0x00a21e01, 0x00a11e01,
+  0x00d05015, 0x00a8040d, 0x009835d8, 0x0075bcb8, 0x00a70402, 0x009835d8,
+  0x0077bc84, 0x00255001, 0x00a8040f, 0x0016573e, 0x009c1576, 0x00e60001,
+  0x00d58670, 0x00982505, 0x00306010, 0x0098357c, 0x009c8505, 0x009c8505,
+  0x003707fe, 0x00983580, 0x00e60001, 0x00166700, 0x0007043c, 0x00b03eff,
+  0x003ee001, 0x0071bc56, 0x009c1588, 0x00f00000, 0x0099158d, 0x00d0581a,
+  0x00f50000, 0x0099258d, 0x00ed058c, 0x008c0498, 0x009c1591, 0x00d00090,
+  0x00d00090, 0x00a31e01, 0x00d05015, 0x0075bc84, 0x00e407f4, 0x007445f0,
+  0x00544900, 0x00745064, 0x00746127, 0x0015c900, 0x00b04300, 0x00a9001b,
+  0x00599500, 0x0004073c, 0x00b0901b, 0x0070bc65, 0x009815d9, 0x00e54002,
+  0x0071bcb8, 0x009815a4, 0x007510b8, 0x0075c034, 0x0071bc84, 0x007510a4,
+  0x0071bc3d, 0x0075103d, 0x005f2500, 0x00a20404, 0x00156002, 0x005f0200,
+  0x00af2800, 0x00366001, 0x009c15ac, 0x0076bc60, 0x0070bc3d, 0x008815b3,
+  0x00222500, 0x00a70402, 0x00a9040d, 0x00b06ac0, 0x00377500, 0x00399500,
+  0x009c35ce, 0x00d00090, 0x00a90405, 0x00309700, 0x009825be, 0x0009073c,
+  0x00a50401, 0x00b0940c, 0x00705c26, 0x009815ce, 0x00d00090, 0x00a50406,
+  0x00a10409, 0x00211500, 0x0078022f, 0x00b01409, 0x00b01403, 0x00b0deff,
+  0x003ee001, 0x00ed05cd, 0x008c0028, 0x00ad1e01, 0x00a1000b, 0x0016ca00,
+  0x00611600, 0x00b02404, 0x00b0100b, 0x00b0940d, 0x00b0840f, 0x00b07402,
+  0x00a31e01, 0x00d05015, 0x00d05015, 0x0071bc84, 0x00c01000, 0x009c15ea,
+  0x00e14102, 0x00e50310, 0x00715210, 0x005f2100, 0x00a20404, 0x00efeeee,
+  0x005f0200, 0x00a12800, 0x001f1000, 0x001f1038, 0x001f1030, 0x001f1028,
+  0x00e50004, 0x00d05a1f, 0x00e14112, 0x00e50110, 0x00715210, 0x005f2100,
+  0x00a20404, 0x00efffcc, 0x005f0200, 0x00a12800, 0x001f1000, 0x001f1030,
+  0x00e50004, 0x00d05a1f, 0x00d87040, 0x0098261a, 0x00e20001, 0x00122800,
+  0x0009083c, 0x00199004, 0x00e20500, 0x00299200, 0x00677200, 0x00a0090b,
+  0x009c161a, 0x00f40000, 0x00aa0903, 0x00ab0902, 0x0099161a, 0x009835f6,
+  0x00e100af, 0x00e2061b, 0x00a00100, 0x009c101e, 0x00548050, 0x00742210,
+  0x00a20011, 0x00b04100, 0x00a30901, 0x00733c2f, 0x00723037, 0x005f0200,
+  0x005f0a00, 0x00e20080, 0x002aa200, 0x0013203e, 0x003bb200, 0x00b0a903,
+  0x00b0390b, 0x00b0b902, 0x00d0011e, 0x00ad090e, 0x00ab090b, 0x00ac090f,
+  0x00ff1000, 0x00a40d0a, 0x00a80d09, 0x00b040e9, 0x007f8c61, 0x00ff3000,
+  0x004f8080, 0x00b0e009, 0x00ae0d0f, 0x00a20d0b, 0x00981635, 0x00d00090,
+  0x00d00090, 0x00ad1e01, 0x00aa1e01, 0x00a81e01, 0x00a71e01, 0x00a61e01,
+  0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a11e01, 0x00840200, 0x00e2063a,
+  0x00a400ed, 0x00c04007, 0x009c1709, 0x00d00090, 0x00d00090, 0x00080f3c,
+  0x003bb001, 0x00b080eb, 0x00d00090, 0x009a864c, 0x00d00090, 0x00a00d13,
+  0x009c2648, 0x00d00090, 0x00d00090, 0x00b2ac00, 0x000a083c, 0x00d06316,
+  0x00e4ffff, 0x000a083c, 0x00b04d13, 0x00d06316, 0x00a50d06, 0x00105001,
+  0x009c2641, 0x00d00090, 0x00a100e9, 0x00745d08, 0x00b01d0a, 0x00761d00,
+  0x00374600, 0x00745d00, 0x00366400, 0x00577600, 0x00677500, 0x0098265b,
+  0x00d06411, 0x00a70d09, 0x00711c48, 0x00777c41, 0x003771fb, 0x00ff1000,
+  0x00a40d09, 0x00747041, 0x004f7003, 0x00b04d09, 0x00307004, 0x009c266e,
+  0x00d00090, 0x00a400ed, 0x00e2066c, 0x00c04007, 0x009c1709, 0x00d00090,
+  0x003bb001, 0x00000f3c, 0x00307007, 0x00983678, 0x00ff2000, 0x00d00090,
+  0x00d00090, 0x00d00090, 0x00080f3c, 0x00ff3000, 0x000f083c, 0x00d0671f,
+  0x00a400ed, 0x00e2067c, 0x00c04007, 0x009c1709, 0x00d00090, 0x003bb001,
+  0x00080f3c, 0x00b0c90f, 0x00738d10, 0x00333001, 0x00705c3d, 0x009816a7,
+  0x00303004, 0x009826a7, 0x00708610, 0x009c26a7, 0x00d00090, 0x00a400ed,
+  0x00e2068d, 0x00c04007, 0x009c1709, 0x003bb001, 0x00333004, 0x00040f3c,
+  0x00044040, 0x00744201, 0x00748859, 0x001440be, 0x00788c5a, 0x00588001,
+  0x001880bf, 0x00a5090f, 0x00a20d0e, 0x00d55070, 0x00155002, 0x00255101,
+  0x00a00d13, 0x0098269f, 0x00355004, 0x00d00090, 0x00d00090, 0x00b28200,
+  0x00a80d04, 0x00255800, 0x00b24200, 0x00b25200, 0x00b02d0e, 0x00c01003,
+  0x009c16b3, 0x00d00090, 0x00a40d13, 0x009826ad, 0x00d06b10, 0x00444001,
+  0x00b2ac00, 0x00b04d13, 0x00e5fffc, 0x00e1ffff, 0x00d06b15, 0x002510fd,
+  0x00d00090, 0x00303504, 0x009826c0, 0x00d00090, 0x00a400ed, 0x00e206bc,
+  0x00c04007, 0x009c1709, 0x003bb001, 0x00333004, 0x00080f3c, 0x00d06b15,
+  0x00477003, 0x00357300, 0x00255101, 0x00ff1000, 0x00a40d09, 0x00745041,
+  0x004f5003, 0x00b04d09, 0x00301303, 0x009816f6, 0x00c05004, 0x009c16eb,
+  0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 0x00ff3000,
+  0x000f083c, 0x00d06f16, 0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090,
+  0x00040f3c, 0x00ff3000, 0x000f043c, 0x00155003, 0x00144500, 0x0015503d,
+  0x00330300, 0x009c26e1, 0x00e30000, 0x00357500, 0x00355004, 0x00155003,
+  0x00144500, 0x00350500, 0x00144500, 0x00355020, 0x00188500, 0x00588400,
+  0x00d06f16, 0x00455003, 0x00305700, 0x009826d4, 0x00e206f3, 0x00a400ed,
+  0x00c04007, 0x009c1709, 0x00d00090, 0x003bb001, 0x00080f3c, 0x00d00090,
+  0x00500100, 0x009c26f9, 0x00ea0000, 0x00211001, 0x00111003, 0x00310100,
+  0x00188100, 0x00211020, 0x001aa100, 0x00310100, 0x001aa100, 0x00211020,
+  0x00188100, 0x00e40001, 0x00588a00, 0x00b04d13, 0x00b080eb, 0x00e20636,
+  0x00d0631f, 0x00b0c90f, 0x00b02d0b, 0x00b0b90b, 0x00ff2000, 0x00b01eff,
+  0x00b03efe, 0x00b04efd, 0x00b05efc, 0x00b06efb, 0x00b07efa, 0x00b08ef9,
+  0x00b0aef8, 0x00b0def7, 0x003ee009, 0x00a100e9, 0x00a40d09, 0x00b01d0a,
+  0x00b0ed0f, 0x00050f3c, 0x00754100, 0x00ae0009, 0x00b05d09, 0x00a0090b,
+  0x009c132e, 0x00e400af, 0x00e80001, 0x00b00400, 0x00a10002, 0x0071803f,
+  0x00b00002, 0x00b01003, 0x00d0321e, 0x00a2090e, 0x00ff1000, 0x007f2c61,
+  0x00ff3000, 0x005f0200, 0x00500a00, 0x009c1731, 0x00fa0000, 0x00ec04e0,
+  0x00ed0008, 0x00a4090b, 0x00a6090f, 0x00774cca, 0x0088173b, 0x003dd700,
+  0x00500f00, 0x00377001, 0x009c3738, 0x00402001, 0x009c1740, 0x00d00090,
+  0x00772c41, 0x00244700, 0x00774cc2, 0x00a0090c, 0x008c1747, 0x00774d00,
+  0x0005073c, 0x00277003, 0x0017703e, 0x003dd700, 0x00a10c09, 0x00ab0c00,
+  0x00311700, 0x00a20c01, 0x00b01c09, 0x00a40c02, 0x00a10c03, 0x00aa0909,
+  0x00a80908, 0x00500700, 0x0098377a, 0x00d00090, 0x00d00090, 0x00a30c08,
+  0x009c175d, 0x00e300c0, 0x00ab0c04, 0x00a20c05, 0x00a40c06, 0x00b03c08,
+  0x00a10c07, 0x00333001, 0x00d00090, 0x00b03c08, 0x00530f00, 0x00a0090c,
+  0x008c1769, 0x003505fc, 0x00982769, 0x00155003, 0x00133500, 0x00350500,
+  0x00133500, 0x00350500, 0x00783210, 0x0078b021, 0x001bb03f, 0x007b203f,
+  0x0012203f, 0x00133030, 0x007a3210, 0x007a4021, 0x0014403f, 0x0074103f,
+  0x0011103f, 0x00b28600, 0x00b2a600, 0x00377001, 0x009c3755, 0x00d00090,
+  0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03, 0x003dd001, 0x00982784,
+  0x00d00090, 0x00d00090, 0x00500f00, 0x00d0771e, 0x00fa2000, 0x00a2090e,
+  0x0042200e, 0x00b0090b, 0x0047f080, 0x00522700, 0x00b0690f, 0x00b0290e,
+  0x00d04519, 0x00d77040, 0x00e90500, 0x007c7484, 0x002cc900, 0x00e90016,
+  0x00a50c0b, 0x00705d00, 0x009c17f3, 0x00d00090, 0x00ab0c0c, 0x008c37d0,
+  0x00a20c01, 0x00702c3c, 0x009817f3, 0x00eb04e0, 0x00a90c0f, 0x00a30c0d,
+  0x00a80b09, 0x009817cf, 0x00e20016, 0x00a40b00, 0x00a50b01, 0x00a60b02,
+  0x00a70b03, 0x00d09270, 0x009c27cf, 0x00e20008, 0x00308008, 0x009c27ab,
+  0x0002083c, 0x00aa0b08, 0x009c17b3, 0x00ea00c0, 0x00a50b05, 0x00b0ab08,
+  0x00a40b04, 0x00a60b06, 0x00a70b07, 0x003aa001, 0x00d00090, 0x00b0ab08,
+  0x00aa0c08, 0x007a4021, 0x0014403f, 0x0074503f, 0x0015503f, 0x00b2a900,
+  0x00aa0c09, 0x007a6021, 0x0016603f, 0x0076703f, 0x0017703f, 0x00b2a900,
+  0x00233008, 0x00388001, 0x00322001, 0x009c37ab, 0x00d00090, 0x00b04b00,
+  0x00b05b01, 0x00b06b02, 0x00b07b03, 0x00b03c02, 0x00b03c0d, 0x00b08b09,
+  0x00b09c0f, 0x00d07f13, 0x00aa0c0f, 0x00a80c01, 0x00718c3b, 0x009817d7,
+  0x00f40000, 0x009927f3, 0x00d07d19, 0x00f00000, 0x009917f3, 0x00d0a970,
+  0x009c27f3, 0x00d00090, 0x00ed07de, 0x008c0498, 0x009817f3, 0x00e40729,
+  0x007445f0, 0x00544750, 0x00a90c03, 0x00b04300, 0x00788c2f, 0x00728037,
+  0x0046901f, 0x005f2051, 0x004f90e0, 0x003606e0, 0x00306b00, 0x009837ed,
+  0x00060b3c, 0x00756100, 0x003bb600, 0x00299600, 0x00b0bc0c, 0x00b09c03,
+  0x00b05c0b, 0x00d00211, 0x00f50000, 0x00500a00, 0x009c17f8, 0x00f00000,
+  0x00761d27, 0x00a40901, 0x00000f3c, 0x00366001, 0x009c17fa, 0x00724ca0,
+  0x0030201f, 0x009c1801, 0x00724ca8, 0x00e60001, 0x00a8000b, 0x001b6200,
+  0x00568b00, 0x00e80001, 0x00b0600b, 0x00ab001b, 0x00188300, 0x006bb800,
+  0x00a70902, 0x00b0b01b, 0x009c3819, 0x0001033c, 0x00b00902, 0x00b01eff,
+  0x00b02efe, 0x00b0aefd, 0x003ee003, 0x0002093c, 0x00ed0816, 0x008c04b1,
+  0x00aa1e01, 0x00a21e01, 0x00a11e01, 0x00010a3c, 0x00d04519, 0x00b0deff,
+  0x003ee001, 0x00771484, 0x00e50500, 0x00277500, 0x0005013c, 0x00ab0701,
+  0x0071bc3b, 0x00981827, 0x00f40000, 0x0099285a, 0x00d0821a, 0x00f00000,
+  0x0099185a, 0x00d00090, 0x00a90703, 0x00a3070b, 0x00a8070f, 0x00a4070e,
+  0x00404001, 0x009c1833, 0x00500300, 0x009c185a, 0x00d00090, 0x00aa070c,
+  0x0098185a, 0x00738d07, 0x004330fc, 0x00303022, 0x00982863, 0x0040a080,
+  0x00981863, 0x00d00090, 0x0040907f, 0x009c1863, 0x00d48070, 0x00d00090,
+  0x00303421, 0x0098385e, 0x00ed0844, 0x008c0498, 0x0098185a, 0x00e40941,
+  0x007445f0, 0x00544550, 0x00a10008, 0x0076bc2f, 0x00716037, 0x00b04300,
+  0x005f1200, 0x005f0900, 0x00a4070e, 0x00740020, 0x00a30701, 0x00b0470e,
+  0x00733c26, 0x00133007, 0x00299300, 0x00e30080, 0x003aa300, 0x00b09703,
+  0x00b0a70c, 0x00b0370b, 0x00ad1e01, 0x00d00090, 0x00d00090, 0x00840d00,
+  0x0076bca0, 0x00e40001, 0x0074403f, 0x00144600, 0x0098285a, 0x00d48070,
+  0x003043f6, 0x009c285a, 0x00ed0868, 0x008c0498, 0x0098185a, 0x00e4090b,
+  0x007445f0, 0x00544550, 0x0076bc2f, 0x00726037, 0x005f2051, 0x004f90e0,
+  0x00b04300, 0x0043901f, 0x00a4070e, 0x00740020, 0x00d00090, 0x00b0470e,
+  0x00a40701, 0x00744c26, 0x0098187a, 0x003993e0, 0x003403e0, 0x003aa400,
+  0x009c287e, 0x000a003c, 0x00a3070b, 0x00743cca, 0x00d00090, 0x003304f8,
+  0x00133002, 0x007340ca, 0x00d08517, 0x00741484, 0x00e70500, 0x00244700,
+  0x00e20020, 0x00a0040b, 0x009c18de, 0x00d00090, 0x00ac0401, 0x0070cc3a,
+  0x009c1892, 0x00f00000, 0x009918de, 0x00d08914, 0x00f50000, 0x009928de,
+  0x00d00090, 0x00a6040f, 0x00a7040d, 0x00a50404, 0x0043501f, 0x009c18df,
+  0x00207080, 0x009828df, 0x00d76270, 0x009828df, 0x009c88de, 0x009c88de,
+  0x00e20080, 0x00d00090, 0x00a70007, 0x007ccc2f, 0x0077c037, 0x005f0700,
+  0x005f0500, 0x00d02000, 0x00af2600, 0x00a70402, 0x00b0640f, 0x00255200,
+  0x00377200, 0x00b05404, 0x00b07402, 0x009c38b9, 0x00d00090, 0x00b00402,
+  0x0002043c, 0x00b0deff, 0x003ee001, 0x00ed08b7, 0x008c04b1, 0x00ad1e01,
+  0x00d08d1e, 0x00a3040d, 0x00333200, 0x009c38dd, 0x00e50001, 0x00155100,
+  0x00a2001c, 0x00422500, 0x009c18dd, 0x00d00090, 0x00a20405, 0x00760210,
+  0x00302700, 0x008828c7, 0x0002073c, 0x00b0640f, 0x00b0240c, 0x00b0240d,
+  0x00b07402, 0x00a2040a, 0x00a70409, 0x00a30407, 0x00a50406, 0x00222300,
+  0x00277500, 0x00b0240a, 0x00b07409, 0x00b02404, 0x00b07403, 0x0003013c,
+  0x0001073c, 0x00b0deff, 0x003ee001, 0x00ed08db, 0x008c0028, 0x00ad1e01,
+  0x00d08d1e, 0x00b0340d, 0x00840d00, 0x00a2040d, 0x00a0040b, 0x009c18de,
+  0x00222300, 0x00d86070, 0x009818de, 0x00188002, 0x00288300, 0x004880fc,
+  0x00308020, 0x009838eb, 0x00e80020, 0x00308200, 0x009828f0, 0x00392001,
+  0x0008023c, 0x00d08f11, 0x00398001, 0x00e74252, 0x007ccc2f, 0x0077c037,
+  0x005f0700, 0x000f9337, 0x004f50e0, 0x004a30fc, 0x003b8a00, 0x00500a00,
+  0x00981900, 0x005f0000, 0x003aa004, 0x009c38fb, 0x00d00090, 0x00d00090,
+  0x00af2600, 0x003bb004, 0x009c3900, 0x003a08e0, 0x004aa0fc, 0x00981909,
+  0x005f0000, 0x003aa004, 0x009c3906, 0x00328300, 0x00d08a19, 0x00a2090e,
+  0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c1913,
+  0x00fa0000, 0x00ab090b, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x0075bcca,
+  0x0098191e, 0x00d00090, 0x00d00090, 0x00500f00, 0x00355001, 0x008c391b,
+  0x0075bcc2, 0x00981925, 0x00d00090, 0x00d00090, 0x00b2f800, 0x00355001,
+  0x008c3922, 0x00b0090b, 0x0002073c, 0x00010a3c, 0x00ed092a, 0x008c04a8,
+  0x00a5090e, 0x0098193f, 0x00ff2000, 0x0045500f, 0x00d00090, 0x00d00090,
+  0x004bf080, 0x00555b00, 0x00a4090c, 0x00981937, 0x00d00090, 0x00b0590e,
+  0x00d0931f, 0x00755c41, 0x00d00090, 0x003505fc, 0x00155003, 0x00350500,
+  0x001bb500, 0x00d00090, 0x00b2b800, 0x00b0890f, 0x00d0321e, 0x00a2090e,
+  0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c1949,
+  0x00fa0000, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x00eb0952, 0x007c1c64,
+  0x002ccb00, 0x00ab090b, 0x00a20908, 0x00840c00, 0x00d09713, 0x00d0961a,
+  0x00d09616, 0x00d09611, 0x00d0951c, 0x00ec0958, 0x00d00008, 0x00b2f800,
+  0x003bb020, 0x00d0971c, 0x00ec095d, 0x00d00004, 0x00b2f800, 0x003bb010,
+  0x00d0971c, 0x00ec0962, 0x00d00002, 0x00b2f800, 0x003bb008, 0x00d0971c,
+  0x00ec0967, 0x00b2f800, 0x003bb004, 0x00d0971c, 0x00ec096b, 0x00122030,
+  0x0072f210, 0x003bb002, 0x008c197c, 0x00d00090, 0x00d00090, 0x00b22800,
+  0x00d0971c, 0x00ec0974, 0x00122038, 0x0072f118, 0x003bb001, 0x008c197c,
+  0x00d00090, 0x00d00090, 0x00b22800, 0x00d0971c, 0x00a50aec, 0x00355700,
+  0x00801c00, 0x00b02908, 0x00b0b90b, 0x00500b00, 0x009c1987, 0x0002073c,
+  0x00010a3c, 0x00ed0987, 0x008c04a8, 0x00a5090e, 0x0098199c, 0x00ff2000,
+  0x00d00090, 0x00d00090, 0x0045500f, 0x004bf080, 0x00a4090c, 0x00981994,
+  0x00555b00, 0x00d00090, 0x00b0590e, 0x00d0991c, 0x00755c41, 0x00d00090,
+  0x003505fc, 0x00155003, 0x00350500, 0x001bb500, 0x00d00090, 0x00b2b800,
+  0x00b0890f, 0x00d0321e, 0x00707cda, 0x009819a5, 0x00702cda, 0x009819a5,
+  0x0070bcda, 0x009819a5, 0x00840d00, 0x0076002f, 0x00840d00
+};
+
+#define STB7109_C2_IMEM_REGION_LENGTH  0xa00
+#define STB7109_C2_DMEM_REGION_LENGTH  0x600
+
+#define STB7109_C2_IMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7109_C2_IMEM_REGION)
+#define STB7109_C2_DMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7109_C2_DMEM_REGION)
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/7109_cut3_fdma2_firmware.h linux-2.6.23.1-stm/include/linux/stm/7109_cut3_fdma2_firmware.h
--- linux-2.6.23.1/include/linux/stm/7109_cut3_fdma2_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/7109_cut3_fdma2_firmware.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,740 @@
+/*  STb710x FDMA Driver
+ *  Copyright (c) 2006 STMicroelectronics Limited.
+ *  Author: Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef FDMA_7109C3_FIRMWARE
+#define FDMA_7109C3_FIRMWARE
+/*This firmware version 2.2*/
+static unsigned long STB7109_C3_DMEM_REGION[]=
+{
+  0x01060300, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x23104052, 0x23100051, 0x00000000, 0x00000000, 0x00000000,
+  0x21100051, 0x017a0136, 0x017d0139, 0x0180013c, 0x0183013f, 0x63103051,
+  0x003f001f, 0x000001c5, 0x000001c7, 0x000001c9, 0x000001d5, 0x000003a6,
+  0x000003a4, 0x000003a1, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000fe, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x0000007e, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00002416, 0x04a004a0, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00002416, 0x04c004c0,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00002416, 0x04e004e0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffff00, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000241f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001428, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000142d, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001432,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001437, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000143c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001441,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001446, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000144b, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001450,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001455, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000145a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000145f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001464, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001469, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000146e
+};
+
+static unsigned long STB7109_C3_IMEM_REGION[]=
+{
+   0x00e1ffff, 0x00e200ff, 0x00f51000, 0x00b010f9, 0x00b020fa, 0x00ef0013,
+  0x00e10001, 0x00ee00a0, 0x00b010ea, 0x00f01000, 0x00ef0013, 0x00a300f8,
+  0x00aa000b, 0x00433a00, 0x009c154b, 0x009b3338, 0x009a223e, 0x00d00090,
+  0x00a70005, 0x00177030, 0x009c121e, 0x00d00090, 0x00a70006, 0x00a2001c,
+  0x00672700, 0x009c14b7, 0x00d00090, 0x00a70002, 0x009c1649, 0x00d00090,
+  0x00a70004, 0x009c17ee, 0x00d00090, 0x00a7001a, 0x009c1a3a, 0x00d00090,
+  0x00a90003, 0x009c103b, 0x00d00090, 0x00a20001, 0x009c149f, 0x00d00090,
+  0x00d0001b, 0x00452003, 0x00461003, 0x00355600, 0x00755461, 0x00a6040e,
+  0x00555001, 0x00765080, 0x00d00090, 0x00b0640e, 0x00755c23, 0x00761c62,
+  0x00266500, 0x007564ca, 0x00d00090, 0x00b0540b, 0x00840d00, 0x00e20500,
+  0x00d00090, 0x00aa020e, 0x00f50000, 0x00ab0a0e, 0x00a10a0d, 0x00d0b070,
+  0x009c10ac, 0x00d00090, 0x00a4020f, 0x00a70201, 0x00a30a04, 0x00d54070,
+  0x00305020, 0x0098207d, 0x007c3ce0, 0x009c1081, 0x00e80020, 0x00ed0057,
+  0x00a50007, 0x00777c2f, 0x00757037, 0x005f0500, 0x005f0300, 0x00a50a0c,
+  0x00a70a14, 0x00b050e9, 0x00941700, 0x00d00090, 0x00ed005e, 0x00a92400,
+  0x00233004, 0x00b090eb, 0x005f0900, 0x00928100, 0x00388001, 0x008c3059,
+  0x00a50a02, 0x0006033c, 0x00605300, 0x008c1065, 0x00a60a05, 0x00a500e9,
+  0x00b06a04, 0x00b0420f, 0x00b05a0c, 0x00d0b070, 0x009c10ac, 0x00d00090,
+  0x00e60026, 0x00d54070, 0x00306500, 0x00982027, 0x00d00090, 0x00a50202,
+  0x009c1079, 0x00d04070, 0x009c1027, 0x00e10000, 0x00b00003, 0x00ed0027,
+  0x008c04f8, 0x00e10001, 0x00b00003, 0x00b01002, 0x008c0027, 0x00a00202,
+  0x009c1079, 0x00d04070, 0x00981075, 0x004c301f, 0x00155002, 0x00265c00,
+  0x004060e0, 0x00981087, 0x00e60020, 0x00366001, 0x00166008, 0x00ed009c,
+  0x00777c2f, 0x00e54252, 0x00757037, 0x000f053c, 0x005f6c00, 0x004f30e0,
+  0x0018c03e, 0x00981095, 0x000f003c, 0x00388001, 0x008c3092, 0x00a50a0c,
+  0x00166038, 0x00386cff, 0x0018803e, 0x00a70a14, 0x00b050e9, 0x00941700,
+  0x00d00090, 0x00ed00a3, 0x00a92400, 0x00233004, 0x00b090eb, 0x005f0900,
+  0x00928100, 0x00388001, 0x008c309e, 0x003806e1, 0x00981060, 0x000f003c,
+  0x00388004, 0x008c30a7, 0x008c0060, 0x008c00ab, 0x00a30a00, 0x00a80a01,
+  0x009810d0, 0x00d00090, 0x00a50201, 0x00775c2f, 0x00777437, 0x00055035,
+  0x00e64042, 0x005f6700, 0x004f30f0, 0x00a62b00, 0x009c20c0, 0x00d00090,
+  0x005f5001, 0x00ac2b00, 0x00af2b00, 0x004f6001, 0x000f0c3c, 0x008c00c4,
+  0x000f053c, 0x00af2b00, 0x000f063c, 0x000f003c, 0x00233010, 0x00388010,
+  0x009810ce, 0x00d0b070, 0x009c10b4, 0x00d00090, 0x00b08a01, 0x00b03a00,
+  0x00b0ba0e, 0x008c0027, 0x00d0b070, 0x009810ca, 0x00533001, 0x007b0210,
+  0x0008003c, 0x008c00ca, 0x00a50a00, 0x00455001, 0x00941d00, 0x00d00090,
+  0x00b06eff, 0x00b07efe, 0x00b08efd, 0x00b09efc, 0x00b0cefb, 0x003ee005,
+  0x00a60a07, 0x00a70a08, 0x00a800e9, 0x00ec0000, 0x00788d00, 0x00106001,
+  0x009c20f3, 0x00796d08, 0x003c9800, 0x00796d00, 0x00398900, 0x005cc900,
+  0x006cc600, 0x009c20f3, 0x007c6c3d, 0x007cc43e, 0x00666c00, 0x007c7c3d,
+  0x007cc43e, 0x00577c00, 0x00d01012, 0x00107001, 0x009c2109, 0x00797d08,
+  0x003c9800, 0x00797d00, 0x00398900, 0x005cc900, 0x006cc700, 0x009c2109,
+  0x007c7c3d, 0x007cc43e, 0x00677c00, 0x007c6c3d, 0x007cc43e, 0x00566c00,
+  0x00a900e9, 0x00b06a07, 0x00b07a08, 0x00799c48, 0x002993fc, 0x00b28b00,
+  0x00b29b00, 0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01,
+  0x00840d00, 0x00a50a00, 0x00455001, 0x00941d00, 0x00d00090, 0x00b09a10,
+  0x00b01eff, 0x00b02efe, 0x00b06efd, 0x00b07efc, 0x00b08efb, 0x00b09efa,
+  0x00b0cef9, 0x00b04ef8, 0x003ee008, 0x00a800e9, 0x00788d00, 0x0047801f,
+  0x00a40e00, 0x00a900e9, 0x00778ca0, 0x00799c48, 0x0002093c, 0x002993fc,
+  0x00e54400, 0x00155710, 0x009c2151, 0x00d00090, 0x00d04070, 0x009c1131,
+  0x00d00090, 0x00e5016a, 0x00b09a11, 0x00b05a14, 0x00d01611, 0x00a7020d,
+  0x00777e00, 0x00a52400, 0x00a60a10, 0x00840700, 0x00765100, 0x00066001,
+  0x00d01410, 0x00765200, 0x00066002, 0x00d01410, 0x00765300, 0x00066003,
+  0x00d01410, 0x0006053c, 0x00066040, 0x00d56040, 0x00a40a12, 0x003505e1,
+  0x00166500, 0x002505e1, 0x00166500, 0x00366001, 0x00306400, 0x00b06a12,
+  0x00983159, 0x00d00090, 0x00a60a08, 0x00266001, 0x00d00090, 0x00b06a08,
+  0x00d01611, 0x00e50270, 0x00155710, 0x00982159, 0x00780327, 0x00d00090,
+  0x00b28b00, 0x00b29b00, 0x00d01611, 0x00ac0a08, 0x00b00a08, 0x002cc001,
+  0x0078c308, 0x00780027, 0x00d00090, 0x00b28b00, 0x00b29b00, 0x00a41e01,
+  0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00a21e01,
+  0x00a11e01, 0x00840d00, 0x00b01eff, 0x00b02efe, 0x00b03efd, 0x00b04efc,
+  0x00b05efb, 0x00b0befa, 0x003ee006, 0x00a20a11, 0x00752c40, 0x00a32400,
+  0x00b00a14, 0x00a5050d, 0x00755e10, 0x00a10a10, 0x00d00090, 0x00840500,
+  0x00713100, 0x00011001, 0x00d01814, 0x00713200, 0x00011002, 0x00d01814,
+  0x00713300, 0x00011003, 0x00d01814, 0x0001033c, 0x00011040, 0x00d51040,
+  0x00a30a12, 0x003505e1, 0x00111500, 0x002505e1, 0x00111500, 0x00311001,
+  0x00a50a08, 0x00b01a12, 0x00255001, 0x00301300, 0x00983194, 0x00d00090,
+  0x00b05a08, 0x00d0191c, 0x00a10a0c, 0x00a30a11, 0x00b00a08, 0x00715308,
+  0x00710027, 0x00d00090, 0x00b21b00, 0x00b23b00, 0x00a01e01, 0x00a51e01,
+  0x00a41e01, 0x00a31e01, 0x00a21e01, 0x00a11e01, 0x00840d00, 0x00a50a00,
+  0x00455001, 0x00941d00, 0x00d00090, 0x00b09a10, 0x00b01eff, 0x00b06efe,
+  0x00b07efd, 0x00b08efc, 0x00b09efb, 0x00b0cefa, 0x00b04ef9, 0x003ee007,
+  0x00a100e9, 0x00701c65, 0x009c11e6, 0x00781c48, 0x00a60012, 0x0041101f,
+  0x00106100, 0x009c21e6, 0x0005083c, 0x002883fc, 0x00c0100b, 0x009811c1,
+  0x00d00090, 0x00d00090, 0x00b21b00, 0x00b28b00, 0x00d01e16, 0x00a60513,
+  0x00d00090, 0x00d00090, 0x00840600, 0x00779e08, 0x00d01e10, 0x00779e10,
+  0x00d01e10, 0x00e601f0, 0x00d04070, 0x009c11cf, 0x00d00090, 0x00b06a14,
+  0x00d01e1e, 0x0006043c, 0x00779d18, 0x00d00090, 0x00a62600, 0x00776108,
+  0x00d01e10, 0x00e60208, 0x00d04070, 0x009c11db, 0x00d00090, 0x00b06a14,
+  0x00d01e1e, 0x0006043c, 0x00d00090, 0x00d00090, 0x00a72600, 0x00d01e10,
+  0x00077040, 0x00777d37, 0x00717128, 0x00d00090, 0x00b21b00, 0x00b28b00,
+  0x00a41e01, 0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01,
+  0x00a11e01, 0x00840d00, 0x00b08a11, 0x00d01e16, 0x00a90a00, 0x00499001,
+  0x00941d00, 0x00d00090, 0x00b06eff, 0x00b08efe, 0x00b04efd, 0x003ee003,
+  0x00a90a10, 0x00a80a11, 0x00a62400, 0x00166008, 0x00769918, 0x00066040,
+  0x00766d37, 0x00799d10, 0x00796128, 0x00b00a14, 0x00b29b00, 0x00b28b00,
+  0x00a41e01, 0x00a81e01, 0x00a61e01, 0x00840d00, 0x00a90a00, 0x00499001,
+  0x00941d00, 0x00d00090, 0x00b06eff, 0x00b08efe, 0x00b04efd, 0x003ee003,
+  0x00a90a10, 0x00a80a11, 0x00a62400, 0x00799d18, 0x00066040, 0x00766d37,
+  0x00796128, 0x00b00a14, 0x00b29b00, 0x00b28b00, 0x00a41e01, 0x00a81e01,
+  0x00a61e01, 0x00840d00, 0x00f40000, 0x00d87040, 0x00982238, 0x00e10500,
+  0x00198004, 0x00299100, 0x00e10001, 0x00aa0900, 0x00ed0228, 0x008c04df,
+  0x00981238, 0x00e4034a, 0x007445f0, 0x00544850, 0x00a1000c, 0x00b04300,
+  0x005f1200, 0x004fa0e0, 0x00ea0001, 0x00ab090f, 0x001aa800, 0x007b01f0,
+  0x00677a00, 0x00b0b90f, 0x00b0b90b, 0x00d0211f, 0x00aa0005, 0x00d00090,
+  0x007a7210, 0x00d00090, 0x00b0a005, 0x00d00116, 0x00ac00f0, 0x00a80005,
+  0x00d1c040, 0x00982336, 0x0011103f, 0x00ed0450, 0x001a1001, 0x002dd100,
+  0x00320a00, 0x0013c200, 0x00193a00, 0x00e20250, 0x00222300, 0x006cc900,
+  0x00eb0500, 0x0005013c, 0x00155004, 0x00255b00, 0x00840200, 0x00d02d19,
+  0x00d02917, 0x00a40501, 0x00724ca0, 0x00981297, 0x00e40460, 0x00244200,
+  0x00c0201f, 0x00981297, 0x00eb0001, 0x00a20400, 0x00702c2e, 0x009c1297,
+  0x001bb100, 0x00a2001c, 0x00522b00, 0x00588b00, 0x00b0201c, 0x00a2050f,
+  0x00aa050c, 0x00ab050b, 0x0070bd00, 0x009c1240, 0x00d22070, 0x00981297,
+  0x00f50000, 0x00991240, 0x00122002, 0x00b0050c, 0x00ab050d, 0x0030b200,
+  0x009c2272, 0x00020b3c, 0x003bb200, 0x00b0250d, 0x00b0deff, 0x00b01efe,
+  0x00b05efd, 0x00b0befc, 0x00b0aefb, 0x00b08efa, 0x003ee006, 0x00ed027d,
+  0x008c08e5, 0x00a81e01, 0x00aa1e01, 0x00ab1e01, 0x00a51e01, 0x00a11e01,
+  0x00ad1e01, 0x00a2050d, 0x00b0a50c, 0x0098128a, 0x002bb200, 0x00d00090,
+  0x00b0b50d, 0x00d02410, 0x00b0deff, 0x00b05efe, 0x00b01efd, 0x003ee003,
+  0x00b0b50d, 0x00ed0292, 0x00000b3c, 0x00981922, 0x00d00090, 0x00d00090,
+  0x00a11e01, 0x00a51e01, 0x00ad1e01, 0x00a2050b, 0x00702d00, 0x009c1240,
+  0x00e20001, 0x00122100, 0x00ab001b, 0x004bb200, 0x009c1240, 0x00588200,
+  0x00a40501, 0x00eb0001, 0x007a4ca0, 0x001bba00, 0x004bb0fe, 0x009812b2,
+  0x009c22ad, 0x007a4d00, 0x00c0a03f, 0x009c12b2, 0x007a4ca8, 0x00eb0001,
+  0x001bba00, 0x00a3000b, 0x006bb0ff, 0x00433b00, 0x00d00090, 0x00b0300b,
+  0x00ab050b, 0x0070bd00, 0x009c1240, 0x00722210, 0x006220ff, 0x00ab0001,
+  0x00a40002, 0x004bb200, 0x00444200, 0x00b0b001, 0x00ab0006, 0x00b04002,
+  0x00a40004, 0x004bb200, 0x00444200, 0x00488200, 0x00b0b006, 0x00b04004,
+  0x00ab001c, 0x004bb200, 0x00a4001a, 0x00b0b01c, 0x00444200, 0x00eb0003,
+  0x00b0401a, 0x00a40d00, 0x0074b0a0, 0x00a300f4, 0x001b1001, 0x00e20001,
+  0x00122b00, 0x00402300, 0x009812d5, 0x00122001, 0x00740062, 0x00b020f5,
+  0x00b04d00, 0x00b090f2, 0x00d02410, 0x00e40001, 0x00144100, 0x006440ff,
+  0x00488400, 0x00a60d00, 0x0042601f, 0x004660e0, 0x00566002, 0x00c02000,
+  0x00b06d00, 0x009812ea, 0x00e20001, 0x00122110, 0x00588200, 0x00b06500,
+  0x00b090f2, 0x00d02410, 0x00a00502, 0x009c12f5, 0x0002053c, 0x00b0ceff,
+  0x00b08efe, 0x003ee002, 0x00ed02f2, 0x008c04f8, 0x00a81e01, 0x00ac1e01,
+  0x00d02410, 0x00a40501, 0x00b06d00, 0x0042401f, 0x00981313, 0x0042403f,
+  0x00c0201f, 0x0098131a, 0x00c0203f, 0x00981321, 0x00e60460, 0x0042401f,
+  0x00e40001, 0x00144200, 0x00a3000b, 0x00533400, 0x00266200, 0x00b0300b,
+  0x00a20600, 0x00721088, 0x00742c2e, 0x00b02600, 0x00144004, 0x00244100,
+  0x00e60001, 0x00166400, 0x00a20006, 0x00522600, 0x00b090f2, 0x00b02006,
+  0x00d02410, 0x00a20001, 0x00eb0001, 0x001bb100, 0x00522b00, 0x00b090f2,
+  0x00b02001, 0x00d02410, 0x00a20002, 0x00eb0001, 0x001bb100, 0x00522b00,
+  0x00b090f2, 0x00b02002, 0x00d02410, 0x00724ca8, 0x00eb0001, 0x001bb200,
+  0x00a3000b, 0x00533b00, 0x00a20004, 0x00b0300b, 0x00eb0001, 0x001bb100,
+  0x00a2001a, 0x00704c2d, 0x00981331, 0x00522b00, 0x00b090f2, 0x00b0201a,
+  0x00d02410, 0x00a20004, 0x00522b00, 0x00b090f2, 0x00b02004, 0x00d02410,
+  0x00b08005, 0x00d00112, 0x00d80050, 0x00788c4c, 0x00981010, 0x00da8040,
+  0x00e600a0, 0x0076a023, 0x00a70aec, 0x00767060, 0x00d00090, 0x00a10600,
+  0x00b0600a, 0x00731c80, 0x00741df0, 0x00751c64, 0x00e20500, 0x00793484,
+  0x00299200, 0x00840400, 0x00f50000, 0x0007093c, 0x00d00090, 0x00d00008,
+  0x00b1f701, 0x00a00902, 0x00981493, 0x00d00090, 0x00a70903, 0x00a20904,
+  0x00a60901, 0x007b7c5e, 0x007b283f, 0x006bb003, 0x0076b05a, 0x00ebffff,
+  0x00ed0366, 0x0041603f, 0x00c0101f, 0x009c19fe, 0x007a6c88, 0x001aa005,
+  0x00e20480, 0x002aa200, 0x00ed0386, 0x00ab0a04, 0x00a20a00, 0x008c09fe,
+  0x0040601f, 0x00b06901, 0x0098136c, 0x00c0103f, 0x009813ad, 0x00d0471d,
+  0x00e70001, 0x00d00008, 0x00400f00, 0x00a20001, 0x00177300, 0x00522700,
+  0x00a10903, 0x00b02001, 0x00a20905, 0x00a70902, 0x00307200, 0x008c2379,
+  0x0002073c, 0x00a10903, 0x00b0290c, 0x00b0290d, 0x00a20904, 0x00b01909,
+  0x00b0290a, 0x0004093c, 0x00b0deff, 0x003ee001, 0x00ed0384, 0x008c002b,
+  0x00ad1e01, 0x00d04919, 0x00d00008, 0x00400f00, 0x00a70002, 0x00eb0001,
+  0x0012b300, 0x00577200, 0x00b0a90e, 0x00b07002, 0x00b0090b, 0x00b06901,
+  0x00a00a0d, 0x008c1499, 0x00a60a0e, 0x00760210, 0x00a20a0f, 0x00ab0a07,
+  0x00722a10, 0x007bbc5b, 0x00b02a0f, 0x00a20b17, 0x00b00a14, 0x00b00a09,
+  0x00b00a0a, 0x00b00a0b, 0x00b00a0c, 0x00b06a0e, 0x00840200, 0x00e6010f,
+  0x00b00a08, 0x00d03a17, 0x00e601a3, 0x00d03a17, 0x00e600d4, 0x00a2090f,
+  0x00b06a0d, 0x00720210, 0x00b00a13, 0x00b0290f, 0x00d04919, 0x00706c2d,
+  0x009c1450, 0x00d00090, 0x00ac090f, 0x00ed0450, 0x007c0210, 0x002dd300,
+  0x00eb04e0, 0x00b0c90f, 0x00a00b09, 0x009813d1, 0x00d00090, 0x00a10903,
+  0x00711c62, 0x00a2090e, 0x00522001, 0x00762c23, 0x00211600, 0x00b0290e,
+  0x0011100a, 0x00d00008, 0x00500f00, 0x00b0190b, 0x00a10902, 0x00a20901,
+  0x00702c3d, 0x009813cb, 0x00d00090, 0x00b0190c, 0x00d03e1a, 0x00e10001,
+  0x0072103c, 0x00b0090c, 0x00b02901, 0x00e10000, 0x00d03e1a, 0x0028b004,
+  0x00a10903, 0x00d00004, 0x00b1f801, 0x00d00004, 0x00500f00, 0x00a20904,
+  0x0004093c, 0x00ed03db, 0x008c002b, 0x00a10902, 0x00a20901, 0x00b0190c,
+  0x00702c3d, 0x009c13ea, 0x00d00090, 0x00a10d00, 0x004110e0, 0x0002093c,
+  0x00b01d00, 0x00b00900, 0x0001033c, 0x00ed03e9, 0x008c04f8, 0x00d04919,
+  0x00211003, 0x0011103e, 0x00111003, 0x00d00090, 0x00b0190d, 0x00b01902,
+  0x00a00b09, 0x009c1438, 0x00d00090, 0x00a10907, 0x00311002, 0x00a20b07,
+  0x00b01b09, 0x00782c44, 0x0042200f, 0x00188002, 0x00b02b07, 0x00b08909,
+  0x00a20b05, 0x00762c44, 0x0042200f, 0x00166002, 0x00b02b05, 0x00b06908,
+  0x00a50b08, 0x009c140e, 0x00d00090, 0x00e500c0, 0x00a20b05, 0x00a10b07,
+  0x00b02b01, 0x00b01b03, 0x00a20b06, 0x00a10b04, 0x00b02b02, 0x00b01b00,
+  0x00355002, 0x00d00090, 0x00b05b08, 0x00a70905, 0x00a50b00, 0x0001073c,
+  0x00716200, 0x00715021, 0x0015503f, 0x00b21c00, 0x00a40b02, 0x00117010,
+  0x00718200, 0x00714021, 0x0014403f, 0x00b21c00, 0x00a70906, 0x0001073c,
+  0x00716200, 0x00715021, 0x0015503f, 0x00b21c00, 0x00117010, 0x00718200,
+  0x00714021, 0x0014403f, 0x00b21c00, 0x00a10b01, 0x0075121e, 0x0011103e,
+  0x00b05b00, 0x00b01b01, 0x00a20b03, 0x0074221e, 0x0012203e, 0x00a1090d,
+  0x00211010, 0x00b04b02, 0x00b02b03, 0x00b0190d, 0x00b01902, 0x00b0c90f,
+  0x00a10901, 0x00721ca8, 0x00e80001, 0x00a00900, 0x009c143e, 0x0071803c,
+  0x00168200, 0x00a5000b, 0x00555600, 0x00148300, 0x00b0500b, 0x00b01901,
+  0x00b04004, 0x00e10460, 0x00211200, 0x00a60d00, 0x00ab0100, 0x007b3088,
+  0x004660e0, 0x00566002, 0x00b0b100, 0x00b06d00, 0x00010a3c, 0x00d04919,
+  0x00ac090f, 0x007c0210, 0x00b0090b, 0x00eb04e0, 0x0028b004, 0x00b0c90f,
+  0x00d00004, 0x00b1f801, 0x00d00004, 0x00500f00, 0x00a10902, 0x00a20b07,
+  0x00b0190c, 0x00b0190d, 0x00782c49, 0x00722d20, 0x00188002, 0x00b02b07,
+  0x00b08909, 0x00a20b05, 0x00762c49, 0x00722d20, 0x00166002, 0x00b02b05,
+  0x00b06908, 0x00a10901, 0x00721ca8, 0x00e80001, 0x00168200, 0x00a5000b,
+  0x00555600, 0x00148300, 0x00b0500b, 0x00b0401a, 0x00e10460, 0x00211200,
+  0x00a60350, 0x00ab0100, 0x007b3088, 0x004660e0, 0x00566002, 0x00b0b100,
+  0x00b06350, 0x00010a3c, 0x00d04919, 0x00d00008, 0x00400f00, 0x00e80460,
+  0x004a601f, 0x00218a00, 0x00a2000b, 0x00a70100, 0x00e50001, 0x00773088,
+  0x00155a00, 0x00b07100, 0x00777c2e, 0x00aa0006, 0x00177004, 0x00233700,
+  0x00e70001, 0x00177300, 0x00522500, 0x005aa700, 0x00b0200b, 0x00b0a006,
+  0x00d03714, 0x0001033c, 0x0002093c, 0x00d00008, 0x00500f00, 0x00ed0499,
+  0x008c04f8, 0x00a2000a, 0x00712c23, 0x00722c60, 0x00ed049e, 0x008c04ef,
+  0x00d03318, 0x00a5001d, 0x00a3001e, 0x00355001, 0x00d00090, 0x00b0501d,
+  0x009c302a, 0x00142030, 0x008c14a8, 0x00722210, 0x00b0301d, 0x00d12040,
+  0x00e30001, 0x00133100, 0x00622300, 0x00311010, 0x00b02001, 0x00b01eff,
+  0x003ee001, 0x00ed04b3, 0x008c087b, 0x00a11e01, 0x00ed04b6, 0x008c08e5,
+  0x00d0021a, 0x00a20006, 0x00722e10, 0x009c14bb, 0x00d04c1b, 0x00d12040,
+  0x00e30001, 0x00133100, 0x00622300, 0x00b01eff, 0x00b02efe, 0x00b0defd,
+  0x003ee003, 0x00ed04c5, 0x008c087b, 0x00ad1e01, 0x00a21e01, 0x00a11e01,
+  0x00500200, 0x009c14bb, 0x00d00090, 0x00a20006, 0x00722e00, 0x009c14cf,
+  0x00d0011b, 0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 0x00b01eff,
+  0x00b02efe, 0x00b0defd, 0x003ee003, 0x00ed04d9, 0x008c08e5, 0x00ad1e01,
+  0x00a21e01, 0x00a11e01, 0x00500200, 0x009c14cf, 0x00d0011b, 0x00e300a0,
+  0x00731023, 0x00e40001, 0x00a10300, 0x00d21040, 0x009c34e7, 0x00422000,
+  0x00840d00, 0x00144200, 0x00611400, 0x00742c22, 0x00b01300, 0x00533200,
+  0x0072244c, 0x0072403e, 0x00840d00, 0x00e300a0, 0x00731023, 0x00e40001,
+  0x00144200, 0x00a10300, 0x00511400, 0x00d00090, 0x00b01300, 0x00840d00,
+  0x00a30201, 0x0007033c, 0x0077005e, 0x00eb0450, 0x00ea0460, 0x002bb100,
+  0x00b07201, 0x00773d00, 0x00c0703f, 0x009c1504, 0x00773ca8, 0x00d05018,
+  0x0047301f, 0x00c0701f, 0x009c1508, 0x00e70000, 0x00a9000b, 0x00e80001,
+  0x00188700, 0x0078003f, 0x00780020, 0x006880ff, 0x00499800, 0x00a40b00,
+  0x00b0900b, 0x00a60005, 0x00e70001, 0x00177100, 0x00777210, 0x006770ff,
+  0x00a80001, 0x00a90002, 0x00aa0006, 0x00488700, 0x00499700, 0x004aa700,
+  0x00b08001, 0x00a80004, 0x00b09002, 0x00488700, 0x00a9001a, 0x00499700,
+  0x00b0a006, 0x00b0901a, 0x00aa001c, 0x004aa700, 0x00b08004, 0x00b0a01c,
+  0x00a00200, 0x00d50050, 0x00455001, 0x00773c3f, 0x00555700, 0x00981536,
+  0x00d00090, 0x00a700f4, 0x00181001, 0x00155800, 0x00407500, 0x00981536,
+  0x00155001, 0x00740062, 0x00a70200, 0x0098153f, 0x00773c3e, 0x0098153f,
+  0x00177100, 0x00566700, 0x00e70003, 0x00747040, 0x00d05417, 0x00a70200,
+  0x009c1543, 0x00740040, 0x00d05417, 0x00547002, 0x00e70001, 0x00177110,
+  0x00566700, 0x00b04b00, 0x00b06005, 0x00b050f5, 0x00840d00, 0x00ec0001,
+  0x00da3040, 0x008c254f, 0x00d0001f, 0x0016ca00, 0x00eb0460, 0x00633600,
+  0x002bba00, 0x00e40500, 0x00ab0b00, 0x0079bc88, 0x00169004, 0x00244600,
+  0x0076bc2e, 0x009c15b5, 0x00d00090, 0x0017c900, 0x00a1001c, 0x00411700,
+  0x009c154c, 0x00d00090, 0x00a7040b, 0x00a1040e, 0x00401001, 0x009c1566,
+  0x00500700, 0x009c154c, 0x004110fe, 0x0076bc84, 0x00a8040c, 0x00b0140e,
+  0x0098154c, 0x0075bcb8, 0x00255001, 0x00a1040f, 0x0016563e, 0x009c1571,
+  0x00e60001, 0x00751cc9, 0x00155002, 0x00d11070, 0x00211001, 0x00355100,
+  0x00305600, 0x0098254c, 0x0006043c, 0x00b01eff, 0x00b02efe, 0x00b03efd,
+  0x00b04efc, 0x003ee004, 0x0071bc56, 0x00981583, 0x00f40000, 0x00992588,
+  0x00d05815, 0x00f00000, 0x00991588, 0x00ed0587, 0x008c04df, 0x009c158f,
+  0x00d00090, 0x00d00090, 0x00a41e01, 0x00a31e01, 0x00a21e01, 0x00a11e01,
+  0x00d0541c, 0x0075bc84, 0x00e409a1, 0x007445f0, 0x00544900, 0x00745064,
+  0x00725084, 0x00b04300, 0x0071bcb8, 0x0098159a, 0x007210b8, 0x0072c034,
+  0x00211001, 0x00111500, 0x00a50401, 0x00755c2f, 0x00725037, 0x0075bc3d,
+  0x0072503d, 0x005f2c00, 0x00a20603, 0x005f0200, 0x0075bc3d, 0x009815a7,
+  0x00222100, 0x0075bc60, 0x00a8060c, 0x00388100, 0x009c25ac, 0x0008003c,
+  0x00b05ac0, 0x00b02603, 0x00b0160b, 0x00b0860c, 0x00a41e01, 0x00a31e01,
+  0x00a21e01, 0x00a11e01, 0x00d0541c, 0x00a8040d, 0x00983625, 0x0075bcb8,
+  0x00a70402, 0x00983625, 0x0077bc84, 0x00255001, 0x00a8040f, 0x0016573e,
+  0x009c15c0, 0x00e60001, 0x00d58670, 0x0098254c, 0x00306010, 0x009835c6,
+  0x009c854c, 0x009c854c, 0x003707fe, 0x009835ca, 0x00e60001, 0x00166700,
+  0x0007043c, 0x00b03eff, 0x003ee001, 0x0071bc56, 0x009c15d2, 0x00f00000,
+  0x009915d7, 0x00d05d14, 0x00f50000, 0x009925d7, 0x00ed05d6, 0x008c04df,
+  0x009c15db, 0x00d00090, 0x00d00090, 0x00a31e01, 0x00d0541c, 0x0075bc84,
+  0x00e40854, 0x007445f0, 0x00544900, 0x00745064, 0x00746127, 0x0015c900,
+  0x00b04300, 0x00a9001b, 0x00599500, 0x0004073c, 0x00b0901b, 0x0070bc65,
+  0x00981626, 0x00e54002, 0x0071bcb8, 0x009815ee, 0x007510b8, 0x0075c034,
+  0x0071bc84, 0x007510a4, 0x0071bc3d, 0x0075103d, 0x00a10401, 0x00711c2f,
+  0x00751037, 0x005f2500, 0x00a20404, 0x00156002, 0x005f0200, 0x00af2800,
+  0x00366001, 0x009c15f9, 0x0076bc60, 0x0070bc3d, 0x00881600, 0x00222500,
+  0x00a70402, 0x00a9040d, 0x00b06ac0, 0x00377500, 0x00399500, 0x009c361b,
+  0x00d00090, 0x00a90405, 0x00309700, 0x0098260b, 0x0009073c, 0x00a50401,
+  0x00b0940c, 0x00705c26, 0x0098161b, 0x00d00090, 0x00a50406, 0x00a10409,
+  0x00211500, 0x0078022f, 0x00b01409, 0x00b01403, 0x00b0deff, 0x003ee001,
+  0x00ed061a, 0x008c002b, 0x00ad1e01, 0x00a1000b, 0x0016ca00, 0x00611600,
+  0x00b02404, 0x00b0100b, 0x00b0940d, 0x00b0840f, 0x00b07402, 0x00a31e01,
+  0x00d0541c, 0x00d0541c, 0x0071bc84, 0x00c01000, 0x009c163a, 0x00e14102,
+  0x00e50310, 0x00715210, 0x00a50401, 0x00755c2f, 0x00715037, 0x005f2100,
+  0x00a20404, 0x00efeeee, 0x005f0200, 0x00a12800, 0x001f1000, 0x001f1038,
+  0x001f1030, 0x001f1028, 0x00e50004, 0x00d05f1c, 0x00e14112, 0x00e50110,
+  0x00715210, 0x00a50401, 0x00755c2f, 0x00715037, 0x005f2100, 0x00a20404,
+  0x00efffcc, 0x005f0200, 0x00a12800, 0x001f1000, 0x001f1030, 0x00e50004,
+  0x00d05f1c, 0x00a30020, 0x00a9001f, 0x00333001, 0x00d00090, 0x00b03020,
+  0x009c301e, 0x00d87040, 0x00b09020, 0x00982674, 0x00e20001, 0x00122800,
+  0x0009083c, 0x00199004, 0x00e20500, 0x00299200, 0x00677200, 0x00a0090b,
+  0x009c1674, 0x00f40000, 0x00aa0903, 0x00ab0902, 0x00991674, 0x0098364f,
+  0x00e100af, 0x00e20675, 0x00a00100, 0x009c101e, 0x00548050, 0x00742210,
+  0x00a20011, 0x00b04100, 0x00a30901, 0x00733c2f, 0x00723037, 0x005f0200,
+  0x005f0a00, 0x00e20080, 0x002aa200, 0x0013203e, 0x003bb200, 0x00b0a903,
+  0x00b0390b, 0x00b0b902, 0x00d0011e, 0x00ad090e, 0x00ab090b, 0x00ac090f,
+  0x00ff1000, 0x00a40d0a, 0x00a80d09, 0x00b040e9, 0x007f8c61, 0x00ff3000,
+  0x004f8080, 0x00b0e009, 0x00ae0d0f, 0x00a20d0b, 0x0098168f, 0x00d00090,
+  0x00d00090, 0x00ad1e01, 0x00aa1e01, 0x00a81e01, 0x00a71e01, 0x00a61e01,
+  0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a11e01, 0x00840200, 0x00e20694,
+  0x00a400ed, 0x00c04007, 0x009c1763, 0x00d00090, 0x00d00090, 0x00080f3c,
+  0x003bb001, 0x00b080eb, 0x00d00090, 0x009a86a6, 0x00d00090, 0x00a00d13,
+  0x009c26a2, 0x00d00090, 0x00d00090, 0x00b2ac00, 0x000a083c, 0x00d06910,
+  0x00e4ffff, 0x000a083c, 0x00b04d13, 0x00d06910, 0x00a50d06, 0x00105001,
+  0x009c269b, 0x00d00090, 0x00a100e9, 0x00745d08, 0x00b01d0a, 0x00761d00,
+  0x00374600, 0x00745d00, 0x00366400, 0x00577600, 0x00677500, 0x009826b5,
+  0x00d0691b, 0x00a70d09, 0x00711c48, 0x00777c41, 0x003771fb, 0x00ff1000,
+  0x00a40d09, 0x00747041, 0x004f7003, 0x00b04d09, 0x00307004, 0x009c26c8,
+  0x00d00090, 0x00a400ed, 0x00e206c6, 0x00c04007, 0x009c1763, 0x00d00090,
+  0x003bb001, 0x00000f3c, 0x00307007, 0x009836d2, 0x00ff2000, 0x00d00090,
+  0x00d00090, 0x00d00090, 0x00080f3c, 0x00ff3000, 0x000f083c, 0x00d06d19,
+  0x00a400ed, 0x00e206d6, 0x00c04007, 0x009c1763, 0x00d00090, 0x003bb001,
+  0x00080f3c, 0x00b0c90f, 0x00738d10, 0x00333001, 0x00705c3d, 0x00981701,
+  0x00303004, 0x00982701, 0x00708610, 0x009c2701, 0x00d00090, 0x00a400ed,
+  0x00e206e7, 0x00c04007, 0x009c1763, 0x003bb001, 0x00333004, 0x00040f3c,
+  0x00044040, 0x00744201, 0x00748859, 0x001440be, 0x00788c5a, 0x00588001,
+  0x001880bf, 0x00a5090f, 0x00a20d0e, 0x00d55070, 0x00155002, 0x00255101,
+  0x00a00d13, 0x009826f9, 0x00355004, 0x00d00090, 0x00d00090, 0x00b28200,
+  0x00a80d04, 0x00255800, 0x00b24200, 0x00b25200, 0x00b02d0e, 0x00c01003,
+  0x009c170d, 0x00d00090, 0x00a40d13, 0x00982707, 0x00d0701a, 0x00444001,
+  0x00b2ac00, 0x00b04d13, 0x00e5fffc, 0x00e1ffff, 0x00d0701f, 0x002510fd,
+  0x00d00090, 0x00303504, 0x0098271a, 0x00d00090, 0x00a400ed, 0x00e20716,
+  0x00c04007, 0x009c1763, 0x003bb001, 0x00333004, 0x00080f3c, 0x00d0701f,
+  0x00477003, 0x00357300, 0x00255101, 0x00ff1000, 0x00a40d09, 0x00745041,
+  0x004f5003, 0x00b04d09, 0x00301303, 0x00981750, 0x00c05004, 0x009c1745,
+  0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 0x00ff3000,
+  0x000f083c, 0x00d07510, 0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090,
+  0x00040f3c, 0x00ff3000, 0x000f043c, 0x00155003, 0x00144500, 0x0015503d,
+  0x00330300, 0x009c273b, 0x00e30000, 0x00357500, 0x00355004, 0x00155003,
+  0x00144500, 0x00350500, 0x00144500, 0x00355020, 0x00188500, 0x00588400,
+  0x00d07510, 0x00455003, 0x00305700, 0x0098272e, 0x00e2074d, 0x00a400ed,
+  0x00c04007, 0x009c1763, 0x00d00090, 0x003bb001, 0x00080f3c, 0x00d00090,
+  0x00500100, 0x009c2753, 0x00ea0000, 0x00211001, 0x00111003, 0x00310100,
+  0x00188100, 0x00211020, 0x001aa100, 0x00310100, 0x001aa100, 0x00211020,
+  0x00188100, 0x00e40001, 0x00588a00, 0x00b04d13, 0x00b080eb, 0x00e20690,
+  0x00d06919, 0x00b0c90f, 0x00b02d0b, 0x00b0b90b, 0x00ff2000, 0x00b01eff,
+  0x00b03efe, 0x00b04efd, 0x00b05efc, 0x00b06efb, 0x00b07efa, 0x00b08ef9,
+  0x00b0aef8, 0x00b0def7, 0x003ee009, 0x00a100e9, 0x00a40d09, 0x00b01d0a,
+  0x00b0ed0f, 0x00050f3c, 0x00754100, 0x00ae0009, 0x00b05d09, 0x00a0090b,
+  0x009c1338, 0x00e400af, 0x00e80001, 0x00b00400, 0x00a10002, 0x0071803f,
+  0x00b00002, 0x00b01003, 0x00d03318, 0x00a7090e, 0x00ff1000, 0x007f7c61,
+  0x00ff3000, 0x005f0700, 0x00500a00, 0x009c178b, 0x00fa0000, 0x00ec04e0,
+  0x00ed0008, 0x00a4090b, 0x00a6090f, 0x00754cca, 0x00881795, 0x003dd500,
+  0x00500f00, 0x00355001, 0x009c3792, 0x00407001, 0x009c179a, 0x00d00090,
+  0x00757c41, 0x00244500, 0x00724cc2, 0x003dd200, 0x00122002, 0x00a0090c,
+  0x008c17a0, 0x00724d00, 0x0005023c, 0x00222003, 0x0012203e, 0x00a10c09,
+  0x00ab0c00, 0x00311200, 0x00a20c01, 0x00b01c09, 0x00a40c02, 0x00a10c03,
+  0x00aa0909, 0x00a80908, 0x002505fc, 0x009c27bb, 0x00255004, 0x009837d7,
+  0x002505fc, 0x00777c41, 0x00377504, 0x009c27e2, 0x00370500, 0x003dd001,
+  0x00177003, 0x0013f700, 0x00155003, 0x00133500, 0x00d07b1c, 0x00530f00,
+  0x00b05eff, 0x003ee001, 0x00a50c08, 0x009c17c5, 0x00e500c0, 0x00ab0c04,
+  0x00a20c05, 0x00a40c06, 0x00a10c07, 0x00355001, 0x00d00090, 0x00b05c08,
+  0x00a51e01, 0x00783210, 0x0078b021, 0x001bb03f, 0x007b203f, 0x0012203f,
+  0x00133030, 0x007a3210, 0x007a4021, 0x0014403f, 0x0074103f, 0x0011103f,
+  0x00b28600, 0x00b2a600, 0x00d07a1c, 0x00b0bc00, 0x00b02c01, 0x00b04c02,
+  0x00b01c03, 0x00e7ffff, 0x003dd001, 0x009827e2, 0x00d00090, 0x00d00090,
+  0x00500f00, 0x00d07d1c, 0x00fa2000, 0x0000073c, 0x009c27b6, 0x00d00090,
+  0x00a7090e, 0x0047700e, 0x00b0090b, 0x0042f080, 0x00577200, 0x00b0690f,
+  0x00b0790e, 0x00d04919, 0x00d77040, 0x00e90500, 0x007c7484, 0x002cc900,
+  0x00e90016, 0x00a50c0b, 0x00705d00, 0x009c1853, 0x00d00090, 0x00ab0c0c,
+  0x008c3830, 0x00a20c01, 0x00702c3c, 0x00981853, 0x00eb04e0, 0x00a90c0f,
+  0x00a30c0d, 0x00a80b09, 0x0098182f, 0x00e20016, 0x00a40b00, 0x00a50b01,
+  0x00a60b02, 0x00a70b03, 0x00d09270, 0x009c282f, 0x00e20008, 0x00308008,
+  0x009c280c, 0x0002083c, 0x00aa0b08, 0x009c1813, 0x00ea00c0, 0x00a50b05,
+  0x00a40b04, 0x00a60b06, 0x00a70b07, 0x003aa001, 0x00d00090, 0x00b0ab08,
+  0x00aa0c08, 0x007a4021, 0x0014403f, 0x0074503f, 0x0015503f, 0x00b2a900,
+  0x00aa0c09, 0x007a6021, 0x0016603f, 0x0076703f, 0x0017703f, 0x00b2a900,
+  0x00233008, 0x00388001, 0x00322001, 0x009c380c, 0x00d00090, 0x00b04b00,
+  0x00b05b01, 0x00b06b02, 0x00b07b03, 0x00b03c02, 0x00b03c0d, 0x00b08b09,
+  0x00b09c0f, 0x00d08513, 0x00aa0c0f, 0x00a80c01, 0x00718c3b, 0x00981837,
+  0x00f40000, 0x00992853, 0x00d08319, 0x00f00000, 0x00991853, 0x00d0a970,
+  0x009c2853, 0x00d00090, 0x00ed083e, 0x008c04df, 0x00981853, 0x00e40783,
+  0x007445f0, 0x00544750, 0x00a90c03, 0x00b04300, 0x00788c2f, 0x00728037,
+  0x0046901f, 0x005f2051, 0x004f90e0, 0x003606e0, 0x00306b00, 0x0098384d,
+  0x00060b3c, 0x00756100, 0x003bb600, 0x00299600, 0x00b0bc0c, 0x00b09c03,
+  0x00b05c0b, 0x00d00211, 0x00f50000, 0x00500a00, 0x009c1858, 0x00f00000,
+  0x00761d27, 0x00a40901, 0x00000f3c, 0x00366001, 0x009c185a, 0x00724ca0,
+  0x0030201f, 0x009c1861, 0x00724ca8, 0x00e60001, 0x00a8000b, 0x001b6200,
+  0x00568b00, 0x00e80001, 0x00b0600b, 0x00ab001b, 0x00188300, 0x006bb800,
+  0x00a70902, 0x00b0b01b, 0x009c3879, 0x0001033c, 0x00b00902, 0x00b01eff,
+  0x00b02efe, 0x00b0aefd, 0x003ee003, 0x0002093c, 0x00ed0876, 0x008c04f8,
+  0x00aa1e01, 0x00a21e01, 0x00a11e01, 0x00010a3c, 0x00d04919, 0x00b0deff,
+  0x003ee001, 0x00771484, 0x00e50500, 0x00277500, 0x0005013c, 0x00ab0701,
+  0x0071bc3b, 0x00981887, 0x00f40000, 0x009928ba, 0x00d0881a, 0x00f00000,
+  0x009918ba, 0x00d00090, 0x00a90703, 0x00a3070b, 0x00a8070f, 0x00a4070e,
+  0x00404001, 0x009c1893, 0x00500300, 0x009c18ba, 0x00d00090, 0x00aa070c,
+  0x009818ba, 0x00738d07, 0x004330fc, 0x00303022, 0x009828c3, 0x0040a080,
+  0x009818c3, 0x00d00090, 0x0040907f, 0x009c18c3, 0x00d48070, 0x00d00090,
+  0x00303421, 0x009838be, 0x00ed08a4, 0x008c04df, 0x009818ba, 0x00e409a1,
+  0x007445f0, 0x00544550, 0x00a10008, 0x0076bc2f, 0x00716037, 0x00b04300,
+  0x005f1200, 0x005f0900, 0x00a4070e, 0x00740020, 0x00a30701, 0x00b0470e,
+  0x00733c26, 0x00133007, 0x00299300, 0x00e30080, 0x003aa300, 0x00b09703,
+  0x00b0a70c, 0x00b0370b, 0x00ad1e01, 0x00d00090, 0x00d00090, 0x00840d00,
+  0x0076bca0, 0x00e40001, 0x0074403f, 0x00144600, 0x009828ba, 0x00d48070,
+  0x003043f6, 0x009c28ba, 0x00ed08c8, 0x008c04df, 0x009818ba, 0x00e4096b,
+  0x007445f0, 0x00544550, 0x0076bc2f, 0x00726037, 0x005f2051, 0x004f90e0,
+  0x00b04300, 0x0043901f, 0x00a4070e, 0x00740020, 0x00d00090, 0x00b0470e,
+  0x00a40701, 0x00744c26, 0x009818da, 0x003993e0, 0x003403e0, 0x003aa400,
+  0x009c28de, 0x000a003c, 0x00a3070b, 0x00743cca, 0x00d00090, 0x003304f8,
+  0x00133002, 0x007340ca, 0x00d08b17, 0x00741484, 0x00e70500, 0x00244700,
+  0x00e20020, 0x00a0040b, 0x009c193e, 0x00d00090, 0x00ac0401, 0x0070cc3a,
+  0x009c18f2, 0x00f00000, 0x0099193e, 0x00d08f14, 0x00f50000, 0x0099293e,
+  0x00d00090, 0x00a6040f, 0x00a7040d, 0x00a50404, 0x0043501f, 0x009c193f,
+  0x00207080, 0x0098293f, 0x00d76270, 0x0098293f, 0x009c893e, 0x009c893e,
+  0x00e20080, 0x00d00090, 0x00a70007, 0x007ccc2f, 0x0077c037, 0x005f0700,
+  0x005f0500, 0x00d02000, 0x00af2600, 0x00a70402, 0x00b0640f, 0x00255200,
+  0x00377200, 0x00b05404, 0x00b07402, 0x009c3919, 0x00d00090, 0x00b00402,
+  0x0002043c, 0x00b0deff, 0x003ee001, 0x00ed0917, 0x008c04f8, 0x00ad1e01,
+  0x00d0931e, 0x00a3040d, 0x00333200, 0x009c393d, 0x00e50001, 0x00155100,
+  0x00a2001c, 0x00422500, 0x009c193d, 0x00d00090, 0x00a20405, 0x00760210,
+  0x00302700, 0x00882927, 0x0002073c, 0x00b0640f, 0x00b0240c, 0x00b0240d,
+  0x00b07402, 0x00a2040a, 0x00a70409, 0x00a30407, 0x00a50406, 0x00222300,
+  0x00277500, 0x00b0240a, 0x00b07409, 0x00b02404, 0x00b07403, 0x0003013c,
+  0x0001073c, 0x00b0deff, 0x003ee001, 0x00ed093b, 0x008c002b, 0x00ad1e01,
+  0x00d0931e, 0x00b0340d, 0x00840d00, 0x00a2040d, 0x00a0040b, 0x009c193e,
+  0x00222300, 0x00d86070, 0x0098193e, 0x00188002, 0x00288300, 0x004880fc,
+  0x00308020, 0x0098394b, 0x00e80020, 0x00308200, 0x00982950, 0x00392001,
+  0x0008023c, 0x00d09511, 0x00398001, 0x00e74252, 0x007ccc2f, 0x0077c037,
+  0x005f0700, 0x000f9337, 0x004f50e0, 0x004a30fc, 0x003b8a00, 0x00500a00,
+  0x00981960, 0x005f0000, 0x003aa004, 0x009c395b, 0x00d00090, 0x00d00090,
+  0x00af2600, 0x003bb004, 0x009c3960, 0x003a08e0, 0x004aa0fc, 0x00981969,
+  0x005f0000, 0x003aa004, 0x009c3966, 0x00328300, 0x00d09019, 0x00a2090e,
+  0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c1973,
+  0x00fa0000, 0x00ab090b, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x0075bcca,
+  0x0098197e, 0x00d00090, 0x00d00090, 0x00500f00, 0x00355001, 0x008c397b,
+  0x0075bcc2, 0x00981985, 0x00d00090, 0x00d00090, 0x00b2f800, 0x00355001,
+  0x008c3982, 0x00b0090b, 0x0002073c, 0x00010a3c, 0x00ed098a, 0x008c04ef,
+  0x00a5090e, 0x0098199f, 0x00ff2000, 0x0045500f, 0x00d00090, 0x00d00090,
+  0x004bf080, 0x00555b00, 0x00a4090c, 0x00981997, 0x00d00090, 0x00b0590e,
+  0x00d0991f, 0x00755c41, 0x00d00090, 0x003505fc, 0x00155003, 0x00350500,
+  0x001bb500, 0x00d00090, 0x00b2b800, 0x00b0890f, 0x00d03318, 0x00a2090e,
+  0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c19a9,
+  0x00fa0000, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x00eb09b2, 0x007c1c64,
+  0x002ccb00, 0x00ab090b, 0x00a20908, 0x00840c00, 0x00d09d13, 0x00d09c1a,
+  0x00d09c16, 0x00d09c11, 0x00d09b1c, 0x00ec09b8, 0x00d00008, 0x00b2f800,
+  0x003bb020, 0x00d09d1c, 0x00ec09bd, 0x00d00004, 0x00b2f800, 0x003bb010,
+  0x00d09d1c, 0x00ec09c2, 0x00d00002, 0x00b2f800, 0x003bb008, 0x00d09d1c,
+  0x00ec09c7, 0x00b2f800, 0x003bb004, 0x00d09d1c, 0x00ec09cb, 0x00122030,
+  0x0072f210, 0x003bb002, 0x008c19dc, 0x00d00090, 0x00d00090, 0x00b22800,
+  0x00d09d1c, 0x00ec09d4, 0x00122038, 0x0072f118, 0x003bb001, 0x008c19dc,
+  0x00d00090, 0x00d00090, 0x00b22800, 0x00d09d1c, 0x00a50aec, 0x00355700,
+  0x00801c00, 0x00b02908, 0x00b0b90b, 0x00500b00, 0x009c19e7, 0x0002073c,
+  0x00010a3c, 0x00ed09e7, 0x008c04ef, 0x00a5090e, 0x009819fc, 0x00ff2000,
+  0x00d00090, 0x00d00090, 0x0045500f, 0x004bf080, 0x00a4090c, 0x009819f4,
+  0x00555b00, 0x00d00090, 0x00b0590e, 0x00d09f1c, 0x00755c41, 0x00d00090,
+  0x003505fc, 0x00155003, 0x00350500, 0x001bb500, 0x00d00090, 0x00b2b800,
+  0x00b0890f, 0x00d03318, 0x00707cda, 0x00981a05, 0x00702cda, 0x00981a05,
+  0x0070bcda, 0x00981a05, 0x00840d00, 0x0076002f, 0x00840d00, 0x00f50000,
+  0x00500a00, 0x009c1a0b, 0x00f00000, 0x00ec04e0, 0x00a7090b, 0x00a50c0a,
+  0x007d7ca3, 0x00ab0c00, 0x00a20c01, 0x00a40c02, 0x00a10c03, 0x00a70c08,
+  0x009c3a1e, 0x00e700c0, 0x00ab0c04, 0x00a20c05, 0x00a40c06, 0x00a10c07,
+  0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03, 0x00377001, 0x00a30908,
+  0x00a60909, 0x00b07c08, 0x0048f500, 0x004af500, 0x00783880, 0x007a6880,
+  0x0078b021, 0x007a4021, 0x001bb03f, 0x0014403f, 0x007b203f, 0x0074103f,
+  0x00a6090f, 0x0011103f, 0x0012203f, 0x00b28600, 0x00b2a600, 0x003dd001,
+  0x00b0690f, 0x008c1a13, 0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03,
+  0x00b0090b, 0x00d04919, 0x00d77040, 0x00e10500, 0x007b7484, 0x002bb100,
+  0x00d00090, 0x00a40b0b, 0x009c1a6c, 0x00d00090, 0x00a10b0f, 0x00a80b03,
+  0x00d91070, 0x00a50b01, 0x002009e0, 0x009c2a6c, 0x00d00090, 0x00ea0004,
+  0x00a90b0c, 0x00883a6c, 0x00329020, 0x008c2a4f, 0x007a9c43, 0x00715c3b,
+  0x00981a54, 0x00f40000, 0x00992a6c, 0x00d0a516, 0x00f00000, 0x00991a6c,
+  0x00ed0a58, 0x008c04df, 0x00981a6c, 0x00e40a07, 0x007445f0, 0x00544730,
+  0x00755c2f, 0x00b04300, 0x00e10000, 0x00a30b06, 0x00725037, 0x00211008,
+  0x005f2031, 0x004f80f8, 0x00288300, 0x003aa001, 0x008c3a61, 0x00399100,
+  0x00741500, 0x00b09b0c, 0x00b08b03, 0x00b04b0b, 0x00d00214
+};
+
+#define TABLE_LENGTH(x) (sizeof(x)/sizeof(*(x)))
+#define STB7109_C3_IMEM_REGION_LENGTH  0x1000
+
+#define STB7109_C3_DMEM_REGION_LENGTH  0x800
+
+#define STB7109_C3_IMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7109_C3_IMEM_REGION)
+#define STB7109_C3_DMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7109_C3_DMEM_REGION)
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/7200_cut1_fdma2_firmware.h linux-2.6.23.1-stm/include/linux/stm/7200_cut1_fdma2_firmware.h
--- linux-2.6.23.1/include/linux/stm/7200_cut1_fdma2_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/7200_cut1_fdma2_firmware.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,753 @@
+#ifndef  FDMA_7200_FIRMWARE
+#define FDMA_7200_FIRMWARE
+
+static unsigned long STB7200_DMEM_REGION[]={0x00060104, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x23104052, 0x23100051, 0x00000000, 0x00000000, 0x00000000, 
+  0x21900051, 0x0196014e, 0x01990151, 0x019c0154, 0x019f0157, 0x63102051, 
+  0x003f001f, 0x000001e9, 0x000001eb, 0x000001ed, 0x000001f9, 0x000003ce, 
+  0x000003cc, 0x000003c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000fe, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x0000003e, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00002416, 0x04a004a0, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00002416, 0x04c004c0, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00002416, 0x04e004e0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffff00, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000241f, 0x05200520, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x0000241f, 0x05400540, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x0000241f, 0x05600560, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00002428, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00002431, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x0000143a, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000143f, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00001444, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00001449, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000144e, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00001453, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00001458, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000145d, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00001462, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00001467, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000146c, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00001471, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00001476, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000147b
+};
+
+
+static unsigned long STB7200_IMEM_REGION[]={0x00e1ffff, 0x00e200ff, 0x00f51000, 0x00b010f9, 0x00b020fa, 0x00ef0013, 
+  0x00e10001, 0x00ee00a0, 0x00b010ea, 0x00f01000, 0x00ef0013, 0x00a300f8, 
+  0x00aa000b, 0x00433a00, 0x009c157b, 0x009b335d, 0x009a2263, 0x00d00090, 
+  0x00a70005, 0x00177030, 0x009c1242, 0x00d00090, 0x00a70006, 0x00a2001c, 
+  0x00672700, 0x009c14ea, 0x00d00090, 0x00a70002, 0x009c1679, 0x00d00090, 
+  0x00a70004, 0x009c184a, 0x00d00090, 0x00a7001a, 0x009c1a67, 0x00d00090, 
+  0x00a90003, 0x009c103b, 0x00d00090, 0x00a20001, 0x009c14d2, 0x00d00090, 
+  0x00d0001b, 0x00452003, 0x00461003, 0x00355600, 0x00755461, 0x00a6040e, 
+  0x00555001, 0x00765080, 0x00d00090, 0x00b0640e, 0x00755c23, 0x00761c62, 
+  0x00266500, 0x007564ca, 0x00d00090, 0x00b0540b, 0x00840d00, 0x00b0901e, 
+  0x00a9001e, 0x00799600, 0x00d59040, 0x00982027, 0x00e60001, 0x00166500, 
+  0x006660ff, 0x00499600, 0x00795110, 0x00155004, 0x00e20560, 0x00222500, 
+  0x00b0901e, 0x00aa020e, 0x00f50000, 0x00ab0a0e, 0x00a10a0d, 0x00d0b070, 
+  0x009c10c4, 0x00d00090, 0x00a4020f, 0x00a70201, 0x00a30a04, 0x00d54070, 
+  0x00305020, 0x00982095, 0x007c3ce0, 0x009c1099, 0x00e80020, 0x00ed0063, 
+  0x00a50007, 0x00777c2f, 0x00757037, 0x005f0500, 0x005f0300, 0x00a50a0c, 
+  0x00a70a14, 0x00b050e9, 0x00941700, 0x00d00090, 0x00ed006a, 0x00a92400, 
+  0x00233004, 0x00b090eb, 0x005f0900, 0x00928100, 0x00388001, 0x008c3065, 
+  0x00a50a02, 0x0006033c, 0x00605300, 0x008c1071, 0x00a60a05, 0x00a500e9, 
+  0x00b06a04, 0x00b0420f, 0x00b05a0c, 0x00d0b070, 0x009c10c4, 0x00d00090, 
+  0x00e60026, 0x00d54070, 0x00306500, 0x0098203c, 0x00d00090, 0x00a50202, 
+  0x009c108a, 0x00d04070, 0x009c103c, 0x00e60001, 0x00a5001e, 0x00715d10, 
+  0x00a50003, 0x00166100, 0x00655600, 0x00ed003c, 0x00b05003, 0x008c052b, 
+  0x00a5001e, 0x00715d10, 0x00e60001, 0x00a50003, 0x00166100, 0x00655600, 
+  0x00a20002, 0x00522600, 0x00b05003, 0x00b02002, 0x008c003c, 0x00a00202, 
+  0x009c108a, 0x00d04070, 0x00981081, 0x004c301f, 0x00155002, 0x00265c00, 
+  0x004060e0, 0x0098109f, 0x00e60020, 0x00366001, 0x00166008, 0x00ed00b4, 
+  0x00777c2f, 0x00e54252, 0x00757037, 0x000f053c, 0x005f6c00, 0x004f30e0, 
+  0x0018c03e, 0x009810ad, 0x000f003c, 0x00388001, 0x008c30aa, 0x00a50a0c, 
+  0x00166038, 0x00386cff, 0x0018803e, 0x00a70a14, 0x00b050e9, 0x00941700, 
+  0x00d00090, 0x00ed00bb, 0x00a92400, 0x00233004, 0x00b090eb, 0x005f0900, 
+  0x00928100, 0x00388001, 0x008c30b6, 0x003806e1, 0x0098106c, 0x000f003c, 
+  0x00388004, 0x008c30bf, 0x008c006c, 0x008c00c3, 0x00a30a00, 0x00a80a01, 
+  0x009810e8, 0x00d00090, 0x00a50201, 0x00775c2f, 0x00777437, 0x00055035, 
+  0x00e64042, 0x005f6700, 0x004f30f0, 0x00a62b00, 0x009c20d8, 0x00d00090, 
+  0x005f5001, 0x00ac2b00, 0x00af2b00, 0x004f6001, 0x000f0c3c, 0x008c00dc, 
+  0x000f053c, 0x00af2b00, 0x000f063c, 0x000f003c, 0x00233010, 0x00388010, 
+  0x009810e6, 0x00d0b070, 0x009c10cc, 0x00d00090, 0x00b08a01, 0x00b03a00, 
+  0x00b0ba0e, 0x008c003c, 0x00d0b070, 0x009810e2, 0x00533001, 0x007b0210, 
+  0x0008003c, 0x008c00e2, 0x00a50a00, 0x00455001, 0x00941d00, 0x00d00090, 
+  0x00b06eff, 0x00b07efe, 0x00b08efd, 0x00b09efc, 0x00b0cefb, 0x003ee005, 
+  0x00a60a07, 0x00a70a08, 0x00a800e9, 0x00ec0000, 0x00788d00, 0x00106001, 
+  0x009c210b, 0x00796d08, 0x003c9800, 0x00796d00, 0x00398900, 0x005cc900, 
+  0x006cc600, 0x009c210b, 0x007c6c3d, 0x007cc43e, 0x00666c00, 0x007c7c3d, 
+  0x007cc43e, 0x00577c00, 0x00d0111a, 0x00107001, 0x009c2121, 0x00797d08, 
+  0x003c9800, 0x00797d00, 0x00398900, 0x005cc900, 0x006cc700, 0x009c2121, 
+  0x007c7c3d, 0x007cc43e, 0x00677c00, 0x007c6c3d, 0x007cc43e, 0x00566c00, 
+  0x00a900e9, 0x00b06a07, 0x00b07a08, 0x00799c48, 0x002993fc, 0x00b28b00, 
+  0x00b29b00, 0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 
+  0x00840d00, 0x00a50a00, 0x00455001, 0x00941d00, 0x00d00090, 0x00b09a10, 
+  0x00b01eff, 0x00b02efe, 0x00b06efd, 0x00b07efc, 0x00b08efb, 0x00b09efa, 
+  0x00b0cef9, 0x00b04ef8, 0x003ee008, 0x00a800e9, 0x00788d00, 0x0047801f, 
+  0x00a40e00, 0x00a900e9, 0x00778ca0, 0x00799c48, 0x0002093c, 0x002993fc, 
+  0x00e54400, 0x00155710, 0x009c2169, 0x00d00090, 0x00d04070, 0x009c1149, 
+  0x00d00090, 0x00e50186, 0x00b09a11, 0x00b05a14, 0x00d0171d, 0x00a7020d, 
+  0x00777e00, 0x00a52400, 0x00a60a10, 0x00840700, 0x00765100, 0x00066001, 
+  0x00d01518, 0x00765200, 0x00066002, 0x00d01518, 0x00765300, 0x00066003, 
+  0x00d01518, 0x0006053c, 0x00066040, 0x00d56040, 0x00a40a12, 0x003505e1, 
+  0x00166500, 0x002505e1, 0x00166500, 0x00366001, 0x00306400, 0x00b06a12, 
+  0x00983175, 0x00d00090, 0x00a60a08, 0x00266001, 0x00d00090, 0x00b06a08, 
+  0x00d0171d, 0x00e50270, 0x00155710, 0x00982175, 0x00c080b4, 0x00981170, 
+  0x00780327, 0x008c0171, 0x00780308, 0x00d00090, 0x00b28b00, 0x00b29b00, 
+  0x00d0171d, 0x00ac0a08, 0x00b00a08, 0x002cc001, 0x0078c308, 0x00780027, 
+  0x00d00090, 0x00b28b00, 0x00b29b00, 0x00a41e01, 0x00ac1e01, 0x00a91e01, 
+  0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00a21e01, 0x00a11e01, 0x00840d00, 
+  0x00b01eff, 0x00b02efe, 0x00b03efd, 0x00b04efc, 0x00b05efb, 0x00b0befa, 
+  0x003ee006, 0x00a20a11, 0x00752c40, 0x00a32400, 0x00b00a14, 0x00a5050d, 
+  0x00755e10, 0x00a10a10, 0x00d00090, 0x00840500, 0x00713100, 0x00011001, 
+  0x00d01a10, 0x00713200, 0x00011002, 0x00d01a10, 0x00713300, 0x00011003, 
+  0x00d01a10, 0x0001033c, 0x00011040, 0x00d51040, 0x00a30a12, 0x003505e1, 
+  0x00111500, 0x002505e1, 0x00111500, 0x00311001, 0x00a50a08, 0x00b01a12, 
+  0x00255001, 0x00301300, 0x009831b0, 0x00d00090, 0x00b05a08, 0x00d01b18, 
+  0x00a10a0c, 0x00a30a11, 0x00b00a08, 0x00715308, 0x00710027, 0x00d00090, 
+  0x00b21b00, 0x00b23b00, 0x00a01e01, 0x00a51e01, 0x00a41e01, 0x00a31e01, 
+  0x00a21e01, 0x00a11e01, 0x00840d00, 0x00a50a00, 0x00455001, 0x00941d00, 
+  0x00d00090, 0x00b09a10, 0x00b01eff, 0x00b06efe, 0x00b07efd, 0x00b08efc, 
+  0x00b09efb, 0x00b0cefa, 0x00b04ef9, 0x003ee007, 0x00a100e9, 0x00781d00, 
+  0x00c080b4, 0x009811d2, 0x00701c65, 0x009c120a, 0x00781c48, 0x00a60012, 
+  0x00751d00, 0x00c050b4, 0x009c11d9, 0x00e100b4, 0x008c01dc, 0x0041101f, 
+  0x00106100, 0x009c220a, 0x0005083c, 0x002883fc, 0x00c0100b, 0x009811e5, 
+  0x00d00090, 0x00d00090, 0x00b21b00, 0x00b28b00, 0x00d0201a, 0x00a60513, 
+  0x00d00090, 0x00d00090, 0x00840600, 0x00779e08, 0x00d02014, 0x00779e10, 
+  0x00d02014, 0x00e60214, 0x00d04070, 0x009c11f3, 0x00d00090, 0x00b06a14, 
+  0x00d02112, 0x0006043c, 0x00779d18, 0x00d00090, 0x00a62600, 0x00776108, 
+  0x00d02014, 0x00e6022c, 0x00d04070, 0x009c11ff, 0x00d00090, 0x00b06a14, 
+  0x00d02112, 0x0006043c, 0x00d00090, 0x00d00090, 0x00a72600, 0x00d02014, 
+  0x00077040, 0x00777d37, 0x00717128, 0x00d00090, 0x00b21b00, 0x00b28b00, 
+  0x00a41e01, 0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 
+  0x00a11e01, 0x00840d00, 0x00b08a11, 0x00d0201a, 0x00a90a00, 0x00499001, 
+  0x00941d00, 0x00d00090, 0x00b06eff, 0x00b08efe, 0x00b04efd, 0x003ee003, 
+  0x00a90a10, 0x00a80a11, 0x00a62400, 0x00166008, 0x00769918, 0x00066040, 
+  0x00766d37, 0x00799d10, 0x00796128, 0x00b00a14, 0x00b29b00, 0x00b28b00, 
+  0x00a41e01, 0x00a81e01, 0x00a61e01, 0x00840d00, 0x00a90a00, 0x00499001, 
+  0x00941d00, 0x00d00090, 0x00b06eff, 0x00b08efe, 0x00b04efd, 0x003ee003, 
+  0x00a90a10, 0x00a80a11, 0x00a62400, 0x00799d18, 0x00066040, 0x00766d37, 
+  0x00796128, 0x00b00a14, 0x00b29b00, 0x00b28b00, 0x00a41e01, 0x00a81e01, 
+  0x00a61e01, 0x00840d00, 0x00f40000, 0x00d87040, 0x0098225d, 0x00e10560, 
+  0x00198004, 0x00299100, 0x00e10001, 0x00aa0900, 0x00ed024c, 0x008c0512, 
+  0x0098125d, 0x00e4036f, 0x007445f0, 0x00544850, 0x00a1000c, 0x00b04300, 
+  0x005f1200, 0x004fa0e0, 0x00ea0001, 0x00ab090f, 0x001aa800, 0x007b01f0, 
+  0x00e80040, 0x00677a00, 0x00b0b90f, 0x00b0890b, 0x00d02413, 0x00aa0005, 
+  0x00d00090, 0x007a7210, 0x00d00090, 0x00b0a005, 0x00d00116, 0x00ac00f0, 
+  0x00a80005, 0x00d1c040, 0x0098235b, 0x0011103f, 0x00ed0450, 0x001a1001, 
+  0x002dd100, 0x00320a00, 0x0013c200, 0x00193a00, 0x00e20275, 0x00222300, 
+  0x006cc900, 0x00eb0560, 0x0005013c, 0x00155004, 0x00255b00, 0x00840200, 
+  0x00d02f1e, 0x00d02b1c, 0x00a40501, 0x00724ca0, 0x009812bc, 0x00e40460, 
+  0x00244200, 0x00c0201f, 0x009812bc, 0x00eb0001, 0x00a20400, 0x00702c2e, 
+  0x009c12bc, 0x001bb100, 0x00a2001c, 0x00522b00, 0x00588b00, 0x00b0201c, 
+  0x00a2050f, 0x00aa050c, 0x00ab050b, 0x0070bd00, 0x009c1265, 0x00d22070, 
+  0x009812bc, 0x00f50000, 0x00991265, 0x00122002, 0x00b0050c, 0x00ab050d, 
+  0x0030b200, 0x009c2297, 0x00020b3c, 0x003bb200, 0x00b0250d, 0x00b0deff, 
+  0x00b01efe, 0x00b05efd, 0x00b0befc, 0x00b0aefb, 0x00b08efa, 0x003ee006, 
+  0x00ed02a2, 0x008c091a, 0x00a81e01, 0x00aa1e01, 0x00ab1e01, 0x00a51e01, 
+  0x00a11e01, 0x00ad1e01, 0x00a2050d, 0x00b0a50c, 0x009812af, 0x002bb200, 
+  0x00d00090, 0x00b0b50d, 0x00d02615, 0x00b0deff, 0x00b05efe, 0x00b01efd, 
+  0x003ee003, 0x00b0b50d, 0x00ed02b7, 0x00000b3c, 0x00981957, 0x00d00090, 
+  0x00d00090, 0x00a11e01, 0x00a51e01, 0x00ad1e01, 0x00a2050b, 0x00702d00, 
+  0x009c1265, 0x00e20001, 0x00122100, 0x00ab001b, 0x004bb200, 0x009c1265, 
+  0x00588200, 0x00a40501, 0x00eb0001, 0x007a4ca0, 0x001bba00, 0x004bb0fe, 
+  0x009812d7, 0x009c22d2, 0x007a4d00, 0x00c0a03f, 0x009c12d7, 0x007a4ca8, 
+  0x00eb0001, 0x001bba00, 0x00a3000b, 0x006bb0ff, 0x00433b00, 0x00d00090, 
+  0x00b0300b, 0x00ab050b, 0x0070bd00, 0x009c1265, 0x00722210, 0x006220ff, 
+  0x00ab0001, 0x00a40002, 0x004bb200, 0x00444200, 0x00b0b001, 0x00ab0006, 
+  0x00b04002, 0x00a40004, 0x004bb200, 0x00444200, 0x00488200, 0x00b0b006, 
+  0x00b04004, 0x00ab001c, 0x004bb200, 0x00a4001a, 0x00b0b01c, 0x00444200, 
+  0x00eb0003, 0x00b0401a, 0x00a40d00, 0x0074b0a0, 0x00a300f4, 0x001b1001, 
+  0x00e20001, 0x00122b00, 0x00402300, 0x009812fa, 0x00122001, 0x00740062, 
+  0x00b020f5, 0x00b04d00, 0x00b090f2, 0x00d02615, 0x00e40001, 0x00144100, 
+  0x006440ff, 0x00488400, 0x00a60d00, 0x0042601f, 0x004660e0, 0x00566002, 
+  0x00c02000, 0x00b06d00, 0x0098130f, 0x00e20001, 0x00122110, 0x00588200, 
+  0x00b06500, 0x00b090f2, 0x00d02615, 0x00a00502, 0x009c131a, 0x0002053c, 
+  0x00b0ceff, 0x00b08efe, 0x003ee002, 0x00ed0317, 0x008c052b, 0x00a81e01, 
+  0x00ac1e01, 0x00d02615, 0x00a40501, 0x00b06d00, 0x0042401f, 0x00981338, 
+  0x0042403f, 0x00c0201f, 0x0098133f, 0x00c0203f, 0x00981346, 0x00e60460, 
+  0x0042401f, 0x00e40001, 0x00144200, 0x00a3000b, 0x00533400, 0x00266200, 
+  0x00b0300b, 0x00a20600, 0x00721088, 0x00742c2e, 0x00b02600, 0x00144004, 
+  0x00244100, 0x00e60001, 0x00166400, 0x00a20006, 0x00522600, 0x00b090f2, 
+  0x00b02006, 0x00d02615, 0x00a20001, 0x00eb0001, 0x001bb100, 0x00522b00, 
+  0x00b090f2, 0x00b02001, 0x00d02615, 0x00a20002, 0x00eb0001, 0x001bb100, 
+  0x00522b00, 0x00b090f2, 0x00b02002, 0x00d02615, 0x00724ca8, 0x00eb0001, 
+  0x001bb200, 0x00a3000b, 0x00533b00, 0x00a20004, 0x00b0300b, 0x00eb0001, 
+  0x001bb100, 0x00a2001a, 0x00704c2d, 0x00981356, 0x00522b00, 0x00b090f2, 
+  0x00b0201a, 0x00d02615, 0x00a20004, 0x00522b00, 0x00b090f2, 0x00b02004, 
+  0x00d02615, 0x00b08005, 0x00d00112, 0x00d80050, 0x00788c4c, 0x00981010, 
+  0x00da8040, 0x00e600a0, 0x0076a023, 0x00a70aec, 0x00767060, 0x00d00090, 
+  0x00a10600, 0x00b0600a, 0x00731c80, 0x00741df0, 0x00751c64, 0x00e20560, 
+  0x00793484, 0x00299200, 0x00840400, 0x00f50000, 0x0007093c, 0x00d00090, 
+  0x00d00008, 0x00b1f701, 0x00a00902, 0x009814c6, 0x00d00090, 0x00ebffff, 
+  0x00a60901, 0x0076b05a, 0x0040601f, 0x00981383, 0x0047603f, 0x00c0701f, 
+  0x009813a2, 0x00c0703f, 0x00b06901, 0x009813d5, 0x00d04a1b, 0x00e70001, 
+  0x00d00008, 0x00400f00, 0x00a20001, 0x00177300, 0x00522700, 0x00d00090, 
+  0x00b02001, 0x00a70903, 0x00a20904, 0x00ed038f, 0x008c0aca, 0x00a20905, 
+  0x00b06901, 0x00a70902, 0x00307200, 0x008c2395, 0x0002073c, 0x00a10903, 
+  0x00b0290c, 0x00b0290d, 0x00a20904, 0x00b01909, 0x00b0290a, 0x0004093c, 
+  0x00b0deff, 0x003ee001, 0x00ed03a0, 0x008c002b, 0x00ad1e01, 0x00d04c1c, 
+  0x00d00008, 0x00400f00, 0x00a70002, 0x00e20001, 0x00122300, 0x00577200, 
+  0x007a6c88, 0x001aa005, 0x00e20480, 0x002aa200, 0x00b07002, 0x00b0a90e, 
+  0x00a70903, 0x00a20a00, 0x00ab0a04, 0x00ed03b3, 0x008c0ac1, 0x00b0090b, 
+  0x00b06901, 0x00a00a0d, 0x008c14cc, 0x00a60a0e, 0x00760210, 0x00a20a0f, 
+  0x00b06a0e, 0x00722a10, 0x00e60001, 0x00b02a0f, 0x00a20a07, 0x00722c5b, 
+  0x00d00090, 0x00a20217, 0x00b00a14, 0x00b00a09, 0x00b00a0a, 0x00b00a0b, 
+  0x00b00a0c, 0x00d00090, 0x00840200, 0x00e60127, 0x00b00a08, 0x00d03c1f, 
+  0x00e601bf, 0x00d03c1f, 0x00e600ec, 0x00a2090f, 0x00b06a0d, 0x00720210, 
+  0x00b00a13, 0x00b0290f, 0x00d04c1c, 0x00a70903, 0x00a20904, 0x00ed03d9, 
+  0x008c0aca, 0x00706c2d, 0x00b06901, 0x009c147e, 0x00d00090, 0x00ac090f, 
+  0x00ed0450, 0x007c0210, 0x002dd300, 0x00eb04e0, 0x00b0c90f, 0x00a00b09, 
+  0x009813ff, 0x00d00090, 0x00a10903, 0x00711c62, 0x00a2090e, 0x00522001, 
+  0x00762c23, 0x00211600, 0x00b0290e, 0x0011100a, 0x00d00090, 0x00d00008, 
+  0x00500f00, 0x00b0190b, 0x00a10902, 0x00a20901, 0x00702c3d, 0x009813f9, 
+  0x00d00090, 0x00b0190c, 0x00d04118, 0x00e10001, 0x0072103c, 0x00b0090c, 
+  0x00b02901, 0x00e10000, 0x00d04118, 0x0028b004, 0x00a10903, 0x00d00004, 
+  0x00b1f801, 0x00d00004, 0x00500f00, 0x00a20904, 0x0004093c, 0x00ed0409, 
+  0x008c002b, 0x00a10902, 0x00a20901, 0x00b0190c, 0x00702c3d, 0x009c1418, 
+  0x00d00090, 0x00a10d00, 0x004110e0, 0x0002093c, 0x00b01d00, 0x00b00900, 
+  0x0001033c, 0x00ed0417, 0x008c052b, 0x00d04c1c, 0x00211003, 0x0011103e, 
+  0x00111003, 0x00d00090, 0x00b0190d, 0x00b01902, 0x00a00b09, 0x009c1466, 
+  0x00d00090, 0x00a10907, 0x00311002, 0x00a20b07, 0x00b01b09, 0x00782c44, 
+  0x0042200f, 0x00188002, 0x00b02b07, 0x00b08909, 0x00a20b05, 0x00762c44, 
+  0x0042200f, 0x00166002, 0x00b02b05, 0x00b06908, 0x00a50b08, 0x009c143c, 
+  0x00d00090, 0x00e500c0, 0x00a20b05, 0x00a10b07, 0x00b02b01, 0x00b01b03, 
+  0x00a20b06, 0x00a10b04, 0x00b02b02, 0x00b01b00, 0x00355002, 0x00d00090, 
+  0x00b05b08, 0x00a50b00, 0x00a70905, 0x0001073c, 0x00716200, 0x00715021, 
+  0x0015503f, 0x00b21c00, 0x00a40b02, 0x00117010, 0x00718200, 0x00714021, 
+  0x0014403f, 0x00b21c00, 0x00a70906, 0x0001073c, 0x00716200, 0x00715021, 
+  0x0015503f, 0x00b21c00, 0x00117010, 0x00718200, 0x00714021, 0x0014403f, 
+  0x00b21c00, 0x00a10b01, 0x0075121e, 0x0011103e, 0x00b05b00, 0x00b01b01, 
+  0x00a20b03, 0x0074221e, 0x0012203e, 0x00a1090d, 0x00211010, 0x00b04b02, 
+  0x00b02b03, 0x00b0190d, 0x00b01902, 0x00b0c90f, 0x00a10901, 0x00721ca8, 
+  0x00e80001, 0x00a00900, 0x009c146c, 0x0071803c, 0x00168200, 0x00a5000b, 
+  0x00555600, 0x00148300, 0x00b0500b, 0x00b01901, 0x00b04004, 0x00e10460, 
+  0x00211200, 0x00a60d00, 0x00ab0100, 0x007b3088, 0x004660e0, 0x00566002, 
+  0x00b0b100, 0x00b06d00, 0x00010a3c, 0x00d04c1c, 0x00ac090f, 0x007c0210, 
+  0x00b0090b, 0x00eb04e0, 0x0028b004, 0x00b0c90f, 0x00d00004, 0x00b1f801, 
+  0x00d00004, 0x00500f00, 0x00a10902, 0x00a20b07, 0x00b0190c, 0x00b0190d, 
+  0x00782c49, 0x00722d20, 0x00188002, 0x00b02b07, 0x00b08909, 0x00a20b05, 
+  0x00762c49, 0x00722d20, 0x00166002, 0x00b02b05, 0x00b06908, 0x00a10901, 
+  0x00721ca8, 0x00e80001, 0x00168200, 0x00a5000b, 0x00555600, 0x00148300, 
+  0x00b0500b, 0x00b0401a, 0x00e10460, 0x00211200, 0x00a60350, 0x00ab0100, 
+  0x007b3088, 0x004660e0, 0x00566002, 0x00b0b100, 0x00b06350, 0x00010a3c, 
+  0x00d04c1c, 0x00d00008, 0x00400f00, 0x00e80460, 0x004a601f, 0x00218a00, 
+  0x00ab000b, 0x00a70100, 0x00e50001, 0x00773088, 0x00155a00, 0x00b07100, 
+  0x00777c2e, 0x00aa0006, 0x00177004, 0x00d00090, 0x00233700, 0x00a20904, 
+  0x00a70903, 0x00ed04bf, 0x008c0aca, 0x00e70001, 0x00177300, 0x005bb500, 
+  0x005aa700, 0x00b0b00b, 0x00b0a006, 0x00d0381f, 0x0001033c, 0x0002093c, 
+  0x00d00008, 0x00500f00, 0x00ed04cc, 0x008c052b, 0x00a2000a, 0x00712c23, 
+  0x00722c60, 0x00ed04d1, 0x008c0522, 0x00d0351d, 0x00a5001f, 0x00a30020, 
+  0x00355001, 0x00d00090, 0x00b0501f, 0x009c302a, 0x00142030, 0x008c14db, 
+  0x00722210, 0x00b0301f, 0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 
+  0x00311010, 0x00b02001, 0x00b01eff, 0x003ee001, 0x00ed04e6, 0x008c08b0, 
+  0x00a11e01, 0x00ed04e9, 0x008c091a, 0x00d0021a, 0x00a20006, 0x00722e10, 
+  0x009c14ee, 0x00d04f1e, 0x00d12040, 0x00e30001, 0x00133100, 0x00622300, 
+  0x00b01eff, 0x00b02efe, 0x00b0defd, 0x003ee003, 0x00ed04f8, 0x008c08b0, 
+  0x00ad1e01, 0x00a21e01, 0x00a11e01, 0x00500200, 0x009c14ee, 0x00d00090, 
+  0x00a20006, 0x00722e00, 0x009c1502, 0x00d0011b, 0x00d12040, 0x00e30001, 
+  0x00133100, 0x00622300, 0x00b01eff, 0x00b02efe, 0x00b0defd, 0x003ee003, 
+  0x00ed050c, 0x008c091a, 0x00ad1e01, 0x00a21e01, 0x00a11e01, 0x00500200, 
+  0x009c1502, 0x00d0011b, 0x00e300a0, 0x00731023, 0x00e40001, 0x00a10300, 
+  0x00d21040, 0x009c351a, 0x00422000, 0x00840d00, 0x00144200, 0x00611400, 
+  0x00742c22, 0x00b01300, 0x00533200, 0x0072244c, 0x0072403e, 0x00840d00, 
+  0x00e300a0, 0x00731023, 0x00e40001, 0x00144200, 0x00a10300, 0x00511400, 
+  0x00d00090, 0x00b01300, 0x00840d00, 0x00a30201, 0x0007033c, 0x0077005e, 
+  0x00eb0450, 0x00ea0460, 0x002bb100, 0x00b07201, 0x00773d00, 0x00c0703f, 
+  0x009c1537, 0x00773ca8, 0x00d0531b, 0x0047301f, 0x00c0701f, 0x009c153b, 
+  0x00e70000, 0x00a9000b, 0x00e80001, 0x00188700, 0x0078003f, 0x00780020, 
+  0x006880ff, 0x00499800, 0x00a40b00, 0x00b0900b, 0x00a60005, 0x00e70001, 
+  0x00177100, 0x00777210, 0x006770ff, 0x00a80001, 0x00a90002, 0x00aa0006, 
+  0x00488700, 0x00499700, 0x004aa700, 0x00b08001, 0x00a80004, 0x00b09002, 
+  0x00488700, 0x00a9001a, 0x00499700, 0x00b0a006, 0x00b0901a, 0x00b08004, 
+  0x00a00200, 0x00d50050, 0x00455001, 0x00773c3f, 0x00555700, 0x00981566, 
+  0x00d00090, 0x00a700f4, 0x00181001, 0x00155800, 0x00407500, 0x00981566, 
+  0x00155001, 0x00740062, 0x00a70200, 0x0098156f, 0x00773c3e, 0x0098156f, 
+  0x00177100, 0x00566700, 0x00e70003, 0x00747040, 0x00d05717, 0x00a70200, 
+  0x009c1573, 0x00740040, 0x00d05717, 0x00547002, 0x00e70001, 0x00177110, 
+  0x00566700, 0x00b04b00, 0x00b06005, 0x00b050f5, 0x00840d00, 0x00ec0001, 
+  0x00da3040, 0x008c257f, 0x00d0001f, 0x0016ca00, 0x00eb0460, 0x00633600, 
+  0x002bba00, 0x00e40560, 0x00ab0b00, 0x0079bc88, 0x00169004, 0x00244600, 
+  0x0076bc2e, 0x009c15e5, 0x00d00090, 0x0017c900, 0x00a1001c, 0x00411700, 
+  0x009c157c, 0x00d00090, 0x00a7040b, 0x00a1040e, 0x00401001, 0x009c1596, 
+  0x00500700, 0x009c157c, 0x004110fe, 0x0076bc84, 0x00a8040c, 0x00b0140e, 
+  0x0098157c, 0x0075bcb8, 0x00255001, 0x00a1040f, 0x0016563e, 0x009c15a1, 
+  0x00e60001, 0x00751cc9, 0x00155002, 0x00d11070, 0x00211001, 0x00355100, 
+  0x00305600, 0x0098257c, 0x0006043c, 0x00b01eff, 0x00b02efe, 0x00b03efd, 
+  0x00b04efc, 0x003ee004, 0x0071bc56, 0x009815b3, 0x00f40000, 0x009925b8, 
+  0x00d05b15, 0x00f00000, 0x009915b8, 0x00ed05b7, 0x008c0512, 0x009c15bf, 
+  0x00d00090, 0x00d00090, 0x00a41e01, 0x00a31e01, 0x00a21e01, 0x00a11e01, 
+  0x00d0571c, 0x0075bc84, 0x00e409d6, 0x007445f0, 0x00544900, 0x00745064, 
+  0x00725084, 0x00b04300, 0x0071bcb8, 0x009815ca, 0x007210b8, 0x0072c034, 
+  0x00211001, 0x00111500, 0x00a50401, 0x00755c2f, 0x00725037, 0x0075bc3d, 
+  0x0072503d, 0x005f2c00, 0x00a20603, 0x005f0200, 0x0075bc3d, 0x009815d7, 
+  0x00222100, 0x0075bc60, 0x00a8060c, 0x00388100, 0x009c25dc, 0x0008003c, 
+  0x00b05ac0, 0x00b02603, 0x00b0160b, 0x00b0860c, 0x00a41e01, 0x00a31e01, 
+  0x00a21e01, 0x00a11e01, 0x00d0571c, 0x00a8040d, 0x00983655, 0x0075bcb8, 
+  0x00a70402, 0x00983655, 0x0077bc84, 0x00255001, 0x00a8040f, 0x0016573e, 
+  0x009c15f0, 0x00e60001, 0x00d58670, 0x0098257c, 0x00306010, 0x009835f6, 
+  0x008c857c, 0x009c857c, 0x003707fe, 0x009835fa, 0x00e60001, 0x00166700, 
+  0x0007043c, 0x00b03eff, 0x003ee001, 0x0071bc56, 0x009c1602, 0x00f00000, 
+  0x00991607, 0x00d06014, 0x00f50000, 0x00992607, 0x00ed0606, 0x008c0512, 
+  0x009c160b, 0x00d00090, 0x00d00090, 0x00a31e01, 0x00d0571c, 0x0075bc84, 
+  0x00e40a9a, 0x007445f0, 0x00544900, 0x00745064, 0x00746127, 0x0015c900, 
+  0x00b04300, 0x00a9001b, 0x00599500, 0x0004073c, 0x00b0901b, 0x0070bc65, 
+  0x00981656, 0x00e54002, 0x0071bcb8, 0x0098161e, 0x007510b8, 0x0075c034, 
+  0x0071bc84, 0x007510a4, 0x0071bc3d, 0x0075103d, 0x00a10401, 0x00711c2f, 
+  0x00751037, 0x005f2500, 0x00a20404, 0x00156002, 0x005f0200, 0x00af2800, 
+  0x00366001, 0x009c1629, 0x0076bc60, 0x0070bc3d, 0x00881630, 0x00222500, 
+  0x00a70402, 0x00a9040d, 0x00b06ac0, 0x00377500, 0x00399500, 0x009c364b, 
+  0x00d00090, 0x00a90405, 0x00309700, 0x0098263b, 0x0009073c, 0x00a50401, 
+  0x00b0940c, 0x00705c26, 0x0098164b, 0x00d00090, 0x00a50406, 0x00a10409, 
+  0x00211500, 0x0078022f, 0x00b01409, 0x00b01403, 0x00b0deff, 0x003ee001, 
+  0x00ed064a, 0x008c002b, 0x00ad1e01, 0x00a1000b, 0x0016ca00, 0x00611600, 
+  0x00b02404, 0x00b0100b, 0x00b0940d, 0x00b0840f, 0x00b07402, 0x00a31e01, 
+  0x00d0571c, 0x00d0571c, 0x0071bc84, 0x00c01000, 0x009c166a, 0x00e14102, 
+  0x00e50310, 0x00715210, 0x00a50401, 0x00755c2f, 0x00715037, 0x005f2100, 
+  0x00a20404, 0x00efeeee, 0x005f0200, 0x00a12800, 0x001f1000, 0x001f1038, 
+  0x001f1030, 0x001f1028, 0x00e50004, 0x00d0621c, 0x00e14112, 0x00e50110, 
+  0x00715210, 0x00a50401, 0x00755c2f, 0x00715037, 0x005f2100, 0x00a20404, 
+  0x00efffcc, 0x005f0200, 0x00a12800, 0x001f1000, 0x001f1030, 0x00e50004, 
+  0x00d0621c, 0x00a30022, 0x00a90021, 0x00333001, 0x00d00090, 0x00b03022, 
+  0x009c301e, 0x00d87040, 0x00b09022, 0x0098201e, 0x00e20001, 0x00122800, 
+  0x00677200, 0x0009083c, 0x00199004, 0x00e20560, 0x00299200, 0x00d00090, 
+  0x00a0090b, 0x009c167f, 0x00f40000, 0x00aa0903, 0x00ab0902, 0x0099167f, 
+  0x0098367f, 0x00528006, 0x00e100a8, 0x00211200, 0x00e206a9, 0x00a00100, 
+  0x009c101e, 0x00548050, 0x00742210, 0x00a20011, 0x00b04100, 0x0072802c, 
+  0x00a30901, 0x00733c2f, 0x00723037, 0x005f0200, 0x005f0a00, 0x00e20080, 
+  0x002aa200, 0x0013203e, 0x003bb200, 0x00b0a903, 0x00b0390b, 0x00b0b902, 
+  0x00d0671f, 0x00ad090e, 0x00ab090b, 0x00ac090f, 0x00ff1000, 0x00a40d0a, 
+  0x00a80d09, 0x00b040e9, 0x007f8c61, 0x00543006, 0x00ff3000, 0x004f8080, 
+  0x00b0401d, 0x00b0e009, 0x00ae0d0f, 0x00a20d0b, 0x009816c5, 0x00d00090, 
+  0x00d00090, 0x00ad1e01, 0x00aa1e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 
+  0x00a51e01, 0x00a41e01, 0x00a31e01, 0x00a11e01, 0x00840200, 0x00e206cf, 
+  0x00a400ed, 0x00b01eff, 0x003ee001, 0x00a5001d, 0x00304500, 0x009c17b8, 
+  0x00d00090, 0x00d00090, 0x00a11e01, 0x00080f3c, 0x003bb001, 0x00b080eb, 
+  0x00d00090, 0x009a86e0, 0x00d00090, 0x00a00d13, 0x009c26dc, 0x00d00090, 
+  0x00d00090, 0x00b2ac00, 0x000a083c, 0x00d06c16, 0x00e4ffff, 0x000a083c, 
+  0x00b04d13, 0x00d06c16, 0x00a50d06, 0x00105001, 0x009c26d5, 0x00d00090, 
+  0x00a100e9, 0x00745d08, 0x00b01d0a, 0x00761d00, 0x00374600, 0x00745d00, 
+  0x00366400, 0x00577600, 0x00677500, 0x009826ef, 0x00d06d15, 0x00a70d09, 
+  0x00711c48, 0x00777c41, 0x003771fb, 0x00ff1000, 0x00a40d09, 0x00747041, 
+  0x004f7003, 0x00b04d09, 0x00307004, 0x009c2707, 0x00d00090, 0x00b01eff, 
+  0x003ee001, 0x00a400ed, 0x00e20705, 0x00a1001d, 0x00304100, 0x009c17b8, 
+  0x00d00090, 0x00d00090, 0x00a11e01, 0x003bb001, 0x00000f3c, 0x00307007, 
+  0x00983711, 0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 
+  0x00ff3000, 0x000f083c, 0x00d0711d, 0x00b01eff, 0x003ee001, 0x00a400ed, 
+  0x00e2071b, 0x00a1001d, 0x00304100, 0x009c17b8, 0x00d00090, 0x00d00090, 
+  0x00a11e01, 0x003bb001, 0x00080f3c, 0x00b0c90f, 0x00738d10, 0x00333001, 
+  0x00705c3d, 0x0098174b, 0x00303004, 0x0098274b, 0x00708610, 0x009c274b, 
+  0x00d00090, 0x00b01eff, 0x003ee001, 0x00a400ed, 0x00e20731, 0x00a1001d, 
+  0x00304100, 0x009c17b8, 0x00d00090, 0x00d00090, 0x00a11e01, 0x003bb001, 
+  0x00333004, 0x00040f3c, 0x00044040, 0x00744201, 0x00748859, 0x001440be, 
+  0x00788c5a, 0x00588001, 0x001880bf, 0x00a5090f, 0x00a20d0e, 0x00d55070, 
+  0x00155002, 0x00255101, 0x00a00d13, 0x00982743, 0x00355004, 0x00d00090, 
+  0x00d00090, 0x00b28200, 0x00a80d04, 0x00255800, 0x00b24200, 0x00b25200, 
+  0x00b02d0e, 0x00c01003, 0x009c1757, 0x00d00090, 0x00a40d13, 0x00982751, 
+  0x00d07514, 0x00444001, 0x00b2ac00, 0x00b04d13, 0x00e5fffc, 0x00e1ffff, 
+  0x00d07519, 0x002510fd, 0x00d00090, 0x00303504, 0x0098276a, 0x00d00090, 
+  0x00b01eff, 0x003ee001, 0x00a400ed, 0x00a1001d, 0x00e20766, 0x00304100, 
+  0x009c17b8, 0x00d00090, 0x00d00090, 0x00a11e01, 0x003bb001, 0x00333004, 
+  0x00080f3c, 0x00d07519, 0x00477003, 0x00357300, 0x00255101, 0x00ff1000, 
+  0x00a40d09, 0x00745041, 0x004f5003, 0x00b04d09, 0x00301303, 0x009817a5, 
+  0x00c05004, 0x009c1795, 0x00ff2000, 0x00d00090, 0x00d00090, 0x00d00090, 
+  0x00080f3c, 0x00ff3000, 0x000f083c, 0x00d07a15, 0x00ff2000, 0x00d00090, 
+  0x00d00090, 0x00d00090, 0x00040f3c, 0x00ff3000, 0x000f043c, 0x00155003, 
+  0x00144500, 0x0015503d, 0x00330300, 0x009c278b, 0x00e30000, 0x00357500, 
+  0x00355004, 0x00155003, 0x00144500, 0x00350500, 0x00144500, 0x00355020, 
+  0x00188500, 0x00588400, 0x00d07a15, 0x00455003, 0x00305700, 0x0098277e, 
+  0x00e207a2, 0x00b01eff, 0x003ee001, 0x00a400ed, 0x00a1001d, 0x00304100, 
+  0x009c17b8, 0x00d00090, 0x00d00090, 0x00a11e01, 0x003bb001, 0x00080f3c, 
+  0x00d00090, 0x00500100, 0x009c27a8, 0x00ea0000, 0x00211001, 0x00111003, 
+  0x00310100, 0x00188100, 0x00211020, 0x001aa100, 0x00310100, 0x001aa100, 
+  0x00211020, 0x00188100, 0x00e40001, 0x00588a00, 0x00b04d13, 0x00b080eb, 
+  0x00e206c6, 0x00d06d13, 0x00a11e01, 0x00b0c90f, 0x00b02d0b, 0x00b0b90b, 
+  0x00ff2000, 0x00b01eff, 0x00b03efe, 0x00b04efd, 0x00b05efc, 0x00b06efb, 
+  0x00b07efa, 0x00b08ef9, 0x00b0aef8, 0x00b0def7, 0x003ee009, 0x00a100e9, 
+  0x00a40d09, 0x00b01d0a, 0x00b0ed0f, 0x00050f3c, 0x00754100, 0x00ae0009, 
+  0x00b05d09, 0x00a0090b, 0x009c135d, 0x00e400a8, 0x00a8001d, 0x00244800, 
+  0x00488001, 0x00b00400, 0x00e40001, 0x00144800, 0x00a10002, 0x00611400, 
+  0x00a80003, 0x00588400, 0x00b01002, 0x00b08003, 0x00d0351d, 0x00a7090e, 
+  0x00ff1000, 0x007f7c61, 0x00ff3000, 0x005f0700, 0x00500a00, 0x009c17e7, 
+  0x00fa0000, 0x00ec04e0, 0x00ed0008, 0x00a4090b, 0x00a6090f, 0x00724cca, 
+  0x008817f1, 0x003dd200, 0x00500f00, 0x00322001, 0x009c37ee, 0x00407001, 
+  0x009c17f6, 0x00d00090, 0x00727c41, 0x00244200, 0x00724cc2, 0x003dd200, 
+  0x00122002, 0x00a0090c, 0x008c17fc, 0x00724d00, 0x0005023c, 0x00222003, 
+  0x0012203e, 0x00a10c09, 0x00ab0c00, 0x00311200, 0x00a20c01, 0x00b01c09, 
+  0x00a40c02, 0x00a10c03, 0x00aa0909, 0x00a80908, 0x002505fc, 0x009c2817, 
+  0x00255004, 0x00983833, 0x002505fc, 0x00777c41, 0x00377504, 0x009c283e, 
+  0x00370500, 0x003dd001, 0x00177003, 0x0013f700, 0x00155003, 0x00133500, 
+  0x00d08118, 0x00530f00, 0x00b05eff, 0x003ee001, 0x00a50c08, 0x009c1821, 
+  0x00e500c0, 0x00ab0c04, 0x00a20c05, 0x00a40c06, 0x00a10c07, 0x00355001, 
+  0x00d00090, 0x00b05c08, 0x00a51e01, 0x00783210, 0x0078b021, 0x001bb03f, 
+  0x007b203f, 0x0012203f, 0x00133030, 0x007a3210, 0x007a4021, 0x0014403f, 
+  0x0074103f, 0x0011103f, 0x00b28600, 0x00b2a600, 0x00d08018, 0x00b0bc00, 
+  0x00b02c01, 0x00b04c02, 0x00b01c03, 0x00e7ffff, 0x003dd001, 0x0098283e, 
+  0x00d00090, 0x00d00090, 0x00500f00, 0x00d08318, 0x00ff2000, 0x0000073c, 
+  0x009c2812, 0x00d00090, 0x00a7090e, 0x0047700e, 0x00b0090b, 0x0042f080, 
+  0x00577200, 0x00b0690f, 0x00b0790e, 0x00d04c1c, 0x00d77040, 0x00e90560, 
+  0x007c7484, 0x002cc900, 0x00e90016, 0x00a50c0b, 0x00705d00, 0x009c18af, 
+  0x00d00090, 0x00ab0c0c, 0x008c388c, 0x00a20c01, 0x00702c3c, 0x009818af, 
+  0x00eb04e0, 0x00a90c0f, 0x00a30c0d, 0x00a80b09, 0x0098188b, 0x00e20016, 
+  0x00a40b00, 0x00a50b01, 0x00a60b02, 0x00a70b03, 0x00d09270, 0x009c288b, 
+  0x00e20008, 0x00308008, 0x009c2868, 0x0002083c, 0x00aa0b08, 0x009c186f, 
+  0x00ea00c0, 0x00a50b05, 0x00a40b04, 0x00a60b06, 0x00a70b07, 0x003aa001, 
+  0x00d00090, 0x00b0ab08, 0x00aa0c08, 0x007a4021, 0x0014403f, 0x0074503f, 
+  0x0015503f, 0x00b2a900, 0x00aa0c09, 0x007a6021, 0x0016603f, 0x0076703f, 
+  0x0017703f, 0x00b2a900, 0x00233008, 0x00388001, 0x00322001, 0x009c3868, 
+  0x00d00090, 0x00b04b00, 0x00b05b01, 0x00b06b02, 0x00b07b03, 0x00b03c02, 
+  0x00b03c0d, 0x00b08b09, 0x00b09c0f, 0x00d08a1f, 0x00aa0c0f, 0x00a80c01, 
+  0x00718c3b, 0x00981893, 0x00f40000, 0x009928af, 0x00d08915, 0x00f00000, 
+  0x009918af, 0x00d0a970, 0x009c28af, 0x00d00090, 0x00ed089a, 0x008c0512, 
+  0x009818af, 0x00e407df, 0x007445f0, 0x00544750, 0x00a90c03, 0x00b04300, 
+  0x00788c2f, 0x00728037, 0x0046901f, 0x005f2051, 0x004f90e0, 0x003606e0, 
+  0x00306b00, 0x009838a9, 0x00060b3c, 0x00756100, 0x003bb600, 0x00299600, 
+  0x00b0bc0c, 0x00b09c03, 0x00b05c0b, 0x00d00211, 0x00b0deff, 0x003ee001, 
+  0x00771484, 0x00e50560, 0x00277500, 0x0005013c, 0x00ab0701, 0x0071bc3b, 
+  0x009818bc, 0x00f40000, 0x009928ef, 0x00d08b1f, 0x00f00000, 0x009918ef, 
+  0x00d00090, 0x00a90703, 0x00a3070b, 0x00a8070f, 0x00a4070e, 0x00404001, 
+  0x009c18c8, 0x00500300, 0x009c18ef, 0x00d00090, 0x00aa070c, 0x009818ef, 
+  0x00738d07, 0x004330fc, 0x00303022, 0x009828f8, 0x0040a080, 0x009818f8, 
+  0x00d00090, 0x0040907f, 0x009c18f8, 0x00d48070, 0x00d00090, 0x00303421, 
+  0x009838f3, 0x00ed08d9, 0x008c0512, 0x009818ef, 0x00e409d6, 0x007445f0, 
+  0x00544550, 0x00a10008, 0x0076bc2f, 0x00716037, 0x00b04300, 0x005f1200, 
+  0x005f0900, 0x00a4070e, 0x00740020, 0x00a30701, 0x00b0470e, 0x00733c26, 
+  0x00133007, 0x00299300, 0x00e30080, 0x003aa300, 0x00b09703, 0x00b0a70c, 
+  0x00b0370b, 0x00ad1e01, 0x00d00090, 0x00d00090, 0x00840d00, 0x0076bca0, 
+  0x00e40001, 0x0074403f, 0x00144600, 0x009828ef, 0x00d48070, 0x003043f6, 
+  0x009c28ef, 0x00ed08fd, 0x008c0512, 0x009818ef, 0x00e409a0, 0x007445f0, 
+  0x00544550, 0x0076bc2f, 0x00726037, 0x005f2051, 0x004f90e0, 0x00b04300, 
+  0x0043901f, 0x00a4070e, 0x00740020, 0x00d00090, 0x00b0470e, 0x00a40701, 
+  0x00744c26, 0x0098190f, 0x003993e0, 0x003403e0, 0x003aa400, 0x009c2913, 
+  0x000a003c, 0x00a3070b, 0x00743cca, 0x00d00090, 0x003304f8, 0x00133002, 
+  0x007340ca, 0x00d08e1c, 0x00741484, 0x00e70560, 0x00244700, 0x00e20020, 
+  0x00a0040b, 0x009c1973, 0x00d00090, 0x00ac0401, 0x0070cc3a, 0x009c1927, 
+  0x00f00000, 0x00991973, 0x00d09219, 0x00f50000, 0x00992973, 0x00d00090, 
+  0x00a6040f, 0x00a7040d, 0x00a50404, 0x0043501f, 0x009c1974, 0x00207080, 
+  0x00982974, 0x00d76270, 0x00982974, 0x008c8973, 0x009c8973, 0x00e20080, 
+  0x00d00090, 0x00a70007, 0x007ccc2f, 0x0077c037, 0x005f0700, 0x005f0500, 
+  0x00d02000, 0x00af2600, 0x00a70402, 0x00b0640f, 0x00255200, 0x00377200, 
+  0x00b05404, 0x00b07402, 0x009c394e, 0x00d00090, 0x00b00402, 0x0002043c, 
+  0x00b0deff, 0x003ee001, 0x00ed094c, 0x008c052b, 0x00ad1e01, 0x00d09713, 
+  0x00a3040d, 0x00333200, 0x009c3972, 0x00e50001, 0x00155100, 0x00a2001c, 
+  0x00422500, 0x009c1972, 0x00d00090, 0x00a20405, 0x00760210, 0x00302700, 
+  0x0088295c, 0x0002073c, 0x00b0640f, 0x00b0240c, 0x00b0240d, 0x00b07402, 
+  0x00a2040a, 0x00a70409, 0x00a30407, 0x00a50406, 0x00222300, 0x00277500, 
+  0x00b0240a, 0x00b07409, 0x00b02404, 0x00b07403, 0x0003013c, 0x0001073c, 
+  0x00b0deff, 0x003ee001, 0x00ed0970, 0x008c002b, 0x00ad1e01, 0x00d09713, 
+  0x00b0340d, 0x00840d00, 0x00a2040d, 0x00a0040b, 0x009c1973, 0x00222300, 
+  0x00d86070, 0x00981973, 0x00188002, 0x00288300, 0x004880fc, 0x00308020, 
+  0x00983980, 0x00e80020, 0x00308200, 0x00982985, 0x00392001, 0x0008023c, 
+  0x00d09816, 0x00398001, 0x00e74252, 0x007ccc2f, 0x0077c037, 0x005f0700, 
+  0x000f9337, 0x004f50e0, 0x004a30fc, 0x003b8a00, 0x00500a00, 0x00981995, 
+  0x005f0000, 0x003aa004, 0x009c3990, 0x00d00090, 0x00d00090, 0x00af2600, 
+  0x003bb004, 0x009c3995, 0x003a08e0, 0x004aa0fc, 0x0098199e, 0x005f0000, 
+  0x003aa004, 0x009c399b, 0x00328300, 0x00d0931e, 0x00a2090e, 0x00ff1000, 
+  0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c19a8, 0x00fa0000, 
+  0x00ab090b, 0x004220fe, 0x00a8090f, 0x00b0290e, 0x0075bcca, 0x009819b3, 
+  0x00d00090, 0x00d00090, 0x00500f00, 0x00355001, 0x008c39b0, 0x0075bcc2, 
+  0x009819ba, 0x00d00090, 0x00d00090, 0x00b2f800, 0x00355001, 0x008c39b7, 
+  0x00b0090b, 0x0002073c, 0x00010a3c, 0x00ed09bf, 0x008c0522, 0x00a5090e, 
+  0x009819d4, 0x00ff2000, 0x0045500f, 0x00d00090, 0x00d00090, 0x004bf080, 
+  0x00555b00, 0x00a4090c, 0x009819cc, 0x00d00090, 0x00b0590e, 0x00d09d14, 
+  0x00755c41, 0x00d00090, 0x003505fc, 0x00155003, 0x00350500, 0x001bb500, 
+  0x00d00090, 0x00b2b800, 0x00b0890f, 0x00d0351d, 0x00a2090e, 0x00ff1000, 
+  0x007f2c61, 0x00ff3000, 0x005f0200, 0x00500a00, 0x009c19de, 0x00fa0000, 
+  0x004220fe, 0x00a8090f, 0x00b0290e, 0x00eb09e7, 0x007c1c64, 0x002ccb00, 
+  0x00ab090b, 0x00a20908, 0x00840c00, 0x00d0a018, 0x00d09f1f, 0x00d09f1b, 
+  0x00d09f16, 0x00d09f11, 0x00ec09ed, 0x00d00008, 0x00b2f800, 0x003bb020, 
+  0x00d0a111, 0x00ec09f2, 0x00d00004, 0x00b2f800, 0x003bb010, 0x00d0a111, 
+  0x00ec09f7, 0x00d00002, 0x00b2f800, 0x003bb008, 0x00d0a111, 0x00ec09fc, 
+  0x00b2f800, 0x003bb004, 0x00d0a111, 0x00ec0a00, 0x00122030, 0x0072f210, 
+  0x003bb002, 0x008c1a11, 0x00d00090, 0x00d00090, 0x00b22800, 0x00d0a111, 
+  0x00ec0a09, 0x00122038, 0x0072f118, 0x003bb001, 0x008c1a11, 0x00d00090, 
+  0x00d00090, 0x00b22800, 0x00d0a111, 0x00a50aec, 0x00355700, 0x00801c00, 
+  0x00b02908, 0x00b0b90b, 0x00500b00, 0x009c1a1c, 0x0002073c, 0x00010a3c, 
+  0x00ed0a1c, 0x008c0522, 0x00a5090e, 0x00981a31, 0x00ff2000, 0x00d00090, 
+  0x00d00090, 0x0045500f, 0x004bf080, 0x00a4090c, 0x00981a29, 0x00555b00, 
+  0x00d00090, 0x00b0590e, 0x00d0a311, 0x00755c41, 0x00d00090, 0x003505fc, 
+  0x00155003, 0x00350500, 0x001bb500, 0x00d00090, 0x00b2b800, 0x00b0890f, 
+  0x00d0351d, 0x00f50000, 0x00500a00, 0x009c1a37, 0x00f00000, 0x00ec04e0, 
+  0x00a7090b, 0x00a50c0a, 0x007d7ca3, 0x00ab0c00, 0x00a20c01, 0x00a40c02, 
+  0x00a10c03, 0x00a70c08, 0x009c3a4a, 0x00e700c0, 0x00ab0c04, 0x00a20c05, 
+  0x00a40c06, 0x00a10c07, 0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03, 
+  0x00377001, 0x00a30908, 0x00a60909, 0x00b07c08, 0x0048f500, 0x004af500, 
+  0x00783880, 0x007a6880, 0x0078b021, 0x007a4021, 0x001bb03f, 0x0014403f, 
+  0x007b203f, 0x0074103f, 0x00a6090f, 0x0011103f, 0x00d00090, 0x00b28600, 
+  0x00b2a600, 0x0012203f, 0x00b0690f, 0x003dd001, 0x008c1a3f, 0x00b0bc00, 
+  0x00b02c01, 0x00b04c02, 0x00b01c03, 0x00b0090b, 0x00d04c1c, 0x00d77040, 
+  0x00e10560, 0x007b7484, 0x002bb100, 0x00d00090, 0x00a40b0b, 0x009c1a99, 
+  0x00d00090, 0x00a10b0f, 0x00a80b03, 0x00d91070, 0x00a50b01, 0x002009e0, 
+  0x009c2a99, 0x00d00090, 0x00ea0004, 0x00a90b0c, 0x00883a99, 0x00329020, 
+  0x008c2a7c, 0x007a9c43, 0x00715c3b, 0x00981a81, 0x00f40000, 0x00992a99, 
+  0x00d0a813, 0x00f00000, 0x00991a99, 0x00ed0a85, 0x008c0512, 0x00981a99, 
+  0x00e40a33, 0x007445f0, 0x00544730, 0x00755c2f, 0x00b04300, 0x00e10000, 
+  0x00a30b06, 0x00725037, 0x00211008, 0x005f2031, 0x004f80f8, 0x00288300, 
+  0x003aa001, 0x008c3a8e, 0x00399100, 0x00741500, 0x00b09b0c, 0x00b08b03, 
+  0x00b04b0b, 0x00d00214, 0x00f50000, 0x00500a00, 0x009c1a9e, 0x00f00000, 
+  0x00761d27, 0x00a40901, 0x00000f3c, 0x00366001, 0x009c1aa0, 0x00724ca0, 
+  0x0030201f, 0x009c1aa7, 0x00724ca8, 0x00e60001, 0x00a8000b, 0x001b6200, 
+  0x00568b00, 0x00e80001, 0x00b0600b, 0x00ab001b, 0x00188300, 0x006bb800, 
+  0x00a70902, 0x00b0b01b, 0x009c3abf, 0x0001033c, 0x00b00902, 0x00b01eff, 
+  0x00b02efe, 0x00b0aefd, 0x003ee003, 0x0002093c, 0x00ed0abc, 0x008c052b, 
+  0x00aa1e01, 0x00a21e01, 0x00a11e01, 0x00010a3c, 0x00d04c1c, 0x00707cbb, 
+  0x00981ac8, 0x0070bcbb, 0x00981ac8, 0x00702cbb, 0x00981ac8, 0x00840d00, 
+  0x0076002f, 0x00840d00, 0x00707cbb, 0x00981acf, 0x00702cbb, 0x00981acf, 
+  0x00840d00, 0x0076002f, 0x00840d00
+};
+
+#define TABLE_LENGTH(x) (sizeof(x)/sizeof(*(x)))
+#define STB7200_IMEM_REGION_LENGTH  0x1000
+
+#define STB7200_DMEM_REGION_LENGTH  0x800
+
+#define STB7200_IMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7200_IMEM_REGION)
+#define STB7200_DMEM_FIRMWARE_SZ  TABLE_LENGTH(STB7200_DMEM_REGION)
+
+
+
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/coprocessor.h linux-2.6.23.1-stm/include/linux/stm/coprocessor.h
--- linux-2.6.23.1/include/linux/stm/coprocessor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/coprocessor.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2003-2004 Giuseppe Cavallaro (peppe.cavallaro@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+#include <asm/addrspace.h>
+
+#define	MEGA			(1024 * 1024)
+typedef unsigned long kaddr_t;
+
+/* IOCTL parameters */
+
+typedef struct {
+	char	    name[16];		/* coprocessor name		    */
+	u_int	    flags;		/* control flags 		    */
+					/* Coprocessor region:              */
+	kaddr_t	    ram_start;		/*   Host effective address         */
+	u_int	    ram_size;		/*   region size (in bytes)         */
+	kaddr_t	    cp_ram_start;	/*   coprocessor effective address  */
+
+} cop_properties_t;
+
+#define ST_IOCTL_BASE		'l'
+#define STCOP_GRANT		_IOR(ST_IOCTL_BASE, 0, u_int)
+#define STCOP_RESET		_IOR(ST_IOCTL_BASE, 1, u_int)
+#define STCOP_START             STCOP_GRANT
+#define STCOP_PEEK		_IOR(ST_IOCTL_BASE, 2, void*)
+#define STCOP_POKE		_IOW(ST_IOCTL_BASE, 3, void*)
+#define STCOP_GET_PROPERTIES	_IOR(ST_IOCTL_BASE, 4, cop_properties_t*)
+#define STCOP_SET_PROPERTIES	_IOW(ST_IOCTL_BASE, 5, cop_properties_t*)
+
+#define NO_DATA		0xdeadbeef
+#define UNDEFINED_DATA	NO_DATA
+
+/* ---------------------------------------------------------------------------
+ *     Generic macros
+ * ------------------------------------------------------------------------ */
+
+#define xstring(x)              string(x)
+#define string(x)		#x
+#define plname(x)		x
+#define make_pname(x,y)		x ## y
+
+#define	MEGA			(1024 * 1024)
+#define COPROCESSOR_MAJOR	63
+#define FILE_2_COP(c,f)	  	(&(c)[MINOR((f)->f_dentry->d_inode->i_rdev)])
+
+#define OUT_PORT		2	/* Mailbox host --> cop. port */
+#define IN_PORT			3	/* Mailbox cop. --> host port */
+#define poke_l(v,a)		*((u_int *)(a)) = (v)
+#define peek_l(a)		*((u_int *)(a))
+
+
+#define COPR_ADDR(cop, off)     ( (cop)->ram_offset  + (off))
+#define HOST_ADDR(cop, off)	( (cop)->vma_address + (off))
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+#define DPRINTK(args...)   printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+#define __debug(a, b)	   _debug(a, b)
+
+/* ---------------------------------------------------------------------------
+ *     Local types
+ * ------------------------------------------------------------------------ */
+
+#define COPROC_SPACE_ALLOCATE	 0x0001	/* coprocessor RAM has been defined */
+#define COPROC_IN_USE    	 0x0002	/* copr. device has been opened     */
+#define COPROC_RUNNING   	 0x0004	/* coproc. is running (ioctl GRANT) */
+
+typedef struct {
+	u_int	    id;			/* CPU ID, now the CPU N. 	    */
+	u_int	    control;		/* see flags above (driver control) */
+	/*
+	 * The base address of coprocessor region, both sides: host (ST40)
+	 * and slave (ST231, LX,...) are build based on offset and start addr.
+	 */
+	u_long	    ram_offset;		/* Coprocessor RAM offset (in bytes)*/
+	u_int	    ram_size;		/* Coprocessor RAM size (in bytes)  */
+	u_long      vma_address;	/* The remap phisycal memory */
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	u_int	    h2c_port;		/* comm. port: host --> coproc.     */
+	u_int	    c2h_port;		/* comm. port: host <-- coproc.     */
+#endif
+	u_int	    irq;		/* interrup used... if any          */
+	u_long	    mbox_wait;		/* CPU signature (waiting for boot) */
+	u_long	    mbox_entryp;	/* where to put the entry point...  */
+	u_long	    mbox_enable;	/* ... to trigger the CPU start     */
+	struct platform_device pdev;
+} coproc_t;
+
+struct coproc_board_info {
+	char *name;
+	int max_coprs;
+};
+
+extern int coproc_cpu_open(coproc_t *);
+extern int coproc_cpu_init(coproc_t *);
+extern int coproc_cpu_grant(coproc_t *, unsigned long);
+extern int coproc_cpu_release(coproc_t *);
+extern int coproc_cpu_reset(coproc_t *);
+extern int coproc_check_area(u_long, u_long, int, coproc_t *);
+extern void coproc_proc_other_info(coproc_t *, struct seq_file *);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/emi.h linux-2.6.23.1-stm/include/linux/stm/emi.h
--- linux-2.6.23.1/include/linux/stm/emi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/emi.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+int emi_init(unsigned long memory_base, unsigned long control_base);
+unsigned long emi_bank_base(int bank);
+void emi_config_pata(int bank);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/fdma-plat.h linux-2.6.23.1-stm/include/linux/stm/fdma-plat.h
--- linux-2.6.23.1/include/linux/stm/fdma-plat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/fdma-plat.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+/* Memory section offsets from FDMA base address */
+#define STB7100_FDMA_BASE 					0x19220000
+#define STB7109_FDMA_BASE 					STB7100_FDMA_BASE
+
+#define STB7100_DMEM_OFFSET            				0x8000     /* Contains the control word interface */
+#define STB7100_IMEM_OFFSET            				0xC000     /* Contains config data */
+
+#define STB7109_DMEM_OFFSET					STB7100_DMEM_OFFSET
+#define STB7109_IMEM_OFFSET					STB7100_IMEM_OFFSET
+
+#define STB7200_DMEM_OFFSET					STB7100_DMEM_OFFSET
+#define STB7200_IMEM_OFFSET					STB7100_IMEM_OFFSET
+
+#define STB7200_FDMA0_BASE					0xFD810000
+#define STB7200_FDMA1_BASE					0xFD820000
+#define STB7200_XBAR_BASE					0xFD830000
+
+#define STB7200_IMEM_OFFSET					STB7100_IMEM_OFFSET
+#define STB7200_DMEM_OFFSET					STB7100_DMEM_OFFSET
+
+#define IMEM_REGION_LENGTH					0xa00
+#define DMEM_REGION_LENGTH					0x600
+
+#define NODE_DATA_OFFSET					0x40
+#define CMD_STAT_OFFSET       					0x04
+
+#define FDMA2_ID						0x0000   /* Block Id */
+#define FDAM2_VER						0x0004
+#define FDMA2_ENABLE_REG					0x0008
+#define FDMA2_CLOCKGATE						0x000C       /* Clock enable control */
+#define FDMA2_REV_ID						0x8000
+
+/*here our our current node params region */
+#define STB7100_FDMA_CMD_STATn_REG 				0x8040 /* (+ n * 0x04) */
+#define STB7100_FDMA_PTR_REG 					0x9180 /* (+ n * 0x40) */
+#define STB7100_FDMA_COUNT_REG					0x9188 /* (+ n * 0x40) */
+#define STB7100_FDMA_SADDR_REG					0x918c /* (+ n * 0x40) */
+#define STB7100_FDMA_DADDR_REG					0x9190 /* (+ n * 0x40) */
+#define STB7100_FDMA_REQ_CTLn_REG				0x9780 /* (+ n * 0x04) */
+
+#define STB7109_FDMA_CMD_STATn_REG				0x9140 /* (+ n * 0x04) */
+#define STB7109_FDMA_REQ_CTLn_REG				0x9180 /* (+ n * 0x04) */
+#define STB7109_FDMA_PTR_REG					0x9400 /* (+ n * 0x40) */
+#define STB7109_FDMA_COUNT_REG					0x9408 /* (+ n * 0x40) */
+#define STB7109_FDMA_SADDR_REG					0x940c /* (+ n * 0x40) */
+#define STB7109_FDMA_DADDR_REG					0x9410 /* (+ n * 0x40) */
+
+#define STB7200_FDMA_CMD_STATn_REG				0x9140 /* (+ n * 0x04) */
+#define STB7200_FDMA_REQ_CTLn_REG				0x9180 /* (+ n * 0x04) */
+#define STB7200_FDMA_PTR_REG					0x9580 /* (+ n * 0x40) */
+#define STB7200_FDMA_COUNT_REG					0x9588 /* (+ n * 0x40) */
+#define STB7200_FDMA_SADDR_REG					0x958c /* (+ n * 0x40) */
+#define STB7200_FDMA_DADDR_REG					0x9590 /* (+ n * 0x40) */
+
+#define FDMA2_SYNCREG                 				0xBF88
+#define FDMA2_CMD_MBOX_STAT_REG					0xBFC0
+#define FDMA2_CMD_MBOX_SET_REG					0xBFC4
+#define FDMA2_CMD_MBOX_CLR_REG					0xBFC8
+#define FDMA2_CMD_MBOX_MASK_REG 				0xBFCC
+
+#define FDMA2_INT_STAT_REG					0xBFD0
+#define FDMA2_INT_SET_REG					0xBFD4
+#define FDMA2_INT_CLR_REG					0xBFD8
+#define FDMA2_INT_MASK_REG					0xBFDC
+
+#define LINUX_FDMA_STB7100_IRQ_VECT			140
+#define LINUX_FDMA_STB7109_IRQ_VECT			LINUX_FDMA_STB7100_IRQ_VECT
+#define LINUX_FDMA0_STB7200_IRQ_VECT			ILC_IRQ(13)
+#define LINUX_FDMA1_STB7200_IRQ_VECT			ILC_IRQ(15)
+
+struct fdma_regs
+{
+	unsigned long fdma_id;
+	unsigned long fdma_ver;
+	unsigned long fdma_en;
+	unsigned long fdma_rev_id;
+	unsigned long fdma_cmd_statn;
+	unsigned long fdma_ptrn;
+	unsigned long fdma_cntn;
+	unsigned long fdma_saddrn;
+	unsigned long fdma_daddrn;
+	unsigned long fdma_req_ctln;
+	unsigned long fdma_cmd_sta;
+	unsigned long fdma_cmd_set;
+	unsigned long fdma_cmd_clr;
+	unsigned long fdma_cmd_mask;
+	unsigned long fdma_int_sta;
+	unsigned long fdma_int_set;
+	unsigned long fdma_int_clr;
+	unsigned long fdma_int_mask;
+	unsigned long fdma_sync_reg;
+	unsigned long fdma_clk_gate;
+	unsigned long fdma_imem_region;
+	unsigned long fdma_dmem_region;
+};
+
+struct fdma_fw {
+	unsigned long * data_reg;
+	unsigned long * imem_reg;
+	unsigned long imem_fw_sz;
+	unsigned long dmem_fw_sz;
+	unsigned long imem_len;
+	unsigned long dmem_len;
+};
+
+struct fdma_platform_device_data {
+	struct fdma_regs *registers_ptr;
+	int    min_ch_num;
+	int    max_ch_num;
+	char  * fw_device_name;
+	struct fdma_fw fw;
+	//struct fdma_dev *fd;
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/fdma-reqs.h linux-2.6.23.1-stm/include/linux/stm/fdma-reqs.h
--- linux-2.6.23.1/include/linux/stm/fdma-reqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/fdma-reqs.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+enum __stb7100_fdma_req_ids {
+	STB7100_FDMA_REQ_SPDIF_TEST =	0,
+	STB7100_FDMA_REQ_NOT_CONN_1,
+	STB7100_FDMA_REQ_NOT_CONN_2,
+	STB7100_FDMA_REQ_VIDEO_HDMI,
+	STB7100_FDMA_REQ_DISEQC_HALF_EMPTY,
+	STB7100_FDMA_REQ_DISEQC_HALF_FULL,
+	STB7100_FDMA_REQ_SH4_SCIF_RX,
+	STB7100_FDMA_REQ_SH4_SCIF_TX,
+	STB7100_FDMA_REQ_SSC_0_RX,
+	STB7100_FDMA_REQ_SSC_1_RX,
+	STB7100_FDMA_REQ_SSC_2_RX,	/* 10 */
+	STB7100_FDMA_REQ_SSC_0_TX,
+	STB7100_FDMA_REQ_SSC_1_TX,
+	STB7100_FDMA_REQ_SSC_2_TX,
+	STB7100_FDMA_REQ_UART_0_RX,
+	STB7100_FDMA_REQ_UART_1_RX,
+	STB7100_FDMA_REQ_UART_2_RX,
+	STB7100_FDMA_REQ_UART_3_RX,
+	STB7100_FDMA_REQ_UART_0_TX,
+	STB7100_FDMA_REQ_UART_1_TX,
+	STB7100_FDMA_REQ_UART_2_TX,	/* 20 */
+	STB7100_FDMA_REQ_UART_3_TX,
+	STB7100_FDMA_REQ_EXT_PIO_0,
+	STB7100_FDMA_REQ_EXT_PIO_1,
+	STB7100_FDMA_REQ_CPXM_DECRYPT,
+	STB7100_FDMA_REQ_CPXM_ENCRYPT,
+	STB7100_FDMA_REQ_PCM_0,
+	STB7100_FDMA_REQ_PCM_1,
+	STB7100_FDMA_REQ_PCM_READ,
+	STB7100_FDMA_REQ_SPDIF,
+	STB7100_FDMA_REQ_SWTS,		/* 30 */
+	STB7100_FDMA_REQ_UNUSED
+};
+
+enum __stb7109_fdma_reqids {
+	STB7109_FDMA_REQ_UNUSED =0,//0
+	STB7109_FDMA_DMA_REQ_HDMI_AVI,
+	STB7109_FDMA_REQ_DISEQC_HALF_EMPTY,
+	STB7109_FDMA_REQ_DISEQC_HALF_FULL,
+	STB7109_FDMA_REQ_SH4_SCIF_RX,
+	STB7109_FDMA_REQ_SH4_SCIF_TX,//5
+	STB7109_FDMA_REQ_SSC_0_RX,//6-8
+	STB7109_FDMA_REQ_SSC_1_RX,
+	STB7109_FDMA_REQ_SSC_2_RX,
+	STB7109_FDMA_REQ_SSC_0_TX,//9-11
+	STB7109_FDMA_REQ_SSC_1_TX,
+	STB7109_FDMA_REQ_SSC_2_TX,
+	STB7109_FDMA_REQ_UART_0_RX,//12-15
+	STB7109_FDMA_REQ_UART_1_RX,
+	STB7109_FDMA_REQ_UART_2_RX,
+	STB7109_FDMA_REQ_UART_3_RX,
+	STB7109_FDMA_REQ_UART_0_TX,//16-19
+	STB7109_FDMA_REQ_UART_1_TX,
+	STB7109_FDMA_REQ_UART_2_TX,
+	STB7109_FDMA_REQ_UART_3_TX,
+	STB7109_FDMA_REQ_REQ_EXT_PIO_0,//20
+	STB7109_FDMA_REQ_REQ_EXT_PIO_1,//21
+	STB7109_FDMA_REQ_CPXM_DECRYPT,
+	STB7109_FDMA_REQ_CPXM_ENCRYPT,
+	STB7109_FDMA_REQ_PCM_0=24,//24
+	STB7109_FDMA_REQ_PCM_1,
+	STB7109_FDMA_REQ_PCM_READ,
+	STB7109_FDMA_REQ_SPDIF,
+	STB7109_FDMA_REQ_SWTS_0,
+	STB7109_FDMA_REQ_SWTS_1,
+	STB7109_FDMA_REQ_SWTS_2
+};
+
+enum __stb7200_fdma_reqids {
+	STB7200_FDMA_REQ_CNT0 =0,
+	STB7200_FDMA_REQ_CNT1,
+	STB7200_FDMA_REQ_HDMI,
+	STB7200_FDMA_REQ_DISEQC0_TX_HALF_EMPTY,
+	STB7200_FDMA_REQ_DISEQC0_RX_HALF_FULL,
+	STB7200_FDMA_REQ_DISEQC1_TX_HALF_EMPTY,
+	STB7200_FDMA_REQ_DISEQC1_RX_HALF_FULL,
+	STB7200_FDMA_REQ_SH4_SCIF_RX,
+	STB7200_FDMA_REQ_SH4_SCIF_TX,
+	STB7200_FDMA_REQ_SSC_0_RX,
+	STB7200_FDMA_REQ_SSC_1_RX,//10
+	STB7200_FDMA_REQ_SSC_2_RX,
+	STB7200_FDMA_REQ_SSC_3_RX,
+	STB7200_FDMA_REQ_SSC_4_RX,
+	STB7200_FDMA_REQ_SSC_0_TX,
+	STB7200_FDMA_REQ_SSC_1_TX,
+	STB7200_FDMA_REQ_SSC_2_TX,
+	STB7200_FDMA_REQ_SSC_3_TX,
+	STB7200_FDMA_REQ_SSC_4_TX,//18
+	STB7200_FDMA_REQ_UART_0_RX,
+	STB7200_FDMA_REQ_UART_1_RX,
+	STB7200_FDMA_REQ_UART_2_RX,
+	STB7200_FDMA_REQ_UART_3_RX,
+	STB7200_FDMA_REQ_UART_0_TX,
+	STB7200_FDMA_REQ_UART_1_TX,
+	STB7200_FDMA_REQ_UART_2_TX,
+	STB7200_FDMA_REQ_UART_3_TX,
+	STB7200_FDMA_REQ_EMI_DMA0,
+	STB7200_FDMA_REQ_EMI_DMA1,
+	STB7200_FDMA_REQ_CPXM_DECRYPT_IN,
+	STB7200_FDMA_REQ_CPXM_DECRYPT_OUT,//30
+	STB7200_FDMA_REQ_CPXM_ENCRYPT_IN,
+	STB7200_FDMA_REQ_CPXM_ENCRYPT_OUT,
+	STB7200_FDMA_REQ_PCM0,
+	STB7200_FDMA_REQ_PCM1,
+	STB7200_FDMA_REQ_PCM2,
+	STB7200_FDMA_REQ_PCM3,
+	STB7200_FDMA_REQ_PCMIN,
+	STB7200_FDMA_REQ_SPDIF,
+	STB7200_FDMA_REQ_HDMI_PCM,
+	STB7200_FDMA_REQ_HDMI_SPDIF,
+	STB7200_FDMA_REQ_TELETEXT,
+	STB7200_FDMA_REQ_TELETEXT_SDOUT,
+	STB7200_FDMA_REQ_MODEM_PCM_PLAY,
+	STB7200_FDMA_REQ_MODEM_PCM_READ,
+	STB7200_FDMA_REQ_UHF_EMPTY,
+	STB7200_FDMA_REQ_UHF_FULL,
+	STB7200_FDMA_REQ_SRC_IP,
+	STB7200_FDMA_REQ_SRC_OP
+	/*49 - 54 reserved*/
+};
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/pio.h linux-2.6.23.1-stm/include/linux/stm/pio.h
--- linux-2.6.23.1/include/linux/stm/pio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/pio.h	2007-11-01 12:00:39.000000000 +0000
@@ -0,0 +1,64 @@
+/*
+ * include/linux/st_pio.h
+ *
+ * Copyright (c) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * ST40 General Purpose IO pins support.
+ *
+ * This layer enables other device drivers to configure PIO
+ * pins, get and set their values, and register an interrupt
+ * routine for when input pins change state.
+ */
+
+#ifndef _LINUX_ST_PIO_H_
+#define _LINUX_ST_PIO_H_ 1
+
+/*
+ * The ST40GX1 has two blocks of PIO registers:
+ *   3 in the ST40 core peripherals (PIO0 to PIO2)
+ *   2 in the ST20 legacy peripherals (comms block) (IO_PIO0 and IO_PIO1)
+ */
+#define STPIO_PIO_BANK(n) ((n)+0)
+#define STPIO_IO_PIO_BANK(n) ((n)+3)
+
+/* Pin configuration constants */
+/* Note that behaviour for modes 0, 6 and 7 differ between the ST40STB1
+ * datasheet (implementation restrictions appendix), and the ST40
+ * architectural defintions.
+ */
+#define STPIO_NONPIO		0	/* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1     	0	/* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR		1	/* Bidirectonal open-drain */
+#define STPIO_OUT		2	/* Output push-pull */
+/*efine STPIO_BIDIR		3	 * Bidirectional open drain */
+#define STPIO_IN		4	/* Input Hi-Z */
+/*efine STPIO_IN		5	 * Input Hi-Z */
+#define STPIO_ALT_OUT		6	/* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR		7	/* Alt bidir open drain (arch defn) */
+
+struct stpio_pin;
+
+/* Request and release exclusive use of a PIO pin */
+struct stpio_pin* stpio_request_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction);
+struct stpio_pin* stpio_request_set_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction, unsigned int value);
+void stpio_free_pin(struct stpio_pin* pin);
+
+/* Get, set value */
+void stpio_set_pin(struct stpio_pin* pin, unsigned int value);
+unsigned int stpio_get_pin(struct stpio_pin* pin);
+
+/* Change the mode of an existing pin */
+void stpio_configure_pin(struct stpio_pin* pin, int direction);
+
+/* Interrupt on external value change */
+void stpio_request_irq(struct stpio_pin* pin, int mode,
+		       void (*handler)(struct stpio_pin *pin, void *dev),
+		       void *dev);
+void stpio_free_irq(struct stpio_pin* pin);
+void stpio_enable_irq(struct stpio_pin* pin, int mode);
+void stpio_disable_irq(struct stpio_pin* pin);
+
+#endif /* _LINUX_ST_PIO_H_ */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/soc.h linux-2.6.23.1-stm/include/linux/stm/soc.h
--- linux-2.6.23.1/include/linux/stm/soc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/soc.h	2007-11-01 12:00:43.000000000 +0000
@@ -0,0 +1,126 @@
+#ifndef __LINUX_ST_SOC_H
+#define __LINUX_ST_SOC_H
+
+/* This is the private platform data for the ssc driver */
+struct plat_ssc_pio_t {
+	unsigned char sclbank;
+	unsigned char sclpin;
+	unsigned char sdoutbank;
+	unsigned char sdoutpin;
+	unsigned char sdinbank;
+	unsigned char sdinpin;
+};
+
+#define SSC_I2C_CAPABILITY  0x1
+#define SSC_SPI_CAPABILITY  0x2
+
+struct plat_ssc_data {
+	unsigned short		capability;	/* bitmask on the ssc capability */
+	struct plat_ssc_pio_t	*pio;		/* the PIO map */
+};
+
+/* Private data for the SATA driver */
+struct plat_sata_data {
+	unsigned long phy_init;
+	unsigned long pc_glue_logic_init;
+	unsigned int only_32bit;
+};
+
+/* Private data for the PWM driver */
+struct plat_stm_pwm_data {
+	unsigned long flags;
+};
+
+#define PLAT_STM_PWM_OUT0	(1<<0)
+#define PLAT_STM_PWM_OUT1	(1<<1)
+
+/* This is the private platform data for the lirc driver */
+struct lirc_pio {
+	unsigned int bank;
+	unsigned int pin;
+	unsigned int dir;
+        struct stpio_pin* pinaddr;
+};
+
+struct plat_lirc_data {
+	unsigned int irbclock;		/* IRB block clock (set to 0 for auto) */
+	unsigned int irbclkdiv;		/* IRB block clock divisor (set to 0 for auto) */
+	unsigned int irbperiodmult;	/* manual setting period multiplier */
+	unsigned int irbperioddiv;	/* manual setting period divisor */
+	unsigned int irbontimemult;	/* manual setting pulse period multiplier */
+	unsigned int irbontimediv;	/* manual setting pulse period divisor */
+	unsigned int irbrxmaxperiod;	/* maximum rx period in uS */
+	unsigned int irbversion;	/* IRB version type (1,2 or 3) */
+	unsigned int sysclkdiv;		/* factor to divide system bus clock by */
+	unsigned int rxpolarity;        /* flag to set gpio rx polarity (usually set to 1) */
+	unsigned int subcarrwidth;      /* Subcarrier width in percent - this is used to */
+					/* make the subcarrier waveform square after passing */
+					/* through the 555-based threshold detector on ST boards */
+	struct lirc_pio *pio_pin_arr;	/* PIO pin settings for driver */
+	unsigned int num_pio_pins;
+};
+
+/* Private data for the STM on-board ethernet driver */
+struct plat_stmmacenet_data {
+	int bus_id;
+	int pbl;
+	void (*fix_mac_speed)(void *priv, unsigned int speed);
+	void (*hw_setup)(void);
+	void *bsp_priv;
+};
+
+struct plat_stmmacphy_data {
+	int bus_id;
+	int phy_addr;
+	unsigned int phy_mask;
+	int interface;
+	int (*phy_reset)(void *priv);
+	void *priv;
+};
+
+struct plat_usb_data {
+	unsigned long ahb2stbus_wrapper_glue_base;
+	unsigned long ahb2stbus_protocol_base;
+	void (*power_up)(void* dev);
+	int initialised;
+	int port_number;
+};
+
+struct stasc_uart_data {
+	unsigned char pio_port;
+	unsigned char pio_pin[4]; /* Tx, Rx, CTS, RTS */
+};
+
+extern struct platform_device *asc_default_console_device;
+
+struct plat_sysconf_data {
+	int sys_device_offset;
+	int sys_sta_offset;
+	int sys_cfg_offset;
+};
+
+void stx7100_early_device_init(void);
+void stb7100_configure_asc(const int *ascs, int num_ascs, int console);
+void sysconf_early_init(struct platform_device *pdev);
+void stpio_early_init(struct platform_device *pdev, int num_pdevs);
+
+void stx7100_configure_sata(void);
+void stx7100_configure_pwm(struct plat_stm_pwm_data *data);
+void stx7100_configure_ssc(struct plat_ssc_data *data);
+void stx7100_configure_usb(void);
+void stx7100_configure_alsa(void);
+void stx7100_configure_ethernet(int rmii_mode, int ext_clk, int phy_bus);
+void stx7100_configure_lirc(void);
+void stx7100_configure_pata(int bank, int irq);
+
+void stx7200_early_device_init(void);
+void stx7200_configure_asc(const int *ascs, int num_ascs, int console);
+
+void stx7200_configure_pwm(struct plat_stm_pwm_data *data);
+void stx7200_configure_ssc(struct plat_ssc_data *data);
+void stx7200_configure_usb(void);
+void stx7200_configure_ethernet(int mac, int rmii_mode, int ext_clk,
+				int phy_bus);
+void stx7200_configure_lirc(void);
+
+#endif /* __LINUX_ST_SOC_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/soc_init.h linux-2.6.23.1-stm/include/linux/stm/soc_init.h
--- linux-2.6.23.1/include/linux/stm/soc_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/soc_init.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,99 @@
+
+#define STPIO_DEVICE(_id, _base, _irq)					\
+{									\
+	.name		= "stpio",					\
+	.id		= _id,						\
+	.num_resources	= 2,						\
+	.resource	= (struct resource[]) {				\
+		{							\
+			.start	= _base,				\
+			.end	= _base + 0x100,			\
+			.flags	= IORESOURCE_MEM			\
+		}, {							\
+			.start	= _irq,					\
+			.flags	= IORESOURCE_IRQ			\
+		}							\
+	},								\
+}
+
+
+#define STASC_DEVICE(_base, _irq, _pio_port, _ptx, _prx, _pcts, _prts)	\
+{									\
+	.name		= "stasc",					\
+	.num_resources	= 2,						\
+	.resource	= (struct resource[]) {				\
+		{							\
+			.start	= _base,				\
+			.end	= _base + 0x100,			\
+			.flags	= IORESOURCE_MEM			\
+		}, {							\
+			.start	= _irq,					\
+			.flags	= IORESOURCE_IRQ			\
+		}							\
+	},								\
+	.dev = {							\
+		.platform_data = &(struct stasc_uart_data) {		\
+			.pio_port	= _pio_port,			\
+			.pio_pin	= { _ptx, _prx, _pcts, _prts },	\
+		}							\
+	}								\
+}
+
+#define USB_WRAPPER(_port, _wrapper_base, _protocol_base)	\
+{								\
+	.ahb2stbus_wrapper_glue_base = _wrapper_base,		\
+	.ahb2stbus_protocol_base = _protocol_base,		\
+	.power_up = usb_power_up,				\
+	.initialised = 0,					\
+	.port_number = _port,					\
+}
+
+
+#define USB_EHCI_DEVICE(_port, _base, _irq)				\
+{									\
+	.name = "ST40-ehci",						\
+	.id=_port,							\
+	.dev = {							\
+		.dma_mask = &st40_dma_mask,				\
+		.coherent_dma_mask = 0xffffffful,			\
+		.platform_data = &usb_wrapper[_port],			\
+	},								\
+	.num_resources = 2,						\
+	.resource = (struct resource[]) {				\
+		[0] = {							\
+			.start = _base,					\
+			.end   = _base + 0xff,				\
+			.flags = IORESOURCE_MEM,			\
+		},							\
+		[1] = {							\
+			.start = _irq,					\
+			.end   = _irq,					\
+			.flags = IORESOURCE_IRQ,			\
+		},							\
+	},								\
+}									\
+
+
+#define USB_OHCI_DEVICE(_port, _base, _irq)				\
+{									\
+	.name = "ST40-ohci",						\
+	.id=_port,							\
+	.dev = {							\
+		.dma_mask = &st40_dma_mask,				\
+		.coherent_dma_mask = 0xffffffful,			\
+		.platform_data = &usb_wrapper[_port],			\
+	},								\
+	.num_resources = 2,						\
+	.resource = (struct resource[]) {				\
+		[0] = {							\
+			.start = _base,					\
+			.end   = _base + 0xff,				\
+			.flags = IORESOURCE_MEM,			\
+		},							\
+		[1] = {							\
+			.start = _irq,					\
+			.end   = _irq,					\
+			.flags = IORESOURCE_IRQ,			\
+		}							\
+	}								\
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/stm-dma.h linux-2.6.23.1-stm/include/linux/stm/stm-dma.h
--- linux-2.6.23.1/include/linux/stm/stm-dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/stm-dma.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2005,7 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#ifndef STM_DMA_H
+#define STM_DMA_H
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/string.h>
+#include <linux/module.h>
+
+
+/*DMA Modes */
+#define MODE_FREERUNNING   		0x01	/* FDMA, GPDMA */
+#define MODE_PACED  		 	0x02	/* FDMA */
+#define MODE_SRC_SCATTER		0x04
+#define MODE_DST_SCATTER		0x05
+
+/* DMA dimensions */
+#define DIM_SRC_SHIFT 0
+#define DIM_DST_SHIFT 2
+#define DIM_SRC(x) (((x) >> DIM_SRC_SHIFT) & 3)
+#define DIM_DST(x) (((x) >> DIM_DST_SHIFT) & 3)
+enum stm_dma_dimensions {
+	DIM_0_x_0 = (0 << DIM_SRC_SHIFT) | (0 << DIM_DST_SHIFT),
+	DIM_0_x_1 = (0 << DIM_SRC_SHIFT) | (1 << DIM_DST_SHIFT),
+	DIM_0_x_2 = (0 << DIM_SRC_SHIFT) | (2 << DIM_DST_SHIFT),
+	DIM_1_x_0 = (1 << DIM_SRC_SHIFT) | (0 << DIM_DST_SHIFT),
+	DIM_1_x_1 = (1 << DIM_SRC_SHIFT) | (1 << DIM_DST_SHIFT),
+	DIM_1_x_2 = (1 << DIM_SRC_SHIFT) | (2 << DIM_DST_SHIFT),
+	DIM_2_x_0 = (2 << DIM_SRC_SHIFT) | (0 << DIM_DST_SHIFT),
+	DIM_2_x_1 = (2 << DIM_SRC_SHIFT) | (1 << DIM_DST_SHIFT),
+	DIM_2_x_2 = (2 << DIM_SRC_SHIFT) | (2 << DIM_DST_SHIFT),
+};
+
+enum stm_dma_flags {
+	STM_DMA_INTER_NODE_PAUSE=0x800,
+	STM_DMA_NODE_COMP_INT=0x1000,
+	STM_DMA_CB_CONTEXT_ISR=0x2000,
+	STM_DMA_CB_CONTEXT_TASKLET=0x4000,
+	STM_DMA_CHANNEL_PAUSE_FLUSH=0x20000,
+	STM_DMA_CHANNEL_PAUSE_NOFLUSH=0x40000,
+	STM_DMA_NOBLOCK_MODE=0x80000,
+	STM_DMA_BLOCK_MODE=0x100000,
+	STM_DMA_LIST_CIRC=0x200000,
+	STM_DMA_LIST_OPEN=0x400000,
+};
+
+#define DMA_CHANNEL_STATUS_IDLE 		0
+#define DMA_CHANNEL_STATUS_RUNNING 		2
+#define DMA_CHANNEL_STATUS_PAUSED 		3
+
+/* Parameters to request_dma_bycap() */
+#define STM_DMAC_ID 			"fdma_dmac"
+#define STM_DMA_CAP_HIGH_BW		"STM_DMA_HIGH_BANDWIDTH"
+#define STM_DMA_CAP_LOW_BW		"STM_DMA_LOW_BANDWIDTH"
+#define STM_DMA_CAP_ETH_BUF		"STM_DMA_ETH_BUFFER"
+
+/* dma_extend() operations */
+#define STM_DMA_OP_PAUSE			1
+#define STM_DMA_OP_UNPAUSE			2
+#define STM_DMA_OP_STOP				3
+#define STM_DMA_OP_COMPILE			4
+#define STM_DMA_OP_STATUS			5
+#define STM_DMA_OP_PACING			7
+
+/* Generic DMA request line configuration */
+
+/* Read/Write */
+#define REQ_CONFIG_READ            0
+#define REQ_CONFIG_WRITE           1
+
+/* Opcodes */
+#define REQ_CONFIG_OPCODE_1        0x00
+#define REQ_CONFIG_OPCODE_2        0x01
+#define REQ_CONFIG_OPCODE_4        0x02
+#define REQ_CONFIG_OPCODE_8        0x03
+#define REQ_CONFIG_OPCODE_16       0x04
+#define REQ_CONFIG_OPCODE_32       0x05
+
+struct stm_dma_req_config
+{
+	unsigned char req_line;		/* Request line index number */
+	unsigned char rw;		/* Access type: Read or Write */
+	unsigned char opcode;		/* Size of word access */
+	unsigned char count;		/* Number of transfers per request */
+	unsigned char increment;	/* Whether to increment */
+	unsigned char hold_off;		/* Holdoff value between req signal samples (in clock cycles)*/
+	unsigned char initiator;	/* Which STBus initiatator to use */
+};
+
+struct stm_dma_req;
+
+/* Generic STM DMA params */
+
+struct stm_dma_params;
+
+struct params_ops {
+	int (*free_params)(struct stm_dma_params* params);
+};
+
+struct stm_dma_params {
+
+	/* Transfer mode eg MODE_DST_SCATTER */
+	unsigned long mode;
+
+	/* a pointer to a callback function of type void foo(void*)
+	 * which will be called on completion of the entire
+	 * transaction or after each transfer suceeds if
+	 * NODE_PAUSE_ISR is specifed */
+	void				(*comp_cb)(unsigned long);
+	unsigned long			comp_cb_parm;
+
+	/* a pointer to a callback function of type void foo(void*)
+	 * which will be called upon failure of a transfer or
+	 * transaction*/
+	void				(*err_cb)(unsigned long);
+	unsigned long			err_cb_parm;
+
+	/*Source location line stride for use in 0/1/2 x 2D modes*/
+	unsigned long			sstride;
+
+	/*Source location line stride for use in 2D x 0/1/2 modes*/
+	unsigned long			dstride;
+
+	/* Line length for any 2D modes */
+	unsigned long			line_len;
+
+	/*source addr - given in phys*/
+	unsigned long 			sar;
+
+	/*dest addr  - given in phys*/
+	unsigned long 			dar;
+
+	unsigned long 			node_bytes;
+
+	struct scatterlist * srcsg;
+	struct scatterlist * dstsg;
+	int sglen;
+
+	int err_cb_isr	:1;
+	int comp_cb_isr	:1;
+
+	int node_pause		:1;
+	int node_interrupt	:1;
+	int circular_llu        :1;
+
+	unsigned long dim;
+
+	/* Parameters for paced transfers */
+	struct stm_dma_req *req;
+
+	/* Pointer to compiled parameters
+	 * this includes the *template* llu node and
+	 * its assoc'd memory */
+	void* priv;
+
+	/* Next pointer for linked list of params */
+	struct stm_dma_params *next;
+
+	/* Pointer to DMAC specific operators on the parameters.
+	 * Filled in by dma_compile_list(). */
+	struct params_ops *params_ops;
+	void* params_ops_priv;
+
+	/* This is only used in the call to dma_compile_list(), so
+	 * shouldn't really be here, but it saves us packing and unpacking
+	 * the parameters into another struct. */
+	gfp_t context;
+};
+
+static inline void dma_params_init(struct stm_dma_params * p,
+				  unsigned long mode,
+				  unsigned long list_type)
+{
+	memset(p,0,sizeof(struct stm_dma_params));
+	p->mode = mode;
+	p->circular_llu = (STM_DMA_LIST_CIRC ==list_type ?1:0);
+};
+
+static inline int dma_get_status(unsigned int chan)
+{
+	return dma_extend(chan,STM_DMA_OP_STATUS,NULL);
+}
+
+static inline int dma_pause_channel(unsigned int chan)
+{
+	return dma_extend(chan, STM_DMA_OP_PAUSE,NULL);
+}
+
+static inline void dma_unpause_channel(unsigned int chan)
+{
+	dma_extend(chan, STM_DMA_OP_UNPAUSE, NULL);
+}
+
+static inline int dma_stop_channel(unsigned int chan)
+{
+	return dma_extend(chan, STM_DMA_OP_STOP, NULL);
+}
+
+static inline int dma_params_free(struct stm_dma_params *params)
+{
+	return params->params_ops->free_params(params);
+}
+
+static inline int dma_compile_list(unsigned int chan,
+				   struct stm_dma_params *params,
+				   gfp_t gfp_mask)
+{
+	params->context = gfp_mask;
+	return dma_extend(chan, STM_DMA_OP_COMPILE, params);
+}
+
+static inline int dma_xfer_list(unsigned int chan, struct stm_dma_params * p)
+{
+	/*TODO :- this is a bit 'orrible -
+	 * should really extend arch/sh/drivers/dma/dma-api.c
+	 * to include a 'set_dma_channel'*/
+	dma_configure_channel(chan, (unsigned long)p);
+	return dma_xfer(chan,0,0,0,0);
+}
+
+static inline struct stm_dma_req *dma_req_config(unsigned int chan,
+	unsigned int req_line,
+	struct stm_dma_req_config* req_config)
+{
+	req_config->req_line = req_line;
+	return (struct stm_dma_req *)dma_extend(chan, STM_DMA_OP_PACING, req_config);
+}
+
+static inline  void dma_params_sg(	struct stm_dma_params *p,
+					struct scatterlist * sg,
+					int nents)
+{
+	if(MODE_SRC_SCATTER==p->mode)
+		p->srcsg=sg;
+	else if (MODE_DST_SCATTER==p->mode)
+		p->dstsg = sg;
+	else
+		BUG();
+	p->sglen = nents;
+}
+
+static inline void dma_params_link(	struct stm_dma_params * parent,
+					struct stm_dma_params * child)
+{
+	parent->next=child;
+}
+
+static inline void dma_params_req(	struct stm_dma_params *p,
+					struct stm_dma_req *req)
+{
+	p->req = req;
+}
+
+static inline void dma_params_addrs(	struct stm_dma_params *p,
+					unsigned long src,
+					unsigned long dst,
+					unsigned long bytes)
+{
+	p->sar = src;
+	p->dar = dst;
+	p->node_bytes = bytes;
+}
+
+static inline void dma_params_interrupts(struct stm_dma_params *p,
+					unsigned long isrflag)
+{
+	if(isrflag & STM_DMA_INTER_NODE_PAUSE)
+		p->node_pause=1;
+	if(isrflag & STM_DMA_NODE_COMP_INT )
+		p->node_interrupt=1;
+
+}
+
+static inline void dma_params_comp_cb(	struct stm_dma_params *p,
+					void (*fn)(unsigned long param),
+					unsigned long param,
+					int isr_context)
+{
+	p->comp_cb = fn;
+	p->comp_cb_parm = param;
+	p->comp_cb_isr = (isr_context == STM_DMA_CB_CONTEXT_ISR ?1:0);
+}
+
+static inline void dma_params_err_cb(	struct stm_dma_params *p,
+					void (*fn)(unsigned long param),
+	      				unsigned long param,
+	      				int isr_context)
+{
+	p->err_cb = fn;
+	p->err_cb_parm = param;
+	p->err_cb_isr = (isr_context == STM_DMA_CB_CONTEXT_ISR ?1:0);
+}
+
+static inline void dma_params_dim(	struct stm_dma_params *p,
+					unsigned long line_len,
+					unsigned long sstride,
+					unsigned long dstride,
+					unsigned long dim)
+{
+	p->line_len = line_len;
+	p->sstride = sstride;
+	p->dstride = dstride;
+	p->dim =dim;
+}
+
+static inline void dma_params_DIM_0_x_0(struct stm_dma_params *p)
+{
+	dma_params_dim(p, 0,0,0, DIM_0_x_0);
+}
+
+static inline void dma_params_DIM_0_x_1(struct stm_dma_params *p)
+{
+	dma_params_dim(p, 0,0,0, DIM_0_x_1);
+}
+
+static inline void dma_params_DIM_0_x_2(struct stm_dma_params *p,
+					unsigned long line_len,
+					unsigned long dstride)
+{
+	dma_params_dim(p, line_len, 0, dstride, DIM_0_x_2);
+}
+
+static inline void dma_params_DIM_1_x_0(struct stm_dma_params *p)
+{
+	dma_params_dim(p, 0,0,0, DIM_1_x_0);
+}
+
+static inline void dma_params_DIM_1_x_1(struct stm_dma_params *p)
+{
+	dma_params_dim(p, 0,0,0, DIM_1_x_1);
+}
+
+static inline void dma_params_DIM_1_x_2(struct stm_dma_params *p,
+					unsigned long line_len,
+					unsigned long dstride)
+{
+	dma_params_dim(p, line_len, line_len, dstride, DIM_1_x_2);
+}
+
+static inline void dma_params_DIM_2_x_0(struct stm_dma_params *p,
+					unsigned long line_len,
+					unsigned long sstride)
+{
+	dma_params_dim(p, line_len, sstride, 0, DIM_2_x_0);
+}
+
+static inline void dma_params_DIM_2_x_1(struct stm_dma_params *p,
+					unsigned long line_len,
+					unsigned long sstride)
+{
+	dma_params_dim(p, line_len, sstride, line_len, DIM_2_x_1);
+}
+#endif
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/stm/sysconf.h linux-2.6.23.1-stm/include/linux/stm/sysconf.h
--- linux-2.6.23.1/include/linux/stm/sysconf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/stm/sysconf.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+struct sysconf_field;
+
+/**
+ * sysconf_claim - Claim ownership of a field of a sysconfig register
+ * @regtype: SYS_STA or SYS_CFG
+ * @regnum: the sysconfig register number
+ * @lsb: the LSB of the register we are claiming
+ * @msb: the MSB of the register we are claiming
+ * @dev: device claiming the field
+ *
+ * This function claims ownership of a field from a sysconfig register.
+ * The part of the sysconfig register being claimed is from bit @lsb
+ * through to bit @msb inclusive. To claim the whole register, @lsb
+ * should be 0, @msb 31 (or 63 for systems with 64 bit sysconfig registers).
+ *
+ * It returns a &struct sysconf_field which can be used in subsequent
+ * operations on this field.
+ */
+struct sysconf_field* sysconf_claim(int regtype, int regnum, int lsb, int msb,
+				    const char* dev);
+
+/**
+ * sysconf_write - Write a value into a field of a sysconfig register
+ * @field: the sysconfig field to write to
+ * @value: the value to write into the field
+ *
+ * This writes @value into the field of the sysconfig register @field.
+ * @field must have been claimed using sysconf_claim().
+ */
+void sysconf_write(struct sysconf_field *field, u64 value);
+
+/**
+ * sysconf_read - Read a field of a sysconfig register
+ * @field: the sysconfig field to read
+ *
+ * This reads a field of the sysconfig register @field.
+ * @field must have been claimed using sysconf_claim().
+ */
+u64 sysconf_read(struct sysconf_field *field);
+
+#define SYS_DEV 0
+#define SYS_STA 1
+#define SYS_CFG 2
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/include/linux/sysctl.h linux-2.6.23.1-stm/include/linux/sysctl.h
--- linux-2.6.23.1/include/linux/sysctl.h	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/include/linux/sysctl.h	2007-11-01 12:00:41.000000000 +0000
@@ -165,6 +165,7 @@
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
+	KERN_FBSPLASH=77,	/* string: path to fbsplash helper */
 };
 
 
diff -x .gitignore -Nurp linux-2.6.23/init/do_mounts_rd.c linux-2.6.23-squashfs3.3/init/do_mounts_rd.c
--- linux-2.6.23/init/do_mounts_rd.c	2007-10-09 21:31:38.000000000 +0100
+++ linux-2.6.23-squashfs3.3/init/do_mounts_rd.c	2007-11-01 05:06:25.000000000 +0000
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@ static int __init crd_load(int in_fd, in
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ *      squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@ identify_ramdisk_image(int fd, int start
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@ identify_ramdisk_image(int fd, int start
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,18 @@ identify_ramdisk_image(int fd, int start
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+		       "RAMDISK: squashfs filesystem found at block %d\n",
+		       start_block);
+		if (squashfsb->s_major < 3)
+			nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		else
+			nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/kernel/sysctl.c linux-2.6.23.1-stm/kernel/sysctl.c
--- linux-2.6.23.1/kernel/sysctl.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/kernel/sysctl.c	2007-11-01 12:00:41.000000000 +0000
@@ -89,6 +89,9 @@
 #ifdef CONFIG_KMOD
 extern char modprobe_path[];
 #endif
+#ifdef CONFIG_FB_SPLASH
+extern char fbsplash_path[];
+#endif
 #ifdef CONFIG_CHR_DEV_SG
 extern int sg_big_buff;
 #endif
@@ -485,6 +488,17 @@
 		.strategy	= &sysctl_string,
 	},
 #endif
+#ifdef CONFIG_FB_SPLASH
+	{
+		.ctl_name	= KERN_FBSPLASH,
+		.procname	= "fbsplash",
+		.data		= &fbsplash_path,
+		.maxlen		= KMOD_PATH_LEN,
+		.mode		= 0644,
+		.proc_handler	= &proc_dostring,
+		.strategy	= &sysctl_string,
+	},
+#endif
 #ifdef CONFIG_CHR_DEV_SG
 	{
 		.ctl_name	= KERN_SG_BIG_BUFF,
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/mm/Makefile linux-2.6.23.1-stm/mm/Makefile
--- linux-2.6.23.1/mm/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/mm/Makefile	2007-11-01 12:00:41.000000000 +0000
@@ -29,4 +29,5 @@
 obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_SMP) += allocpercpu.o
 obj-$(CONFIG_QUICKLIST) += quicklist.o
+obj-$(CONFIG_BPA2) += bpa2.o
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/mm/Kconfig linux-2.6.23.1-stm/mm/Kconfig
--- linux-2.6.23.1/mm/Kconfig
+++ linux-2.6.23.1-stm/mm/Kconfig
@@ -177,3 +177,14 @@ config NR_QUICK
 config VIRT_TO_BUS
 	def_bool y
 	depends on !ARCH_NO_VIRT_TO_BUS
+
+config BPA2
+	bool "Big Physical Area version 2"
+	---help---
+	  Enables kernel support for reserving large areas of physical
+	  memory at boot-time for use by certain device drivers (such as
+	  video framegrabbers, etc.) which require it. This is backwards
+	  compatible wit the origional "Big Physical Area" API,
+	  but with extensions for multiple areas. It can also be configured
+	  from the architecture specific setup code.
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/mm/bootmem.c linux-2.6.23.1-stm/mm/bootmem.c
--- linux-2.6.23.1/mm/bootmem.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/mm/bootmem.c	2007-11-01 12:00:40.000000000 +0000
@@ -19,6 +19,8 @@
 
 #include "internal.h"
 
+#define CONFIG_DEBUG_BOOTMEM
+
 /*
  * Access to this subsystem has to be serialized externally. (this is
  * true for the boot process anyway)
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/mm/bpa2.c linux-2.6.23.1-stm/mm/bpa2.c
--- linux-2.6.23.1/mm/bpa2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/mm/bpa2.c	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,580 @@
+/*
+ * Copyright (c) 2007 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Derived from mm/bigphysarea.c which was:
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?)
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/ptrace.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/pfn.h>
+#include <linux/bpa2.h>
+
+struct range {
+	struct range *next;
+	unsigned long base;			/* base of allocated block */
+	unsigned long size;			/* size in bytes */
+};
+
+struct bpa2_part {
+	char res_name[20];
+	struct resource res;
+	const char* name;
+	const char** aka;
+	struct range *free_list;
+	struct range *used_list;
+	struct range initial_free_list;
+	int low_mem;
+	struct list_head next;
+};
+
+static LIST_HEAD(bpa2_parts);
+static struct bpa2_part *bpa2_bigphysarea_part;
+static DEFINE_SPINLOCK(bpa2_lock);
+
+static void __init bpa2_init_failure(struct bpa2_part* bp, const char* msg)
+{
+	printk(KERN_ERR "bpa2: %s ignored: %s\n", bp->res_name, msg);
+}
+
+static int __init bpa2_alloc_low(struct bpa2_part* bp)
+{
+	void* addr;
+	unsigned long size = bp->res.end - bp->res.start + 1;
+
+	addr = alloc_bootmem_low_pages(size);
+	if (addr == NULL) {
+		bpa2_init_failure(bp, "could not allocate");
+		return 0;
+	}
+
+	bp->res.start = virt_to_phys(addr);
+	bp->res.end = virt_to_phys(addr) + size - 1;
+	bp->low_mem = 1;
+
+	return 1;
+}
+
+static int __init bpa2_init_low(struct bpa2_part* bp)
+{
+	void* addr;
+	unsigned long size = bp->res.end - bp->res.start + 1;
+
+	/* Can't use reserve_bootmem() because there is no return code to
+	 * indicate success or failure. So use __alloc_bootmem_core(),
+	 * specifying a goal, which must be available. */
+	addr = __alloc_bootmem_core(NODE_DATA(0)->bdata, size, PAGE_SIZE,
+				    bp->res.start, 0);
+
+	if (addr != phys_to_virt(bp->res.start)) {
+		bpa2_init_failure(bp, "could not allocate");
+		if (addr) {
+			free_bootmem((unsigned long)addr, size);
+		}
+		return 0;
+	}
+
+	bp->low_mem = 1;
+
+	return 1;
+}
+
+static int __init bpa2_init_ext(struct bpa2_part* bp)
+{
+	return 1;
+}
+
+/**
+ * bpa2_init - initialize bpa2 partitions
+ * @partdescs: description of the partitions
+ * @nparts: number of partitions
+ *
+ * This function initialises the bpa2 internal data structures
+ * based on the partition descriptions which are passed in.
+ *
+ * This must be called from early in the platform initialisation
+ * sequence, while bootmem is still active.
+ */
+void __init bpa2_init(struct bpa2_partition_desc* partdescs, int nparts)
+{
+	struct bpa2_part *new_parts;
+	struct bpa2_part* bp;
+
+	new_parts = alloc_bootmem(sizeof(*new_parts) * nparts);
+	if (! new_parts) {
+		printk(KERN_ERR "bpa2: could not allocate part table\n");
+		return;
+	}
+
+	bp = new_parts;
+	for ( ; nparts; nparts--) {
+		unsigned long start_pfn, end_pfn;
+		struct range *free_list = &bp->initial_free_list;
+		int ok;
+
+		start_pfn = PFN_UP(partdescs->start);
+		end_pfn = PFN_DOWN(partdescs->start + partdescs->size);
+
+		snprintf(bp->res_name, sizeof(bp->res_name),
+			 "BPA2 (%s)", partdescs->name);
+		bp->res.name = bp->res_name;
+		bp->res.start = PFN_PHYS(start_pfn);
+		bp->res.end = PFN_PHYS(end_pfn) - 1;
+		bp->res.flags = IORESOURCE_BUSY | IORESOURCE_MEM;
+		bp->name = partdescs->name;
+		bp->aka = partdescs->aka;
+
+		if (partdescs->start == 0) {
+			ok = bpa2_alloc_low(bp);
+		} else if ((start_pfn >= min_low_pfn) && (end_pfn <= max_low_pfn)) {
+			ok = bpa2_init_low(bp);
+		} else if ((start_pfn > max_low_pfn) || (end_pfn > min_low_pfn)) {
+			ok = bpa2_init_ext(bp);
+		} else {
+			bpa2_init_failure(bp, "spans low memory boundary");
+			ok = 0;
+		}
+
+		if (!ok)
+			continue;
+
+		if (insert_resource(&iomem_resource, &bp->res)) {
+			bpa2_init_failure(bp, "could not reserve");
+			continue;
+		}
+
+		free_list->next = NULL;
+		free_list->base = bp->res.start;
+		free_list->size = (bp->res.end + 1) - bp->res.start;
+		bp->free_list = free_list;
+
+		list_add_tail(&bp->next, &bpa2_parts);
+
+		bp++;
+		partdescs++;
+	}
+
+	if (bpa2_bigphysarea_part == NULL) {
+		bp = bpa2_find_part("bigphysarea");
+
+		if (bp->low_mem) {
+			bpa2_bigphysarea_part = bp;
+		} else {
+			/* Should rate limit this I suppose */
+			printk(KERN_ERR "bpa2: bigphysarea not in logical memory\n");
+		}
+	}
+}
+
+static int __init bpa2_setup(char *str)
+{
+	int par;
+	struct bpa2_partition_desc partdesc = {
+		.name   = "bigphysarea",
+		.start  = 0,
+		.size   = 0,
+		.flags  = 0,
+		.aka    = NULL,
+	};
+
+	if (get_option(&str,&par) == 0)
+                return -EINVAL;
+
+	partdesc.size = par << PAGE_SHIFT;
+	bpa2_init(&partdesc, 1);
+
+	return 1;
+}
+__setup("bigphysarea=", bpa2_setup);
+
+/**
+ * bpa2_find_part - find a bpa2 partition based on its name
+ * @name: name of the partition to find
+ *
+ * Return the bpa2 partition corrisponding to the requested name.
+ */
+struct bpa2_part* bpa2_find_part(const char* name)
+{
+	struct bpa2_part* bp;
+	const char** p;
+
+	list_for_each_entry(bp, &bpa2_parts, next) {
+		if (! strcmp(bp->name, name))
+			return bp;
+		if (bp->aka) {
+			for (p=bp->aka; *p; p++) {
+				if (! strcmp(*p, name))
+					return bp;
+			}
+		}
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(bpa2_find_part);
+
+/**
+ * bpa2_low_part - return whether a partition resides in low memory
+ * @part: partition to query
+ *
+ * Return whether the specified patrition resides in low (that is,
+ * kernel logical) memory. If it does, then functions such as
+ * phys_to_virt() can be used to convert the allocated memory into
+ * a virtual address which can be directly dereferenced.
+ *
+ * If this is not true, then the region will not be mapped into
+ * the kernel's address space, and so if access is required it will
+ * need to be mapped using ioremap() and accessed using readl() etc.
+ */
+int bpa2_low_part(struct bpa2_part* part)
+{
+	return part->low_mem;
+}
+EXPORT_SYMBOL(bpa2_low_part);
+
+/**
+ * bpa2_alloc_pages - allocate pages from a bpa2 partition
+ * @bp: partition to allocate from
+ * @count: number of pages to allocate
+ * @align: required alinment
+ * @priority: GFP_* flags to use
+ *
+ * Allocate `count' pages from the partition. Pages are aligned to
+ * a multiple of `align'. `priority' has the same meaning in kmalloc, and
+ * is used for partition management information, it does not influence the
+ * memory returned.
+ *
+ *
+ *
+ * This function may not be called from an interrupt.
+ */
+unsigned long bpa2_alloc_pages(struct bpa2_part* bp, int count, int align, int priority)
+{
+	struct range *range, **range_ptr, *new_range, *align_range;
+	unsigned long aligned_base=0;
+
+	new_range   = NULL;
+	align_range = NULL;
+
+	if (align == 0)
+		align = PAGE_SIZE;
+	else
+		align = align * PAGE_SIZE;
+
+	spin_lock(&bpa2_lock);
+
+	/*
+	 * Search a free block which is large enough, even with alignment.
+	 */
+	range_ptr = &bp->free_list;
+	while (*range_ptr != NULL) {
+		range = *range_ptr;
+		aligned_base = ((range->base + align - 1) / align) * align;
+		if (aligned_base + count * PAGE_SIZE <=
+		    range->base + range->size)
+			break;
+	     range_ptr = &range->next;
+	}
+	if (*range_ptr == NULL)
+		goto fail;
+	range = *range_ptr;
+	/*
+	 * When we have to align, the pages needed for alignment can
+	 * be put back to the free pool.
+	 * We check here if we need a second range data structure later
+	 * and allocate it now, so that we don't have to check for a
+	 * failed kmalloc later.
+	 */
+	if (aligned_base - range->base + count * PAGE_SIZE < range->size) {
+		new_range = kmalloc(sizeof(struct range), priority);
+		if (new_range == NULL)
+			goto fail;
+	}
+	if (aligned_base != range->base) {
+		align_range = kmalloc(sizeof(struct range), priority);
+		if (align_range == NULL) {
+			if (new_range != NULL)
+				kfree(new_range);
+			goto fail;
+		}
+		align_range->base = range->base;
+		align_range->size = aligned_base - range->base;
+		range->base = aligned_base;
+		range->size -= align_range->size;
+		align_range->next = range;
+		*range_ptr = align_range;
+		range_ptr = &align_range->next;
+	}
+	if (new_range != NULL) {
+		/*
+		 * Range is larger than needed, create a new list element for
+		 * the used list and shrink the element in the free list.
+		 */
+		new_range->base        = range->base;
+		new_range->size        = count * PAGE_SIZE;
+		range->base = new_range->base + new_range->size;
+		range->size = range->size - new_range->size;
+	} else {
+		/*
+		 * Range fits perfectly, remove it from free list.
+		 */
+		*range_ptr = range->next;
+		new_range = range;
+	}
+	/*
+	 * Insert block into used list
+	 */
+	new_range->next = bp->used_list;
+	bp->used_list = new_range;
+
+	spin_unlock(&bpa2_lock);
+
+	return new_range->base;
+
+fail:
+	spin_unlock(&bpa2_lock);
+	return 0;
+}
+EXPORT_SYMBOL(bpa2_alloc_pages);
+
+/**
+ * bpa2_free_pages - free pages allocated from a bpa2 partition
+ * @bp: partition to free pages back to
+ * @base:
+ * @align: required alinment
+ * @priority: GFP_* flags to use
+ *
+ * Free pages allocated with `bigphysarea_alloc_pages'. `base' must be an
+ * address returned by `bigphysarea_alloc_pages'.
+ * This function my not be called from an interrupt!
+ */
+void bpa2_free_pages(struct bpa2_part* bp, unsigned long base)
+{
+	struct range *prev, *next, *range, **range_ptr;
+
+	spin_lock(&bpa2_lock);
+
+	/*
+	 * Search the block in the used list.
+	 */
+	for (range_ptr = &bp->used_list;
+	     *range_ptr != NULL;
+	     range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base == base)
+			break;
+	if (*range_ptr == NULL) {
+		printk("%s: 0x%08x, not allocated!\n", __FUNCTION__,
+		       (unsigned)base);
+		spin_unlock(&bpa2_lock);
+		return;
+	}
+	range = *range_ptr;
+	/*
+	 * Remove range from the used list:
+	 */
+	*range_ptr = (*range_ptr)->next;
+	/*
+	 * The free-list is sorted by address, search insertion point
+	 * and insert block in free list.
+	 */
+	for (range_ptr = &bp->free_list, prev = NULL;
+	     *range_ptr != NULL;
+	     prev = *range_ptr, range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base >= base)
+			break;
+	range->next  = *range_ptr;
+	*range_ptr   = range;
+	/*
+	 * Concatenate free range with neighbors, if possible.
+	 * Try for upper neighbor (next in list) first, then
+	 * for lower neighbor (predecessor in list).
+	 */
+	if (range->next != NULL &&
+	    range->base + range->size == range->next->base) {
+		next = range->next;
+		range->size += range->next->size;
+		range->next = next->next;
+		if (next != &bp->initial_free_list)
+			kfree(next);
+	}
+	if (prev != NULL &&
+	    prev->base + prev->size == range->base) {
+		prev->size += prev->next->size;
+		prev->next = range->next;
+		if (range != &bp->initial_free_list)
+			kfree(range);
+	}
+	spin_unlock(&bpa2_lock);
+}
+EXPORT_SYMBOL(bpa2_free_pages);
+
+caddr_t	bigphysarea_alloc_pages(int count, int align, int priority)
+{
+	unsigned long addr;
+
+	if (! bpa2_bigphysarea_part)
+		return NULL;
+
+	addr = bpa2_alloc_pages(bpa2_bigphysarea_part, count, align, priority);
+	if (addr == 0)
+		return NULL;
+
+	return phys_to_virt(addr);
+}
+EXPORT_SYMBOL(bigphysarea_alloc_pages);
+
+void bigphysarea_free_pages(caddr_t mapped_addr)
+{
+	unsigned long addr = virt_to_phys(mapped_addr);
+
+	bpa2_free_pages(bpa2_bigphysarea_part, addr);
+}
+EXPORT_SYMBOL(bigphysarea_free_pages);
+
+caddr_t bigphysarea_alloc(int size)
+{
+	int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+	return bigphysarea_alloc_pages(pages, 1, GFP_KERNEL);
+}
+EXPORT_SYMBOL(bigphysarea_alloc);
+
+void bigphysarea_free(caddr_t addr, int size)
+{
+	(void)size;
+	bigphysarea_free_pages(addr);
+}
+EXPORT_SYMBOL(bigphysarea_free);
+
+#ifdef CONFIG_PROC_FS
+
+static char* get_part_info(char *p, struct bpa2_part *bp)
+{
+	struct range *ptr;
+	int     free_count, free_total, free_max;
+	int     used_count, used_total, used_max;
+
+	free_count = 0;
+	free_total = 0;
+	free_max   = 0;
+	for (ptr = bp->free_list; ptr != NULL; ptr = ptr->next) {
+		free_count++;
+		free_total += ptr->size;
+		if (ptr->size > free_max)
+			free_max = ptr->size;
+	}
+
+	used_count = 0;
+	used_total = 0;
+	used_max   = 0;
+	for (ptr = bp->used_list; ptr != NULL; ptr = ptr->next) {
+		used_count++;
+		used_total += ptr->size;
+		if (ptr->size > used_max)
+			used_max = ptr->size;
+	}
+
+	p += sprintf(p, "Partition: %s, size %ld kB\n", bp->name,
+		     (bp->res.end - bp->res.start + 1) / 1024);
+	if (bp->aka) {
+		const char** aka;
+		p += sprintf(p, "AKA: ");
+		for (aka=bp->aka; *aka; aka++)
+			p += sprintf(p, "%s, ", *aka);
+		p -= 2;
+		p += sprintf(p, "\n");
+	}
+	p += sprintf(p, "                       free list:             used list:\n");
+	p += sprintf(p, "number of blocks:      %8d               %8d\n",
+		     free_count, used_count);
+	p += sprintf(p, "size of largest block: %8d kB            %8d kB\n",
+		     free_max / 1024, used_max / 1024);
+	p += sprintf(p, "total:                 %8d kB            %8d kB\n",
+		     free_total / 1024, used_total /1024);
+
+	return  p;
+}
+
+static int get_info(char *buffer, char **addr, off_t offset, int count)
+{
+	struct bpa2_part* bp;
+	char* p = buffer;
+
+	spin_lock(&bpa2_lock);
+
+	list_for_each_entry(bp, &bpa2_parts, next) {
+		p = get_part_info(p, bp);
+		if (bpa2_parts.prev != &bp->next) {
+			*p++ = '\n';
+			*p++ = '\0';
+		}
+	}
+
+	spin_unlock(&bpa2_lock);
+
+	return p-buffer;
+}
+
+/*
+ * Called from late in the kernel initialisation sequence, once the
+ * normal memory allocator is available.
+ */
+static int __init bpa2_proc_init(void)
+{
+	create_proc_info_entry("bpa2", 0444, &proc_root, get_info);
+
+	return 0;
+}
+__initcall(bpa2_proc_init);
+
+#endif /* CONFIG_PROC_FS */
+
+void bpa2_memory(struct bpa2_part *part, unsigned long *base,
+		 unsigned long *size)
+{
+	if (base)
+		*base = (unsigned long)phys_to_virt(part->res.start);
+	if (size)
+		*size = part->res.end - part->res.start + 1;
+}
+
+void bigphysarea_memory(unsigned long *base, unsigned long *size)
+{
+	bpa2_memory(bpa2_bigphysarea_part, base, size);
+}
+EXPORT_SYMBOL(bigphysarea_memory);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/net/core/netpoll.c linux-2.6.23.1-stm/net/core/netpoll.c
--- linux-2.6.23.1/net/core/netpoll.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/net/core/netpoll.c	2007-11-01 12:00:39.000000000 +0000
@@ -46,6 +46,10 @@
 		(MAX_UDP_CHUNK + sizeof(struct udphdr) + \
 				sizeof(struct iphdr) + sizeof(struct ethhdr))
 
+#ifdef CONFIG_NWHW_CONFIG
+void nwhw_uconfig(struct net_device *);
+#endif
+
 static void zap_completion_queue(void);
 static void arp_reply(struct sk_buff *skb);
 
@@ -676,6 +680,13 @@
 	if (!netif_running(ndev)) {
 		unsigned long atmost, atleast;
 
+#ifdef CONFIG_NWHW_CONFIG
+		/* Configuring the network hardware from the command line,
+		   enabling the NWHW_CONFIG support, we are quite sure that the
+		   network devices properties must be set manually. */
+		nwhw_uconfig(ndev);
+#endif
+
 		printk(KERN_INFO "%s: device %s not up yet, forcing it\n",
 		       np->name, np->dev_name);
 
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/net/ipv4/ipconfig.c linux-2.6.23.1-stm/net/ipv4/ipconfig.c
--- linux-2.6.23.1/net/ipv4/ipconfig.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/net/ipv4/ipconfig.c	2007-11-01 12:00:39.000000000 +0000
@@ -178,6 +178,7 @@
 
 static struct ic_device *ic_first_dev __initdata = NULL;/* List of open device */
 static struct net_device *ic_dev __initdata = NULL;	/* Selected device */
+static unsigned int __initdata ipconf_delay = 0;
 
 static int __init ic_open_devs(void)
 {
@@ -185,6 +186,12 @@
 	struct net_device *dev;
 	unsigned short oflags;
 
+	if (ipconf_delay) {
+		printk(KERN_INFO "Waiting %dsec before opening network devices...\n",
+		       ipconf_delay);
+		ssleep(ipconf_delay);
+	}
+
 	last = &ic_first_dev;
 	rtnl_lock();
 
@@ -1507,5 +1514,12 @@
 	return ip_auto_config_setup(addrs);
 }
 
+static int __init ipconfdelay_config_setup(char *str)
+{
+	ipconf_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+
 __setup("ip=", ip_auto_config_setup);
 __setup("nfsaddrs=", nfsaddrs_config_setup);
+__setup("ipconfdelay=", ipconfdelay_config_setup);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/net/sunrpc/xprtsock.c linux-2.6.23.1-stm/net/sunrpc/xprtsock.c
--- linux-2.6.23.1/net/sunrpc/xprtsock.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/net/sunrpc/xprtsock.c	2007-11-01 12:00:41.000000000 +0000
@@ -1620,7 +1620,7 @@
 	if (args->timeout)
 		xprt->timeout = *args->timeout;
 	else
-		xprt_set_timeout(&xprt->timeout, 2, 60 * HZ);
+		xprt_set_timeout(&xprt->timeout, 7, 60 * HZ);
 
 	xs_format_peer_addresses(xprt);
 	dprintk("RPC:       set up transport to address %s\n",
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/Kconfig linux-2.6.23.1-stm/sound/Kconfig
--- linux-2.6.23.1/sound/Kconfig	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/sound/Kconfig	2007-11-01 12:00:40.000000000 +0000
@@ -67,6 +67,8 @@
 
 source "sound/sh/Kconfig"
 
+source "sound/stm/Kconfig"
+
 # the following will depend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/Makefile linux-2.6.23.1-stm/sound/Makefile
--- linux-2.6.23.1/sound/Makefile	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/sound/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -5,7 +5,7 @@
 obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/ stm/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/core/pcm_lib.c linux-2.6.23.1-stm/sound/core/pcm_lib.c
--- linux-2.6.23.1/sound/core/pcm_lib.c	2007-10-12 17:43:44.000000000 +0100
+++ linux-2.6.23.1-stm/sound/core/pcm_lib.c	2007-11-01 12:00:42.000000000 +0000
@@ -127,6 +127,7 @@
 
 static void xrun(struct snd_pcm_substream *substream)
 {
+printk("%s\n", __FUNCTION__);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if (substream->pstr->xrun_debug) {
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/Kconfig linux-2.6.23.1-stm/sound/stm/Kconfig
--- linux-2.6.23.1/sound/stm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/Kconfig	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,41 @@
+# ALSA SH4 drivers
+
+menu "ST PCM-ALSA driver"
+	depends on SND!=n && CPU_SUBTYPE_ST40
+
+config SND_STM8000
+	tristate "STM8000 ALSA driver"
+	depends on CPU_SUBTYPE_STM8000
+	select SND_PCM
+	help
+	  Say Y here for ALSA support on the STm8000.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-stm8000.
+
+config SND_STB710X
+	tristate "STB710x ALSA driver"
+	depends on CPU_SUBTYPE_STB7100
+	select SND_PCM
+	select STM_DMA
+	help
+	  Say Y here for ALSA support on the STb710x.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-stb710x.
+
+config STB7100_IEC_DEBUG
+	bool "STB710x ALSA driver IEC debug"
+	depends on CPU_SUBTYPE_STB7100
+	select SND_PCM
+	select STM_DMA
+	help
+	  Say Y here for ALSA-IEC debugging on the STb710x.
+
+config STB7100_FIFO_DEBUG
+	bool "STb710x Player FIFO under/overflow checking"
+	depends on SND_STB710X
+	select SND_PCM
+	help
+	  Say Y here for runtime checking of FIFO status
+endmenu
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/Makefile linux-2.6.23.1-stm/sound/stm/Makefile
--- linux-2.6.23.1/sound/stm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/Makefile	2007-11-01 12:00:40.000000000 +0000
@@ -0,0 +1,10 @@
+
+snd-stm8000-objs := st_pcm_core.o
+snd-stb710x-objs := st_pcm_core.o
+snd-spdif-stb710x-objs :=st_pcm_core.o
+
+obj-$(CONFIG_SND_STM8000) += snd-stm8000.o
+obj-$(CONFIG_SND_STB710X) += snd-stb710x.o
+
+
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/st_pcm.h linux-2.6.23.1-stm/sound/stm/st_pcm.h
--- linux-2.6.23.1/sound/stm/st_pcm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/st_pcm.h	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,313 @@
+/*
+ *  Definitions for ST PCM Player Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *  Authors: Stephen Gallimore <Stephen.Gallimore@st.com> and
+ *  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef _PCM_PLAYER_HW_H
+#define _PCM_PLAYER_HW_H
+
+#include <sound/asound.h>
+#include <linux/stm/stm-dma.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define INCR_FSYNTH    0x1
+#define DECR_FSYNTH    0x2
+#define SDIV_SHIFT_VAL 0x4000
+#define MD_SHIFT_VAL   0x8000
+
+/*make some named definitions to refer to each output device so we dont need to rely on the card number*/
+/*card majors*/
+#define PCM0_DEVICE			0
+#define PCM1_DEVICE			1
+#define SPDIF_DEVICE			2
+#define PROTOCOL_CONVERTER_DEVICE	3
+#define PCMIN_DEVICE			4
+/*card minors*/
+#define MAIN_DEVICE			0
+#define SUB_DEVICE1			1
+struct pcm_hw_t;
+
+typedef enum {
+	STM_DATA_TYPE_LPCM,
+	STM_DATA_TYPE_IEC60958,
+	STM_DATA_TYPE_I2S
+} stm_snd_data_type_t;
+
+
+typedef struct {
+        int                  major;
+        int                  minor;
+        stm_snd_data_type_t  input_type;
+        stm_snd_data_type_t  output_type;
+        snd_card_t          *device;
+        int                  in_use;
+} stm_snd_output_device_t;
+
+#define PCM_SAMPLE_SIZE_BYTES		4
+
+#if (STM_USE_BIGPHYS_AREA == 0)
+#define PCM_MAX_FRAMES			3276  /* <128k, max slab allocation */
+#define PCM_PREALLOC_SIZE		(128*1024)
+#define PCM_PREALLOC_MAX		(128*1024)
+#else
+#define PCM_MAX_FRAMES			48000 /* 1s @ 48KHz */
+/* Note: we cannot preallocate a buffer from ALSA if we want to
+ * use bigphysmem for large buffers and the standard page
+ * alocation for small buffers. The preallocation is spotted by
+ * the generic ALSA driver layer and the size is used to limit
+ * the buffer size requests before they even get to this driver.
+ * This overrides the buffer_bytes_max value in the hardware
+ * capabilities structure we set up.
+ */
+#define PCM_PREALLOC_SIZE		0
+#define PCM_PREALLOC_MAX		0
+#endif
+
+/*
+ * Buffers larger than 128k should come from bigphysmem to avoid
+ * page fragmentation and random resource starvation in the rest of
+ * the system. Buffers <=128k come from the ALSA dma memory allocation
+ * system, which uses get_free_pages directly, not a slab memory cache.
+ */
+#define PCM_BIGALLOC_SIZE		(128*1024)
+
+#define FRAMES_TO_BYTES(x,channels) (( (x) * (channels) ) * PCM_SAMPLE_SIZE_BYTES)
+#define BYTES_TO_FRAMES(x,channels) (( (x) / (channels) ) / PCM_SAMPLE_SIZE_BYTES)
+
+/*
+ * Common PCM Player Control register definitions
+ */
+#define PCMP_OPERATION_MASK		0x3
+#define PCMP_OFF			0x0
+#define PCMP_MUTE			0x1
+#define PCMP_ON				0x2
+
+#define PCMP_MEM_FMT_16_0		0
+#define PCMP_MEM_FMT_16_16		(1L<<2)
+#define PCMP_NO_ROUNDING		0
+#define PCMP_ROUNDING			(1L<<3)
+
+#define PCMP_DIV_MASK			0x00000ff0
+#define PCMP_FSYNTH_DIVIDE32_1		(0L<<4)
+#define PCMP_FSYNTH_DIVIDE32_128	(1L<<4)
+#define PCMP_FSYNTH_DIVIDE32_192	(6L<<4)
+#define PCMP_FSYNTH_DIVIDE32_256	(2L<<4)
+#define PCMP_FSYNTH_DIVIDE32_384	(3L<<4)
+#define PCMP_FSYNTH_DIVIDE32_512	(4L<<4)
+#define PCMP_FSYNTH_DIVIDE32_784	(6L<<4)
+
+#define PCMP_IGNORE_SPDIF_LATENCY	0
+#define PCMP_WAIT_SPDIF_LATENCY		(1L<<12)
+
+#define PCMP_SAMPLES_SHIFT		13
+/*
+ * The sample count field is 19bits wide, so the maximum size
+ * is 2^20-1 = 104,857. However becuase we count a sample for every
+ * channel and we usually have 10 channel PCM Players it is helpful
+ * to make this a nice round number that is a multiple of 10.
+ */
+#define PCMP_MAX_SAMPLES		(104000)
+
+/*
+ * PCM Player Format register definitions
+ */
+#define PCMP_FORMAT_16			1
+#define PCMP_FORMAT_32			0
+#define PCMP_LENGTH_24			0
+#define PCMP_LENGTH_20			(1L<<1)
+#define PCMP_LENGTH_18			(2L<<1)
+#define PCMP_LENGTH_16			(3L<<1)
+
+#define PCMP_LRLEVEL_LEFT_LOW		0
+#define PCMP_LRLEVEL_LEFT_HIGH		(1L<<3)
+#define PCMP_CLK_RISING			0
+#define PCMP_CLK_FALLING		(1L<<4)
+
+/* Danger Will Robinson Danger Danger!!!
+ * the data delay by one bit logic is inverted
+ */
+#define PCMP_PADDING_ON			0
+#define PCMP_PADDING_OFF		(1L<<5)
+
+#define PCMP_ALIGN_START		0
+#define PCMP_ALIGN_END			(1L<<6)
+#define PCMP_LSB_FIRST			0
+#define PCMP_MSB_FIRST			(1L<<7)
+
+#define PCMP_STATUS_RUNNING		(1L<<0)
+#define PCMP_STATUS_UNDERFLOW		(1L<<1)
+#define PCMP_STATUS_ALLREAD		(1L<<2)
+
+/*
+ * DVD category code definition for convenience.
+ */
+#define IEC958_AES1_CON_NON_IEC908_DVD (IEC958_AES1_CON_LASEROPT_ID|0x018)
+
+/*
+ * Extension to the ALSA channel status definitions for consumer mode 24bit
+ * wordlength.
+ */
+#define IEC958_AES4_CON_WORDLEN_MAX_24 (1<<0)
+#define IEC958_AES4_CON_WORDLEN_24_20  (5<<1)
+
+typedef enum iec_encodings {
+	ENCODING_IEC60958 = 0,
+	ENCODING_IEC61937_AC3,
+	ENCODING_IEC61937_DTS_1,
+	ENCODING_IEC61937_DTS_2,
+	ENCODING_IEC61937_DTS_3,
+	ENCODING_IEC61937_MPEG_384_FRAME,
+	ENCODING_IEC61937_MPEG_1152_FRAME,
+	ENCODING_IEC61937_MPEG_1024_FRAME,
+	ENCODING_IEC61937_MPEG_2304_FRAME,
+	ENCODING_IEC61937_MPEG_768_FRAME,
+	ENCODING_IEC61937_MPEG_2304_FRAME_LSF,
+	ENCODING_IEC61937_MPEG_768_FRAME_LSF,
+}iec_encodings_t;
+
+#define ENCODED_STREAM_TYPES  12
+
+typedef struct IEC60958 {
+	/* Channel status bits are the same for L/R subframes */
+       	snd_aes_iec958_t  channel;
+
+        /* Validity bits can be different on L and R e.g. in
+         * professional applications
+         */
+        u8                validity_l[24];
+        u8                validity_r[24];
+        /* User bits are considered contiguous across L/R subframes */
+        u8                user[48];
+}IEC60958_t;
+
+
+typedef struct {
+	int			(*free_device)     (struct pcm_hw_t *card);
+	int			(*open_device)     (snd_pcm_substream_t *substream);
+	int			(*program_hw)      (snd_pcm_substream_t *substream);
+	snd_pcm_uframes_t	(*playback_pointer)(snd_pcm_substream_t *substream);
+
+	void			(*start_playback)  (snd_pcm_substream_t *substream);
+	void			(*stop_playback)   (snd_pcm_substream_t *substream);
+	void			(*pause_playback)  (snd_pcm_substream_t *substream);
+	void			(*unpause_playback)(snd_pcm_substream_t *substream);
+} stm_playback_ops_t;
+
+typedef struct _IEC61937 {
+	int pause_mode; /*do we attmept a pause burst of mute with null ? */
+	int mute_rep;	/**/
+	int pause_count;
+	int frame_size;/*frames per burst*/
+	int latency;/*61937 defined maximum decode latency*/
+	int unpause_flag;
+}IEC61937_t;
+
+typedef struct pcmin_ctx{
+	struct 	timer_list period_timer;
+	int 	timer_halt;
+	int 	fr_delta;
+	int 	last_fr;
+}pcmin_ctx;
+
+typedef struct pcm_hw_t {
+	snd_card_t		*card;
+
+	spinlock_t		lock;
+	int			irq;
+        stm_snd_output_device_t *card_data;
+	unsigned long		buffer_start_addr;
+	unsigned long		pcmplayer_control;
+	unsigned long		irq_mask;
+	snd_pcm_hardware_t      hw;
+
+	snd_pcm_uframes_t    	hwbuf_current_addr;
+	snd_pcm_substream_t 	*current_substream;
+	char		   	*out_pipe;
+	char		    	*pcm_clock_reg;
+	char 			*pcm_player;
+	char                    *pcm_converter;
+	int		     	are_clocks_active;
+	int                     oversampling_frequency;
+
+	stm_playback_ops_t	*playback_ops;
+
+        IEC60958_t              current_spdif_control;
+        IEC60958_t              pending_spdif_control;
+        IEC60958_t              default_spdif_control;
+
+	int                     iec60958_output_count;
+	char			iec60958_rawmode;
+	char 			iec_encoding_mode;
+
+	IEC61937_t 		iec61937;
+	int  			min_ch;
+	int 			max_ch;
+	int 			fdma_req;
+	struct 	stm_dma_params  dmap;
+	struct  stm_dma_req     *dma_req;
+	int 			i2s_sampling_edge;
+	int			fifo_check_mode;
+	struct 	pcmin_ctx	pcmin;
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+	int 			spdif_player_mode;
+	int			fdma_channel;
+#endif
+} pcm_hw_t;
+
+struct stm_freq_s {
+	u32 freq;
+	u32 sdiv_val;
+	u32 pe_val;
+	u32 md_val;
+	u32 pe_quantum;
+};
+
+#define NUM_CLOCK_SETTINGS	5
+
+#define PCM0_SYNC_ID		2
+#define PCM1_SYNC_ID		4
+#define SPDIF_SYNC_MODE_ON	1
+
+#define chip_t pcm_hw_t
+
+static int snd_pcm_dev_free(snd_device_t *dev);
+
+static int __devinit snd_card_pcm_allocate(pcm_hw_t *stm8000, int device,char* name);
+static int __devinit snd_iec60958_create_controls(pcm_hw_t *chip);
+static int __devinit snd_generic_create_controls(pcm_hw_t *chip);
+static int __devinit register_platform_driver(	struct platform_device *platform_dev,
+						pcm_hw_t *chip,
+						int dev_nr);
+void set_spdif_syncing_status(int enable);
+
+extern void iec60958_default_channel_status(pcm_hw_t *chip);
+extern void iec60958_set_runtime_status(snd_pcm_substream_t *substream);
+
+
+#define DEBUG_PRINT(_x)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _ST_PCM_H */
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/st_pcm_core.c linux-2.6.23.1-stm/sound/stm/st_pcm_core.c
--- linux-2.6.23.1/sound/stm/st_pcm_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/st_pcm_core.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1315 @@
+/*
+ *  STPCM Player Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *  Authors: Stephen Gallimore <Stephen.Gallimore@st.com> and
+ *  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/cpu/cacheflush.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/proc_fs.h>
+
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#define SNDRV_GET_ID
+#include <sound/initval.h>
+
+#include <sound/asoundef.h>
+
+#if defined(CONFIG_BIGPHYS_AREA)
+
+#include <linux/bigphysarea.h>
+#define STM_USE_BIGPHYS_AREA 1
+
+#elif defined(CONFIG_BPA2)
+
+#include <linux/bpa2.h>
+#define STM_USE_BIGPHYS_AREA 1
+
+#else
+
+/* Private dummy defines so we do not have to ifdef the code */
+static caddr_t  bigphysarea_alloc(int size) { return NULL; }
+static void     bigphysarea_free(caddr_t addr, int size) {}
+#define STM_USE_BIGPHYS_AREA 0
+
+#endif /* CONFIG_BIGPHYS_AREA */
+
+
+#include <asm/dma.h>
+#include "st_pcm.h"
+
+static int index[SNDRV_CARDS] = {SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1};
+        	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = {SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1};	/* ID for this card */
+
+static u8 global_spdif_sync_status=0;
+
+static int get_spdif_syncing_status(void)
+{
+	return global_spdif_sync_status;
+}
+
+
+void set_spdif_syncing_status(int enable)
+{
+	global_spdif_sync_status = enable;
+}
+
+
+#if defined (CONFIG_CPU_SUBTYPE_STB7100)
+
+#define SND_DRV_CARDS  5
+
+static stm_snd_output_device_t  card_list[SND_DRV_CARDS]= {
+        /*major                      minor             input type          output type          */
+        {PCM0_DEVICE,               MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_LPCM},
+        {PCM1_DEVICE,               MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_LPCM},
+        {SPDIF_DEVICE,              MAIN_DEVICE, STM_DATA_TYPE_IEC60958, STM_DATA_TYPE_IEC60958},
+        {PROTOCOL_CONVERTER_DEVICE, MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_IEC60958},
+        {PCM0_DEVICE,	   	    SUB_DEVICE1, STM_DATA_TYPE_I2S,	 STM_DATA_TYPE_LPCM}
+};
+
+#include "stb7100_snd.h"
+#include "stm7100_pcm.c"
+#include "stb7100_i2s_spdif.c"
+#include "stb7100_spdif.c"
+#include "stb7100_pcmin.c"
+#define DEVICE_NAME "STb7100"
+
+#else
+	#error "BAD cpu arhitecture defined - PCM player is not supported"
+#endif
+
+MODULE_AUTHOR("Mark Glaisher <mark.glaisher@st.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION(DEVICE_NAME " ALSA driver");
+MODULE_SUPPORTED_DEVICE("{{STM," DEVICE_NAME "}}");
+
+static int snd_pcm_playback_hwfree(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+        chip->card_data->in_use = 0;
+
+	if(runtime->dma_area == NULL)
+		return 0;
+
+        if(STM_USE_BIGPHYS_AREA &&
+           runtime->dma_bytes > PCM_BIGALLOC_SIZE) {
+
+		bigphysarea_free(runtime->dma_area,
+				 runtime->dma_bytes);
+
+		runtime->dma_area    = 0;
+		runtime->dma_addr    = 0;
+		runtime->dma_bytes   = 0;
+
+		return 0;
+	}
+	else
+		return snd_pcm_lib_free_pages(substream);
+}
+
+
+static snd_pcm_uframes_t snd_pcm_playback_pointer(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	return chip->playback_ops->playback_pointer(substream);
+}
+
+
+static int snd_pcm_playback_prepare(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long flags=0;
+	/* Chip isn't running at this point so we don't have to disable interrupts*/
+	spin_lock_irqsave(&chip->lock,flags);
+
+#if defined (CONFIG_CPU_SUBTYPE_STB7100)
+	/*
+	 * On the STb7100 we can only use either the PCM0 device or the protocol
+	 * converter as they physically use the same hardware. As we have no
+	 * device specific hook for prepare, we do this here for the moment.
+	 */
+	if((card_list[PCM0_DEVICE].in_use               && (chip->card_data->major == PROTOCOL_CONVERTER_DEVICE)) ||
+	   (card_list[PROTOCOL_CONVERTER_DEVICE].in_use && (chip->card_data->major == PCM0_DEVICE)))
+	{
+		if(chip->card_data->minor == SUB_DEVICE1)
+			goto setup;
+
+		int converter_enable = (chip->card_data->major==PROTOCOL_CONVERTER_DEVICE ? 1:0);
+		printk("%s: device (%d,%d) is in use by (%d,%d)\n",
+                	__FUNCTION__,
+                	chip->card_data->major,
+                	chip->card_data->minor,
+                	(converter_enable ? 	PCM0_DEVICE:
+                				PROTOCOL_CONVERTER_DEVICE),
+                	(converter_enable ? 	card_list[PCM0_DEVICE].minor:
+                				card_list[PROTOCOL_CONVERTER_DEVICE].minor));
+
+        	return -EBUSY;
+        }
+#endif
+setup:
+	chip->card_data->in_use = 1;
+	spin_unlock_irqrestore(&chip->lock,flags);
+
+	if(chip->playback_ops->program_hw(substream) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+
+static int snd_pcm_dev_free(snd_device_t *dev)
+{
+	pcm_hw_t *snd_card = dev->device_data;
+
+	DEBUG_PRINT(("snd_pcm_dev_free(dev = 0x%08lx)\n",dev));
+	DEBUG_PRINT((">>> snd_card = 0x%08lx\n",snd_card));
+
+	if(snd_card->playback_ops->free_device)
+		return snd_card->playback_ops->free_device(snd_card);
+
+	return 0;
+}
+
+
+static int snd_playback_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	switch(cmd)
+	{
+		case SNDRV_PCM_TRIGGER_START:
+			chip->playback_ops->start_playback(substream);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			chip->playback_ops->stop_playback(substream);
+		        chip->card_data->in_use = 0;
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			chip->playback_ops->pause_playback(substream);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			chip->playback_ops->unpause_playback(substream);
+			break;
+		default:
+			return -EINVAL;
+	}
+	snd_pcm_trigger_done(substream,substream);
+	return 0;
+}
+
+
+static int snd_pcm_playback_close(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	DEBUG_PRINT(("snd_pcm_playback_close(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx\n",chip));
+
+	/*
+	 * If the PCM clocks are programmed then ensure the playback is
+	 * stopped. If not do nothing otherwise we can end up with the
+	 * DAC in a bad state.
+	 */
+	if(chip->are_clocks_active)
+		chip->playback_ops->stop_playback(substream);
+
+	spin_lock(&chip->lock);
+	chip->current_substream = 0;
+	spin_unlock(&chip->lock);
+
+	return 0;
+}
+
+
+static int snd_pcm_playback_hwparams(snd_pcm_substream_t * substream,
+					 snd_pcm_hw_params_t * hw_params)
+{
+	int   err  = 0;
+	int   size = 0;
+	char* addr = 0;
+
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	size = params_buffer_bytes(hw_params);
+
+	if (STM_USE_BIGPHYS_AREA && size > PCM_BIGALLOC_SIZE){
+		/*
+		 * This routine can be called multiple times without a free
+		 * in between, so we need to make sure we don't overallocate.
+		 */
+		if(runtime->dma_area) {
+			if(runtime->dma_bytes >= size) {
+				err = 0; /* Not changed */
+				goto exit;
+			}
+			else {
+				/* Use this to make sure we do the right free */
+				snd_pcm_playback_hwfree(substream);
+			}
+		}
+
+		addr = bigphysarea_alloc(size);
+
+		if(addr == 0) {
+			printk(KERN_WARNING "ALSA driver: sound buffer allocation from bigphysmem failed.\n");
+			printk(KERN_WARNING "ALSA driver: either increase bigphysmem pages with 'bigphyspages=xxxx' on the kernel command line\n");
+			printk(KERN_WARNING "ALSA driver: or reduce the requested buffer size to <=128k (3276 audio frames)\n");
+			err = -ENOMEM;
+			goto exit;
+		}
+		else{
+			dma_cache_wback(&addr, size);
+			runtime->dma_area    = addr;
+			runtime->dma_addr    = virt_to_phys(addr);
+			runtime->dma_bytes   = size;
+			err = 1; /* Changed buffer */
+		}
+	}
+	else {
+		err = snd_pcm_lib_malloc_pages(substream, size);
+		if(err >= 0) {
+			runtime->dma_addr = virt_to_phys(runtime->dma_area);
+		}
+	}
+
+exit:
+	DEBUG_PRINT((">>> dma_area = 0x%08lx err = %d\n",substream->runtime->dma_area, err));
+
+	return err;
+}
+
+
+/*
+ * This is a constraint rule which limits the period size to the capabilities
+ * of the ST PCM Players. These only have a 19bit count register which
+ * counts individual samples, i.e. for a 10-channel player it will count 10
+ * for each alsa 10 channel frame. This means we also need to ensure that
+ * the number of samples is an exact multiple of the number of channels.
+ */
+static int snd_pcm_period_size_rule(snd_pcm_hw_params_t *params,
+				     snd_pcm_hw_rule_t   *rule)
+{
+	snd_interval_t *periodsize;
+	snd_interval_t *channels;
+	snd_interval_t  newperiodsize;
+
+	int refine = 0;
+
+	periodsize    = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+	newperiodsize = *periodsize;
+	channels      = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	if((periodsize->max * channels->min) > PCMP_MAX_SAMPLES) {
+		newperiodsize.max = PCMP_MAX_SAMPLES / channels->min;
+		refine = 1;
+	}
+
+	if((periodsize->min * channels->min) > PCMP_MAX_SAMPLES) {
+		newperiodsize.min = PCMP_MAX_SAMPLES / channels->min;
+		refine = 1;
+	}
+
+	if(refine) {
+		DEBUG_PRINT(("snd_pcm_period_size_rule: refining (%d,%d) to (%d,%d)\n",periodsize->min,periodsize->max,newperiodsize.min,newperiodsize.max));
+		return snd_interval_refine(periodsize, &newperiodsize);
+	}
+
+	return 0;
+}
+
+
+static int snd_pcm_playback_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	int err = 0;
+
+	DEBUG_PRINT(("snd_pcm_playback_open(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx\n",chip));
+
+	snd_pcm_set_sync(substream);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_TIME,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	spin_lock(&chip->lock);
+
+	chip->current_substream = substream;
+        runtime->hw = chip->hw;
+
+        if(chip->playback_ops->open_device)
+		err = chip->playback_ops->open_device(substream);
+
+	spin_unlock(&chip->lock);
+
+	return err;
+}
+
+/*
+ * nopage callback for mmapping a RAM page
+ */
+
+static struct page *snd_pcm_mmap_data_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+{
+        snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+        snd_pcm_runtime_t *runtime;
+        unsigned long offset;
+        struct page * page;
+        void *vaddr;
+        size_t dma_bytes;
+
+        if (substream == NULL)
+                return NOPAGE_OOM;
+        runtime = substream->runtime;
+        offset = area->vm_pgoff << PAGE_SHIFT;
+        offset += address - area->vm_start;
+        snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+        dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
+        if (offset > dma_bytes - PAGE_SIZE)
+                return NOPAGE_SIGBUS;
+
+        if (substream->ops->page) {
+                page = substream->ops->page(substream, offset);
+                if (! page)
+                        return NOPAGE_OOM;
+        } else {
+                vaddr = runtime->dma_area + offset;
+                page = virt_to_page(vaddr);
+        }
+        get_page(page);
+        if (type)
+                *type = VM_FAULT_MINOR;
+        return page;
+}
+
+
+static struct vm_operations_struct snd_pcm_vm_ops_data =
+{
+        .open =         snd_pcm_mmap_data_open,
+        .close =        snd_pcm_mmap_data_close,
+        .nopage =       snd_pcm_mmap_data_nopage,
+};
+
+/*
+ * mmap the DMA buffer on RAM
+ */
+
+static int snd_pcm_mmap(snd_pcm_substream_t *substream, struct vm_area_struct *area)
+{
+        area->vm_ops = &snd_pcm_vm_ops_data;
+        area->vm_private_data = substream;
+        area->vm_flags |= VM_RESERVED;
+
+        area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+
+        atomic_inc(&substream->runtime->mmap_count);
+        return 0;
+}
+
+
+static int snd_pcm_silence(snd_pcm_substream_t *substream, int channel,
+                            snd_pcm_uframes_t    pos,       snd_pcm_uframes_t count)
+{
+        snd_pcm_runtime_t *runtime = substream->runtime;
+        char *hwbuf;
+	int   totalbytes;
+
+        if(channel != -1)
+                return -EINVAL;
+
+        hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+
+	totalbytes = frames_to_bytes(runtime, count);
+
+        snd_pcm_format_set_silence(runtime->format, hwbuf, totalbytes);
+        dma_cache_wback(hwbuf, totalbytes);
+        return 0;
+}
+
+
+static int snd_pcm_copy(snd_pcm_substream_t	*substream,
+			 int			 channel,
+			 snd_pcm_uframes_t	 pos,
+			 void __user		*buf,
+			 snd_pcm_uframes_t	 count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	char		  *hwbuf;
+	int                totalbytes;
+
+	if(channel != -1)
+		return -EINVAL;
+
+	hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+
+	totalbytes = frames_to_bytes(runtime, count);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+
+		if(copy_from_user(hwbuf, buf, totalbytes))
+			return -EFAULT;
+
+		dma_cache_wback(hwbuf, totalbytes);
+	}
+	else{
+		dma_cache_inv(hwbuf,totalbytes);
+
+		if(copy_to_user(buf,hwbuf,totalbytes))
+			return -EFAULT;
+	}
+	return 0;
+}
+
+/*
+ * IEC60958 channel status and format handling for SPDIF and I2S->SPDIF
+ * protocol converters
+ */
+void iec60958_default_channel_status(pcm_hw_t *chip)
+{
+	chip->default_spdif_control.channel.status[0]  = (IEC958_AES0_CON_NOT_COPYRIGHT |
+							  IEC958_AES0_CON_EMPHASIS_NONE);
+
+	chip->default_spdif_control.channel.status[1] |= (IEC958_AES1_CON_NON_IEC908_DVD |
+							  IEC958_AES1_CON_ORIGINAL) ;
+
+
+	chip->default_spdif_control.channel.status[2] |= (IEC958_AES2_CON_SOURCE_UNSPEC |
+							  IEC958_AES2_CON_CHANNEL_UNSPEC);
+
+	chip->default_spdif_control.channel.status[3] |= (IEC958_AES3_CON_FS_44100 |
+							  IEC958_AES3_CON_CLOCK_VARIABLE);
+
+	chip->default_spdif_control.channel.status[4]  = (IEC958_AES4_CON_WORDLEN_MAX_24 |
+							  IEC958_AES4_CON_WORDLEN_24_20);
+
+	memset(chip->default_spdif_control.user,      0x0,sizeof(u8)*48);
+	memset(chip->default_spdif_control.validity_l,0x0,sizeof(u8)*24);
+	memset(chip->default_spdif_control.validity_r,0x0,sizeof(u8)*24);
+}
+
+
+void iec60958_set_runtime_status(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if(chip->pending_spdif_control.channel.status[0] & IEC958_AES0_PROFESSIONAL) {
+		chip->pending_spdif_control.channel.status[0] &= ~IEC958_AES0_PRO_FS;
+		switch(substream->runtime->rate){
+			case 32000:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_32000;
+				break;
+			case 48000:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_48000;
+				break;
+			default:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_44100;
+				break;
+		}
+
+		chip->pending_spdif_control.channel.status[2]
+			&= ~((IEC958_AES2_PRO_SBITS | IEC958_AES2_PRO_WORDLEN));
+
+		chip->pending_spdif_control.channel.status[2]
+			|= (IEC958_AES2_PRO_SBITS_24 | IEC958_AES2_PRO_WORDLEN_24_20);
+
+		chip->pending_spdif_control.channel.status[4] = 0;
+
+	} else {
+		chip->pending_spdif_control.channel.status[3] &=
+				 ~((IEC958_AES3_CON_FS|IEC958_AES3_CON_CLOCK));
+		switch(substream->runtime->rate){
+			case 32000:
+				chip->pending_spdif_control.channel.status[3]
+					|= IEC958_AES3_CON_FS_32000;
+				break;
+			case 48000:
+				chip->pending_spdif_control.channel.status[3]
+					 |= IEC958_AES3_CON_FS_48000;
+				break;
+			default:
+				chip->pending_spdif_control.channel.status[3]
+					 |= IEC958_AES3_CON_FS_44100;
+				break;
+		}
+
+		chip->pending_spdif_control.channel.status[3] |= IEC958_AES3_CON_CLOCK_VARIABLE;
+
+		if(chip->pending_spdif_control.channel.status[0] & IEC958_AES0_NONAUDIO) {
+			DEBUG_PRINT(("iec60958_set_runtime_status: NON LPCM Setup\n",dev));
+			chip->pending_spdif_control.channel.status[4] = 0;
+			/*
+			 * Force all validity bits to 1 as specified in the spec
+			 * to prevent accidental interpretation as LPCM.
+			 */
+			memset(chip->default_spdif_control.validity_l,0xff,sizeof(u8)*24);
+			memset(chip->default_spdif_control.validity_r,0xff,sizeof(u8)*24);
+		} else {
+			DEBUG_PRINT(("iec60958_set_runtime_status: 24bit LPCM Setup\n",dev));
+			chip->pending_spdif_control.channel.status[4]  = (IEC958_AES4_CON_WORDLEN_MAX_24 |
+									  IEC958_AES4_CON_WORDLEN_24_20);
+		}
+	}
+
+}
+
+
+static int snd_iec60958_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+
+static int snd_iec60958_default_get(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.iec958.status[0] = chip->default_spdif_control.channel.status[0];
+	ucontrol->value.iec958.status[1] = chip->default_spdif_control.channel.status[1];
+	ucontrol->value.iec958.status[2] = chip->default_spdif_control.channel.status[2];
+	ucontrol->value.iec958.status[3] = chip->default_spdif_control.channel.status[3];
+
+	return 0;
+}
+
+
+static int snd_iec60958_default_put(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	u32 val, old;
+
+	val =  ucontrol->value.iec958.status[0]        |
+	      (ucontrol->value.iec958.status[1] << 8)  |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+
+	old =  chip->default_spdif_control.channel.status[0] 	    |
+	      (chip->default_spdif_control.channel.status[1] << 8)  |
+	      (chip->default_spdif_control.channel.status[2] << 16) |
+	      (chip->default_spdif_control.channel.status[3] << 24);
+
+	if(val == old)
+		return 0;
+
+	spin_lock_irq(&chip->lock);
+	chip->default_spdif_control.channel = ucontrol->value.iec958;
+	spin_unlock_irq(&chip->lock);
+	return (val != old);
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_default __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_default_get,
+	.put =		snd_iec60958_default_put
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_stream __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_default_get,
+	.put =		snd_iec60958_default_put
+};
+
+static int snd_iec60958_maskc_get(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO          |
+					   IEC958_AES0_PROFESSIONAL      |
+					   IEC958_AES0_CON_NOT_COPYRIGHT |
+					   IEC958_AES0_CON_EMPHASIS;
+
+	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |
+					   IEC958_AES1_CON_CATEGORY;
+
+	ucontrol->value.iec958.status[2] = 0;
+
+	ucontrol->value.iec958.status[3] = 0;
+	return 0;
+}
+
+
+static int snd_iec60958_maskp_get(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO     |
+					   IEC958_AES0_PROFESSIONAL |
+					   IEC958_AES0_PRO_EMPHASIS;
+
+	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
+					   IEC958_AES1_PRO_USERBITS;
+
+	return 0;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_maskc __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskc_get,
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_mask __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskc_get,
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_maskp __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskp_get,
+};
+
+
+static int snd_iec60958_raw_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+
+static int snd_iec60958_raw_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->iec60958_rawmode;
+	return 0;
+}
+
+
+static int snd_iec60958_raw_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned char old, val;
+
+	spin_lock_irq(&chip->lock);
+	old = chip->iec60958_rawmode;
+	val = ucontrol->value.integer.value[0];
+	chip->iec60958_rawmode = val;
+	spin_unlock_irq(&chip->lock);
+	return old != val;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_raw __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "RAW",
+	.info =		snd_iec60958_raw_info,
+	.get =		snd_iec60958_raw_get,
+	.put =		snd_iec60958_raw_put
+};
+
+
+static int snd_iec60958_sync_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.integer.value[0] = global_spdif_sync_status;
+	return 0;
+}
+
+
+static int snd_iec60958_sync_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+
+	unsigned char old, val;
+
+	old = get_spdif_syncing_status();
+	val = ucontrol->value.integer.value[0];
+	set_spdif_syncing_status(val);
+	return old != val;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_sync __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "PCM Sync",
+	.info =		snd_iec60958_raw_info, /* Reuse from the RAW switch */
+	.get =		snd_iec60958_sync_get,
+	.put =		snd_iec60958_sync_put
+};
+
+
+/*IEC61937 encoding mode status -  when transmitting a surround encoded data
+ * stream the repitition period of iec61937 pause bursts and external decode latency
+ *  are dependant on stream type*/
+
+
+typedef struct iec_encoding_mode_tbl {
+	char name[30];
+	iec_encodings_t id_flag;
+}iec_encoding_mode_tbl_t;
+
+static iec_encoding_mode_tbl_t iec_xfer_modes[12]=
+	{
+		{"IEC60958"	,ENCODING_IEC60958},
+		{"IEC61937_AC3"	,ENCODING_IEC61937_AC3},
+		{"IEC61937_DTS1",ENCODING_IEC61937_DTS_1},
+		{"IEC61937_DTS2",ENCODING_IEC61937_DTS_2},
+		{"IEC61937_DTS3",ENCODING_IEC61937_DTS_3},
+		{"IEC61937_MPEG_384",ENCODING_IEC61937_MPEG_384_FRAME},
+		{"IEC61937_MPEG_1152",ENCODING_IEC61937_MPEG_1152_FRAME},
+		{"IEC61937_MPEG_1024",ENCODING_IEC61937_MPEG_1024_FRAME},
+		{"IEC61937_MPEG_2304",ENCODING_IEC61937_MPEG_2304_FRAME},
+		{"IEC61937_MPEG_768",ENCODING_IEC61937_MPEG_768_FRAME},
+		{"IEC61937_MPEG_2304_LSF",ENCODING_IEC61937_MPEG_2304_FRAME_LSF},
+		{"IEC61937_MPEG_768_LSF",ENCODING_IEC61937_MPEG_768_FRAME_LSF},
+	};
+
+
+
+static int snd_iec_encoding_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = ENCODED_STREAM_TYPES;
+	if (uinfo->value.enumerated.item > (ENCODED_STREAM_TYPES-1))
+		uinfo->value.enumerated.item = (ENCODED_STREAM_TYPES);
+	strcpy(uinfo->value.enumerated.name,iec_xfer_modes[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int snd_iec_encoding_get(snd_kcontrol_t* kcontrol,snd_ctl_elem_value_t* ucontrol)
+{
+	int i;
+
+	for(i=0; i< ENCODED_STREAM_TYPES; i++)
+		ucontrol->value.integer.value[i] = iec_xfer_modes[i].id_flag;
+
+	return 0;
+}
+
+static int snd_iec_encoding_put(	 snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	spin_lock_irq(&chip->lock);
+	chip->iec_encoding_mode = ucontrol->value.integer.value[0];
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_iec_encoding __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE)"Encoding",
+	.info =		snd_iec_encoding_info,
+	.get =		snd_iec_encoding_get,
+	.put =		snd_iec_encoding_put,
+};
+
+static int snd_clock_put(snd_kcontrol_t * kcontrol,snd_ctl_elem_value_t * ucontrol)
+{
+
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+
+	int direction = (((int)ucontrol->value.integer.value[1]) > 0) ? 1:0;
+	int adjusts=ucontrol->value.integer.value[0];
+
+	spin_lock_irq(&chip->lock);
+	adjust_audio_clock(chip->current_substream,adjusts,direction);
+
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+
+
+static int snd_clock_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.min = -10000;
+	uinfo->value.integer.max = 10000;
+
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_clock_adjust  __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		"PLAYBACK Clock Adjust",
+	.info =		snd_clock_info,
+	.put =		snd_clock_put,
+};
+
+/*now three controls to specify the available encoding modes */
+
+static int __devinit snd_generic_create_controls(pcm_hw_t *chip)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_clock_adjust,chip));
+	if(err < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int __devinit snd_iec60958_create_controls(pcm_hw_t *chip)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+
+	if(chip->card_data->input_type == STM_DATA_TYPE_IEC60958)
+	{
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_iec60958_raw, chip));
+		if (err < 0)
+			return err;
+
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_iec60958_sync, chip));
+		if (err < 0)
+			return err;
+	}
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_default, chip));
+	if (err < 0)
+		return err;
+
+	/*
+	 * stream is a copy of default for the moment for application
+	 * compatibility, more investigation required
+	 */
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_stream, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_maskc, chip));
+	if (err < 0)
+		return err;
+
+	/*
+	 * Mask is a copy of the consumer mask.
+	 */
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_mask, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_maskp, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec_encoding,chip));
+	if(err < 0)
+		return err;
+
+	return 0;
+}
+
+
+static void format_iec60958_frame(snd_pcm_substream_t *substream,
+				  u32                 *left_subframe,
+				  u32                 *right_subframe)
+{
+	/*
+	 * Format for the SPDIF player. Note that the ordering of CUV is
+	 * the reverse of that specified in the SPDIF player specification,
+	 * but is correct with regards to the ST reference driver documentation.
+	 *
+     	 * 31 ..16 bit data16| 15 ext data 8 | 7 zero  4 | 3 ctrl bits 0
+    	 * |xxxxxxxxxxxxxxxx | ????????        0000      | VUC0
+    	 */
+	static const u32 channel_status_bit = (1 << 1);
+	static const u32 user_bit           = (1 << 2);
+	static const u32 validity_bit       = (1 << 3);
+
+        pcm_hw_t   *chip       = snd_pcm_substream_chip(substream);
+
+        u8 *channel_status = &chip->current_spdif_control.channel.status[0];
+	u8 *user           = &chip->current_spdif_control.user[0];
+        u8 *validity_l     = &chip->current_spdif_control.validity_l[0];
+        u8 *validity_r     = &chip->current_spdif_control.validity_r[0];
+	/*
+	 * Index and test bit for channel status and validity
+	 */
+        int word_index      = chip->iec60958_output_count/8;
+        u32 test_bit        = 1 << (chip->iec60958_output_count%8);
+        /*
+         * Index and test bits for the user bits, which are contiguous across
+         * L/R subframes.
+         */
+        int user_word_index = (chip->iec60958_output_count*2)/8;
+	u32 u_test_bit_l    = 1 << (chip->iec60958_output_count*2)%8;
+	u32 u_test_bit_r    = u_test_bit_l << 1;
+	u32 format_word_l   = 0;
+	u32 format_word_r   = 0;
+
+	if(chip->iec60958_output_count == 0) {
+		/*
+		 * Start of a new burst, so update the control bits
+		 */
+		chip->current_spdif_control = chip->pending_spdif_control;
+	}
+
+#if defined(CONFIG_STB7100_IEC_DEBUG)
+	static int print_debug;
+	if(chip->iec60958_output_count == 0){
+		if(*left_subframe == 0xf8720000 && *right_subframe == 0x4e1f0000)
+			print_debug = 1;
+	}
+
+	if(chip->iec60958_output_count == 8) {
+		print_debug = 0;
+	}
+
+	if(print_debug) {
+	  	printk("%03d: in(0x%08x,0x%08x) ",chip->iec60958_output_count,*left_subframe,*right_subframe);
+	}
+#endif
+    	/*
+    	 * channel status is only ever 35 bits long , so we can ingnore the
+	 * remaining 157 frames
+	 */
+    	if((word_index <5) && (channel_status[word_index] & test_bit))
+    	{
+    		format_word_l |= channel_status_bit;
+    		format_word_r |= channel_status_bit;
+    	}
+
+	if(user[user_word_index] & u_test_bit_l)
+		format_word_l |= user_bit;
+
+	if(user[user_word_index] & u_test_bit_r)
+		format_word_r |= user_bit;
+
+	if(validity_l[word_index] & test_bit)
+		format_word_l |= validity_bit;
+
+	if(validity_r[word_index] & test_bit)
+		format_word_r |= validity_bit;
+
+	*left_subframe  = (*left_subframe  & 0xffffff00) | format_word_l;
+	*right_subframe = (*right_subframe & 0xffffff00) | format_word_r;
+
+#if defined(CONFIG_STB7100_IEC_DEBUG)
+	if(print_debug) {
+		printk("%03d: out(0x%08x,0x%08x)\n",chip->iec60958_output_count,*left_subframe,*right_subframe);
+	}
+#endif
+	chip->iec60958_output_count = (chip->iec60958_output_count+1)%192;
+}
+
+/*
+ * Internal function which can be called independently by other modules
+ * to get IEC60958 formatting. Note the interface is slightly manipulated
+ * to allow channels to be skipped in the buffer.
+ */
+int snd_pcm_format_iec60958_copy(snd_pcm_substream_t	*substream,
+				 int			data_channels,
+			 	 snd_pcm_uframes_t	pos,
+			 	 void	__user		*buffer,
+			 	 snd_pcm_uframes_t	count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	u32 __user        *buf32   = (u32 __user *) buffer;
+	int i;
+
+	/*
+	 * Note that runtime->channels must be 2 for an SPDIF device
+	 * which maps to the two subframes in an SPDIF frame. Each subframe
+	 * is 32bits, so each "output frame" is 8 bytes (2x4).
+	 */
+	int dstwidth  = sizeof(u32)*2;
+	int srcwidth  = samples_to_bytes(runtime, data_channels);
+	int bit_width = snd_pcm_format_physical_width(substream->runtime->format);
+
+        u32 *hwbuf    = (u32*)(runtime->dma_area + (pos*dstwidth));
+
+	if(!access_ok(VERIFY_READ, buffer, (count * srcwidth)))
+		return -EFAULT;
+
+
+	for(i=0;i<count;i++)
+	{
+		u32 left_subframe;
+		u32 right_subframe;
+
+		__get_user(left_subframe, buf32);
+		__get_user(right_subframe, buf32+1);
+
+		if(bit_width == 24)
+		{
+		  /*
+		   * We can support S24_LE (24bits in the bottom 3bytes of
+		   * a 32bit word) by shifting the audio bits into position
+		   */
+		  left_subframe  <<= 8;
+		  right_subframe <<= 8;
+		}
+
+		format_iec60958_frame(substream, &left_subframe, &right_subframe);
+
+		*hwbuf     = left_subframe;
+		*(hwbuf+1) = right_subframe;
+
+		buf32  += data_channels;
+	    	hwbuf  += 2;
+	}
+
+	dma_cache_wback((void*)(runtime->dma_area + (pos*dstwidth)), (count*dstwidth));
+
+	return 0;
+}
+
+
+/*
+ * This is the ALSA interface for the card "ops" structure
+ */
+static int snd_iec60958_silence(snd_pcm_substream_t *substream,
+				int                  channel,
+				snd_pcm_uframes_t    pos,
+				snd_pcm_uframes_t    count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	u32               *hwbuf;
+	static const int dstwidth  = sizeof(u32)*2;
+	int i;
+
+        if(channel != -1)
+                return -EINVAL;
+
+        hwbuf = (u32*)(runtime->dma_area + (pos*dstwidth));
+
+	for(i=0;i<count;i++)
+	{
+		u32 left_subframe  = 0;
+		u32 right_subframe = 0;
+
+		format_iec60958_frame(substream, &left_subframe, &right_subframe);
+
+		*hwbuf     = left_subframe;
+		*(hwbuf+1) = right_subframe;
+
+	    	hwbuf += 2;
+	}
+
+	dma_cache_wback((void*)(runtime->dma_area + (pos*dstwidth)), (count*dstwidth));
+
+        return 0;
+}
+
+
+static int snd_iec60958_copy(snd_pcm_substream_t  *substream,
+			     int                   channel,
+			     snd_pcm_uframes_t     pos,
+			     void __user          *buf,
+			     snd_pcm_uframes_t     count)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if(channel != -1)
+		return -EINVAL;
+
+	if(chip->iec60958_rawmode)
+		return snd_pcm_copy(substream,channel,pos,buf,count);
+	else
+		return snd_pcm_format_iec60958_copy(substream,substream->runtime->channels,pos,buf,count);
+}
+
+
+static void snd_card_pcm_free(snd_pcm_t *pcm)
+{
+	DEBUG_PRINT(("snd_card_pcm_free(pcm = 0x%08lx)\n",pcm));
+
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+
+static snd_pcm_ops_t  snd_card_playback_ops_pcm = {
+	.open      =            snd_pcm_playback_open,
+        .close     =            snd_pcm_playback_close,
+        .mmap      =            snd_pcm_mmap,
+        .silence   =            snd_pcm_silence,
+	.copy      =            snd_pcm_copy,
+        .ioctl     =            snd_pcm_lib_ioctl,
+        .hw_params =            snd_pcm_playback_hwparams,
+        .hw_free   =            snd_pcm_playback_hwfree,
+        .prepare   =            snd_pcm_playback_prepare,
+        .trigger   =            snd_playback_trigger,
+        .pointer   =            snd_pcm_playback_pointer,
+};
+
+
+static snd_pcm_ops_t  snd_card_playback_ops_iec60958 = {
+	.open      =            snd_pcm_playback_open,
+        .close     =            snd_pcm_playback_close,
+        .mmap      =            snd_pcm_mmap,
+        .silence   =            snd_iec60958_silence,
+	.copy      =            snd_iec60958_copy,
+        .ioctl     =            snd_pcm_lib_ioctl,
+        .hw_params =            snd_pcm_playback_hwparams,
+        .hw_free   =            snd_pcm_playback_hwfree,
+        .prepare   =            snd_pcm_playback_prepare,
+        .trigger   =            snd_playback_trigger,
+        .pointer   =            snd_pcm_playback_pointer,
+};
+
+
+static int __devinit snd_card_pcm_allocate(pcm_hw_t *snd_card, int device,char* name)
+{
+	int err;
+	snd_pcm_t *pcm;
+
+	if(snd_card->card_data->input_type == STM_DATA_TYPE_IEC60958){
+
+		err = snd_pcm_new(snd_card->card,name, snd_card->card_data->minor,1, 0, &pcm);
+		snd_pcm_set_ops(pcm,SNDRV_PCM_STREAM_PLAYBACK,&snd_card_playback_ops_iec60958);
+	}
+	else if(snd_card->card_data->major == PCM0_DEVICE &&
+		snd_card->card_data->minor == SUB_DEVICE1){
+			err = snd_pcm_new(snd_card->card,name,snd_card->card_data->minor,0,1 , &pcm);
+			snd_pcm_set_ops(pcm,SNDRV_PCM_STREAM_CAPTURE,&snd_card_playback_ops_pcm);
+	}
+	else{
+		err = snd_pcm_new(snd_card->card,name, snd_card->card_data->minor,1, 0, &pcm);
+		snd_pcm_set_ops(pcm,SNDRV_PCM_STREAM_PLAYBACK,&snd_card_playback_ops_pcm);
+	}
+
+	if (err < 0)
+		return err;
+
+	pcm->private_data = snd_card;
+	pcm->private_free = snd_card_pcm_free;
+	pcm->info_flags   = 0;
+	strcpy(pcm->name, name);
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm,
+					SNDRV_DMA_TYPE_CONTINUOUS,
+					snd_dma_continuous_data(GFP_KERNEL),
+					PCM_PREALLOC_SIZE,
+					PCM_PREALLOC_MAX);
+	return 0;
+}
+
+static int register_platform_driver(struct platform_device *platform_dev,pcm_hw_t *chip, int dev_nr)
+{
+	static struct resource *res;
+	if (!platform_dev){
+       		printk("%s Failed. Check your kernel SoC config\n",__FUNCTION__);
+         	return -EINVAL;
+       	}
+
+	res = platform_get_resource(platform_dev, IORESOURCE_IRQ,0);    /*resource 0 */
+	if(res!=NULL){
+		chip->min_ch = res->start;
+		chip->max_ch = res->end;
+	}
+	else return -ENOSYS;
+
+	res = platform_get_resource(platform_dev, IORESOURCE_IRQ,1);
+	if(res!=NULL)
+		chip->fdma_req = res->start;
+	else return -ENOSYS;
+
+	/*we only care about this var for the analogue devices*/
+	if(dev_nr < SPDIF_DEVICE  || dev_nr == PCMIN_DEVICE)  {
+		res = platform_get_resource(platform_dev, IORESOURCE_IRQ,2);
+		if(res!=NULL)
+			chip->i2s_sampling_edge =
+				(res->start ==1 ? PCMP_CLK_FALLING:PCMP_CLK_RISING);
+		else return -ENOSYS;
+	}
+	return 0;
+}
+
+static int __init alsa_card_init(void)
+{
+	int i=0;
+	for(;i<SND_DRV_CARDS-1;i++){
+		if (snd_pcm_card_probe(i) < 0){
+			DEBUG_PRINT(("STm PCM Player not found or device busy\n"));
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static void __exit alsa_card_exit(void)
+{
+	int i=0;
+
+	for(i=0;i<SND_DRV_CARDS-1;i++){
+		if(card_list[i].device)
+			snd_card_free(card_list[i].device);
+	}
+}
+
+EXPORT_SYMBOL(format_iec60958_frame);
+EXPORT_SYMBOL(snd_pcm_format_iec60958_copy);
+
+module_init(alsa_card_init)
+module_exit(alsa_card_exit)
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/stb7100_i2s_spdif.c linux-2.6.23.1-stm/sound/stm/stb7100_i2s_spdif.c
--- linux-2.6.23.1/sound/stm/stb7100_i2s_spdif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/stb7100_i2s_spdif.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,443 @@
+/*
+ *  STb7100 PCM->SPDIF protocol converter setup
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+/*
+ * Default HW template for PCM player 0 when used with the I2S->SPDIF
+ * protocol converter.
+ */
+static snd_pcm_hardware_t stb7100_converter_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID     |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	(SNDRV_PCM_FMTBIT_S32_LE),
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 48000,
+	.channels_min	  = 10,
+	.channels_max	  = 10,
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.period_bytes_min = FRAMES_TO_BYTES(1,10),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	/*The above 5 parms will be overidden in stb7100_pcm_open once
+	 * we have loaded the channel configs for this cpu - we still need
+	 * to provide defaults however*/
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+
+DECLARE_WAIT_QUEUE_HEAD(software_reset_wq);
+static volatile int software_reset_complete = 0;
+
+static void reset_pcm_converter(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t * chip = snd_pcm_substream_chip(substream);
+	u32 reg;
+
+	software_reset_complete = 0;
+	reg = readl(chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	writel((reg|PR_CFG_CONV_SW_RESET),chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	wait_event(software_reset_wq, (software_reset_complete != 0));
+	writel(reg,chip->pcm_converter+AUD_SPDIF_PR_CFG);
+}
+
+static void reset_converter_fifo(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t * chip = snd_pcm_substream_chip(substream);
+	unsigned long reg =readl(chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	writel((reg & ~PR_CFG_FIFO_ENABLE),chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	writel(reg |=PR_CFG_FIFO_ENABLE ,chip->pcm_converter+AUD_SPDIF_PR_CFG);
+}
+
+static inline void bit_duplicate(u32 bits, u32 *word1, u32 *word2)
+{
+	int i,test_bit;
+
+	*word1 = 0;
+	*word2 = 0;
+	test_bit = 1;
+
+	for(i=0;i<16;i++) {
+		if(bits & test_bit) {
+			*word1 |= (1<<(i*2));
+			*word1 |= (1<<(i*2+1));
+		}
+
+		test_bit <<= 1;
+	}
+	/*
+	 * Note that test bit keeps going!
+	 */
+	for(i=0;i<16;i++) {
+		if(bits & test_bit) {
+			*word2 |= (1<<(i*2));
+			*word2 |= (1<<(i*2+1));
+		}
+
+		test_bit <<= 1;
+	}
+
+}
+
+
+static void stb7100_converter_write_channel_status(pcm_hw_t *chip)
+{
+	u32 chstatus,word1,word2;
+
+	chstatus = chip->current_spdif_control.channel.status[0]        |
+		   (chip->current_spdif_control.channel.status[1] <<8)  |
+		   (chip->current_spdif_control.channel.status[2] <<16) |
+		   (chip->current_spdif_control.channel.status[3] <<24);
+
+	bit_duplicate(chstatus, &word1, &word2);
+
+	writel(	word1, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE);
+
+	writel(	word2, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 4);
+
+	chstatus = chip->current_spdif_control.channel.status[4]        |
+		   (chip->current_spdif_control.channel.status[5] <<8)  |
+		   (chip->current_spdif_control.channel.status[6] <<16) |
+		   (chip->current_spdif_control.channel.status[7] <<24);
+
+	bit_duplicate(chstatus, &word1, &word2);
+
+	writel(	word1, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 8);
+	writel(	word2, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 12);
+
+	writel(	0, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 16);
+	writel(	0, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 20);
+}
+
+
+static irqreturn_t stb7100_converter_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+	unsigned long handled= IRQ_NONE;
+	pcm_hw_t *chip = dev_id;
+
+        /* Read and clear interrupt status */
+	spin_lock(&chip->lock);
+	val = readl(chip->pcm_converter + AUD_SPDIF_PR_INT_STA);
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+	spin_unlock(&chip->lock);
+
+	if(val & PR_SOFT_RESET_INT_ENABLE){
+		software_reset_complete = 1;
+		wake_up(&software_reset_wq);
+		handled = IRQ_HANDLED;
+	}
+	if(val & PR_UNDERFLOW_INT){
+		printk("%s I2S Converter PLayer FIFO Underflow detected\n",__FUNCTION__);
+		handled = IRQ_HANDLED;
+	}
+	if(val & PR_I2S_FIFO_OVERRUN_INT){
+		printk("%s I2S Converter PLayer FIFO Overflow detected\n",__FUNCTION__);
+		handled = IRQ_HANDLED;
+	}
+	if(val & PR_AUDIO_SAMPLES_FULLY_READ_INT){
+            /* Inform higher layer that we have completed a period */
+		snd_pcm_period_elapsed(chip->current_substream);
+		handled =IRQ_HANDLED;
+	}
+	return handled;
+}
+
+static void stb7100_converter_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	writel((chip->pcmplayer_control|PCMP_ON), chip->pcm_player+STM_PCMP_CONTROL);
+}
+
+static void stb7100_converter_pause_playback(snd_pcm_substream_t *substream)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+}
+
+static void stb7100_converter_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) & ~PR_CFG_DEVICE_ENABLE;
+	writel(reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+	writel((reg|PR_CTRL_OFF), chip->pcm_converter+AUD_SPDIF_PR_SPDIF_CTRL);
+
+	reset_converter_fifo(substream);
+
+	writel(0         , chip->pcm_converter + AUD_SPDIF_PR_INT_EN);
+	writel(0xffffffff, chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+
+	/*
+	 * Stop PCM Player0 with mute, see the stm7100_pcm.c for an explanation
+	 */
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+	dma_stop_channel(chip->fdma_channel);
+	dma_params_free(&chip->dmap);
+}
+
+
+static void stb7100_converter_start_playback(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t     *chip = snd_pcm_substream_chip(substream);
+	unsigned long cfg_reg;
+	unsigned long ctrl_reg;
+	int res = 0;
+	/*
+	 * We appear to need to reset the PCM player otherwise we end up
+	 * with channel data sent to the wrong channels when starting up for
+	 * the second time.
+	 */
+	stb7100_reset_pcm_player(chip);
+
+	res=dma_xfer_list(chip->fdma_channel,&chip->dmap);
+	if(res !=0)
+		printk("%s FDMA_CH %d failed to start %d\n",__FUNCTION__,chip->fdma_channel,res);
+
+	cfg_reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) ;
+	ctrl_reg = readl(chip->pcm_converter +AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+
+	writel(ctrl_reg | PR_CTRL_AUDIO_DATA_MODE,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+	writel(cfg_reg  | PR_CFG_DEVICE_ENABLE, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	writel((chip->pcmplayer_control | PCMP_ON), chip->pcm_player + STM_PCMP_CONTROL);
+
+}
+
+static int stb7100_converter_program_player(snd_pcm_substream_t * substream)
+{
+	unsigned long cfg_reg = 0;
+	unsigned long ctl_reg = 0;
+	unsigned long interrupt_list = (PR_INTERRUPT_ENABLE             |
+					PR_SOFT_RESET_INT_ENABLE        |
+					PR_AUDIO_SAMPLES_FULLY_READ_INT);
+	unsigned long flags=0;
+
+	snd_pcm_runtime_t * runtime = substream->runtime;
+	pcm_hw_t          * chip    = snd_pcm_substream_chip(substream);
+	int val =0;
+
+	if(chip->fifo_check_mode)
+		interrupt_list |= (PR_I2S_FIFO_OVERRUN_INT | PR_UNDERFLOW_INT);
+
+	/*we only ever call from the stm7100_pcm program func,
+	 * therefore we assume we already own the chip lock*/
+	spin_lock_irqsave(&chip->lock,flags);
+	/*
+	 * Clear then enable the protocol converter interrupts.
+	 */
+	writel(0xffffffff,    chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+	writel(interrupt_list,chip->pcm_converter + AUD_SPDIF_PR_INT_EN);
+
+	cfg_reg = (PR_CFG_FIFO_ENABLE | PR_CFG_REQ_ACK_ENABLE);
+
+	if(runtime->format == SNDRV_PCM_FORMAT_S16_LE)
+	  cfg_reg |= PR_CFG_WORD_SZ_16BIT;
+	else
+	  cfg_reg |= PR_CFG_WORD_SZ_24BIT;
+
+	writel(cfg_reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	/*
+	 * Setup initial channel status data for the hardware mode and
+	 * program for the new data burst.
+	 */
+	chip->pending_spdif_control = chip->default_spdif_control;
+	iec60958_set_runtime_status(substream);
+	chip->iec60958_output_count = 0;
+
+	chip->current_spdif_control = chip->pending_spdif_control;
+	stb7100_converter_write_channel_status(chip);
+
+	val = 	chip->current_spdif_control.validity_l[0]        |
+	 	(chip->current_spdif_control.validity_l[1] <<8)  |
+	 	(chip->current_spdif_control.validity_l[2] <<16) |
+	 	(chip->current_spdif_control.validity_l[3] <<24);
+	/*TODO need a way to set up and expose the channel status/user & validity to the user*/
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_VALIDITY);
+
+	val = 	chip->current_spdif_control.user[0]        |
+		(chip->current_spdif_control.user[1] <<8)  |
+		(chip->current_spdif_control.user[2] <<16) |
+		(chip->current_spdif_control.user[3] <<24);
+
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_USER_DATA);
+
+	/*
+	 * These following writes refer to the IEC encoded mode - which is part
+	 * of the converter block but not implemented in the instance of the
+	 * 7100, so make sure it is all swithced off
+	 */
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PAUSE);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_DATA_BURST);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PA_PB);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PC_PD);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CL1);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CR1);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_SUV);
+
+	/*
+	 * Setup the control register, but don't start it all of just yet.
+	 */
+	ctl_reg   = PR_CTRL_SW_STUFFING | PR_CTRL_16BIT_DATA_NOROUND | PR_CTRL_OFF;
+	ctl_reg  |= SPDIF_FSYNTH_DIVIDE32_128;
+        ctl_reg  |= ((runtime->period_size * 2) << PR_CTRL_SAMPLES_SHIFT);
+
+	writel(ctl_reg, chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+	spin_unlock_irqrestore(&chip->lock,flags);
+	/*this reset will cause us to de-schedule, then well get an IRQ when
+	 * the reset has completed, so make sure we dont hold any locks by now*/
+	reset_pcm_converter(substream);
+	return 0;
+}
+
+
+static int stb7100_converter_free(pcm_hw_t *card)
+{
+	writel(0, card->pcm_converter + AUD_SPDIF_PR_CFG );
+	writel(0, card->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+	writel(PCMP_OFF, card->pcm_player + STM_PCMP_CONTROL);
+
+	if(card->fdma_channel)
+		free_dma(card->fdma_channel);
+
+	iounmap(card->pcm_clock_reg);
+	iounmap(card->out_pipe);
+	iounmap(card->pcm_player);
+	iounmap(card->pcm_converter);
+
+	if(card->irq > 0)
+		free_irq(card->irq,(void *)card);
+
+	kfree(card);
+	return 0;
+}
+
+
+static stm_playback_ops_t stb7100_converter_ops = {
+	.free_device      = stb7100_converter_free,
+	.open_device      = stb7100_pcm_open,
+	.program_hw       = stb7100_pcm_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_converter_start_playback,
+	.stop_playback    = stb7100_converter_stop_playback,
+	.pause_playback   = stb7100_converter_pause_playback,
+	.unpause_playback = stb7100_converter_unpause_playback
+};
+
+
+static int stb7100_create_converter_device(pcm_hw_t *in_chip,snd_card_t  **this_card,int dev)
+{
+	int err = 0;
+	int irq = linux_pcm_irq[dev];
+	pcm_hw_t * chip = in_chip;
+
+	*this_card = snd_card_new(index[card_list[dev].major],id[card_list[dev].major], THIS_MODULE, 0);
+        if (this_card == NULL){
+      		printk(" cant allocate new card of %d\n",card_list[dev].major);
+      		return -ENOMEM;
+        }
+
+	chip->fdma_channel =-1;
+	chip->card_data = &card_list[dev];
+	spin_lock_init(&chip->lock);
+
+        chip->card          = *this_card;
+	chip->irq           = -1;
+	chip->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	chip->out_pipe      = ioremap(FDMA2_BASE_ADDRESS,0);
+
+	strcpy((*this_card)->shortname, "STb7100_CNV");
+	strcpy((*this_card)->longname,  "STb7100_CNV");
+	sprintf((*this_card)->driver,   "%d",chip->card_data->major);
+        /*
+         * In this case we need the base address of pcm0 for the player +
+         * the base address of the IEC60958 device for the conversion block
+         */
+	chip->pcm_player    = ioremap(pcm_base_addr[0],0);
+	chip->pcm_converter = ioremap(pcm_base_addr[chip->card_data->major],0);
+	chip->hw            = stb7100_converter_hw;
+	chip->oversampling_frequency = 128;
+
+	chip->playback_ops  = &stb7100_converter_ops;
+
+	if(request_irq(irq, stb7100_converter_interrupt, SA_INTERRUPT, "STB7100_CNV",(void*)chip)){
+               		printk(">>> failed to get IRQ %d\n",irq);
+	                stb7100_converter_free(chip);
+        	        return -EBUSY;
+        }
+
+	chip->irq = irq;
+
+	iec60958_default_channel_status(chip);
+
+	/*
+	 * For the converter device we rely on the PCM0 clock setup to drive
+	 * the IEC block.
+	 */
+	set_default_device_clock(chip);
+
+	stb7100_reset_pcm_player(chip);
+
+	if((err = snd_card_pcm_allocate(chip,chip->card_data->minor,(*this_card)->longname)) < 0) {
+        	printk(" >>> Failed to create PCM-SPDIF converter Stream\n");
+        	stb7100_converter_free(chip);
+    	}
+
+    	if ((err = snd_iec60958_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if((err = snd_generic_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if((err = snd_device_new((*this_card), SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0){
+        	printk(">>> creating sound device :%d,%d failed\n",chip->card_data->major,chip->card_data->minor);
+        	stb7100_converter_free(chip);
+		return err;
+    	}
+
+	if((err = snd_card_register((*this_card))) < 0){
+        	stb7100_converter_free(chip);
+		return err;
+    	}
+    	return 0;
+}
+
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/stb7100_pcmin.c linux-2.6.23.1-stm/sound/stm/stb7100_pcmin.c
--- linux-2.6.23.1/sound/stm/stb7100_pcmin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/stb7100_pcmin.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,396 @@
+/*
+ *  STb710x Digitial PCM Reader Sound Driver
+ *  Copyright (c)   (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+
+static snd_pcm_hardware_t stb7100_pcmin_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID),
+
+	.formats =	SNDRV_PCM_FMTBIT_S32_LE,
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 |
+			 SNDRV_PCM_RATE_96000 |
+			 SNDRV_PCM_RATE_192000 ),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 192000,
+	.channels_min	  = 2,
+	.channels_max	  = 2,
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,2),
+	.period_bytes_min = FRAMES_TO_BYTES(1,2),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,2),
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+void stb7100_reset_pcmin(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	writel(1,chip->pcm_player);
+	writel(0,chip->pcm_player);
+}
+
+static u32 get_target_time(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	u32 period_samples = bytes_to_samples(runtime,frames_to_bytes(runtime,runtime->period_size))/ runtime->channels;
+	u32 rate =runtime->rate;
+	/*TODO :- we may suffer from rounding err for 44.1 case,
+	 * but the 1ms overhead obviates the discrepency. */
+	u32 period_data =  (rate / period_samples);
+	u32 period_time = (PCMIN_MILLIS_PSEC / period_data) + PCMIN_TMR_OVRHD_MILLIS;
+	return  ( jiffies + ((period_time  * HZ)/ PCMIN_MILLIS_PSEC)) ;
+}
+
+static void stb7100_pcmin_timer_irq(unsigned long handle)
+{
+	snd_pcm_substream_t *substream;
+	pcm_hw_t          *chip;
+	snd_pcm_runtime_t *runtime;
+	u32 pos,irqflags;
+	static u32 last_jiff;
+
+	substream =(snd_pcm_substream_t *) handle;
+	runtime = substream->runtime;
+	chip     = snd_pcm_substream_chip(substream);
+
+	spin_lock_irqsave(&chip->lock,irqflags);
+	if(chip->pcmin.timer_halt){
+		chip->pcmin.timer_halt=0;
+		return;
+	}
+
+	pos = substream->runtime->dma_bytes - get_dma_residue(chip->fdma_channel);
+	if(pos < chip->pcmin.last_fr)
+		chip->pcmin.fr_delta = pos  + (snd_pcm_lib_buffer_bytes(substream) - chip->pcmin.last_fr);
+	else
+		chip->pcmin.fr_delta  += (pos - chip->pcmin.last_fr);
+
+	chip->pcmin.last_fr = pos;
+
+	if(chip->pcmin.fr_delta >=  frames_to_bytes(runtime,runtime->period_size)){
+		snd_pcm_period_elapsed(substream);
+		chip->pcmin.fr_delta=0;
+	}
+	else printk("%s Period Not elapsed\n 	Frame delta Actual %x expected %x\n	Timer delta Actual %ld expected %ld\n",
+			__FUNCTION__,
+			chip->pcmin.fr_delta,
+			frames_to_bytes(runtime,runtime->period_size),
+			((jiffies - last_jiff) *1000) /HZ,
+			get_target_time(substream)-jiffies);
+
+	/*wait for *about a sample period in time*/
+	mod_timer(&chip->pcmin.period_timer,get_target_time(substream));
+	last_jiff = jiffies;
+	spin_unlock_irqrestore(&chip->lock,irqflags);
+}
+
+static void stb7100_pcmin_stop_read(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long irqflags;
+
+
+	if(chip->fifo_check_mode)
+		writel(PCMIN_INT_OVF, chip->pcm_player + STM_PCMIN_ITS_EN_CLR);
+
+	dma_stop_channel(chip->fdma_channel);
+	dma_params_free(&chip->dmap);
+	chip->dma_req = NULL; /* free'd by the above call to dma_params_free() */
+
+	spin_lock_irqsave(&chip->lock,irqflags);
+	writel(AUD_PCMIN_CTRL_OFF_MODE,chip->pcm_player + STM_PCMIN_CTRL);
+	stb7100_reset_pcmin(substream);
+	chip->pcmin.timer_halt=1;
+	spin_unlock_irqrestore(&chip->lock,irqflags);
+
+}
+
+static void stb7100_pcmin_start_read(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long irqflags=0;
+	int res = dma_xfer_list(chip->fdma_channel,&chip->dmap);
+	if(res !=0)
+		printk("%s FDMA_CH %d failed to start %d\n",__FUNCTION__,chip->fdma_channel,res);
+
+	writel(chip->pcmplayer_control | AUD_PCMIN_CTRL_PCM_MODE,chip->pcm_player + STM_PCMIN_CTRL);
+	stb7100_reset_pcmin(substream);
+
+	if(chip->fifo_check_mode)
+		writel(PCMIN_INT_OVF | PCMIN_INT_VSYNC	,chip->pcm_player + STM_PCMIN_ITS_EN);
+
+	spin_lock_irqsave(&chip->lock,irqflags);
+
+	chip->pcmin.fr_delta =0;
+	chip->pcmin.last_fr =0;
+	chip->pcmin.period_timer.data = (u32)substream;
+	chip->pcmin.period_timer.function = &stb7100_pcmin_timer_irq;
+	mod_timer(&(chip->pcmin.period_timer),get_target_time(substream));
+	chip->pcmin.timer_halt=0;
+	spin_unlock_irqrestore(&chip->lock,irqflags);
+}
+
+
+
+static irqreturn_t stb7100_pcmin_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+	pcm_hw_t *stb7100 = dev_id;
+	irqreturn_t res =IRQ_NONE;
+
+	/* Read and clear interrupt status */
+	spin_lock(&stb7100->lock);
+	val =  readl(stb7100->pcm_player + STM_PCMIN_ITS);
+	writel(val,stb7100->pcm_player + STM_PCMIN_ITS_CLR);
+	spin_unlock(&stb7100->lock);
+
+	if(unlikely(val & PCMIN_INT_OVF) == PCMIN_INT_OVF){
+		printk("%s PCM Reader FIFO Overflow detected\n",__FUNCTION__);
+		res=IRQ_HANDLED;
+	}
+	return res;
+}
+
+static struct stm_dma_req_config pcmin_req_config = {
+	.rw		= REQ_CONFIG_READ,
+	.opcode		= REQ_CONFIG_OPCODE_4,
+	.count		= 1,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 0, /* This was 1 for 7100, do we need to fix? */
+};
+
+static int stb7100_pcmin_program_fdma(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t          *chip    = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long irqflags=0;
+	int err=0;
+
+	if(!chip->out_pipe || ! chip->pcm_player)
+		return -EINVAL;
+
+	spin_lock_irqsave(&chip->lock,irqflags);
+
+	if (chip->dma_req == NULL) {
+		chip->dma_req = dma_req_config(chip->fdma_channel, chip->fdma_req, &pcmin_req_config);
+		if (chip->dma_req == NULL) {
+			spin_unlock_irqrestore(&chip->lock,irqflags);
+			return -EBUSY;
+		}
+	}
+
+	dma_params_init(&chip->dmap,
+			MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	dma_params_DIM_0_x_1(&chip->dmap);
+
+	dma_params_req(&chip->dmap, chip->dma_req);
+
+	dma_params_addrs(&chip->dmap,
+			virt_to_phys(chip->pcm_player+STM_PCMP_DATA_FIFO),
+			runtime->dma_addr,
+			snd_pcm_lib_buffer_bytes(substream));
+
+	dma_compile_list(chip->fdma_channel, &chip->dmap, GFP_ATOMIC);
+	spin_unlock_irqrestore(&chip->lock,irqflags);
+	return err;
+}
+
+static int stb7100_program_pcmin(snd_pcm_substream_t *substream)
+{
+
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long ctrlreg, fmtreg;
+
+	/*The real SLCK format is to set data stable on falling edge*/
+	fmtreg= AUD_PCMIN_FMT_ORDER_MSB | AUD_PCMIN_FMT_ALIGN_LR |
+		AUD_PCMIN_FMT_PADDING_ON |  AUD_PCMIN_FMT_SLCK_EDGE_RISING |
+		AUD_PCMIN_FMT_LR_POLARITY_HIGH | AUD_PCMIN_FMT_DATA_SZ_24 |
+		AUD_PCMIN_FMT_NBIT_32 ;
+
+	ctrlreg =  (runtime->period_size * runtime->channels) << AUD_PCMIN_CTRL_SAMPLES_SHIFT;
+	ctrlreg = AUD_PCMIN_CTRL_DATA_ROUND | AUD_PCMIN_CTRL_MEM_FMT_16_0;
+	writel(fmtreg,chip->pcm_player + STM_PCMIN_FMT	);
+	chip->pcmplayer_control = ctrlreg;
+	return 0;
+}
+
+static int stb7100_pcmin_program_hw(snd_pcm_substream_t *substream)
+{
+	int err=0;
+	if((err = stb7100_program_pcmin(substream)) < 0)
+		return err;
+
+	if((err = stb7100_pcmin_program_fdma(substream)) < 0)
+		return err;
+	return 0;
+}
+
+static int stb7100_pcmin_open(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	int err=0;
+	const char * dmac_id =STM_DMAC_ID;
+	const char * lb_cap_channel = STM_DMA_CAP_LOW_BW;
+	const char * hb_cap_channel = STM_DMA_CAP_HIGH_BW;
+
+	if(chip->fdma_channel <0){
+		err=request_dma_bycap(&dmac_id,&hb_cap_channel,"STB710x_PCMIN_DMA");
+		if(err <0){
+			err=request_dma_bycap(&dmac_id,&lb_cap_channel,	"STB710x_PCMIN_DMA");
+			if(err <0){
+				printk(" %s error in DMA request %d\n",__FUNCTION__,err);
+				return err;
+			}
+		}
+		chip->fdma_channel= err;
+		init_timer(&chip->pcmin.period_timer);
+		chip->pcmin.period_timer.data = (u32)substream;
+		chip->pcmin.period_timer.function = &stb7100_pcmin_timer_irq;
+		add_timer(&chip->pcmin.period_timer);
+	}
+	return 0;
+}
+
+static int stb7100_pcmin_free(pcm_hw_t *card)
+{
+	del_timer(&card->pcmin.period_timer);
+	stb7100_pcm_free(card);
+	return 0;
+}
+
+
+static stm_playback_ops_t stb7100_pcmin_ops = {
+	.free_device      = stb7100_pcmin_free,
+	.open_device      = stb7100_pcmin_open,
+	.program_hw       = stb7100_pcmin_program_hw,
+
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_pcmin_start_read,
+	.stop_playback    = stb7100_pcmin_stop_read,
+};
+
+static struct platform_device *pcmin_platform_device;
+
+static int __init stb710x_alsa_pcmin_probe(struct device *dev)
+{
+	pcmin_platform_device = to_platform_device(dev);
+	return 0;
+}
+
+static struct device_driver alsa_pcmin_driver = {
+	.name  = "710x_ALSA_PCMIN",
+	.owner = THIS_MODULE,
+	.bus   = &platform_bus_type,
+	.probe = stb710x_alsa_pcmin_probe,
+};
+
+static struct device alsa_pcmin_device = {
+	.bus_id="alsa_710x_pcmin",
+	.driver = &alsa_pcmin_driver,
+	.parent   = &platform_bus ,
+	.bus      = &platform_bus_type,
+};
+
+
+static int __init snd_pcmin_stb710x_probe(pcm_hw_t *in_chip,snd_card_t *card,int dev)
+{
+	unsigned err=0;
+	pcm_hw_t * chip={0};
+
+	static snd_device_ops_t ops = {
+    		.dev_free = snd_pcm_dev_free,
+	};
+	if(driver_register(&alsa_pcmin_driver)==0){
+		if(device_register(&alsa_pcmin_device)!=0)
+			return -ENOSYS;
+	}
+	else return -ENOSYS;
+
+	if((chip = kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+        	return -ENOMEM;
+
+	spin_lock_init(&chip->lock);
+	chip->irq 		= -1;
+	chip->fdma_channel 	= -1;
+
+	chip->card         	= card;
+	chip->card_data = &card_list[dev];
+
+	chip->hw           = stb7100_pcmin_hw;
+	chip->playback_ops  = &stb7100_pcmin_ops;
+
+	chip->oversampling_frequency = 256;
+	chip->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	chip->out_pipe      = ioremap(FDMA2_BASE_ADDRESS, 0);
+	chip->pcm_player    = ioremap(PCMIN_BASE,0);
+
+	if(request_irq(	LINUX_PCMREADER_ALLREAD_IRQ,
+			stb7100_pcmin_interrupt,
+			SA_INTERRUPT,
+			"STB7100_PCMIN",
+			(void*)chip)){
+
+               	printk(">>> failed to get IRQ %d\n",LINUX_PCMREADER_ALLREAD_IRQ);
+	        stb7100_pcm_free(chip);
+        	return -EBUSY;
+        }
+	else chip->irq = LINUX_PCMREADER_ALLREAD_IRQ;
+
+	if((err = snd_card_pcm_allocate(chip,chip->card_data->minor,card->longname)) < 0){
+        	printk(">>> Failed to create PCM stream \n");
+	        stb7100_pcm_free(chip);
+	}
+
+	if((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,chip, &ops)) < 0){
+		printk(">>> creating sound device :%d,%d failed\n",
+			chip->card_data->major,chip->card_data->minor);
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_card_register(card)) < 0) {
+		printk("%s snd_card_registration() failed !\n",__FUNCTION__);
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if(register_platform_driver(	pcmin_platform_device,
+					chip,
+					card_list[PCMIN_DEVICE].major)!=0){
+
+		printk("%s Error Registering PCM Reader\n",__FUNCTION__);
+		return -ENODEV;
+	}
+	in_chip = chip;
+	return 0;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/stb7100_snd.h linux-2.6.23.1-stm/sound/stm/stb7100_snd.h
--- linux-2.6.23.1/sound/stm/stb7100_snd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/stb7100_snd.h	2007-11-01 12:00:41.000000000 +0000
@@ -0,0 +1,375 @@
+/*
+ *  STb7100 ALSA Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef STB7100_SND_H_
+#define STB7100_SND_H_
+
+#define FDMA2_BASE_ADDRESS			0x19220000
+#define AUD_CFG_BASE				0x19210000
+#define SPDIF_BASE				0x18103000
+#define PCMP0_BASE				0x18101000
+#define PCMP1_BASE				0x18101800
+#define PCM0_CONVERTER_BASE     		0x18103800
+#define PCMIN_BASE				0x18102000
+
+#define FDMA2_BASE_ADDRESS			0x19220000
+#define AUD_CFG_BASE				0x19210000
+
+#define LINUX_PCMPLAYER0_ALLREAD_IRQ		144
+#define LINUX_PCMPLAYER1_ALLREAD_IRQ		145
+#define LINUX_SPDIFPLAYER_ALLREAD_IRQ		147
+#define LINUX_SPDIFCONVERTER_ALLREAD_IRQ	142
+#define	LINUX_PCMREADER_ALLREAD_IRQ		146
+
+/*
+ * Thankfully the block register offsets for PCM0/1 & spdif
+ * are the same, only with a differing base address.
+ *
+ * Alas this is not the case for the Fsynth's, so we must specify those seperately
+ */
+#define STM_PCMP_DATA_FIFO			0x04
+#define STM_PCMP_IRQ_STATUS			0x08
+#define STM_PCMP_IRQ_ENABLE			0x10
+#define STM_PCMP_ITS_CLR 			0x0C
+#define STM_PCMP_IRQ_EN_SET			0x14
+#define STM_PCMP_IRQ_EN_CLR			0x18
+#define STM_PCMP_CONTROL        		0x1C
+#define STM_PCMP_STATUS         		0x20
+#define STM_PCMP_FORMAT         		0x24
+
+/*
+ * The STb7100 PCM Player has an interrupt status, which inconveniently doesn't
+ * have the bits laid out in the same position as the PCM Player Status register.
+ */
+#define PCMP_INT_STATUS_ALLREAD			(1<<1)
+#define PCMP_INT_STATUS_UNDERFLOW		(1<<0)
+
+
+#define AUD_FSYN0_MD				0x10
+#define AUD_FSYN0_PE 				0x14
+#define AUD_FSYN0_SDIV				0x18
+#define AUD_FSYN0_PROG_EN      			0x1c
+
+#define AUD_FSYN1_MD				0x20
+#define AUD_FSYN1_PE				0x24
+#define AUD_FSYN1_SDIV				0x28
+#define AUD_FSYN1_PROG_EN			0x2c
+
+#define AUD_FSYN2_MD				0x30
+#define AUD_FSYN2_PE 				0x34
+#define AUD_FSYN2_SDIV				0x38
+#define AUD_FSYN2_PROG_EN			0x3c
+
+
+/*spdif control reg operators*/
+
+#define SPDIF_OFF				0x00
+#define SPDIF_MUTE_NULL_DATA			0x01
+#define SPDIF_MUTE_BURST			0x02
+#define SPDIF_PCM_ON				0x03
+#define SPDIF_ENCODED_ON			0x04
+#define SPDIF_IDLE 				(1L<<3)
+#define SPDIF_BIT16_DATA_ROUND 			(1L<<4)
+#define SPDIF_BIT16_DATA_NOROUND 		(0L<<4)
+#define SPDIF_FSYNTH_DIVIDE32_1			(0L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_128		(1L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_192		(6L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_256		(2L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_384		(3L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_512		(4L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_784		(6L<<5)
+#define SPDIF_BYTE_SWAP 			(1L<<13)
+#define SPDIF_HW_STUFFING 			(1L<<14)
+#define SPDIF_SW_STUFFING 			(0L<<14)
+#define SPDIF_SAMPLES_SHIFT			15
+
+
+#define AUD_SPDIF_STA 				0x20
+#define AUD_SPDIF_PA_PB 			0x24
+#define AUD_SPDIF_PC_PD 			0x28
+#define AUD_SPDIF_CL1   			0x2c/*left subframe status 31-0*/
+#define AUD_SPDIF_CR1   			0x30 /*right subframe status 31-0*/
+#define AUD_SPDIF_CL2_CR2_UV 			0x34
+#define AUD_SPDIF_PAU_LAT 			0x38
+#define AUD_SPDIF_FRA_LEN_BST 			0x3c
+
+
+/*spdif int generation vals*/
+#define ENABLE_INT_UNDERFLOW 			(1L<<0)
+#define ENABLE_INT_EODBURST 			(1L<<1)
+#define ENABLE_INT_EOBLOCK 			(1L<<2)
+#define ENABLE_INT_EOLATENCY 			(1L<<3)
+#define ENABLE_INT_EOPD				(1L<<4)
+#define ENABLE_INT_NSAMPLE 			(1L<<5)
+
+#define SPDIF_INT_STATUS_UNF			(1L<<0)
+#define SPDIF_INT_STATUS_EODBURST  		(1L<<1)
+#define SPDIF_INT_STATUS_EOBLOCK 		(1L<<2)
+#define SPDIF_INT_STATUS_EOLATENCY 		(1L<<3)
+#define SPDIF_INT_STATUS_EOPD	 		(1L<<4)
+#define SPDIF_INT_STATUS_ALLREAD 		(1L<<5)
+
+
+#define MPEG_DECODE_LAT_48KHZ 21 /*really 20.9 ms*/
+#define MPEG_DECODE_LAT_441KHZ 23 /*really 22.75 ms*/
+#define MPEG_DECODE_LAT_32KHZ 31 /*really 30.35 ms*/
+
+#define TIME_TO_FRAMES(freq,time)((time * freq) /1000)
+
+#define  IEC61937_PA  		 0xF872
+#define  IEC61937_PB  		 0x4E1F
+#define  IEC61937_DTS_TYPE_1	 11
+#define  IEC61937_DTS_TYPE_2	 12
+#define  IEC61937_DTS_TYPE_3	 13
+#define  IEC61937_AC3_STREAM     0x1
+
+#define DUMP_CONVERTER_STATE(chip) (\
+	printk("%s\n\
+	AUD_SPDIF_PR_CFG %x\n\
+	AUD_SPDIF_PR_STAT %x\n\
+	AUD_SPDIF_PR_INT_EN %x\n\
+	AUD_SPDIF_PR_INT_STA %x\n\
+	AUD_SPDIF_PR_INT_CLR %x\n\
+	AUD_SPDIF_PR_VALIDITY %x\n\
+	AUD_SPDIF_PR_USER_DATA %x\n\
+	AUD_SPDIF_PR_CHANNEL_STA_BASE %x\n\
+	AUD_SPDIF_PR_SPDIF_CTRL	%x\n\
+	AUD_SPDIF_PR_SPDIF_STA	%x\n\
+	AUD_SPDIF_PR_SPDIF_PAUSE %x\n\
+	AUD_SPDIF_PR_SPDIF_DATA_BURST %x\n\
+	AUD_SPDIF_PR_SPDIF_PA_PB %x\n\
+	AUD_SPDIF_PR_SPDIF_PC_PD %x\n\
+	AUD_SPDIF_PR_SPDIF_CL1	%x\n\
+	AUD_SPDIF_PR_SPDIF_CR1	%x\n\
+	AUD_SPDIF_PR_SPDIF_SUV	%x\n",\
+	__FUNCTION__,\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_CFG),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_STAT ),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_INT_EN),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_INT_STA),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_INT_CLR),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_VALIDITY ),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_USER_DATA),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_STA),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PAUSE),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_DATA_BURST),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PA_PB),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PC_PD),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CL1),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CR1	),\
+	(int)readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_SUV)));
+
+#define DUMP_SPDIF_STATE()(\
+	printk("%s\n\
+	AUD_SPDIF_RST  %x\n\
+	AUD_SPDIF_DATA %x\n\
+	AUD_SPDIF_ITS  %x\n\
+	AUD_SPDIF_ITS_CLR %x\n\
+	AUD_SPDIF_ITS_EN %x\n\
+	AUD_SPDIF_ITS_EN_SET %x\n\
+	AUD_SPDIF_ITS_EN_CLR %x\n\
+	AUD_SPDIF_CTL %x\n\
+	AUD_SPDIF_STA %x\n\
+	AUD_SPDIF_PA_PB %x\n\
+	AUD_SPDIF_PC_PD %x\n \
+	AUD_SPDIF_CL1 %x\n\
+	AUD_SPDIF_CR1 %x\n\
+	AUD_SPDIF_CL2CR2UV %x\n\
+	AUD_SPDIF_FRA_LEN_BST %x\n\
+	AUD_SPDIF_PAU_LAT %x \n",\
+		__FUNCTION__,\
+		(int)readl(chip->pcm_player+0x00),\
+		(int)readl(chip->pcm_player+STM_PCMP_DATA_FIFO),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_STATUS),\
+		(int)readl(chip->pcm_player+STM_PCMP_ITS_CLR ),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_ENABLE),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_SET),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_CLR),\
+		(int)readl(chip->pcm_player+STM_PCMP_CONTROL),\
+		(int)readl(chip->pcm_player+STM_PCMP_STATUS ),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PA_PB),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PC_PD),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CL1),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CR1),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CL2_CR2_UV),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_FRA_LEN_BST),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PAU_LAT)))
+
+#define DUMP_PCM_STATE(chip)(\
+	printk("%s\n\
+	STM_PCMP_RST %x\n\
+	STM_PCMP_DATA_FIFO %x\n\
+	STM_PCMP_IRQ_STATUS %x\n\
+	STM_PCMP_IRQ_ENABLE %x\n\
+	STM_PCMP_ITS_CLR  %x\n\
+	STM_PCMP_IRQ_EN_SET %x\n\
+	STM_PCMP_IRQ_EN_CLR %x\n\
+	STM_PCMP_CONTROL %x\n\
+	STM_PCMP_STATUS  %x\n\
+	STM_PCMP_FORMAT %x\n",\
+	__FUNCTION__,\
+	(int)readl(chip->pcm_player+0x00),\
+	(int)readl(chip->pcm_player+STM_PCMP_DATA_FIFO),\
+	(int)readl(chip->pcm_player+STM_PCMP_IRQ_STATUS),\
+	(int)readl(chip->pcm_player+STM_PCMP_IRQ_ENABLE),\
+	(int)readl(chip->pcm_player+STM_PCMP_ITS_CLR ),\
+	(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_SET),\
+	(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_CLR),\
+	(int)readl(chip->pcm_player+STM_PCMP_CONTROL),\
+	(int)readl(chip->pcm_player+STM_PCMP_STATUS ),\
+	(int)readl(chip->pcm_player+STM_PCMP_FORMAT )));
+
+#define DUMP_PCMIN(chip)( \
+	printk("%s\n %x PCMIN_ITS %x\n %x PCMIN_IT_EN %x\n %x PCMIN_CTRL %x\n %x \
+PCMIN_STA %x\n %x PCMIN_FMT %x\n %x AUD_IO_CTL %x\n %x IRQ_VECT_NR %x\n\n", \
+	__FUNCTION__, \
+	(int)chip->pcm_player + STM_PCMIN_ITS, \
+	(int)readl(chip->pcm_player + STM_PCMIN_ITS), \
+	(int)chip->pcm_player + STM_PCMIN_ITS_EN, \
+	(int)readl(chip->pcm_player + STM_PCMIN_ITS_EN), \
+	(int)chip->pcm_player + STM_PCMIN_CTRL, \
+	(int)readl(chip->pcm_player + STM_PCMIN_CTRL), \
+	(int)chip->pcm_player + STM_PCMIN_STA, \
+	(int)readl(chip->pcm_player + STM_PCMIN_STA), \
+	(int)chip->pcm_player + STM_PCMIN_FMT, \
+	(int)readl(chip->pcm_player + STM_PCMIN_FMT), \
+	(int)chip->pcm_clock_reg + AUD_IO_CTL_REG, \
+	(int)readl(chip->pcm_clock_reg + AUD_IO_CTL_REG), \
+	(int) ((chip->irq * 0x20) +0x200) ));
+/*
+ * I2S to SPDIF Protocol converter defines
+ */
+#define AUD_SPDIF_PR_CFG			0x00
+#define AUD_SPDIF_PR_STAT			0x04
+#define AUD_SPDIF_PR_INT_EN			0x08
+#define AUD_SPDIF_PR_INT_STA			0x0c
+#define AUD_SPDIF_PR_INT_CLR			0x10
+#define AUD_SPDIF_PR_VALIDITY			0x100
+#define AUD_SPDIF_PR_USER_DATA			0x104
+#define AUD_SPDIF_PR_CHANNEL_STA_BASE		0x108
+#define AUD_SPDIF_PR_SPDIF_CTRL			0x200
+#define AUD_SPDIF_PR_SPDIF_STA			0x204
+#define AUD_SPDIF_PR_SPDIF_PAUSE		0x208
+#define AUD_SPDIF_PR_SPDIF_DATA_BURST		0x20c
+#define AUD_SPDIF_PR_SPDIF_PA_PB		0x210
+#define AUD_SPDIF_PR_SPDIF_PC_PD		0x214
+#define AUD_SPDIF_PR_SPDIF_CL1			0x218
+#define AUD_SPDIF_PR_SPDIF_CR1			0x21c
+#define AUD_SPDIF_PR_SPDIF_SUV			0x220
+
+#define PR_CFG_DEVICE_ENABLE			(1L<<0)
+#define PR_CFG_CONV_SW_RESET			(1L<<1)
+#define PR_CFG_FIFO_ENABLE			(1L<<2)
+#define PR_CFG_WORD_SZ_16BIT			(0L<<3)
+#define PR_CFG_WORD_SZ_20BIT			(1L<<3)
+#define PR_CFG_WORD_SZ_24BIT			(2L<<3)
+#define PR_CFG_REQ_ACK_ENABLE			(1L<<5)
+
+
+#define PR_PD_PAUSE_BURST_INT			(1L<<31)
+#define PR_AUDIO_SAMPLES_FULLY_READ_INT		(1L<<22)
+#define PR_PD_DATA_BURST_INT			(1L<<21)
+#define PR_LATENCY_INT				(1L<<20)
+#define PR_EOBLOCK_INT				(1L<<19)
+#define PR_EODATABURST_INT			(1L<<18)
+#define PR_UNDERFLOW_INT			(1L<<17)
+#define PR_RUN_STOP_INT				(1L<<16)
+#define PR_I2S_FIFO_OVERRUN_INT			(1L<<8)
+#define PR_CHLL_STS_UNDERRUN_INT		(1L<<7)
+#define PR_CHLL_STS_EMPTY_INT			(1L<<6)
+#define PR_USER_DATA_UNDERRUN_INT		(1L<<5)
+#define PR_USER_DATA_EMPTY_INT			(1L<<4)
+#define PR_VALIDITY_UNDERRUN_INT		(1L<<3)
+#define PR_VALIDITY_EMPTY_INT			(1L<<2)
+#define PR_SOFT_RESET_INT_ENABLE		(1L<<1)
+#define PR_INTERRUPT_ENABLE			(1L<<0)
+
+
+#define PR_CTRL_OFF				0
+#define PR_CTRL_MUTE_PCM_NULL_DATA		1
+#define PR_CTRL_MUTE_PAUSE_BURST		2
+#define PR_CTRL_AUDIO_DATA_MODE			3
+#define PR_CTRL_16BIT_DATA_NOROUND		0
+#define PR_CTRL_16BIT_DATA_ROUND		(1L<<4)
+#define PR_CTRL_SW_STUFFING			0
+#define PR_CTRL_HW_STUFFING			(1L<<14)
+#define PR_CTRL_SAMPLES_SHIFT			15
+
+
+#define STM_PCMIN_HRST				0x00
+#define STM_PCMIN_DATA				0x04
+#define STM_PCMIN_ITS				0x08
+#define STM_PCMIN_ITS_CLR			0x0c
+#define STM_PCMIN_ITS_EN			0x10
+#define STM_PCMIN_ITS_EN_SET			0x14
+#define STM_PCMIN_ITS_EN_CLR			0x18
+#define STM_PCMIN_CTRL				0x1c
+#define STM_PCMIN_STA				0x20
+#define STM_PCMIN_FMT				0x24
+
+
+#define PCMIN_INT_OVF				(1<<0)
+#define PCMIN_INT_VSYNC				(1<<1)
+
+#define AUD_PCMIN_CTRL_SAMPLES_SHIFT		(1<<4)
+#define AUD_PCMIN_CTRL_MEM_FMT_16_16		(1<<2)
+#define AUD_PCMIN_CTRL_MEM_FMT_16_0		(0<<2)
+#define AUD_PCMIN_CTRL_NO_ROUND			(0<<3)
+#define AUD_PCMIN_CTRL_DATA_ROUND		(1<<3)
+#define AUD_PCMIN_CTRL_PCM_MODE			0x02
+#define AUD_PCMIN_CTRL_CD_MODE			0x00
+#define AUD_PCMIN_CTRL_OFF_MODE			0x03
+
+#define AUD_PCMIN_FMT_ORDER_MSB			(1<<7)
+#define AUD_PCMIN_FMT_ORDER_LSB			(0<<7)
+#define AUD_PCMIN_FMT_ALIGN_RL			(0<<6)
+#define AUD_PCMIN_FMT_ALIGN_LR			(1<<6)
+#define AUD_PCMIN_FMT_PADDING_ON		(0<<5)
+#define AUD_PCMIN_FMT_PADDING_OFF		(1<<5)
+#define AUD_PCMIN_FMT_SLCK_EDGE_RISING		(0<<4)
+#define AUD_PCMIN_FMT_SLCK_EDGE_FALLING		(1<<4)
+#define AUD_PCMIN_FMT_LR_POLARITY_HIGH		(1<<3)
+#define AUD_PCMIN_FMT_LR_POLARITY_LOW		(0<<3)
+#define AUD_PCMIN_FMT_DATA_SZ_24		(0<<1)
+#define AUD_PCMIN_FMT_DATA_SZ_18		(2<<1)
+#define AUD_PCMIN_FMT_DATA_SZ_20		(1<<1)
+#define AUD_PCMIN_FMT_DATA_SZ_16		(3<<1)
+#define AUD_PCMIN_FMT_NBIT_32			(0<<0)
+#define AUD_PCMIN_FMT_NBIT_16			(1<<0)
+
+#define AUD_PCMIN_STA_ALLREAD			1<<19
+#define AUD_PCMIN_STA_SAMPLES_MASK		0x1FFFC
+#define AUD_PCMIN_STA_RUNNING 			1
+
+#define PCMIN_TMR_OVRHD_MILLIS 	1
+#define PCMIN_MILLIS_PSEC		1000
+
+#endif /*STB7100_SND_H_*/
+
+static int snd_pcmin_stb710x_probe(pcm_hw_t *chip,snd_card_t *card,int dev);
+static int snd_spdif_stb710x_probe(pcm_hw_t **chip,snd_card_t **card,int dev);
+static int stb7100_create_converter_device(pcm_hw_t *chip,snd_card_t **this_card,int dev);
+
+static int stb7100_converter_program_player(snd_pcm_substream_t *substream);
+static void stb7100_reset_pcm_player(pcm_hw_t *chip);
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/stb7100_spdif.c linux-2.6.23.1-stm/sound/stm/stb7100_spdif.c
--- linux-2.6.23.1/sound/stm/stb7100_spdif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/stb7100_spdif.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,564 @@
+/*
+ *  STb710x SPDIF player setup
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <asm/dma.h>
+#include <linux/stm/stm-dma.h>
+#if (STM_USE_BIGPHYS_AREA == 0)
+#define SPDIF_MAX_FRAMES	((128*1024)/8)  /* <128k, max slab allocation */
+#else
+#define SPDIF_MAX_FRAMES	48000           /* 1s @ 48KHz */
+#endif
+
+/*
+ * Default HW template for SPDIF player.
+ */
+static snd_pcm_hardware_t stb7100_spdif_hw =
+{
+	.info =		(SNDRV_PCM_INFO_INTERLEAVED |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	(SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE),
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 48000,
+	.channels_min	  = 2,
+	.channels_max	  = 2,
+	.buffer_bytes_max = FRAMES_TO_BYTES(SPDIF_MAX_FRAMES,2),
+	.period_bytes_min = FRAMES_TO_BYTES(1,2),
+	.period_bytes_max = FRAMES_TO_BYTES(SPDIF_MAX_FRAMES,2),
+	.periods_min	  = 1,
+	.periods_max	  = SPDIF_MAX_FRAMES
+};
+
+
+static inline void reset_spdif_on(pcm_hw_t  *chip)
+{
+	writel(1,chip->pcm_player);
+}
+
+static inline void reset_spdif_off(pcm_hw_t  *chip)
+{
+	writel(0,chip->pcm_player);
+}
+
+static void stb7100_iec61937_deferred_unpause(pcm_hw_t * chip)
+{
+	spin_lock(&chip->lock);
+	writel(SPDIF_INT_STATUS_EODBURST ,chip->pcm_player +STM_PCMP_IRQ_EN_CLR);
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+	chip->iec61937.pause_count=0;
+	/*throw an xrun to flush the buffer of invalidated data bursts and re-align the
+	 * next burst with a block boundary*/
+	snd_pcm_kernel_ioctl(chip->current_substream, SNDRV_PCM_IOCTL_XRUN, NULL);
+}
+
+static irqreturn_t stb7100_spdif_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long int_status;
+	pcm_hw_t *stb7100 = dev_id;
+	irqreturn_t status =IRQ_NONE;;
+	/* Read and clear interrupt status */
+	spin_lock(&stb7100->lock);
+	int_status = readl(stb7100->pcm_player + STM_PCMP_IRQ_STATUS);
+	writel(int_status,stb7100->pcm_player + STM_PCMP_ITS_CLR);
+	spin_unlock(&stb7100->lock);
+
+	if((int_status & SPDIF_INT_STATUS_ALLREAD) == SPDIF_INT_STATUS_ALLREAD ){
+		snd_pcm_period_elapsed(stb7100->current_substream);
+		status =  IRQ_HANDLED;
+	}
+	if((int_status & SPDIF_INT_STATUS_UNF)==SPDIF_INT_STATUS_UNF) {
+		printk("%s SPDIF PLayer FIFO Underflow detected\n",__FUNCTION__);
+		status = IRQ_HANDLED;
+	}
+	if((int_status & SPDIF_INT_STATUS_EOLATENCY) == SPDIF_INT_STATUS_EOLATENCY){
+		status =  IRQ_HANDLED;
+	}
+	if((int_status & SPDIF_INT_STATUS_EODBURST) == SPDIF_INT_STATUS_EODBURST){
+		stb7100->iec61937.pause_count = ((stb7100->iec61937.pause_count+1)
+						%stb7100->iec61937.frame_size);
+		/*we have to wait until we have completed an entire iec91637 burst length
+		 * before we stop emitting bursts, so we have to wait for mod(iec61937_frame_size)*/
+		if((stb7100->iec61937.pause_count==0) && (stb7100->iec61937.unpause_flag==1)){
+			stb7100->iec61937.unpause_flag=0;
+			stb7100_iec61937_deferred_unpause(stb7100);
+		}
+		status =  IRQ_HANDLED;
+	}
+	return status;
+}
+
+
+static inline void stb7100_spdif_pause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if (chip->iec_encoding_mode != ENCODING_IEC60958) {
+		/*here we turn on iec61937 pause bursts, modulated by the
+		 * frames of latency value*/
+		chip->iec61937.pause_count = chip->iec60958_output_count;
+		chip->iec60958_output_count=0;
+		writel(chip->irq_mask | SPDIF_INT_STATUS_EODBURST,chip->pcm_player+STM_PCMP_IRQ_EN_SET);
+    	}
+	else{
+		 /*the SPDIF IP will always at least complete the next 192 frame
+		  * burst - this gives an audible delay between an analogue and digital
+		  * pause, so here we want to flush out that buffer, the only way to do this
+		  * is throw a reset.*/
+		 reset_spdif_on(chip);
+		 reset_spdif_off(chip);
+	}
+	spin_lock(&chip->lock);
+	writel((chip->pcmplayer_control|chip->iec61937.pause_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+
+}
+
+
+static inline void stb7100_spdif_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	/*we are doing pause burst, must count %frame_size*/
+	if(chip->iec_encoding_mode != ENCODING_IEC60958){
+		/*first we need to check if pause burst are enable,
+		 * otherwise we will deadlock here
+		 * */
+		if(readl(chip->pcm_player+STM_PCMP_IRQ_ENABLE) & ENABLE_INT_EODBURST){
+			chip->iec61937.unpause_flag=1;
+			return;
+		}
+	}
+
+	spin_lock(&chip->lock);
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static inline void stb7100_spdif_start_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	dma_xfer_list(chip->fdma_channel,&chip->dmap);
+	spin_lock(&chip->lock);
+	reset_spdif_off(chip);
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),chip->pcm_player + STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static inline void stb7100_spdif_stop_playback(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	spin_lock(&chip->lock);
+	writel(0,chip->pcm_player+STM_PCMP_CONTROL);
+	reset_spdif_on(chip);
+	spin_unlock(&chip->lock);
+	dma_stop_channel(chip->fdma_channel);
+	dma_params_free(&chip->dmap);
+}
+
+
+static void stb7100_spdif_set_iec_mode(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned int decode_lat=0;
+	unsigned int rate =substream->runtime->rate;
+
+	switch(	chip->iec_encoding_mode){
+
+		case ENCODING_IEC61937_AC3:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep =3;
+			chip->iec61937.latency=256;
+			chip->iec61937.frame_size=1536;
+			break;
+		case ENCODING_IEC61937_DTS_1:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=768;
+			chip->iec61937.frame_size=512;
+			break;
+		case ENCODING_IEC61937_DTS_2:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=1280;
+			chip->iec61937.frame_size=1024;
+			break;
+		case ENCODING_IEC61937_DTS_3:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=2304;
+			chip->iec61937.frame_size=2048;
+			break;
+			{
+		case ENCODING_IEC61937_MPEG_384_FRAME:
+			chip->iec61937.frame_size = 384;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_1152_FRAME:
+			chip->iec61937.frame_size = 1152;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_1024_FRAME:
+			chip->iec61937.frame_size = 1024;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_2304_FRAME:
+			chip->iec61937.frame_size = 2304;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_768_FRAME:
+			chip->iec61937.frame_size = 768;
+			/*fallthrough*/
+generic_mpeg_encoding:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 32;
+			switch(rate){
+				case 32000:
+					decode_lat = MPEG_DECODE_LAT_32KHZ;
+					break;
+				case 44100:
+					decode_lat = MPEG_DECODE_LAT_441KHZ;
+					break;
+				case 48000:
+					decode_lat = MPEG_DECODE_LAT_48KHZ;
+					break;
+				default:
+					printk("%s Unsupported Sample Freq\n",__FUNCTION__);
+					break;
+			}
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+			}
+		case ENCODING_IEC61937_MPEG_2304_FRAME_LSF:
+			chip->iec61937.frame_size=2304;
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 64;
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+		case ENCODING_IEC61937_MPEG_768_FRAME_LSF:
+			chip->iec61937.frame_size=768;
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 64;
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+		default:
+			printk("%s unrecognised IEC61937 mode\n",__FUNCTION__);
+			/*fallthorugh*/
+		case ENCODING_IEC60958:
+			chip->iec61937.pause_mode=SPDIF_MUTE_NULL_DATA;
+			chip->iec61937.mute_rep =1;
+			chip->iec61937.latency=256;
+			break;
+	}
+}
+
+
+static int stb7100_program_spdifplayer(snd_pcm_substream_t *substream){
+
+	unsigned long reg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	u32 val=0;
+	unsigned long flags=0;
+	u32 irq_enable = ENABLE_INT_NSAMPLE;
+
+	reg =(runtime->period_size * runtime->channels) << SPDIF_SAMPLES_SHIFT;
+	reg |= SPDIF_SW_STUFFING | SPDIF_BIT16_DATA_NOROUND;
+
+	if(chip->fifo_check_mode)
+		irq_enable |= SPDIF_INT_STATUS_UNF;
+
+	spin_lock_irqsave(&chip->lock,flags);
+	switch(chip->oversampling_frequency)
+	{
+		case 128:
+			reg |= SPDIF_FSYNTH_DIVIDE32_128;
+			break;
+		case 256:
+			reg |= SPDIF_FSYNTH_DIVIDE32_256;
+			break;
+		default:
+			printk("stb7100_program_spdifplayer: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+			break;
+	}
+
+	reset_spdif_on(chip);
+	reset_spdif_off(chip);
+
+	/*
+	 * Setup channel status bits for the hardware mode and prepare for
+	 * starting a new data burst. Also setup the hardware pause burst
+	 * registers with the channel status as well.
+	 */
+	chip->pending_spdif_control = chip->default_spdif_control;
+	iec60958_set_runtime_status(substream);
+	chip->iec60958_output_count = 0;
+	stb7100_spdif_set_iec_mode(substream);
+
+	val = chip->pending_spdif_control.channel.status[0]	   |
+	      (chip->pending_spdif_control.channel.status[1] <<8)  |
+	      (chip->pending_spdif_control.channel.status[2] <<16) |
+	      (chip->pending_spdif_control.channel.status[3] <<24);
+
+	writel(val, chip->pcm_player + AUD_SPDIF_CL1);
+	writel(val, chip->pcm_player + AUD_SPDIF_CR1);
+
+	val = chip->pending_spdif_control.channel.status[4];
+	val |= (val << 8); /* Right channel status always = left channel status */
+	writel(val, chip->pcm_player + AUD_SPDIF_CL2_CR2_UV);
+
+	/*enable the latency irq*/
+	if(get_spdif_syncing_status()){
+		irq_enable |= ENABLE_INT_EOLATENCY;
+		chip->spdif_player_mode = SPDIF_ENCODED_ON;
+	}
+	if(chip->iec_encoding_mode != ENCODING_IEC60958){
+
+		int pause_data_type=-0;
+		reg |= SPDIF_HW_STUFFING;
+		switch(chip->iec_encoding_mode){
+			case ENCODING_IEC61937_AC3:
+				pause_data_type	= IEC61937_AC3_STREAM;
+				break;
+			case ENCODING_IEC61937_DTS_1:
+				pause_data_type	= IEC61937_DTS_TYPE_1;
+				break;
+			case ENCODING_IEC61937_DTS_2:
+				pause_data_type= IEC61937_DTS_TYPE_2;
+				break;
+			case ENCODING_IEC61937_DTS_3:
+				pause_data_type= IEC61937_DTS_TYPE_3;
+				break;
+			default:
+				printk("%s Uncrecognised Encoded Data Stream %d\n",
+					__FUNCTION__,chip->iec_encoding_mode);
+				break;
+		}
+		val =( 1 <<16)  | (chip->iec61937.mute_rep & 0x0000ffff);
+		writel(val,chip->pcm_player + AUD_SPDIF_FRA_LEN_BST);
+
+		val = (IEC61937_PA <<16)| IEC61937_PB ;
+		writel(val ,chip->pcm_player +AUD_SPDIF_PA_PB );
+
+		val = 	(pause_data_type <<16) | chip->iec61937.mute_rep;
+		writel(val,chip->pcm_player +AUD_SPDIF_PC_PD);
+
+		chip->spdif_player_mode = SPDIF_ENCODED_ON;
+	}
+	else{
+		reg |= SPDIF_SW_STUFFING;
+		chip->spdif_player_mode =SPDIF_ENCODED_ON;
+	}
+
+	val =((chip->iec61937.mute_rep <<16) |
+			(chip->iec61937.latency & 0x0000ffff)) ;
+	writel(val,chip->pcm_player + AUD_SPDIF_PAU_LAT);
+
+	chip->pcmplayer_control = reg;
+	chip->irq_mask = irq_enable;
+	writel(0,chip->pcm_player +STM_PCMP_IRQ_EN_SET);
+	writel(chip->irq_mask,chip->pcm_player +STM_PCMP_IRQ_EN_SET);
+	spin_unlock_irqrestore(&chip->lock,flags);
+
+	return 0;
+}
+
+
+static int stb7100_spdif_program_hw(snd_pcm_substream_t *substream)
+{
+	int err;
+	if((err = stb7100_program_fsynth(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_spdifplayer(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_fdma(substream)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int stb7100_spdif_open(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	int err=0;
+	const char * dmac_id =STM_DMAC_ID;
+	const char * lb_cap_channel = STM_DMA_CAP_LOW_BW;
+	const char * hb_cap_channel = STM_DMA_CAP_HIGH_BW;
+
+	if(chip->iec60958_rawmode){
+		runtime->hw.info   |= SNDRV_PCM_INFO_MMAP;
+		runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE; /* Only 32bit in RAW mode */
+	}
+
+	if(chip->fdma_channel <0){
+		err=request_dma_bycap(&dmac_id,&hb_cap_channel,"STB710x_SPDIF_DMA");
+		if(err <0){
+			err=request_dma_bycap(&dmac_id,&lb_cap_channel,	"STB710x_SPDIF_DMA");
+			if(err <0){
+				printk(" %s error in DMA request %d\n",__FUNCTION__,err);
+				return err;
+			}
+		}
+		chip->fdma_channel= err;
+	}
+	return 0;
+}
+
+
+static stm_playback_ops_t stb7100_spdif_ops = {
+	.free_device      = stb7100_pcm_free,
+	.open_device      = stb7100_spdif_open,
+	.program_hw       = stb7100_spdif_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_spdif_start_playback,
+	.stop_playback    = stb7100_spdif_stop_playback,
+	.pause_playback   = stb7100_spdif_pause_playback,
+	.unpause_playback = stb7100_spdif_unpause_playback
+};
+
+static struct platform_device *spdif_platform_device;
+
+static int __init stb710x_alsa_spdif_probe(struct device *dev)
+{
+	spdif_platform_device = to_platform_device(dev);
+	return 0;
+}
+
+static struct device_driver alsa_spdif_driver = {
+	.name  = "710x_ALSA_SPD",
+	.owner = THIS_MODULE,
+	.bus   = &platform_bus_type,
+	.probe = stb710x_alsa_spdif_probe,
+};
+
+static struct device alsa_spdif_device = {
+	.bus_id="alsa_710x_spdif",
+	.driver = &alsa_spdif_driver,
+	.parent   = &platform_bus ,
+	.bus      = &platform_bus_type,
+};
+
+
+
+int snd_spdif_stb710x_probe(pcm_hw_t **in_chip,snd_card_t **card,int dev)
+{
+
+	int err=0;
+	pcm_hw_t *chip={0};
+	static snd_device_ops_t ops = {
+		.dev_free = snd_pcm_dev_free,
+	};
+
+	if(driver_register(&alsa_spdif_driver)==0){
+		if(device_register(&alsa_spdif_device)!=0)
+			return -ENOSYS;
+	}
+	else return -ENOSYS;
+
+	if((chip = kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+        	return -ENOMEM;
+
+	*card = snd_card_new(index[card_list[dev].major],id[card_list[dev].major], THIS_MODULE, 0);
+        if (card == NULL){
+      		printk(" cant allocate new card of %d\n",card_list[dev].major);
+      		return -ENOMEM;
+        }
+
+	sprintf((*card)->driver,   "%d",card_list[dev].major);
+	strcpy((*card)->shortname, "STb7100_SPDIF");
+	sprintf((*card)->longname, "STb7100_SPDIF");
+
+	spin_lock_init(&chip->lock);
+	chip->irq          = -1;
+	chip->fdma_channel = -1;
+
+	chip->card         = *card;
+	chip->card_data = &card_list[dev];
+
+	chip->hw           = stb7100_spdif_hw;
+	chip->playback_ops  = &stb7100_spdif_ops;
+
+	chip->oversampling_frequency = 128; /* This is for HDMI compatibility */
+	chip->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	chip->out_pipe      = ioremap(FDMA2_BASE_ADDRESS, 0);
+	chip->pcm_player    = ioremap(SPDIF_BASE,0);
+
+
+
+	iec60958_default_channel_status(chip);
+	chip->iec_encoding_mode = ENCODING_IEC60958;
+
+	if(request_irq(LINUX_SPDIFPLAYER_ALLREAD_IRQ,
+                       stb7100_spdif_interrupt, SA_INTERRUPT,
+                       "STB7100 SPDIF Player",(void*)chip))
+	{
+		printk((">>> failed to get IRQ\n"));
+		stb7100_pcm_free(chip);
+		return -EBUSY;
+	}
+	else
+		chip->irq = LINUX_SPDIFPLAYER_ALLREAD_IRQ;
+
+	if(register_platform_driver(spdif_platform_device,chip,card_list[dev].major)!=0)
+		return -ENODEV;
+
+	if ((err = snd_card_pcm_allocate(chip, chip->card_data->minor, (*card)->longname)) < 0){
+		printk(">>> failed to create PCM stream\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_iec60958_create_controls(chip)) < 0){
+		printk(">>> failed to create SPDIF ctls\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if((err = snd_generic_create_controls(chip)) < 0){
+		printk(">>> failed to create generic ctls\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new((*card), SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0){
+		printk(">>> creating sound device failed\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_card_register((*card))) < 0) {
+		printk(">>> cant register card\n");
+		snd_card_free(*card);
+		return err;
+	}
+	*in_chip = chip;
+	return 0;
+}
diff --exclude=.pc --exclude=patches -ur --new-file linux-2.6.23.1/sound/stm/stm7100_pcm.c linux-2.6.23.1-stm/sound/stm/stm7100_pcm.c
--- linux-2.6.23.1/sound/stm/stm7100_pcm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23.1-stm/sound/stm/stm7100_pcm.c	2007-11-01 12:00:42.000000000 +0000
@@ -0,0 +1,1147 @@
+/*
+ *  STb710x PCM Player Sound Driver
+ *  Copyright (c)   (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+static unsigned long pcm_base_addr[SND_DRV_CARDS] =
+{
+	PCMP0_BASE,
+	PCMP1_BASE,
+	SPDIF_BASE,
+	PCM0_CONVERTER_BASE,
+	PCMIN_BASE
+};
+
+static unsigned long linux_pcm_irq[SND_DRV_CARDS] =
+{
+	LINUX_PCMPLAYER0_ALLREAD_IRQ,
+	LINUX_PCMPLAYER1_ALLREAD_IRQ,
+    	LINUX_SPDIFPLAYER_ALLREAD_IRQ,
+    	LINUX_SPDIFCONVERTER_ALLREAD_IRQ,
+    	LINUX_PCMREADER_ALLREAD_IRQ,
+};
+/*
+ * Extra PCM Player format regsiter define for 7100 Cut2/3
+ */
+#define PCMP_CHANNELS_SHIFT     (8)
+/*
+ * On Cut2/3 7100 DMA requests can be triggered when 2,4,6,8 or 10 cells
+ * are available in the PCMP Player FIFO. For the moment pick the middle
+ * value.
+ */
+#define PCMP_DREQ_TRIGGER       (6L)
+#define PCMP_DREQ_TRIGGER_SHIFT (12)
+
+#define AUD_ADAC_CTL_REG		0x100
+#define AUD_IO_CTL_REG			0x200
+
+/*
+ * AUD_ FSYNTH_CFG control vals
+ */
+#define AUD_FSYNTH_SATA_PHY_30MHZ_REF		(0<<23)
+#define AUD_FSYNTH_SYSBCLKINALT_REF		(1<<23)
+#define AUD_FSYNTH_VGOOD_REF_SOURCE		(0<<16)
+#define AUD_FSYNTH_GOOD_REF_SOURCE		(1<<16)
+#define AUD_FSYNTH_BAD_REF_SOURCE		(2<<16)
+#define AUD_FSYNTH_VBAD_REF_SOURCE		(3<<16)
+#define AUD_FSYNTH_FS_REF_CLK_27_30MHZ		(0<<15)
+#define AUD_FSYNTH_FS_REF_CLK_54_60MHZ		(1<<15)
+#define AUD_FSYNTH_NPDA_POWER_DOWN		(0<<14)
+#define AUD_FSYNTH_NPDA_POWER_UP		(1<<14)
+
+#define AUD_FSYNTH_UNKNOWN_STANDBY		(0<<13)
+#define AUD_FSYNTH_UNKNOWN_ACTIVE		(1<<13)
+#define AUD_FSYNTH_FSYNTH2_STANDBY		(0<<12)
+#define AUD_FSYNTH_FSYNTH2_ACTIVE		(1<<12)
+#define AUD_FSYNTH_FSYNTH1_STANDBY		(0<<11)
+#define AUD_FSYNTH_FSYNTH1_ACTIVE		(1<<11)
+#define AUD_FSYNTH_FSYNTH0_STANDBY		(0<<10)
+#define AUD_FSYNTH_FSYNTH0_ACTIVE		(1<<10)
+
+#define AUD_FSYNTH_RESERVED_9			(1<<9)
+#define AUD_FSYNTH_RESERVED_8			(1<<8)
+#define AUD_FSYNTH_RESERVED_7			(1<<7)
+#define AUD_FSYNTH_RESERVED_6			(1<<6)
+#define AUD_FSYNTH_RESERVED_5			(1<<5)
+
+#define AUD_FSYNTH_FSYNTH2_BYPASS		(0<<4)
+#define AUD_FSYNTH_FSYNTH2_ENABLE		(1<<4)
+#define AUD_FSYNTH_FSYNTH1_BYPASS		(0<<3)
+#define AUD_FSYNTH_FSYNTH1_ENABLE		(1<<3)
+#define AUD_FSYNTH_FSYNTH0_BYPASS		(0<<2)
+#define AUD_FSYNTH_FSYNTH0_ENABLE		(1<<2)
+#define AUD_FSYNTH_RESERVED_1			(1<<1)
+#define AUD_FSYNTH_RESET_ON			(1<<0)
+
+
+/*AUD_IO_CTL reg vals*/
+#define PCM_DATA_IN	0
+#define PCM_DATA_OUT	1
+
+#define PCM_CLK_OUT	0
+#define PCM0_OUT	1
+#define PCM1_OUT	2
+#define SPDIF_ENABLE	3
+
+/*AUD_ADAC_CTL vals*/
+
+#define DAC_NRST     0x1
+#define DAC_SOFTMUTE 0x10
+/* here we bring the dac sub-blocks out of powerdown these are
+ * -DAC BANDGAP  (bit 6)
+ * -ANALOUG PART (bit 5)
+ * -DIGITAL PART (bit 3)
+ * then we reset with bit 1
+ */
+#define DAC_POWERUP_VAL (1 << 3 | 1 <<5 | 1 <<6)
+
+
+/*here we define the block offsets for both pcm players that is fysnth0 & 1
+ * We must specify the pe/md/ and sdiv offsets
+ * */
+ typedef enum {
+ 	SDIV=0x0,
+ 	PE,
+ 	MD,
+ 	PROG_EN
+ }clk_offsets;
+
+
+ /*unfortunatley for pcm0/1 the reg offsets for the fsynth programming are different
+  * hence we select from the table according to the current output*/
+static unsigned long dev_fsynth_regs[4][SND_DRV_CARDS]= {
+			/*PCM0*/		/*PCM1*/	/*spdif*/
+/*SDIV*/	{AUD_FSYN0_SDIV,	AUD_FSYN1_SDIV,		AUD_FSYN2_SDIV},
+/*PE*/		{AUD_FSYN0_PE,		AUD_FSYN1_PE,		AUD_FSYN2_PE},
+/*MD*/		{AUD_FSYN0_MD,		AUD_FSYN1_MD,		AUD_FSYN2_MD},
+/*PROG_EN*/	{AUD_FSYN0_PROG_EN,	AUD_FSYN1_PROG_EN,	AUD_FSYN2_PROG_EN}};
+
+
+#define MEM_FULL_READIRQ	0x02
+#define SELECT_PROG_FSYN	0x01
+#define SELECT_RSTP		0x01
+#define SELECT_PCM_FSYN_CLK	(0x01 << 2)
+#define SELECT_SYSBCLKINALT	(0x01 << 23)
+
+
+static snd_pcm_hardware_t stb7100_pcm_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID     |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	/*.formats   now defined at runtime on card - card basis due
+	to reliability problems when switching between modes on cards utilising an external DAC*/	
+	
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 |
+			 SNDRV_PCM_RATE_96000 |
+			 SNDRV_PCM_RATE_192000 ),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 192000,
+	.channels_min	  = 10,/*vals now taken from setup.c for platform*/
+	.channels_max	  = 10,/*specific channel availability -but we must still provide a default*/
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.period_bytes_min = FRAMES_TO_BYTES(1,10),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+
+/*
+ * The following FSynth programming has been provided by ST validation
+ * teams for STb7100 Cut1.3. They are for an oversampling frequency of 256*Fs.
+ *
+ *  peq is the value for a 0.001 % adjustment of the current output freq
+ *  which is defined by the forumlae in the manual.
+ */
+
+static struct stm_freq_s gClockSettings[NUM_CLOCK_SETTINGS] =
+{
+     	/*             freq(Fs) sdiv  pe      md   peq */
+	/*8.1920 == */{ 32000,  0x4, 0x5a00, 0xfd, 0xa},
+	/*11.2895Mhz*/{ 44100,  0x4, 0x5EE9, 0xF5 ,0x7},
+	/*12.2880MHz*/{ 48000,  0x4, 0x3C00, 0xF3 ,0x7},
+	/*24.5760MHz*/{ 96000,  0x3, 0x3C00, 0xF3 ,0x6},
+	/*36.8640MHz*/{ 192000, 0x2, 0x7AAB ,0xFA, 0x8}
+};
+
+
+/*Here we can  dynamically adjust the sampling frequencies of playback on the
+ * pcm0/1 players and the SPDIF. The function allows a +/- 10 % adjustment of
+ * frequency in 0.001% increments of current playback frequency.
+ *
+ * The adjusts parm indicates the number of .001% adjustments to apply,
+ *  up to a maximum of 10000, or 10%
+ *
+ * There is an error  in the order of 1 % due to relying on integer
+ * approximations of float values, not available in the kernel.
+ * Additionally the PE solutions of the equation do not offer a linear response,
+ * here we assume a linear response and discard the remainder as error.
+ * We can never calculate the exact output frequency from this driver,
+ * so we utilise a quanta value which represents a % adjustment of each frequency
+ * */
+int adjust_audio_clock(snd_pcm_substream_t *substream,int adjusts,int dir)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	int i=0,total_shift=0;
+	unsigned long new_pe=0, peq=0,new_md=0,new_sdiv=0;
+
+	unsigned long pg_en_offset = dev_fsynth_regs[PROG_EN][chip->card_data->major];
+	unsigned long pe_offset    = dev_fsynth_regs[PE][chip->card_data->major];
+	unsigned long md_offset    = dev_fsynth_regs[MD][chip->card_data->major];
+ 	unsigned long sdiv_offset  = dev_fsynth_regs[SDIV][chip->card_data->major];
+
+	unsigned long cur_pe   = readl(chip->pcm_clock_reg + pe_offset);
+	unsigned long cur_md   = readl(chip->pcm_clock_reg + md_offset);
+	unsigned long cur_sdiv = readl(chip->pcm_clock_reg + sdiv_offset);
+
+	if( ((adjusts <=0) || (adjusts >10000)) || !substream)
+		return -EINVAL;
+
+	/*get the correct fsynth settings for FS*/
+	while(i < NUM_CLOCK_SETTINGS && runtime->rate != gClockSettings[i].freq)
+		i++;
+
+	if(!(i<=NUM_CLOCK_SETTINGS))
+		return -ENODEV;
+
+	peq = 	gClockSettings[i].pe_quantum;
+	new_md = cur_md;
+	new_pe = cur_pe;
+	new_sdiv = cur_sdiv;
+
+	if(INCR_FSYNTH == dir){
+		if(((adjusts*peq )+cur_pe) > 0xffff){
+			while(total_shift<=adjusts){
+				while(new_pe < 0xffff){
+					if(total_shift>=adjusts)
+						goto write_fsynth;
+					new_pe+=peq;
+					total_shift++;
+				}
+				/*overflow- incr the md and set the
+				 * pe down to maintain current FS*/
+				new_md--;
+				/*now we have crossed the sdiv
+				 *md is a 5 bit signed term, leaving
+				 * 1-16 available*/
+				if(new_md  < 0x10){
+					new_sdiv--;
+					new_md = 0x1f;
+					new_pe +=SDIV_SHIFT_VAL;
+				}
+				else new_pe -= MD_SHIFT_VAL;
+			}
+		}
+		else new_pe += adjusts *peq;
+
+	}
+	else if(DECR_FSYNTH == dir){
+		if( (int)(cur_pe-(adjusts*peq )) < (int)0x000){
+			while(total_shift <=adjusts){
+				while((int)new_pe > (int)0){
+					if(total_shift >= adjusts)
+						goto write_fsynth;
+					new_pe -= peq;
+					total_shift++;
+				}
+				new_md++;
+
+				if(new_md  >0x1f) {
+					new_sdiv++;
+					new_md =0x10;
+					new_pe +=SDIV_SHIFT_VAL;
+				}
+				else new_pe+=MD_SHIFT_VAL;
+			}
+		}
+		else new_pe -= adjusts * peq;
+	}
+	else return -EINVAL;
+
+
+
+write_fsynth:
+	writel(0,chip->pcm_clock_reg+pg_en_offset);
+	writel(new_pe,chip->pcm_clock_reg + pe_offset);
+	writel(new_md,chip->pcm_clock_reg + md_offset);
+	writel(new_sdiv,chip->pcm_clock_reg + sdiv_offset);
+	writel(1,chip->pcm_clock_reg+pg_en_offset);
+	return 0;
+}
+
+
+void stb7100_reset_pcm_player(pcm_hw_t  *chip)
+{
+	/* Give the pcm player a soft reset */
+	writel(1,chip->pcm_player );
+	writel(0,chip->pcm_player );
+}
+
+
+static void stb7100_reset_internal_DAC(pcm_hw_t *chip)
+{
+	writel(0,chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	writel((DAC_POWERUP_VAL|DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+}
+
+
+static void stb7100_pcm_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+
+	/*if we have fifo checking turned on we must also stop this interrupt first to
+	 * prevent an error condition being generated as the player is disabled*/
+	if(chip->fifo_check_mode)
+		writel( ENABLE_INT_UNDERFLOW,chip->pcm_player + STM_PCMP_IRQ_EN_CLR);
+
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG) | DAC_SOFTMUTE;
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		udelay(100);
+		reg = reg & ~DAC_NRST; /* Reset active low */
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	}
+
+	/*
+	 * Disable PCM Player IRQ, this is important when switching
+	 * between PCM0 and the protocol converter as there is
+	 * nowhere else to turn the interrupts off, and the
+	 * PCM0 interrupt will fire with the wrong card structure!
+	 */
+	writel(MEM_FULL_READIRQ, chip->pcm_player + STM_PCMP_IRQ_EN_CLR);
+
+	/*
+	 * We use "mute" to stop the PCM player, which in fact is implemented
+	 * as a pause, rather than "off" becuase it keeps the L/R clocks
+	 * running to the DACs. This avoids noise on the analogue output
+	 * and occasional DAC failures, due to the DACs being intolerant of
+	 * losing their clocks unless in reset or powerdown modes. At the
+	 * moment we have no control over external DACs in this code.
+	 *
+	 * Note: the internal DAC doesn't absolutely need this (as it
+	 * can be reset).
+	 */
+	 /* It is  possible for us to effect a mute at the internal DAC
+	 * rather than in the player.  For the externally connected DAC, this is not
+	 * possible.
+	 */
+	if( chip->card_data->major == PCM1_DEVICE){
+		writel((chip->pcmplayer_control|PCMP_OFF),chip->pcm_player+STM_PCMP_CONTROL);
+	}
+	else writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+
+	dma_stop_channel(chip->fdma_channel);
+	dma_params_free(&chip->dmap);
+	chip->dma_req = NULL; /* free'd by the above call to dma_params_free() */
+}
+
+
+static void stb7100_pcm_start_playback(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t     *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+	int res = dma_xfer_list(chip->fdma_channel,&chip->dmap);
+	if(res !=0)
+		printk("%s FDMA_CH %d failed to start %d\n",__FUNCTION__,chip->fdma_channel,res);
+
+	spin_lock(&chip->lock);
+
+	/*
+	 * We appear to need to reset the PCM player otherwise we end up
+	 * with channel data sent to the wrong channels when starting up for
+	 * the second time.
+	 */
+	stb7100_reset_pcm_player(chip);
+
+	writel((chip->pcmplayer_control | PCMP_ON), chip->pcm_player + STM_PCMP_CONTROL);
+
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG) | DAC_NRST; /* Bring DAC out of Reset */
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		udelay(100);
+		writel((reg & ~DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG); /* Unmute */
+	}
+	/*again we enable this err-checking interrput last to prevent an err condiftion
+	 * as the device is programmed */
+	if(chip->fifo_check_mode)
+		writel( ENABLE_INT_UNDERFLOW,chip->pcm_player + STM_PCMP_IRQ_EN_SET);
+
+	
+
+	spin_unlock(&chip->lock);
+}
+
+
+static void stb7100_pcm_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+        spin_lock(&chip->lock);
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		writel((reg & ~DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+        }
+	if(chip->fifo_check_mode)
+		writel( ENABLE_INT_UNDERFLOW,chip->pcm_player + STM_PCMP_IRQ_EN_SET);
+
+	writel((chip->pcmplayer_control|PCMP_ON),chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static void stb7100_pcm_pause_playback(snd_pcm_substream_t *substream)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+	if(chip->card_data->major == PCM1_DEVICE){
+	        reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	        writel((reg | DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	}
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+
+	if(chip->fifo_check_mode)
+		writel( ENABLE_INT_UNDERFLOW,chip->pcm_player + STM_PCMP_IRQ_EN_CLR);
+
+	spin_unlock(&chip->lock);
+}
+
+static snd_pcm_uframes_t stb7100_fdma_playback_pointer(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	/*
+	 * Calculate our current playback position, using the number of bytes
+	 * left for the DMA engine needs to transfer to complete a full
+	 * iteration of the buffer. This is common to all STb7100 audio players
+	 * using the FDMA (including SPDIF).
+	 */
+	u32 pos = substream->runtime->dma_bytes - get_dma_residue(chip->fdma_channel);
+	return bytes_to_frames(substream->runtime,pos);
+}
+
+
+static irqreturn_t stb7100_pcm_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+	pcm_hw_t *stb7100 = dev_id;
+	irqreturn_t res =IRQ_NONE;
+
+	/* Read and clear interrupt status */
+	spin_lock(&stb7100->lock);
+	val = readl(stb7100->pcm_player + STM_PCMP_IRQ_STATUS);
+	writel(val,stb7100->pcm_player + STM_PCMP_ITS_CLR);
+	spin_unlock(&stb7100->lock);
+
+	if(unlikely((val & ENABLE_INT_UNDERFLOW ) == ENABLE_INT_UNDERFLOW)){
+		printk("%s PCM PLayer #%d FIFO Underflow detected\n",
+			__FUNCTION__,
+			stb7100->current_substream->pcm->card->number);
+		res = IRQ_HANDLED;
+	}
+	if(likely(val & PCMP_INT_STATUS_ALLREAD)){
+		/*Inform higher layer that we have completed a period */
+		snd_pcm_period_elapsed(stb7100->current_substream);
+		res=  IRQ_HANDLED;
+	}
+	return  res;
+}
+
+static struct stm_dma_req_config req_config = {
+	.rw		= REQ_CONFIG_WRITE,
+	.opcode		= REQ_CONFIG_OPCODE_4,
+	.count		= 1,
+	.increment	= 0,
+	.hold_off	= 0,
+	.initiator	= 0, /* This was 1 for 7100, do we need to fix? */
+};
+
+static int stb7100_program_fdma(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t          *chip    = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long irqflags=0;
+	int err=0;
+
+	if(!chip->out_pipe || ! chip->pcm_player)
+		return -EINVAL;
+
+	spin_lock_irqsave(&chip->lock,irqflags);
+
+	if (chip->dma_req == NULL) {
+		chip->dma_req = dma_req_config(chip->fdma_channel, chip->fdma_req, &req_config);
+		if (chip->dma_req == NULL) {
+			spin_unlock_irqrestore(&chip->lock,irqflags);
+			return -EBUSY;
+		}
+	}
+
+	dma_params_init(&chip->dmap,
+			MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	chip->buffer_start_addr = (unsigned long)runtime->dma_addr;
+
+	dma_params_DIM_1_x_0(&chip->dmap);
+
+	dma_params_req(&chip->dmap, chip->dma_req);
+
+	dma_params_addrs(&chip->dmap,runtime->dma_addr,
+			virt_to_phys(chip->pcm_player+STM_PCMP_DATA_FIFO),
+			snd_pcm_lib_buffer_bytes(substream));
+
+	dma_compile_list(chip->fdma_channel, &chip->dmap, GFP_ATOMIC);
+
+	spin_unlock_irqrestore(&chip->lock,irqflags);
+	return err;
+}
+
+
+static int stb7100_program_fsynth(snd_pcm_substream_t *substream)
+{
+	int i;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+        unsigned long flags=0;
+        int err=0, dev_num=0,sdiv=0;
+
+	spin_lock_irqsave(&chip->lock,flags);
+        dev_num = chip->card_data->major == PROTOCOL_CONVERTER_DEVICE ?
+        			0:
+        			chip->card_data->major;
+
+	if(! runtime->rate  || ! chip->pcm_clock_reg){
+		err= -EINVAL;
+		goto exit;
+	}
+
+	else for(i=0; i < NUM_CLOCK_SETTINGS; i++) {
+		if (runtime->rate == gClockSettings[i].freq){
+
+			writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+
+                        /*if we are using the PCM converter we require a divisor of 128 not 256
+                           therefore our SDIV must be incremented to account for this
+                         */
+			switch(chip->oversampling_frequency){
+				case 128:
+					/*
+					 * FSynth setting are for 256xFs, adding
+					 * one to sdiv changes this to 128xFs
+					 */
+					sdiv = gClockSettings[i].sdiv_val +1;
+					break;
+				case 256:
+					sdiv = gClockSettings[i].sdiv_val;
+					break;
+				default:
+					printk("snd_pcm_program_freq: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+					err= -EINVAL;
+					goto exit;
+			}
+
+                        writel(sdiv,chip->pcm_clock_reg +dev_fsynth_regs[SDIV][dev_num]);
+
+			writel(gClockSettings[i].md_val ,
+				chip->pcm_clock_reg + dev_fsynth_regs[MD][dev_num]);
+
+			writel(gClockSettings[i].pe_val,
+				chip->pcm_clock_reg + dev_fsynth_regs[PE][dev_num]);
+
+			writel(SELECT_PROG_FSYN,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+			writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+			err = 0;
+			goto exit;
+		}
+	}
+	err =  -1;
+exit:
+	spin_unlock_irqrestore(&chip->lock,flags);
+	return err;
+
+}
+
+
+static int stb7100_program_pcmplayer(snd_pcm_substream_t *substream)
+{
+	unsigned long ctrlreg, fmtreg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	unsigned long irqmask = MEM_FULL_READIRQ;
+	unsigned long flags=0;
+
+	fmtreg = PCMP_FORMAT_32  | PCMP_ALIGN_START  | PCMP_MSB_FIRST  |
+		 chip->i2s_sampling_edge |PCMP_PADDING_ON;
+
+	ctrlreg = (runtime->period_size * runtime->channels) << PCMP_SAMPLES_SHIFT;
+
+	/*
+	 * The PCM data format is set to be I2S.
+	 * External DACs must be configured to expect this format and
+	 * an oversampling frequency of 256*Fs. Please see the documentation
+	 * on http://www.stlinux.com for board configuration information.
+	 *
+         * Except when we are running the PCM0 with the spdif converter, in
+         * which case the HDMI expects an oversampling frequency of 128*FS,
+         * as defined in the spec.
+         */
+
+        ctrlreg |= PCMP_NO_ROUNDING;
+	
+	/*We will always clock out I2s from the DAC's, however, when in 16bit
+	 * mode we can flip the L/R ordering bit to give the correct LR ordering for
+	 * 16 bit packed into I2s.  With the caviat that */
+        if(runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
+		ctrlreg |= PCMP_MEM_FMT_16_16;
+		fmtreg  |= PCMP_LENGTH_16 | PCMP_LRLEVEL_LEFT_HIGH;
+        } else {
+		ctrlreg |= PCMP_MEM_FMT_16_0;
+		fmtreg  |= PCMP_LENGTH_24| PCMP_LRLEVEL_LEFT_LOW;
+        }
+
+
+	/*
+	 * Note that the frequency divide is the same for both 32bit and 16bit
+	 * data input, because the number of _output_ bits per subframe is
+	 * always 32.
+	 */
+	spin_lock_irqsave(&chip->lock,flags);
+	switch(chip->oversampling_frequency){
+		case 128:
+			ctrlreg |= PCMP_FSYNTH_DIVIDE32_128;
+			break;
+		case 256:
+			ctrlreg |= PCMP_FSYNTH_DIVIDE32_256;
+			break;
+		default:
+			printk("snd_pcm_program_pcmplayer: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+			break;
+	}
+
+	if(PROTOCOL_CONVERTER_DEVICE==chip->card_data->major){
+		/*this call will result in a reset and sleep of the
+		 * converter, so we abandon locks now.*/
+	 	spin_unlock_irqrestore(&chip->lock,flags);
+		stb7100_converter_program_player(substream);
+		spin_lock_irqsave(&chip->lock,flags);
+	}
+
+	if(get_spdif_syncing_status()==SPDIF_SYNC_MODE_ON)
+		ctrlreg |= PCMP_WAIT_SPDIF_LATENCY;
+	else
+		ctrlreg |= PCMP_IGNORE_SPDIF_LATENCY;
+
+	chip->pcmplayer_control = ctrlreg;
+        /*
+         * The 7100 cut >=3 can use 2-10 channels, cut < 3 is like the
+         * stm8000 and is fixed to 5 stereo channels. 7109 is always dynamic
+         * channel programmable.
+         */
+
+	fmtreg |= (runtime->channels/2) << PCMP_CHANNELS_SHIFT;
+	fmtreg |= PCMP_DREQ_TRIGGER << PCMP_DREQ_TRIGGER_SHIFT;
+	writel(fmtreg, chip->pcm_player + STM_PCMP_FORMAT);
+
+	/*enable the allread irq - but only for the pcm players, the pcm
+	 * converter takes this interrupt during I2s->IEC60958 mode*/
+	if(PROTOCOL_CONVERTER_DEVICE != chip->card_data->major){
+		writel(irqmask,chip->pcm_player + STM_PCMP_IRQ_EN_SET);
+	}
+	spin_unlock_irqrestore(&chip->lock,flags);
+	return 0;
+}
+
+
+static int stb7100_pcm_program_hw(snd_pcm_substream_t *substream)
+{
+	int err=0;
+	if((err = stb7100_program_fsynth(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_pcmplayer(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_fdma(substream)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int stb7100_pcm_free(pcm_hw_t *card)
+{
+	writel(PCMP_OFF, card->pcm_player + STM_PCMP_CONTROL);
+	iounmap(card->pcm_clock_reg);
+	iounmap(card->out_pipe);
+	iounmap(card->pcm_player);
+
+	if(card->irq > 0)
+		free_irq(card->irq,(void *)card);
+
+	if(card->fdma_channel>=0)
+		free_dma(card->fdma_channel);
+
+	kfree(card);
+
+	return 0;
+}
+
+
+static void set_default_device_clock(pcm_hw_t * chip)
+{
+/*
+ * Set a default clock frequency running for each device. Not doing this
+ * can lead to clocks not starting correctly later, for reasons that
+ * cannot be explained at this time.
+ */
+
+ /*the protocol converter clocks from the pcm0 clock(fsynth0)*/
+ 	int dev = (PROTOCOL_CONVERTER_DEVICE == chip->card_data->major) ?
+ 					0:
+ 					chip->card_data->major;
+
+	writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev]);
+
+        writel(gClockSettings[0].sdiv_val ,
+               chip->pcm_clock_reg +dev_fsynth_regs[SDIV][dev]);
+
+        writel(gClockSettings[0].md_val ,
+               chip->pcm_clock_reg + dev_fsynth_regs[MD][dev]);
+
+        writel(gClockSettings[0].pe_val,
+               chip->pcm_clock_reg + dev_fsynth_regs[PE][dev]);
+
+        writel(SELECT_PROG_FSYN,chip->pcm_clock_reg +
+               dev_fsynth_regs[PROG_EN][dev]);
+
+        writel(0,chip->pcm_clock_reg +
+               dev_fsynth_regs[PROG_EN][dev]);
+        writel(0,chip->pcm_player + STM_PCMP_CONTROL);
+}
+
+
+static void stb7100_pcm0_create(pcm_hw_t *stb7100)
+{
+	unsigned long reg;
+	/*
+	 * Do a one time setup of the audio clock system
+	 *
+	 * First put the audio FSynth block into reset
+	 */
+	reg =	AUD_FSYNTH_SATA_PHY_30MHZ_REF	|
+		AUD_FSYNTH_VGOOD_REF_SOURCE	|
+		AUD_FSYNTH_FS_REF_CLK_27_30MHZ	|
+		AUD_FSYNTH_NPDA_POWER_UP	|
+		AUD_FSYNTH_FSYNTH2_ACTIVE	|
+		AUD_FSYNTH_FSYNTH1_ACTIVE	|
+		AUD_FSYNTH_FSYNTH0_ACTIVE	|
+		/*
+		 * Each of these reserved bits relates to one of the
+		 * Fsynth's (6-0 7-1 8-2).  However at the present time
+		 * they are not documented.  The datasheets
+		 * are currently being updated.  Each must be set to
+		 * enable correct playback at 256Khz DAC freq */
+		AUD_FSYNTH_RESERVED_6		|
+		AUD_FSYNTH_RESERVED_7		|
+		AUD_FSYNTH_RESERVED_8		|
+		AUD_FSYNTH_FSYNTH2_ENABLE	|
+		AUD_FSYNTH_FSYNTH1_ENABLE	|
+		AUD_FSYNTH_FSYNTH0_ENABLE;
+
+	writel((reg | AUD_FSYNTH_RESET_ON),stb7100->pcm_clock_reg);
+	/*
+	 * Now bring it out of reset, powering up the analogue
+	 * part and bringing the digital parts out of standby.
+	 */
+	writel(reg,stb7100->pcm_clock_reg);
+
+	/*
+	 * Set all the audio pins to be outputs
+	 */
+	reg =	PCM_DATA_OUT << PCM_CLK_OUT |
+		PCM_DATA_OUT << PCM0_OUT    |
+		PCM_DATA_OUT << PCM1_OUT    |
+		PCM_DATA_OUT << SPDIF_ENABLE;
+
+	writel(reg,stb7100->pcm_clock_reg+AUD_IO_CTL_REG);
+}
+
+
+static unsigned int stb7100_pcm_channels[] = { 2,4,6,8,10 };
+
+
+static snd_pcm_hw_constraint_list_t stb7100_constraints_channels = {
+		.count = ARRAY_SIZE(stb7100_pcm_channels),
+		.list = stb7100_pcm_channels,
+		.mask = 0
+};
+
+static int stb7100_pcm_open(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+    	int                err=0;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	const char * dmac_id =STM_DMAC_ID;
+	const char * lb_cap_channel = STM_DMA_CAP_LOW_BW;
+	const char * hb_cap_channel = STM_DMA_CAP_HIGH_BW;
+
+	if(chip->fdma_channel <0){
+		if((err=request_dma_bycap(
+					&dmac_id,
+					&hb_cap_channel,
+					"STB7100_PCM_DMA"))<0){
+			if((err=request_dma_bycap(
+						&dmac_id,
+						&lb_cap_channel,
+						"STB7100_PCM_DMA"))<0){
+				return -ENODEV;
+			}
+		}
+		chip->fdma_channel= err;
+	}
+	BUG_ON(chip->fdma_channel <0);
+	/*PCMP IP's prior to 7100C3 are fixed to 10 channels, later
+	 * revisions and 7109's can program for 2-10 channels - here we
+	 * expose the number of programmable channels*/
+
+	runtime->hw.channels_min = chip->min_ch;
+	runtime->hw.channels_max = chip->max_ch;
+	
+	/*
+	 *Here we disable 16b mode for PCM0/PCM_CNV.
+	 * There is a catch 22 in that both protocol converter & PCM0 will fail to
+	 * reinitialise correctly if their clock source is removed, and we cannot
+	 * guarantee correct L/R ordering after a 16/32 - 32/16b mode switch
+	 * unless we remove the clocks after playback*/
+	if(	(chip->card_data->major == PCM0_DEVICE) || 
+		(chip->card_data->major == PROTOCOL_CONVERTER_DEVICE))
+	
+		runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;
+	else
+		runtime->hw.formats = (SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE);
+	
+	runtime->hw.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,chip->max_ch),
+	runtime->hw.period_bytes_min = FRAMES_TO_BYTES(1,chip->min_ch),
+	runtime->hw.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,chip->max_ch),
+
+	err = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &stb7100_constraints_channels);
+	return err;
+}
+
+
+static stm_playback_ops_t stb7100_pcm_ops = {
+	.free_device      = stb7100_pcm_free,
+	.open_device      = stb7100_pcm_open,
+	.program_hw       = stb7100_pcm_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_pcm_start_playback,
+	.stop_playback    = stb7100_pcm_stop_playback,
+	.pause_playback   = stb7100_pcm_pause_playback,
+	.unpause_playback = stb7100_pcm_unpause_playback
+};
+
+static snd_device_ops_t ops = {
+    .dev_free = snd_pcm_dev_free,
+};
+
+
+static int stb7100_create_lpcm_device(pcm_hw_t *in_chip,snd_card_t **this_card,int dev)
+{
+	int err = 0;
+	int irq = linux_pcm_irq[dev];
+
+	pcm_hw_t * chip  = in_chip;
+	snd_card_t *card={0};
+
+	card = snd_card_new(index[card_list[dev].major],id[card_list[dev].major], THIS_MODULE, 0);
+        if (this_card == NULL){
+      		printk(" cant allocate new card of %d\n",card_list[dev].major);
+      		return -ENOMEM;
+        }
+
+	chip->fdma_channel =-1;
+	chip->card_data = &card_list[dev];
+	spin_lock_init(&chip->lock);
+
+
+
+        chip->card          = card;
+	chip->irq           = -1;
+	chip->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	chip->out_pipe      = ioremap(FDMA2_BASE_ADDRESS,0);
+	chip->pcm_converter = 0;
+	chip->pcm_player    = ioremap(pcm_base_addr[chip->card_data->major],0);
+        chip->hw            = stb7100_pcm_hw;
+	chip->oversampling_frequency = 256;
+
+	chip->playback_ops  = &stb7100_pcm_ops;
+
+	sprintf(card->shortname, "STb7100_PCM%d",chip->card_data->major);
+	sprintf(card->longname,  "STb7100_PCM%d",chip->card_data->major );
+	sprintf(card->driver,    "%d",chip->card_data->major);
+
+	if(request_irq(irq, stb7100_pcm_interrupt, SA_INTERRUPT, "STB7100_PCM", (void*)chip)){
+               		printk(">>> failed to get IRQ %d\n",irq);
+	                stb7100_pcm_free(chip);
+        	        return -EBUSY;
+        }
+	chip->irq = irq;
+
+    	switch(chip->card_data->major){
+	        case PCM0_DEVICE:
+        	    	stb7100_pcm0_create(chip);
+			break;
+		case PCM1_DEVICE:
+			stb7100_reset_internal_DAC(chip);
+			break;
+    	}
+
+	set_default_device_clock(chip);
+	stb7100_reset_pcm_player(chip);
+
+	if((err = snd_card_pcm_allocate(chip,chip->card_data->minor,card->longname)) < 0){
+        	printk(">>> Failed to create PCM stream \n");
+	        stb7100_pcm_free(chip);
+    	}
+    	if((err = snd_generic_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,chip, &ops)) < 0){
+		printk(">>> creating sound device :%d,%d failed\n",chip->card_data->major,chip->card_data->minor);
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_card_register(card)) < 0) {
+		printk("%s snd_card_registration() failed !\n",__FUNCTION__);
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	*this_card = card;
+	return 0;
+}
+static struct platform_device *pcm0_platform_device;
+static struct platform_device *pcm1_platform_device;
+static struct platform_device *cnv_platform_device;
+
+static int stb710x_platform_alsa_probe(struct device *dev);
+
+static struct device_driver alsa_cnv_driver = {
+	.name  = "710x_ALSA_CNV",
+	.owner = THIS_MODULE,
+	.bus   = &platform_bus_type,
+	.probe = stb710x_platform_alsa_probe,
+};
+
+static struct device_driver alsa_pcm0_driver = {
+	.name  = "710x_ALSA_PCM0",
+	.owner = THIS_MODULE,
+	.bus   = &platform_bus_type,
+	.probe = stb710x_platform_alsa_probe,
+};
+
+static struct device_driver alsa_pcm1_driver = {
+	.name  = "710x_ALSA_PCM1",
+	.owner = THIS_MODULE,
+	.bus   = &platform_bus_type,
+	.probe = stb710x_platform_alsa_probe,
+};
+static struct device alsa_pcm1_device = {
+	.bus_id="alsa_710x_pcm1",
+	.driver = &alsa_pcm1_driver,
+	.parent   = &platform_bus ,
+	.bus      = &platform_bus_type,
+};
+
+static struct device alsa_pcm0_device = {
+	.bus_id="alsa_710x_pcm0",
+	.driver = &alsa_pcm0_driver,
+	.parent   = &platform_bus ,
+	.bus      = &platform_bus_type,
+};
+static struct device alsa_cnv_device = {
+	.bus_id="alsa_710x_cnv",
+	.driver = &alsa_cnv_driver,
+	.parent   = &platform_bus ,
+	.bus      = &platform_bus_type,
+};
+
+
+static int __init stb710x_platform_alsa_probe(struct device *dev)
+{
+	if(strcmp(dev->bus_id,alsa_pcm0_driver.name)==0)
+	        pcm0_platform_device = to_platform_device(dev);
+
+	else if(strcmp(dev->bus_id,alsa_pcm1_driver.name)==0)
+	        pcm1_platform_device = to_platform_device(dev);
+
+	else if(strcmp(dev->bus_id,alsa_cnv_driver.name)==0)
+	        cnv_platform_device = to_platform_device(dev);
+
+	else return -EINVAL;
+
+        return 0;
+}
+
+static int snd_pcm_card_generic_probe( int dev)
+{
+	struct device_driver *  dev_driver;
+	struct device * device;
+
+	switch(dev){
+		case PCM0_DEVICE:
+			dev_driver= 	&alsa_pcm0_driver;
+			device =  	&alsa_pcm0_device;
+			break;
+		case PCM1_DEVICE:
+			dev_driver= 	&alsa_pcm1_driver;
+			device =  	&alsa_pcm1_device;
+			break;
+		case PROTOCOL_CONVERTER_DEVICE:
+			dev_driver= 	&alsa_cnv_driver;
+			device =  	&alsa_cnv_device;
+			break;
+		default:
+			return -EINVAL;
+	}
+	if(driver_register(dev_driver)==0){
+		if(device_register(device)!=0)
+			return -ENOSYS;
+	}
+	else return -ENOSYS;
+	return 0;
+}
+
+
+static int snd_pcm_stb710x_probe(pcm_hw_t **chip,snd_card_t **card,int dev)
+{
+	unsigned long err=0;
+	if( (err= snd_pcm_card_generic_probe(dev))<0){
+               	snd_card_free(*card);
+               	return -ENOSYS;
+	}
+
+	if((*chip =(pcm_hw_t *) kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+        	return -ENOMEM;
+
+	switch(card_list[dev].major){
+       		case PROTOCOL_CONVERTER_DEVICE:
+			if(register_platform_driver(cnv_platform_device,*chip,card_list[dev].major)!=0){
+				printk("%s Error Registering Protocol Converter\n",__FUNCTION__);
+				return -ENODEV;
+			}
+	      		if((err=  stb7100_create_converter_device(*chip,card,dev))<0){
+	       		 	printk("%s Error Creating protocol Converter\n",__FUNCTION__);
+	       		       	snd_card_free(*card);
+	      		}
+			return err;
+	        case PCM0_DEVICE:
+	        	{
+			pcm_hw_t *ip_chip={0};
+
+			if(register_platform_driver(pcm0_platform_device,*chip,card_list[dev].major)!=0){
+				printk("%s Error Registering PCM0 player\n",__FUNCTION__);
+				return -ENODEV;
+			}
+	        	if((err = stb7100_create_lpcm_device(*chip,card,PCM0_DEVICE)) <0){
+				printk("%s Error Creating PCM0 player\n",__FUNCTION__);
+	                       	snd_card_free(*card);
+	        	}
+
+	 		if((err = snd_pcmin_stb710x_probe(ip_chip,*card,PCMIN_DEVICE))<0)
+				return -ENODEV;
+
+	              	return err;
+	        	}
+	        case PCM1_DEVICE:
+
+	        	if(register_platform_driver(pcm1_platform_device,*chip,card_list[dev].major)!=0){
+				printk("%s Error Registering PCM1 player\n",__FUNCTION__);
+				return -ENODEV;
+	        	}
+	               	if((err = stb7100_create_lpcm_device(*chip,card,PCM1_DEVICE)) <0){
+	               		printk("%s Error Creating PCM1 player\n",__FUNCTION__);
+	                      	snd_card_free(*card);
+	               	}
+	                return err;
+	        default:
+	        	printk("%s Cant Recognise Alsa Card %d\n",__FUNCTION__,dev);
+	              	return -ENODEV;
+	        }
+	return 0;
+}
+
+static int __init snd_pcm_card_probe(int dev)
+{
+	snd_card_t card={0};
+	snd_card_t * ptr  = &card;
+	pcm_hw_t *chip={0};
+	int err=0;
+
+	if(SPDIF_DEVICE == dev){
+		if((err = snd_spdif_stb710x_probe(&chip,&ptr,dev))<0)
+			goto err_exit;
+	}
+	else switch(dev){
+		case PCM0_DEVICE:
+		case PCM1_DEVICE:
+		case PROTOCOL_CONVERTER_DEVICE:
+	 		err = snd_pcm_stb710x_probe(&chip,&ptr,dev);
+	 		if(err < 0)
+	 			goto err_exit;
+	 		break;
+	 	default:
+	 		printk("%s Bad Alsa Card vector- %d\n",__FUNCTION__,dev);
+	 		goto err_exit;
+	}
+#if defined(CONFIG_STB7100_FIFO_DEBUG)
+	chip->fifo_check_mode=1;
+#else
+	chip->fifo_check_mode=0;
+#endif
+        return 0;
+err_exit:
+	printk("%s Error Initialising Audio Device %d - err %d\n",__FUNCTION__,dev,err);
+	return err;
+}
