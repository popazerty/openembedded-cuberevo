Integrate ST SPI driver into kernel SPI subsystem.

Signed-off-by: Angus Clark <angus.clark@st.com>

Index: linux-2.6.17/arch/sh/boards/st/stb7100ref/setup.c
===================================================================
--- linux-2.6.17.orig/arch/sh/boards/st/stb7100ref/setup.c	2008-03-05 10:36:48.000000000 +0000
+++ linux-2.6.17/arch/sh/boards/st/stb7100ref/setup.c	2008-03-05 10:58:50.000000000 +0000
@@ -18,6 +18,7 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/mtd/physmap.h>
+#include <linux/spi/spi.h>
 #include <asm/io.h>
 #include <linux/stm/710x_fdma.h>
 #include <linux/stm/7100_fdma2_firmware.h>
@@ -84,9 +85,8 @@
 	/* Route UART2 and PWM to PIO4 instead of SCIF */
 	sysconf &= ~(1<<0);
 
-	/* Set SSC2_MUX_SEL = 0 */
-	/* Treat SSC2 as I2C instead of SSC */
-	sysconf &= ~(1<<3);
+	/* Set SSC{0,1,2}_MUX_SEL = 0 */
+	sysconf &= ~(0xE);
 
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
@@ -185,6 +185,7 @@
 	{3, 0, 3, 1, 3, 2},
 	{4, 0, 4, 1, 0xff, 0xff},
 };
+
 static struct plat_ssc_data ssc_private_info = {
 	.capability  =
 		(SSC_I2C_CAPABILITY << (0*2)) |
@@ -192,6 +193,7 @@
 		(SSC_I2C_CAPABILITY << (2*2)),
 	.pio         = ssc_pio
 };
+
 struct platform_device ssc_device = {
 	.name = "ssc",
 	.id = -1,
@@ -1010,6 +1012,7 @@
 		alsa_710x_resource_pcmin[2].end =   0;
 
 	}
+
 	ret = platform_add_devices(stb7100ref_devices, ARRAY_SIZE(stb7100ref_devices));
 	return ret;
 }
Index: linux-2.6.17/drivers/i2c/busses/i2c-stm.c
===================================================================
--- linux-2.6.17.orig/drivers/i2c/busses/i2c-stm.c	2008-03-05 10:35:47.000000000 +0000
+++ linux-2.6.17/drivers/i2c/busses/i2c-stm.c	2008-03-05 10:58:50.000000000 +0000
@@ -32,7 +32,7 @@
 #include <asm/processor.h>
 #include <asm/delay.h>
 #include "./i2c-stm.h"
-#include "../../stm/stm_ssc.h"
+#include <linux/stm/stm_ssc.h>
 
 #undef dgb_print
 
Index: linux-2.6.17/drivers/spi/Kconfig
===================================================================
--- linux-2.6.17.orig/drivers/spi/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/drivers/spi/Kconfig	2008-03-05 10:58:50.000000000 +0000
@@ -103,6 +103,30 @@
 	  GPIO lines to provide the SPI bus. This can be used where
 	  the inbuilt hardware cannot provide the transfer mode, or
 	  where the board is using non hardware connected pins.
+
+config SPI_STM
+	bool "STMicroelectronics SPI support"
+	depends on SPI_MASTER && CPU_SUBTYPE_ST40
+	select SPI_BITBANG
+	help
+	  STMicroelectronics SoCs support for SPI.
+
+config SPI_STM_PIO
+        bool "SPI bit-banging PIO driver"
+	depends on SPI_STM
+	help
+	  If you say yes to this option, support will be included for the
+	  PIO driven SPI in bit-banging mode.
+
+config SPI_STM_SSC
+	bool "SPI hardware SSC driver"
+	depends on SPI_STM
+	select STM_SSC
+	help
+	  If you say yes to this option, support will be included for the
+	  SSC driven SPI.
+
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
@@ -121,6 +145,15 @@
 comment "SPI Protocol Masters"
 	depends on SPI_MASTER
 
+config SPI_SPIDEV
+	tristate "User mode SPI device driver support"
+	depends on SPI_MASTER && EXPERIMENTAL
+	help
+	  This supports user mode SPI protocol drivers.
+
+	  Note that this application programming interface is EXPERIMENTAL
+	  and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes.
+
 
 #
 # Add new SPI protocol masters in alphabetical order above this line
Index: linux-2.6.17/drivers/spi/Makefile
===================================================================
--- linux-2.6.17.orig/drivers/spi/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/drivers/spi/Makefile	2008-03-05 10:58:50.000000000 +0000
@@ -17,9 +17,12 @@
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
+obj-$(CONFIG_SPI_STM_PIO)		+= spi_stm_gpio.o
+obj-$(CONFIG_SPI_STM_SSC)		+= spi_stm_ssc.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
+obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 # 	... add above this line ...
 
 # SPI slave controller drivers (upstream link)
Index: linux-2.6.17/drivers/spi/spi.c
===================================================================
--- linux-2.6.17.orig/drivers/spi/spi.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/drivers/spi/spi.c	2008-03-05 10:58:50.000000000 +0000
@@ -23,6 +23,7 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
+#include <linux/mutex.h>
 #include <linux/spi/spi.h>
 
 
@@ -32,7 +33,7 @@
  */
 static void spidev_release(struct device *dev)
 {
-	const struct spi_device	*spi = to_spi_device(dev);
+	struct spi_device	*spi = to_spi_device(dev);
 
 	/* spi masters may cleanup for released devices */
 	if (spi->master->cleanup)
@@ -152,6 +153,11 @@
 	sdrv->shutdown(to_spi_device(dev));
 }
 
+/**
+ * spi_register_driver - register a SPI driver
+ * @sdrv: the driver to register
+ * Context: can sleep
+ */
 int spi_register_driver(struct spi_driver *sdrv)
 {
 	sdrv->driver.bus = &spi_bus_type;
@@ -180,23 +186,44 @@
 };
 
 static LIST_HEAD(board_list);
-static DECLARE_MUTEX(board_lock);
+static DEFINE_MUTEX(board_lock);
 
 
-/* On typical mainboards, this is purely internal; and it's not needed
+/**
+ * spi_new_device - instantiate one new SPI device
+ * @master: Controller to which device is connected
+ * @chip: Describes the SPI device
+ * Context: can sleep
+ *
+ * On typical mainboards, this is purely internal; and it's not needed
  * after board init creates the hard-wired devices.  Some development
  * platforms may not be able to use spi_register_board_info though, and
  * this is exported so that for example a USB or parport based adapter
  * driver could add devices (which it would learn about out-of-band).
+ *
+ * Returns the new device, or NULL.
  */
-struct spi_device *__init_or_module
-spi_new_device(struct spi_master *master, struct spi_board_info *chip)
+struct spi_device *spi_new_device(struct spi_master *master,
+				  struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
 	struct device		*dev = master->cdev.dev;
 	int			status;
 
-	/* NOTE:  caller did any chip->bus_num checks necessary */
+	/* NOTE:  caller did any chip->bus_num checks necessary.
+	 *
+	 * Also, unless we change the return value convention to use
+	 * error-or-pointer (not NULL-or-pointer), troubleshootability
+	 * suggests syslogged diagnostics are best here (ugh).
+	 */
+
+	/* Chipselects are numbered 0..max; validate. */
+	if (chip->chip_select >= master->num_chipselect) {
+		dev_err(dev, "cs%d > max %d\n",
+			chip->chip_select,
+			master->num_chipselect);
+		return NULL;
+	}
 
 	if (!spi_master_get(master))
 		return NULL;
@@ -210,12 +237,14 @@
 	proxy->master = master;
 	proxy->chip_select = chip->chip_select;
 	proxy->max_speed_hz = chip->max_speed_hz;
+	proxy->mode = chip->mode;
 	proxy->irq = chip->irq;
 	proxy->modalias = chip->modalias;
 
 	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
 			"%s.%u", master->cdev.class_id,
 			chip->chip_select);
+
 	proxy->dev.parent = dev;
 	proxy->dev.bus = &spi_bus_type;
 	proxy->dev.platform_data = (void *) chip->platform_data;
@@ -223,10 +252,10 @@
 	proxy->controller_state = NULL;
 	proxy->dev.release = spidev_release;
 
-	/* drivers may modify this default i/o setup */
+	/* drivers may modify this initial i/o setup */
 	status = master->setup(proxy);
 	if (status < 0) {
-		dev_dbg(dev, "can't %s %s, status %d\n",
+		dev_err(dev, "can't %s %s, status %d\n",
 				"setup", proxy->dev.bus_id, status);
 		goto fail;
 	}
@@ -236,7 +265,7 @@
 	 */
 	status = device_register(&proxy->dev);
 	if (status < 0) {
-		dev_dbg(dev, "can't %s %s, status %d\n",
+		dev_err(dev, "can't %s %s, status %d\n",
 				"add", proxy->dev.bus_id, status);
 		goto fail;
 	}
@@ -250,7 +279,12 @@
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
-/*
+/**
+ * spi_register_board_info - register SPI devices for a given board
+ * @info: array of chip descriptors
+ * @n: how many descriptors are provided
+ * Context: can sleep
+ *
  * Board-specific early init code calls this (probably during arch_initcall)
  * with segments of the SPI device table.  Any device nodes are created later,
  * after the relevant parent SPI controller (bus_num) is defined.  We keep
@@ -275,24 +309,21 @@
 	bi->n_board_info = n;
 	memcpy(bi->board_info, info, n * sizeof *info);
 
-	down(&board_lock);
+	mutex_lock(&board_lock);
 	list_add_tail(&bi->list, &board_list);
-	up(&board_lock);
+	mutex_unlock(&board_lock);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(spi_register_board_info);
 
 /* FIXME someone should add support for a __setup("spi", ...) that
  * creates board info from kernel command lines
  */
 
-static void __init_or_module
-scan_boardinfo(struct spi_master *master)
+static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
-	struct device		*dev = master->cdev.dev;
 
-	down(&board_lock);
+	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
 		struct spi_board_info	*chip = bi->board_info;
 		unsigned		n;
@@ -300,21 +331,13 @@
 		for (n = bi->n_board_info; n > 0; n--, chip++) {
 			if (chip->bus_num != master->bus_num)
 				continue;
-			/* some controllers only have one chip, so they
-			 * might not use chipselects.  otherwise, the
-			 * chipselects are numbered 0..max.
+			/* NOTE: this relies on spi_new_device to
+			 * issue diagnostics when given bogus inputs
 			 */
-			if (chip->chip_select >= master->num_chipselect
-					&& master->num_chipselect) {
-				dev_dbg(dev, "cs%d > max %d\n",
-					chip->chip_select,
-					master->num_chipselect);
-				continue;
-			}
 			(void) spi_new_device(master, chip);
 		}
 	}
-	up(&board_lock);
+	mutex_unlock(&board_lock);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -337,9 +360,10 @@
 /**
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
- * @size: how much driver-private data to preallocate; the pointer to this
+ * @size: how much zeroed driver-private data to allocate; the pointer to this
  *	memory is in the class_data field of the returned class_device,
  *	accessible with spi_master_get_devdata().
+ * Context: can sleep
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
@@ -352,15 +376,14 @@
  * the master's methods before calling spi_register_master(); and (after errors
  * adding the device) calling spi_master_put() to prevent a memory leak.
  */
-struct spi_master * __init_or_module
-spi_alloc_master(struct device *dev, unsigned size)
+struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {
 	struct spi_master	*master;
 
 	if (!dev)
 		return NULL;
 
-	master = kzalloc(size + sizeof *master, SLAB_KERNEL);
+	master = kzalloc(size + sizeof *master, GFP_KERNEL);
 	if (!master)
 		return NULL;
 
@@ -376,6 +399,7 @@
 /**
  * spi_register_master - register SPI master controller
  * @master: initialized master, originally from spi_alloc_master()
+ * Context: can sleep
  *
  * SPI master controllers connect to their drivers using some non-SPI bus,
  * such as the platform bus.  The final stage of probe() in that code
@@ -392,10 +416,9 @@
  * After a successful return, the caller is responsible for calling
  * spi_unregister_master().
  */
-int __init_or_module
-spi_register_master(struct spi_master *master)
+int spi_register_master(struct spi_master *master)
 {
-	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
+	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
 	struct device		*dev = master->cdev.dev;
 	int			status = -ENODEV;
 	int			dynamic = 0;
@@ -403,8 +426,17 @@
 	if (!dev)
 		return -ENODEV;
 
+	/* even if it's just one always-selected device, there must
+	 * be at least one chipselect
+	 */
+	if (master->num_chipselect == 0)
+		return -EINVAL;
+
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num < 0) {
+		/* FIXME switch to an IDR based scheme, something like
+		 * I2C now uses, so we can't run out of "dynamic" IDs
+		 */
 		master->bus_num = atomic_dec_return(&dyn_bus_id);
 		dynamic = 1;
 	}
@@ -439,6 +471,7 @@
 /**
  * spi_unregister_master - unregister SPI master controller
  * @master: the master being unregistered
+ * Context: can sleep
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.
@@ -447,7 +480,9 @@
  */
 void spi_unregister_master(struct spi_master *master)
 {
-	(void) device_for_each_child(master->cdev.dev, NULL, __unregister);
+	int dummy;
+
+	dummy = device_for_each_child(master->cdev.dev, NULL, __unregister);
 	class_device_unregister(&master->cdev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
@@ -455,6 +490,7 @@
 /**
  * spi_busnum_to_master - look up master associated with bus_num
  * @bus_num: the master's bus number
+ * Context: can sleep
  *
  * This call may be used with devices that are registered after
  * arch init time.  It returns a refcounted pointer to the relevant
@@ -463,16 +499,20 @@
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
-	if (bus_num) {
-		char			name[8];
-		struct kobject		*bus;
-
-		snprintf(name, sizeof name, "spi%u", bus_num);
-		bus = kset_find_obj(&spi_master_class.subsys.kset, name);
-		if (bus)
-			return container_of(bus, struct spi_master, cdev.kobj);
+	struct class_device	*cdev;
+	struct spi_master	*master = NULL;
+	struct spi_master	*m;
+
+	down(&spi_master_class.sem);
+	list_for_each_entry(cdev, &spi_master_class.children, node) {
+		m = container_of(cdev, struct spi_master, cdev);
+		if (m->bus_num == bus_num) {
+			master = spi_master_get(m);
+			break;
+		}
 	}
-	return NULL;
+	up(&spi_master_class.sem);
+	return master;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 
@@ -488,6 +528,7 @@
  * spi_sync - blocking/synchronous SPI data transfers
  * @spi: device with which data will be exchanged
  * @message: describes the data transfers
+ * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
  * is non-interruptible, and has no timeout.  Low-overhead controller
@@ -504,7 +545,7 @@
  *
  * The return value is a negative error code if the message could not be
  * submitted, else zero.  When the value is zero, then message->status is
- * also defined:  it's the completion code for the transfer, either zero
+ * also defined;  it's the completion code for the transfer, either zero
  * or a negative error code from the controller driver.
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
@@ -534,6 +575,7 @@
  * @n_tx: size of txbuf, in bytes
  * @rxbuf: buffer into which data will be read
  * @n_rx: size of rxbuf, in bytes (need not be dma-safe)
+ * Context: can sleep
  *
  * This performs a half duplex MicroWire style transaction with the
  * device, sending txbuf and then reading rxbuf.  The return value
@@ -541,7 +583,8 @@
  * This call may only be used from a context that may sleep.
  *
  * Parameters to this routine are always copied using a small buffer;
- * performance-sensitive or bulk transfer code should instead use
+ * portable code should never use this for more than 32 bytes.
+ * Performance-sensitive or bulk transfer code should instead use
  * spi_{async,sync}() calls with dma-safe buffers.
  */
 int spi_write_then_read(struct spi_device *spi,
@@ -607,7 +650,7 @@
 {
 	int	status;
 
-	buf = kmalloc(SPI_BUFSIZ, SLAB_KERNEL);
+	buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
 	if (!buf) {
 		status = -ENOMEM;
 		goto err0;
Index: linux-2.6.17/drivers/spi/spi_bitbang.c
===================================================================
--- linux-2.6.17.orig/drivers/spi/spi_bitbang.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/drivers/spi/spi_bitbang.c	2008-03-05 10:58:50.000000000 +0000
@@ -16,7 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
@@ -188,16 +187,14 @@
 
 	bitbang = spi_master_get_devdata(spi->master);
 
-	/* REVISIT: some systems will want to support devices using lsb-first
-	 * bit encodings on the wire.  In pure software that would be trivial,
-	 * just bitbang_txrx_le_cphaX() routines shifting the other way, and
-	 * some hardware controllers also have this support.
+	/* Bitbangers can support SPI_CS_HIGH, SPI_3WIRE, and so on;
+	 * add those to master->flags, and provide the other support.
 	 */
-	if ((spi->mode & SPI_LSB_FIRST) != 0)
+	if ((spi->mode & ~(SPI_CPOL|SPI_CPHA|bitbang->flags)) != 0)
 		return -EINVAL;
 
 	if (!cs) {
-		cs = kzalloc(sizeof *cs, SLAB_KERNEL);
+		cs = kzalloc(sizeof *cs, GFP_KERNEL);
 		if (!cs)
 			return -ENOMEM;
 		spi->controller_state = cs;
@@ -211,7 +208,7 @@
 	if (!cs->txrx_word)
 		return -EINVAL;
 
-	retval = spi_bitbang_setup_transfer(spi, NULL);
+	retval = bitbang->setup_transfer(spi, NULL);
 	if (retval < 0)
 		return retval;
 
@@ -239,7 +236,7 @@
 /**
  * spi_bitbang_cleanup - default cleanup for per-word I/O loops
  */
-void spi_bitbang_cleanup(const struct spi_device *spi)
+void spi_bitbang_cleanup(struct spi_device *spi)
 {
 	kfree(spi->controller_state);
 }
@@ -266,9 +263,10 @@
  * Drivers can provide word-at-a-time i/o primitives, or provide
  * transfer-at-a-time ones to leverage dma or fifo hardware.
  */
-static void bitbang_work(void *_bitbang)
+static void bitbang_work(struct work_struct *work)
 {
-	struct spi_bitbang	*bitbang = _bitbang;
+	struct spi_bitbang	*bitbang =
+		container_of(work, struct spi_bitbang, work);
 	unsigned long		flags;
 
 	spin_lock_irqsave(&bitbang->lock, flags);
@@ -302,10 +300,6 @@
 		setup_transfer = NULL;
 
 		list_for_each_entry (t, &m->transfers, transfer_list) {
-			if (bitbang->shutdown) {
-				status = -ESHUTDOWN;
-				break;
-			}
 
 			/* override or restore speed and wordsize */
 			if (t->speed_hz || t->bits_per_word) {
@@ -410,8 +404,6 @@
 	m->status = -EINPROGRESS;
 
 	bitbang = spi_master_get_devdata(spi->master);
-	if (bitbang->shutdown)
-		return -ESHUTDOWN;
 
 	spin_lock_irqsave(&bitbang->lock, flags);
 	if (!spi->max_speed_hz)
@@ -442,9 +434,10 @@
  * hardware that basically exposes a shift register) or per-spi_transfer
  * (which takes better advantage of hardware like fifos or DMA engines).
  *
- * Drivers using per-word I/O loops should use (or call) spi_bitbang_setup and
- * spi_bitbang_cleanup to handle those spi master methods.  Those methods are
- * the defaults if the bitbang->txrx_bufs routine isn't initialized.
+ * Drivers using per-word I/O loops should use (or call) spi_bitbang_setup,
+ * spi_bitbang_cleanup and spi_bitbang_setup_transfer to handle those spi
+ * master methods.  Those methods are the defaults if the bitbang->txrx_bufs
+ * routine isn't initialized.
  *
  * This routine registers the spi_master, which will process requests in a
  * dedicated task, keeping IRQs unblocked most of the time.  To stop
@@ -457,7 +450,7 @@
 	if (!bitbang->master || !bitbang->chipselect)
 		return -EINVAL;
 
-	INIT_WORK(&bitbang->work, bitbang_work, bitbang);
+	INIT_WORK(&bitbang->work, bitbang_work, &bitbang->work);
 	spin_lock_init(&bitbang->lock);
 	INIT_LIST_HEAD(&bitbang->queue);
 
@@ -506,28 +499,12 @@
  */
 int spi_bitbang_stop(struct spi_bitbang *bitbang)
 {
-	unsigned	limit = 500;
-
-	spin_lock_irq(&bitbang->lock);
-	bitbang->shutdown = 0;
-	while (!list_empty(&bitbang->queue) && limit--) {
-		spin_unlock_irq(&bitbang->lock);
+	spi_unregister_master(bitbang->master);
 
-		dev_dbg(bitbang->master->cdev.dev, "wait for queue\n");
-		msleep(10);
-
-		spin_lock_irq(&bitbang->lock);
-	}
-	spin_unlock_irq(&bitbang->lock);
-	if (!list_empty(&bitbang->queue)) {
-		dev_err(bitbang->master->cdev.dev, "queue didn't empty\n");
-		return -EBUSY;
-	}
+	WARN_ON(!list_empty(&bitbang->queue));
 
 	destroy_workqueue(bitbang->workqueue);
 
-	spi_unregister_master(bitbang->master);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(spi_bitbang_stop);
Index: linux-2.6.17/drivers/spi/spi_stm_gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17/drivers/spi/spi_stm_gpio.c	2008-03-05 10:58:50.000000000 +0000
@@ -0,0 +1,297 @@
+/*
+ *  -------------------------------------------------------------------------
+ *  spi_stm_gpio.c SPI/GPIO driver for STMicroelectronics platforms
+ *  -------------------------------------------------------------------------
+ *
+ *  Copyright (c) 2008 STMicroelectronics Limited
+ *  Author: Francesco Virlinzi <francesco.virlinzi@st.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License version 2.0 ONLY.  See linux/COPYING for more information.
+ *
+ *  -------------------------------------------------------------------------
+ *  Changelog:
+ *  2008-02-05 Angus Clark <Angus.Clark@st.com>
+ *    - back-ported from stlinux2.3 to stlinux2.2
+ *  2008-01-24 Angus Clark <angus.clark@st.com>
+ *    - chip_select modified to ignore devices with no chip_select, and keep
+ *      hold of PIO pin (freeing pin selects STPIO_IN (high-Z) mode).
+ *    - added spi_stmpio_setup() and spi_stmpio_setup_transfer() to enfore
+ *	SPI_STMPIO_MAX_SPEED_HZ
+ *
+ *  -------------------------------------------------------------------------
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/io.h>
+#include <linux/param.h>
+
+#ifdef CONFIG_SPI_DEBUG
+#define dgb_print(fmt, args...)  printk(KERN_INFO "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NAME "spi_stm_pio"
+
+/* Maybe this should be included in platform_data? */
+#define SPI_STMPIO_MAX_SPEED_HZ		1000000
+
+static inline void setsck(struct spi_device *dev, int on)
+{
+	struct platform_device *pdev =
+		container_of(dev->dev.parent, struct platform_device, dev);
+	struct plat_ssc_pio_t *pio_info =
+		(struct plat_ssc_pio_t *)pdev->dev.platform_data;
+	stpio_set_pin(pio_info->clk, on ? 1 : 0);
+}
+
+static inline void setmosi(struct spi_device *dev, int on)
+{
+	struct platform_device *pdev
+		= container_of(dev->dev.parent, struct platform_device, dev);
+	struct plat_ssc_pio_t *pio_info =
+		(struct plat_ssc_pio_t *)pdev->dev.platform_data;
+	stpio_set_pin(pio_info->sdout, on ? 1 : 0);
+}
+
+static inline u32 getmiso(struct spi_device *dev)
+{
+	struct platform_device *pdev
+		= container_of(dev->dev.parent, struct platform_device, dev);
+	struct plat_ssc_pio_t *pio_info =
+		(struct plat_ssc_pio_t *)pdev->dev.platform_data;
+	return stpio_get_pin(pio_info->sdin) ? 1 : 0;
+}
+
+#define EXPAND_BITBANG_TXRX
+#define spidelay(x) ndelay(x)
+#include <linux/spi/spi_bitbang.h>
+
+struct spi_stm_gpio {
+	struct spi_bitbang	bitbang;
+	struct platform_device	*pdev;
+
+	/* Max speed supported by STPIO bit-banging SPI controller */
+	int max_speed_hz;
+};
+
+static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+
+static void spi_gpio_chipselect(struct spi_device *spi, int value)
+{
+	unsigned int out;
+
+	dgb_print("\n");
+	if (spi->chip_select == SPI_NO_CHIPSELECT)
+		return;
+
+	/* Request stpio_pin if not already done so */
+	/*  (stored in spi_device->controller_data) */
+	if (!spi->controller_data)
+		spi->controller_data =
+			stpio_request_pin(spi_get_bank(spi->chip_select),
+					  spi_get_line(spi->chip_select),
+					  "spi-cs", STPIO_OUT);
+
+	if (!spi->controller_data) {
+		printk(KERN_ERR NAME " Error spi-cs locked or not-exist\n");
+		return;
+	}
+
+	if (value == BITBANG_CS_ACTIVE)
+		out = spi->mode & SPI_CS_HIGH ? 1 : 0;
+	else
+		out = spi->mode & SPI_CS_HIGH ? 0 : 1;
+
+	stpio_set_pin((struct stpio_pin *)spi->controller_data, out);
+
+	dgb_print("%s PIO%d[%d] -> %d \n",
+		  value == BITBANG_CS_ACTIVE ? "select" : "deselect",
+		  spi_get_bank(spi->chip_select),
+		  spi_get_line(spi->chip_select), out);
+
+	return;
+}
+
+
+static int spi_stmpio_setup(struct spi_device *spi)
+{
+	struct spi_stm_gpio *spi_st = spi_master_get_devdata(spi->master);
+
+	dgb_print("\n");
+
+	if (spi->max_speed_hz > spi_st->max_speed_hz) {
+		printk(KERN_ERR NAME " requested baud rate (%dhz) exceeds "
+		       "max (%dhz)\n",
+		       spi->max_speed_hz, spi_st->max_speed_hz);
+		return -EINVAL;
+	}
+
+	return spi_bitbang_setup(spi);
+}
+
+static int spi_stmpio_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	dgb_print("\n");
+
+	if (t)
+		if (t->speed_hz > spi->max_speed_hz) {
+			printk(KERN_ERR NAME " requested baud rate (%dhz) "
+			       "exceeds max (%dhz)\n",
+			       t->speed_hz, spi->max_speed_hz);
+			return -EINVAL;
+		}
+
+	return spi_bitbang_setup_transfer(spi, t);
+}
+
+static int __init spi_probe(struct platform_device *pdev)
+{
+	struct plat_ssc_pio_t *pio_info =
+			(struct plat_ssc_pio_t *)pdev->dev.platform_data;
+	struct spi_master *master;
+	struct spi_stm_gpio *st_bitbang;
+
+	dgb_print("\n");
+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_stm_gpio));
+	if (!master)
+		return -1;
+
+	st_bitbang = spi_master_get_devdata(master);
+	if (!st_bitbang)
+		return -1;
+
+	platform_set_drvdata(pdev, st_bitbang);
+	st_bitbang->bitbang.master = spi_master_get(master);
+	st_bitbang->bitbang.master->setup = spi_stmpio_setup;
+	st_bitbang->bitbang.setup_transfer = spi_stmpio_setup_transfer;
+	st_bitbang->bitbang.chipselect = spi_gpio_chipselect;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
+
+	master->num_chipselect = SPI_NO_CHIPSELECT + 1;
+	master->bus_num = pdev->id;
+	st_bitbang->max_speed_hz = SPI_STMPIO_MAX_SPEED_HZ;
+
+	pio_info->clk = stpio_request_pin(pio_info->sclbank,
+					  pio_info->sclpin,
+					  "SPI Clock", STPIO_OUT);
+	if (!pio_info->clk) {
+		spi_master_put(master);
+		printk(KERN_ERR NAME " Faild to clk pin allocation\n");
+		return -1;
+	}
+
+	pio_info->sdout = stpio_request_pin(pio_info->sdoutbank,
+					    pio_info->sdoutpin,
+					    "SPI Data Out", STPIO_OUT);
+	if (!pio_info->sdout) {
+		spi_master_put(master);
+		printk(KERN_ERR NAME " Faild to sda pin allocation\n");
+		return -1;
+	}
+
+	pio_info->sdin = stpio_request_pin(pio_info->sdinbank,
+					   pio_info->sdinpin,
+					   "SPI Data In", STPIO_IN);
+	if (!pio_info->sdin) {
+		spi_master_put(master);
+		printk(KERN_ERR NAME " Faild to sdo pin allocation\n");
+		return -1;
+	}
+
+	stpio_set_pin(pio_info->clk, 0);
+	stpio_set_pin(pio_info->sdout, 0);
+	stpio_set_pin(pio_info->sdin, 0);
+
+	if (spi_bitbang_start(&st_bitbang->bitbang)) {
+		spi_master_put(master);
+		printk(KERN_ERR NAME
+		       "The SPI Core refuses the spi_stm_gpio adapter\n");
+		return -1;
+	}
+	printk(KERN_INFO NAME ": Registered SPI Bus %d: PIO%d[%d/%d/%d]\n",
+	       master->bus_num, pio_info->sclbank, pio_info->sclpin,
+	       pio_info->sdoutpin, pio_info->sdinpin);
+
+	return 0;
+}
+
+static int spi_remove(struct platform_device *pdev)
+{
+	struct plat_ssc_pio_t *pio_info =
+			(struct plat_ssc_pio_t *)pdev->dev.platform_data;
+	struct spi_stm_gpio *sp = platform_get_drvdata(pdev);
+
+	dgb_print("\n");
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+	stpio_free_pin(pio_info->clk);
+	stpio_free_pin(pio_info->sdout);
+	stpio_free_pin(pio_info->sdin);
+	return 0;
+}
+
+static struct platform_driver spi_sw_driver = {
+	.driver.name = "spi_st_pio",
+	.driver.owner = THIS_MODULE,
+	.probe = spi_probe,
+	.remove = spi_remove,
+};
+
+static int __init spi_gpio_init(void)
+{
+	printk(KERN_INFO NAME ": PIO based SPI Driver\n");
+	return platform_driver_register(&spi_sw_driver);
+}
+
+static void __exit spi_gpio_exit(void)
+{
+	dgb_print("\n");
+	platform_driver_unregister(&spi_sw_driver);
+}
+
+MODULE_AUTHOR("Francesco Virlinzi <francesco.virlinzi@st.com>");
+MODULE_DESCRIPTION("GPIO based SPI Driver");
+MODULE_LICENSE("GPL");
+
+module_init(spi_gpio_init);
+module_exit(spi_gpio_exit);
+
Index: linux-2.6.17/drivers/spi/spi_stm_ssc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17/drivers/spi/spi_stm_ssc.c	2008-03-05 10:58:50.000000000 +0000
@@ -0,0 +1,488 @@
+/*
+ *  ------------------------------------------------------------------------
+ *  spi_stm_ssc.c SPI/SSC driver for STMicroelectronics platforms
+ *  ------------------------------------------------------------------------
+ *
+ *  Copyright (c) 2008 STMicroelectronics Limited
+ *  Author: Angus Clark <Angus.Clark@st.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License Version 2.0 only.  See linux/COPYING for more information.
+ *
+ *  ------------------------------------------------------------------------
+ *  Changelog:
+ *  2008-02-05 Angus Clark <Angus.Clark@st.com>
+ *    - back-ported from stlinux2.3 to stlinux2.2
+ *
+ *  ------------------------------------------------------------------------
+ */
+
+#include <linux/stpio.h>
+#include <asm/semaphore.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/st_soc.h>
+#include <linux/stm/stm_ssc.h>
+#include <linux/param.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/delay.h>
+
+#undef dgb_print
+
+#ifdef CONFIG_SPI_DEBUG
+#define SPI_LOOP_DEBUG
+#define dgb_print(fmt, args...)  printk(KERN_INFO "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NAME "spi_stm_ssc"
+
+struct spi_stm_ssc {
+
+	/* SSC SPI Controller */
+	struct spi_bitbang	bitbang;
+	unsigned long		base;
+	unsigned int		fcomms;
+	struct platform_device  *pdev;
+	struct list_head	list;
+	struct ssc_t		*ssc_bus;
+
+	/* SSC SPI current transaction */
+	const u8		*tx_ptr;
+	u8			*rx_ptr;
+	u16			bits_per_word;
+	unsigned int		baud;
+	unsigned int		tx_bytes_pending;
+	unsigned int		rx_bytes_pending;
+	struct completion	done;
+
+};
+
+static void spi_stmssc_chipselect(struct spi_device *spi, int value)
+{
+	unsigned int out;
+
+	dgb_print("\n");
+	if (spi->chip_select == SPI_NO_CHIPSELECT)
+		return;
+
+	/* Request stpio_pin if not already done so */
+	/*  (stored in spi_device->controller_data) */
+	if (!spi->controller_data)
+		spi->controller_data =
+			stpio_request_pin(spi_get_bank(spi->chip_select),
+					  spi_get_line(spi->chip_select),
+					  "spi-cs", STPIO_OUT);
+	if (!spi->controller_data) {
+		printk(KERN_ERR NAME " Error spi-cs locked or not-exist\n");
+		return;
+	}
+
+	if (value == BITBANG_CS_ACTIVE)
+		out = spi->mode & SPI_CS_HIGH ? 1 : 0;
+	else
+		out = spi->mode & SPI_CS_HIGH ? 0 : 1;
+
+	stpio_set_pin((struct stpio_pin *)spi->controller_data, out);
+
+	dgb_print("%s PIO%d[%d] -> %d \n",
+		  value == BITBANG_CS_ACTIVE ? "select" : "deselect",
+		  spi_get_bank(spi->chip_select),
+		  spi_get_line(spi->chip_select), out);
+
+	return;
+}
+
+static int spi_stmssc_setup_transfer(struct spi_device *spi,
+				     struct spi_transfer *t)
+{
+	struct spi_stm_ssc *st_ssc;
+	u32 hz;
+	u8 bits_per_word;
+	u16 reg;
+	u32 sscbrg;
+
+	st_ssc = spi_master_get_devdata(spi->master);
+	bits_per_word = (t) ? t->bits_per_word : 0;
+	hz = (t) ? t->speed_hz : 0;
+
+	/* If not specified, use defaults */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+	if (!hz)
+		hz = spi->max_speed_hz;
+
+	/* Actually, can probably support 2-16 without any other change!!! */
+	if (bits_per_word != 8 && bits_per_word != 16) {
+		printk(KERN_ERR NAME " unsupported bits_per_word=%d\n", bits_per_word);
+		return -EINVAL;
+	}
+	st_ssc->bits_per_word = bits_per_word;
+
+	/* Set SSC_BRF */
+	/* TODO: program prescaler for slower baudrates */
+	sscbrg = st_ssc->fcomms/(2*hz);
+	if (sscbrg < 0x07 || sscbrg > (0x1 << 16)) {
+		printk(KERN_ERR NAME " baudrate outside valid range %d (sscbrg = %d)\n",
+			  hz, sscbrg);
+		return -EINVAL;
+	}
+	st_ssc->baud = st_ssc->fcomms/(2*sscbrg);
+	if (sscbrg == (0x1 << 16)) /* 16-bit counter wraps */
+		sscbrg = 0x0;
+	dgb_print("setting baudrate: hz = %d, sscbrg = %d\n", hz, sscbrg);
+	ssc_store16(st_ssc, SSC_BRG, sscbrg);
+
+	 /* Set SSC_CTL and enable SSC */
+	 reg = ssc_load16(st_ssc, SSC_CTL);
+	 reg |= SSC_CTL_MS;
+
+	 if (spi->mode & SPI_CPOL)
+		 reg |= SSC_CTL_PO;
+	 else
+		 reg &= ~SSC_CTL_PO;
+
+	 if (spi->mode & SPI_CPHA)
+		 reg |= SSC_CTL_PH;
+	 else
+		 reg &= ~SSC_CTL_PH;
+
+	 if ((spi->mode & SPI_LSB_FIRST) == 0)
+		 reg |= SSC_CTL_HB;
+	 else
+		 reg &= ~SSC_CTL_HB;
+
+	 if (spi->mode & SPI_LOOP)
+		 reg |= SSC_CTL_LPB;
+	 else
+		 reg &= ~SSC_CTL_LPB;
+
+	 reg &= 0xfff0;
+	 reg |= (bits_per_word - 1);
+
+	 reg |= SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO;
+	 reg |= SSC_CTL_EN;
+
+	 dgb_print("ssc_ctl = 0x%04x\n", reg);
+	 ssc_store16(st_ssc, SSC_CTL, reg);
+
+	 /* Clear the status register */
+	 ssc_load16(st_ssc, SSC_RBUF);
+
+	 return 0;
+}
+
+/* the spi->mode bits understood by this driver: */
+#define MODEBITS  (SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_LOOP | SPI_CS_HIGH)
+static int spi_stmssc_setup(struct spi_device *spi)
+{
+	struct spi_stm_ssc *st_ssc;
+	int retval;
+
+	st_ssc = spi_master_get_devdata(spi->master);
+
+	if (spi->mode & ~MODEBITS) {
+		printk(KERN_ERR NAME "unsupported mode bits %x\n",
+			  spi->mode & ~MODEBITS);
+		return -EINVAL;
+	}
+
+	if (!spi->max_speed_hz)  {
+		printk(KERN_ERR NAME " max_speed_hz unspecified\n");
+		return -EINVAL;
+	}
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	retval = spi_stmssc_setup_transfer(spi, NULL);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+/* For SSC SPI as MASTER, TX/RX is handled as follows:
+
+   1. Fill the TX_FIFO with up to (SSC_TXFIFO_SIZE - 1) words, and enable
+      TX_FIFO_EMPTY interrupts.
+   2. When the last word of TX_FIFO is copied to the shift register,
+      a TX_FIFO_EMPTY interrupt is issued, and the last word will *start* being
+      shifted out/in.
+   3. On receiving a TX_FIFO_EMPTY interrupt, copy all *available* received
+      words from the RX_FIFO. Note, depending on the time taken to shift out/in
+      the 'last' word compared to the IRQ latency, the 'last' word may not be
+      available yet in the RX_FIFO.
+   4. If there are more bytes to TX, refill the TX_FIFO.  Since the 'last' word
+      from the previous iteration may still be (or about to be) in the RX_FIFO,
+      only add up to (SSC_TXFIFO_SIZE - 1) words.  If all bytes have been
+      transmitted, disable TX and set completion.
+   5. If we are interested in the received data, check to see if the 'last' word
+      has been received.  If not, then wait the period of shifting 1 word, then
+      read the 'last' word from the RX_FIFO.
+
+*/
+static void spi_stmssc_fill_tx_fifo(struct spi_stm_ssc *st_ssc)
+{
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+	int i;
+
+	for (i = 0; i < SSC_TXFIFO_SIZE - 1 && st_ssc->tx_bytes_pending > 0; i++) {
+		if (st_ssc->bits_per_word > 8) {
+			if (st_ssc->tx_ptr) {
+				tmp.bytes[1] = *st_ssc->tx_ptr++;
+				tmp.bytes[0] = *st_ssc->tx_ptr++;
+			} else {
+				tmp.bytes[1] = 0;
+				tmp.bytes[0] = 0;
+			}
+
+			st_ssc->tx_bytes_pending -= 2;
+
+		} else {
+			if (st_ssc->tx_ptr)
+				tmp.bytes[0] = *st_ssc->tx_ptr++;
+			else
+				tmp.bytes[0] = 0;
+
+			st_ssc->tx_bytes_pending--;
+		}
+		ssc_store16(st_ssc, SSC_TBUF, tmp.word);
+	}
+}
+
+static int spi_stmssc_rx_mopup(struct spi_stm_ssc *st_ssc)
+{
+	unsigned long word_period_ns;
+	u16 rx_fifo_status;
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+
+	dgb_print("\n");
+
+	word_period_ns = 1000000000 / st_ssc->baud;
+	word_period_ns *= st_ssc->bits_per_word;
+
+	/* delay for period equivalent to shifting 1 complete word
+	   out of and into shift register */
+	ndelay(word_period_ns);
+
+	/* Check 'last' word is actually there! */
+	rx_fifo_status = ssc_load16(st_ssc, SSC_RX_FSTAT);
+	if (rx_fifo_status == 1) {
+		tmp.word = ssc_load16(st_ssc, SSC_RBUF);
+		if (st_ssc->rx_ptr) {
+			if (st_ssc->bits_per_word > 8) {
+				*st_ssc->rx_ptr++ = tmp.bytes[1];
+				*st_ssc->rx_ptr++ = tmp.bytes[0];
+				st_ssc->rx_bytes_pending -= 2;
+			} else {
+				*st_ssc->rx_ptr++ = tmp.bytes[0];
+				st_ssc->rx_bytes_pending--;
+			}
+		}
+		if (st_ssc->rx_bytes_pending)
+			dgb_print("rx_bytes_pending = %d\n",
+				  st_ssc->rx_bytes_pending);
+	} else
+		dgb_print("should only be one word in RX_FIFO"
+			  "(rx_fifo_status = %d)\n", rx_fifo_status);
+
+	return 0;
+}
+
+
+static int spi_stmssc_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct spi_stm_ssc *st_ssc;
+
+	dgb_print("\n");
+
+	st_ssc = spi_master_get_devdata(spi->master);
+
+	st_ssc->tx_ptr = t->tx_buf;
+	st_ssc->rx_ptr = t->rx_buf;
+	st_ssc->tx_bytes_pending = t->len;
+	st_ssc->rx_bytes_pending = t->len;
+	INIT_COMPLETION(st_ssc->done);
+
+	/* fill TX_FIFO */
+	spi_stmssc_fill_tx_fifo(st_ssc);
+
+	/* enable TX_FIFO_EMPTY interrupts */
+	ssc_store16(st_ssc, SSC_IEN, SSC_IEN_TIEN);
+
+	/* wait for all bytes to be transmitted*/
+	wait_for_completion(&st_ssc->done);
+
+	/* if necessary, check all bytes have been received */
+	if (st_ssc->rx_bytes_pending && st_ssc->rx_ptr)
+		spi_stmssc_rx_mopup(st_ssc);
+
+	/* disable ints */
+	ssc_store16(st_ssc, SSC_IEN, 0x0);
+
+	return t->len - st_ssc->tx_bytes_pending;
+}
+
+static void spi_stmssc_irq(void *data)
+{
+	struct spi_stm_ssc *st_ssc = (struct spi_stm_ssc *)data;
+	unsigned int rx_fifo_status;
+	u16 ssc_status;
+
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+
+
+	ssc_status = ssc_load16(st_ssc, SSC_STA);
+
+	/* FIFO_TX_EMPTY */
+	if (ssc_status & SSC_STA_TIR) {
+		/* Find number of words available in RX_FIFO: 8 if RX_FIFO_FULL,
+		   else SSC_RX_FSTAT (0-7)
+		*/
+		rx_fifo_status = (ssc_status & SSC_STA_RIR) ? 8 :
+			ssc_load16(st_ssc, SSC_RX_FSTAT);
+		/* Read all available words from RX_FIFO */
+		while (rx_fifo_status) {
+			tmp.word = ssc_load16(st_ssc, SSC_RBUF);
+
+			if (st_ssc->rx_ptr) {
+				if (st_ssc->bits_per_word > 8) {
+					*st_ssc->rx_ptr++ = tmp.bytes[1];
+					*st_ssc->rx_ptr++ = tmp.bytes[0];
+					st_ssc->rx_bytes_pending -= 2;
+				} else {
+					*st_ssc->rx_ptr++ = tmp.bytes[0];
+					st_ssc->rx_bytes_pending--;
+				}
+			}
+
+			rx_fifo_status = ssc_load16(st_ssc, SSC_RX_FSTAT);
+		}
+
+		/* See if there is more data to send */
+		if (st_ssc->tx_bytes_pending > 0)
+			spi_stmssc_fill_tx_fifo(st_ssc);
+		else {
+			/* No more data to send */
+			ssc_store16(st_ssc, SSC_IEN, 0x0);
+			complete(&st_ssc->done);
+		}
+	}
+}
+
+static LIST_HEAD(stm_busses);
+
+static int probe_spi_stmssc(struct ssc_t *ssc_bus, int bus_num) {
+	struct spi_master *master;
+	struct spi_stm_ssc *st_ssc;
+	u16 reg;
+
+	master = spi_alloc_master(&ssc_bus->dev, sizeof(struct spi_stm_ssc));
+	if (!master)
+		return -ENOMEM;
+
+	st_ssc = spi_master_get_devdata(master);
+	st_ssc->ssc_bus = ssc_bus;
+
+	st_ssc->bitbang.master		= spi_master_get(master);
+	st_ssc->bitbang.chipselect	= spi_stmssc_chipselect;
+	st_ssc->bitbang.setup_transfer	= spi_stmssc_setup_transfer;
+	st_ssc->bitbang.txrx_bufs	= spi_stmssc_txrx_bufs;
+	st_ssc->bitbang.master->setup	= spi_stmssc_setup;
+
+	master->num_chipselect = SPI_NO_CHIPSELECT + 1;
+	master->bus_num = bus_num;
+	init_completion(&st_ssc->done);
+
+	st_ssc->base = (unsigned long)ssc_bus->base;
+	ssc_request_bus(ssc_bus, spi_stmssc_irq, st_ssc);
+
+	st_ssc->fcomms = ssc_get_clock();
+
+	/* Disable I2C and Reset SSC */
+	ssc_store16(st_ssc, SSC_I2C, 0x0);
+	reg = ssc_load16(st_ssc, SSC_CTL);
+	reg |= SSC_CTL_SR;
+	ssc_store16(st_ssc, SSC_CTL, reg);
+
+	udelay(1);
+	reg = ssc_load16(st_ssc, SSC_CTL);
+	reg &= ~SSC_CTL_SR;
+	ssc_store16(st_ssc, SSC_CTL, reg);
+
+	/* Start bitbang worker */
+	if (spi_bitbang_start(&st_ssc->bitbang)) {
+		printk(KERN_ERR NAME
+		       " The SPI Core refuses the spi_stm_ssc adapter\n");
+		ssc_release_bus(ssc_bus);
+		spi_master_put(master);
+		return -ENODEV;
+	}
+
+	/* Add to list of ST_SSC SPI busses */
+	list_add(&(st_ssc->list), &(stm_busses));
+
+	printk(KERN_INFO NAME ": Registered SPI Bus %d on SSC%d\n",
+	       master->bus_num, ssc_bus->ssc_id);
+
+	return 0;
+
+}
+
+static int __init spi_stm_ssc_init(void)
+{
+	unsigned int n_ssc = ssc_device_available();
+	unsigned int i;
+	unsigned int bus_num = 0;
+
+	printk(KERN_INFO NAME ": SSC SPI Driver\n");
+
+	/* Add SSC SPI busses */
+	for (i = 0; i < n_ssc; i++) {
+		if (ssc_capability(i) & SSC_SPI_CAPABILITY) {
+			if (probe_spi_stmssc(ssc_device_request(i), bus_num) == 0)
+				bus_num++;
+		}
+	}
+
+	return 0;
+}
+
+static void __exit spi_stm_ssc_exit(void)
+{
+	struct list_head *item;
+	struct spi_stm_ssc *st_ssc;
+	dgb_print("\n");
+
+	list_for_each(item, &(stm_busses)) {
+		st_ssc = container_of(item, struct spi_stm_ssc, list);
+		list_del(&st_ssc->list);
+		spi_bitbang_stop(&st_ssc->bitbang);
+		ssc_release_bus(st_ssc->ssc_bus);
+		kfree(st_ssc->bitbang.master);
+	}
+}
+
+late_initcall(spi_stm_ssc_init);
+module_exit(spi_stm_ssc_exit);
+
+MODULE_AUTHOR("STMicroelectronics <www.st.com>");
+MODULE_DESCRIPTION("STM SSC SPI driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.17/drivers/spi/spidev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17/drivers/spi/spidev.c	2008-03-05 10:58:50.000000000 +0000
@@ -0,0 +1,590 @@
+/*
+ * spidev.c -- simple synchronous userspace interface to SPI devices
+ *
+ * Copyright (C) 2006 SWAPP
+ *	Andrea Paterniani <a.paterniani@swapp-eng.it>
+ * Copyright (C) 2007 David Brownell (simplification, cleanup)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+
+#include <asm/uaccess.h>
+
+
+/*
+ * This supports acccess to SPI devices using normal userspace I/O calls.
+ * Note that while traditional UNIX/POSIX I/O semantics are half duplex,
+ * and often mask message boundaries, full SPI support requires full duplex
+ * transfers.  There are several kinds of of internal message boundaries to
+ * handle chipselect management and other protocol options.
+ *
+ * SPI has a character major number assigned.  We allocate minor numbers
+ * dynamically using a bitmask.  You must use hotplug tools, such as udev
+ * (or mdev with busybox) to create and destroy the /dev/spidevB.C device
+ * nodes, since there is no fixed association of minor numbers with any
+ * particular SPI bus or device.
+ */
+#define SPIDEV_MAJOR			153	/* assigned */
+#define N_SPI_MINORS			32	/* ... up to 256 */
+
+static unsigned long	minors[N_SPI_MINORS / BITS_PER_LONG];
+
+
+/* Bit masks for spi_device.mode management.  Note that incorrect
+ * settings for CS_HIGH and 3WIRE can cause *lots* of trouble for other
+ * devices on a shared bus:  CS_HIGH, because this device will be
+ * active when it shouldn't be;  3WIRE, because when active it won't
+ * behave as it should.
+ *
+ * REVISIT should changing those two modes be privileged?
+ */
+#define SPI_MODE_MASK		(SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
+				| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP)
+
+struct spidev_data {
+	struct device		dev;
+	dev_t			devt;
+	struct class_device	*class_dev;
+	struct spi_device	*spi;
+	struct list_head	device_entry;
+
+	struct mutex		buf_lock;
+	unsigned		users;
+	u8			*buffer;
+};
+
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+static unsigned bufsiz = 4096;
+module_param(bufsiz, uint, S_IRUGO);
+MODULE_PARM_DESC(bufsiz, "data bytes in biggest supported SPI message");
+
+/*-------------------------------------------------------------------------*/
+
+/* Read-only message with current device setup */
+static ssize_t
+spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct spidev_data	*spidev;
+	struct spi_device	*spi;
+	ssize_t			status = 0;
+
+	/* chipselect only toggles at start or end of operation */
+	if (count > bufsiz)
+		return -EMSGSIZE;
+
+	spidev = filp->private_data;
+	spi = spidev->spi;
+
+	mutex_lock(&spidev->buf_lock);
+	status = spi_read(spi, spidev->buffer, count);
+	if (status == 0) {
+		unsigned long	missing;
+
+		missing = copy_to_user(buf, spidev->buffer, count);
+		if (count && missing == count)
+			status = -EFAULT;
+		else
+			status = count - missing;
+	}
+	mutex_unlock(&spidev->buf_lock);
+
+	return status;
+}
+
+/* Write-only message with current device setup */
+static ssize_t
+spidev_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	struct spidev_data	*spidev;
+	struct spi_device	*spi;
+	ssize_t			status = 0;
+	unsigned long		missing;
+
+	/* chipselect only toggles at start or end of operation */
+	if (count > bufsiz)
+		return -EMSGSIZE;
+
+	spidev = filp->private_data;
+	spi = spidev->spi;
+
+	mutex_lock(&spidev->buf_lock);
+	missing = copy_from_user(spidev->buffer, buf, count);
+	if (missing == 0) {
+		status = spi_write(spi, spidev->buffer, count);
+		if (status == 0)
+			status = count;
+	} else
+		status = -EFAULT;
+	mutex_unlock(&spidev->buf_lock);
+
+	return status;
+}
+
+static int spidev_message(struct spidev_data *spidev,
+		struct spi_ioc_transfer *u_xfers, unsigned n_xfers)
+{
+	struct spi_message	msg;
+	struct spi_transfer	*k_xfers;
+	struct spi_transfer	*k_tmp;
+	struct spi_ioc_transfer *u_tmp;
+	struct spi_device	*spi = spidev->spi;
+	unsigned		n, total;
+	u8			*buf;
+	int			status = -EFAULT;
+
+	spi_message_init(&msg);
+	k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
+	if (k_xfers == NULL)
+		return -ENOMEM;
+
+	/* Construct spi_message, copying any tx data to bounce buffer.
+	 * We walk the array of user-provided transfers, using each one
+	 * to initialize a kernel version of the same transfer.
+	 */
+	mutex_lock(&spidev->buf_lock);
+	buf = spidev->buffer;
+	total = 0;
+	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+			n;
+			n--, k_tmp++, u_tmp++) {
+		k_tmp->len = u_tmp->len;
+
+		total += k_tmp->len;
+		if (total > bufsiz) {
+			status = -EMSGSIZE;
+			goto done;
+		}
+
+		if (u_tmp->rx_buf) {
+			k_tmp->rx_buf = buf;
+			if (!access_ok(VERIFY_WRITE, (u8 __user *)
+						(ptrdiff_t) u_tmp->rx_buf,
+						u_tmp->len))
+				goto done;
+		}
+		if (u_tmp->tx_buf) {
+			k_tmp->tx_buf = buf;
+			if (copy_from_user(buf, (const u8 __user *)
+						(ptrdiff_t) u_tmp->tx_buf,
+					u_tmp->len))
+				goto done;
+		}
+		buf += k_tmp->len;
+
+		k_tmp->cs_change = !!u_tmp->cs_change;
+		k_tmp->bits_per_word = u_tmp->bits_per_word;
+		k_tmp->delay_usecs = u_tmp->delay_usecs;
+		k_tmp->speed_hz = u_tmp->speed_hz;
+#ifdef VERBOSE
+		dev_dbg(&spi->dev,
+			"  xfer len %zd %s%s%s%dbits %u usec %uHz\n",
+			u_tmp->len,
+			u_tmp->rx_buf ? "rx " : "",
+			u_tmp->tx_buf ? "tx " : "",
+			u_tmp->cs_change ? "cs " : "",
+			u_tmp->bits_per_word ? : spi->bits_per_word,
+			u_tmp->delay_usecs,
+			u_tmp->speed_hz ? : spi->max_speed_hz);
+#endif
+		spi_message_add_tail(k_tmp, &msg);
+	}
+
+	status = spi_sync(spi, &msg);
+	if (status < 0)
+		goto done;
+
+	/* copy any rx data out of bounce buffer */
+	buf = spidev->buffer;
+	for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
+		if (u_tmp->rx_buf) {
+			if (__copy_to_user((u8 __user *)
+					(ptrdiff_t) u_tmp->rx_buf, buf,
+					u_tmp->len)) {
+				status = -EFAULT;
+				goto done;
+			}
+		}
+		buf += u_tmp->len;
+	}
+	status = total;
+
+done:
+	mutex_unlock(&spidev->buf_lock);
+	kfree(k_xfers);
+	return status;
+}
+
+static int
+spidev_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	int			err = 0;
+	int			retval = 0;
+	struct spidev_data	*spidev;
+	struct spi_device	*spi;
+	u32			tmp;
+	unsigned		n_ioc;
+	struct spi_ioc_transfer	*ioc;
+
+	/* Check type and command number */
+	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
+		return -ENOTTY;
+
+	/* Check access direction once here; don't repeat below.
+	 * IOC_DIR is from the user perspective, while access_ok is
+	 * from the kernel perspective; so they look reversed.
+	 */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE,
+				(void __user *)arg, _IOC_SIZE(cmd));
+	if (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ,
+				(void __user *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
+
+	spidev = filp->private_data;
+	spi = spidev->spi;
+
+	switch (cmd) {
+	/* read requests */
+	case SPI_IOC_RD_MODE:
+		retval = __put_user(spi->mode & SPI_MODE_MASK,
+					(__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_LSB_FIRST:
+		retval = __put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
+					(__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_BITS_PER_WORD:
+		retval = __put_user(spi->bits_per_word, (__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_MAX_SPEED_HZ:
+		retval = __put_user(spi->max_speed_hz, (__u32 __user *)arg);
+		break;
+
+	/* write requests */
+	case SPI_IOC_WR_MODE:
+		retval = __get_user(tmp, (u8 __user *)arg);
+		if (retval == 0) {
+			u8	save = spi->mode;
+
+			if (tmp & ~SPI_MODE_MASK) {
+				retval = -EINVAL;
+				break;
+			}
+
+			tmp |= spi->mode & ~SPI_MODE_MASK;
+			spi->mode = (u8)tmp;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->mode = save;
+			else
+				dev_dbg(&spi->dev, "spi mode %02x\n", tmp);
+		}
+		break;
+	case SPI_IOC_WR_LSB_FIRST:
+		retval = __get_user(tmp, (__u8 __user *)arg);
+		if (retval == 0) {
+			u8	save = spi->mode;
+
+			if (tmp)
+				spi->mode |= SPI_LSB_FIRST;
+			else
+				spi->mode &= ~SPI_LSB_FIRST;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->mode = save;
+			else
+				dev_dbg(&spi->dev, "%csb first\n",
+						tmp ? 'l' : 'm');
+		}
+		break;
+	case SPI_IOC_WR_BITS_PER_WORD:
+		retval = __get_user(tmp, (__u8 __user *)arg);
+		if (retval == 0) {
+			u8	save = spi->bits_per_word;
+
+			spi->bits_per_word = tmp;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->bits_per_word = save;
+			else
+				dev_dbg(&spi->dev, "%d bits per word\n", tmp);
+		}
+		break;
+	case SPI_IOC_WR_MAX_SPEED_HZ:
+		retval = __get_user(tmp, (__u32 __user *)arg);
+		if (retval == 0) {
+			u32	save = spi->max_speed_hz;
+
+			spi->max_speed_hz = tmp;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->max_speed_hz = save;
+			else
+				dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);
+		}
+		break;
+
+	default:
+		/* segmented and/or full-duplex I/O request */
+		if (_IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))
+				|| _IOC_DIR(cmd) != _IOC_WRITE)
+			return -ENOTTY;
+
+		tmp = _IOC_SIZE(cmd);
+		if ((tmp % sizeof(struct spi_ioc_transfer)) != 0) {
+			retval = -EINVAL;
+			break;
+		}
+		n_ioc = tmp / sizeof(struct spi_ioc_transfer);
+		if (n_ioc == 0)
+			break;
+
+		/* copy into scratch area */
+		ioc = kmalloc(tmp, GFP_KERNEL);
+		if (!ioc) {
+			retval = -ENOMEM;
+			break;
+		}
+		if (__copy_from_user(ioc, (void __user *)arg, tmp)) {
+			kfree(ioc);
+			retval = -EFAULT;
+			break;
+		}
+
+		/* translate to spi_message, execute */
+		retval = spidev_message(spidev, ioc, n_ioc);
+		kfree(ioc);
+		break;
+	}
+	return retval;
+}
+
+static int spidev_open(struct inode *inode, struct file *filp)
+{
+	struct spidev_data	*spidev;
+	int			status = -ENXIO;
+
+	mutex_lock(&device_list_lock);
+
+	list_for_each_entry(spidev, &device_list, device_entry) {
+		if (spidev->devt == inode->i_rdev) {
+			status = 0;
+			break;
+		}
+	}
+	if (status == 0) {
+		if (!spidev->buffer) {
+			spidev->buffer = kmalloc(bufsiz, GFP_KERNEL);
+			if (!spidev->buffer) {
+				dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
+				status = -ENOMEM;
+			}
+		}
+		if (status == 0) {
+			spidev->users++;
+			filp->private_data = spidev;
+			nonseekable_open(inode, filp);
+		}
+	} else
+		pr_debug("spidev: nothing for minor %d\n", iminor(inode));
+
+	mutex_unlock(&device_list_lock);
+	return status;
+}
+
+static int spidev_release(struct inode *inode, struct file *filp)
+{
+	struct spidev_data	*spidev;
+	int			status = 0;
+
+	mutex_lock(&device_list_lock);
+	spidev = filp->private_data;
+	filp->private_data = NULL;
+	spidev->users--;
+	if (!spidev->users) {
+		kfree(spidev->buffer);
+		spidev->buffer = NULL;
+	}
+	mutex_unlock(&device_list_lock);
+
+	return status;
+}
+
+static struct file_operations spidev_fops = {
+	.owner =	THIS_MODULE,
+	/* REVISIT switch to aio primitives, so that userspace
+	 * gets more complete API coverage.  It'll simplify things
+	 * too, except for the locking.
+	 */
+	.write =	spidev_write,
+	.read =		spidev_read,
+	.ioctl =	spidev_ioctl,
+	.open =		spidev_open,
+	.release =	spidev_release,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* The main reason to have this class is to make mdev/udev create the
+ * /dev/spidevB.C character device nodes exposing our userspace API.
+ * It also simplifies memory management.
+ */
+static struct class *spidev_class;
+
+/*-------------------------------------------------------------------------*/
+
+static int spidev_probe(struct spi_device *spi)
+{
+	struct spidev_data	*spidev;
+	int			status;
+	unsigned long		minor;
+
+	/* Allocate driver data */
+	spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);
+	if (!spidev)
+		return -ENOMEM;
+
+	/* Initialize the driver data */
+	spidev->spi = spi;
+	mutex_init(&spidev->buf_lock);
+
+	INIT_LIST_HEAD(&spidev->device_entry);
+
+	/* If we can allocate a minor number, hook up this device.
+	 * Reusing minors is fine so long as udev or mdev is working.
+	 */
+	mutex_lock(&device_list_lock);
+	minor = find_first_zero_bit(minors, N_SPI_MINORS);
+	if (minor < N_SPI_MINORS) {
+		spidev->dev.parent = &spi->dev;
+		spidev->devt = MKDEV(SPIDEV_MAJOR, minor);
+		snprintf(spidev->dev.bus_id, sizeof spidev->dev.bus_id,
+			 "spidev%d.%d",
+			 spi->master->bus_num, spi->chip_select);
+		status = device_register(&spidev->dev);
+		spidev->class_dev = class_device_create(spidev_class, NULL, spidev->devt,
+							&spidev->dev, "spidev%d.%d",
+							spi->master->bus_num, spi->chip_select);
+	} else {
+		dev_dbg(&spi->dev, "no minor number available!\n");
+		status = -ENODEV;
+	}
+	if (status == 0) {
+		printk(KERN_INFO "Registering SPIDEV device (%s)\n", spidev->dev.bus_id);
+		set_bit(minor, minors);
+		dev_set_drvdata(&spi->dev, spidev);
+		list_add(&spidev->device_entry, &device_list);
+	}
+	mutex_unlock(&device_list_lock);
+
+	if (status != 0)
+		kfree(spidev);
+
+	return status;
+}
+
+static int spidev_remove(struct spi_device *spi)
+{
+	struct spidev_data	*spidev = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&device_list_lock);
+
+	list_del(&spidev->device_entry);
+	dev_set_drvdata(&spi->dev, NULL);
+	clear_bit(MINOR(spidev->devt), minors);
+	class_device_destroy(spidev_class, spidev->devt);
+	device_unregister(&spidev->dev);
+
+	mutex_unlock(&device_list_lock);
+
+	return 0;
+}
+
+static struct spi_driver spidev_spi = {
+	.driver = {
+		.name =		"spidev",
+		.owner =	THIS_MODULE,
+	},
+	.probe =	spidev_probe,
+	.remove =	__devexit_p(spidev_remove),
+
+	/* NOTE:  suspend/resume methods are not necessary here.
+	 * We don't do anything except pass the requests to/from
+	 * the underlying controller.  The refrigerator handles
+	 * most issues; the controller driver handles the rest.
+	 */
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+static int __init spidev_init(void)
+{
+	int status;
+
+	printk("%s\n", __FUNCTION__);
+
+	/* Claim our 256 reserved device numbers.  Then register a class
+	 * that will key udev/mdev to add/remove /dev nodes.  Last, register
+	 * the driver which manages those device numbers.
+	 */
+	BUILD_BUG_ON(N_SPI_MINORS > 256);
+	status = register_chrdev(SPIDEV_MAJOR, "spi", &spidev_fops);
+	if (status < 0)
+		return status;
+
+	spidev_class = class_create(THIS_MODULE, "spidev");
+	if (IS_ERR(spidev_class))
+		return 0;
+
+	status = spi_register_driver(&spidev_spi);
+	if (status < 0) {
+		class_destroy(spidev_class);
+		unregister_chrdev(SPIDEV_MAJOR, spidev_spi.driver.name);
+	}
+	return status;
+}
+module_init(spidev_init);
+
+static void __exit spidev_exit(void)
+{
+	spi_unregister_driver(&spidev_spi);
+	class_destroy(spidev_class);
+	unregister_chrdev(SPIDEV_MAJOR, spidev_spi.driver.name);
+}
+module_exit(spidev_exit);
+
+MODULE_AUTHOR("Andrea Paterniani, <a.paterniani@swapp-eng.it>");
+MODULE_DESCRIPTION("User mode SPI device interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6.17/drivers/stm/Kconfig
===================================================================
--- linux-2.6.17.orig/drivers/stm/Kconfig	2008-01-30 17:01:40.000000000 +0000
+++ linux-2.6.17/drivers/stm/Kconfig	2008-03-05 10:58:50.000000000 +0000
@@ -55,8 +55,7 @@
        bool "STM Synchronous Serial Controller"
        default y
        ---help---
-         This driver is required to support the I2C and the SPI
-         Protocol on STM SOCs
+         This driver is required to support the SSC-based I2C Protocol on STM SOCs
 
 config  STM_SSC_DEBUG
 	bool "STM SSC Debug"
@@ -65,32 +64,6 @@
 	---help---
 	  Enable this option to print out information on STM SSC device driver
 
-config STM_SPI
-	bool "STM Serial Peripheral Interface"
-	select STM_SSC
-	---help---
-	  This driver is required to support the SPI Protocol
-
-config  STM_SPI_DEBUG
-        bool "STM SPI Debug"
-        depends on STM_SPI
-        default n
-        ---help---
-        Enable this option to print out information on STM SPI device driver
-
-config STM_SPI_CHAR_DEV
-	bool "STM SPI: add char device interface"
-	depends on STM_SPI
-	---help---
-	Enable this option to add the device file interface
-
-config STM_SPI_HW_FIFO
-	bool "STM SPI: hardware Fifo support"
-	depends on STM_SPI
-	---help---
-	Enable this option to add the ssc-hardware fifo support
-
-
 choice
 	prompt "STMicroelectronics coprocessor support"
         depends on CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STB7100
Index: linux-2.6.17/drivers/stm/Makefile
===================================================================
--- linux-2.6.17.orig/drivers/stm/Makefile	2008-01-30 17:01:42.000000000 +0000
+++ linux-2.6.17/drivers/stm/Makefile	2008-03-05 10:58:50.000000000 +0000
@@ -3,9 +3,8 @@
 #
 
 obj-$(CONFIG_STB7100_FDMA)	+= 710x_fdma2.o
-obj-$(CONFIG_STM_SSC)           += stm_ssc.o
-obj-$(CONFIG_STM_SPI)           += stm_spi.o
 obj-$(CONFIG_STM_COPROCESSOR)   += stm-coprocessor.o
+obj-$(CONFIG_STM_SSC)           += stm_ssc.o
 obj-$(CONFIG_STM_COPROCESSOR_FRMW)   += stm-coprocessor_frmw.o
 ifneq ($(CONFIG_STM_COPROCESSOR)$(CONFIG_STM_COPROCESSOR_FRMW),nn)
 obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= copro-stb7100.o
Index: linux-2.6.17/drivers/stm/stm_spi.c
===================================================================
--- linux-2.6.17.orig/drivers/stm/stm_spi.c	2008-01-30 17:01:39.000000000 +0000
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,937 +0,0 @@
-/*
-   -------------------------------------------------------------------------
-   stm_spi.c
-   -------------------------------------------------------------------------
-   STMicroelectronics
-   Version: 2.0 (1 April 2007)
-   ----------------------------------------------------------------------------
-   May be copied or modified under the terms of the GNU General Public
-   License.  See linux/COPYING for more information.
-
-   ------------------------------------------------------------------------- */
-
-#include "stm_spi.h"
-#include <linux/stpio.h>
-#include <asm/semaphore.h>
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <asm/uaccess.h>
-#include <asm/param.h>		/* for HZ */
-
-#undef dgb_print
-
-#ifdef  CONFIG_STM_SPI_DEBUG
-#define SPI_LOOP_DEBUG
-#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
-#else
-#define dgb_print(fmt, args...)
-#endif
-
-#define NANOSEC_PER_SEC         1000000000
-
-#define SPI_LINE_SHIFT      0x0
-#define SPI_BANK_SHIFT      0x3
-#define SPI_MODE_SHIFT      0x7
-
-#define SPI_LINE_MASK       0x7
-#define SPI_BANK_MASK       0xf
-#define SPI_MODE_MASK       0x1
-#define SPI_DEVICE_MASK     0xff
-
-#define spi_get_mode(address)       ( (address >> SPI_MODE_SHIFT) & SPI_MODE_MASK )
-#define spi_get_bank(address)       ( (address >> SPI_BANK_SHIFT) & SPI_BANK_MASK )
-#define spi_get_line(address)       ( (address >> SPI_LINE_SHIFT) & SPI_LINE_MASK )
-#define spi_get_device(address)     (  address & SPI_DEVICE_MASK )
-
-enum spi_state_machine_e {
-	SPI_FSM_VOID = 0,
-	SPI_FSM_PREPARE,
-	SPI_FSM_RUNNING,
-	SPI_FSM_STOP,
-	SPI_FSM_COMPLETE,
-	SPI_FSM_ABORT
-};
-
-#define SPI_PHASE_MASK            0x01
-#define SPI_PHASE_HIGH            0x01
-#define SPI_PHASE_LOW             0x00
-
-#define SPI_POLARITY_MASK         0x02
-#define SPI_POLARITY_HIGH         0x02
-#define SPI_POLARITY_LOW          0x00
-
-#define SPI_MSB_MASK              0x04
-#define SPI_MSB                   0x04
-#define SPI_LSB                   0x00
-
-#define SPI_FULLDUPLEX_MASK       0x08
-#define SPI_FULLDUPLEX            0x08
-#define SPI_HALFDUPLEX            0x00
-
-#define SPI_WIDE_MASK             0x10
-#define SPI_WIDE_16BITS           0x10
-#define SPI_WIDE_8BITS            0x00
-
-#define SPI_CSACTIVE_MASK         0x20
-#define SPI_CSACTIVE_HIGH         0x20
-#define SPI_CSACTIVE_LOW          0x00
-
-#define SPI_BAUDRATE_MASK         0xffff0000
-#define SPI_BAUDRATE_SHIFT        0x10
-
-/*
- *  * Virtual Configuration *
- *
- *  [  0: POLARITY  :0]
- *  [  1: PHASE     :1]
- *  [  2: MSB       :2]
- *  [  3: FULL/HALF :3]
- *  [  4: WIDE      :4]
- *  [  5: CS_ACTIVE :5]
- *  [ 15: FREE      :6]
- *  [ 31: BAUDRATE  :16]
- *
- */
-
-struct spi_transaction_t {
-	struct spi_client_t *client;	/* the transaction's owner */
-	enum spi_state_machine_e state;
-	enum spi_state_machine_e next_state;
-	unsigned int msg_length;
-	unsigned int idx_write;
-	unsigned int idx_read;
-};
-
-/*
- *  In this way i can manage no more than 5 bus spi
- *  but 5 it's enough for our platform
- */
-#define MAX_NUMBER_SPI_BUSSES 5
-/*
- *  This array is used to speed up the
- *  open device file
- */
-struct spi_device_t *spi_busses_array[MAX_NUMBER_SPI_BUSSES];
-//static LIST_HEAD(spi_busses);
-/*
- * In this way the spi bus will be available
- * with the spi_busses_array array
- * or the spi_busses list
- */
-
-#define jump_on_fsm_complete(trsc)	{ (trsc)->state = SPI_FSM_COMPLETE;	\
-					 goto be_fsm_complete;}
-
-#define jump_on_fsm_abort(trsc)		{ (trsc)->state = SPI_FSM_ABORT;	\
-					 goto be_fsm_abort;}
-
-void spi_state_machine(struct spi_transaction_t *transaction)
-{
-	struct spi_client_t *client = transaction->client;
-	struct ssc_t *ssc_bus = container_of(client->dev->dev.parent, struct ssc_t,dev);
-	unsigned short status;
-	short tx_fifo_status;
-	short rx_fifo_status;
-	unsigned int config = client->config;
-	unsigned int phase, polarity;
-	unsigned int hb;
-	unsigned int wide_frame = (config & SPI_WIDE_MASK) ? 1 : 0;
-
-	union {
-		char bytes[2];
-		short word;
-	} tmp = {.word = 0,};
-
-	transaction->state = transaction->next_state;
-
-	switch (transaction->state) {
-	case SPI_FSM_PREPARE:
-		dgb_print("-SPI_FSM_PREPARE\n");
-		phase    = ((config & SPI_PHASE_MASK) ? 1 : 0);
-		polarity = ((config & SPI_POLARITY_MASK) ? 1 : 0);
-		hb       = ((config & SPI_MSB_MASK) ? 1 : 0);
-		wide_frame = ((config & SPI_WIDE_MASK) ? 1 : 0) * 0x8 + 0x7;
-
-		stpio_set_pin(ssc_bus->pio_clk, STPIO_OUT);
-		stpio_set_pin(ssc_bus->pio_data, STPIO_OUT);
-		stpio_set_pin(ssc_bus->pio_data, STPIO_IN);
-
-		ssc_store16(ssc_bus, SSC_BRG,
-			    (config & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
-
-		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR | 0x1);
-		ssc_store16(ssc_bus, SSC_I2C, 0x0);
-		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
-			    (SSC_CTL_PO * polarity) |
-			    (SSC_CTL_PH * phase) | (SSC_CTL_HB * hb) |
-#ifdef SPI_LOOP_DEBUG
-			    SSC_CTL_LPB |
-#endif
-#ifdef CONFIG_STM_SPI_HW_FIFO
-			    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO |
-#endif
-			    wide_frame);
-
-		transaction->next_state = SPI_FSM_RUNNING;
-		ssc_load16(ssc_bus, SSC_RBUF);	/* only to clear the status register */
-#ifdef CONFIG_STM_SPI_HW_FIFO
-		for (tx_fifo_status = 0;
-		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
-		     transaction->idx_write < transaction->msg_length;
-		     ++tx_fifo_status)
-#endif
-		{
-			if (wide_frame > 0x7) {
-				dgb_print(" Writing %c %c\n",
-					  client->wr_buf[transaction->
-							 idx_write * 2],
-					  client->wr_buf[transaction->
-							 idx_write * 2 + 1]);
-				tmp.bytes[1] =
-				    client->wr_buf[transaction->idx_write * 2];
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write * 2 +
-						   1];
-			} else {
-				dgb_print(" Writing %c\n",
-					  client->wr_buf[transaction->
-							 idx_write]);
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write];
-			}
-			++transaction->idx_write;
-			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
-		}
-		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_RIEN);
-		break;
-
-	case SPI_FSM_RUNNING:
-		status = ssc_load16(ssc_bus, SSC_STA);
-		dgb_print(" SPI_FSM_RUNNING 0x%x\n", status);
-#ifndef CONFIG_STM_SPI_HW_FIFO
-		if ((status & SSC_STA_RIR) &&
-		    transaction->idx_read < transaction->msg_length) {
-#else
-		for (rx_fifo_status = ssc_load16(ssc_bus, SSC_RX_FSTAT);
-		     rx_fifo_status &&
-		     transaction->idx_read < transaction->msg_length;
-		     --rx_fifo_status) {
-#endif
-			tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
-			if (wide_frame) {
-				client->rd_buf[transaction->idx_read * 2] =
-				    tmp.bytes[1];
-				client->rd_buf[transaction->idx_read * 2 + 1] =
-				    tmp.bytes[0];
-				dgb_print(" Reading: %c %c\n", tmp.bytes[1],
-					  tmp.bytes[0]);
-			} else {
-				client->rd_buf[transaction->idx_read] =
-				    tmp.bytes[0];
-				dgb_print(" Reading: %c\n", tmp.bytes[0]);
-			}
-			++transaction->idx_read;
-		}
-#ifndef CONFIG_STM_SPI_HW_FIFO
-		if ((status & SSC_STA_TIR)
-		    && transaction->idx_write < transaction->msg_length) {
-#else
-		for (tx_fifo_status = ssc_load16(ssc_bus, SSC_TX_FSTAT);
-		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
-		     transaction->idx_write < transaction->msg_length;
-		     ++tx_fifo_status) {
-#endif
-			if (wide_frame) {
-				dgb_print(" Writing %c %c\n",
-					  client->wr_buf[transaction->
-							 idx_write * 2],
-					  client->wr_buf[transaction->
-							 idx_write * 2 + 1]);
-				tmp.bytes[1] =
-				    client->wr_buf[transaction->idx_write * 2];
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write * 2 +
-						   1];
-			} else {
-				dgb_print(" Writing %c\n",
-					  client->wr_buf[transaction->
-							 idx_write]);
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write];
-			}
-			++transaction->idx_write;
-			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
-		}
-
-		if (transaction->idx_write >= transaction->msg_length &&
-		    transaction->idx_read >= transaction->msg_length)
-			jump_on_fsm_complete(transaction);
-		break;
-	case SPI_FSM_COMPLETE:
-	      be_fsm_complete:
-		dgb_print(" SPI_FSM_COMPLETE\n");
-		ssc_store16(ssc_bus, SSC_IEN, 0x0);
-		wake_up(&(ssc_bus->wait_queue));
-		break;
-
-	case SPI_FSM_VOID:
-	default:
-		;
-	}
-	return;
-}
-
-#define chip_asserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
-			     stpio_set_pin((client)->pio_chip, 0x1);		\
-			else stpio_set_pin((client)->pio_chip, 0x0);
-
-#define chip_deasserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
-			       stpio_set_pin((client)->pio_chip, 0x0);		\
-			  else stpio_set_pin((client)->pio_chip, 0x1);
-
-int spi_write(struct spi_client_t *client, char *wr_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct ssc_t *ssc_bus =
-		container_of(client->dev->dev.parent, struct ssc_t, dev);
-	struct spi_transaction_t transaction = {.client = client,
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	dgb_print("\n");
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
-	chip_asserted(client);
-
-	client->rd_buf = kmalloc(count, GFP_KERNEL);
-	client->wr_buf = wr_buffer;
-	if (client->config & SPI_WIDE_MASK)
-		transaction.msg_length >>= 1;
-
-	spi_state_machine(&transaction);
-	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
-						   (transaction.state == SPI_FSM_COMPLETE),
-						   client->timeout * HZ);
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(&transaction);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI write\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-	ssc_release_bus(ssc_bus);
-	kfree(client->rd_buf);
-	client->rd_buf = NULL;
-	client->wr_buf = NULL;
-	return result;
-}
-
-int spi_read(struct spi_client_t *client, char *rd_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct ssc_t *ssc_bus =
-		container_of(client->dev->dev.parent, struct ssc_t, dev);
-	unsigned int wide_frame =
-	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
-	struct spi_transaction_t transaction = {.client = client,
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	/*
-	 * the first step is request the bus access
-	 */
-	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
-
-	chip_asserted(client);
-
-#ifdef SPI_LOOP_DEBUG
-#define DUMMY   "dummy_string_only_for_test"
-	count = strlen(DUMMY);
-#endif
-
-	client->rd_buf = rd_buffer;
-	client->wr_buf = (char *)kmalloc(count, GFP_KERNEL);
-
-#ifdef SPI_LOOP_DEBUG
-	strcpy(client->wr_buf, DUMMY);
-#endif
-
-/*
- *  When the data frame is 16 bits long
- *  then msg_length must be %2=0
- *
- */
-	if (wide_frame)
-		transaction.msg_length >>= 1;	// frame oriented
-
-	spi_state_machine(&transaction);
-	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
-						   (transaction.state == SPI_FSM_COMPLETE),
-						   client->timeout * HZ);
-
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(&transaction);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in read wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-
-	ssc_release_bus(ssc_bus);
-	kfree(client->wr_buf);
-	client->rd_buf = NULL;
-	client->wr_buf = NULL;
-	return result;
-}
-
-int spi_write_then_read(struct spi_client_t *client, char *wr_buffer,
-			char *rd_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct ssc_t *ssc_bus =
-		container_of(client->dev->dev.parent, struct ssc_t, dev);
-	struct spi_transaction_t transaction = {.client = client,
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	dgb_print("\n");
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	ssc_request_bus(ssc_bus, spi_state_machine, (void *)&transaction);
-
-	chip_asserted(client);
-
-	client->rd_buf = rd_buffer;
-	client->wr_buf = wr_buffer;
-
-	if (client->config & SPI_WIDE_MASK)
-		transaction.msg_length >>= 1;	// frame oriented...
-
-	spi_state_machine(&transaction);
-	timeout = wait_event_interruptible_timeout(ssc_bus->wait_queue,
-						  (transaction.state == SPI_FSM_COMPLETE),
-						  client->timeout * HZ);
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(&transaction);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in read wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-	ssc_release_bus(ssc_bus);
-
-	return count;
-}
-
-struct spi_client_t *spi_create_client(int bus_number)
-{
-	struct spi_client_t *client;
-
-	dgb_print("\n");
-
-	if (bus_number >= MAX_NUMBER_SPI_BUSSES)
-		return NULL;
-	if (!spi_busses_array[bus_number])
-		return NULL;
-	client =
-	    (struct spi_client_t *)kzalloc(sizeof(struct spi_client_t),
-					   GFP_KERNEL);
-	if (!client)
-		return NULL;
-	client->dev = spi_busses_array[bus_number];
-	client->timeout = 5;	/* 5 seconds */
-/*
- *  1 Phase
- *  1 Polarity
- *  1 Heading
- *  - Full/Half
- *  1 Wide (16bits)
- *  0 CSActive
- *  1 MHz (at 100MHz of common clock)
- */
-	client->config = 0x420017;
-
-	return client;
-}
-
-int spi_client_release(struct spi_client_t *client)
-{
-	dgb_print("\n");
-	if (!client)
-		return 0;
-	if (client->pio_chip != NULL) {
-		stpio_free_pin(client->pio_chip);
-		client->pio_chip = NULL;
-	}
-	dgb_print("PIO-chip released\n");
-	if (client->rd_buf != NULL)
-		kfree(client->rd_buf);
-	kfree(client);
-	return 1;
-}
-
-int spi_client_addressing(struct spi_client_t *client, unsigned int slave_address)
-{
-	unsigned int spi_device;
-
-	spi_device = spi_get_device(slave_address);
-
-	dgb_print("Spi opening Slave 0x%x (%d)\n", spi_device, spi_device);
-
-/* 1. release the Pio of previous addressing*/
-	if (client->pio_chip)
-		stpio_free_pin(client->pio_chip);
-	client->pio_chip = NULL;
-// 2. check if the pio[BANK][LINE] used for chip_selector is free
-	client->pio_chip =
-	    stpio_request_pin(spi_get_bank(slave_address),
-			      spi_get_line(slave_address), "spi-chip-selector",
-			      STPIO_OUT);
-
-	if (!(client->pio_chip)) {
-/*
- * Somebody already requested the PIO[bank][line]
- * therefore we abort the addressing
- */
-		dgb_print("Error Pio locked or not-exist\n");
-		return -ENOSYS;
-	}
-	dgb_print("->with PIO [%d][%d]\n", spi_get_bank(slave_address),
-		  spi_get_line(slave_address));
-
-	client->config &= ~SPI_FULLDUPLEX;
-	dgb_print("->with FULLDUPLEX = 0x%x\n", spi_get_mode(slave_address));
-	client->config |= ( SPI_FULLDUPLEX * spi_get_mode(slave_address));
-/*
- *  Free the data of prev addressing
- */
-	if (client->rd_buf != NULL)
-		kfree(client->rd_buf);
-
-	client->rd_buf = NULL;
-	chip_deasserted(client);
-
-	return 0;
-
-}
-
-int spi_client_control(struct spi_client_t *client, int cmd, int arg)
-{
-	dgb_print("\n");
-	switch (cmd) {
-	case SPI_IOCTL_WIDEFRAME:
-		client->config &= ~SPI_WIDE_MASK;
-		if (arg)
-			client->config |= SPI_WIDE_16BITS;
-		break;
-	case SPI_IOCTL_POLARITY:
-		client->config &=  ~SPI_POLARITY_MASK;
-		if (arg)
-			client->config |= SPI_POLARITY_HIGH;
-		break;
-	case SPI_IOCTL_PHASE:
-		client->config &= ~SPI_PHASE_MASK;
-		if (arg)
-			client->config |= SPI_PHASE_HIGH;
-		break;
-	case SPI_IOCTL_HEADING:
-		client->config &= ~SPI_MSB_MASK;
-		if (arg)
-			client->config |= SPI_MSB;
-		break;
-	case SPI_IOCTL_BUADRATE:
-		{
-			unsigned long baudrate;
-			baudrate = ssc_get_clock() / (2 * arg);
-			client->config &= ~SPI_BAUDRATE_MASK;
-			client->config |= (baudrate << SPI_BAUDRATE_SHIFT);
-		}
-		break;
-	case SPI_IOCTL_CSACTIVE:
-		client->config &= ~SPI_CSACTIVE_MASK;
-		if (arg)
-			client->config |= SPI_CSACTIVE_HIGH;
-		break;
-	case SPI_IOCTL_ADDRESS:
-		if (spi_client_addressing(client, (unsigned int)arg) != 0)
-			return -1;
-		break;
-	case SPI_IOCTL_TIMEOUT:
-		client->timeout = arg;
-		break;
-	default:
-		;
-	}
-#ifdef SPI_STM_DEBUG
-	{
-		unsigned int conf = client->config;
-		dgb_print("SPI - Virtual Config:\n");
-		dgb_print(" - PHASE:    0x%x\n", (conf & SPI_PHASE_MASK) != 0);
-		dgb_print(" - POLARITY: 0x%x\n",
-			  (conf & SPI_POLARITY_MASK) != 0);
-		dgb_print(" - HEADING:  0x%x\n", (conf & SPI_MSB_MASK) != 0);
-		dgb_print(" - FULLDUP:  0x%x\n",
-			  (conf & SPI_FULLDUPLEX_MASK) != 0);
-		dgb_print(" - WIDE:     0x%x\n", (conf & SPI_WIDE_MASK) != 0);
-		dgb_print(" - CSACTIVE: 0x%x\n",
-			  (conf & SPI_CSACTIVE_MASK) != 0);
-		dgb_print(" - BUADRATE: 0x%x\n",
-			  (conf & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
-	}
-#endif
-
-}
-
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-#define SPI_MAJOR 153
-static struct class *spi_dev_class;
-static struct cdev spi_cdev;
-
-static ssize_t spi_cdev_read(struct file *filp,
-			     char __user * buff, size_t count, loff_t * offp)
-{
-	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
-	unsigned int wide_frame =
-	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
-	char *read_buffer;
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	if (client->config & SPI_FULLDUPLEX_MASK) {
-/*
- * In FullDuplex Mode
- * The Datas are already ready...
- */
-		if (!client->rd_buf)
-			return 0;
-		dgb_print("Reading in FullD\n");
-		if (wide_frame)
-			count &= ~0x1;
-		copy_to_user(buff, client->rd_buf, count);
-		kfree(client->rd_buf);
-		client->rd_buf = NULL;
-		return count;
-	}
-
-	dgb_print("Reading in Half/D %d bytes\n", count);
-	read_buffer = (char *)kmalloc(count, GFP_KERNEL);
-	spi_read(client, read_buffer, count);
-	copy_to_user(buff, read_buffer, count);
-	kfree(read_buffer);
-	return count;
-}
-
-static ssize_t spi_cdev_write(struct file *filp,
-			      const char __user * buff,
-			      size_t count, loff_t * offp)
-{
-	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
-	char *wr_buffer;
-	char *rd_buffer;
-	int result;
-	dgb_print("\n");
-
-	wr_buffer = kmalloc(count, GFP_KERNEL);
-	rd_buffer = kmalloc(count, GFP_KERNEL);
-
-	copy_from_user(wr_buffer, buff, count);
-
-	result = spi_write_then_read(client, wr_buffer, rd_buffer, count);
-
-	if (result >= 0)
-		result = count;
-
-	if (!(client->config & SPI_FULLDUPLEX)) {
-#ifdef SPI_LOOP_DEBUG
-		dgb_print("Read: %s\n", rd_buffer);
-#endif
-		kfree(rd_buffer);
-		client->rd_buf = NULL;
-	}
-
-	return result;
-}
-
-static int spi_cdev_ioctl(struct inode *inode,
-			  struct file *filp, unsigned int cmd,
-			  unsigned long arg)
-{
-	dgb_print("\n");
-	spi_client_control((struct spi_client_t *)filp->private_data, cmd, arg);
-	return 0;
-}
-
-static int spi_cdev_open(struct inode *inode, struct file *filp)
-{
-	unsigned int minor;
-	struct spi_client_t *client;
-
-	dgb_print("\n");
-	minor = iminor(inode);
-	client = spi_create_client(minor);
-	filp->private_data = client;
-	if (client)
-		return 0;
-	else
-		return -ENODEV;
-}
-
-static int spi_cdev_release(struct inode *inode, struct file *filp)
-{
-	dgb_print("\n");
-	spi_client_release((struct spi_client_t *)filp->private_data);
-	filp->private_data = NULL;
-	return 0;
-}
-
-struct file_operations spi_fops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.open = spi_cdev_open,
-	.release = spi_cdev_release,
-	.read = spi_cdev_read,
-	.write = spi_cdev_write,
-	.ioctl = spi_cdev_ioctl
-};
-#endif
-
-static int spi_stm_match(struct device *dev, struct device_driver *drv)
-{
-	dgb_print("\n");
-	if (dev == NULL || drv == NULL)
-		return 0;
-	return !strncmp(dev->bus_id, drv->name, 3);
-}
-
-struct bus_type spi_bus_type = {
-	.name = "spi",
-	.match = spi_stm_match,
-};
-
-void spi_del_adapter(struct spi_device_t *spi_dev)
-{
-	dgb_print("\n");
-	spi_busses_array[spi_dev->idx_dev] = 0;
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	class_device_destroy(spi_dev_class, MKDEV(SPI_MAJOR, spi_dev->idx_dev));
-#endif
-	kfree(spi_dev);
-	return;
-}
-
-static int spi_bus_driver_probe(struct device *dev)
-{
-	struct spi_device_t *spi_dev;
-
-	dgb_print("\n");
-	spi_dev = container_of(dev, struct spi_device_t, dev);
-
-	return spi_dev->dev_type == SPI_DEV_BUS_ADAPTER;
-};
-
-static void spi_bus_driver_remove(struct device *dev)
-{
-	struct spi_device_t *spi_dev;
-	spi_dev = container_of(dev, struct spi_device_t, dev);
-	dgb_print("\n");
-//   spi_del_adapter(spi_dev);
-//   dgb_print("..\n");
-	return;
-}
-static void spi_bus_driver_shutdown(struct device *dev)
-{
-	struct spi_device_t *spi_dev;
-	spi_dev = container_of(dev, struct spi_device_t, dev);
-	dgb_print("\n");
-	spi_del_adapter(spi_dev);
-	return;
-}
-static struct device_driver spi_bus_drv = {
-	.owner = THIS_MODULE,
-	.name = "spi_bus_drv",
-	.bus = &spi_bus_type,
-	.probe = spi_bus_driver_probe,
-	.shutdown = spi_bus_driver_shutdown,
-	.remove = spi_bus_driver_remove,
-};
-
-int spi_add_adapter(struct spi_device_t *spi_dev)
-{
-	unsigned int ret;
-	unsigned int idx_dev = spi_dev->idx_dev;
-	struct device *dev;
-
-	dgb_print("\n");
-	spi_dev->dev_type = SPI_DEV_BUS_ADAPTER;
-	spi_dev->dev.bus = &(spi_bus_type);
-	sprintf(spi_dev->dev.bus_id, "spi-%d", idx_dev);
-	spi_dev->dev.release = spi_del_adapter;
-	spi_dev->dev.driver = &spi_bus_drv;
-	ret = device_register(&spi_dev->dev);
-	if (ret) {
-		printk(KERN_WARNING "Unable to register %s bus\n",
-		       spi_dev->dev.bus_id);
-		kfree(spi_dev);
-	} else
-		spi_busses_array[idx_dev] = spi_dev;
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	dev = spi_dev->dev.parent;
-	spi_dev->class_dev = class_device_create(spi_dev_class, NULL,
-						 MKDEV(SPI_MAJOR,
-						 spi_dev->idx_dev), dev,
-						 "spi-%d", spi_dev->idx_dev);
-#endif
-	return ret;
-}
-
-static int spi_adapter_detect()
-{
-	unsigned int idx;
-	unsigned int num_ssc_bus = ssc_device_available();
-	unsigned int num_spi_bus;
-	struct spi_device_t *spi_dev;
-	struct ssc_t **ssc_busses;
-	dgb_print("\n");
-/*
- *  Check the ssc on the platform
- */
-	ssc_busses = (struct ssc_t **)kmalloc(num_ssc_bus *
-					      sizeof(struct ssc_t *),
-					      GFP_KERNEL);
-	for (idx = 0, num_spi_bus = 0; idx < num_ssc_bus; ++idx)
-		if ((ssc_capability(idx) & SSC_SPI_CAPABILITY))
-			ssc_busses[num_spi_bus++] = ssc_device_request(idx);
-
-	for (idx = 0; idx < num_spi_bus; ++idx) {
-		spi_dev = (struct spi_device_t *)
-		    kmalloc(sizeof(struct spi_device_t), GFP_KERNEL);
-		memset(&spi_dev->dev, 0, sizeof(struct device));
-		spi_dev->dev.parent = &(ssc_busses[idx]->dev);
-		spi_dev->idx_dev = idx;
-		spi_add_adapter(spi_dev);
-	};
-	kfree(ssc_busses);
-	return 0;
-}
-
-static void __init spi_core_init(void)
-{
-	unsigned int ret;
-	dgb_print("\n");
-	ret = bus_register(&spi_bus_type);
-	if (ret) {
-		printk(KERN_WARNING "Unable to register spi bus\n");
-		return ;
-	}
-	ret = driver_register(&spi_bus_drv);
-	if (ret) {
-		printk(KERN_WARNING "Unable to register spi driver\n");
-		return ;
-        }
-        printk(KERN_INFO "spi layer initialized\n");
-}
-
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-static void __init spi_cdev_init(void)
-{
-	dev_t ch_device;
-	dgb_print("\n");
-
-	spi_dev_class = class_create(THIS_MODULE, "spi-dev");
-	if (IS_ERR(spi_dev_class))
-		return 0;
-
-	ch_device = MKDEV(SPI_MAJOR, 0);
-	register_chrdev_region(ch_device, 255, "spi");
-	cdev_init(&(spi_cdev), &(spi_fops));
-	cdev_add(&(spi_cdev), ch_device, 255);
-	printk(KERN_INFO "spi /dev layer initialized\n");
-	return 0;
-}
-device_initcall(spi_cdev_init);
-#endif
-
-static int __init spi_late_init(void)
-{
-	dgb_print("\n");
-	spi_adapter_detect();
-	return 0;
-}
-
-static int __exit spi_exit(void)
-{
-	dev_t ch_device;
-
-	dgb_print("\n");
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	ch_device = MKDEV(SPI_MAJOR, 0);
-	cdev_del(&(spi_cdev));
-	unregister_chrdev_region(ch_device, 255);
-#endif
-
-	driver_unregister(&spi_bus_drv);
-	bus_unregister(&spi_bus_type);
-	return 0;
-}
-
-subsys_initcall(spi_core_init);
-late_initcall(spi_late_init);
-module_exit(spi_exit);
-
-MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
-MODULE_DESCRIPTION("Module for stm spi device");
-MODULE_LICENSE("GPL");
Index: linux-2.6.17/drivers/stm/stm_ssc.c
===================================================================
--- linux-2.6.17.orig/drivers/stm/stm_ssc.c	2008-01-30 17:01:39.000000000 +0000
+++ linux-2.6.17/drivers/stm/stm_ssc.c	2008-03-05 10:58:50.000000000 +0000
@@ -1,26 +1,32 @@
 /*
-   -------------------------------------------------------------------------
-   stm_ssc.c
-   -------------------------------------------------------------------------
-   STMicroelectronics
-   -------------------------------------------------------------------------
- *  Copyright (C) 2006  Virlinzi Francesco
- *                   <francesco.virlinzi@st.com>
- *
- * 23 August 2006 - Modified to support the 2.6.17 kernel version
- *      Virlinzi Francesco <francesco.virlinzi@st.com>
+ * -------------------------------------------------------------------------
+ * stm_ssc.c
+ * -------------------------------------------------------------------------
+ * STMicroelectronics
+ * -------------------------------------------------------------------------
+ * Copyright (C) 2006  Virlinzi Francesco
+ *                  <francesco.virlinzi@st.com>
  *
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
+ * Changelog:
+ * 2008-02-05 Angus Clark <Angus.Clark@st.com>
+ *   - Init skips configuration for busses without capabilities
+ *   - Different IO pin configuration for SPI capable busses
+ *
+ * 23 August 2006 Virlinzi Francesco <francesco.virlinzi@st.com>
+ *   - Modified to support the 2.6.17 kernel version
+ *
+ *
  * ------------------------------------------------------------------------- */
 
-#include "stm_ssc.h"
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <asm/semaphore.h>
 #include <asm/clock.h>
 #include <linux/st_soc.h>
+#include <linux/stm/stm_ssc.h>
 #include <linux/wait.h>
 #include <linux/module.h>
 #include <linux/ioport.h>
@@ -52,12 +58,12 @@
  */
 static struct ssc_t ssc_device[NR_SSC_BUSSES];
 
-static struct platform_device *ssc_device_data;
+static struct platform_device *ssc_device_data = NULL;
 
 unsigned int ssc_device_available()
 {
 	dgb_print("\n");
-	return ssc_device_data->num_resources / 2;
+	return ssc_device_data ? ssc_device_data->num_resources / 2 : 0;
 }
 
 unsigned int ssc_get_clock()
@@ -107,7 +113,7 @@
 
 static irqreturn_t ssc_handler(int this_irq, void *dev_id, struct pt_regs *regs)
 {
-	struct ssc_t *ssc_bus = (struct ssc *)dev_id;
+	struct ssc_t *ssc_bus = (struct ssc_t *)dev_id;
 	if (ssc_bus->irq_function != NULL)
 		ssc_bus->irq_function(ssc_bus->irq_private_data);
 	return IRQ_HANDLED;
@@ -115,7 +121,7 @@
 
 static int __init stm_ssc_probe(struct device *dev)
 {
-   dgb_print("\n");
+	dgb_print("\n");
 	ssc_device_data = to_platform_device(dev);
 
 	if (!ssc_device_data->name ){
@@ -127,8 +133,8 @@
 
 static int stm_ssc_remove(struct device *dev)
 {
-    dgb_print("\n");
-    return 0;
+	dgb_print("\n");
+	return 0;
 }
 
 static void stm_ssc_shutdown(struct device *dev)
@@ -139,11 +145,11 @@
 
 static struct device_driver ssc_driver = {
 	.name = "ssc",
-   .owner = THIS_MODULE,
+	.owner = THIS_MODULE,
 	.bus = &platform_bus_type,
 	.probe = stm_ssc_probe,
-   .shutdown = stm_ssc_shutdown,
-   .remove = stm_ssc_remove,
+	.shutdown = stm_ssc_shutdown,
+	.remove = stm_ssc_remove,
 };
 
 /*
@@ -163,8 +169,18 @@
 	dgb_print("\n");
 
 	info = (struct plat_ssc_data *)
-	    (ssc_device_data->dev.platform_data);
+		(ssc_device_data->dev.platform_data);
 	pio_info = info->pio;
+
+	/* 0. skip if not SSC_I2C_CAPABILITY or SSC_SPI_CAPABILITY */
+	if (ssc_capability(ssc_data->ssc_id) != SSC_I2C_CAPABILITY &&
+	    ssc_capability(ssc_data->ssc_id) != SSC_SPI_CAPABILITY) {
+		printk(KERN_INFO
+		       "st_ssc: bus%d - skipping configuration, "
+		       "no capability defined\n", ssc_data->ssc_id);
+		return -ENODEV;
+	}
+
 /*1.    IO Mem*/
 	res =
 	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
@@ -190,8 +206,10 @@
 	pio_bank = pio_info[ssc_data->ssc_id].sclbank;
 	pio_line = pio_info[ssc_data->ssc_id].sclpin;
 
-	ssc_data->pio_clk = stpio_request_pin(pio_bank, pio_line,
-					      "ssc clock", STPIO_ALT_BIDIR);
+	ssc_data->pio_clk =
+		stpio_request_pin(pio_bank, pio_line, "ssc clock",
+				  ssc_capability(ssc_data->ssc_id) == SSC_I2C_CAPABILITY ?
+				  STPIO_ALT_BIDIR : STPIO_ALT_OUT);
 	if (!ssc_data->pio_clk) {
 		printk(KERN_ERR
 		       "ERROR: ssc bus %d Request PIO clock pins not Done\n",
@@ -204,8 +222,10 @@
 	pio_bank = pio_info[ssc_data->ssc_id].sdoutbank;
 	pio_line = pio_info[ssc_data->ssc_id].sdoutpin;
 
-	ssc_data->pio_data = stpio_request_pin(pio_bank, pio_line,
-					       "ssc data", STPIO_ALT_BIDIR);
+	ssc_data->pio_data =
+		stpio_request_pin(pio_bank, pio_line, "ssc data",
+				  ssc_capability(ssc_data->ssc_id) == SSC_I2C_CAPABILITY ?
+				  STPIO_ALT_BIDIR : STPIO_ALT_OUT);
 	if (!ssc_data->pio_data) {
 		printk(KERN_ERR
 		       "ERROR: ssc bus %d Request PIO Data pins not Done\n",
@@ -223,8 +243,9 @@
 
 	if (pio_bank != 0xff) {
 		ssc_data->pio_data_in =
-		    stpio_request_pin(pio_bank,
-				      pio_line, "ssc data in", STPIO_ALT_BIDIR);
+		    stpio_request_pin(pio_bank, pio_line, "ssc data in",
+				      ssc_capability(ssc_data->ssc_id) == SSC_I2C_CAPABILITY ?
+				      STPIO_ALT_BIDIR : STPIO_IN);
 		if (ssc_data->pio_data_in == NULL) {
 			printk(KERN_ERR
 			       "ERROR: ssc %d Request PIO DataIN pins not Done\n",
@@ -250,7 +271,7 @@
 		goto release_pio_data_in;
 	}
 	dgb_print("ssc bus %d Request IRQ %d Done\n",
-		ssc_data->ssc_id, res->start);
+		  ssc_data->ssc_id, (int)res->start);
         ssc_data->dev.driver = &ssc_driver;
 	ssc_data->dev.parent = &platform_bus ;
         sprintf(ssc_data->dev.bus_id, "ssc-%d", ssc_data->ssc_id);
Index: linux-2.6.17/drivers/stm/stm_ssc.h
===================================================================
--- linux-2.6.17.orig/drivers/stm/stm_ssc.h	2008-03-05 10:35:47.000000000 +0000
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,230 +0,0 @@
-/*
-   --------------------------------------------------------------------
-
-   stm_ssc.h
-   define and struct for STMicroelectronics SSC device
-
-   --------------------------------------------------------------------
-
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
-
-*/
-
-#ifndef STM_SSC_H
-#define STM_SSC_H 1
-
-#include <linux/device.h>
-#include <linux/wait.h>
-#include <linux/stpio.h>
-#include <linux/mutex.h>
-#include <asm/io.h>
-
-
-/* SSC Baud Rate generator */
-#define SSC_BRG                  0x0
-/* SSC Transmitter Buffer  */
-#define SSC_TBUF                 0x4
-/* SSC Receive Buffer      */
-#define SSC_RBUF                 0x8
-/*SSC Control              */
-#define SSC_CTL                  0xC
-#define SSC_CTL_DATA_WIDTH_9     0x8
-#define SSC_CTL_BM               0xf
-#define SSC_CTL_HB               0x10
-#define SSC_CTL_PH               0x20
-#define SSC_CTL_PO		 0x40
-#define SSC_CTL_SR		 0x80
-#define SSC_CTL_MS		 0x100
-#define SSC_CTL_EN		 0x200
-#define SSC_CTL_LPB		 0x400
-#define SSC_CTL_EN_TX_FIFO       0x800
-#define SSC_CTL_EN_RX_FIFO       0x1000
-#define SSC_CTL_EN_CLST_RX       0x2000
-
-/* SSC Interrupt Enable */
-#define SSC_IEN               	0x10
-#define SSC_IEN_RIEN		0x1
-#define SSC_IEN_TIEN		0x2
-#define SSC_IEN_TEEN		0x4
-#define SSC_IEN_REEN		0x8
-#define SSC_IEN_PEEN		0x10
-#define SSC_IEN_AASEN		0x40
-#define SSC_IEN_STOPEN		0x80
-#define SSC_IEN_ARBLEN		0x100
-#define SSC_IEN_NACKEN		0x400
-#define SSC_IEN_REPSTRTEN	0x800
-#define SSC_IEN_TX_FIFO_HALF	0x1000
-#define SSC_IEN_RX_FIFO_HALF_FULL	0x4000
-
-/* SSC Status */
-#define SSC_STA                   0x14
-#define SSC_STA_RIR		  0x1
-#define SSC_STA_TIR		  0x2
-#define SSC_STA_TE		  0x4
-#define SSC_STA_RE		  0x8
-#define SSC_STA_PE		 0x10
-#define SSC_STA_CLST		 0x20
-#define SSC_STA_AAS		 0x40
-#define SSC_STA_STOP		 0x80
-#define SSC_STA_ARBL		0x100
-#define SSC_STA_BUSY		0x200
-#define SSC_STA_NACK		0x400
-#define SSC_STA_REPSTRT		0x800
-#define SSC_STA_TX_FIFO_HALF	0x1000
-#define SSC_STA_TX_FIFO_FULL    0x2000
-#define SSC_STA_RX_FIFO_HALF    0x4000
-
-/*SSC I2C Control */
-#define SSC_I2C               	0x18
-#define SSC_I2C_I2CM		0x1
-#define SSC_I2C_STRTG		0x2
-#define SSC_I2C_STOPG		0x4
-#define SSC_I2C_ACKG		0x8
-#define SSC_I2C_AD10		0x10
-#define SSC_I2C_TXENB		0x20
-#define SSC_I2C_REPSTRTG	0x800
-#define SSC_I2C_I2CFSMODE	0x1000
-/* SSC Slave Address */
-#define SSC_SLAD              	0x1C
-/* SSC I2C bus repeated start hold time */
-#define SSC_REP_START_HOLD    	0x20
-/* SSC I2C bus start hold time */
-#define SSC_START_HOLD        	0x24
-/* SSC I2C bus repeated start setup time */
-#define SSC_REP_START_SETUP   	 0x28
-/* SSC I2C bus repeated stop setup time */
-#define SSC_DATA_SETUP		0x2C
-/* SSC I2C bus stop setup time */
-#define SSC_STOP_SETUP		0x30
-/* SSC I2C bus free time */
-#define SSC_BUS_FREE		0x34
-
-/* SSC Tx FIFO Status */
-#define SSC_TX_FSTAT            0x38
-#define SSC_TX_FSTAT_STATUS     0x07
-
-/* SSC Rx FIFO Status */
-#define SSC_RX_FSTAT            0x3C
-#define SSC_RX_FSTAT_STATUS     0x07
-
-/* SSC Prescaler value value for clock */
-#define SSC_PRE_SCALER_BRG      0x40
-
-/* SSC Clear bit operation */
-#define SSC_CLR			0x80
-#define SSC_CLR_SSCAAS 		0x40
-#define SSC_CLR_SSCSTOP 	0x80
-#define SSC_CLR_SSCARBL 	0x100
-#define SSC_CLR_NACK    	0x400
-#define SSC_CLR_REPSTRT     	0x800
-
-/* SSC Noise suppression Width */
-#define SSC_NOISE_SUPP_WIDTH	0x100
-/* SSC Clock Prescaler */
-#define SSC_PRSCALER		0x104
-#define SSC_PRSC_VALUE          0x0f
-
-/* SSC Noise suppression Width dataout */
-#define SSC_NOISE_SUPP_WIDTH_DATAOUT	0x108
-
-/* SSC Prescaler for delay in dataout */
-#define SSC_PRSCALER_DATAOUT	0x10c
-
-#define SSC_TXFIFO_SIZE         0x8
-#define SSC_RXFIFO_SIZE         0x8
-/*
- * The I2C timing register could be ready
- * for normal or fast rate
- */
-#define SSC_I2C_READY_NORMAL    0x0
-#define SSC_I2C_READY_FAST      0x1
-struct ssc_t {
-	unsigned int ssc_id;
-	struct stpio_pin *pio_clk;
-	struct stpio_pin *pio_data;
-	struct stpio_pin *pio_data_in;
-	wait_queue_head_t wait_queue;
-	struct mutex	  mutex_bus;
-	void *base;
-	void (*irq_function) (void *);
-	void *irq_private_data;
-        unsigned char    i2c_timing;
-        struct device dev;
-};
-
-struct ssc_t *ssc_device_request(unsigned int ssc_id);
-
-/*
- *  How many ssc device are available on this platform
- */
-unsigned int ssc_device_available(void);
-
-/*
- *  The input clock for each SSC device
- */
-
-unsigned int ssc_get_clock(void);
-
-/*
- *  To say if the ssc_is ssc can support I2C and/or SPI protocol
- */
-
-#define SSC_I2C_CAPABILITY  0x1
-#define SSC_SPI_CAPABILITY  0x2
-
-unsigned int ssc_capability(unsigned int ssc_id);
-/*
- *   To request the bus access
- *   The user registers also the function and the data that
- *   they want use in the IRQ_Function
- */
-void ssc_request_bus(struct ssc_t *, void (*irq_function) (void *),
-		     void *irq_data);
-
-/*
- *   To release the bus
- */
-void ssc_release_bus(struct ssc_t *);
-
-/*
-   we have to use the following macro
-   to access the SSC I/O Memory
-*/
-#define ssc_store16(ssc , offset, value) iowrite16(value,ssc->base+offset)
-#define ssc_store8( ssc , offset, value) iowrite8( value,ssc->base+offset)
-
-#define ssc_load16( ssc,offset)          ioread16(ssc->base+offset)
-#define ssc_load8(  ssc,offset)	         ioread8( ssc->base+offset)
-
-/*
- *   This macro could be used to built the capability field
- *   of struct plat_ssc_data for each SoC
- */
-#define ssc_ability(idx_ssc, cap)  \
-         ( cap & (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY ) ) << (idx_ssc*2)
-
-#define ssc0_ability(cap)  ssc_ability(0,cap)
-#define ssc1_ability(cap)  ssc_ability(1,cap)
-#define ssc2_ability(cap)  ssc_ability(2,cap)
-#define ssc3_ability(cap)  ssc_ability(3,cap)
-#define ssc4_ability(cap)  ssc_ability(4,cap)
-
-#endif				/* STM_SSC_H */
Index: linux-2.6.17/include/linux/spi/spi.h
===================================================================
--- linux-2.6.17.orig/include/linux/spi/spi.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/include/linux/spi/spi.h	2008-03-05 10:58:51.000000000 +0000
@@ -32,11 +32,12 @@
  * @max_speed_hz: Maximum clock rate to be used with this chip
  *	(on this board); may be changed by the device's driver.
  *	The spi_transfer.speed_hz can override this for each transfer.
- * @chip-select: Chipselect, distinguishing chips handled by "master".
+ * @chip_select: Chipselect, distinguishing chips handled by @master.
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
- *	The "active low" default for chipselect mode can be overridden,
- *	as can the "MSB first" default for each word in a transfer.
+ *	The "active low" default for chipselect mode can be overridden
+ *	(by specifying SPI_CS_HIGH) as can the "MSB first" default for
+ *	each word in a transfer (by specifying SPI_LSB_FIRST).
  * @bits_per_word: Data transfers involve one or more words; word sizes
  *	like eight or 12 bits are common.  In-memory wordsizes are
  *	powers of two bytes (e.g. 20 bit samples use 32 bits).
@@ -48,14 +49,18 @@
  * @controller_state: Controller's runtime state
  * @controller_data: Board-specific definitions for controller, such as
  *	FIFO initialization parameters; from board_info.controller_data
+ * @modalias: Name of the driver to use with this device, or an alias
+ *	for that name.  This appears in the sysfs "modalias" attribute
+ *	for driver coldplugging, and in uevents used for hotplugging
  *
- * An spi_device is used to interchange data between an SPI slave
+ * A @spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
  *
- * In "dev", the platform_data is used to hold information about this
+ * In @dev, the platform_data is used to hold information about this
  * device that's meaningful to the device's protocol driver, but not
  * to its controller.  One example might be an identifier for a chip
- * variant with slightly different functionality.
+ * variant with slightly different functionality; another might be
+ * information about how this particular board wires the chip's pins.
  */
 struct spi_device {
 	struct device		dev;
@@ -71,19 +76,23 @@
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
+#define	SPI_3WIRE	0x10			/* SI/SO signals shared */
+#define	SPI_LOOP	0x20			/* loopback mode */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;
 	const char		*modalias;
 
-	// likely need more hooks for more protocol options affecting how
-	// the controller talks to each chip, like:
-	//  - memory packing (12 bit samples into low bits, others zeroed)
-	//  - priority
-	//  - drop chipselect after each word
-	//  - chipselect delays
-	//  - ...
+	/*
+	 * likely need more hooks for more protocol options affecting how
+	 * the controller talks to each chip, like:
+	 *  - memory packing (12 bit samples into low bits, others zeroed)
+	 *  - priority
+	 *  - drop chipselect after each word
+	 *  - chipselect delays
+	 *  - ...
+	 */
 };
 
 static inline struct spi_device *to_spi_device(struct device *dev)
@@ -114,11 +123,48 @@
 	spi->controller_state = state;
 }
 
+/* device driver data */
+
+static inline void spi_set_drvdata(struct spi_device *spi, void *data)
+{
+	dev_set_drvdata(&spi->dev, data);
+}
+
+static inline void *spi_get_drvdata(struct spi_device *spi)
+{
+	return dev_get_drvdata(&spi->dev);
+}
 
 struct spi_message;
 
 
 
+/**
+ * struct spi_driver - Host side "protocol" driver
+ * @probe: Binds this driver to the spi device.  Drivers can verify
+ *	that the device is actually present, and may need to configure
+ *	characteristics (such as bits_per_word) which weren't needed for
+ *	the initial configuration done during system setup.
+ * @remove: Unbinds this driver from the spi device
+ * @shutdown: Standard shutdown callback used during system state
+ *	transitions such as powerdown/halt and kexec
+ * @suspend: Standard suspend callback used during system state transitions
+ * @resume: Standard resume callback used during system state transitions
+ * @driver: SPI device drivers should initialize the name and owner
+ *	field of this structure.
+ *
+ * This represents the kind of device driver that uses SPI messages to
+ * interact with the hardware at the other end of a SPI link.  It's called
+ * a "protocol" driver because it works through messages rather than talking
+ * directly to SPI hardware (which is what the underlying SPI controller
+ * driver does to pass those messages).  These protocols are defined in the
+ * specification for the device(s) supported by the driver.
+ *
+ * As a rule, those device protocols represent the lowest level interface
+ * supported by a driver, and it will support upper level interfaces too.
+ * Examples of such upper levels include frameworks like MTD, networking,
+ * MMC, RTC, filesystem character device nodes, and hardware monitoring.
+ */
 struct spi_driver {
 	int			(*probe)(struct spi_device *spi);
 	int			(*remove)(struct spi_device *spi);
@@ -135,15 +181,18 @@
 
 extern int spi_register_driver(struct spi_driver *sdrv);
 
+/**
+ * spi_unregister_driver - reverse effect of spi_register_driver
+ * @sdrv: the driver to unregister
+ * Context: can sleep
+ */
 static inline void spi_unregister_driver(struct spi_driver *sdrv)
 {
-	if (!sdrv)
-		return;
-	driver_unregister(&sdrv->driver);
+	if (sdrv)
+		driver_unregister(&sdrv->driver);
 }
 
 
-
 /**
  * struct spi_master - interface to SPI master controller
  * @cdev: class interface to this driver
@@ -154,19 +203,22 @@
  *	each slave has a chipselect signal, but it's common that not
  *	every chipselect is connected to a slave.
  * @setup: updates the device mode and clocking records used by a
- *	device's SPI controller; protocol code may call this.
+ *	device's SPI controller; protocol code may call this.  This
+ *	must fail if an unrecognized or unsupported mode is requested.
+ *	It's always safe to call this unless transfers are pending on
+ *	the device whose settings are being modified.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
  *
- * Each SPI master controller can communicate with one or more spi_device
+ * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
  * but not chip select signals.  Each device may be configured to use a
  * different clock rate, since those shared signals are ignored unless
  * the chip is selected.
  *
  * The driver for an SPI controller manages access to those devices through
- * a queue of spi_message transactions, copyin data between CPU memory and
- * an SPI slave device).  For each such message it queues, it calls the
+ * a queue of spi_message transactions, copying data between CPU memory and
+ * an SPI slave device.  For each such message it queues, it calls the
  * message's completion function when the transaction completes.
  */
 struct spi_master {
@@ -211,7 +263,7 @@
 						struct spi_message *mesg);
 
 	/* called on release() to free memory provided by spi_master */
-	void			(*cleanup)(const struct spi_device *spi);
+	void			(*cleanup)(struct spi_device *spi);
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
@@ -270,35 +322,45 @@
  * struct spi_transfer - a read/write buffer pair
  * @tx_buf: data to be written (dma-safe memory), or NULL
  * @rx_buf: data to be read (dma-safe memory), or NULL
- * @tx_dma: DMA address of tx_buf, if spi_message.is_dma_mapped
- * @rx_dma: DMA address of rx_buf, if spi_message.is_dma_mapped
+ * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped
+ * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped
  * @len: size of rx and tx buffers (in bytes)
  * @speed_hz: Select a speed other then the device default for this
- *      transfer. If 0 the default (from spi_device) is used.
+ *      transfer. If 0 the default (from @spi_device) is used.
  * @bits_per_word: select a bits_per_word other then the device default
- *      for this transfer. If 0 the default (from spi_device) is used.
+ *      for this transfer. If 0 the default (from @spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
- *	the next transfer or completing this spi_message.
- * @transfer_list: transfers are sequenced through spi_message.transfers
+ *	the next transfer or completing this @spi_message.
+ * @transfer_list: transfers are sequenced through @spi_message.transfers
  *
  * SPI transfers always write the same number of bytes as they read.
- * Protocol drivers should always provide rx_buf and/or tx_buf.
+ * Protocol drivers should always provide @rx_buf and/or @tx_buf.
  * In some cases, they may also want to provide DMA addresses for
  * the data being transferred; that may reduce overhead, when the
  * underlying driver uses dma.
  *
- * If the transmit buffer is null, undefined data will be shifted out
- * while filling rx_buf.  If the receive buffer is null, the data
+ * If the transmit buffer is null, zeroes will be shifted out
+ * while filling @rx_buf.  If the receive buffer is null, the data
  * shifted in will be discarded.  Only "len" bytes shift out (or in).
  * It's an error to try to shift out a partial word.  (For example, by
  * shifting out three bytes with word size of sixteen or twenty bits;
  * the former uses two bytes per word, the latter uses four bytes.)
  *
+ * In-memory data values are always in native CPU byte order, translated
+ * from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
+ * for example when bits_per_word is sixteen, buffers are 2N bytes long
+ * (@len = 2N) and hold N sixteen bit words in CPU byte order.
+ *
+ * When the word size of the SPI transfer is not a power-of-two multiple
+ * of eight bits, those in-memory words include extra bits.  In-memory
+ * words are always seen by protocol drivers as right-justified, so the
+ * undefined (rx) or unused (tx) bits are always the most significant bits.
+ *
  * All SPI transfers start with the relevant chipselect active.  Normally
  * it stays selected until after the last transfer in a message.  Drivers
- * can affect the chipselect signal using cs_change:
+ * can affect the chipselect signal using cs_change.
  *
  * (i) If the transfer isn't the last one in the message, this flag is
  * used to make the chipselect briefly go inactive in the middle of the
@@ -307,9 +369,14 @@
  * chip transactions together.
  *
  * (ii) When the transfer is the last one in the message, the chip may
- * stay selected until the next transfer.  This is purely a performance
- * hint; the controller driver may need to select a different device
- * for the next message.
+ * stay selected until the next transfer.  On multi-device SPI busses
+ * with nothing blocking messages going to other devices, this is just
+ * a performance hint; starting a message to another device deselects
+ * this one.  But in other cases, this can be used to ensure correctness.
+ * Some devices need protocol transactions to be built from a series of
+ * spi_message submissions, where the content of one message is determined
+ * by the results of previous messages and where the whole transaction
+ * ends when the chipselect goes intactive.
  *
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.
@@ -352,7 +419,7 @@
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
  *
- * An spi_message is used to execute an atomic sequence of data transfers,
+ * A @spi_message is used to execute an atomic sequence of data transfers,
  * each represented by a struct spi_transfer.  The sequence is "atomic"
  * in the sense that no other spi_message may use that SPI bus until that
  * sequence completes.  On some systems, many such sequences can execute as
@@ -402,6 +469,7 @@
 {
 	memset(m, 0, sizeof *m);
 	INIT_LIST_HEAD(&m->transfers);
+	INIT_LIST_HEAD(&m->queue);
 }
 
 static inline void
@@ -444,15 +512,22 @@
 }
 
 /**
- * spi_setup -- setup SPI mode and clock rate
+ * spi_setup - setup SPI mode and clock rate
  * @spi: the device whose settings are being modified
+ * Context: can sleep, and no requests are queued to the device
  *
  * SPI protocol drivers may need to update the transfer mode if the
- * device doesn't work with the mode 0 default.  They may likewise need
+ * device doesn't work with its default.  They may likewise need
  * to update clock rates or word sizes from initial values.  This function
  * changes those settings, and must be called from a context that can sleep.
- * The changes take effect the next time the device is selected and data
- * is transferred to or from it.
+ * Except for SPI_CS_HIGH, which takes effect immediately, the changes take
+ * effect the next time the device is selected and data is transferred to
+ * or from it.  When this function returns, the spi device is deselected.
+ *
+ * Note that this call will fail if the protocol driver specifies an option
+ * that the underlying controller or its driver does not support.  For
+ * example, not all hardware supports wire transfers using nine bit words,
+ * LSB-first wire encoding, or active-high chipselects.
  */
 static inline int
 spi_setup(struct spi_device *spi)
@@ -462,9 +537,10 @@
 
 
 /**
- * spi_async -- asynchronous SPI transfer
+ * spi_async - asynchronous SPI transfer
  * @spi: device with which data will be exchanged
  * @message: describes the data transfers, including completion callback
+ * Context: any (irqs may be blocked, etc)
  *
  * This call may be used in_irq and other contexts which can't sleep,
  * as well as from task contexts which can sleep.
@@ -510,6 +586,7 @@
  * @spi: device to which data will be written
  * @buf: data buffer
  * @len: data buffer size
+ * Context: can sleep
  *
  * This writes the buffer and returns zero or a negative error code.
  * Callable only from contexts that can sleep.
@@ -533,8 +610,9 @@
  * @spi: device from which data will be read
  * @buf: data buffer
  * @len: data buffer size
+ * Context: can sleep
  *
- * This writes the buffer and returns zero or a negative error code.
+ * This reads the buffer and returns zero or a negative error code.
  * Callable only from contexts that can sleep.
  */
 static inline int
@@ -560,6 +638,7 @@
  * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read
  * @spi: device with which data will be exchanged
  * @cmd: command to be written before data is read back
+ * Context: can sleep
  *
  * This returns the (unsigned) eight bit number returned by the
  * device, or else a negative error code.  Callable only from
@@ -580,6 +659,7 @@
  * spi_w8r16 - SPI synchronous 8 bit write followed by 16 bit read
  * @spi: device with which data will be exchanged
  * @cmd: command to be written before data is read back
+ * Context: can sleep
  *
  * This returns the (unsigned) sixteen bit number returned by the
  * device, or else a negative error code.  Callable only from
@@ -615,7 +695,37 @@
  * parport adapters, or microcontrollers acting as USB-to-SPI bridges.
  */
 
-/* board-specific information about each SPI device */
+/**
+ * struct spi_board_info - board-specific template for a SPI device
+ * @modalias: Initializes spi_device.modalias; identifies the driver.
+ * @platform_data: Initializes spi_device.platform_data; the particular
+ *	data stored there is driver-specific.
+ * @controller_data: Initializes spi_device.controller_data; some
+ *	controllers need hints about hardware setup, e.g. for DMA.
+ * @irq: Initializes spi_device.irq; depends on how the board is wired.
+ * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits
+ *	from the chip datasheet and board-specific signal quality issues.
+ * @bus_num: Identifies which spi_master parents the spi_device; unused
+ *	by spi_new_device(), and otherwise depends on board wiring.
+ * @chip_select: Initializes spi_device.chip_select; depends on how
+ *	the board is wired.
+ * @mode: Initializes spi_device.mode; based on the chip datasheet, board
+ *	wiring (some devices support both 3WIRE and standard modes), and
+ *	possibly presence of an inverter in the chipselect path.
+ *
+ * When adding new SPI devices to the device tree, these structures serve
+ * as a partial device template.  They hold information which can't always
+ * be determined by drivers.  Information that probe() can establish (such
+ * as the default transfer wordsize) is not included here.
+ *
+ * These structures are used in two places.  Their primary role is to
+ * be stored in tables of board-specific device descriptors, which are
+ * declared early in board initialization and then used (much later) to
+ * populate a controller's device tree after the that controller's driver
+ * initializes.  A secondary (and atypical) role is as a parameter to
+ * spi_new_device() call, which happens after those controller drivers
+ * are active in some dynamic board configuration models.
+ */
 struct spi_board_info {
 	/* the device name and module name are coupled, like platform_bus;
 	 * "modalias" is normally the driver name.
@@ -642,10 +752,14 @@
 	u16		bus_num;
 	u16		chip_select;
 
+	/* mode becomes spi_device.mode, and is essential for chips
+	 * where the default of SPI_CS_HIGH = 0 is wrong.
+	 */
+	u8		mode;
+
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff
 	 * needed to behave without being bound to a driver:
-	 *  - chipselect polarity
 	 *  - quirks like clock rate mattering when not selected
 	 */
 };
Index: linux-2.6.17/include/linux/spi/spi_bitbang.h
===================================================================
--- linux-2.6.17.orig/include/linux/spi/spi_bitbang.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17/include/linux/spi/spi_bitbang.h	2008-03-05 10:58:51.000000000 +0000
@@ -25,8 +25,8 @@
 	spinlock_t		lock;
 	struct list_head	queue;
 	u8			busy;
-	u8			shutdown;
 	u8			use_dma;
+	u8			flags;		/* extra spi->mode support */
 
 	struct spi_master	*master;
 
@@ -55,7 +55,7 @@
  * methods, if you like.
  */
 extern int spi_bitbang_setup(struct spi_device *spi);
-extern void spi_bitbang_cleanup(const struct spi_device *spi);
+extern void spi_bitbang_cleanup(struct spi_device *spi);
 extern int spi_bitbang_transfer(struct spi_device *spi, struct spi_message *m);
 extern int spi_bitbang_setup_transfer(struct spi_device *spi,
 				      struct spi_transfer *t);
Index: linux-2.6.17/include/linux/spi/spidev.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17/include/linux/spi/spidev.h	2008-03-05 10:58:51.000000000 +0000
@@ -0,0 +1,128 @@
+/*
+ * include/linux/spi/spidev.h
+ *
+ * Copyright (C) 2006 SWAPP
+ *	Andrea Paterniani <a.paterniani@swapp-eng.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+
+#ifndef SPIDEV_H
+#define SPIDEV_H
+
+
+/* User space versions of kernel symbols for SPI clocking modes,
+ * matching <linux/spi/spi.h>
+ */
+
+#define SPI_CPHA		0x01
+#define SPI_CPOL		0x02
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#define SPI_CS_HIGH		0x04
+#define SPI_LSB_FIRST		0x08
+#define SPI_3WIRE		0x10
+#define SPI_LOOP		0x20
+
+/*---------------------------------------------------------------------------*/
+
+/* IOCTL commands */
+
+#define SPI_IOC_MAGIC			'k'
+
+/**
+ * struct spi_ioc_transfer - describes a single SPI transfer
+ * @tx_buf: Holds pointer to userspace buffer with transmit data, or null.
+ *	If no data is provided, zeroes are shifted out.
+ * @rx_buf: Holds pointer to userspace buffer for receive data, or null.
+ * @len: Length of tx and rx buffers, in bytes.
+ * @speed_hz: Temporary override of the device's bitrate.
+ * @bits_per_word: Temporary override of the device's wordsize.
+ * @delay_usecs: If nonzero, how long to delay after the last bit transfer
+ *	before optionally deselecting the device before the next transfer.
+ * @cs_change: True to deselect device before starting the next transfer.
+ *
+ * This structure is mapped directly to the kernel spi_transfer structure;
+ * the fields have the same meanings, except of course that the pointers
+ * are in a different address space (and may be of different sizes in some
+ * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
+ * Zero-initialize the structure, including currently unused fields, to
+ * accomodate potential future updates.
+ *
+ * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
+ * Pass it an array of related transfers, they'll execute together.
+ * Each transfer may be half duplex (either direction) or full duplex.
+ *
+ *	struct spi_ioc_transfer mesg[4];
+ *	...
+ *	status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);
+ *
+ * So for example one transfer might send a nine bit command (right aligned
+ * in a 16-bit word), the next could read a block of 8-bit data before
+ * terminating that command by temporarily deselecting the chip; the next
+ * could send a different nine bit command (re-selecting the chip), and the
+ * last transfer might write some register values.
+ */
+struct spi_ioc_transfer {
+	__u64		tx_buf;
+	__u64		rx_buf;
+
+	__u32		len;
+	__u32		speed_hz;
+
+	__u16		delay_usecs;
+	__u8		bits_per_word;
+	__u8		cs_change;
+	__u32		pad;
+
+	/* If the contents of 'struct spi_ioc_transfer' ever change
+	 * incompatibly, then the ioctl number (currently 0) must change;
+	 * ioctls with constant size fields get a bit more in the way of
+	 * error checking than ones (like this) where that field varies.
+	 *
+	 * NOTE: struct layout is the same in 64bit and 32bit userspace.
+	 */
+};
+
+/* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
+#define SPI_MSGSIZE(N) \
+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
+		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
+#define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
+
+
+/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) */
+#define SPI_IOC_RD_MODE			_IOR(SPI_IOC_MAGIC, 1, __u8)
+#define SPI_IOC_WR_MODE			_IOW(SPI_IOC_MAGIC, 1, __u8)
+
+/* Read / Write SPI bit justification */
+#define SPI_IOC_RD_LSB_FIRST		_IOR(SPI_IOC_MAGIC, 2, __u8)
+#define SPI_IOC_WR_LSB_FIRST		_IOW(SPI_IOC_MAGIC, 2, __u8)
+
+/* Read / Write SPI device word length (1..N) */
+#define SPI_IOC_RD_BITS_PER_WORD	_IOR(SPI_IOC_MAGIC, 3, __u8)
+#define SPI_IOC_WR_BITS_PER_WORD	_IOW(SPI_IOC_MAGIC, 3, __u8)
+
+/* Read / Write SPI device default max speed hz */
+#define SPI_IOC_RD_MAX_SPEED_HZ		_IOR(SPI_IOC_MAGIC, 4, __u32)
+#define SPI_IOC_WR_MAX_SPEED_HZ		_IOW(SPI_IOC_MAGIC, 4, __u32)
+
+
+
+#endif /* SPIDEV_H */
Index: linux-2.6.17/include/linux/st_soc.h
===================================================================
--- linux-2.6.17.orig/include/linux/st_soc.h	2008-01-30 17:01:40.000000000 +0000
+++ linux-2.6.17/include/linux/st_soc.h	2008-03-05 10:58:51.000000000 +0000
@@ -67,7 +67,7 @@
 	unsigned int num_pio_pins;
 };
 
-/* This is the private platform data for the ssc driver */
+/* This is the private platform data for the ssc (and spi_stm_pio) driver */
 struct plat_ssc_pio_t {
         unsigned char sclbank;
         unsigned char sclpin;
@@ -75,11 +75,31 @@
         unsigned char sdoutpin;
         unsigned char sdinbank;
         unsigned char sdinpin;
+
+	struct stpio_pin *clk;
+	struct stpio_pin *sdout;
+	struct stpio_pin *sdin;
 };
 
+#define SSC_UNCONFIGURED    0x0
 #define SSC_I2C_CAPABILITY  0x1
 #define SSC_SPI_CAPABILITY  0x2
 
+#define SPI_LINE_SHIFT		0x0
+#define SPI_LINE_MASK		0x7
+#define SPI_BANK_SHIFT		0x3
+#define SPI_BANK_MASK		0xf
+#define spi_get_bank(address)  (((address) >> SPI_BANK_SHIFT) & SPI_BANK_MASK)
+#define spi_get_line(address)  (((address) >> SPI_LINE_SHIFT) & SPI_LINE_MASK)
+#define spi_set_cs(bank, line) ((((bank) & SPI_BANK_MASK) << SPI_BANK_SHIFT) | \
+				 (((line) & SPI_LINE_MASK) << SPI_LINE_SHIFT))
+/* each spi bus is able to manage 'all' the pios as chip selector
+   therefore each master must have 8(pioline)x10(piobank)
+   10 pio banks is enough for our boards
+   SPI_NO_CHIPSELECT to specify SPI device with no CS (ie CS tied to ground)
+*/
+#define SPI_NO_CHIPSELECT	(spi_set_cs(9, 7) + 1)
+
 struct plat_ssc_data {
         unsigned short  capability;   /* bitmask on the ssc capability */
         struct plat_ssc_pio_t *pio;   /* the Pio map */
Index: linux-2.6.17/include/linux/stm/stm_ssc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17/include/linux/stm/stm_ssc.h	2008-03-05 10:58:51.000000000 +0000
@@ -0,0 +1,231 @@
+/*
+   --------------------------------------------------------------------
+
+   stm_ssc.h
+   define and struct for STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef STM_SSC_H
+#define STM_SSC_H 1
+
+#include <linux/device.h>
+#include <linux/wait.h>
+#include <linux/stpio.h>
+#include <linux/mutex.h>
+#include <asm/io.h>
+
+
+/* SSC Baud Rate generator */
+#define SSC_BRG                  0x0
+/* SSC Transmitter Buffer  */
+#define SSC_TBUF                 0x4
+/* SSC Receive Buffer      */
+#define SSC_RBUF                 0x8
+/*SSC Control              */
+#define SSC_CTL                  0xC
+#define SSC_CTL_DATA_WIDTH_9     0x8
+#define SSC_CTL_BM               0xf
+#define SSC_CTL_HB               0x10
+#define SSC_CTL_PH               0x20
+#define SSC_CTL_PO		 0x40
+#define SSC_CTL_SR		 0x80
+#define SSC_CTL_MS		 0x100
+#define SSC_CTL_EN		 0x200
+#define SSC_CTL_LPB		 0x400
+#define SSC_CTL_EN_TX_FIFO       0x800
+#define SSC_CTL_EN_RX_FIFO       0x1000
+#define SSC_CTL_EN_CLST_RX       0x2000
+
+/* SSC Interrupt Enable */
+#define SSC_IEN               	0x10
+#define SSC_IEN_RIEN		0x1
+#define SSC_IEN_TIEN		0x2
+#define SSC_IEN_TEEN		0x4
+#define SSC_IEN_REEN		0x8
+#define SSC_IEN_PEEN		0x10
+#define SSC_IEN_AASEN		0x40
+#define SSC_IEN_STOPEN		0x80
+#define SSC_IEN_ARBLEN		0x100
+#define SSC_IEN_NACKEN		0x400
+#define SSC_IEN_REPSTRTEN	0x800
+#define SSC_IEN_TX_FIFO_HALF	0x1000
+#define SSC_IEN_RX_FIFO_HALF_FULL	0x4000
+
+/* SSC Status */
+#define SSC_STA                   0x14
+#define SSC_STA_RIR		  0x1
+#define SSC_STA_TIR		  0x2
+#define SSC_STA_TE		  0x4
+#define SSC_STA_RE		  0x8
+#define SSC_STA_PE		 0x10
+#define SSC_STA_CLST		 0x20
+#define SSC_STA_AAS		 0x40
+#define SSC_STA_STOP		 0x80
+#define SSC_STA_ARBL		0x100
+#define SSC_STA_BUSY		0x200
+#define SSC_STA_NACK		0x400
+#define SSC_STA_REPSTRT		0x800
+#define SSC_STA_TX_FIFO_HALF	0x1000
+#define SSC_STA_TX_FIFO_FULL    0x2000
+#define SSC_STA_RX_FIFO_HALF    0x4000
+
+/*SSC I2C Control */
+#define SSC_I2C               	0x18
+#define SSC_I2C_I2CM		0x1
+#define SSC_I2C_STRTG		0x2
+#define SSC_I2C_STOPG		0x4
+#define SSC_I2C_ACKG		0x8
+#define SSC_I2C_AD10		0x10
+#define SSC_I2C_TXENB		0x20
+#define SSC_I2C_REPSTRTG	0x800
+#define SSC_I2C_I2CFSMODE	0x1000
+/* SSC Slave Address */
+#define SSC_SLAD              	0x1C
+/* SSC I2C bus repeated start hold time */
+#define SSC_REP_START_HOLD    	0x20
+/* SSC I2C bus start hold time */
+#define SSC_START_HOLD        	0x24
+/* SSC I2C bus repeated start setup time */
+#define SSC_REP_START_SETUP   	 0x28
+/* SSC I2C bus repeated stop setup time */
+#define SSC_DATA_SETUP		0x2C
+/* SSC I2C bus stop setup time */
+#define SSC_STOP_SETUP		0x30
+/* SSC I2C bus free time */
+#define SSC_BUS_FREE		0x34
+
+/* SSC Tx FIFO Status */
+#define SSC_TX_FSTAT            0x38
+#define SSC_TX_FSTAT_STATUS     0x07
+
+/* SSC Rx FIFO Status */
+#define SSC_RX_FSTAT            0x3C
+#define SSC_RX_FSTAT_STATUS     0x07
+
+/* SSC Prescaler value value for clock */
+#define SSC_PRE_SCALER_BRG      0x40
+
+/* SSC Clear bit operation */
+#define SSC_CLR			0x80
+#define SSC_CLR_SSCAAS 		0x40
+#define SSC_CLR_SSCSTOP 	0x80
+#define SSC_CLR_SSCARBL 	0x100
+#define SSC_CLR_NACK    	0x400
+#define SSC_CLR_REPSTRT     	0x800
+
+/* SSC Noise suppression Width */
+#define SSC_NOISE_SUPP_WIDTH	0x100
+/* SSC Clock Prescaler */
+#define SSC_PRSCALER		0x104
+#define SSC_PRSC_VALUE          0x0f
+
+/* SSC Noise suppression Width dataout */
+#define SSC_NOISE_SUPP_WIDTH_DATAOUT	0x108
+
+/* SSC Prescaler for delay in dataout */
+#define SSC_PRSCALER_DATAOUT	0x10c
+
+#define SSC_TXFIFO_SIZE         0x8
+#define SSC_RXFIFO_SIZE         0x8
+/*
+ * The I2C timing register could be ready
+ * for normal or fast rate
+ */
+#define SSC_I2C_READY_NORMAL    0x0
+#define SSC_I2C_READY_FAST      0x1
+struct ssc_t {
+	unsigned int ssc_id;
+	struct stpio_pin *pio_clk;
+	struct stpio_pin *pio_data;
+	struct stpio_pin *pio_data_in;
+	wait_queue_head_t wait_queue;
+	struct mutex	  mutex_bus;
+	void *base;
+	void (*irq_function) (void *);
+	void *irq_private_data;
+        unsigned char    i2c_timing;
+        struct device dev;
+};
+
+struct ssc_t *ssc_device_request(unsigned int ssc_id);
+
+/*
+ *  How many ssc device are available on this platform
+ */
+unsigned int ssc_device_available(void);
+
+/*
+ *  The input clock for each SSC device
+ */
+
+unsigned int ssc_get_clock(void);
+
+/*
+ *  To say if the ssc_is ssc can support I2C and/or SPI protocol
+ */
+
+#define SSC_UNCONFIGURED    0x0
+#define SSC_I2C_CAPABILITY  0x1
+#define SSC_SPI_CAPABILITY  0x2
+
+unsigned int ssc_capability(unsigned int ssc_id);
+/*
+ *   To request the bus access
+ *   The user registers also the function and the data that
+ *   they want use in the IRQ_Function
+ */
+void ssc_request_bus(struct ssc_t *, void (*irq_function) (void *),
+		     void *irq_data);
+
+/*
+ *   To release the bus
+ */
+void ssc_release_bus(struct ssc_t *);
+
+/*
+   we have to use the following macro
+   to access the SSC I/O Memory
+*/
+#define ssc_store16(ssc , offset, value) iowrite16(value,ssc->base+offset)
+#define ssc_store8( ssc , offset, value) iowrite8( value,ssc->base+offset)
+
+#define ssc_load16( ssc,offset)          ioread16(ssc->base+offset)
+#define ssc_load8(  ssc,offset)	         ioread8( ssc->base+offset)
+
+/*
+ *   This macro could be used to built the capability field
+ *   of struct plat_ssc_data for each SoC
+ */
+#define ssc_ability(idx_ssc, cap)					\
+         ( cap & (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY ) ) << (idx_ssc*2)
+
+#define ssc0_ability(cap)  ssc_ability(0,cap)
+#define ssc1_ability(cap)  ssc_ability(1,cap)
+#define ssc2_ability(cap)  ssc_ability(2,cap)
+#define ssc3_ability(cap)  ssc_ability(3,cap)
+#define ssc4_ability(cap)  ssc_ability(4,cap)
+
+#endif				/* STM_SSC_H */
Index: linux-2.6.17/drivers/stm/stm_spi.h
===================================================================
--- linux-2.6.17.orig/drivers/stm/stm_spi.h	2008-01-30 17:01:39.000000000 +0000
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,103 +0,0 @@
-/*
-   --------------------------------------------------------------------
-
-   stm_spi.h
-   define and struct for SPI device driver
-   based on STMicroelectronics SSC device
-
-   --------------------------------------------------------------------
-
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
-
-*/
-#ifndef STM_SPI
-#define STM_SPI
-
-#define SPI_IOCTL_WIDEFRAME     0x01
-#define SPI_ARG_WIDE_16BITS     0x01
-#define SPI_ARG_WIDE_8BITS      0x00
-
-#define SPI_IOCTL_PHASE         0x02
-#define SPI_ARG_PHASE_HIGH      0x01
-#define SPI_ARG_PHASE_LOW       0x00
-
-#define SPI_IOCTL_POLARITY      0x04
-#define SPI_ARG_POLARITY_HIGH   0x01
-#define SPI_ARG_POLARIT_LOWY    0x00
-
-#define SPI_IOCTL_HEADING       0x08
-#define SPI_ARG_HEADING_MSB     0x01
-#define SPI_ARG_HEADING_LSB     0x00
-
-#define SPI_IOCTL_CSACTIVE      0x10
-#define SPI_ARG_CSACTIVE_HIGH   0x01
-#define SPI_ARG_CSACTIVE_LOW    0x00
-
-#define SPI_IOCTL_BUADRATE      0x20
-
-#define SPI_IOCTL_ADDRESS       0x40
-
-#define SPI_IOCTL_TIMEOUT       0x80
-
-/*#define SPI_IOCTL_NOSELECTION   0x100*/
-
-
-#ifdef __KERNEL__
-#include "stm_ssc.h"
-#include <linux/device.h>
-
-extern struct bus_type spi_bus_type;
-
-#define SPI_DEV_BUS_ADAPTER      0x01
-#define SPI_DEV_CLIENT_ADAPTER   0x02
-
-struct spi_device_t {
-	unsigned int idx_dev;
-        unsigned int dev_type; /* SPI_DEV_BUS_ADAPTER xor SPI_DEV_CLIENT_ADAPTER*/
-	struct device dev;
-	struct class_device *class_dev;
-};
-
-struct spi_client_t {
-	struct spi_device_t *dev;       /* the bus device used */
-	struct stpio_pin *pio_chip;
-	char *wr_buf;
-	char *rd_buf;
-	unsigned long config;		/* the clinet configuration */
-	unsigned long timeout;
-};
-
-struct spi_client_t* spi_create_client(int bus_number);
-
-int spi_client_release(struct spi_client_t* spi);
-
-int spi_client_control(struct spi_client_t* spi, int cmd, int arg);
-
-int spi_write(struct spi_client_t* spi, char *wr_buffer, size_t count);
-
-int spi_read(struct spi_client_t* spi, char *rd_buffer, size_t count);
-
-int spi_write_then_read(struct spi_client_t* spi,char *wr_buffer,
-			char *rd_buffer, size_t count);
-
-#endif
-
-#endif
Index: linux-2.6.17/arch/sh/boards/st/hms1/setup.c
===================================================================
--- linux-2.6.17.orig/arch/sh/boards/st/hms1/setup.c	2008-01-30 17:01:40.000000000 +0000
+++ linux-2.6.17/arch/sh/boards/st/hms1/setup.c	2008-03-05 10:58:51.000000000 +0000
@@ -50,9 +50,8 @@
 	/* Route UART2 and PWM to PIO4 instead of SCIF */
 	sysconf &= ~(1<<0);
 
-	/* Set SSC2_MUX_SEL = 0 */
-	/* Treat SSC2 as I2C instead of SSC */
-	sysconf &= ~(1<<3);
+	/* Set SSC{0,1,2}_MUX_SEL = 0 */
+	sysconf &= ~(0xE);
 
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
Index: linux-2.6.17/arch/sh/boards/st/stb7100mboard/setup.c
===================================================================
--- linux-2.6.17.orig/arch/sh/boards/st/stb7100mboard/setup.c	2008-01-30 17:01:40.000000000 +0000
+++ linux-2.6.17/arch/sh/boards/st/stb7100mboard/setup.c	2008-03-05 10:58:51.000000000 +0000
@@ -107,9 +107,8 @@
 	/* Route UART2 and PWM to PIO4 instead of SCIF */
 	sysconf &= ~(1<<0);
 
-	/* Set SSC2_MUX_SEL = 0 */
-	/* Treat SSC2 as I2C instead of SSC */
-	sysconf &= ~(1<<3);
+	/* Set SSC{0,1,2}_MUX_SEL = 0 */
+	sysconf &= ~(0xE);
 
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
Index: linux-2.6.17/arch/sh/boards/st/stb7109eref/setup.c
===================================================================
--- linux-2.6.17.orig/arch/sh/boards/st/stb7109eref/setup.c	2008-03-05 10:36:48.000000000 +0000
+++ linux-2.6.17/arch/sh/boards/st/stb7109eref/setup.c	2008-03-05 10:58:51.000000000 +0000
@@ -89,9 +89,9 @@
 	printk("STb7109 version %ld.x\n", chip_revision);
 
 	/* Route UART2 instead of SCI to PIO4 */
-	/* Set ssc2_mux_sel = 0 */
 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
-	sysconf &= ~(1<<3);
+	/* Set SSC{0,1,2}_MUX_SEL = 0 */
+	sysconf &= ~(0xE);
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
 	/* Permanently enable Flash VPP */
