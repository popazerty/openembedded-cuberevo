diff --git a/MAKEALL b/MAKEALL
index 931ea5e..4b9934a 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -682,6 +682,12 @@ LIST_sh="		\
 	mb680se		\
 	pdk7105		\
 	pdk7105se	\
+	ipidtv7105	\
+	ipidtv7105se	\
+	mb704		\
+	mb704se		\
+	5197cab		\
+	5197cabse	\
 	cb101		\
 	cb101se		\
 	cb102		\
diff --git a/Makefile b/Makefile
index 24e239d..436fd47 100644
--- a/Makefile
+++ b/Makefile
@@ -2781,6 +2781,39 @@ pdk7105se_config :		unconfig
 	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
 	@./mkconfig -a pdk7105 sh sh pdk7105 "" stx7105
 
+ipidtv7105_config \
+ipidtv7105se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7105    1" >>include/config.h
+	@echo "#define CONFIG_SH_IPIDTV7105 1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
+	@./mkconfig -a ipidtv7105 sh sh pdk7105 "" stx7105
+
+mb704_config \
+mb704se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX5197   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB704     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/mb704/config.tmp)
+	@./mkconfig -a mb704 sh sh mb704 "" stx5197
+
+5197cab_config \
+5197cabse_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX5197   1" >>include/config.h
+	@echo "#define CONFIG_SH_5197CAB   1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/5197cab/config.tmp)
+	@./mkconfig -a 5197cab sh sh 5197cab "" stx5197
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
diff --git a/board/5197cab/5197cab.c b/board/5197cab/5197cab.c
new file mode 100644
index 0000000..2b22d5a
--- /dev/null
+++ b/board/5197cab/5197cab.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-CAB"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/5197cab/5197cab.romgen b/board/5197cab/5197cab.romgen
new file mode 100644
index 0000000..08fa12f
--- /dev/null
+++ b/board/5197cab/5197cab.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/5197cab/Makefile b/board/5197cab/Makefile
new file mode 100644
index 0000000..70041dd
--- /dev/null
+++ b/board/5197cab/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/5197cab/config.mk b/board/5197cab/config.mk
new file mode 100644
index 0000000..d83a0ae
--- /dev/null
+++ b/board/5197cab/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# STx5197-CAB board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/5197cab/init-5197cab.S b/board/5197cab/init-5197cab.S
new file mode 100644
index 0000000..d1c9920
--- /dev/null
+++ b/board/5197cab/init-5197cab.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "5197cab.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/cb101/init-cb101.S b/board/cb101/init-cb101.S
index 7cc8997..5f6c463 100644
--- a/board/cb101/init-cb101.S
+++ b/board/cb101/init-cb101.S
@@ -16,8 +16,9 @@
  */
 
 
-.balign 32
+	.section .data.init, "a"
 
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/cb101/u-boot.lds b/board/cb101/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/cb101/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/cb102/init-cb102.S b/board/cb102/init-cb102.S
index 2be2646..688b229 100644
--- a/board/cb102/init-cb102.S
+++ b/board/cb102/init-cb102.S
@@ -32,8 +32,10 @@
 #define DELAY(VAL)				/* do nothing */
 #endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
 
-.balign 32
 
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/cb102/u-boot.lds b/board/cb102/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/cb102/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/cb103/init-cb103.S b/board/cb103/init-cb103.S
index 5a1b661..32770ab 100644
--- a/board/cb103/init-cb103.S
+++ b/board/cb103/init-cb103.S
@@ -30,6 +30,8 @@
 #define DELAY(VAL)				/* do nothing */
 
 
+	.section .data.init, "a"
+
 	.balign 32
 
 __memory_setup_table:
diff --git a/board/hms1/hms1.c b/board/hms1/hms1.c
index b6b22b1..82726d9 100644
--- a/board/hms1/hms1.c
+++ b/board/hms1/hms1.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stb7100reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -62,10 +63,6 @@ static void stb7100mboard_init_ide(void)
 }
 #endif
 
-#ifdef CONFIG_SH_STB7100_SATA
-extern void stb7100_sata_init(void);
-#endif
-
 #endif
 
 int board_init(void)
diff --git a/board/hms1/init-hms1.S b/board/hms1/init-hms1.S
index 62781db..fef751a 100644
--- a/board/hms1/init-hms1.S
+++ b/board/hms1/init-hms1.S
@@ -10,7 +10,10 @@
  * An opcode of 0 marks the table end
  */
 
-.balign 32
+
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/hms1/u-boot.lds b/board/hms1/u-boot.lds
deleted file mode 100644
index 246c526..0000000
--- a/board/hms1/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb411/init-mb411.S b/board/mb411/init-mb411.S
index 7969ddd..e926753 100644
--- a/board/mb411/init-mb411.S
+++ b/board/mb411/init-mb411.S
@@ -10,7 +10,10 @@
  * An opcode of 0 marks the table end
  */
 
-.balign 32
+
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/mb411/mb411.c b/board/mb411/mb411.c
index f91e107..0038b2d 100644
--- a/board/mb411/mb411.c
+++ b/board/mb411/mb411.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stb7100reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -69,10 +70,6 @@ static void stb7100mboard_init_ide(void)
 }
 #endif
 
-#ifdef CONFIG_SH_STB7100_SATA
-extern void stb7100_sata_init(void);
-#endif
-
 #endif
 
 int board_init(void)
diff --git a/board/mb411/u-boot.lds b/board/mb411/u-boot.lds
deleted file mode 100644
index 246c526..0000000
--- a/board/mb411/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb442/init-mb442.S b/board/mb442/init-mb442.S
index 043a6e9..68c85db 100644
--- a/board/mb442/init-mb442.S
+++ b/board/mb442/init-mb442.S
@@ -10,7 +10,10 @@
  * An opcode of 0 marks the table end
  */
 
-.balign 32
+
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/mb442/mb442.c b/board/mb442/mb442.c
index cf4837c..ee5ea3a 100644
--- a/board/mb442/mb442.c
+++ b/board/mb442/mb442.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stb7100reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -69,10 +70,6 @@ static void stb7100ref_init_ide(void)
 }
 #endif
 
-#ifdef CONFIG_SH_STB7100_SATA
-extern void stb7100_sata_init(void);
-#endif
-
 #endif
 
 int board_init(void)
diff --git a/board/mb442/u-boot.lds b/board/mb442/u-boot.lds
deleted file mode 100644
index 246c526..0000000
--- a/board/mb442/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb448/init-mb448.S b/board/mb448/init-mb448.S
index cc2c920..430e875 100644
--- a/board/mb448/init-mb448.S
+++ b/board/mb448/init-mb448.S
@@ -10,7 +10,10 @@
  * An opcode of 0 marks the table end
  */
 
-.balign 32
+
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/mb448/mb448.c b/board/mb448/mb448.c
index 76580e1..0162801 100644
--- a/board/mb448/mb448.c
+++ b/board/mb448/mb448.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stb7100reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -67,10 +68,6 @@ static void stb7100ref_init_ide(void)
 }
 #endif
 
-#ifdef CONFIG_SH_STB7100_SATA
-extern void stb7100_sata_init(void);
-#endif
-
 #endif
 
 int board_init(void)
diff --git a/board/mb448/u-boot.lds b/board/mb448/u-boot.lds
deleted file mode 100644
index 246c526..0000000
--- a/board/mb448/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb519/init-mb519.S b/board/mb519/init-mb519.S
index 5bde353..6d91947 100644
--- a/board/mb519/init-mb519.S
+++ b/board/mb519/init-mb519.S
@@ -16,8 +16,9 @@
  */
 
 
-.balign 32
+	.section .data.init, "a"
 
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/mb519/u-boot.lds b/board/mb519/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/mb519/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
index 1cc7e31..e9d3b27 100644
--- a/board/mb618/init-mb618.S
+++ b/board/mb618/init-mb618.S
@@ -29,8 +29,10 @@
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
 
-.balign 32
 
+	.section .data.init, "a"
+
+	.balign 32
 
 __memory_setup_table:
 
diff --git a/board/mb618/u-boot.lds b/board/mb618/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/mb618/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb628/init-mb628.S b/board/mb628/init-mb628.S
index 9f65bb5..62933e5 100644
--- a/board/mb628/init-mb628.S
+++ b/board/mb628/init-mb628.S
@@ -30,6 +30,8 @@
 #define DELAY(VAL)				/* do nothing */
 
 
+	.section .data.init, "a"
+
 	.balign 32
 
 __memory_setup_table:
diff --git a/board/mb628/mb628.c b/board/mb628/mb628.c
index 0a72207..8aa355c 100644
--- a/board/mb628/mb628.c
+++ b/board/mb628/mb628.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7141reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -109,6 +110,10 @@ extern int board_init(void)
 {
 	configPIO();
 
+#if defined(CONFIG_SH_STM_SATA)
+	stx7141_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
 	return 0;
 }
 
diff --git a/board/mb628/u-boot.lds b/board/mb628/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/mb628/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
index 89c6597..1099bc9 100644
--- a/board/mb671/init-mb671.S
+++ b/board/mb671/init-mb671.S
@@ -30,6 +30,8 @@
 #define DELAY(VAL)				/* do nothing */
 
 
+	.section .data.init, "a"
+
 	.balign 32
 
 __memory_setup_table:
diff --git a/board/mb671/mb671.c b/board/mb671/mb671.c
index 254ee1a..073fe75 100644
--- a/board/mb671/mb671.c
+++ b/board/mb671/mb671.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007-2008 STMicroelectronics.
+ * (C) Copyright 2007-2009 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -38,13 +38,13 @@
 
 #define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
 
-void flashWriteEnable(void)
+extern void flashWriteEnable(void)
 {
 	/*  Enable vpp for writing to flash */
 	*EPLD_FlashCtrlAddr = 3;
 }
 
-void flashWriteDisable(void)
+extern void flashWriteDisable(void)
 {
 	/*  Disable vpp for writing to flash */
 	*EPLD_FlashCtrlAddr = 2;
@@ -59,7 +59,7 @@ static void configPIO(void)
 	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
 }
 
-int board_init(void)
+extern int board_init(void)
 {
 	unsigned long sysconf;
 
@@ -120,7 +120,8 @@ int board_init(void)
 	return 0;
 }
 
-int checkboard (void)
+
+extern int checkboard (void)
 {
 	printf ("\n\nBoard: STx7200-Reference (MB671)"
 #ifdef CONFIG_SH_SE_MODE
@@ -140,5 +141,9 @@ int checkboard (void)
 #endif
 #endif	/* CONFIG_DRIVER_NETSTMAC */
 
+#if defined(CONFIG_SH_STM_SATA)
+	stx7200_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
 	return 0;
 }
diff --git a/board/mb671/u-boot.lds b/board/mb671/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/mb671/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb680/init-mb680.S b/board/mb680/init-mb680.S
index 811b362..28af5b1 100644
--- a/board/mb680/init-mb680.S
+++ b/board/mb680/init-mb680.S
@@ -30,6 +30,8 @@
 #define DELAY(VAL)				/* do nothing */
 
 
+	.section .data.init, "a"
+
 	.balign 32
 
 __memory_setup_table:
diff --git a/board/mb680/mb680.c b/board/mb680/mb680.c
index c7cd953..4d2da9f 100644
--- a/board/mb680/mb680.c
+++ b/board/mb680/mb680.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7105reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -176,6 +177,10 @@ extern int board_init(void)
 	phy_reset();
 #endif	/* CONFIG_STMAC_LAN8700 */
 
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
 	return 0;
 }
 
diff --git a/board/mb680/u-boot.lds b/board/mb680/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/mb680/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/board/mb704/Makefile b/board/mb704/Makefile
new file mode 100644
index 0000000..70041dd
--- /dev/null
+++ b/board/mb704/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb704/config.mk b/board/mb704/config.mk
new file mode 100644
index 0000000..ca02cd3
--- /dev/null
+++ b/board/mb704/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB704 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb704/init-mb704.S b/board/mb704/init-mb704.S
new file mode 100644
index 0000000..e848acc
--- /dev/null
+++ b/board/mb704/init-mb704.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb704.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb704/mb704.c b/board/mb704/mb704.c
new file mode 100644
index 0000000..cf40a9a
--- /dev/null
+++ b/board/mb704/mb704.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-Mboard (MB704)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/mb704/mb704.romgen b/board/mb704/mb704.romgen
new file mode 100644
index 0000000..08fa12f
--- /dev/null
+++ b/board/mb704/mb704.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/pdk7105/init-pdk7105.S b/board/pdk7105/init-pdk7105.S
index 25bca4d..badb26e 100644
--- a/board/pdk7105/init-pdk7105.S
+++ b/board/pdk7105/init-pdk7105.S
@@ -30,6 +30,8 @@
 #define DELAY(VAL)				/* do nothing */
 
 
+	.section .data.init, "a"
+
 	.balign 32
 
 __memory_setup_table:
diff --git a/board/pdk7105/pdk7105.c b/board/pdk7105/pdk7105.c
index 29df917..c489b83 100644
--- a/board/pdk7105/pdk7105.c
+++ b/board/pdk7105/pdk7105.c
@@ -24,14 +24,12 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7105reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
 
 
-#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
-
-
 void flashWriteEnable(void)
 {
 	/* Enable Vpp for writing to flash */
@@ -119,24 +117,77 @@ static void configEthernet(void)
 	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
 }
 
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+#if defined(CONFIG_SOFT_SPI)
+	/* Configure SPI Serial Flash for PIO "bit-banging" */
+
+#if 1
+	/*
+	 * On the PDK-7105 board, the following 4 pairs of PIO
+	 * pins are connected together with a 3K3 resistor.
+	 *
+	 *	SPI_CLK  PIO15[0] <-> PIO2[5] COM_CLK
+	 *	SPI_DOUT PIO15[1] <-> PIO2[6] COM_DOUT
+	 *	SPI_NOCS PIO15[2] <-> PIO2[4] COM_NOTCS
+	 *	SPI_DIN  PIO15[3] <-> PIO2[7] COM_DIN
+	 *
+	 * To minimise drive "contention", we may set
+	 * associated pins on PIO2 to be simple inputs.
+	 */
+	SET_PIO_PIN(PIO_PORT(2),4,STPIO_IN);	/* COM_NOTCS */
+	SET_PIO_PIN(PIO_PORT(2),5,STPIO_IN);	/* COM_CLK */
+	SET_PIO_PIN(PIO_PORT(2),6,STPIO_IN);	/* COM_DOUT */
+	SET_PIO_PIN(PIO_PORT(2),7,STPIO_IN);	/* COM_DIN */
+#endif
+
+	/* SPI is on PIO15:[3:0] */
+	SET_PIO_PIN(PIO_PORT(15),3,STPIO_IN);	/* SPI_DIN */
+	SET_PIO_PIN(PIO_PORT(15),0,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(15),1,STPIO_OUT);	/* SPI_DOUT */
+	SET_PIO_PIN(PIO_PORT(15),2,STPIO_OUT);	/* SPI_NOCS */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(15), 2, 1);	/* deassert SPI_NOCS */
+	STPIO_SET_PIN(PIO_PORT(15), 0, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), 1, 0);	/* deassert SPI_DOUT */
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
 static void configPIO(void)
 {
 	unsigned long sysconf;
 
 	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
-
-	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
-	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
-
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	SET_PIO_ASC(PIO_PORT(0), 0, 1, 4, 3);  /* UART0 */
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 */
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 */
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	/* Route UART0 via PIO0 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG19;
+	/* PIO0[0] CFG19[16,8,0]   AltFunction = 4 */
+	/* PIO0[1] CFG19[17,9,1]   AltFunction = 4 */
+	/* PIO0[3] CFG19[19,11,3]  AltFunction = 4 */
+	/* PIO0[4] CFG19[20,12,4]  AltFunction = 4 */
+	sysconf &= ~0x1b1b1bul;	/* 7,7,0,7,7 */
+	sysconf |=  0x001b1bul;	/* 3,3,0,3,3 */
+	*STX7105_SYSCONF_SYS_CFG19 = sysconf;
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
 	/* Select UART2 via PIO4 */
 	sysconf = *STX7105_SYSCONF_SYS_CFG07;
 	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
 	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
 	sysconf &= ~(1ul<<2 | 1ul<<1);
 	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
-
 	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
 	sysconf = *STX7105_SYSCONF_SYS_CFG34;
 	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
@@ -146,7 +197,7 @@ static void configPIO(void)
 	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
 	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
 	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
-
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
 	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
 	sysconf = *STX7105_SYSCONF_SYS_CFG35;
 	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
@@ -156,15 +207,30 @@ static void configPIO(void)
 	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
 	sysconf |=  0x000ful;	/* 1,1,1,1 */
 	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
+	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
 
 	/* Configure & Reset the Ethernet PHY */
 	configEthernet();
+
+#if defined(CONFIG_SPI)
+	/* Configure for SPI Serial Flash */
+	configSpi();
+#endif	/* CONFIG_SPI */
 }
 
 extern int board_init(void)
 {
 	configPIO();
 
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
 	return 0;
 }
 
diff --git a/board/pdk7105/u-boot.lds b/board/pdk7105/u-boot.lds
deleted file mode 100644
index 3a1e91b..0000000
--- a/board/pdk7105/u-boot.lds
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(sh4)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/sh/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	_uboot_end_data = .;
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		__bss_end = .;
-	}
-	_uboot_end = .;
-}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 0fb7229..3bc8c62 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -280,19 +280,7 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 #elif defined(CONFIG_SH4)
 
-#if defined(CONFIG_SH_STB7100)
-#include <asm/stb7100reg.h>
-#elif defined(CONFIG_SH_STX7105)
-#include <asm/stx7105reg.h>
-#elif defined(CONFIG_SH_STX7111)
-#include <asm/stx7111reg.h>
-#elif defined(CONFIG_SH_STX7141)
-#include <asm/stx7141reg.h>
-#elif defined(CONFIG_SH_STX7200)
-#include <asm/stx7200reg.h>
-#else
-#error Missing Device Definitions!
-#endif
+#include "asm/socregs.h"
 
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -311,9 +299,11 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	print_num ("boot_params",	(ulong)bd->bi_boot_params);
 	print_num ("memstart",		(ulong)bd->bi_memstart);
 	print_mem ("memsize",		(ulong)bd->bi_memsize);
+#ifndef CFG_NO_FLASH
 	print_num ("flashstart",	(ulong)bd->bi_flashstart);
 	print_mem ("flashsize",		(ulong)bd->bi_flashsize);
 	print_num ("flashoffset",	(ulong)bd->bi_flashoffset);
+#endif /* CFG_NO_FLASH */
 
 #if defined(CONFIG_CMD_NET)
 	puts ("ethaddr     =");
@@ -330,6 +320,9 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		printf ("\nSTb7109 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
 	else if (STB7100_DEVICEID_7100(bd->bi_devid))
 		printf ("\nSTb7100 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX5197)
+	if (STX5197_DEVICEID_5197(bd->bi_devid))
+		printf ("\nSTx5197 version %ld.x", STX5197_DEVICEID_CUT(bd->bi_devid));
 #elif defined(CONFIG_SH_STX7105)
 	if (STX7105_DEVICEID_7105(bd->bi_devid))
 		printf ("\nSTx7105 version %ld.x", STX7105_DEVICEID_CUT(bd->bi_devid));
diff --git a/common/cmd_spi.c b/common/cmd_spi.c
index 7604422..cf91a01 100644
--- a/common/cmd_spi.c
+++ b/common/cmd_spi.c
@@ -1,6 +1,7 @@
 /*
  * (C) Copyright 2002
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ * (C) Copyright 2009 STMicroelectronics.  Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -38,13 +39,6 @@
 #endif
 
 /*
- * External table of chip select functions (see the appropriate board
- * support for the actual definition of the table).
- */
-extern spi_chipsel_type spi_chipsel[];
-extern int spi_chipsel_cnt;
-
-/*
  * Values from last command.
  */
 static int   device;
@@ -65,7 +59,7 @@ static uchar din[MAX_SPI_BYTES];
 
 int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	char  *cp = 0;
+	uchar  *cp = 0;
 	uchar tmp;
 	int   j;
 	int   rcode = 0;
@@ -82,7 +76,7 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		if (argc >= 3)
 			bitlen = simple_strtoul(argv[2], NULL, 10);
 		if (argc >= 4) {
-			cp = argv[3];
+			cp = (uchar*)argv[3];
 			for(j = 0; *cp; j++, cp++) {
 				tmp = *cp - '0';
 				if(tmp > 9)
@@ -117,7 +111,7 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		printf("Error with the SPI transaction.\n");
 		rcode = 1;
 	} else {
-		cp = (char *)din;
+		cp = din;
 		for(j = 0; j < ((bitlen + 7) / 8); j++) {
 			printf("%02X", *cp++);
 		}
diff --git a/common/env_flash.c b/common/env_flash.c
index 52cca46..f37a6ee 100644
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -53,7 +53,7 @@ DECLARE_GLOBAL_DATA_PTR;
 # endif
 #endif
 
-char * env_name_spec = "Flash";
+char * env_name_spec = "NOR Flash";
 
 #ifdef ENV_IS_EMBEDDED
 
diff --git a/common/env_nand.c b/common/env_nand.c
index 38a07f8..598bb64 100644
--- a/common/env_nand.c
+++ b/common/env_nand.c
@@ -64,7 +64,7 @@ extern nand_info_t nand_info[];
 extern uchar default_environment[];
 extern int default_environment_size;
 
-char * env_name_spec = "NAND";
+char * env_name_spec = "NAND Flash";
 
 
 #ifdef ENV_IS_EMBEDDED
diff --git a/common/soft_spi.c b/common/soft_spi.c
index e425061..e4ac762 100644
--- a/common/soft_spi.c
+++ b/common/soft_spi.c
@@ -27,7 +27,7 @@
 #include <common.h>
 #include <spi.h>
 
-#if defined(CONFIG_SOFT_SPI)
+#if defined(CONFIG_SOFT_SPI) && !defined(CONFIG_SH4)
 
 /*-----------------------------------------------------------------------
  * Definitions
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
index b66a274..10e506c 100644
--- a/cpu/sh/Makefile
+++ b/cpu/sh/Makefile
@@ -26,7 +26,10 @@ include $(TOPDIR)/config.mk
 LIB	= lib$(CPU).a
 
 START	= start.o
-OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o ecc.o stm-nand.o
+OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
+OBJS	+= ecc.o stm-nand.o cmd_copybbt.o	# NAND
+OBJS	+= sata-init.o sata-probe.o		# SATA
+OBJS	+= spi.o env_eeprom.o			# SPI
 SOBJS	=
 
 all:	.depend $(START) $(LIB)
diff --git a/cpu/sh/cmd_copybbt.c b/cpu/sh/cmd_copybbt.c
new file mode 100644
index 0000000..25ca5f8
--- /dev/null
+++ b/cpu/sh/cmd_copybbt.c
@@ -0,0 +1,256 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+
+#if defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING) && defined(CONFIG_CMD_NAND)
+
+
+#include <nand.h>
+
+
+#define NAND_SIGNATURE_OFFSET		0x80u
+#define NAND_SIGNATURE_LENGTH		0x40u
+#define NAND_BB_SKIP_OFFSET		(NAND_SIGNATURE_OFFSET + NAND_SIGNATURE_LENGTH)
+
+
+typedef struct skip_bb			/* see cpu/sh/start.S for more details */
+{
+	uchar	pattern[8];
+	u32	block_size;
+	u32	num_blocks;
+	u32	array[0];
+} skip_bb;
+
+
+static int check_skip_bb(const ulong addr)
+{
+	const uchar * const signature = (uchar*)(addr+NAND_SIGNATURE_OFFSET);
+	const skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	const uchar pattern[] = "SKIP_BBs";
+	size_t i;
+
+	/*
+	 * ensure the (64-byte) NAND magic signature is correct
+	 */
+	for(i=0; i<NAND_SIGNATURE_LENGTH; i++)
+	{
+		if (signature[i] != i)
+		{
+			printf ("Error: "
+				"Invalid NAND signature at 0x%08x (%x != %x)\n",
+				&signature[i],
+				signature[i],
+				i);
+			return (1);	/* image is INVALID */
+		}
+	}
+
+	/*
+	 * ensure the (8-byte) "skip_bb" pattern is correct.
+	 */
+	for(i=0; i<sizeof(ptr->pattern); i++)
+	{
+		if (ptr->pattern[i] != pattern[i])
+		{
+			printf ("Error: "
+				"Invalid SKIP_BB pattern at 0x%08x (%x != %x)\n",
+				ptr->pattern,
+				ptr->pattern[i],
+				pattern[i]);
+			return (1);	/* image is INVALID */
+		}
+	}
+
+	/*
+	 * ensure the address provided is 4-byte aligned!
+	 */
+	if (addr % 4ul != 0ul)
+	{
+		printf ("Error: "
+			"address (0x%08lx) must be 4-byte aligned\n",
+			addr);
+		return (1);		/* 'addr' is INVALID */
+	}
+
+	/*
+	 * ensure the physical NAND device has been initialized & selected.
+	 */
+	if ((nand_curr_device < 0) || (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+	{
+		printf ("Error: "
+			"Invalid NAND device (%d) currently selected\n",
+			nand_curr_device);
+		return (1);		/* NAND device is INVALID */
+	}
+
+	/*
+	 * ensure the Block size agrees with physical NAND device.
+	 */
+	if (ptr->block_size != nand_info[nand_curr_device].erasesize)
+	{
+		printf ("Error: "
+			"Block Size (%uKiB) does not agree with physical NAND (%uKiB)\n",
+			ptr->block_size >> 10,
+			nand_info[nand_curr_device].erasesize >> 10);
+		return (1);		/* Block Size does NOT AGREE */
+	}
+
+	/*
+	 * test to see if physical block #0 is tagged as being "BAD"
+	 */
+	if (ptr->array[0])
+	{
+		printf ("Warning: "
+			"Block #0 is marked as being BAD - are you sure?\n");
+	}
+
+	return (0);			/* image is okay */
+}
+
+
+static int do_info(const ulong addr)
+{
+	const skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	size_t i;
+	size_t skipped;
+
+	if (check_skip_bb(addr))	/* is image invalid ? */
+		return (1);		/* bad image */
+
+	printf( "info: The skip_bb structure at 0x%x looks okay,\n"
+		"info: There is space for %u bad blocks (each of %u KiB).\n",
+		addr + NAND_BB_SKIP_OFFSET,
+		ptr->num_blocks,
+		ptr->block_size >> 10);
+
+	/* how many blocks are to be skipped ? */
+	for(i=skipped=0; i<ptr->num_blocks; i++)
+	{
+		if (ptr->array[i])
+			skipped++;
+	}
+
+	if (skipped == 0)
+	{
+		printf("info: There are NO blocks marked to be skipped\n");
+	}
+	else
+	{
+		printf("info: There are %u blocks marked to be skipped:\n",
+			skipped);
+		for(i=0; i<ptr->num_blocks; i++)
+		{
+			if (ptr->array[i])
+			{
+				printf("\tblock #%u is marked to be skipped (at 0x%x)\n",
+				i,
+				i*ptr->block_size);
+			}
+		}
+	}
+
+	return (0);			/* okay */
+}
+
+
+static int do_copy(const ulong addr)
+{
+	skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	ulong start;
+	size_t i;
+
+	if (check_skip_bb(addr))	/* is image invalid ? */
+		return (1);		/* bad image */
+
+	for(i=start=0; i<ptr->num_blocks; i++,start+=ptr->block_size)
+	{
+		ulong read;
+		nand_info_t * const nand = &nand_info[nand_curr_device];
+		const ulong skip = nand_block_isbad(nand, start) ? 1 : 0;
+		if (skip)	/* do we skip it ? */
+		{
+			printf( "info: "
+				"tagging block #%u as bad (at 0x%x)\n",
+				i,
+				start);
+		}
+
+		/* update the array in the skip_bb structure */
+		*(volatile ulong*)(&ptr->array[i]) = skip;
+
+		/* did we succeed ? */
+		read = *(volatile ulong*)(&ptr->array[i]);
+		if (read != skip)
+		{
+			printf( "Error: "
+				"For block #%u, poke to 0x%08x failed! (%u != %u)\n",
+				i,
+				&ptr->array[i],
+				skip,
+				read);
+			return (1);		/* poke FAILED */
+		}
+	}
+
+	return (0);			/* okay */
+}
+
+
+extern int do_copybbt (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	if ( (argc==3) && (strcmp (argv[1], "info")==0))
+	{
+		const ulong addr = simple_strtoul (argv[2], NULL, 16);
+		return do_info(addr);
+	}
+	else if ( (argc==3) && (strcmp (argv[1], "copy")==0))
+	{
+		const ulong addr = simple_strtoul (argv[2], NULL, 16);
+		return do_copy(addr);
+	}
+	else
+	{
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return (1);		/* bad command usage */
+	}
+
+	return (0);
+}
+
+
+U_BOOT_CMD(
+	copybbt, 3, 0, do_copybbt,
+	"copybbt - copies abridged version of NAND BBT\n",
+	"info [addr] - shows status of copied BBT in RAM\n"
+	"copybbt copy [addr] - copies BBT into RAM copy of u-boot.bin\n"
+	"\t\t      this may be done prior to burning to NAND\n"
+);
+
+
+#endif /* CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+
+
diff --git a/cpu/sh/config.mk b/cpu/sh/config.mk
index 5cc8f25..2589ae2 100644
--- a/cpu/sh/config.mk
+++ b/cpu/sh/config.mk
@@ -2,6 +2,9 @@
 # (C) Copyright 2003
 # Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
 #
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -21,4 +24,10 @@
 # MA 02111-1307 USA
 #
 
-PLATFORM_CPPFLAGS += -m4 -m4-nofpu -U__sh3__
+### old:  PLATFORM_CPPFLAGS += -m4 -m4-nofpu -U__sh3__
+### want: PLATFORM_CPPFLAGS += -m4 -mno-implicit-fp
+PLATFORM_CPPFLAGS += -m4-nofpu -U__sh3__ -D__SH4__=1
+
+# all SH (ST40) CPUs will use the same linker script file
+LDSCRIPT := $(TOPDIR)/cpu/$(CPU)/u-boot.lds
+
diff --git a/cpu/sh/env_eeprom.c b/cpu/sh/env_eeprom.c
new file mode 100644
index 0000000..eda86ba
--- /dev/null
+++ b/cpu/sh/env_eeprom.c
@@ -0,0 +1,270 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * (C) Copyright 2009 STMicroelectronics Ltd.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/*
+ * NOTE: For the ST40 series of SoCs, we use the "eeprom" set of
+ * commands to access SPI serial flash memory devices.
+ *
+ * Hence we need to define CFG_ENV_IS_IN_EEPROM is we want the
+ * environment stored in SPI serial flash.
+ *
+ * This file allows us to store U-boot's environment in SPI
+ * serial flash, and boot from SPI using the SPIBOOT mode
+ * controller in the STMicroelectronics' EMI.
+ *
+ * Sometimes (during initialization) we access the SPI via the
+ * SPIBOOT mode controller, other times (post-initialization)
+ * we access the SPI serial flash via the SSC (or PIOs).
+ * This file tries to take care of dealing with the
+ * duality aspects of all this.
+ *
+ * If CFG_BOOT_FROM_SPI is defined, then we assume we are booting
+ * from SPI serial flash, using the SoC's SPIBOOT mode, to re-map
+ * the serial flash to 0xA0000000 in the EMI space. Otherwise,
+ * we assume we are *not* booting using the SoC's SPIBOOT mode,
+ * in which case we need to use either the SSC or PIO to talk
+ * to the SPI serial flash.
+ * The main difference in usage, is the environment variables
+ * will always be honoured if CFG_BOOT_FROM_SPI is defined,
+ * whereas, if CFG_BOOT_FROM_SPI is not defined, then
+ * the environment variables will only be honoured *after* the
+ * SPI has been initialized (i.e. after serial initialization).
+ * Hence, "baudrate" may not be honoured if the environment is
+ * stored in SPI, unless CFG_BOOT_FROM_SPI is also defined.
+ */
+
+#if defined(CFG_ENV_IS_IN_EEPROM)
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+env_t *env_ptr = NULL;
+
+char * env_name_spec = "SPI Serial Flash";
+
+extern uchar (*env_get_char)(int);
+extern uchar env_get_char_memory (int index);
+
+
+#if defined(CFG_BOOT_FROM_SPI)
+	/*
+	 * The following function will read a 32-bit value
+	 * from the serial flash, via the SPIBOOT controller,
+	 * whilst in SPI Boot mode.
+	 */
+static inline u32 spiboot_get_u32(const int index)
+{
+	return *(u32*)(CFG_EMI_SPI_BASE + index);
+}
+
+
+	/*
+	 * The following function will read a byte
+	 * from the serial flash, via the SPIBOOT
+	 * controller, whilst in SPI boot mode.
+	 * NOTE: we *need* to perform a 4-byte read, and only
+	 * extract the one byte we are really interested in.
+	 */
+static inline uchar spiboot_get_byte(const int index)
+{
+	const u32 word = spiboot_get_u32(index & ~0x3u);
+	return ( ( word >> (index%4)*8 ) & 0xffu );
+}
+
+
+/************************************************************************
+ * Initialize Environment use
+ *
+ * Note: as we are using SPIBOOT mode to read the serial flash,
+ * then we need to perform 32-bit accesses only. Hence, we loop
+ * whilst reading 4-bytes into 'buf' and then update the CRC.
+ */
+extern int env_init(void)
+{
+	ulong crc, len, new;
+	unsigned off;
+	uchar buf[4];		/* only do 32-bits per iteration */
+
+	/* read old CRC (from flash) */
+	crc = spiboot_get_u32(CFG_ENV_OFFSET + offsetof(env_t,crc));
+
+	/* compute current CRC */
+	new = 0;
+	len = ENV_SIZE;
+	off = CFG_ENV_OFFSET + offsetof(env_t,data);
+	while (len > 0)
+	{
+		int n = (len > sizeof(buf)) ? sizeof(buf) : len;
+		*(ulong*)buf = spiboot_get_u32(off);
+		new = crc32 (new, buf, n);
+		len -= n;
+		off += n;
+	}
+
+	/* is the flash environment good ? */
+	if (crc == new)
+	{
+		gd->env_addr  = CFG_ENV_OFFSET + offsetof(env_t,data);
+		gd->env_valid = 1;
+	}
+	else
+	{
+		gd->env_addr  = 0;
+		gd->env_valid = 0;
+	}
+
+	return (0);
+}
+#endif	/* CFG_BOOT_FROM_SPI */
+
+
+/************************************************************************
+ * Initialize Environment use
+ *
+ * Note: for this case, we are storing the environment
+ * in SPI serial flash - but we are *not* booting from SPI
+ * serial flash, so we can not obtain the proper environment
+ * until we have probed for the SPI serial flash - which we do later.
+ * So, we initially just "fake" the environment by pretending
+ * that there is not one!
+ */
+#if !defined(CFG_BOOT_FROM_SPI)
+extern int env_init(void)
+{
+	gd->env_addr  = 0;
+	gd->env_valid = 0;	/* no valid environment */
+
+	return (0);
+}
+
+/*
+ * The following function is performed to initialize
+ * the environment *after* the SPI driver has been
+ * initialized.
+ */
+extern int env_init_after_spi_done(void)
+{
+	ulong crc, len, new;
+	unsigned off;
+	uchar buf[64];
+
+	/* read old CRC */
+	eeprom_read (CFG_DEF_EEPROM_ADDR,
+		     CFG_ENV_OFFSET+offsetof(env_t,crc),
+		     (uchar *)&crc, sizeof(ulong));
+
+	new = 0;
+	len = ENV_SIZE;
+	off = offsetof(env_t,data);
+	while (len > 0) {
+		int n = (len > sizeof(buf)) ? sizeof(buf) : len;
+
+		eeprom_read (CFG_DEF_EEPROM_ADDR, CFG_ENV_OFFSET+off, buf, n);
+		new = crc32 (new, buf, n);
+		len -= n;
+		off += n;
+	}
+
+	if (crc == new) {
+		gd->env_addr  = offsetof(env_t,data);
+		gd->env_valid = 1;
+	} else {
+		gd->env_addr  = 0;
+		gd->env_valid = 0;
+	}
+
+	return (0);
+}
+#endif	/* !CFG_BOOT_FROM_SPI */
+
+
+extern uchar env_get_char_spec (int index)
+{
+	uchar c;
+
+#if defined(CFG_BOOT_FROM_SPI)
+	if ( (env_ptr==NULL) ||
+	     (gd->env_addr != (ulong)&(env_ptr->data)) )
+	{
+		/*
+		 * Not relocated the environment yet.
+		 * So the SPI is not yet initialized, so use the SPI-BOOT
+		 * controller to read the environment directly via the EMI.
+		 */
+		c = spiboot_get_byte(CFG_ENV_OFFSET + index);
+	}
+	else
+#endif	/* CFG_BOOT_FROM_SPI */
+	{
+		/*
+		 * Serial flash accessible via SSC or PIO, so
+		 * we can need to use the 'normal' SPI interfaces
+		 * to talk to the SPI serial flash device.
+		 */
+		eeprom_read (CFG_DEF_EEPROM_ADDR,
+			     CFG_ENV_OFFSET+index+offsetof(env_t,data),
+			     &c, 1);
+	}
+
+	return (c);
+}
+
+
+extern void env_relocate_spec (void)
+{
+#if defined(CFG_BOOT_FROM_SPI)
+	const uchar * const from = (uchar*)(CFG_EMI_SPI_BASE + CFG_ENV_OFFSET);
+	memcpy( (uchar*)env_ptr, from, CFG_ENV_SIZE);
+#else
+	eeprom_read (
+		CFG_DEF_EEPROM_ADDR,
+		CFG_ENV_OFFSET,
+		(uchar *)env_ptr,
+		CFG_ENV_SIZE);
+#endif	/* CFG_BOOT_FROM_SPI */
+}
+
+
+extern int saveenv(void)
+{
+	return eeprom_write (CFG_DEF_EEPROM_ADDR,
+			     CFG_ENV_OFFSET,
+			     (uchar *)env_ptr,
+			     CFG_ENV_SIZE);
+}
+
+
+#endif	/* CFG_ENV_IS_IN_EEPROM */
+
+
diff --git a/cpu/sh/init_ram.S b/cpu/sh/init_ram.S
index 50318b3..ccd6d50 100644
--- a/cpu/sh/init_ram.S
+++ b/cpu/sh/init_ram.S
@@ -1,8 +1,9 @@
 /*
- * (C) Copyright 2004-2007 STMicroelectronics.
+ * (C) Copyright 2004-2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
  * Start Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -34,6 +35,8 @@
  *	This code expects to be run with the caches enabled.
  */
 
+	.section .text.init, "ax"
+
 ENTRY(init_ram)
 	/* Stash the pr somewhere safe */
 	sts	pr, r14
diff --git a/cpu/sh/sata-init.c b/cpu/sh/sata-init.c
new file mode 100644
index 0000000..4530e53
--- /dev/null
+++ b/cpu/sh/sata-init.c
@@ -0,0 +1,366 @@
+/*
+ * STM SATA initialization
+ *
+ * Copyright (C) 2007,2009 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file is based on "arch/sh/kernel/cpu/sh4/sata-init.c"
+ * in STMicroelectronics' release "stm23_0119" of the linux kernel.
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_SH_STM_SATA)
+
+
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+
+
+#if defined(CONFIG_SH_STX7105)		/* Cut 3.x (or later) */
+#define SYS_STA00	STX7105_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7105_SYSCONF_SYS_CFG33
+#elif defined(CONFIG_SH_STX7141)	/* Cut 2.x (or later) */
+#define SYS_STA00	STX7141_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7141_SYSCONF_SYS_CFG33
+#elif defined(CONFIG_SH_STX7200)	/* Cut 3.x (or later) */
+#define SYS_STA00	STX7200_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7200_SYSCONF_SYS_CFG33
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+/* sysconf status 0 */
+#define sata_tdo	(1<<1)
+
+/* sysconf config 33 */
+#define soft_jtag_en	(1<<6)
+#define tms_sata_en	(1<<5)
+#define trstn_sata	(1<<4)
+#define tdi_high	(1<<1)
+#define tdi_low		(0<<1)
+#define tck_high	(1<<0)
+#define tck_low		(0<<0)
+
+
+/*
+ * to minimize (future) maintenance with the linux sources,
+ * we "fake" the sysconf_field struct.
+ */
+typedef int sysconf_field;
+
+/* when reading, only interested in SYS_STA00[2:0] */
+#define sysconf_read(sc)	((readl((sc))) & 0x07)
+
+/* when writing, only interested in SYS_CFG33[6:0] */
+#define sysconf_write(sc, val)	\
+	do { writel((((readl(sc))&(~0x7F))|(val)),(sc)); } while (0)
+
+
+static void SATA_JTAG_IR_Select_MIPHY(
+	const sysconf_field sc)
+{
+	/* Flush trst synchronizer with two tck clocks */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Set tap into idle state */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Set tap into shift ir state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in MacroMicroBusAccess TDI = 101 */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_low | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_low | tck_high);
+
+	/* Set tap into idle mode */
+	sysconf_write(sc,
+		      soft_jtag_en | tms_sata_en | trstn_sata | tdi_high |
+		      tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+}
+
+static void SATA_JTAG_DR_Write_MIPHY(
+	const sysconf_field sc,
+	const u8 regno,
+	const u8 data)
+{
+	int k;
+	u8 x;
+
+	/* Set TAP into shift dr state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in DR=[17:10]=data;[9:2]address=regno;[1]rd=0;[0]wr=1  */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Push in the register address */
+	for (k = 0; k < 8; k++) {
+		x = ((regno >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Push in the data to be written */
+	x = 0;
+	for (k = 0; k < 7; k++) {
+		x = ((data >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Set TAP back round into SHIFT DR STATE
+	 * (exit1_dr,update_dr,idle,idle,select_dr,capture_dr) */
+	x = ((data >> 7) & 0x1);
+	x = x << 1;
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | x | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | x | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/*Set TAP into idle mode */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+}
+
+static u32 SATA_JTAG_DR_Read_MIPHY(
+	const sysconf_field sc,
+	const sysconf_field status_sc,
+	const u8 regno)
+{
+	int k;
+	u8 x;
+	u32 ctrlbit, regvalue = 0;
+
+	/* Set TAP into shift DR state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in DR=[17:10]dummy_data;[9:2]address=regno;[1]rd=1;[0]wr=0  */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+
+	/*  push in the register address */
+	for (k = 0; k < 8; k++) {
+		x = ((regno >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Push in 0 in the data field */
+	for (k = 0; k < 7; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	}
+
+	/* Set TAP back round into SHIFT DR STATE
+	 * (exit1_dr,update_dr,idle,idle,select_dr,capture_dr) */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift out the MIPHY register contents */
+
+	/* Discard first 10 bits */
+	for (k = 0; k < 10; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	}
+
+	for (k = 0; k < 7; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+		ctrlbit = sysconf_read(status_sc);
+		ctrlbit = ctrlbit & sata_tdo;
+		ctrlbit = ctrlbit >> 1;
+		regvalue = ((ctrlbit & 0x1) << k) | regvalue;
+	}
+
+	/* Set TAP into idle mode */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	ctrlbit = sysconf_read(status_sc);
+	ctrlbit = ctrlbit & sata_tdo;
+	ctrlbit = ctrlbit >> 1;
+	regvalue = ((ctrlbit & 0x1) << 7) | regvalue;
+
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	return (regvalue);
+}
+
+extern void stm_sata_miphy_init(void)
+{
+	const sysconf_field sc        = (sysconf_field)SYS_CFG33;	/* SYS_CFG33[6:0] */
+	const sysconf_field status_sc = (sysconf_field)SYS_STA00;	/* SYS_STA00[2:0] */
+
+	SATA_JTAG_IR_Select_MIPHY(sc);
+
+	/* Force Macro1 in reset and request PLL calibration reset */
+
+	/* Force PLL calibration reset, PLL reset and assert
+	 * Deserializer Reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x16);
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x11, 0x0);
+	/* Force macro1 to use rx_lspd, tx_lspd (by default rx_lspd
+	 * and tx_lspd set for Gen1)  */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x10, 0x1);
+
+	/* Force Recovered clock on first I-DLL phase & all
+	 * Deserializers in HP mode */
+
+	/* Force Rx_Clock on first I-DLL phase on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x72, 0x40);
+	/* Force Des in HP mode on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x12, 0x00);
+
+	/* Wait for HFC_READY = 0 */
+	while (SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x1) & 0x3)
+		;
+
+	/* Restart properly Process compensation & PLL Calibration */
+
+	/* Set properly comsr definition for 30 MHz ref clock */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x41, 0x1E);
+	/* comsr compensation reference */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x42, 0x33);
+	/* Set properly comsr definition for 30 MHz ref clock */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x41, 0x1E);
+	/* comsr cal gives more suitable results in fast PVT for comsr
+	   used by TX buffer to build slopes making TX rise/fall fall
+	   times. */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x42, 0x33);
+	/* Force VCO current to value defined by address 0x5A */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x51, 0x2);
+	/* Force VCO current to value defined by address 0x5A */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x5A, 0xF);
+	/* Enable auto load compensation for pll_i_bias */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x47, 0x2A);
+	/* Force restart compensation and enable auto load for
+	 * Comzc_Tx, Comzc_Rx & Comsr on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x40, 0x13);
+
+	/* Wait for comzc & comsr done */
+	while ((SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x40) & 0xC) != 0xC)
+		;
+
+	/* Recommended settings for swing & slew rate FOR SATA GEN 1
+	 * from CPG */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x20, 0x00);
+	/* (Tx Swing target 500-550mV peak-to-peak diff) */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x21, 0x2);
+	/* (Tx Slew target120-140 ps rising/falling time) */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x22, 0x4);
+
+	/* Force Macro1 in partial mode & release pll cal reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x10);
+	udelay(10);
+
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x50, 0x8D);
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x50, 0x8D);
+
+	/*  Wait for phy_ready */
+	/*  When phy is in ready state ( register 0x01 of macro1 to 0x13) */
+	while ((SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x01) & 0x03) != 0x03)
+		;
+
+	/* Enable macro1 to use rx_lspd  & tx_lspd from link interface */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x10, 0x00);
+	/* Release Rx_Clock on first I-DLL phase on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x72, 0x00);
+
+	/* Deassert deserializer reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x00);
+	/* des_bit_lock_en is set */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x02, 0x08);
+
+	/* bit lock detection strength */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x86, 0x61);
+}
+
+
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/sata-probe.c b/cpu/sh/sata-probe.c
new file mode 100644
index 0000000..67be239
--- /dev/null
+++ b/cpu/sh/sata-probe.c
@@ -0,0 +1,171 @@
+/*
+ * STM SATA initialization
+ *
+ * Copyright (C) 2005-2009 STMicroelectronics Limited
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file is based on "drivers/ata/sata_stm.c"
+ * in STMicroelectronics' release "stm23_0119" of the linux kernel.
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_SH_STM_SATA)
+
+
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+
+
+#if defined(CONFIG_SH_STX7105)		/* Cut 3.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7105.c */
+#elif defined(CONFIG_SH_STX7141)	/* Cut 2.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7141.c */
+#elif defined(CONFIG_SH_STX7200)	/* Cut 3.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7200.c */
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+/*
+ * Bases addresses of the SATA component blocks:
+ *	Wrapper registers		0x000 - 0x3FF
+ *	DMA Controller registers	0x400 - 0x7FF
+ *	SATA Host Controller		0x800 - 0xBFF
+ */
+#define SATA_BASE_ADDR				(CFG_ATA_BASE_ADDR & ~0xfff)	/* 4K aligned */
+#define SATA_AHB2STBUS_BASE			(SATA_BASE_ADDR + 0x000)
+#define SATA_AHBDMA_BASE			(SATA_BASE_ADDR + 0x400)
+#define SATA_AHBHOST_BASE			(SATA_BASE_ADDR + 0x800)
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x00c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x018)
+
+/* AHB host controller */
+#define SATA_CDR0				(SATA_AHBHOST_BASE + 0x000)
+#define SATA_CDR1				(SATA_AHBHOST_BASE + 0x004)
+#define SATA_CDR2				(SATA_AHBHOST_BASE + 0x008)
+#define SATA_CDR3				(SATA_AHBHOST_BASE + 0x00c)
+#define SATA_CDR4				(SATA_AHBHOST_BASE + 0x010)
+#define SATA_CDR5				(SATA_AHBHOST_BASE + 0x014)
+#define SATA_CDR6				(SATA_AHBHOST_BASE + 0x018)
+#define SATA_CDR7				(SATA_AHBHOST_BASE + 0x01c)
+#define SATA_CLR0				(SATA_AHBHOST_BASE + 0x020)
+#define SATA_SCR0				(SATA_AHBHOST_BASE + 0x024)
+#define SATA_SCR1				(SATA_AHBHOST_BASE + 0x028)
+#define SATA_SCR2				(SATA_AHBHOST_BASE + 0x02c)
+#define SATA_SCR3				(SATA_AHBHOST_BASE + 0x030)
+#define SATA_SCR4				(SATA_AHBHOST_BASE + 0x034)
+#define SATA_DMACR				(SATA_AHBHOST_BASE + 0x070)
+#define SATA_DBTSR				(SATA_AHBHOST_BASE + 0x074)
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x088)
+#define SATA_VERSIONR				(SATA_AHBHOST_BASE + 0x0f8)
+
+/* AHB DMA controller */
+#define DMAC_COMP_VERSION			(SATA_AHBDMA_BASE + 0x3fc)
+
+
+
+extern int stm_sata_probe(void)
+{
+	int t, timeout;
+
+	/* AHB bus wrapper setup */
+
+	// SATA_AHB2STBUS_STBUS_OPC
+	// 2:0  -- 100 = Store64/Load64
+	// 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	/* opcode = Load4 |Store4 */
+	writel(3, SATA_AHB2STBUS_STBUS_OPC);
+
+	// SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+	// 3:0  -- 0111 = 128 Packets
+	// 3:0  -- 0110 =  64 Packets
+	/* WAS: Message size = 64 packet when 6 now 3 */
+	writel(3, SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+	// SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+	// 3:0  -- 0110 = 64 Packets
+	// 3:0  -- 0001 =  2 Packets
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(2, SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+        // PC_GLUE_LOGIC
+        // 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+        // 8    -- 1  = Time out enabled
+	// (has bit 8 moved to bit 16 on 7109 cut2?)
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+	if (pc_glue_logic_init)
+	{
+		writel(pc_glue_logic_init, SATA_PC_GLUE_LOGIC);
+	}
+
+	/* Clear initial Serror */
+	writel(-1, SATA_SCR1);
+
+#if 0
+{
+	/*
+	 * Note: for this code to be executed, it is imperative
+	 * that this SATA initialization takes place *AFTER*
+	 * the serial console has been initialized!
+	 */
+	const unsigned sata_rev = readl(SATA_VERSIONR);
+	const unsigned dmac_rev = readl(DMAC_COMP_VERSION);
+
+	printf("info: SATA version %c.%c%c DMA version %c.%c%c\n",
+		(int)(sata_rev >> 24) & 0xff,
+		(int)(sata_rev >> 16) & 0xff,
+		(int)(sata_rev >>  8) & 0xff,
+		(int)(dmac_rev >> 24) & 0xff,
+		(int)(dmac_rev >> 16) & 0xff,
+		(int)(dmac_rev >>  8) & 0xff);
+}
+#endif
+
+	/*
+	 * Now we reset the SATA PHY.
+	 */
+	writel(0x301, SATA_SCR2);	/* issue phy wake/reset */
+	readl(SATA_SCR0);		/* dummy read; flush */
+	udelay(1000);			/* 1 ms  -  a guess */
+	writel(0x300, SATA_SCR2);	/* phy wake/clear reset */
+
+	/* wait for phy to become ready, if necessary */
+	timeout = 25;
+	do
+	{
+		udelay(200000);		/* 200 ms */
+		t = readl(SATA_SCR0);
+		if ((t & 0xf) != 1)
+			break;
+	} while (--timeout);
+
+	/* QQQ: we could now print the link status if we want ... */
+
+	return 0;			/* Okay */
+}
+
+
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/spi.c b/cpu/sh/spi.c
new file mode 100644
index 0000000..969bac7
--- /dev/null
+++ b/cpu/sh/spi.c
@@ -0,0 +1,1023 @@
+/*
+ * (C) Copyright 2007,2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+#include <asm/io.h>
+#include <spi.h>
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI)
+
+
+/**********************************************************************/
+
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+/* SSC Baud Rate Generator Register */
+#define SSC_BRG			0x0000
+
+/* SSC Transmit Buffer Register */
+#define SSC_TBUF		0x0004
+
+/* SSC Receive Buffer Register */
+#define SSC_RBUF		0x0008
+
+/* SSC Control Register */
+#define SSC_CON			0x000C
+#define SSC_CON_HB		(1ul<<4)	/* endianness */
+#define SSC_CON_PH		(1ul<<5)	/* clock phase */
+#define SSC_CON_PO		(1ul<<6)	/* clock polarity */
+#define SSC_CON_SR		(1ul<<7)	/* SSC software reset */
+#define SSC_CON_MS		(1ul<<8)	/* master/slave select */
+#define SSC_CON_EN		(1ul<<9)	/* SSC enable */
+#define SSC_CON_LPB		(1ul<<10)	/* SSC loopback mode */
+#define SSC_CON_TXFIFO		(1ul<<11)	/* transmit-side FIFO */
+#define SSC_CON_RXFIFO		(1ul<<12)	/* receive-side FIFO */
+#define SSC_CON_CLSTRX		(1ul<<13)	/* clock stretch mechanism */
+
+/* SSC Interrupt Enable Register */
+#define SSC_IEN			0x0010
+
+/* SSC Status Register */
+#define SSC_STAT		0x0014
+#define SSC_STAT_RIR		(1ul<<0)	/* receive buffer full flag */
+#define SSC_STAT_TIR		(1ul<<1)	/* transmit buffer empty flag */
+#define SSC_STAT_TE		(1ul<<2)	/* transmit Error flag */
+#define SSC_STAT_RE		(1ul<<3)	/* receive Error flag */
+#define SSC_STAT_PE		(1ul<<4)	/* phase Error flag */
+
+/* SSC I2C Control Register */
+#define SSC_I2C			0x0018
+
+#define SPI_CPHA		0x01		/* clock phase */
+#define SPI_CPOL		0x02		/* clock polarity */
+#define SPI_LSB_FIRST		0x08		/* endianness */
+#define SPI_LOOP		0x20		/* loop-back test mode */
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/**********************************************************************/
+
+
+#define MIN(a,b)	( (a) < (b) ? (a) : (b) )
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+/* For Atmel AT45DB321D Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x3cu		/* Mask Bits [5:2] */
+#define CFG_STM_SPI_DEVICE_VAL	0x34u		/* Binary xx1101xx */
+
+#define OP_READ_STATUS		0xd7u		/* Status Register Read */
+#define OP_READ_DEVID		0x9fu		/* Manufacturer & Device ID Read */
+//#define OP_READ_ARRAY		0xe8u		/* Continuous Array Read */
+//#define OP_READ_ARRAY		0x0bu		/* Continuous Array Read */
+#define OP_READ_ARRAY		0x03u		/* Continuous Array Read */
+#define OP_WRITE_VIA_BUFFER1	0x82u		/* Main Memory Page Program via Buffer 1 */
+#define OP_WRITE_VIA_BUFFER2	0x85u		/* Main Memory Page Program via Buffer 2 */
+#define OP_PAGE_TO_BUFFER1	0x53u		/* Main Memory Page to Buffer 1 Transfer */
+#define OP_PAGE_TO_BUFFER2	0x55u		/* Main Memory Page to Buffer 2 Transfer */
+
+#define SR_READY		(1u<<7)		/* Status Register Read/nBusy bit */
+
+#elif defined(CONFIG_SPI_FLASH_ST)	/******************************/
+
+/* For ST M25Pxx Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x60u		/* Mask Bits [6:5] */
+#define CFG_STM_SPI_DEVICE_VAL	0x00u		/* Binary x00xxxxx */
+
+#define OP_READ_STATUS		0x05u		/* Read Status Register */
+#define OP_WRITE_STATUS		0x01u		/* Write Status Register */
+#define OP_READ_DEVID		0x9fu		/* Read ID */
+#define OP_READ_ARRAY		0x03u		/* Read Data Bytes */
+#define OP_WREN			0x06u		/* Write Enable */
+#define OP_SE			0xD8u		/* Sector Erase */
+#define OP_PP			0x02u		/* Page Program */
+
+#define SR_WIP			(1u<<0)		/* Status Register Write In Progress bit */
+#define SR_BP_MASK		0x1c		/* Block Protect Bits (BP[2:0]) */
+
+#elif defined(CONFIG_SPI_FLASH_MXIC)	/******************************/
+
+/* For Macronix MX25Lxxx Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x00u		/* Mask Bits */
+#define CFG_STM_SPI_DEVICE_VAL	0x00u		/* Binary xxxxxxxx */
+
+#define OP_READ_STATUS		0x05u		/* Read Status Register */
+#define OP_WRITE_STATUS		0x01u		/* Write Status Register */
+#define OP_READ_DEVID		0x9fu		/* Read ID */
+#define OP_READ_ARRAY		0x03u		/* Read Data Bytes */
+#define OP_WREN			0x06u		/* Write Enable */
+#define OP_SE			0x20u		/* Sector Erase */
+#define OP_PP			0x02u		/* Page Program */
+
+#define SR_WIP			(1u<<0)		/* Status Register Write In Progress bit */
+#define SR_BP_MASK		0x3c		/* Block Protect Bits (BP[3:0]) */
+
+#else					/******************************/
+
+#error Please specify which SPI Serial Flash is being used
+
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+
+/**********************************************************************/
+
+
+#define CFG_STM_SPI_SSC_BASE	ST40_SSC0_REGS_BASE	/* SSC #0 */
+static const unsigned long ssc = CFG_STM_SPI_SSC_BASE;	/* SSC base */
+
+#define ssc_write(offset, value)	writel((value), (ssc)+(offset))
+#define ssc_read(offset)		readl((ssc)+(offset))
+
+
+/**********************************************************************/
+
+
+static unsigned pageSize;	/* 256, 512 or 528 bytes per page ? */
+static unsigned eraseSize;	/* smallest supported erase size */
+static unsigned deviceSize;	/* Size of the device in Bytes */
+static const char * deviceName;	/* Name of the device */
+
+
+/**********************************************************************/
+
+
+#if 0
+#define isprint(x)    ( ((x)>=0x20u) && ((x)<0x7fu) )
+static void hexdump(
+	const unsigned char * const data,
+	const unsigned int data_size)
+{
+	const unsigned int wrap = 16;
+	const unsigned int ceiling = ((data_size-1) / wrap + 1) * wrap;
+	unsigned int i, j;
+
+	if (data_size==0)	/* no data ? */
+	{
+		return;		/* do nothing */
+	}
+
+	for(i=0; i<ceiling; i++)
+	{
+			/* print the hexadecimal represenation */
+		printf(i<data_size ? "%02x " : ".. ",
+			data[i]);
+
+			/* now the ASCII representation */
+		if (i%wrap==(wrap-1))
+		{
+			printf("   ");
+			for(j=i+1-wrap; (j<=i)&&(j<data_size);j++)
+			{
+				printf("%c",
+					isprint(data[j]) ? data[j] : '.');
+			}
+			printf("\n");
+		}
+	}
+}
+#endif
+
+
+/**********************************************************************/
+
+
+/*
+ * Transfer (i.e. exchange) one "word" with selected SPI device.
+ * Typically one word is 8-bits (an octet), but it does not need to be,
+ * this function is word-width agnostic - when using the SSC.
+ * However, for PIO bit-banging, then one word is explicitly
+ * unconditionally assumed to be exactly 8-bits in length.
+ *
+ *	input:   "out" is word to be send to slave SPI device
+ *	returns: one word read from the slave SPI device
+ *
+ * It is the caller's responsibility to ensure that the
+ * chip select (SPI_NOTCS) is correctly asserted.
+ */
+static unsigned int spi_xfer_one_word(const unsigned int out)
+{
+	unsigned int in = 0;
+
+#if defined(CONFIG_SOFT_SPI)		/* Use PIO Bit-Banging for SPI */
+	signed int i;
+	for(i=7; i>=0; i--)		/* for each bit in turn ... */
+	{				/* do 8 bits, msb first */
+		SPI_SCL(0);		/* SPI_CLK = low */
+		SPI_SDA(out & (1u<<i));	/* output next bit on SPI_DOUT */
+		SPI_DELAY;		/* clock low cycle */
+
+		SPI_SCL(1);		/* SPI_CLK = high */
+		SPI_DELAY;		/* sample on RISING clock edge */
+
+		in <<= 1;		/* shift */
+		in |= SPI_READ;		/* get next bit from SPI_DIN */
+	}
+#else					/* Use SSC for SPI */
+	/* write out data 'out' */
+	ssc_write(SSC_TBUF, out);
+
+	/* wait for Receive Buffer Full flag to be asserted */
+	while ((ssc_read(SSC_STAT) & SSC_STAT_RIR) == 0)
+	{
+		;	/* busy poll - do nothing */
+	}
+
+	/* read in data */
+	in = ssc_read(SSC_RBUF);
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* return exchanged data */
+	return in;
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * transfer (i.e. exchange) a series of "words" with SPI device.
+ * Typically one word is 8-bits (an octet).
+ * This function is expects a word to be exactly 8-bits.
+ *
+ *	input:   chipsel is pointer to the chip-select function (if !NULL)
+ *		 bitlen number of *bits* (not bytes) to be exchanged
+ *		 dout pointer to array of words to be sent to SPI
+ *		 din pointer to array of words that were read from SPI
+ *	returns: zero on success, else non-zero.
+ *
+ *	Note: 'din' may be NULL if caller does not need to see it.
+ */
+extern int spi_xfer(
+	spi_chipsel_type const chipsel,
+	const int bitlen,
+	uchar * const dout,
+	uchar * const din)
+{
+	size_t i;
+	const int bytelen = bitlen / 8;	/* number of 8-bit bytes */
+
+	/*
+	 * This code assumes that as we are using the SSC, that we will always
+	 * be swapping multiples of *whole* 8-bit bytes between the master
+	 * and the slave device.
+	 * This assumption is strictly unnecessary, as we could re-program
+	 * the SSC to allow any bit-size we want. However, this initial version
+	 * of the code sets the pervading transfers to 8-bits in the SSC.
+	 * So, right now, we just give up if the number of bits is not a
+	 * whole number of (8-bit) bytes - after printing a suitable diagnostic.
+	 */
+	if (bitlen & 0x7)
+	{
+		printf("ERROR: %s() called with non-multiple of octets (%u bits)\n",
+			__FUNCTION__,
+			bitlen);
+		return 1;	/* error status */
+	}
+
+#if 0	/* QQQ - DELETE */
+	hexdump(dout, bytelen);
+#endif	/* QQQ - DELETE */
+
+	if(chipsel)
+	{	/* assert SPI CS */
+		chipsel(1);
+	}
+
+	/* transfer: write bytes in 'dout', and read into 'din' */
+	for(i=0; i<bytelen; i++)
+	{
+		uchar data;
+		data = spi_xfer_one_word(dout[i]);
+		if (din != NULL) din[i] = data;
+	}
+
+	if(chipsel)
+	{	/* de-assert SPI CS */
+		chipsel(0);
+	}
+
+#if 0	/* QQQ - DELETE */
+	if (din != NULL)
+	{
+		hexdump(din, bytelen);
+		printf("\n");
+	}
+#endif	/* QQQ - DELETE */
+
+	return 0;	/* success */
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * read the SPI slave device's "Status Register".
+ *
+ * input:   none
+ * returns: the value of the status register.
+ */
+static unsigned int spi_read_status(
+	spi_chipsel_type const chipsel)
+{
+	unsigned char data[2] = { OP_READ_STATUS, 0x00 };
+
+	/* issue the Status Register Read command */
+	spi_xfer(chipsel, sizeof(data)*8, data, data);
+
+	/* return the status byte read */
+	return data[1];
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * poll the "Status Register" waiting till it is not busy.
+ *
+ * input:   none
+ * returns: none
+ */
+static void spi_wait_till_ready(
+	spi_chipsel_type const chipsel)
+{
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+	while (!(spi_read_status(chipsel) & SR_READY))
+		;	/* do nothing */
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+	while (spi_read_status(chipsel) & SR_WIP)
+		;	/* do nothing */
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * probe the serial flash on the SPI bus, to ensure
+ * it is a known type, and initialize its properties.
+ */
+static int spi_probe_serial_flash(
+	spi_chipsel_type const chipsel)
+{
+	unsigned int status;
+	unsigned char devid[8] = {
+		OP_READ_DEVID,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
+
+	/* read & detect the SPI device type */
+	status = spi_read_status(chipsel);
+	if (
+		(status == 0xffu)	/* nothing talking to us ? */	||
+		( (status & CFG_STM_SPI_DEVICE_MASK) != CFG_STM_SPI_DEVICE_VAL )
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, status = 0x%02x\n",
+			status);
+		return -1;
+	}
+
+	/*
+	 * if we get here, then we think we may have a SPI
+	 * device, so now check it is the correct one!
+	 */
+	spi_xfer(chipsel, sizeof(devid)*8, devid, devid);
+
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+
+	/* extract the page size */
+	if (
+		(devid[1] != 0x1fu)	||	/* Manufacturer ID */
+		(devid[2] != 0x27u)	||	/* Memory Type */
+		(devid[3] != 0x01u)		/* Code + Version */
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize = (status & 1u) ? 512u : 528u;
+	eraseSize = pageSize;
+	deviceSize = 8192u * pageSize;		/* 32 Mbit == 4 MiB */
+	deviceName = "Atmel AT45DB321D";
+
+#elif defined(CONFIG_SPI_FLASH_ST)
+
+	if (
+		(devid[1] != 0x20u)	||	/* Manufacturer ID */
+		(devid[2] != 0x20u)	||	/* Memory Type */
+		(				/* Memory Capacity */
+			(devid[3] != 0x14u) &&	/* M25P80 */
+			(devid[3] != 0x15u) &&	/* M25P16 */
+			(devid[3] != 0x16u) &&	/* M25P32 */
+			(devid[3] != 0x17u) &&	/* M25P64 */
+			(devid[3] != 0x18u)	/* M25P128 */
+		)
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize   = 256u;
+	eraseSize  = 64u<<10;			/* 64 KiB, 256 pages/sector */
+	deviceSize = 1u<<devid[3];		/* Memory Capacity */
+	if (devid[3] == 0x14u)
+	{
+		deviceName = "ST M25P80";	/* 8 Mbit == 1 MiB */
+	}
+	else if (devid[3] == 0x15u)
+	{
+		deviceName = "ST M25P16";	/* 16 Mbit == 2 MiB */
+	}
+	else if (devid[3] == 0x16u)
+	{
+		deviceName = "ST M25P32";	/* 32 Mbit == 4 MiB */
+	}
+	else if (devid[3] == 0x17u)
+	{
+		deviceName = "ST M25P64";	/* 64 Mbit == 8 MiB */
+	}
+	else if (devid[3] == 0x18u)
+	{
+		deviceName = "ST M25P128";	/* 128 Mbit == 16 MiB */
+		eraseSize = 256u<<10;		/* 256 KiB, 1024 pages/sector */
+	}
+
+#elif defined(CONFIG_SPI_FLASH_MXIC)
+
+	if (
+		(devid[1] != 0xc2u)	||	/* Manufacturer ID */
+		(devid[2] != 0x26u)	||	/* Memory Type */
+		(				/* Memory Capacity */
+			(devid[3] != 0x15u) &&	/* MX25L1655D */
+			(devid[3] != 0x17u) &&	/* MX25L6455E */
+			(devid[3] != 0x18u)	/* MX25L12855E */
+		)
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize   = 256u;
+	eraseSize  = 4u<<10;			/* 4 KiB, 16 pages/sector */
+	deviceSize = 1u<<devid[3];		/* Memory Capacity */
+	if (devid[3] == 0x15u)
+	{
+		deviceName = "MXIC MX25L1655D";	/* 16 Mbit == 2 MiB */
+	}
+	else if (devid[3] == 0x17u)
+	{
+		deviceName = "MXIC MX25L6455E";	/* 64 Mbit == 8 MiB */
+	}
+	else if (devid[3] == 0x18u)
+	{
+		deviceName = "MXIC MX25L12855E";/* 128 Mbit == 16 MiB */
+	}
+
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+#if 1
+	/* tell them what we found */
+	printf("info: found %s (%uMiB) device (page=%u,erase=%u)\n",
+		deviceName,
+		deviceSize >> 20,	/* in MiB */
+		pageSize,		/* in bytes */
+		eraseSize);		/* in bytes */
+#endif
+
+#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+	/* is the device in a write protected mode ? */
+	if (status & SR_BP_MASK)	/* BPx != 0 ? */
+	{
+		printf( "warning: "
+			"SPI device may be write-protected (status=0x%02x)\n",
+			status);
+#if 0	/* do we want to un-lock it, if we can ? */
+{
+	unsigned char enable[1] = { OP_WREN };
+	unsigned char unlock[2] = { OP_WRITE_STATUS, 0x00 };
+
+	/* let the user know we are trying to un-lock it */
+	printf("info: unlocking SPI ...\n");
+
+	/* issue a WRITE ENABLE (WREN) command */
+	spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+	/* issue a WRITE Status Register (WRSR) command */
+	spi_xfer(chipsel, sizeof(unlock)*8, unlock, NULL);
+
+	/* give it some time to clear the non-volatile flags */
+	udelay(2 * 1000);	/* 2 ms */
+
+	/* re-read (and display) the updated status register */
+	status = spi_read_status(chipsel);
+	if (status & SR_BP_MASK)	/* BPx != 0 ? */
+	{	/* we MAY have succeeded, but we needed a longer delay! */
+		printf("warning:            ... FAILED! (status=0x%02x)\n",
+			status);
+	}
+	else
+	{	/* the delay was long enough, and we succeeded. */
+		printf("info:               ... succeeded.\n");
+	}
+}
+#endif	/* unlock it */
+	}
+#endif	/* CONFIG_SPI_FLASH_ST || CONFIG_SPI_FLASH_MXIC */
+
+	return 0;
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * initialise the SSC to talk to the slave SPI device.
+ */
+extern void spi_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+	unsigned long reg;
+	const unsigned long bits_per_word = 8;	/* one word == 8-bits */
+	const unsigned long mode = CFG_STM_SPI_MODE /* | SPI_LOOP */;
+	const unsigned long fcomms = gd->bd->bi_emifrq*1000*1000;
+	const unsigned long hz = CFG_STM_SPI_FREQUENCY;
+	      unsigned long sscbrg = fcomms/(2*hz);
+
+#if defined(CONFIG_SH_STX5197)
+	/* configure SSC0 to use the SPI pads (not PIO1[7:6]) */
+	reg = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+	reg |= 1ul<<14;	/* CFG_CTRL_M.SPI_BOOTNOTCOMMS = 1 [14] */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = reg;
+#endif	/* CONFIG_SH_STX5197 */
+
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+	/* program the SSC's Baud-Rate Generator */
+	if ((sscbrg < 0x07u) || (sscbrg > (0x1u << 16)))
+	{
+		printf("ERROR: Unable to set SSC buad-rate generator to 0x%04x\n",
+			sscbrg);
+		return;
+	}
+	/* TODO: program pre-scaler for slower baud rates */
+	if (sscbrg == (0x1 << 16)) /* 16-bit counter wraps */
+	{
+		sscbrg = 0x0;	/* slowest possible clock frequency */
+	}
+	ssc_write(SSC_BRG,sscbrg);
+#if 0	/* QQQ */
+	printf("info: fcomms=%uMHz, SPI=%uHz, brg=0x%04x\n",
+		fcomms/1000/1000, hz, sscbrg);
+#endif
+
+	/* Disable I2C sub-system */
+	ssc_write( SSC_I2C, 0x0);
+
+	/* Perform a S/W reset the SSC */
+	reg = ssc_read( SSC_CON);
+	reg |= SSC_CON_SR;		/* enable software reset */
+	ssc_write( SSC_CON, reg);
+	udelay(1);			/* let reset propagate */
+	reg = ssc_read( SSC_CON);
+	reg &= ~SSC_CON_SR;		/* disable software reset */
+	ssc_write( SSC_CON, reg);
+
+	/* Configure & enable the SSC's control register */
+	reg = ssc_read(SSC_CON);
+	reg |= SSC_CON_EN;		/* Enable the SSC */
+	reg |= SSC_CON_MS;		/* set SSC as the SPI master */
+	if (mode & SPI_CPOL)
+		reg |= SSC_CON_PO;	/* Clock idles at logic 1 */
+	else
+		reg &= ~SSC_CON_PO;	/* Clock idles at logic 0 */
+	if (mode & SPI_CPHA)
+		reg |= SSC_CON_PH;	/* Pulse in first half-cycle */
+	else
+		reg &= ~SSC_CON_PH;	/* Pulse in second half-cycle */
+	if (mode & SPI_LSB_FIRST)
+		reg &= ~SSC_CON_HB;	/* LSB first */
+	else
+		reg |= SSC_CON_HB;	/* MSB first */
+	if (mode & SPI_LOOP)
+		reg |= SSC_CON_LPB;	/* put SSC in loop-back mode */
+	else
+		reg &= ~SSC_CON_LPB;	/* remove SSC from loop-back mode */
+	reg &= ~0x0ful;			/* set bit width */
+	reg |= (bits_per_word - 1ul);	/* set bit width */
+	ssc_write(SSC_CON,reg);
+
+	/* clear the status register */
+	(void)ssc_read(SSC_RBUF);
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* now probe the serial flash, to ensure it is the correct one */
+	spi_probe_serial_flash(chipsel);
+}
+
+
+/**********************************************************************/
+
+
+extern void spi_init_f (void) { }
+extern void spi_init_r (void) { }
+
+
+/**********************************************************************/
+
+
+static unsigned long get_binary_offset(const uchar * addr, int alen)
+{
+	unsigned long offset = 0;
+
+	for(;alen>0;--alen)
+	{
+		offset <<= 8;
+		offset |= *addr++;
+	}
+
+	return offset;
+}
+
+
+/**********************************************************************/
+
+
+static unsigned long get_dataflash_offset(const unsigned long addr)
+{
+	unsigned long offset;
+
+	/* optionally map a 'binary' address to a 'dataflash' address */
+	if (pageSize == 528u)
+	{	/* one page is 528 (0x210) bytes */
+		const unsigned long page = addr / pageSize;
+		const unsigned long byte = addr % pageSize;
+		offset = (page << 10) | (byte);
+	}
+	else
+	{	/* no special mapping needed */
+		offset = addr;
+	}
+
+	return offset;
+}
+
+
+/**********************************************************************/
+
+
+extern ssize_t spi_read (
+	uchar * const addr,
+	const int alen,
+	uchar * const buffer,
+	const int len)
+{
+	int i;
+	const unsigned long start = get_binary_offset(addr,alen);
+	const unsigned long offset = get_dataflash_offset(start);
+	const unsigned long last   = start + len - 1ul;
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+	if (len < 1) return len;
+	if (last >= deviceSize)	/* Out of range ? */
+	{
+		printf("ERROR: Offset out of range (max=0x%lx)\n",
+			deviceSize-1ul);
+		return 0;
+	}
+
+	/* assert SPI CS */
+	(*chipsel)(1);
+
+	/* issue appropriate READ array command */
+	spi_xfer_one_word(OP_READ_ARRAY);
+
+	/* write the 24-bit address to start reading from */
+	spi_xfer_one_word( (offset>>16) & 0xffu );
+	spi_xfer_one_word( (offset>>8)  & 0xffu );
+	spi_xfer_one_word( (offset>>0)  & 0xffu );
+
+#if (OP_READ_ARRAY==0xe8u)	/* Legacy command needs 4 dummy bytes */
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+#elif (OP_READ_ARRAY==0x0bu)	/* High-Speed command needs 1 dummy byte */
+	spi_xfer_one_word(0x00);
+#endif
+
+	/* now read in each byte in turn, and put it in "buffer" */
+	for(i=0; i<len; i++)
+	{
+		buffer[i] = spi_xfer_one_word(0x00);
+	}
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+	return len;
+}
+
+
+/**********************************************************************/
+
+
+static void my_spi_write(
+	spi_chipsel_type const chipsel,
+	const unsigned long address,
+	const uchar * const buffer,
+	unsigned long len)
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+{
+	const unsigned long offset = get_dataflash_offset(address);
+	size_t i;
+
+#if 0	/* QQQ - DELETE */
+	printf("%s():\t buffer=0x%08x, len=%-3u  0x%06x..0x%06x\n",
+		__FUNCTION__, buffer, len, address, address+len-1u);
+#endif	/* QQQ - DELETE */
+
+	if (len != pageSize)	/* partial page update ? */
+	{
+		/*
+		 * Need to read, merge, erase & write one page.
+		 * That is, we copy the whole page into one
+		 * of the serial-flash buffers, and then just over-write
+		 * with the new data to be updated (in 'buffer'). Then
+		 * we erase & write back the whole (merged) page.
+		 */
+
+		unsigned char transfer[4] = {
+			OP_PAGE_TO_BUFFER1,
+			(offset>>16) & 0xffu,
+			(offset>>8)  & 0xffu,
+			(offset>>0)  & 0xffu,
+		};
+
+		/* copy page (to be updated) in serial flash into buffer #1 */
+		spi_xfer(chipsel, sizeof(transfer)*8, transfer, NULL);
+
+		/* now wait until the transfer has completed ... */
+		spi_wait_till_ready(chipsel);
+	}
+
+	/* assert SPI CS */
+	(*chipsel)(1);
+
+	/* issue appropriate WRITE command */
+	spi_xfer_one_word(OP_WRITE_VIA_BUFFER1);
+
+	/* write the 24-bit address to start writing to */
+	spi_xfer_one_word( (offset>>16) & 0xffu );
+	spi_xfer_one_word( (offset>>8)  & 0xffu );
+	spi_xfer_one_word( (offset>>0)  & 0xffu );
+
+	/* now write in each byte in turn */
+	for(i=0; i<len; i++)
+	{
+		spi_xfer_one_word(buffer[i]);
+	}
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+	/* now wait until the programming has completed ... */
+	spi_wait_till_ready(chipsel);
+}
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+{
+	const unsigned pages       = eraseSize / pageSize;
+	const unsigned long sector = (address / eraseSize) * eraseSize;
+	unsigned long page_base;
+	size_t i;
+	unsigned page;
+	const uchar * ptr;
+#if defined(CONFIG_SPI_FLASH_ST)
+	unsigned char buff[256<<10];	/* maximum of 256 KiB erase size */
+#elif defined(CONFIG_SPI_FLASH_MXIC)
+	unsigned char buff[4<<10];	/* maximum of 4 KiB erase size */
+#endif
+	unsigned char enable[1] = { OP_WREN };
+	unsigned char erase[4] = {
+		OP_SE,
+		(sector>>16) & 0xffu,
+		(sector>>8)  & 0xffu,
+		(sector>>0)  & 0xffu,
+	};
+
+#if 0	/* QQQ - DELETE */
+	printf("%s():\t buffer=0x%08x, len=%-5u  0x%06x..0x%06x\n",
+		__FUNCTION__, buffer, len, address, address+len-1u);
+#endif	/* QQQ - DELETE */
+
+	if (len != eraseSize)	/* partial sector update ? */
+	{
+		/*
+		 * Need to read, merge, erase & write one sector.
+		 * That is, we copy the whole sector from
+		 * the serial-flash into RAM, and then just over-write
+		 * with the new data to be updated (in 'buffer'). Then
+		 * we erase & write back the whole (merged) sector.
+		 */
+		unsigned char addr[3] = {
+			(sector>>16) & 0xffu,
+			(sector>>8)  & 0xffu,
+			(sector>>0)  & 0xffu,
+		};
+		const unsigned long offset = address - sector;
+
+		/* read the entire extant sector's content into RAM */
+		spi_read ( addr, sizeof(addr), buff, eraseSize );
+
+		/* now merge the old with the new data */
+		for( i=0; i<len; i++)
+		{
+			buff[offset+i] = buffer[i];
+		}
+		ptr = buff;	/* use "merged" buffer */
+	}
+	else
+	{
+		ptr = buffer;	/* use original buffer */
+	}
+
+	/* issue a WRITE ENABLE (WREN) command */
+	spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+	/* issue a Sector Erase command */
+	spi_xfer(chipsel, sizeof(erase)*8, erase, NULL);
+
+	/* now wait until the erase has completed ... */
+	spi_wait_till_ready(chipsel);
+
+	/* now program each page in turn ... */
+	for (page_base=sector,page=0u; page<pages; page++)
+	{
+		/* issue a WRITE ENABLE (WREN) command */
+		spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+		/* assert SPI CS */
+		(*chipsel)(1);
+
+		/* issue a Page Program command */
+		spi_xfer_one_word(OP_PP);
+
+		/* write the 24-bit address to start writing to */
+		spi_xfer_one_word( (page_base>>16) & 0xffu );
+		spi_xfer_one_word( (page_base>>8)  & 0xffu );
+		spi_xfer_one_word( (page_base>>0)  & 0xffu );
+
+		/* now write in each byte in turn */
+		for(i=0; i<pageSize; i++)
+		{
+			spi_xfer_one_word(*ptr++);
+		}
+
+		/* de-assert SPI CS */
+		(*chipsel)(0);
+
+		/* now wait until the programming has completed ... */
+		spi_wait_till_ready(chipsel);
+
+		/* advance to next page */
+		page_base += pageSize;
+	}
+}
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+
+/**********************************************************************/
+
+
+extern ssize_t spi_write (
+	uchar * const addr,
+	const int alen,
+	uchar * buffer,
+	const int len)
+{
+	const unsigned long first  = get_binary_offset(addr,alen);
+	const unsigned long last   = first + len - 1ul;
+	const unsigned long lsector= (first + len) / eraseSize;
+	      unsigned long sector = first / eraseSize;
+	const unsigned long byte   = first % eraseSize;
+	      unsigned long ptr    = first;
+	unsigned written = 0;		/* amount written between two dots */
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+	if (len < 1) return len;
+	if (last >= deviceSize)	/* Out of range ? */
+	{
+		printf("ERROR: Offset out of range (max=0x%lx)\n",
+			deviceSize-1ul);
+		return 0;
+	}
+
+	/* process up to end of first erase block */
+	if (byte != 0)
+	{
+		/* till end of first erase block, or entirety, which is less */
+		const unsigned long size = MIN(len,eraseSize-byte);
+		my_spi_write(chipsel, first, buffer, size);
+
+		sector++;
+		ptr += size;
+		buffer += size;
+		written += size;
+	}
+
+	/* process each whole erase block in turn */
+	while(sector<lsector)
+	{
+		/* print a series of dots (every 16KiB) */
+		if ( (written+=eraseSize,written) >= (16u<<10) )
+		{
+			printf(".");	/* print a dot */
+			written = 0;	/* reset counter */
+		}
+
+		/* a whole erase block */
+		my_spi_write(chipsel, ptr, buffer, eraseSize);
+
+		sector++;
+		ptr += eraseSize;
+		buffer += eraseSize;
+
+	}
+	printf("\n");	/* terminate any row of printed dots */
+
+	/* finally, process any data at the tail */
+	if (ptr <= last)
+	{
+		my_spi_write(chipsel, ptr, buffer, last-ptr+1u);
+	}
+
+	return len;
+}
+
+
+/**********************************************************************/
+
+
+#endif	/* defined(CONFIG_SPI) */
+
+
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 590d9db..9918d8e 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -29,21 +29,10 @@
 #include "asm/sh4reg.h"
 #include "asm/asmdefs.h"
 #include "asm/pmb.h"
+#include "asm/socregs.h"
 
-#if defined(CONFIG_SH_STB7100)
-#include <asm/stb7100reg.h>
-#elif defined(CONFIG_SH_STX7105)
-#include <asm/stx7105reg.h>
-#elif defined(CONFIG_SH_STX7111)
-#include <asm/stx7111reg.h>
-#elif defined(CONFIG_SH_STX7141)
-#include <asm/stx7141reg.h>
-#elif defined(CONFIG_SH_STX7200)
-#include <asm/stx7200reg.h>
-#else
-#error Missing Device Definitions!
-#endif
 
+	.section .text.init, "ax"
 
 	.global _start
 _start:
@@ -59,11 +48,6 @@ set_sr:
 	MOV_CONST32_R0 0x400000F0
 	ldc	r0, sr
 
-	/* Set FPSCR:	FR=0, SZ=0, PR=1, DN=0, RM=01 */
-set_fpscr:
-	MOV_CONST32_R0 0x00080001
-	lds	r0, fpscr
-
 	/* disable the watchdog timer */
 disable_watchdog:
 	MOV_CONST32_R0 ST40_CPG_WTCSR
@@ -91,12 +75,80 @@ skip_signature:
 preamble_signature_pattern:
 	bytes 0x00 0x3f			/* 64-bytes: 0x00, 0x01, ..., 0x3f */
 
+#if defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	/*
+	 *	const static struct skip_bb
+	 *	{
+	 *		char	pattern[8];
+	 *		u32	block_size;
+	 *		u32	num_blocks;
+	 *		u32	array[num_blocks];
+	 *	} skip_bb;
+	 *
+	 *	"array[]" is a set of flags, whose value is
+	 *	interpreted as:
+	 *		if array[x] == 0,
+	 *		then physical block #x is GOOD,
+	 *		else physical block #x is BAD.
+	 *	NOTE Physical Block #0 *must* always be GOOD.
+	 *
+	 *	assert( strcmp(pattern,"SKIP_BBs") == 0 );
+	 *	assert( (block_size % (16<<10)) == 0 );
+	 *	assert( sizeof(array) == num_blocks * 4 );
+	 *	assert( array[0] == 0 );
+	 *
+	 *	By default the linker will fill "array[]"
+	 *	with ZEROS (assume all blocks are GOOD).
+	 *	If is the responsibility of the configurer
+	 *	to ensure that "array[]" is big enough.
+	 *	It is the responsibility of the NAND flasher
+	 *	to fill the array appropriately.
+	 */
+skip_bb:			/* the skip_bb structure */
+skip_bb_pattern:		/* 8-byte "magic" pattern */
+	.ascii "SKIP_BBs"
+skip_bb_size:			/* size of each NAND block */
+	.long	CFG_NAND_SKIP_BLOCK_SIZE
+skip_bb_count:			/* number of bad-block entries in array */
+	.long	CFG_NAND_SKIP_BLOCK_COUNT
+skip_bb_array:			/* the array itself (0==GOOD) */
+	.fill CFG_NAND_SKIP_BLOCK_COUNT, 4, 0
+#endif	/* CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+
 skipped_signature:
 					/* resume from here */
 #endif	/* CFG_BOOT_FROM_NAND */
 
 
 	/*
+	 * If were are going to boot U-boot from SPI (serial flash),
+	 * then the following pokes are required/recommended to be
+	 * done early, when using the EMI's SPIBOOT mode controller.
+	 */
+#if defined(CFG_BOOT_FROM_SPI)
+config_spiboot_controller:
+	MOV_CONST32_R0 ST40_EMI_SPI_REGS_BASE
+	mov	r0, r1
+
+	MOV_CONST32_R0 0x00020011	/* *ST40_EMI_SPI_CONFIGDATA = 0x00020010|ST */
+	mov.l	r0, @(ST40_EMI_SPI_CONFIGDATA-ST40_EMI_SPI_REGS_BASE,r1)
+
+#if 1
+	/* For serial flash we use FAST_READ */
+	mov	#2, r0			/* *ST40_EMI_SPI_MODESELECT = FAST_READ */
+#else
+	mov	#3, r0			/* *ST40_EMI_SPI_MODESELECT = CONTIG_MODE|FAST_READ */
+#endif
+	mov.l	r0, @(ST40_EMI_SPI_MODESELECT-ST40_EMI_SPI_REGS_BASE,r1)
+
+	/* Slow (divide) the SPI clock down to improve reliability. */
+	mov	#4, r0			/* *ST40_EMI_SPI_CLOCKDIV = 4 */
+	mov.l	r0, @(ST40_EMI_SPI_CLOCKDIV-ST40_EMI_SPI_REGS_BASE,r1)
+
+#endif	/* CFG_BOOT_FROM_SPI */
+
+
+	/*
 	 * Determine if we are in the correct location ? (i.e. RAM)
 	 *  r8 == 1 in RAM, assume initialization already done by GDB.
 	 *  r8 == 0 in FLASH, need to relocate, set up memory, etc...
@@ -165,6 +217,14 @@ set_pmb:
 	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
 	SH4_SET_PMB 7 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
 	SH4_SET_PMB 8 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+#elif defined(CONFIG_SH_STX5197) && defined(CONFIG_SH_MB704)
+	SH4_SET_PMB 0 0x80 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00 128 0 0 1	/* SPI Flash (in SPIBOOT mode) UN-cached */
+#elif defined(CONFIG_SH_STX5197) && defined(CONFIG_SH_5197CAB)
+	SH4_SET_PMB 0 0x80 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00 128 0 0 1	/* SPI Flash (in SPIBOOT mode) UN-cached */
 #elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_MB680)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
@@ -203,6 +263,13 @@ set_pmb:
 	SH4_SET_PMB 11 0xad 0x05  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 12 0xae 0x06  16		/* NAND + CI CACHED */
 	SH4_SET_PMB 13 0xaf 0x07  16		/* PCI CACHED */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_IPIDTV7105)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
@@ -338,9 +405,21 @@ enable_se_mode:
 .balign 4
 #endif	/* CONFIG_SH_SE_MODE */
 
+
 	/*
-	 * relocate code: r1=source, r2=dest, r3=dest_end
-	 * QQQ: in 32-bit mode, "dest" is UN-cached - should optimize this.
+	 * now relocate "u-boot.bin" (from FLASH to RAM):
+	 *	r0 == scratch/temp
+	 *	r1 == source address (SRC)
+	 *	r2 == destination address (DST)
+	 *	r3 == destination END address
+	 *	r4 == &skip_bb.array[x] (x=block number: 0,1,2,...)
+	 *	r5 == skip_bb.block_size	(CFG_NAND_SKIP_BLOCK_SIZE)
+	 *	r6 == skip_bb.block_size - 1	(block mask)
+	 *
+	 *	NOTE:	r4, r5 & r6 are only used if the the macro
+	 *		CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING is defined.
+	 *
+	 *	QQQ: in 32-bit mode, "DST" is UN-cached - should optimize this.
 	 */
 relocate:
 	mov	#0x1f, r0
@@ -350,7 +429,15 @@ relocate:
 	mov	r10, r2			/* were we WANT to be: START off */
 	and	r0, r2			/* ensure destination is 32-byte cache aligned */
 	mov	r11, r3			/* were we WANT to be: END off */
-1:	mov.l	@(0,r1), r0		/* read & write a line at a time */
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	mov.l	skip_bb_offset, r4	/* r4 = &skip_bb - _start */
+	add	r9, r4			/* r4 = &skip_bb (P0 (cached)) */
+	mov.l	@(8,r4), r5		/* r5 = NAND block_size */
+	mov	r5, r6
+	add	#-1, r6			/* r6 = block_size - 1 (i.e. mask) */
+	add	#16, r4			/* r4 = &array[0]  */
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+1:	mov.l	@(0,r1), r0		/* read & write a cache line at a time */
 	mov.l	r0, @(0,r2)
 	mov.l	@(4,r1), r0
 	mov.l	r0, @(4,r2)
@@ -367,12 +454,28 @@ relocate:
 	mov.l	@(28,r1), r0
 	mov.l	r0, @(28,r2)
 	ocbp	@r2			/* flush one line */
-	add	#32, r1			/* next line */
+	add	#32, r1			/* next source line */
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	mov	r1, r0			/* test for a new block */
+	and	r6, r0			/* r0 = SRC & (block_size - 1) */
+	cmp/eq	#0, r0			/* is it a new block ? */
+	bf	do_next_line		/* branch if it is the same block */
+do_next_block:				/* okay, we are on a new NAND block */
+	add	#4, r4
+	mov.l	@r4, r0			/* r0 = array[++x] */
+	cmp/eq	#0, r0			/* is it a GOOD block ? */
+	bt	do_next_line		/* branch if it is a GOOD block */
+					/* okay, we have a BAD block, try NEXT */
+	bra	do_next_block		/* check it is good as well! */
+	  add	r5, r1			/* SRC += block_size */
+do_next_line:
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
 	pref	@r1			/* pre-fetch next line */
 	add	#32, r2			/* next line */
 	cmp/hi	r2, r3			/* while (r2<=r3) ... */
 	bt	1b
 
+
 	/*
 	 * now jump to absolute (non-PIC) address environment.
 	 */
@@ -396,7 +499,7 @@ do_enable_pmb_cache:
 #endif	/* CONFIG_SH_SE_MODE */
 
 	/* init stack pointer */
-init_sp:	
+init_sp:
 	mov.l	stack_addr, sp
 
 	/* Clear the bss */
@@ -426,6 +529,9 @@ stack_addr:	.long TEXT_BASE - (CFG_GBL_DATA_SIZE + CFG_MALLOC_LEN + CFG_BOOTPARA
 bss_start:	.long __bss_start
 bss_end:	.long __bss_end
 hyperspace_addr:.long hyperspace
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+skip_bb_offset:	.long skip_bb - _start
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
 
 start_sh4boot_addr:.long start_sh4boot
 
@@ -438,3 +544,16 @@ sh_cache_set_op_offset:		.long sh_cache_set_op - .
 sh_toggle_pmb_cacheability_offset:
 				.long sh_toggle_pmb_cacheability - .
 #endif	/* CONFIG_SH_SE_MODE */
+
+
+#if defined(CFG_ENV_IS_IN_EEPROM)
+	/*
+	 * The following is a hack to work around a awkward linker
+	 * dependency issue. We need to force "ld" to pull in the CPU
+	 * specific version of "env_eeprom.o", rather than the generic
+	 * "common/env_eeprom.o" file that the linker seems to prefer!
+	 * QQQ: try to solve this properly, or make it non-loadable!
+	 */
+	.long env_init	/* any reference to anything in "env_eeprom.o" */
+#endif /* CFG_ENV_IS_IN_EEPROM */
+
diff --git a/cpu/sh/stm-nand.c b/cpu/sh/stm-nand.c
index ae7880c..4d3efbf 100644
--- a/cpu/sh/stm-nand.c
+++ b/cpu/sh/stm-nand.c
@@ -32,20 +32,7 @@
 #include <asm/errno.h>
 #include <asm/st40reg.h>
 #include <asm/io.h>
-
-#if defined(CONFIG_SH_STB7100)
-#include <asm/stb7100reg.h>
-#elif defined(CONFIG_SH_STX7105)
-#include <asm/stx7105reg.h>
-#elif defined(CONFIG_SH_STX7111)
-#include <asm/stx7111reg.h>
-#elif defined(CONFIG_SH_STX7141)
-#include <asm/stx7141reg.h>
-#elif defined(CONFIG_SH_STX7200)
-#include <asm/stx7200reg.h>
-#else
-#error Missing Device Definitions!
-#endif
+#include <asm/socregs.h>
 
 
 #define isprint(x)	( ((x)>=0x20u) && ((x)<0x7fu) )
diff --git a/cpu/sh/stx5197/Makefile b/cpu/sh/stx5197/Makefile
new file mode 100644
index 0000000..9c483e8
--- /dev/null
+++ b/cpu/sh/stx5197/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stx5197.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stx5197/stx5197.c b/cpu/sh/stx5197/stx5197.c
new file mode 100644
index 0000000..d4e2996
--- /dev/null
+++ b/cpu/sh/stx5197/stx5197.c
@@ -0,0 +1,218 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+#include <spi.h>
+
+
+#define SET_SYSCONF_BIT(reg,flag,bit)			\
+	do {						\
+		if (flag)				\
+		{	/* set bit 'bit' */		\
+			reg |= (1ul<<(bit));		\
+		}					\
+		else					\
+		{	/* clear bit 'bit' */		\
+			reg &= ~(1ul<<(bit));		\
+		}					\
+	} while (0)
+
+#define SET_SYSCONF_BITS(reg,flag,first,last,yes,no)	\
+	do {						\
+		const unsigned long _mask = 		\
+			(1ul<<((last)-(first)+1))-1ul;	\
+		/* clear all bits in 'first':'last' */	\
+		reg &= ~(_mask<<(first));		\
+		if (flag)				\
+		{	/* set 'yes' in first:last */	\
+			reg |= ((yes)<<(first));	\
+		}					\
+		else					\
+		{	/* set 'no' in first:last */	\
+			reg |= ((no)<<(first));		\
+		}					\
+	} while (0)
+
+
+static void stx5197_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 140;	/* comms_clk = 140 MHz */
+}
+
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(const int speed)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_E;
+
+	/* MAC speed*/
+	/* CFG_CTRL_E.MAC_SPEED_SEL = speed==100 ? 1 : 0 [1] */
+	SET_SYSCONF_BIT(sysconf, speed==100, 1);
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_E = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(const int rmii, const int ext_clk, const int phy_bus)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_E;
+
+	/* Ethernet interface on */
+	/* CFG_CTRL_E.ETHERNET_INTERFACE_ON = 1 [0] */
+	SET_SYSCONF_BIT(sysconf, 1, 0);
+
+	/* MII plyclk out enable: 0=output, 1=input */
+	/* CFG_CTRL_E.MII_PHYCLK_OUT_EN = ext_clk ? 1 : 0 [6] */
+	SET_SYSCONF_BIT(sysconf, ext_clk, 6);
+
+	/* RMII/MII pin mode */
+	/* CFG_CTRL_E.MII_ETHERNET_SEL = rmii ? 2 : 3 [8:7] */
+	SET_SYSCONF_BITS(sysconf, rmii, 7, 8, 0x2, 0x3);
+
+	/* MII mode */
+	/* CFG_CTRL_E.MII_MODE = rmii ? 0 : 1 [2] */
+	SET_SYSCONF_BIT(sysconf, !rmii, 2);
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_E = sysconf;
+}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx5197_usb_init(void)
+{
+	unsigned long sysconf;
+
+	/* USB power down */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_H;
+	sysconf &= ~(1ul<<8);	/* CFG_CTRL_H.USB_POWERDOWN_REQ = 0 [8] */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_H = sysconf;
+
+	/* DDR enable for ULPI */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+	sysconf &= ~(1ul<<12);	/* CFG_CTRL_M.ULPI_DDR_EN_I = 0 [12] */
+				/* 0=8-bit SDR ULPI, 1=4-bit DDR ULPI */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = sysconf;
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_16BIT		|
+		USB_FLAGS_STRAP_PLL		|
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD256);
+}
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+/**********************************************************************/
+
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+#if defined(CONFIG_SPI) && !defined(CONFIG_SOFT_SPI)
+static void spi_chip_select(const int cs)
+{
+	unsigned long reg;
+
+	reg = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+
+	if (cs)
+	{	/* assert SPI CS */
+		reg &= ~(1ul<<13);	/* CFG_CTRL_M.SPI_CS_WHEN_SSC_USED = 0 [13] */
+	}
+	else
+	{	/* DE-assert SPI CS */
+		reg |= 1ul<<13;		/* CFG_CTRL_M.SPI_CS_WHEN_SSC_USED = 1 [13] */
+	}
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = reg;
+
+	if (cs)
+	{	/* wait 250ns for CS assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+#endif	/* CONFIG_SPI && !defined(CONFIG_SOFT_SPI) */
+
+
+/**********************************************************************/
+
+
+extern int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx5197_clocks();
+
+	/* obtain the chip cut + device id */
+	bd->bi_devid = *STX5197_HD_CONF_MON_CONFIG_MONITOR_H;
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	stmac_eth_hw_setup(0, 1, 0);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	return 0;
+}
+
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
index 7d56225..47280ee 100644
--- a/cpu/sh/stx7105/stx7105.c
+++ b/cpu/sh/stx7105/stx7105.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -31,8 +31,8 @@
 #include <asm/pio.h>
 #include <asm/stbus.h>
 #include <ata.h>
+#include <spi.h>
 
-#define PIO_BASE  ST40_PIO0_REGS_BASE
 
 static void stx7105_clocks(void)
 {
@@ -263,3 +263,90 @@ extern void stx7105_usb_init(void)
 
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
 
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7105_configure_sata(void)
+{
+	static int initialised_phy = 0;
+	unsigned long sysconf;
+
+	if (!initialised_phy)
+	{
+		/* Power up the SATA PHY */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<9);	/* [11] SATA1_PHY_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* Power up the SATA host */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<11);	/* [9] SATA1_HC_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void stx7105_spi_scl(const int val)
+{
+	const int pin = 0;	/* PIO15[0] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern void stx7105_spi_sda(const int val)
+{
+	const int pin = 1;	/* PIO15[1] = SPI_DOUT */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern unsigned char stx7105_spi_read(void)
+{
+	const int pin = 3;	/* PIO15[3] = SPI_DIN */
+	return STPIO_GET_PIN(15, pin);
+}
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 2;	/* PIO15[2] = SPI_NOTCS */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+#endif	/* CONFIG_SOFT_SPI */
+
+
diff --git a/cpu/sh/stx7141/stx7141.c b/cpu/sh/stx7141/stx7141.c
index cdd42ae..27bbac6 100644
--- a/cpu/sh/stx7141/stx7141.c
+++ b/cpu/sh/stx7141/stx7141.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -226,3 +226,33 @@ extern void stx7141_usb_init(void)
 
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
 
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7141_configure_sata(void)
+{
+	static int initialised_phy = 0;
+	unsigned long sysconf;
+
+	if (!initialised_phy)
+	{
+		/* enable reset  */
+		sysconf = *STX7141_SYSCONF_SYS_CFG04;
+		sysconf |= 1u<<9;
+		*STX7141_SYSCONF_SYS_CFG04 = sysconf;
+
+		sysconf = *STX7141_SYSCONF_SYS_CFG32;
+		sysconf |= 1u<<6;	/* [6] SATA_SLUMBER_POWER_MODE */
+		*STX7141_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/stx7200/stx7200.c b/cpu/sh/stx7200/stx7200.c
index 98c8f0e..58cf0d3 100644
--- a/cpu/sh/stx7200/stx7200.c
+++ b/cpu/sh/stx7200/stx7200.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007 STMicroelectronics.
+ * (C) Copyright 2007, 2009 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -531,3 +531,23 @@ extern void stx7200_usb_init(void)
 
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
 
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7200_configure_sata(void)
+{
+	static int initialised_phy = 0;
+
+	if (!initialised_phy)
+	{
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/u-boot.lds b/cpu/sh/u-boot.lds
new file mode 100644
index 0000000..04595d9
--- /dev/null
+++ b/cpu/sh/u-boot.lds
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2007-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text.init)
+		*(.text.init)		/* pre-initialization code */
+		. = ALIGN(32);		/* align to a cache-line */
+		*(.data.init)		/* pre-initialization data */
+		*(.text)		/* post-initialization code */
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		*(COMMON)		/* ensure common data is initialized */
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 72d1cc6..6470f22 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2008 STMicroelectronics Limited
+ * Copyright (C) 2007-2009 STMicroelectronics Limited
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -33,6 +33,8 @@
 
 #if defined(CONFIG_SH_STB7100)
 extern void stb7100_usb_init(void);
+#elif defined(CONFIG_SH_STX5197)
+extern void stx5197_usb_init(void);
 #elif defined(CONFIG_SH_STX7105)
 extern void stx7105_usb_init(void);
 #elif defined(CONFIG_SH_STX7111)
@@ -51,6 +53,8 @@ extern int usb_cpu_init(void)
 {
 #if defined(CONFIG_SH_STB7100)
 	stb7100_usb_init();
+#elif defined(CONFIG_SH_STX5197)
+	stx5197_usb_init();
 #elif defined(CONFIG_SH_STX7105)
 	stx7105_usb_init();
 #elif defined(CONFIG_SH_STX7111)
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
index 217a66d..d84c54f 100644
--- a/drivers/serial/stm-asc.c
+++ b/drivers/serial/stm-asc.c
@@ -20,6 +20,7 @@
 #include "asm/termbits.h"
 #include "asm/io.h"
 #include "asm/pio.h"
+#include "asm/socregs.h"
 
 #define CS7		0000040
 #define CS8		0000060
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index 62d17eb..ba0bd4b 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -60,6 +60,9 @@
        defined(CONFIG_SH_MB671)		|| \
        defined(CONFIG_SH_MB680)		|| \
        defined(CONFIG_SH_PDK7105)	|| \
+       defined(CONFIG_SH_IPIDTV7105)	|| \
+       defined(CONFIG_SH_MB704)		|| \
+       defined(CONFIG_SH_5197CAB)	|| \
        defined(CONFIG_SH_CB101)		|| \
        defined(CONFIG_SH_CB102)
 #  include "asm/io_stb1eval.h"
diff --git a/include/asm-sh/pio.h b/include/asm-sh/pio.h
index d271ed4..845157c 100644
--- a/include/asm-sh/pio.h
+++ b/include/asm-sh/pio.h
@@ -84,7 +84,7 @@ do {								\
 		((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));	\
 } while (0)
 #define STPIO_GET_PIN(PORT, PIN)				\
-	((readb(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
+	((readl(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
 
 #define SET_PIO_ASC_OUTDIR(PIO_ADDR, TX, RX, CTS, RTS, OUTDIR)	\
 do {								\
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
index cab439c..5b5ac45 100644
--- a/include/asm-sh/soc.h
+++ b/include/asm-sh/soc.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -28,7 +28,7 @@
 
 
 /*
- *	common call-back functons for STMAC.
+ *	common call-back functions for STMAC.
  */
 extern int  stmac_default_pbl (void);
 extern void stmac_set_mac_speed (int speed);
@@ -40,5 +40,25 @@ extern void stmac_set_mac_speed (int speed);
 extern void stx7200_configure_ethernet (
 	int mac, int rmii, int ext_clk, int phy_bus);
 
+
+/*
+ * SATA initialization functions.
+ */
+extern void stm_sata_miphy_init(void);
+extern int  stm_sata_probe(void);
+
+extern void stb7100_sata_init(void);
+extern void stx7105_configure_sata(void);
+extern void stx7141_configure_sata(void);
+extern void stx7200_configure_sata(void);
+
+
+/*
+ * Software "bit-banging" functions for SPI accesses.
+ */
+extern void		stx7105_spi_scl(const int val);
+extern void		stx7105_spi_sda(const int val);
+extern unsigned char	stx7105_spi_read(void);
+
 #endif	/* _SOC_H_ */
 
diff --git a/include/asm-sh/socregs.h b/include/asm-sh/socregs.h
new file mode 100644
index 0000000..793ad90
--- /dev/null
+++ b/include/asm-sh/socregs.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2004-2009
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __SOC_REG_H
+#define __SOC_REG_H
+
+
+#if defined(CONFIG_SH_STB7100)
+#	include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX5197)
+#	include <asm/stx5197reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#	include <asm/stx7105reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#	include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#	include <asm/stx7141reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#	include <asm/stx7200reg.h>
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+#endif /* __SOC_REG_H */
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
index c807842..6593b77 100644
--- a/include/asm-sh/st40reg.h
+++ b/include/asm-sh/st40reg.h
@@ -437,6 +437,13 @@
 #define ST40_EMI_NAND_ECC_CHECKCODE_2X8_3	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x029C)
 #define ST40_EMI_NAND_DATA_FIFO_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0300)
 
+/* EMI SPI serial flash registers */
+#define ST40_EMI_SPI_REGS_BASE			(ST40_EMI_REGS_BASE + 0x2000)
+#define ST40_EMI_SPI_CLOCKDIV			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0010)
+#define ST40_EMI_SPI_MODESELECT			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0018)
+#define ST40_EMI_SPI_CONFIGDATA			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0020)
+#define ST40_EMI_SPI_STATUSMODECHANGE		SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0028)
+
 /* Peripheral Component Interconnect control registers (all ST40 variants) */
 /* PCI Local Registers */
 #define ST40_PCI_VCR_STATUS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000000)
diff --git a/include/asm-sh/stx5197reg.h b/include/asm-sh/stx5197reg.h
new file mode 100644
index 0000000..29518e2
--- /dev/null
+++ b/include/asm-sh/stx5197reg.h
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008-2009.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti5197reg.h
+ */
+
+
+#ifndef __STX5197REG_H
+#define __STX5197REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMI_VERSION
+#define ST40_LMI_VERSION 4
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 2
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX5197_COMMS_BASE
+#define STX5197_COMMS_BASE 0xfd100000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX5197_COMMS_BASE
+#endif
+
+/* STi5197 control registers */
+#ifndef STX5197_SYSSERV_REGS_BASE
+#define STX5197_SYSSERV_REGS_BASE 0xfdc00000
+#endif
+
+#ifndef STX5197_HD_CONFIG_MONITOR_BASE
+#define STX5197_HD_CONFIG_MONITOR_BASE 0xfd901000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe000000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfdf00000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX5197_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX5197_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX5197_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX5197_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX5197_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX5197_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX5197_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX5197_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX5197_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX5197_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX5197_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX5197_COMMS_BASE + 0x00042000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STi5197 control registers
+ */
+
+/* System services registers (STi5197 variant) */
+#define STX5197_SYSSERV_PLLA_CONFIG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x00)
+#define STX5197_SYSSERV_PLLA_CONFIG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x04)
+#define STX5197_SYSSERV_PLLB_CONFIG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x08)
+#define STX5197_SYSSERV_PLLB_CONFIG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0C)
+#define STX5197_SYSSERV_FS216_SETUP_A		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x10)
+#define STX5197_SYSSERV_FSA_SETUP		STX5197_SYSSERV_FS216_SETUP_A
+#define STX5197_SYSSERV_FS216X4_CLK1_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x14)
+#define STX5197_SYSSERV_SPARE1_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK1_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK1_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x18)
+#define STX5197_SYSSERV_SPARE1_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK1_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK2_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x20)
+#define STX5197_SYSSERV_PCM_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK2_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK2_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x24)
+#define STX5197_SYSSERV_PCM_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK2_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK3_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x30)
+#define STX5197_SYSSERV_SPDIF_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK3_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK3_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x34)
+#define STX5197_SYSSERV_SPDIF_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK3_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK4_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x40)
+#define STX5197_SYSSERV_SC_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK4_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK4_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x44)
+#define STX5197_SYSSERV_SC_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK4_SETUP1
+#define STX5197_SYSSERV_FS216_SETUP_B		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x50)
+#define STX5197_SYSSERV_FSB_SETUP		STX5197_SYSSERV_FS216_SETUP_B
+#define STX5197_SYSSERV_FS216X4_CLK5_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x54)
+#define STX5197_SYSSERV_PIX_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK5_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK5_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x58)
+#define STX5197_SYSSERV_PIX_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK5_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK6_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x60)
+#define STX5197_SYSSERV_FDMA_FS_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK6_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK6_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x64)
+#define STX5197_SYSSERV_FDMA_FS_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK6_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK7_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x70)
+#define STX5197_SYSSERV_AUX_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK7_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK7_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x74)
+#define STX5197_SYSSERV_AUX_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK7_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK8_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x80)
+#define STX5197_SYSSERV_USB_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK8_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK8_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x84)
+#define STX5197_SYSSERV_USB_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK8_SETUP1
+#define STX5197_SYSSERV_CLKDIV0_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x90)
+#define STX5197_SYSSERV_CLKDIV0_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x94)
+#define STX5197_SYSSERV_CLKDIV0_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x98)
+#define STX5197_SYSSERV_CLKDIV1_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa0)
+#define STX5197_SYSSERV_CLKDIV1_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa4)
+#define STX5197_SYSSERV_CLKDIV1_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa8)
+#define STX5197_SYSSERV_CLKDIV2_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xac)
+#define STX5197_SYSSERV_CLKDIV2_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb0)
+#define STX5197_SYSSERV_CLKDIV2_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb4)
+#define STX5197_SYSSERV_CLKDIV3_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb8)
+#define STX5197_SYSSERV_CLKDIV3_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xbc)
+#define STX5197_SYSSERV_CLKDIV3_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc0)
+#define STX5197_SYSSERV_CLKDIV4_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc4)
+#define STX5197_SYSSERV_CLKDIV4_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc8)
+#define STX5197_SYSSERV_CLKDIV4_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xcc)
+#define STX5197_SYSSERV_CLKDIV6_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd0)
+#define STX5197_SYSSERV_CLKDIV6_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd4)
+#define STX5197_SYSSERV_CLKDIV6_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd8)
+#define STX5197_SYSSERV_CLKDIV7_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xdc)
+#define STX5197_SYSSERV_CLKDIV7_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe0)
+#define STX5197_SYSSERV_CLKDIV7_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe4)
+#define STX5197_SYSSERV_CLKDIV8_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe8)
+#define STX5197_SYSSERV_CLKDIV8_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xec)
+#define STX5197_SYSSERV_CLKDIV8_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf0)
+#define STX5197_SYSSERV_CLKDIV9_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf4)
+#define STX5197_SYSSERV_CLKDIV9_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf8)
+#define STX5197_SYSSERV_CLKDIV9_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xfc)
+#define STX5197_SYSSERV_CLKDIV10_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x100)
+#define STX5197_SYSSERV_CLKDIV10_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x104)
+#define STX5197_SYSSERV_CLKDIV10_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x108)
+#define STX5197_SYSSERV_MODE_CONTROL		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x110)
+#define STX5197_SYSSERV_REDUCED_PWR_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x114)
+#define STX5197_SYSSERV_LOW_POWER_DIS0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x118)
+#define STX5197_SYSSERV_LOW_POWER_DIS1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x11C)
+#define STX5197_SYSSERV_LOW_POWER_COUNTER_CFG0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x120)
+#define STX5197_SYSSERV_LOW_POWER_COUNTER_CFG1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x124)
+#define STX5197_SYSSERV_WATCHDOG_COUNTER_CFG0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x130)
+#define STX5197_SYSSERV_WATCHDOG_COUNTER_CFG1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x134)
+#define STX5197_SYSSERV_RESET_STATUS		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x140)
+#define STX5197_SYSSERV_SC_POWER_DETECT_CFG	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x144)
+#define STX5197_SYSSERV_SC_INSERTION_RST_CFG	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x148)
+#define STX5197_SYSSERV_CPU_INT_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x150)
+#define STX5197_SYSSERV_DCO_SD_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x160)
+#define STX5197_SYSSERV_DCO_CMD			SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x164)
+#define STX5197_SYSSERV_DCO_PCM_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x168)
+#define STX5197_SYSSERV_DCO_HD_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x16C)
+#define STX5197_SYSSERV_DCO_MODE_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x170)
+#define STX5197_SYSSERV_CLOCK_SEL_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x180)
+#define STX5197_SYSSERV_DIV_FORCE_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x184)
+#define STX5197_SYSSERV_CLK_OBS_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x188)
+#define STX5197_SYSSERV_RTCS_LSB_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x200)
+#define STX5197_SYSSERV_RTCS_MSB_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x204)
+#define STX5197_SYSSERV_RTCS_CONTROL_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x208)
+#define STX5197_SYSSERV_RTCS_LSB_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x210)
+#define STX5197_SYSSERV_RTCS_MSB_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x214)
+#define STX5197_SYSSERV_RTCS_CONTROL_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x218)
+#define STX5197_SYSSERV_REG_LOCK_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x300)
+#define STX5197_SYSSERV_CLKBIST_PLL0_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0390)
+#define STX5197_SYSSERV_CLKBIST_PLL0_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0394)
+#define STX5197_SYSSERV_CLKBIST_PLL0_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0398)
+#define STX5197_SYSSERV_CLKBIST_PLL0_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x039c)
+#define STX5197_SYSSERV_CLKBIST_PLL1_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a0)
+#define STX5197_SYSSERV_CLKBIST_PLL1_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a4)
+#define STX5197_SYSSERV_CLKBIST_PLL1_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a8)
+#define STX5197_SYSSERV_CLKBIST_PLL1_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03ac)
+#define STX5197_SYSSERV_CLKBIST_PCM_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b0)
+#define STX5197_SYSSERV_CLKBIST_PCM_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b4)
+#define STX5197_SYSSERV_CLKBIST_PCM_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b8)
+#define STX5197_SYSSERV_CLKBIST_PCM_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03bc)
+#define STX5197_SYSSERV_CLKBIST_FS0_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c0)
+#define STX5197_SYSSERV_CLKBIST_FS0_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c4)
+#define STX5197_SYSSERV_CLKBIST_FS0_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c8)
+#define STX5197_SYSSERV_CLKBIST_FS0_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03cc)
+#define STX5197_SYSSERV_CLKBIST_FS1_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d0)
+#define STX5197_SYSSERV_CLKBIST_FS1_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d4)
+#define STX5197_SYSSERV_CLKBIST_FS1_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d8)
+#define STX5197_SYSSERV_CLKBIST_FS1_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03dc)
+
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_C	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x0)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_D	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x4)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_E	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x8)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_F	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0xC)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_G	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x10)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_H	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x14)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_I	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x18)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_J	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x1C)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_K	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x40)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_L	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x44)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_M	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x48)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_N	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x4C)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_O	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x50)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_P	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x54)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_Q	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x58)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_R	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x5C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_C	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x20)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_D	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x24)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_E	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x28)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_F	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x2C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_G	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x30)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_H	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x34)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_I	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x38)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_J	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x3C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_K	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x60)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_L	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x64)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_M	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x68)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_N	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x6C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_O	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x70)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_P	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x74)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_Q	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x78)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_R	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x7C)
+
+#define STX5197_DEVID_5197c1_VAL	0x003f	/* STx5197 cut 1.x */	/* QQQ - TO CHECK */
+#define STX5197_DEVID_5197c2_VAL	0x003f	/* STx5197 cut 2.x */
+#define STX5197_DEVID_ID_SHIFT		12
+#define STX5197_DEVID_ID_MASK		0x3ff	/* ten bits */
+#define STX5197_DEVID_CUT_SHIFT		28
+#define STX5197_DEVID_CUT_MASK		0xf	/* four bits */
+
+#define STX5197_DEVICEID_5197(ID)	(	\
+	((((ID)>>STX5197_DEVID_ID_SHIFT)&STX5197_DEVID_ID_MASK)==STX5197_DEVID_5197c1_VAL)  || \
+	((((ID)>>STX5197_DEVID_ID_SHIFT)&STX5197_DEVID_ID_MASK)==STX5197_DEVID_5197c2_VAL)     )
+#define STX5197_DEVICEID_CUT(ID)  ((((ID) >> STX5197_DEVID_CUT_SHIFT) & STX5197_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX5197REG_H */
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
index 480450d..0106515 100644
--- a/include/asm-sh/u-boot.h
+++ b/include/asm-sh/u-boot.h
@@ -1,6 +1,9 @@
 /*
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -33,9 +36,11 @@ typedef struct bd_info
 	unsigned long bi_boot_params;	/* where this board expects params */
 	unsigned long bi_memstart;	/* start of DRAM memory */
 	unsigned long bi_memsize;	/* size  of DRAM memory in bytes */
+#ifndef CFG_NO_FLASH
 	unsigned long bi_flashstart;	/* start of FLASH memory */
 	unsigned long bi_flashsize;	/* size  of FLASH memory */
 	unsigned long bi_flashoffset;	/* reserved area for startup monitor */
+#endif /* CFG_NO_FLASH */
 #ifdef CONFIG_SH_STB7100
 	unsigned long bi_devid;
 	unsigned long bi_pll0frq;
@@ -48,7 +53,8 @@ typedef struct bd_info
 	unsigned long bi_emifrq;
 	unsigned long bi_lmifrq;
 #endif
-#if	defined(CONFIG_SH_STX7105) ||	\
+#if	defined(CONFIG_SH_STX5197) ||	\
+	defined(CONFIG_SH_STX7105) ||	\
 	defined(CONFIG_SH_STX7111) ||	\
 	defined(CONFIG_SH_STX7141) ||	\
 	defined(CONFIG_SH_STX7200)
diff --git a/include/configs/5197cab.h b/include/configs/5197cab.h
new file mode 100644
index 0000000..18a7069
--- /dev/null
+++ b/include/configs/5197cab.h
@@ -0,0 +1,262 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ * As the STx5197-CAB board only has SPI flash, then define it.
+ */
+#define CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI SDRAM */
+
+#define CFG_EMI_SPI_BASE	0xA0000000	/* SPI Serial FLASH in SPIBOOT-mode */
+#define CFG_MONITOR_BASE	0		/* Offset in SPI for u-boot.bin */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD 5197cab
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"update=" \
+		  "eeprom write $load_addr $monitor_base $monitor_len\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+#define CFG_STM_ASC2_BASE		0xfd132000ul	/* UART2 = AS0 */
+#define CFG_STM_ASC3_BASE		0xfd133000ul	/* UART3 = AS1 */
+
+/* 9-pin Female connector (J1), or 4-pin header (J2) */
+#define CFG_STM_ASC_BASE		CFG_STM_ASC3_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* Config for on-chip STMAC + LAN8700 PHY */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xfde00000ul	/* MAC = STM MAC */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#else
+#	undef CONFIG_CMD_NET		/* un-define if no networking at all */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfdd00000	/* front panel */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"5197CAB> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH				/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS				/* NOR-flash specific */
+#define CFG_NO_FLASH				/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	U10	ST	M25P32
+ *	U13	ST	M25PX64/128
+ *	U4	Atmel	AT45DB321
+ *	U12	Mxic	MX25Lxx
+ */
+/* choose Atmel or ST SPI Serial Flash */
+#if 1
+#	define CONFIG_SPI_FLASH_ST	/* ST M25Pxx (U10, U13) */
+#elif 1
+#	define CONFIG_SPI_FLASH_ATMEL	/* ATMEL AT45DB321 (U4) */
+#else
+#	define CONFIG_SPI_FLASH_MXIC	/* MXIC MX25Lxxx (U12) */
+#endif
+
+#define CONFIG_SPI			/* enable the SPI driver */
+#define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#define CFG_I2C_FRAM			/* to minimize performance degradation */
+#undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+/*
+ *	NOTE: To use the Atmel AT45DB321D serial flash for booting,
+ *	then it is required to re-program the page size to 512 bytes.
+ *	(default is 528 bytes per page). This is a once only,
+ *	irreversible programming option, and can not be undone.
+ *	This programming may be done from U-boot (booted via JTAG)
+ *
+ *		U-Boot> sspi 0 32 3D2A80A6	--> FFFFFFFF
+ *		U-Boot> sspi 0 16 D7		--> FFB4
+ *	Then power-cycle the board before using it.
+ */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ipidtv7105.h b/include/configs/ipidtv7105.h
new file mode 100644
index 0000000..29ab450
--- /dev/null
+++ b/include/configs/ipidtv7105.h
@@ -0,0 +1,381 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+#define CFG_BOOT_FROM_NAND	/* QQQ: define until boot-from-SPI is working */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI serial flash */
+/* QQQ: Note, need access to a modified board to verify the SPI configuration */
+#error QQQ: to add boot-from-SPI configuration!
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD ipidtv7105
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* 9-pin D-type connector on debug board - CN8 (next to RJ-45) */
+#	define CFG_STM_ASC_BASE		ST40_ASC0_REGS_BASE	/* UART #0 */
+#else
+	/* 9-pin D-type connector on debug board - CN7 */
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* UART #3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041FTL
+ *    External PHY connected via the MII off-board 15x2 header.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_KSZ8041FTL			/* PHY = Micrel KSZ8041FTL */
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* CN10 upper slot */
+#	define CFG_USB1_BASE			0xfea00000	/* CN10 lower slot */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"IPIDTV7105> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI and/or NAND) */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH		/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS		/* NOR-flash specific */
+#define CFG_NO_FLASH		/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	U33	ST	M25P32
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (US3) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7105_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7105_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7105_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 0 && defined(CONFIG_CMD_NAND)
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
index ef5f65e..1d6b531 100644
--- a/include/configs/mb628.h
+++ b/include/configs/mb628.h
@@ -187,10 +187,26 @@
 #endif	/* ifdef CONFIG_SH_STB7100_USB */
 
 /*---------------------------------------------------------------
- * IDE driver config
+ * SATA driver config
  */
 
-#if defined(CONFIG_SH_STB7100_USB)
+/* SATA works on cut 2.x of the STx7141 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
 #	define CFG_64BIT_LBA
 #	define CONFIG_LBA48
 #	define CONFIG_DOS_PARTITION
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
index a3626c9..0c4ff2d 100644
--- a/include/configs/mb671.h
+++ b/include/configs/mb671.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007-2008 STMicroelectronics.
+ * (C) Copyright 2007-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -187,25 +187,25 @@
 #endif	/* ifdef CONFIG_SH_STB7100_USB */
 
 /*---------------------------------------------------------------
- * IDE driver config
+ * SATA driver config
  */
 
-/* SATA should work on cut 2 of the STi7200 */
-//#define CONFIG_SH_STB7100_SATA
+/* SATA works on cut 3.x of the STx7200 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
 
-#ifdef CONFIG_SH_STB7100_SATA
-#	define CFG_PIO_MODE		4
-#	define CFG_IDE_MAXBUS		1
-#	define CFG_IDE_MAXDEVICE	1
-#	define CFG_ATA_BASE_ADDR	0x????
-#	define CFG_ATA_IDE0_OFFSET	0x0
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfd520000	/* SATA #0 */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
 #	define CFG_ATA_REG_OFFSET	0x0
 #	define CFG_ATA_DATA_OFFSET	0x0
 #	define CFG_ATA_STRIDE		0x4
-#	define CFG_ATA_ALT_OFFSET	0x8
-#endif	/* CONFIG_SH_STB7100_SATA */
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
 
-#if defined(CONFIG_SH_STB7100_SATA) ||	\
+#if defined(CONFIG_SH_STM_SATA) ||	\
     defined(CONFIG_SH_STB7100_USB)
 #	define CFG_64BIT_LBA
 #	define CONFIG_LBA48
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index cb89d0e..21c1fe9 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -214,10 +214,26 @@
 #endif	/* ifdef CONFIG_SH_STB7100_USB */
 
 /*---------------------------------------------------------------
- * IDE driver config
+ * SATA driver config
  */
 
-#if defined(CONFIG_SH_STB7100_USB)
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
 #	define CFG_64BIT_LBA
 #	define CONFIG_LBA48
 #	define CONFIG_DOS_PARTITION
@@ -343,6 +359,25 @@
 #	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
 #endif	/* CONFIG_CMD_NAND */
 
+#if 1 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+	/*
+	 * If we want to store "u-boot.bin" in NAND flash starting at
+	 * physical block #0, but there are Bad Blocks in the first
+	 * few blocks that we need to "skip" over, then we need
+	 * to define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING to allow
+	 * skipping of these bad blocks for u-boot to relocate itself.
+	 * In addition, we also need to tell U-boot the block size,
+	 * and provide it a local abridged copy of the master Bad Block
+	 * Table (BBT), which must also be stored in physical block #0
+	 * - see "cpu/sh/start.S" for details.
+	 * Also, CFG_NAND_SKIP_BLOCK_COUNT defines the number of blocks
+	 * stored in the abridged copy of the master BBT.
+	 */
+#	define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING	/* define for skipping */
+#	define CFG_NAND_SKIP_BLOCK_SIZE		(16<<10)/* Block Size = 16 KiB */
+#	define CFG_NAND_SKIP_BLOCK_COUNT	16	/* entries in the array */
+#endif /* CFG_BOOT_FROM_NAND */
+
 /*-----------------------------------------------------------------------
  * Address, size, & location of U-boot's Environment Sector
  */
diff --git a/include/configs/mb704.h b/include/configs/mb704.h
new file mode 100644
index 0000000..f0cdfde
--- /dev/null
+++ b/include/configs/mb704.h
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ * As the MB704 board only has SPI flash, then define it.
+ */
+#define CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI SDRAM */
+
+#define CFG_EMI_SPI_BASE	0xA0000000	/* SPI Serial FLASH in SPIBOOT-mode */
+#define CFG_MONITOR_BASE	0		/* Offset in SPI for u-boot.bin */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb704
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"update=" \
+		  "eeprom write $load_addr $monitor_base $monitor_len\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+#define CFG_STM_ASC2_BASE		0xfd132000ul	/* UART2 = AS0 */
+#define CFG_STM_ASC3_BASE		0xfd133000ul	/* UART3 = AS1 */
+/* choose which ST ASC UART to use */
+#if 1
+	/* Upper 9-pin Female connector */
+#	define CFG_STM_ASC_BASE	CFG_STM_ASC2_BASE	/* UART2 = AS0 */
+#else
+	/* Lower 9-pin Male connector */
+#	define CFG_STM_ASC_BASE	CFG_STM_ASC3_BASE	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet, all use the on-chip ST MAC.
+ * The choice in PHYs are:
+ *    On-board SMSC LAN8700 PHY (on MB762 peripheral board).
+ *    External PHY connected via the MII off-board 15x2 header (MB704).
+ *    External PHY connected via the MII off-board 15x2 header (MB762).
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* Config for on-chip STMAC + LAN8700 PHY */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xfde00000ul	/* MAC = STM MAC */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#else
+#	undef CONFIG_CMD_NET		/* un-define if no networking at all */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfdd00000	/* front panel */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB704> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH				/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS				/* NOR-flash specific */
+#define CFG_NO_FLASH				/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ * 	Board	Manuf	Device		Name	MB704		MB772
+ * 	-----	-----	------		----	-----		-----
+ *	MB704	Atmel	AT45DB321D	IC11	J10 1-2		n/a
+ *	MB762	ST	M25P80		IC27	J10 2-3		J9B 1-2
+ *	MB762	ST	M25P32		IC28	J10 2-3		J9B 2-3
+ *
+ *	NOTE: To use the ST flash on the MB762 peripheral board,
+ *	then the following settings are also required:
+ *
+ *		MB704	J10 2-3
+ *		MB762	J9A 2-3
+ *		MB762	SW1-1 OFF
+ *		MB762	SW1-2 OFF
+ */
+/* choose Atmel or ST SPI Serial Flash */
+#if 1
+#	define CONFIG_SPI_FLASH_ATMEL	/* ATMEL AT45DB321D, on MB704 */
+#else
+#	define CONFIG_SPI_FLASH_ST	/* ST M25Pxx, on MB762 */
+#endif
+
+#define CONFIG_SPI			/* enable the SPI driver */
+#define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#define CFG_I2C_FRAM			/* to minimize performance degradation */
+#undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+/*
+ *	NOTE: To use the Atmel AT45DB321D serial flash for booting,
+ *	then it is required to re-program the page size to 512 bytes.
+ *	(default is 528 bytes per page). This is a once only,
+ *	irreversible programming option, and can not be undone.
+ *	This programming may be done from U-boot (booted via JTAG)
+ *
+ *		U-Boot> sspi 0 32 3D2A80A6	--> FFFFFFFF
+ *		U-Boot> sspi 0 16 D7		--> FFB4
+ *	Then power-cycle the board before using it.
+ */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
index b0c16f1..61cd318 100644
--- a/include/configs/pdk7105.h
+++ b/include/configs/pdk7105.h
@@ -36,6 +36,24 @@
 /* This should really be replaced with something which uses bd->...	*/
 #define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
+
+/*-----------------------------------------------------------------------
+ *	Jumper settings to select between the SoC's 3 boot-modes:
+ *		a) boot from NOR flash
+ *		b) boot from NAND flash
+ *		c) boot from SPI serial flash
+ *
+ *	With the LED display panel facing the user:
+ *
+ *	Jumper	Location	NOR	NAND	SPI
+ *	------	--------	---	----	---
+ *	JE6	top-most	EAST	EAST	WEST
+ *	JE5	below JE6	EAST	WEST	EAST
+ *	JE3	left-side	NORTH	SOUTH	SOUTH
+ *	JE2	right-side	SOUTH	NORTH	NORTH
+ */
+
+
 /*-----------------------------------------------------------------------
  * Are we booting directly from a NAND Flash device ?
  * If so, then define the "CFG_BOOT_FROM_NAND" macro,
@@ -45,15 +63,28 @@
 
 
 /*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
  * Assume we run out of uncached memory for the moment
  */
 
-#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSC with JE2 */
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI, so *DO* swap CSA and CSC with JE2 */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND, so *DO* swap CSA and CSC with JE2 */
 #define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
 #define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
 #define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
-#else		/* else, do *NOT* swap CSA and CSC using JE2 */
+#else					/* else, do *NOT* swap CSA and CSC using JE2 */
 #define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
 #define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
 #define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
@@ -141,10 +172,10 @@
 /* choose which ST ASC UART to use */
 #if 1
 	/* 9-pin D-type connector on STi7105-SDK-SB daughter board */
-#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
+#	define CFG_STM_ASC_BASE		ST40_ASC2_REGS_BASE	/* UART #2 */
 #else
 	/* JN5, 6-way connector - QQQ NOT TESTED */
-#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 = AS1 */
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* UART #3 */
 #endif
 
 /*---------------------------------------------------------------
@@ -201,10 +232,26 @@
 #endif	/* ifdef CONFIG_SH_STB7100_USB */
 
 /*---------------------------------------------------------------
- * IDE driver config
+ * SATA driver config
  */
 
-#if defined(CONFIG_SH_STB7100_USB)
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
 #	define CFG_64BIT_LBA
 #	define CONFIG_LBA48
 #	define CONFIG_DOS_PARTITION
@@ -235,7 +282,7 @@
  * FLASH organization
  */
 
-/* Choose if we want FLASH Support (NAND &/or NOR devices)
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
  * With the PDK7105 combination, we may use *both*
  * NOR and NAND flash, at the same time, if we want.
  *
@@ -244,6 +291,7 @@
 #undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
 #define CONFIG_CMD_FLASH	/* define for NOR flash */
 #define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
 
 /*-----------------------------------------------------------------------
  * NOR FLASH organization
@@ -331,18 +379,52 @@
 #endif	/* CONFIG_CMD_NAND */
 
 /*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	US3	ST	M25P64
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (US3) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7105_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7105_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7105_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/*-----------------------------------------------------------------------
  * Address, size, & location of U-boot's Environment Sector
  */
 
 #define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
 
-#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
 #	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
-#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
 #	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
 #endif	/* CONFIG_CMD_NAND */
diff --git a/include/spi.h b/include/spi.h
index 03dc5bc..9fc0e1a 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -1,6 +1,7 @@
 /*
  * (C) Copyright 2001
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
+ * (C) Copyright 2009 STMicroelectronics. Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -70,4 +71,11 @@ void spi_init(void);
  */
 int  spi_xfer(spi_chipsel_type chipsel, int bitlen, uchar *dout, uchar *din);
 
+/*
+ * External table of chip select functions (see the appropriate board
+ * support for the actual definition of the table).
+ */
+extern spi_chipsel_type spi_chipsel[];
+extern int spi_chipsel_cnt;
+
 #endif	/* _SPI_H_ */
diff --git a/lib_sh/board.c b/lib_sh/board.c
index f135424..48ebea3 100644
--- a/lib_sh/board.c
+++ b/lib_sh/board.c
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004-2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -33,19 +34,10 @@
 #if defined(CONFIG_CMD_NAND)
 #include <nand.h>
 #endif
-#if defined(CONFIG_SH_STB7100)
-#include <asm/stb7100reg.h>
-#elif defined(CONFIG_SH_STX7105)
-#include <asm/stx7105reg.h>
-#elif defined(CONFIG_SH_STX7111)
-#include <asm/stx7111reg.h>
-#elif defined(CONFIG_SH_STX7141)
-#include <asm/stx7141reg.h>
-#elif defined(CONFIG_SH_STX7200)
-#include <asm/stx7200reg.h>
-#else
-#error Missing Device Definitions!
+#if defined(CONFIG_SPI)
+#include <spi.h>
 #endif
+#include <asm/socregs.h>
 #include <asm/st40reg.h>
 
 extern ulong _uboot_end_data;
@@ -74,6 +66,7 @@ extern int soc_init (void); 	/* Detect/set SOC settings  */
 extern int board_init (void);   /* Set up board             */
 extern int timer_init (void);
 extern int checkboard (void);   /* Give info about board    */
+extern int env_init_after_spi_done (void);
 
 static void mem_malloc_init (void)
 {
@@ -231,23 +224,31 @@ void start_sh4boot (void)
 	bd->bi_memstart = CFG_SDRAM_BASE;	/* start of  DRAM memory */
 	bd->bi_memsize = gd->ram_size;	/* size  of  DRAM memory in bytes */
 	bd->bi_baudrate = gd->baudrate;	/* Console Baudrate */
-	bd->bi_flashstart = CFG_FLASH_BASE;
 #ifndef CFG_NO_FLASH
+	bd->bi_flashstart = CFG_FLASH_BASE;
 	bd->bi_flashsize = size;
-#endif /* CFG_NO_FLASH */
 #if CFG_MONITOR_BASE == CFG_FLASH_BASE
 	bd->bi_flashoffset = monitor_flash_len;	/* reserved area for U-Boot */
 #else
 	bd->bi_flashoffset = 0;
 #endif
+#endif /* CFG_NO_FLASH */
 
 	/* initialize malloc() area */
 	mem_malloc_init ();
 
 #if defined(CONFIG_CMD_NAND)
 	puts ("NAND:  ");
-	nand_init();		/* go init the NAND */
+	nand_init ();		/* go init the NAND */
+#endif
+
+#if defined(CONFIG_SPI)
+	puts ("SPI:  ");
+	spi_init ();		/* go init the SPI */
+#if defined(CFG_ENV_IS_IN_EEPROM) && !defined(CFG_BOOT_FROM_SPI)
+	env_init_after_spi_done ();
 #endif
+#endif	/* defined(CONFIG_SPI) */
 
 	/* Allocate environment function pointers etc. */
 	env_relocate ();
diff --git a/lib_sh/cacheops.S b/lib_sh/cacheops.S
index 22eca9c..efeabcb 100644
--- a/lib_sh/cacheops.S
+++ b/lib_sh/cacheops.S
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2004-2008 STMicroelectronics.
+ * (C) Copyright 2004-2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -31,7 +31,7 @@
 #include "asm/sh4reg.h"
 #include "asm/pmb.h"
 
-	.text
+	.section .text.init, "ax"
 
 	/*
 	 * void sh_cache_set_op (ulong op)
diff --git a/lib_sh/time.c b/lib_sh/time.c
index d676033..2dbc7cf 100644
--- a/lib_sh/time.c
+++ b/lib_sh/time.c
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004,2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -23,20 +24,7 @@
  */
 
 #include <common.h>
-
-#if defined(CONFIG_SH_STB7100)
-#include <asm/stb7100reg.h>
-#elif defined(CONFIG_SH_STX7105)
-#include <asm/stx7105reg.h>
-#elif defined(CONFIG_SH_STX7111)
-#include <asm/stx7111reg.h>
-#elif defined(CONFIG_SH_STX7141)
-#include <asm/stx7141reg.h>
-#elif defined(CONFIG_SH_STX7200)
-#include <asm/stx7200reg.h>
-#else
-#error Missing Device Definitions!
-#endif
+#include <asm/socregs.h>
 
 #define TMU_TICKS_PER_SEC CFG_HZ
 #define TMU_START0 0x01
diff --git a/sh_config.mk b/sh_config.mk
index 6129e52..fd7b172 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2004-2008
+# (C) Copyright 2004-2009
 # Andy Sturges, STMicroelectronics, andy.sturges@st.com
 # Sean McGoogan STMicroelectronics, <Sean.McGoogan@st.com>
 #
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2009-04-27\""
+SH_IDENT_STRING="\"stm23-2009-08-05\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
