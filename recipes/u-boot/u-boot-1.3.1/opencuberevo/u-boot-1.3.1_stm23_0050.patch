diff --git a/MAKEALL b/MAKEALL
index 928cf58..ecfdfd0 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -670,6 +670,10 @@ LIST_sh="		\
 	mb442se_30	\
 	mb442se_27_128	\
 	mb442se_30_128	\
+	hmp7100		\
+	hmp7100_128	\
+	hmp7100se	\
+	hmp7100se_128	\
 	hms1		\
 	hms1_128	\
 	mb519		\
@@ -684,6 +688,8 @@ LIST_sh="		\
 	mb680se		\
 	mb796		\
 	mb796se		\
+	hdk5289		\
+	hdk5289se	\
 	pdk7105		\
 	pdk7105se	\
 	ipidtv7105	\
@@ -697,10 +703,13 @@ LIST_sh="		\
 	cb102		\
 	cb102se		\
 	fldbse		\
+	fudbse		\
 	mb628		\
 	mb628se		\
 	eud7141		\
 	eud7141se	\
+	mb837se		\
+	hdk7108se	\
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index 5672fe4..bb42360 100644
--- a/Makefile
+++ b/Makefile
@@ -2700,6 +2700,25 @@ mb442se_30_128_config : 	unconfig
 	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb442/config.tmp)
 	@$(MKCONFIG) -a mb442 sh sh mb442 st stb7100
 
+hmp7100_config \
+hmp7100_128_config \
+hmp7100se_config \
+hmp7100se_128_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hmp7100
+	@echo "#define CONFIG_SH_STB7100     1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HMP7100     1" >>$(obj)include/config.h
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_HMP7100_128 1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE     1" >>$(obj)include/config.h)
+	$(if $(findstring se_config,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/hmp7100/config.tmp)
+	$(if $(findstring se_128,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/hmp7100/config.tmp)
+	$(if $(findstring 7100_128,$@), \
+	@echo "TEXT_BASE = 0x8BF00000" >$(obj)board/st/hmp7100/config.tmp)
+	@$(MKCONFIG) -a hmp7100 sh sh hmp7100 st stb7100
+
 mb448_config :		unconfig
 	@mkdir -p $(obj)include
 	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
@@ -2816,6 +2835,26 @@ ipidtv7105se_config :		unconfig
 	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
 	@$(MKCONFIG) -a ipidtv7105 sh sh pdk7105 st stx7105
 
+mb837se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb837
+	@echo "#define CONFIG_SH_STX7108    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB837      1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb837/config.tmp)
+	@$(MKCONFIG) -a mb837 sh sh mb837 st stx7108
+
+hdk7108se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hdk7108
+	@echo "#define CONFIG_SH_STX7108    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HDK7108      1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/hdk7108/config.tmp)
+	@$(MKCONFIG) -a hdk7108 sh sh hdk7108 st stx7108
+
 mb704_config \
 mb704se_config :		unconfig
 	@mkdir -p $(obj)include $(obj)board/st/mb704
@@ -2867,6 +2906,13 @@ fldbse_config :		unconfig
 	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h
 	@$(MKCONFIG) -a fldb sh sh fldb st fli7510
 
+fudbse_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/fudb
+	@echo "#define CONFIG_SH_FLI7540   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_FUDB      1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a fudb sh sh fudb st fli7540
+
 # QQQ following should have "TEXT_BASE = 0x8FF00000" for SE mode.
 # QQQ However, the current TargetPacks only define the PMB
 # QQQ for the first 128MiB region of RAM.
@@ -2883,6 +2929,18 @@ mb796se_config :		unconfig
 	@$(MKCONFIG) -a mb796 sh sh mb796 st stx5206
 
 
+hdk5289_config \
+hdk5289se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hdk5289
+	@echo "#define CONFIG_SH_STX5206   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HDK5289   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/hdk5289/config.tmp)
+	@$(MKCONFIG) -a hdk5289 sh sh hdk5289 st stx5206
+
+
 #========================================================================
 # STMicroelectronics ST200
 #========================================================================
diff --git a/board/st/cb101/init-cb101.S b/board/st/cb101/init-cb101.S
index 03375cb..5e6450f 100644
--- a/board/st/cb101/init-cb101.S
+++ b/board/st/cb101/init-cb101.S
@@ -378,12 +378,12 @@ __memory_setup_table:
    * their 32-bit SE mode locations as defined in the datasheet and change the
    * 'upper bound addresses' (in row attribute registers) for the LMIs.
    */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+  UPDATE32(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE32(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, (0x88000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, (0x88000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/st/cb102/init-cb102.S b/board/st/cb102/init-cb102.S
index 20b12df..022bae2 100644
--- a/board/st/cb102/init-cb102.S
+++ b/board/st/cb102/init-cb102.S
@@ -399,12 +399,12 @@ __memory_setup_table:
 	 * their 32-bit SE mode locations as defined in the datasheet and change the
 	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
 	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/st/cb103/init-cb103.S b/board/st/cb103/init-cb103.S
index 5506db0..2636224 100644
--- a/board/st/cb103/init-cb103.S
+++ b/board/st/cb103/init-cb103.S
@@ -53,12 +53,12 @@ __memory_setup_table:
 	 * their 32-bit SE mode locations as defined in the datasheet and change the
 	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
 	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/st/eud7141/init-eud7141.S b/board/st/eud7141/init-eud7141.S
index 82faa60..9cfb2e1 100644
--- a/board/st/eud7141/init-eud7141.S
+++ b/board/st/eud7141/init-eud7141.S
@@ -52,11 +52,13 @@ __memory_setup_table:
 	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
 	 * their 32-bit SE mode locations as defined in the datasheet and change the
 	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * For LMI #0, we have 256MiB (UBA = 0x40000000 + 256MiB = 0x50000000).
+	 * For LMI #1, we have 128MiB (UBA = 0x80000000 + 128MiB = 0x88000000).
 	 */
 	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
 	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
-	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x50000000)
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x50000000)
 	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
 	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
 #endif	/* CONFIG_SH_SE_MODE */
diff --git a/board/st/fudb/Makefile b/board/st/fudb/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/fudb/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/fudb/config.mk b/board/st/fudb/config.mk
new file mode 100644
index 0000000..6fcc9d3
--- /dev/null
+++ b/board/st/fudb/config.mk
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2009-2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Freeman-Ultra (FLI7540) Development Board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/fudb/fli7540.romgen b/board/st/fudb/fli7540.romgen
new file mode 100644
index 0000000..2f92243
--- /dev/null
+++ b/board/st/fudb/fli7540.romgen
@@ -0,0 +1,3295 @@
+/*
+This file was automatically generated on Wed 16 Jun 10 at 18:29:24 by user mcgoogan, host hoiho.bri.st.com using romgen R1.4.0 with the ST TargetPack fudb_gpd201
+
+TargetPack files used:
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/fudb_gpd201/fudb_gpd201.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/fudb_gpd201/fudb_gpd201.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/fudb_gpd201/fudb_gpd201_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/jtag_core.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_ccn_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_addr_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_data_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_regs.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/debug/tapmux.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9ckg_ddr.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9ckg_south_reg.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9t1s_t1i_1.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9t1s_t1i_2.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9vdec_pu_config_reg0.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_c9vdec_pu_config_reg1.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_clockgena_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_emireg.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_mixer16.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_mixer32.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_pctl16.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_pctl32.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/FLI7540_trs_c9t1s_t1i_1.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/fli7540.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/fli7540.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/fli7540/fli7540_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_emi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_pio.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/tapmux.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/__init__.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/jtag.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/utilities/utilities.py
+*/
+
+
+/*
+FLI7540_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe000014, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe000024, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe00001c, 0xffffffff, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe000020, 0xffffffff, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0_CFG
+*/
+OR32(0xfe000000, 0x00100000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_POWER_CFG
+*/
+OR32(0xfe000010, 0x00000001)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0_CFG
+*/
+UPDATE32(0xfe000000, 0xffff00f8, 0x00001e02)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_POWER_CFG
+*/
+UPDATE32(0xfe000010, 0xfffffffe, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe000000, 0x80000000, 0x80000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0_CFG
+*/
+UPDATE32(0xfe000000, 0xffefffff, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_CFG
+*/
+OR32(0xfe000004, 0x00100000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_POWER_CFG
+*/
+OR32(0xfe000010, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_CFG
+*/
+UPDATE32(0xfe000004, 0xfff800f8, 0x00002803)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_POWER_CFG
+*/
+UPDATE32(0xfe000010, 0xfffffffd, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe000004, 0x80000000, 0x80000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_CFG
+*/
+UPDATE32(0xfe000004, 0xffefffff, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0HS_DIV0_CFG
+*/
+POKE32(0xfe000900, 0x00000001)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0HS_DIV1_CFG
+*/
+POKE32(0xfe000904, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0HS_DIV2_CFG
+*/
+POKE32(0xfe000908, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0HS_DIV3_CFG
+*/
+POKE32(0xfe00090c, 0x00000001)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe000a10, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
+*/
+POKE32(0xfe000a14, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe000a18, 0x00000000)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV7_CFG
+*/
+POKE32(0xfe000b1c, 0x00000001)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe000b20, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe000b24, 0x00000003)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe000b28, 0x00000007)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe000b2c, 0x00000004)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0LS_DIV12_CFG
+*/
+POKE32(0xfe000a30, 0x00000008)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV13_CFG
+*/
+POKE32(0xfe000b34, 0x00000007)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe000b38, 0x00000007)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL0LS_DIV15_CFG
+*/
+POKE32(0xfe000a3c, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe000b40, 0x00000002)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe000b44, 0x00000003)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe000014, 0x69aa9555)
+
+
+/*
+FLI7540_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe000024, 0x0000000a)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_SEL
+*/
+UPDATE32(0xfe0a0000, 0xffffff80, 0x00000780)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_1
+*/
+POKE32(0xfe0a0008, 0x00000032)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_2
+*/
+POKE32(0xfe0a001c, 0x00000032)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_3
+*/
+POKE32(0xfe0a0030, 0x00000032)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_1_1
+*/
+UPDATE32(0xfe0a000c, 0xf8000000, 0x071c7271)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_1_2
+*/
+UPDATE32(0xfe0a0010, 0xf8000000, 0x071c7271)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_1_3
+*/
+UPDATE32(0xfe0a0014, 0xf8000000, 0x071c7231)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_1_4
+*/
+UPDATE32(0xfe0a0018, 0xf8000000, 0x07333439)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_2_1
+*/
+UPDATE32(0xfe0a0020, 0xf8000000, 0x072aab3a)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_2_2
+*/
+UPDATE32(0xfe0a0024, 0xf8000000, 0x07666613)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_2_3
+*/
+UPDATE32(0xfe0a0028, 0xf8000000, 0x0744ec52)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_2_4
+*/
+UPDATE32(0xfe0a002c, 0xf8000000, 0x07333439)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_3_1
+*/
+UPDATE32(0xfe0a0034, 0xf8000000, 0x0700002f)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_3_2
+*/
+UPDATE32(0xfe0a0038, 0xf8000000, 0x07777831)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_3_3
+*/
+UPDATE32(0xfe0a003c, 0xf8000000, 0x0703a92a)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_FS_SOUTH_3_4
+*/
+UPDATE32(0xfe0a0040, 0xf8000000, 0x0744edb2)
+
+
+/*
+FLI7540_c9ckg_south_reg.CTL_EN
+*/
+POKE32(0xfe0a0004, 0x003fffff)
+
+
+/*
+FLI7540_c9ckg_ddr.CTL_PLL_DDR_FREQ
+*/
+POKE32(0xfe080004, 0x00002306)
+
+
+/*
+FLI7540_c9ckg_ddr.STATUS_PLL_DDR
+*/
+WHILE_NE32(0xfe08000c, 0x00000001, 0x00000001)
+
+
+/*
+FLI7540_c9ckg_ddr.CTL_EN
+*/
+POKE32(0xfe080000, 0x00000006)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfd100860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfd100800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfd100810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfd100820, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfd100830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfd100840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfd100100, 0x001126d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfd100108, 0x8d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfd100110, 0x9a200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfd100118, 0x0400021d)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfd100140, 0x001126d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfd100148, 0x8d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfd100150, 0x9a200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfd100158, 0x0400021d)
+POKE32(0xfd300000, 0x0000000b)
+POKE32(0xfd300004, 0x00000008)
+POKE32(0xfd300008, 0x0000000a)
+POKE32(0xfd30000c, 0x00000000)
+POKE32(0xfd300010, 0x00000009)
+POKE32(0xfd300014, 0x00000000)
+POKE32(0xfd300018, 0x00000007)
+POKE32(0xfd30001c, 0x00000000)
+POKE32(0xfd300060, 0x00007801)
+POKE32(0xfd300064, 0x00007403)
+POKE32(0xfd300068, 0x00000000)
+POKE32(0xfd30006c, 0x00000000)
+POKE32(0xfd300070, 0x00007204)
+POKE32(0xfd300074, 0x00000000)
+POKE32(0xfd300078, 0x00007202)
+POKE32(0xfd30007c, 0x00000000)
+POKE32(0xfd428000, 0x00000000)
+POKE32(0xfd428004, 0x00000000)
+POKE32(0xfd428008, 0x00000000)
+POKE32(0xfd42800c, 0x00000001)
+POKE32(0xfd458000, 0x00000000)
+POKE32(0xfd458004, 0x00000001)
+POKE32(0xfd458008, 0x00000003)
+POKE32(0xfd45800c, 0x00000002)
+
+
+/*
+st40_pio.PIO_CLEAR_PC0
+*/
+POKE32(0xfd988028, 0x00000020)
+
+
+/*
+st40_pio.PIO_SET_PC1
+*/
+POKE32(0xfd988034, 0x00000020)
+
+
+/*
+st40_pio.PIO_CLEAR_PC2
+*/
+POKE32(0xfd988048, 0x00000020)
+
+
+/*
+st40_pio.PIO_SET_POUT
+*/
+POKE32(0xfd988004, 0x00000020)
+DELAY(100)
+
+
+/*
+st40_pio.PIO_CLEAR_POUT
+*/
+POKE32(0xfd988008, 0x00000020)
+DELAY(100)
+
+
+/*
+st40_pio.PIO_SET_POUT
+*/
+POKE32(0xfd988004, 0x00000020)
+
+
+/*
+FLI7540_mixer32.GENC
+*/
+POKE32(0xfd310000, 0x00090710)
+
+
+/*
+FLI7540_mixer32.ROWADDRMSK
+*/
+POKE32(0xfd310028, 0xfffffc00)
+
+
+/*
+FLI7540_mixer32.LMIBADDR
+*/
+POKE32(0xfd310030, 0x00bf0080)
+
+
+/*
+FLI7540_mixer32.DDRP1
+*/
+POKE32(0xfd310038, 0x4331cf04)
+
+
+/*
+FLI7540_mixer32.BDLCK
+*/
+POKE32(0xfd310040, 0x00000717)
+
+
+/*
+FLI7540_mixer32.BDLAT
+*/
+POKE32(0xfd310048, 0x3f3f1707)
+
+
+/*
+FLI7540_mixer32.BDCRIS
+*/
+POKE32(0xfd310050, 0x00101010)
+
+
+/*
+FLI7540_mixer32.BDHPP
+*/
+POKE32(0xfd310058, 0x00000707)
+
+
+/*
+FLI7540_mixer32.BDQTHD
+*/
+POKE32(0xfd310060, 0x00000002)
+
+
+/*
+FLI7540_mixer32.BDLDINEF
+*/
+POKE32(0xfd310068, 0x00222190)
+
+
+/*
+FLI7540_mixer32.BDSTINEF
+*/
+POKE32(0xfd310070, 0x00222190)
+
+
+/*
+FLI7540_mixer32.INFLWREG
+*/
+POKE32(0xfd310080, 0x1f2f3f7f)
+
+
+/*
+FLI7540_mixer32.ARBFLWREG
+*/
+POKE32(0xfd310088, 0x2f070003)
+
+
+/*
+FLI7540_mixer32.BKFLWREG
+*/
+POKE32(0xfd310090, 0x0e0c4032)
+
+
+/*
+FLI7540_mixer32.HPPFLWREG1
+*/
+POKE32(0xfd3100a0, 0x1f032080)
+
+
+/*
+FLI7540_mixer32.HPPFLWREG2
+*/
+POKE32(0xfd3100a8, 0x0030004c)
+
+
+/*
+FLI7540_mixer32.REQMEM
+*/
+POKE32(0xfd3100b0, 0x00800040)
+
+
+/*
+FLI7540_mixer32.RESMEM
+*/
+POKE32(0xfd3100b8, 0x02000080)
+
+
+/*
+FLI7540_mixer32.RESMEM0
+*/
+POKE32(0xfd3100c0, 0x01000080)
+
+
+/*
+FLI7540_mixer32.RESMEM1
+*/
+POKE32(0xfd3100c8, 0x01000080)
+
+
+/*
+FLI7540_mixer32.GENP0
+*/
+POKE32(0xfd3101c0, 0x104008c9)
+
+
+/*
+FLI7540_mixer32.SPBKREG_0
+*/
+POKE32(0xfd310200, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_1
+*/
+POKE32(0xfd310204, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_2
+*/
+POKE32(0xfd310208, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_3
+*/
+POKE32(0xfd31020c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_4
+*/
+POKE32(0xfd310210, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_5
+*/
+POKE32(0xfd310214, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_6
+*/
+POKE32(0xfd310218, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_7
+*/
+POKE32(0xfd31021c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_8
+*/
+POKE32(0xfd310220, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_9
+*/
+POKE32(0xfd310224, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_10
+*/
+POKE32(0xfd310228, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_11
+*/
+POKE32(0xfd31022c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_12
+*/
+POKE32(0xfd310230, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_13
+*/
+POKE32(0xfd310234, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_14
+*/
+POKE32(0xfd310238, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_15
+*/
+POKE32(0xfd31023c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_16
+*/
+POKE32(0xfd310240, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_17
+*/
+POKE32(0xfd310244, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_18
+*/
+POKE32(0xfd310248, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_19
+*/
+POKE32(0xfd31024c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_20
+*/
+POKE32(0xfd310250, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_21
+*/
+POKE32(0xfd310254, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_22
+*/
+POKE32(0xfd310258, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_23
+*/
+POKE32(0xfd31025c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_24
+*/
+POKE32(0xfd310260, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_25
+*/
+POKE32(0xfd310264, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_26
+*/
+POKE32(0xfd310268, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_27
+*/
+POKE32(0xfd31026c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_28
+*/
+POKE32(0xfd310270, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_29
+*/
+POKE32(0xfd310274, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_30
+*/
+POKE32(0xfd310278, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_31
+*/
+POKE32(0xfd31027c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_32
+*/
+POKE32(0xfd310280, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_33
+*/
+POKE32(0xfd310284, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_34
+*/
+POKE32(0xfd310288, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_35
+*/
+POKE32(0xfd31028c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_36
+*/
+POKE32(0xfd310290, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_37
+*/
+POKE32(0xfd310294, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_38
+*/
+POKE32(0xfd310298, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_39
+*/
+POKE32(0xfd31029c, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_40
+*/
+POKE32(0xfd3102a0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_41
+*/
+POKE32(0xfd3102a4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_42
+*/
+POKE32(0xfd3102a8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_43
+*/
+POKE32(0xfd3102ac, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_44
+*/
+POKE32(0xfd3102b0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_45
+*/
+POKE32(0xfd3102b4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_46
+*/
+POKE32(0xfd3102b8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_47
+*/
+POKE32(0xfd3102bc, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_48
+*/
+POKE32(0xfd3102c0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_49
+*/
+POKE32(0xfd3102c4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_50
+*/
+POKE32(0xfd3102c8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_51
+*/
+POKE32(0xfd3102cc, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_52
+*/
+POKE32(0xfd3102d0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_53
+*/
+POKE32(0xfd3102d4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_54
+*/
+POKE32(0xfd3102d8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_55
+*/
+POKE32(0xfd3102dc, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_56
+*/
+POKE32(0xfd3102e0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_57
+*/
+POKE32(0xfd3102e4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_58
+*/
+POKE32(0xfd3102e8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_59
+*/
+POKE32(0xfd3102ec, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_60
+*/
+POKE32(0xfd3102f0, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_61
+*/
+POKE32(0xfd3102f4, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_62
+*/
+POKE32(0xfd3102f8, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPBKREG_63
+*/
+POKE32(0xfd3102fc, 0x000a0908)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_0
+*/
+POKE32(0xfd310400, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_1
+*/
+POKE32(0xfd310404, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_2
+*/
+POKE32(0xfd310408, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_3
+*/
+POKE32(0xfd31040c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_4
+*/
+POKE32(0xfd310410, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_5
+*/
+POKE32(0xfd310414, 0x09090809)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_6
+*/
+POKE32(0xfd310418, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_7
+*/
+POKE32(0xfd31041c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_8
+*/
+POKE32(0xfd310420, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_9
+*/
+POKE32(0xfd310424, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_10
+*/
+POKE32(0xfd310428, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_11
+*/
+POKE32(0xfd31042c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_12
+*/
+POKE32(0xfd310430, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_13
+*/
+POKE32(0xfd310434, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_14
+*/
+POKE32(0xfd310438, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_15
+*/
+POKE32(0xfd31043c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_16
+*/
+POKE32(0xfd310440, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_17
+*/
+POKE32(0xfd310444, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_18
+*/
+POKE32(0xfd310448, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_19
+*/
+POKE32(0xfd31044c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_20
+*/
+POKE32(0xfd310450, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_21
+*/
+POKE32(0xfd310454, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_22
+*/
+POKE32(0xfd310458, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_23
+*/
+POKE32(0xfd31045c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_24
+*/
+POKE32(0xfd310460, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_25
+*/
+POKE32(0xfd310464, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_26
+*/
+POKE32(0xfd310468, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_27
+*/
+POKE32(0xfd31046c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_28
+*/
+POKE32(0xfd310470, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_29
+*/
+POKE32(0xfd310474, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_30
+*/
+POKE32(0xfd310478, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_31
+*/
+POKE32(0xfd31047c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_32
+*/
+POKE32(0xfd310480, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_33
+*/
+POKE32(0xfd310484, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_34
+*/
+POKE32(0xfd310488, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_35
+*/
+POKE32(0xfd31048c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_36
+*/
+POKE32(0xfd310490, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_37
+*/
+POKE32(0xfd310494, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_38
+*/
+POKE32(0xfd310498, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_39
+*/
+POKE32(0xfd31049c, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_40
+*/
+POKE32(0xfd3104a0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_41
+*/
+POKE32(0xfd3104a4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_42
+*/
+POKE32(0xfd3104a8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_43
+*/
+POKE32(0xfd3104ac, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_44
+*/
+POKE32(0xfd3104b0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_45
+*/
+POKE32(0xfd3104b4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_46
+*/
+POKE32(0xfd3104b8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_47
+*/
+POKE32(0xfd3104bc, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_48
+*/
+POKE32(0xfd3104c0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_49
+*/
+POKE32(0xfd3104c4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_50
+*/
+POKE32(0xfd3104c8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_51
+*/
+POKE32(0xfd3104cc, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_52
+*/
+POKE32(0xfd3104d0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_53
+*/
+POKE32(0xfd3104d4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_54
+*/
+POKE32(0xfd3104d8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_55
+*/
+POKE32(0xfd3104dc, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_56
+*/
+POKE32(0xfd3104e0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_57
+*/
+POKE32(0xfd3104e4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_58
+*/
+POKE32(0xfd3104e8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_59
+*/
+POKE32(0xfd3104ec, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_60
+*/
+POKE32(0xfd3104f0, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_61
+*/
+POKE32(0xfd3104f4, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_62
+*/
+POKE32(0xfd3104f8, 0x09090909)
+
+
+/*
+FLI7540_mixer32.SPSRCREG_63
+*/
+POKE32(0xfd3104fc, 0x09090909)
+
+
+/*
+FLI7540_pctl32.PHY_PLLCR
+*/
+OR32(0xfd320418, 0x0005c000)
+
+
+/*
+FLI7540_pctl32.TOGCNT1U
+*/
+POKE32(0xfd3200c0, 0x000000f0)
+
+
+/*
+FLI7540_pctl32.TINIT
+*/
+POKE32(0xfd3200c4, 0x000000c8)
+
+
+/*
+FLI7540_pctl32.TRSTH
+*/
+POKE32(0xfd3200c8, 0x00000000)
+
+
+/*
+FLI7540_pctl32.TOGCNT100N
+*/
+POKE32(0xfd3200cc, 0x00000018)
+
+
+/*
+FLI7540_pctl32.PHY_PTR1
+*/
+POKE32(0xfd320420, 0x5de604b0)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x00010000, 0x00010000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+POKE32(0xfd320484, 0x24980002)
+
+
+/*
+FLI7540_pctl32.POWCTL
+*/
+POKE32(0xfd320044, 0x00000001)
+
+
+/*
+FLI7540_pctl32.POWSTAT
+*/
+WHILE_NE32(0xfd320048, 0x00000001, 0x00000001)
+
+
+/*
+FLI7540_pctl32.MCFG
+*/
+POKE32(0xfd320080, 0x00060041)
+
+
+/*
+FLI7540_pctl32.PPCFG
+*/
+POKE32(0xfd320084, 0x00000019)
+
+
+/*
+FLI7540_pctl32.PUB_PPMCFG
+*/
+POKE32(0xfd3204a8, 0x0000000e)
+
+
+/*
+FLI7540_pctl32.ODTCFG
+*/
+POKE32(0xfd32008c, 0x00000008)
+
+
+/*
+FLI7540_pctl32.DQSECFG
+*/
+POKE32(0xfd320090, 0x00112111)
+
+
+/*
+FLI7540_pctl32.TREFI
+*/
+POKE32(0xfd3200d0, 0x0000004e)
+
+
+/*
+FLI7540_pctl32.TMRD
+*/
+POKE32(0xfd3200d4, 0x00000002)
+
+
+/*
+FLI7540_pctl32.TRFC
+*/
+POKE32(0xfd3200d8, 0x0000003e)
+
+
+/*
+FLI7540_pctl32.TRP
+*/
+POKE32(0xfd3200dc, 0x00000006)
+
+
+/*
+FLI7540_pctl32.TRTW
+*/
+POKE32(0xfd3200e0, 0x00000006)
+
+
+/*
+FLI7540_pctl32.TAL
+*/
+POKE32(0xfd3200e4, 0x00000003)
+
+
+/*
+FLI7540_pctl32.TCL
+*/
+POKE32(0xfd3200e8, 0x00000007)
+
+
+/*
+FLI7540_pctl32.TCWL
+*/
+POKE32(0xfd3200ec, 0x00000006)
+
+
+/*
+FLI7540_pctl32.TRAS
+*/
+POKE32(0xfd3200f0, 0x00000016)
+
+
+/*
+FLI7540_pctl32.TRC
+*/
+POKE32(0xfd3200f4, 0x0000001b)
+
+
+/*
+FLI7540_pctl32.TRCD
+*/
+POKE32(0xfd3200f8, 0x00000006)
+
+
+/*
+FLI7540_pctl32.TRRD
+*/
+POKE32(0xfd3200fc, 0x00000005)
+
+
+/*
+FLI7540_pctl32.TRTP
+*/
+POKE32(0xfd320100, 0x00000004)
+
+
+/*
+FLI7540_pctl32.TWR
+*/
+POKE32(0xfd320104, 0x00000007)
+
+
+/*
+FLI7540_pctl32.TWTR
+*/
+POKE32(0xfd320108, 0x00000004)
+
+
+/*
+FLI7540_pctl32.TEXSR
+*/
+POKE32(0xfd32010c, 0x000000c8)
+
+
+/*
+FLI7540_pctl32.TXP
+*/
+POKE32(0xfd320110, 0x00000003)
+
+
+/*
+FLI7540_pctl32.TXPDLL
+*/
+POKE32(0xfd320114, 0x00000007)
+
+
+/*
+FLI7540_pctl32.TCKE
+*/
+POKE32(0xfd32012c, 0x00000003)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80100000)
+DELAY(1)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80100001)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80140003)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80160003)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x801205e3)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x8010d733)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80100001)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80100002)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80100002)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x8010c733)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+DELAY(1)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x80123de3)
+DELAY(1)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+POKE32(0xfd320040, 0x821205e3)
+
+
+/*
+FLI7540_pctl32.MCMD
+*/
+WHILE_NE32(0xfd320040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl32.SCTL
+*/
+POKE32(0xfd320004, 0x00000001)
+
+
+/*
+FLI7540_pctl32.STAT
+*/
+WHILE_NE32(0xfd320008, 0x00000001, 0x00000001)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+OR32(0xfd320484, 0x00020000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x00040000, 0x00040000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x00200000, 0x00200000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+OR32(0xfd320484, 0xfcff0000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x00400000, 0x00400000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+OR32(0xfd320484, 0xfcff0000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x01000000, 0x01000000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x02000000, 0x02000000)
+
+
+/*
+FLI7540_pctl32.PHY_DX0LCDLR1
+*/
+POKE32(0xfd3205e4, 0x0000211d)
+
+
+/*
+FLI7540_pctl32.PHY_DX1LCDLR1
+*/
+POKE32(0xfd320624, 0x0000221e)
+
+
+/*
+FLI7540_pctl32.PHY_DX2LCDLR1
+*/
+POKE32(0xfd320664, 0x0000211d)
+
+
+/*
+FLI7540_pctl32.PHY_DX3LCDLR1
+*/
+POKE32(0xfd3206a4, 0x0000211c)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x08000000, 0x08000000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x10000000, 0x10000000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x40000000, 0x40000000)
+
+
+/*
+FLI7540_pctl32.PUB_SMCTL
+*/
+WHILE_NE32(0xfd320484, 0x80000000, 0x80000000)
+
+
+/*
+FLI7540_pctl32.PHYPVTCFG
+*/
+POKE32(0xfd320300, 0x000045d0)
+
+
+/*
+FLI7540_pctl32.PHYTUPDWAIT
+*/
+POKE32(0xfd320320, 0x00000003)
+
+
+/*
+FLI7540_pctl32.PVTTUPDWAIT
+*/
+POKE32(0xfd320324, 0x00000003)
+
+
+/*
+FLI7540_pctl32.PHYIOCRV1
+*/
+POKE32(0xfd32031c, 0x00004305)
+
+
+/*
+FLI7540_pctl32.SCTL
+*/
+POKE32(0xfd320004, 0x00000002)
+
+
+/*
+FLI7540_pctl32.PHY_PIR
+*/
+UPDATE32(0xfd320404, 0xefffffff, 0x00000000)
+
+
+/*
+FLI7540_mixer16.GENC
+*/
+POKE32(0xfd350000, 0x00090710)
+
+
+/*
+FLI7540_mixer16.ROWADDRMSK
+*/
+POKE32(0xfd350028, 0xfffffc00)
+
+
+/*
+FLI7540_mixer16.LMIBADDR
+*/
+POKE32(0xfd350030, 0x007f0040)
+
+
+/*
+FLI7540_mixer16.DDRP1
+*/
+POKE32(0xfd350038, 0x4331cf04)
+
+
+/*
+FLI7540_mixer16.BDLCK
+*/
+POKE32(0xfd350040, 0x00000717)
+
+
+/*
+FLI7540_mixer16.BDLAT
+*/
+POKE32(0xfd350048, 0x3f3f1707)
+
+
+/*
+FLI7540_mixer16.BDCRIS
+*/
+POKE32(0xfd350050, 0x00101010)
+
+
+/*
+FLI7540_mixer16.BDHPP
+*/
+POKE32(0xfd350058, 0x00000707)
+
+
+/*
+FLI7540_mixer16.BDQTHD
+*/
+POKE32(0xfd350060, 0x00000002)
+
+
+/*
+FLI7540_mixer16.BDLDINEF
+*/
+POKE32(0xfd350068, 0x00222190)
+
+
+/*
+FLI7540_mixer16.BDSTINEF
+*/
+POKE32(0xfd350070, 0x00222190)
+
+
+/*
+FLI7540_mixer16.INFLWREG
+*/
+POKE32(0xfd350080, 0x1f2f3f7f)
+
+
+/*
+FLI7540_mixer16.ARBFLWREG
+*/
+POKE32(0xfd350088, 0x2f070003)
+
+
+/*
+FLI7540_mixer16.BKFLWREG
+*/
+POKE32(0xfd350090, 0x0e0c4032)
+
+
+/*
+FLI7540_mixer16.HPPFLWREG1
+*/
+POKE32(0xfd3500a0, 0x1f032080)
+
+
+/*
+FLI7540_mixer16.HPPFLWREG2
+*/
+POKE32(0xfd3500a8, 0x0030004c)
+
+
+/*
+FLI7540_mixer16.REQMEM
+*/
+POKE32(0xfd3500b0, 0x00800040)
+
+
+/*
+FLI7540_mixer16.RESMEM
+*/
+POKE32(0xfd3500b8, 0x02000080)
+
+
+/*
+FLI7540_mixer16.RESMEM0
+*/
+POKE32(0xfd3500c0, 0x01000080)
+
+
+/*
+FLI7540_mixer16.RESMEM1
+*/
+POKE32(0xfd3500c8, 0x01000080)
+
+
+/*
+FLI7540_mixer16.GENP0
+*/
+POKE32(0xfd3501c0, 0x104018ca)
+
+
+/*
+FLI7540_mixer16.SPBKREG_0
+*/
+POKE32(0xfd350200, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_1
+*/
+POKE32(0xfd350204, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_2
+*/
+POKE32(0xfd350208, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_3
+*/
+POKE32(0xfd35020c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_4
+*/
+POKE32(0xfd350210, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_5
+*/
+POKE32(0xfd350214, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_6
+*/
+POKE32(0xfd350218, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_7
+*/
+POKE32(0xfd35021c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_8
+*/
+POKE32(0xfd350220, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_9
+*/
+POKE32(0xfd350224, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_10
+*/
+POKE32(0xfd350228, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_11
+*/
+POKE32(0xfd35022c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_12
+*/
+POKE32(0xfd350230, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_13
+*/
+POKE32(0xfd350234, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_14
+*/
+POKE32(0xfd350238, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_15
+*/
+POKE32(0xfd35023c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_16
+*/
+POKE32(0xfd350240, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_17
+*/
+POKE32(0xfd350244, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_18
+*/
+POKE32(0xfd350248, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_19
+*/
+POKE32(0xfd35024c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_20
+*/
+POKE32(0xfd350250, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_21
+*/
+POKE32(0xfd350254, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_22
+*/
+POKE32(0xfd350258, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_23
+*/
+POKE32(0xfd35025c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_24
+*/
+POKE32(0xfd350260, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_25
+*/
+POKE32(0xfd350264, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_26
+*/
+POKE32(0xfd350268, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_27
+*/
+POKE32(0xfd35026c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_28
+*/
+POKE32(0xfd350270, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_29
+*/
+POKE32(0xfd350274, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_30
+*/
+POKE32(0xfd350278, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_31
+*/
+POKE32(0xfd35027c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_32
+*/
+POKE32(0xfd350280, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_33
+*/
+POKE32(0xfd350284, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_34
+*/
+POKE32(0xfd350288, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_35
+*/
+POKE32(0xfd35028c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_36
+*/
+POKE32(0xfd350290, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_37
+*/
+POKE32(0xfd350294, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_38
+*/
+POKE32(0xfd350298, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_39
+*/
+POKE32(0xfd35029c, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_40
+*/
+POKE32(0xfd3502a0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_41
+*/
+POKE32(0xfd3502a4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_42
+*/
+POKE32(0xfd3502a8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_43
+*/
+POKE32(0xfd3502ac, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_44
+*/
+POKE32(0xfd3502b0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_45
+*/
+POKE32(0xfd3502b4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_46
+*/
+POKE32(0xfd3502b8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_47
+*/
+POKE32(0xfd3502bc, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_48
+*/
+POKE32(0xfd3502c0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_49
+*/
+POKE32(0xfd3502c4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_50
+*/
+POKE32(0xfd3502c8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_51
+*/
+POKE32(0xfd3502cc, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_52
+*/
+POKE32(0xfd3502d0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_53
+*/
+POKE32(0xfd3502d4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_54
+*/
+POKE32(0xfd3502d8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_55
+*/
+POKE32(0xfd3502dc, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_56
+*/
+POKE32(0xfd3502e0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_57
+*/
+POKE32(0xfd3502e4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_58
+*/
+POKE32(0xfd3502e8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_59
+*/
+POKE32(0xfd3502ec, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_60
+*/
+POKE32(0xfd3502f0, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_61
+*/
+POKE32(0xfd3502f4, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_62
+*/
+POKE32(0xfd3502f8, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPBKREG_63
+*/
+POKE32(0xfd3502fc, 0x00080706)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_0
+*/
+POKE32(0xfd350400, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_1
+*/
+POKE32(0xfd350404, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_2
+*/
+POKE32(0xfd350408, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_3
+*/
+POKE32(0xfd35040c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_4
+*/
+POKE32(0xfd350410, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_5
+*/
+POKE32(0xfd350414, 0x09090809)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_6
+*/
+POKE32(0xfd350418, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_7
+*/
+POKE32(0xfd35041c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_8
+*/
+POKE32(0xfd350420, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_9
+*/
+POKE32(0xfd350424, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_10
+*/
+POKE32(0xfd350428, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_11
+*/
+POKE32(0xfd35042c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_12
+*/
+POKE32(0xfd350430, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_13
+*/
+POKE32(0xfd350434, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_14
+*/
+POKE32(0xfd350438, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_15
+*/
+POKE32(0xfd35043c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_16
+*/
+POKE32(0xfd350440, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_17
+*/
+POKE32(0xfd350444, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_18
+*/
+POKE32(0xfd350448, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_19
+*/
+POKE32(0xfd35044c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_20
+*/
+POKE32(0xfd350450, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_21
+*/
+POKE32(0xfd350454, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_22
+*/
+POKE32(0xfd350458, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_23
+*/
+POKE32(0xfd35045c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_24
+*/
+POKE32(0xfd350460, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_25
+*/
+POKE32(0xfd350464, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_26
+*/
+POKE32(0xfd350468, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_27
+*/
+POKE32(0xfd35046c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_28
+*/
+POKE32(0xfd350470, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_29
+*/
+POKE32(0xfd350474, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_30
+*/
+POKE32(0xfd350478, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_31
+*/
+POKE32(0xfd35047c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_32
+*/
+POKE32(0xfd350480, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_33
+*/
+POKE32(0xfd350484, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_34
+*/
+POKE32(0xfd350488, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_35
+*/
+POKE32(0xfd35048c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_36
+*/
+POKE32(0xfd350490, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_37
+*/
+POKE32(0xfd350494, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_38
+*/
+POKE32(0xfd350498, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_39
+*/
+POKE32(0xfd35049c, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_40
+*/
+POKE32(0xfd3504a0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_41
+*/
+POKE32(0xfd3504a4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_42
+*/
+POKE32(0xfd3504a8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_43
+*/
+POKE32(0xfd3504ac, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_44
+*/
+POKE32(0xfd3504b0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_45
+*/
+POKE32(0xfd3504b4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_46
+*/
+POKE32(0xfd3504b8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_47
+*/
+POKE32(0xfd3504bc, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_48
+*/
+POKE32(0xfd3504c0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_49
+*/
+POKE32(0xfd3504c4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_50
+*/
+POKE32(0xfd3504c8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_51
+*/
+POKE32(0xfd3504cc, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_52
+*/
+POKE32(0xfd3504d0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_53
+*/
+POKE32(0xfd3504d4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_54
+*/
+POKE32(0xfd3504d8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_55
+*/
+POKE32(0xfd3504dc, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_56
+*/
+POKE32(0xfd3504e0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_57
+*/
+POKE32(0xfd3504e4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_58
+*/
+POKE32(0xfd3504e8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_59
+*/
+POKE32(0xfd3504ec, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_60
+*/
+POKE32(0xfd3504f0, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_61
+*/
+POKE32(0xfd3504f4, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_62
+*/
+POKE32(0xfd3504f8, 0x09090909)
+
+
+/*
+FLI7540_mixer16.SPSRCREG_63
+*/
+POKE32(0xfd3504fc, 0x09090909)
+
+
+/*
+FLI7540_pctl16.PHY_PLLCR
+*/
+OR32(0xfd360418, 0x0005c000)
+
+
+/*
+FLI7540_pctl16.TOGCNT1U
+*/
+POKE32(0xfd3600c0, 0x000000f0)
+
+
+/*
+FLI7540_pctl16.TINIT
+*/
+POKE32(0xfd3600c4, 0x000000c8)
+
+
+/*
+FLI7540_pctl16.TRSTH
+*/
+POKE32(0xfd3600c8, 0x00000000)
+
+
+/*
+FLI7540_pctl16.TOGCNT100N
+*/
+POKE32(0xfd3600cc, 0x00000018)
+
+
+/*
+FLI7540_pctl16.PHY_PTR1
+*/
+POKE32(0xfd360420, 0x5de604b0)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x00010000, 0x00010000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+POKE32(0xfd360484, 0x24980002)
+
+
+/*
+FLI7540_pctl16.POWCTL
+*/
+POKE32(0xfd360044, 0x00000001)
+
+
+/*
+FLI7540_pctl16.POWSTAT
+*/
+WHILE_NE32(0xfd360048, 0x00000001, 0x00000001)
+
+
+/*
+FLI7540_pctl16.MCFG
+*/
+POKE32(0xfd360080, 0x00060041)
+
+
+/*
+FLI7540_pctl16.PPCFG
+*/
+POKE32(0xfd360084, 0x00000000)
+
+
+/*
+FLI7540_pctl16.ODTCFG
+*/
+POKE32(0xfd36008c, 0x00000008)
+
+
+/*
+FLI7540_pctl16.DQSECFG
+*/
+POKE32(0xfd360090, 0x00112111)
+
+
+/*
+FLI7540_pctl16.TREFI
+*/
+POKE32(0xfd3600d0, 0x0000004e)
+
+
+/*
+FLI7540_pctl16.TMRD
+*/
+POKE32(0xfd3600d4, 0x00000002)
+
+
+/*
+FLI7540_pctl16.TRFC
+*/
+POKE32(0xfd3600d8, 0x0000003e)
+
+
+/*
+FLI7540_pctl16.TRP
+*/
+POKE32(0xfd3600dc, 0x00000006)
+
+
+/*
+FLI7540_pctl16.TRTW
+*/
+POKE32(0xfd3600e0, 0x00000006)
+
+
+/*
+FLI7540_pctl16.TAL
+*/
+POKE32(0xfd3600e4, 0x00000003)
+
+
+/*
+FLI7540_pctl16.TCL
+*/
+POKE32(0xfd3600e8, 0x00000007)
+
+
+/*
+FLI7540_pctl16.TCWL
+*/
+POKE32(0xfd3600ec, 0x00000006)
+
+
+/*
+FLI7540_pctl16.TRAS
+*/
+POKE32(0xfd3600f0, 0x00000016)
+
+
+/*
+FLI7540_pctl16.TRC
+*/
+POKE32(0xfd3600f4, 0x0000001b)
+
+
+/*
+FLI7540_pctl16.TRCD
+*/
+POKE32(0xfd3600f8, 0x00000006)
+
+
+/*
+FLI7540_pctl16.TRRD
+*/
+POKE32(0xfd3600fc, 0x00000005)
+
+
+/*
+FLI7540_pctl16.TRTP
+*/
+POKE32(0xfd360100, 0x00000004)
+
+
+/*
+FLI7540_pctl16.TWR
+*/
+POKE32(0xfd360104, 0x00000007)
+
+
+/*
+FLI7540_pctl16.TWTR
+*/
+POKE32(0xfd360108, 0x00000004)
+
+
+/*
+FLI7540_pctl16.TEXSR
+*/
+POKE32(0xfd36010c, 0x000000c8)
+
+
+/*
+FLI7540_pctl16.TXP
+*/
+POKE32(0xfd360110, 0x00000003)
+
+
+/*
+FLI7540_pctl16.TXPDLL
+*/
+POKE32(0xfd360114, 0x00000007)
+
+
+/*
+FLI7540_pctl16.TCKE
+*/
+POKE32(0xfd36012c, 0x00000003)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80100000)
+DELAY(1)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80100001)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80140003)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80160003)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x801205e3)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x8010d733)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80100001)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80100002)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80100002)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x8010c733)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+DELAY(1)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x80123de3)
+DELAY(1)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+POKE32(0xfd360040, 0x821205e3)
+
+
+/*
+FLI7540_pctl16.MCMD
+*/
+WHILE_NE32(0xfd360040, 0x80000000, 0x00000000)
+
+
+/*
+FLI7540_pctl16.SCTL
+*/
+POKE32(0xfd360004, 0x00000001)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+OR32(0xfd360484, 0x00020000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+OR32(0xfd360484, 0x00020000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x00040000, 0x00040000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x00200000, 0x00200000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+OR32(0xfd360484, 0xfcff0000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x00400000, 0x00400000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+OR32(0xfd360484, 0xfcff0000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x01000000, 0x01000000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x02000000, 0x02000000)
+
+
+/*
+FLI7540_pctl16.PHY_DX0LCDLR1
+*/
+POKE32(0xfd3605e4, 0x0000241d)
+
+
+/*
+FLI7540_pctl16.PHY_DX1LCDLR1
+*/
+POKE32(0xfd360624, 0x0000221d)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x08000000, 0x08000000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x10000000, 0x10000000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x40000000, 0x40000000)
+
+
+/*
+FLI7540_pctl16.PUB_SMCTL
+*/
+WHILE_NE32(0xfd360484, 0x80000000, 0x80000000)
+
+
+/*
+FLI7540_pctl16.PHYPVTCFG
+*/
+POKE32(0xfd360300, 0x000045d0)
+
+
+/*
+FLI7540_pctl16.PHYTUPDWAIT
+*/
+POKE32(0xfd360320, 0x00000003)
+
+
+/*
+FLI7540_pctl16.PVTTUPDWAIT
+*/
+POKE32(0xfd360324, 0x00000003)
+
+
+/*
+FLI7540_pctl16.PHYIOCRV1
+*/
+POKE32(0xfd36031c, 0x00004305)
+
+
+/*
+FLI7540_pctl16.SCTL
+*/
+POKE32(0xfd360004, 0x00000002)
+
+
+/*
+FLI7540_pctl16.PHY_PIR
+*/
+UPDATE32(0xfd360404, 0xefffffff, 0x00000000)
diff --git a/board/st/fudb/fudb.c b/board/st/fudb/fudb.c
new file mode 100644
index 0000000..72be75d
--- /dev/null
+++ b/board/st/fudb/fudb.c
@@ -0,0 +1,212 @@
+/*
+ * (C) Copyright 2009-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/fli7540reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/soc.h>
+#include <i2c.h>
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+#if (CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE)	/* UART #1 */
+	/* Route UART #1 via PIO9 for TX, RX, CTS & RTS */
+	SET_PIO_ASC(PIO_PORT(9), 3, 2, STPIO_NO_PIN, STPIO_NO_PIN);
+#elif (CFG_STM_ASC_BASE == ST40_ASC1_REGS_BASE)	/* UART #2 */
+	/* Route UART #2 via PIO25 for TX, RX, CTS & RTS */
+	SET_PIO_ASC(PIO_PORT(25), 5, 4, 3, 2);
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+	unsigned long sysconf;
+
+	/*
+	 * CFG_COMMS_CONFIG_2[13] = spi_enable = 0
+	 * i.e. disable the SPI boot-controller.
+	 */
+	sysconf = readl(CFG_COMMS_CONFIG_2);
+	sysconf &= ~(1ul<<13);
+	writel(sysconf, CFG_COMMS_CONFIG_2);
+
+	/*
+	 *	For both S/W "bit-banging" and H/W SSC, the SPI is on PIO17[5:0].
+	 *	Now, we set up the PIO pins correctly.
+	 */
+	SET_PIO_PIN(PIO_PORT(20),5,STPIO_IN);	/* SPI_MISO */
+	SET_PIO_PIN(PIO_PORT(20),2,STPIO_OUT);	/* SPI_CSN */
+#if defined(CONFIG_SOFT_SPI)	/* Configure SPI Serial Flash for PIO "bit-banging" */
+	SET_PIO_PIN(PIO_PORT(21),2,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(21),3,STPIO_OUT);	/* SPI_MOSI */
+#elif defined(CONFIG_STM_SSC_SPI)		/* Use the H/W SSC for SPI */
+	SET_PIO_PIN(PIO_PORT(21),2,STPIO_ALT_OUT);/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(21),3,STPIO_ALT_OUT);/* SPI_MOSI */
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* drive (non-SSC) outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(20), 2, 1);	/* deassert SPI_CSN */
+#if defined(CONFIG_SOFT_SPI)
+	STPIO_SET_PIN(PIO_PORT(21), 2, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(21), 3, 0);	/* deassert SPI_MOSI */
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
+
+#if defined(CONFIG_SOFT_I2C)
+static void configI2c(void)
+{
+	/*
+	 * The I2C busses are routed as follows:
+	 *
+	 *	Bus	  SCL		  SDA
+	 *	---	  ---		  ---
+	 *	 1	PIO10[2]	PIO10[3]
+	 *	 2	PIO9[4]		PIO9[5]
+	 *	 3	PIO26[7]	PIO27[6]
+	 */
+#if defined(CONFIG_I2C_BUS_1)			/* Use I2C Bus "1" */
+	SET_PIO_PIN(PIO_PORT(10),2,STPIO_BIDIR);/* I2C1_SCL */
+	SET_PIO_PIN(PIO_PORT(10),3,STPIO_BIDIR);/* I2C1_SDA */
+#elif defined(CONFIG_I2C_BUS_2)			/* Use I2C Bus "2" */
+	SET_PIO_PIN(PIO_PORT(9),4,STPIO_BIDIR);	/* I2C2_SCL */
+	SET_PIO_PIN(PIO_PORT(9),5,STPIO_BIDIR);	/* I2C2_SDA */
+#elif defined(CONFIG_I2C_BUS_3)			/* Use I2C Bus "3" */
+	SET_PIO_PIN(PIO_PORT(26),7,STPIO_BIDIR);/* I2C3_SCL */
+	SET_PIO_PIN(PIO_PORT(27),6,STPIO_BIDIR);/* I2C3_SDA */
+#else
+#error Unknown I2C Bus!
+#endif
+}
+
+extern void fli7540_i2c_scl(const int val)
+{
+#if defined(CONFIG_I2C_BUS_1)			/* Use I2C Bus "1" */
+	STPIO_SET_PIN(PIO_PORT(10), 2, (val) ? 1 : 0);
+#elif defined(CONFIG_I2C_BUS_2)			/* Use I2C Bus "2" */
+	STPIO_SET_PIN(PIO_PORT(9), 4, (val) ? 1 : 0);
+#elif defined(CONFIG_I2C_BUS_3)			/* Use I2C Bus "3" */
+	STPIO_SET_PIN(PIO_PORT(26), 7, (val) ? 1 : 0);
+#endif
+}
+
+extern void fli7540_i2c_sda(const int val)
+{
+#if defined(CONFIG_I2C_BUS_1)			/* Use I2C Bus "1" */
+	STPIO_SET_PIN(PIO_PORT(10), 3, (val) ? 1 : 0);
+#elif defined(CONFIG_I2C_BUS_2)			/* Use I2C Bus "2" */
+	STPIO_SET_PIN(PIO_PORT(9), 5, (val) ? 1 : 0);
+#elif defined(CONFIG_I2C_BUS_3)			/* Use I2C Bus "3" */
+	STPIO_SET_PIN(PIO_PORT(27), 6, (val) ? 1 : 0);
+#endif
+}
+
+extern int fli7540_i2c_read(void)
+{
+#if defined(CONFIG_I2C_BUS_1)			/* Use I2C Bus "1" */
+	return STPIO_GET_PIN(PIO_PORT(10), 3);
+#elif defined(CONFIG_I2C_BUS_2)			/* Use I2C Bus "2" */
+	return STPIO_GET_PIN(PIO_PORT(9), 5);
+#elif defined(CONFIG_I2C_BUS_3)			/* Use I2C Bus "3" */
+	return STPIO_GET_PIN(PIO_PORT(27), 6);
+#endif
+}
+#endif	/* CONFIG_SOFT_I2C */
+
+#if defined(CONFIG_I2C_CMD_TREE)
+extern unsigned int i2c_get_bus_speed(void)
+{
+	return CFG_I2C_SPEED;
+}
+extern int i2c_set_bus_speed(unsigned int speed)
+{
+	return -1;
+}
+#endif	/* CONFIG_I2C_CMD_TREE */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	fli7540_configure_ethernet (fli7540_ethernet_rmii, 0, 0);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+#if defined(CONFIG_SOFT_I2C)
+	/* Configuration for the I2C bus */
+	configI2c();
+#endif	/* CONFIG_SOFT_I2C */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: FLI7540 Development Board"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#if defined(CONFIG_SPI)
+	/*
+	 * Configure for the SPI Serial Flash.
+	 * Note: for CFG_BOOT_FROM_SPI + CFG_ENV_IS_IN_EEPROM, this
+	 * needs to be done after env_init(), hence it is done
+	 * here, and not in board_init().
+	 */
+	configSpi();
+#endif	/* CONFIG_SPI */
+
+	return 0;
+}
diff --git a/board/st/fudb/init-fudb.S b/board/st/fudb/init-fudb.S
new file mode 100644
index 0000000..0c96e1f
--- /dev/null
+++ b/board/st/fudb/init-fudb.S
@@ -0,0 +1,55 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#undef CONFIG_SH_OLD_POKE_LOOP_PARADIGM
+
+
+#include "asm/fli7540reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --show-comment <stmc2>:fudb_gpd201:st40host,boot_companions=0
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "fudb_gpd201" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even though U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "fli7540.romgen"
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/fudb/nand.c b/board/st/fudb/nand.c
new file mode 100644
index 0000000..793881c
--- /dev/null
+++ b/board/st/fudb/nand.c
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2010 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/fli7540reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
+#else
+#error It is not possible to use bit-banging with NAND on the Freeman Ultra Development Board.
+#endif /* CFG_NAND_FLEX_MODE */
+
+
diff --git a/board/st/hdk5289/Makefile b/board/st/hdk5289/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/hdk5289/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hdk5289/config.mk b/board/st/hdk5289/config.mk
new file mode 100644
index 0000000..564f440
--- /dev/null
+++ b/board/st/hdk5289/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HDK5289 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x93F00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x93F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hdk5289/hdk5289.c b/board/st/hdk5289/hdk5289.c
new file mode 100644
index 0000000..13b95ee
--- /dev/null
+++ b/board/st/hdk5289/hdk5289.c
@@ -0,0 +1,122 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx5206reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+static void phy_reset(void)
+{
+	/*
+	 * Reset the Ethernet PHY.
+	 *
+	 *	PIO2[2] = ETH_RESET
+	 *
+	 */
+	STPIO_SET_PIN(PIO_PORT(2), 2, 0);
+	udelay(15000);				/* 15 ms */
+	STPIO_SET_PIN(PIO_PORT(2), 2, 1);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Route the GPIO block to the PIOx pads, as by
+	 * default the SATFE owns them... (why, oh why???) */
+	sysconf = *STX5206_SYSCONF_SYS_CFG10;
+	sysconf |= 1ul << 13;
+	*STX5206_SYSCONF_SYS_CFG10 = sysconf;
+
+#if CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART2 = AS0 */
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 1, STPIO_NO_PIN, STPIO_NO_PIN);
+
+	/* Route UART2 via PIO1 for TX, RX */
+	sysconf = *STX5206_SYSCONF_SYS_CFG16;
+	/* PIO1[1] CFG16[9,1]   AltFunction = 1 */
+	/* PIO1[2] CFG16[10,2]  AltFunction = 1 */
+	/* PIO1[3] CFG16[11,3]  AltFunction = 0 */
+	/* PIO1[4] CFG16[12,4]  AltFunction = 0 */
+	sysconf &= ~(0x0303ul<<1);	/* 0,0,3,3 */
+	sysconf |=  (0x0000ul<<1);	/* 0,0,0,0 */
+	*STX5206_SYSCONF_SYS_CFG16 = sysconf;
+#else
+#error Unknown ASC port selected!
+#endif	/* CFG_STM_ASC_BASE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/*
+	 * Configure the Ethernet PHY Reset signal
+	 *	PIO2[2] = ETH_RESET
+	 */
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_OUT);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/* Reset the PHY */
+	phy_reset();
+
+	stx5206_configure_ethernet(stx5206_ethernet_mii, 0, 0);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx5289-HDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/hdk5289/init-hdk5289.S b/board/st/hdk5289/init-hdk5289.S
new file mode 100644
index 0000000..5c0858e
--- /dev/null
+++ b/board/st/hdk5289/init-hdk5289.S
@@ -0,0 +1,70 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#undef CONFIG_SH_OLD_POKE_LOOP_PARADIGM
+
+
+#include "asm/stx5206reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+#ifdef QQQ	/* QQQ - DELETE */
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --show-comment <stmc2>:mb796stx5206:st40,boot_companions=0
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb796stx5206" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "hdk5289-stx5206.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX5206_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
+#endif	/* CONFIG_SH_SE_MODE */
+#endif		/* QQQ - DELETE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk5289/nand.c b/board/st/hdk5289/nand.c
new file mode 100644
index 0000000..954e2bd
--- /dev/null
+++ b/board/st/hdk5289/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2010 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx5206reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void hdk5289_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int hdk5289_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = hdk5289_device_ready;
+	nand->hwcontrol     = hdk5289_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/hdk7108/Makefile b/board/st/hdk7108/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/hdk7108/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hdk7108/config.mk b/board/st/hdk7108/config.mk
new file mode 100644
index 0000000..86cf4fd
--- /dev/null
+++ b/board/st/hdk7108/config.mk
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2008,2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HDK7108 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hdk7108/hdk7108-stx7108.romgen b/board/st/hdk7108/hdk7108-stx7108.romgen
new file mode 100644
index 0000000..9b2deb4
--- /dev/null
+++ b/board/st/hdk7108/hdk7108-stx7108.romgen
@@ -0,0 +1,2124 @@
+/*
+This file was automatically generated on Thu 01 Jul 10 at 18:01:35 by user mcgoogan, host hoiho.bri.st.com using romgen R1.4.0 with the ST TargetPack hdk7108stx7108
+
+TargetPack files used:
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk7108stx7108/hdk7108stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk7108stx7108/hdk7108stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk7108stx7108/hdk7108stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk7108stx7108/tm1668_fp.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk7108stx7108/tm1668_fp.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/jtag_core.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_ccn_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_addr_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_data_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_regs.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/debug/tapmux.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_emi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/tapmux.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/l2_cache_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3mixer_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3pctl_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3phy_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgena_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgenb_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_ddrdbg.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_0_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_1_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_2_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_3_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_4_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/__init__.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/jtag.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/utilities/utilities.py
+*/
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfde98014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfde98024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfde98000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xfff80000, 0x00003203)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfde98000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfde98004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xfff80000, 0x00018709)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfde98004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xffefffff, 0x00000000)
+POKE32(0xfde98908, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffffcf, 0x00000010)
+POKE32(0xfde9890c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffff3f, 0x00000040)
+POKE32(0xfde98a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffffcff, 0x00000100)
+POKE32(0xfde98a14, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffff3ff, 0x00000400)
+POKE32(0xfde98b18, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffcfff, 0x00002000)
+POKE32(0xfde98a1c, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffff3fff, 0x00004000)
+POKE32(0xfde98a20, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffcffff, 0x00010000)
+POKE32(0xfde98a24, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfff3ffff, 0x00040000)
+POKE32(0xfde98a28, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffcfffff, 0x00100000)
+POKE32(0xfde98a2c, 0x0000000e)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xff3fffff, 0x00400000)
+POKE32(0xfde98a30, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfcffffff, 0x01000000)
+POKE32(0xfde98a34, 0x00000009)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xf3ffffff, 0x04000000)
+POKE32(0xfde98b38, 0x00000011)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xcfffffff, 0x20000000)
+POKE32(0xfde98a3c, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0x3fffffff, 0x40000000)
+POKE32(0xfde98b40, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffffc, 0x00000002)
+POKE32(0xfde98b44, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfdab8014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfdab8024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfdab8000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xfff80000, 0x00004e07)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfdab8000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfdab8004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xfff80000, 0x00002803)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfdab8004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xffefffff, 0x00000000)
+POKE32(0xfdab8b04, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffff3, 0x00000008)
+POKE32(0xfdab8b08, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffffcf, 0x00000020)
+POKE32(0xfdab8b0c, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffff3f, 0x00000080)
+POKE32(0xfdab8a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffcff, 0x00000100)
+POKE32(0xfdab8b14, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffff3ff, 0x00000800)
+POKE32(0xfdab8b1c, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffff3fff, 0x00008000)
+POKE32(0xfdab8b20, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffcffff, 0x00020000)
+POKE32(0xfdab8b24, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfff3ffff, 0x00080000)
+POKE32(0xfdab8b28, 0x0000001f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffcfffff, 0x00200000)
+POKE32(0xfdab8b2c, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xff3fffff, 0x00800000)
+POKE32(0xfdab8b30, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfcffffff, 0x02000000)
+POKE32(0xfdab8b34, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xf3ffffff, 0x08000000)
+POKE32(0xfdab8a38, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xcfffffff, 0x10000000)
+POKE32(0xfdab8b3c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0x3fffffff, 0x80000000)
+POKE32(0xfdab8b40, 0x0000000f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffffc, 0x00000002)
+POKE32(0xfdab8b44, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c0de)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfd5460b8, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_MD3
+*/
+POKE32(0xfd546080, 0x00000013)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_PE3
+*/
+POKE32(0xfd546084, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_SDIV3
+*/
+POKE32(0xfd54608c, 0x00000002)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000001)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c1a0)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_0
+*/
+IF_GT32(1, 0xfde20000, 0xf0000000, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x02200200)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_0
+*/
+ELSE(1)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x02200200)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+ENDIF(1)
+POKE32(0x10008000, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe900860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe900800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe900810, 0x00000020)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe900820, 0x00000022)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe900830, 0x0000002c)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe900840, 0x00000030)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe900100, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe900108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe900110, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe900118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe900140, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe900148, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe900150, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe900158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe900180, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe900188, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe900190, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe900198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe9001c0, 0x00c447f9)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe9001c8, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe9001d0, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe9001d8, 0x0000000a)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe900028, 0x00000010)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+UPDATE32(0xfde30028, 0xfffffffd, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+OR32(0xfde30028, 0x00000002)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde52030, 0x00500040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde52038, 0x33220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde521c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde52000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde520a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde52028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde500c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde500c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde500cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde500c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde50410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde50434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+UPDATE32(0xfde5031c, 0xfffffffb, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde50044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde50048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde50080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde50084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde5008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde50090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde500d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde500d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde500d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde500dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde500e0, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde500e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde500e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde500ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde500f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde500f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde500f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde500fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde50100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde50104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde50108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde5010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde50110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde50114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde50118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde5011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde50120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde50124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde50128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde5012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde50130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde50134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde50138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00140083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00120043)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde50484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde50300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde50320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000003)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+UPDATE32(0xfde30028, 0xfffffffb, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+OR32(0xfde30028, 0x00000004)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde72030, 0x00900080)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde72038, 0x33220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde721c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde72000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde720a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde72028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde700c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde700c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde700cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde700c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde70410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde70434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+UPDATE32(0xfde7031c, 0xfffffffb, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde70044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde70048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde70080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde70084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde7008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde70090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde700d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde700d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde700d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde700dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde700e0, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde700e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde700e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde700ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde700f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde700f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde700f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde700fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde70100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde70104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde70108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde7010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde70110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde70114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde70118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde7011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde70120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde70124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde70128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde7012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde70130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde70134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde70138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00140083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00120043)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde70484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde70300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde70320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000003)
+UPDATE32(0xfdea3a00, 0x00000000, 0x0a0d0b0c)
+UPDATE32(0xfd2e0004, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd2e0008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd2e000c, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd2e0010, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd2e0014, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd2e0018, 0x0000ffff, 0x00000000)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfd544010, 0xffff5f1c, 0x000000a3)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfd5440b0, 0xffffff00, 0x000000a3)
+ENDIF(1)
+UPDATE32(0xfe76b0fc, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5450ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5450f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5450f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5450f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5450fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5451ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5451f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5451f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5451f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5451fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5452ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5452f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5452f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5452f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5452fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5453ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5453f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5453f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5453f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5453fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd545efc, 0xfffffff8, 0x00000005)
+UPDATE32(0xfde00030, 0xfffffff8, 0x00000006)
+UPDATE32(0xfde00034, 0xfffffff8, 0x00000001)
+UPDATE32(0xfde00038, 0xfffffff8, 0x00000000)
+UPDATE32(0xfde0004c, 0xfffffc00, 0x00000000)
+UPDATE32(0xfde00050, 0xfffffc00, 0x00000000)
+UPDATE32(0xfde00108, 0x1fffffff, 0xa0000000)
+UPDATE32(0xfde0010c, 0xfffffff8, 0x00000005)
+UPDATE32(0xfde00110, 0xfff8f8f8, 0x00010202)
+UPDATE32(0xfde00114, 0xfff8f8f8, 0x00000000)
+UPDATE32(0xfde20044, 0xfffffffc, 0x00000000)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0004, 0xfffffff8, 0x00000006)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0008, 0xfffffff8, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab000c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0010, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0024, 0xfffffff8, 0x00000006)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0028, 0xfffffff8, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab002c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab002c, 0x0000fff8, 0x00000002)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0030, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0030, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0044, 0xfffffff8, 0x00000006)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0048, 0xfffffff8, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab004c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab004c, 0x0000fff8, 0x00000003)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0050, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0050, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0084, 0xfffffff8, 0x00000006)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0088, 0xfffffff8, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab008c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab008c, 0x0000fff8, 0x00000002)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0090, 0xfffffff0, 0x00000001)
+ENDIF(1)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0090, 0xfffffff0, 0x00000001)
+ENDIF(1)
+UPDATE32(0xfd002024, 0xfff01fff, 0x0003c000)
+UPDATE32(0xfd003024, 0xfff01fff, 0x0003c000)
+UPDATE32(0xfd004024, 0xfff01fff, 0x0003c000)
+IF_EQ32(1, 0xfe7000b8, 0x00000001, 0x00000000)
+  UPDATE32(0xfe0fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+IF_EQ32(1, 0xfe7000b8, 0x00000002, 0x00000000)
+  UPDATE32(0xfe1fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+IF_EQ32(1, 0xfe7000b8, 0x00000004, 0x00000000)
+  UPDATE32(0xfe2fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+IF_EQ32(1, 0xfda500d4, 0x00000001, 0x00000001)
+  UPDATE32(0xfda8f000, 0xffd00000, 0x0026c207)
+ENDIF(1)
+IF_EQ32(1, 0xfda500d4, 0x00000001, 0x00000001)
+  UPDATE32(0xfda89000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+IF_EQ32(1, 0xfe70010c, 0x00000001, 0x00000001)
+  UPDATE32(0xfe737000, 0xffd00000, 0x0026c207)
+ENDIF(1)
+IF_EQ32(1, 0xfe70010c, 0x00000001, 0x00000001)
+  UPDATE32(0xfe731000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+IF_EQ32(1, 0xfda50078, 0x00000004, 0x00000000)
+  UPDATE32(0xfdaa9744, 0xffd00000, 0x0026c207)
+ENDIF(1)
+
+
+#if 0		/* added by Sean McGoogan <Sean.McGoogan@st.com> */
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY2
+*/
+POKE32(0xf7100200, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY2
+*/
+POKE32(0xf6100200, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY3
+*/
+POKE32(0xf7100300, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY3
+*/
+POKE32(0xf6100300, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY4
+*/
+POKE32(0xf7100400, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY4
+*/
+POKE32(0xf6100400, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY5
+*/
+POKE32(0xf7100500, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY5
+*/
+POKE32(0xf6100500, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY6
+*/
+POKE32(0xf7100600, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY6
+*/
+POKE32(0xf6100600, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY7
+*/
+POKE32(0xf7100700, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY7
+*/
+POKE32(0xf6100700, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY8
+*/
+POKE32(0xf7100800, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY8
+*/
+POKE32(0xf6100800, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY9
+*/
+POKE32(0xf7100900, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY9
+*/
+POKE32(0xf6100900, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY10
+*/
+POKE32(0xf7100a00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY10
+*/
+POKE32(0xf6100a00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY11
+*/
+POKE32(0xf7100b00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY11
+*/
+POKE32(0xf6100b00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY12
+*/
+POKE32(0xf7100c00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY12
+*/
+POKE32(0xf6100c00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY13
+*/
+POKE32(0xf7100d00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY13
+*/
+POKE32(0xf6100d00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY14
+*/
+POKE32(0xf7100e00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY14
+*/
+POKE32(0xf6100e00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY15
+*/
+POKE32(0xf7100f00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY15
+*/
+POKE32(0xf6100f00, 0x80000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x40000188)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0xa0000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x80000188)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+OR32(0xff000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+IF_EQ32(1, 0xff000010, 0x00000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+  UPDATE32(0xff000010, 0xffffffef, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+ELSE(1)
+
+
+/*
+st40_ccn_regs.CCN_PASCR
+*/
+  UPDATE32(0xff000070, 0x7fffffff, 0x80000000)
+ENDIF(1)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+#endif	/* added by Sean McGoogan <Sean.McGoogan@st.com> */
diff --git a/board/st/hdk7108/hdk7108.c b/board/st/hdk7108/hdk7108.c
new file mode 100644
index 0000000..9540153
--- /dev/null
+++ b/board/st/hdk7108/hdk7108.c
@@ -0,0 +1,156 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7108reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* QQQ - TO DO */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* QQQ - TO DO */
+}
+
+
+#define PIOALT(port, pin, alt, dir)			\
+do							\
+{							\
+	stx7108_pioalt_select((port), (pin), (alt));	\
+	stx7108_pioalt_pad((port), (pin), (dir));	\
+} while(0)
+
+static void configPIO(void)
+{
+	/* Setup PIOs for ASC device */
+
+#if CFG_STM_ASC_BASE == ST40_ASC1_REGS_BASE
+
+	/* Route UART1 via PIO5 for TX, RX, CTS & RTS (Alternative #1) */
+	PIOALT(5, 1, 1, &stx7108_pioalt_pad_out);	/* UART1-TX */
+	PIOALT(5, 2, 1, &stx7108_pioalt_pad_in);	/* UART1-RX */
+	PIOALT(5, 4, 1, &stx7108_pioalt_pad_out);	/* UART1-RTS */
+	PIOALT(5, 3, 1, &stx7108_pioalt_pad_in);	/* UART1-CTS */
+
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE
+
+	/* Route UART3 via PIO24/25 for TX, RX (Alternative #1) */
+	PIOALT(24, 4, 1, &stx7108_pioalt_pad_out);	/* UART3-TX */
+	PIOALT(24, 5, 1, &stx7108_pioalt_pad_in);	/* UART3-RX */
+//	PIOALT(24, 7, 1, &stx7108_pioalt_pad_out);	/* UART3-RTS */
+//	PIOALT(25, 0, 1, &stx7108_pioalt_pad_in);	/* UART3-CTS */
+
+#else
+#error Unknown ASC port selected!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/*
+	 * Configure the Ethernet PHY Reset signal
+	 *	PIO15[4] == POWER_ON_ETH (a.k.a. ETH_RESET)
+	 */
+	SET_PIO_PIN(PIO_PORT(15), 4, STPIO_OUT);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	/*
+	 * Some of the peripherals are powered by regulators
+	 * controlled by the following PIO line...
+	 *	PIO5[0] == POWER_ON
+	 */
+	SET_PIO_PIN(PIO_PORT(5), 0, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 0, 1);
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+static void phy_reset(void)
+{
+	/*
+	 * Reset the Ethernet PHY.
+	 * Note both PHYs share the *same* reset line.
+	 *
+	 *	PIO15[4] = POWER_ON_ETH (a.k.a. ETH_RESET)
+	 */
+	STPIO_SET_PIN(PIO_PORT(15), 4, 0);
+	udelay(10000);				/* 10 ms */
+	STPIO_SET_PIN(PIO_PORT(15), 4, 1);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+extern int board_init(void)
+{
+	configPIO();
+
+#ifdef QQQ	/* QQQ - DELETE */
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+#endif		/* QQQ - DELETE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/* Reset the PHY */
+	phy_reset();
+#if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0, on MII JP2 */
+	stx7108_configure_ethernet(0, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0, });
+#elif CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE		/* MII1, IC+ IP1001 (UP1) */
+	stx7108_configure_ethernet(1, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+		//QQQ	.mode = stx7108_ethernet_mode_gmii_gtx,
+			.ext_clk = 0,
+			.phy_bus = 1, });
+#else
+#error Unknown base address for the STM GMAC
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+#if defined(CONFIG_CMD_I2C)
+	stx7108_configure_i2c();
+#endif	/* CONFIG_CMD_I2C */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7108-HDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/hdk7108/init-hdk7108.S b/board/st/hdk7108/init-hdk7108.S
new file mode 100644
index 0000000..1dd0172
--- /dev/null
+++ b/board/st/hdk7108/init-hdk7108.S
@@ -0,0 +1,61 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#undef CONFIG_SH_OLD_POKE_LOOP_PARADIGM
+
+
+#include "asm/stx7108reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --show-comment <stmc2>:hdk7108stx7108:host
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "hdk7108stx7108" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * At the time of writing this (July 2010) the output from "romgen"
+	 * needs to be edited slightly.  The edit is just two add two lines
+	 * to comment out all the PMB + 32-bit mode configuration. The lines
+	 * to comment out start with the pokes that setup the PMB arrays,
+	 * and end with pokes that configure the CCN registers.
+	 * That is, the following two lines should be added:
+	 *		#if 0
+	 *		#endif
+	 * See the supplied version of the ".romgen" file, to see where
+	 * these have been added, if there is any doubt.
+	 */
+#include "hdk7108-stx7108.romgen"
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk7108/nand.c b/board/st/hdk7108/nand.c
new file mode 100644
index 0000000..30cbe03
--- /dev/null
+++ b/board/st/hdk7108/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2010 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7108reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void hdk7108_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int hdk7108_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = hdk7108_device_ready;
+	nand->hwcontrol     = hdk7108_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/hmp7100/Makefile b/board/st/hmp7100/Makefile
new file mode 100644
index 0000000..80745c0
--- /dev/null
+++ b/board/st/hmp7100/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hmp7100/config.mk b/board/st/hmp7100/config.mk
new file mode 100644
index 0000000..ee1ef4e
--- /dev/null
+++ b/board/st/hmp7100/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2010
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HMP7100 board
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at SDRAM BASE  + 63M in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hmp7100/hmp7100.c b/board/st/hmp7100/hmp7100.c
new file mode 100644
index 0000000..69b4d39
--- /dev/null
+++ b/board/st/hmp7100/hmp7100.c
@@ -0,0 +1,125 @@
+/*
+ * (C) Copyright 2004,2010 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+extern void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+extern void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Nothing to do! */
+}
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+
+  /*  Setup up ethernet reset */
+#if defined(CONFIG_SMC911X_BASE) && 0	/* QQQ */
+  SET_PIO_PIN(PIO_PORT(2), 7, STPIO_OUT);
+#endif
+#if defined(CONFIG_DRIVER_NETSTMAC)
+  SET_PIO_PIN(PIO_PORT(5), 3, STPIO_OUT);
+#endif
+}
+
+extern int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_SMC911X_BASE) && 0	/* QQQ */
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 7, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 7, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 7, 0);
+#endif
+
+#if defined(CONFIG_DRIVER_NETSTMAC)
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(5), 3, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(5), 3, 0);
+	udelay(2000);
+	STPIO_SET_PIN(PIO_PORT(5), 3, 1);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	/*
+	 * On some HMP7100 boards, the NOR flash for CSAn (EMI Bank #0)
+	 * has been increased to 32MiB. However, the default TargetPacks
+	 * only provide a region of 16MiB for all of CSAn.
+	 * The following will set sizeof(EMI Bank #0) == 32 MiB,
+	 * hence allowing all of the NOR flash to be accessed.
+	 *
+	 * It should be noted, that this will have the side-effect
+	 * of logically disabling CSBn, as EMI Bank #0 will now
+	 * occlude EMI Bank #1.
+	 *
+	 * See https://bugzilla.stlinux.com/show_bug.cgi?id=9065#c27
+	 */
+	*ST40_EMI_BANK1_BASEADDRESS = 0x8;
+
+	return 0;
+}
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: HMP7100"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/hmp7100/init-hmp7100.S b/board/st/hmp7100/init-hmp7100.S
new file mode 100644
index 0000000..ee52106
--- /dev/null
+++ b/board/st/hmp7100/init-hmp7100.S
@@ -0,0 +1,244 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#define CONFIG_SH_OLD_POKE_LOOP_PARADIGM	/* QQQ - DELETE */
+
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT1) /* 266 MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ELSE
+#if (INPUT_CLOCK_RATE == 30)   /* 384 MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_HMP7100_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+#if CONFIG_SH_HMP7100_128
+       POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+#if 1	/* see https://bugzilla.stlinux.com/show_bug.cgi?id=9065#c27 */
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+#else
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+#endif
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ELSE
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+#if defined(CONFIG_SH_SE_MODE) && !defined(CONFIG_SH_STB7109_CUT2)
+  /*
+   * Note that we also manually need to move the System and Video LMI base
+   * addresses to their 32-bit SE mode locations as defined in the datasheet.
+   */
+        UPDATE32(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
+#ifdef CONFIG_SH_HMP7100_128
+        UPDATE32(ST40_LMI_SDRA0_0(SYS), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(SYS), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+#else
+        UPDATE32(ST40_LMI_SDRA0_0(SYS), 0x001FFFFF, (0x44000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(SYS), 0x001FFFFF, (0x44000000 & 0xFFE00000))
+#endif
+        UPDATE32(ST40_LMI_SDRA0_0(VID), 0x001FFFFF, (0x64000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(VID), 0x001FFFFF, (0x64000000 & 0xFFE00000))
+
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb442/init-mb442.S b/board/st/mb442/init-mb442.S
index b4cae18..59bea73 100644
--- a/board/st/mb442/init-mb442.S
+++ b/board/st/mb442/init-mb442.S
@@ -220,16 +220,16 @@ __memory_setup_table:
    * Note that we also manually need to move the System and Video LMI base
    * addresses to their 32-bit SE mode locations as defined in the datasheet.
    */
-        UPDATE_LONG(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
+        UPDATE32(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
 #ifdef CONFIG_SH_MB442_128
-        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x48001a00)
-        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x48001a00)
+        UPDATE32(ST40_LMI_SDRA0_0(SYS), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(SYS), 0x001FFFFF, (0x48000000 & 0xFFE00000))
 #else
-        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x44001900)
-        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x44001900)
+        UPDATE32(ST40_LMI_SDRA0_0(SYS), 0x001FFFFF, (0x44000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(SYS), 0x001FFFFF, (0x44000000 & 0xFFE00000))
 #endif
-        POKE_LONG(ST40_LMI_SDRA0_0(VID), 0x64001900)
-        POKE_LONG(ST40_LMI_SDRA1_0(VID), 0x64001900)
+        UPDATE32(ST40_LMI_SDRA0_0(VID), 0x001FFFFF, (0x64000000 & 0xFFE00000))
+        UPDATE32(ST40_LMI_SDRA1_0(VID), 0x001FFFFF, (0x64000000 & 0xFFE00000))
 
 #endif	/* CONFIG_SH_SE_MODE */
 
diff --git a/board/st/mb519/init-mb519.S b/board/st/mb519/init-mb519.S
index 9c30f68..df83099 100644
--- a/board/st/mb519/init-mb519.S
+++ b/board/st/mb519/init-mb519.S
@@ -366,12 +366,12 @@ __memory_setup_table:
    * their 32-bit SE mode locations as defined in the datasheet and change the
    * 'upper bound addresses' (in row attribute registers) for the LMIs.
    */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+  UPDATE32(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE32(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, (0x88000000 & 0xFFE00000))
+  UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, (0x88000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/st/mb671/init-mb671.S b/board/st/mb671/init-mb671.S
index 46d6259..4d99b0c 100644
--- a/board/st/mb671/init-mb671.S
+++ b/board/st/mb671/init-mb671.S
@@ -53,12 +53,12 @@ __memory_setup_table:
 	 * their 32-bit SE mode locations as defined in the datasheet and change the
 	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
 	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, (0x90000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/st/mb837/Makefile b/board/st/mb837/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/mb837/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb837/config.mk b/board/st/mb837/config.mk
new file mode 100644
index 0000000..31d2ffe
--- /dev/null
+++ b/board/st/mb837/config.mk
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2008,2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB837 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb837/init-mb837.S b/board/st/mb837/init-mb837.S
new file mode 100644
index 0000000..a7c28dd
--- /dev/null
+++ b/board/st/mb837/init-mb837.S
@@ -0,0 +1,61 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#undef CONFIG_SH_OLD_POKE_LOOP_PARADIGM
+
+
+#include "asm/stx7108reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb837stx7108:host
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb837stx7108" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * At the time of writing this (April 2010) the output from "romgen"
+	 * needs to be edited slightly.  The edit is just two add two lines
+	 * to comment out all the PMB + 32-bit mode configuration. The lines
+	 * to comment out start with the pokes that setup the PMB arrays,
+	 * and end with pokes that configure the CCN registers.
+	 * That is, the following two lines should be added:
+	 *		#if 0
+	 *		#endif
+	 * See the supplied version of the ".romgen" file, to see where
+	 * these have been added, if there is any doubt.
+	 */
+#include "mb837-stx7108.romgen"
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb837/mb837-stx7108.romgen b/board/st/mb837/mb837-stx7108.romgen
new file mode 100644
index 0000000..862f5f6
--- /dev/null
+++ b/board/st/mb837/mb837-stx7108.romgen
@@ -0,0 +1,3110 @@
+/*
+This file was automatically generated on Mon 22 Mar 10 at 15:03:36 by user mcgoogans, host hoiho.bri.st.com using romgen R1.4.0 with the ST TargetPack mb837stx7108 using the option --target-connect with the ST Micro Connect hesiod-hti
+
+TargetPack files used:
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb837stx7108/mb837stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb837stx7108/mb837stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb837stx7108/mb837stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb837stx7108/mb837stx7108_epld.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/jtag_core.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_ccn_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_addr_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_data_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_regs.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/debug/tapmux.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_emi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/tapmux.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/l2_cache_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3mixer_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3pctl_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3phy_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgena_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgenb_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_ddrdbg.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_0_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_1_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_2_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_3_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_4_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/__init__.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/jtag.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/utilities/utilities.py
+*/
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfde98014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfde98024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfde98000) (used target peek value 0x80003203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfde98000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfde98010) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfde98000) (used target peek value 0x00183203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xfff80000, 0x00003203)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfde98010) (used target peek value 0x00000001) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfde98000) (used target peek value 0x80103203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfde98000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfde98000) (used target peek value 0x80103203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfde98004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfde98004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfde98010) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfde98004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xfff80000, 0x00018709)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfde98010) (used target peek value 0x00000002) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfde98004) (used target peek value 0x80118709) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfde98004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfde98004) (used target peek value 0x80118709) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xffefffff, 0x00000000)
+POKE32(0xfde98908, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffffcf, 0x00000010)
+POKE32(0xfde9890c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00000010) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffff3f, 0x00000040)
+POKE32(0xfde98a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00000050) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffffcff, 0x00000100)
+POKE32(0xfde98a14, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00000150) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffff3ff, 0x00000400)
+POKE32(0xfde98b18, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00000550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffcfff, 0x00002000)
+POKE32(0xfde98a1c, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00002550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffff3fff, 0x00004000)
+POKE32(0xfde98a20, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00006550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffcffff, 0x00010000)
+POKE32(0xfde98a24, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00016550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfff3ffff, 0x00040000)
+POKE32(0xfde98a28, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00056550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffcfffff, 0x00100000)
+POKE32(0xfde98a2c, 0x0000000e)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00156550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xff3fffff, 0x00400000)
+POKE32(0xfde98a30, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x00556550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfcffffff, 0x01000000)
+POKE32(0xfde98a34, 0x00000009)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x01556550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xf3ffffff, 0x04000000)
+POKE32(0xfde98b38, 0x00000011)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x05556550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xcfffffff, 0x20000000)
+POKE32(0xfde98a3c, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfde98014) (used target peek value 0x25556550) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0x3fffffff, 0x40000000)
+POKE32(0xfde98b40, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfde98024) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffffc, 0x00000002)
+POKE32(0xfde98b44, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfde98024) (used target peek value 0x00000002) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfdab8014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfdab8024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfdab8000) (used target peek value 0x80003203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfdab8000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfdab8010) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfdab8000) (used target peek value 0x00183203) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xfff80000, 0x00004e07)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfdab8010) (used target peek value 0x00000001) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfdab8000) (used target peek value 0x80104e07) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfdab8000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfdab8000) (used target peek value 0x80104e07) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfdab8004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfdab8004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfdab8010) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfdab8004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xfff80000, 0x00002803)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfdab8010) (used target peek value 0x00000002) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfdab8004) (used target peek value 0x80102803) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfdab8004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfdab8004) (used target peek value 0x80102803) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xffefffff, 0x00000000)
+POKE32(0xfdab8b04, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffff3, 0x00000008)
+POKE32(0xfdab8b08, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x00000008) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffffcf, 0x00000020)
+POKE32(0xfdab8b0c, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x00000028) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffff3f, 0x00000080)
+POKE32(0xfdab8a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000000a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffcff, 0x00000100)
+POKE32(0xfdab8b14, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000001a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffff3ff, 0x00000800)
+POKE32(0xfdab8b1c, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000009a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffff3fff, 0x00008000)
+POKE32(0xfdab8b20, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000089a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffcffff, 0x00020000)
+POKE32(0xfdab8b24, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000289a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfff3ffff, 0x00080000)
+POKE32(0xfdab8b28, 0x0000001f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x000a89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffcfffff, 0x00200000)
+POKE32(0xfdab8b2c, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x002a89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xff3fffff, 0x00800000)
+POKE32(0xfdab8b30, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x00aa89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfcffffff, 0x02000000)
+POKE32(0xfdab8b34, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x02aa89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xf3ffffff, 0x08000000)
+POKE32(0xfdab8a38, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x0aaa89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xcfffffff, 0x10000000)
+POKE32(0xfdab8b3c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfdab8014) (used target peek value 0x1aaa89a8) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0x3fffffff, 0x80000000)
+POKE32(0xfdab8b40, 0x0000000f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfdab8024) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffffc, 0x00000002)
+POKE32(0xfdab8b44, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfdab8024) (used target peek value 0x00000002) */
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c0de)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfd5460b8, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_MD3
+*/
+POKE32(0xfd546080, 0x00000013)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_PE3
+*/
+POKE32(0xfd546084, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_SDIV3
+*/
+POKE32(0xfd54608c, 0x00000002)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000001)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c1a0)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_0
+*/
+IF_GT32(1, 0xfde20000, 0xf0000000, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x02200200)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_0
+*/
+ELSE(1)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x02200200)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+ENDIF(1)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_0
+*/
+/* PEEK(0xfde20000) (used target peek value 0x0d443041) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+/* PEEK(0xfde2004c) (used target peek value 0x01850ff7) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+/* PEEK(0xfde2004c) (used target peek value 0x01850ff6) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_4
+*/
+/* PEEK(0xfde2004c) (used target peek value 0x022002f6) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_STATUS_5
+*/
+/* PEEK(0xfde20014) (used target peek value 0x00000001) */
+POKE32(0x10008000, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe900860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe900800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe900810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe900820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe900830, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe900840, 0x00000020)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe900100, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe900108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe900110, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe900118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe900140, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe900148, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe900150, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe900158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe900180, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe900188, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe900190, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe900198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe9001c0, 0x00c447f9)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe9001c8, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe9001d0, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe9001d8, 0x0000000a)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe900028, 0x00000010)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+/* PEEK(0xfde30028) (used target peek value 0xffffffff) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+UPDATE32(0xfde30028, 0xfffffffd, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+/* PEEK(0xfde30028) (used target peek value 0xfffffffd) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+OR32(0xfde30028, 0x00000002)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+/* PEEK(0xfde20084) (used target peek value 0x00000000) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde52030, 0x00500040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde52038, 0x33220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde521c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde52000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde520a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde52028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde500c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde500c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde500cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde500c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+/* PEEK(0xfde50410) (used target peek value 0x00000027) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde50410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0x00010000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+/* PEEK(0xfde50434) (used target peek value 0x00001884) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde50434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+/* PEEK(0xfde5031c) (used target peek value 0x00002105) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+UPDATE32(0xfde5031c, 0xfffffffb, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0x00010000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde50044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+/* PEEK(0xfde50048) (used target peek value 0x00000003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde50048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde50080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde50084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde5008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde50090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde500d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde500d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde500d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde500dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde500e0, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde500e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde500e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde500ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde500f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde500f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde500f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde500fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde50100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde50104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde50108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde5010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde50110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde50114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde50118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde5011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde50120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde50124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde50128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde5012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde50130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde50134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde50138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x07100000) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x07100000) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00140083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00140083) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00140083) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00160003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00160003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00120043)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00120043) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00120043) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00109403) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00109403) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00100005) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde50040) (used target peek value 0x00100005) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+/* PEEK(0xfde50008) (used target peek value 0x00000001) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xbfd90002) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde50484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xbfd90000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde50484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde50300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde50320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+/* PEEK(0xfde50008) (used target peek value 0x00000003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000003)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+/* PEEK(0xfde30028) (used target peek value 0xffffffff) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+UPDATE32(0xfde30028, 0xfffffffb, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+/* PEEK(0xfde30028) (used target peek value 0xfffffffb) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_12
+*/
+OR32(0xfde30028, 0x00000004)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+/* PEEK(0xfde20084) (used target peek value 0x00000003) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde72030, 0x00900080)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde72038, 0x33220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde721c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde72000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde720a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde72028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde700c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde700c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde700cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde700c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+/* PEEK(0xfde70410) (used target peek value 0x00000027) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde70410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0x00010000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+/* PEEK(0xfde70434) (used target peek value 0x00001884) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde70434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+/* PEEK(0xfde7031c) (used target peek value 0x00002105) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+UPDATE32(0xfde7031c, 0xfffffffb, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0x00010000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde70044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+/* PEEK(0xfde70048) (used target peek value 0x00000003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde70048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde70080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde70084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde7008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde70090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde700d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde700d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde700d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde700dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde700e0, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde700e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde700e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde700ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde700f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde700f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde700f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde700fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde70100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde70104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde70108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde7010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde70110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde70114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde70118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde7011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde70120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde70124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde70128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde7012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde70130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde70134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde70138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x07100000) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x07100000) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00140083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00140083) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00140083) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00160003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00160003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00120043)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00120043) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00120043) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00109403) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00109403) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00100005) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+/* PEEK(0xfde70040) (used target peek value 0x00100005) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+/* PEEK(0xfde70008) (used target peek value 0x00000001) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xbfd90002) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde70484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xbfd90000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+/* PEEK(0xfde70484) (used target peek value 0xffff0000) */
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde70300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde70320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+/* PEEK(0xfde70008) (used target peek value 0x00000003) */
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000003)
+/* PEEK(0xfdea3a00) (used target peek value 0x0a0b0c0d) */
+UPDATE32(0xfdea3a00, 0x00000000, 0x0a0d0b0c)
+/* PEEK(0xfd2e0004) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e0004, 0xfffffff0, 0x00000001)
+/* PEEK(0xfd2e0008) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e0008, 0xfffffff8, 0x00000003)
+/* PEEK(0xfd2e000c) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e000c, 0xfffffff8, 0x00000006)
+/* PEEK(0xfd2e0010) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e0010, 0xfffffff8, 0x00000001)
+/* PEEK(0xfd2e0014) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e0014, 0xfffffff8, 0x00000000)
+/* PEEK(0xfd2e0018) (used target peek value 0x00000000) */
+UPDATE32(0xfd2e0018, 0x0000ffff, 0x00000000)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfd544010, 0xffff5f1c, 0x000000a3)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x00000060) */
+/* PEEK(0xfd544010) (used target peek value 0x00000060) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfd5440b0, 0xffffff00, 0x000000a3)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfd5440b0) (used target peek value 0x00000060) */
+/* PEEK(0xfe76b0fc) (used target peek value 0x00000000) */
+UPDATE32(0xfe76b0fc, 0xfffffff8, 0x00000005)
+/* PEEK(0xfd5450ec) (used target peek value 0x00000000) */
+UPDATE32(0xfd5450ec, 0xfffffff0, 0x00000001)
+/* PEEK(0xfd5450f0) (used target peek value 0x00000000) */
+UPDATE32(0xfd5450f0, 0xfffffff8, 0x00000005)
+/* PEEK(0xfd5450f4) (used target peek value 0x00000000) */
+UPDATE32(0xfd5450f4, 0xfffffff8, 0x00000003)
+/* PEEK(0xfd5450f8) (used target peek value 0x00000000) */
+UPDATE32(0xfd5450f8, 0xfffffff8, 0x00000002)
+/* PEEK(0xfd5450fc) (used target peek value 0x00000000) */
+UPDATE32(0xfd5450fc, 0xfffffff8, 0x00000000)
+/* PEEK(0xfd5451ec) (used target peek value 0x00000000) */
+UPDATE32(0xfd5451ec, 0xfffffff0, 0x00000001)
+/* PEEK(0xfd5451f0) (used target peek value 0x00000000) */
+UPDATE32(0xfd5451f0, 0xfffffff8, 0x00000005)
+/* PEEK(0xfd5451f4) (used target peek value 0x00000000) */
+UPDATE32(0xfd5451f4, 0xfffffff8, 0x00000003)
+/* PEEK(0xfd5451f8) (used target peek value 0x00000000) */
+UPDATE32(0xfd5451f8, 0xfffffff8, 0x00000002)
+/* PEEK(0xfd5451fc) (used target peek value 0x00000000) */
+UPDATE32(0xfd5451fc, 0xfffffff8, 0x00000000)
+/* PEEK(0xfd5452ec) (used target peek value 0x00000000) */
+UPDATE32(0xfd5452ec, 0xfffffff0, 0x00000001)
+/* PEEK(0xfd5452f0) (used target peek value 0x00000000) */
+UPDATE32(0xfd5452f0, 0xfffffff8, 0x00000005)
+/* PEEK(0xfd5452f4) (used target peek value 0x00000000) */
+UPDATE32(0xfd5452f4, 0xfffffff8, 0x00000003)
+/* PEEK(0xfd5452f8) (used target peek value 0x00000000) */
+UPDATE32(0xfd5452f8, 0xfffffff8, 0x00000002)
+/* PEEK(0xfd5452fc) (used target peek value 0x00000000) */
+UPDATE32(0xfd5452fc, 0xfffffff8, 0x00000000)
+/* PEEK(0xfd5453ec) (used target peek value 0x00000000) */
+UPDATE32(0xfd5453ec, 0xfffffff0, 0x00000001)
+/* PEEK(0xfd5453f0) (used target peek value 0x00000000) */
+UPDATE32(0xfd5453f0, 0xfffffff8, 0x00000005)
+/* PEEK(0xfd5453f4) (used target peek value 0x00000000) */
+UPDATE32(0xfd5453f4, 0xfffffff8, 0x00000003)
+/* PEEK(0xfd5453f8) (used target peek value 0x00000000) */
+UPDATE32(0xfd5453f8, 0xfffffff8, 0x00000002)
+/* PEEK(0xfd5453fc) (used target peek value 0x00000000) */
+UPDATE32(0xfd5453fc, 0xfffffff8, 0x00000000)
+/* PEEK(0xfd545efc) (used target peek value 0x00000000) */
+UPDATE32(0xfd545efc, 0xfffffff8, 0x00000005)
+/* PEEK(0xfde00030) (used target peek value 0x00000005) */
+UPDATE32(0xfde00030, 0xfffffff8, 0x00000006)
+/* PEEK(0xfde00034) (used target peek value 0x00000000) */
+UPDATE32(0xfde00034, 0xfffffff8, 0x00000001)
+/* PEEK(0xfde00038) (used target peek value 0x00000003) */
+UPDATE32(0xfde00038, 0xfffffff8, 0x00000000)
+/* PEEK(0xfde0004c) (used target peek value 0x00000000) */
+UPDATE32(0xfde0004c, 0xfffffc00, 0x00000000)
+/* PEEK(0xfde00050) (used target peek value 0x00000000) */
+UPDATE32(0xfde00050, 0xfffffc00, 0x00000000)
+/* PEEK(0xfde00108) (used target peek value 0xe0000081) */
+UPDATE32(0xfde00108, 0x1fffffff, 0xa0000000)
+/* PEEK(0xfde0010c) (used target peek value 0x00000005) */
+UPDATE32(0xfde0010c, 0xfffffff8, 0x00000005)
+/* PEEK(0xfde00110) (used target peek value 0x00000000) */
+UPDATE32(0xfde00110, 0xfff8f8f8, 0x00010202)
+/* PEEK(0xfde00114) (used target peek value 0x00010303) */
+UPDATE32(0xfde00114, 0xfff8f8f8, 0x00000000)
+/* PEEK(0xfde20044) (used target peek value 0x00000000) */
+UPDATE32(0xfde20044, 0xfffffffc, 0x00000000)
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0004, 0xfffffff8, 0x00000006)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0004) (used target peek value 0x01000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0008, 0xfffffff8, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0008) (used target peek value 0x80100000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab000c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab000c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0010, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0010) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0024, 0xfffffff8, 0x00000006)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0024) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0028, 0xfffffff8, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0028) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab002c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab002c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab002c, 0x0000fff8, 0x00000002)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0030, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0030) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0030, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0044, 0xfffffff8, 0x00000006)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0044) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0048, 0xfffffff8, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0048) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab004c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab004c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab004c, 0x0000fff8, 0x00000003)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0050, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0050) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0050, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0084, 0xfffffff8, 0x00000006)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0084) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0088, 0xfffffff8, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0088) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab008c, 0x0000fff8, 0x00000000)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab008c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab008c, 0x0000fff8, 0x00000002)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00000000)
+  UPDATE32(0xfdab0090, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfdab0090) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfd544010, 0x00002000, 0x00002000)
+  UPDATE32(0xfdab0090, 0xfffffff0, 0x00000001)
+ENDIF(1)
+/* PEEK(0xfd544010) (used target peek value 0x000000a3) */
+/* PEEK(0xfd002024) (used target peek value 0x00000000) */
+UPDATE32(0xfd002024, 0xfff01fff, 0x0003c000)
+/* PEEK(0xfd003024) (used target peek value 0x00000000) */
+UPDATE32(0xfd003024, 0xfff01fff, 0x0003c000)
+/* PEEK(0xfd004024) (used target peek value 0x00000000) */
+UPDATE32(0xfd004024, 0xfff01fff, 0x0003c000)
+IF_EQ32(1, 0xfe7000b8, 0x00000001, 0x00000000)
+  UPDATE32(0xfe0fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+/* PEEK(0xfe7000b8) (used target peek value 0x00000006) */
+/* PEEK(0xfe0fff04) (used target peek value 0x0002c007) */
+IF_EQ32(1, 0xfe7000b8, 0x00000002, 0x00000000)
+  UPDATE32(0xfe1fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+/* PEEK(0xfe7000b8) (used target peek value 0x00000006) */
+IF_EQ32(1, 0xfe7000b8, 0x00000004, 0x00000000)
+  UPDATE32(0xfe2fff04, 0xffc00000, 0x00264207)
+ENDIF(1)
+/* PEEK(0xfe7000b8) (used target peek value 0x00000006) */
+IF_EQ32(1, 0xfda500d4, 0x00000001, 0x00000001)
+  UPDATE32(0xfda8f000, 0xffd00000, 0x0026c207)
+ENDIF(1)
+/* PEEK(0xfda500d4) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfda500d4, 0x00000001, 0x00000001)
+  UPDATE32(0xfda89000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+/* PEEK(0xfda500d4) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfe70010c, 0x00000001, 0x00000001)
+  UPDATE32(0xfe737000, 0xffd00000, 0x0026c207)
+ENDIF(1)
+/* PEEK(0xfe70010c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfe70010c, 0x00000001, 0x00000001)
+  UPDATE32(0xfe731000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+/* PEEK(0xfe70010c) (used target peek value 0x00000000) */
+IF_EQ32(1, 0xfda50078, 0x00000004, 0x00000000)
+  UPDATE32(0xfdaa9744, 0xffd00000, 0x0026c207)
+ENDIF(1)
+/* PEEK(0xfda50078) (used target peek value 0x00000006) */
+
+
+#if 0		/* added by Sean McGoogan <Sean.McGoogan@st.com> */
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY2
+*/
+POKE32(0xf7100200, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY2
+*/
+POKE32(0xf6100200, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY3
+*/
+POKE32(0xf7100300, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY3
+*/
+POKE32(0xf6100300, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY4
+*/
+POKE32(0xf7100400, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY4
+*/
+POKE32(0xf6100400, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY5
+*/
+POKE32(0xf7100500, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY5
+*/
+POKE32(0xf6100500, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY6
+*/
+POKE32(0xf7100600, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY6
+*/
+POKE32(0xf6100600, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY7
+*/
+POKE32(0xf7100700, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY7
+*/
+POKE32(0xf6100700, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY8
+*/
+POKE32(0xf7100800, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY8
+*/
+POKE32(0xf6100800, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY9
+*/
+POKE32(0xf7100900, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY9
+*/
+POKE32(0xf6100900, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY10
+*/
+POKE32(0xf7100a00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY10
+*/
+POKE32(0xf6100a00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY11
+*/
+POKE32(0xf7100b00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY11
+*/
+POKE32(0xf6100b00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY12
+*/
+POKE32(0xf7100c00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY12
+*/
+POKE32(0xf6100c00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY13
+*/
+POKE32(0xf7100d00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY13
+*/
+POKE32(0xf6100d00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY14
+*/
+POKE32(0xf7100e00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY14
+*/
+POKE32(0xf6100e00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY15
+*/
+POKE32(0xf7100f00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY15
+*/
+POKE32(0xf6100f00, 0x80000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x40000188)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0xa0000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x80000188)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+/* PEEK(0xff000010) (used target peek value 0x00000000) */
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+OR32(0xff000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+IF_EQ32(1, 0xff000010, 0x00000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+  UPDATE32(0xff000010, 0xffffffef, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+ELSE(1)
+
+
+/*
+st40_ccn_regs.CCN_PASCR
+*/
+  UPDATE32(0xff000070, 0x7fffffff, 0x80000000)
+ENDIF(1)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+/* PEEK(0xff000010) (used target peek value 0x00000000) */
+
+
+/*
+st40_ccn_regs.CCN_PASCR
+*/
+/* PEEK(0xff000070) (used target peek value 0x00000000) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+#endif	/* added by Sean McGoogan <Sean.McGoogan@st.com> */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_1
+*/
+/* PEEK(0xfde30008) (used target peek value 0x00000002) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_1
+*/
+OR32(0xfde30008, 0x00000002)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+/* PEEK(0xfde20048) (used target peek value 0x00003010) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+OR32(0xfde20048, 0x00000800)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+/* PEEK(0xfde20048) (used target peek value 0x00003810) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+OR32(0xfde20048, 0x00000400)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_0
+*/
+/* PEEK(0xfde30004) (used target peek value 0x0000000d) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_0
+*/
+OR32(0xfde30004, 0x00000002)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+/* PEEK(0xfde20048) (used target peek value 0x00003c10) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+UPDATE32(0xfde20048, 0xfffff7ff, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+/* PEEK(0xfde20048) (used target peek value 0x00003410) */
+
+
+/*
+stx7108_sysconf_1_regs.SYSCONF_1_SYSTEM_CONFIG_3
+*/
+UPDATE32(0xfde20048, 0xfffffbff, 0x00000000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_6
+*/
+POKE32(0xfde3001c, 0xfec04000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_0
+*/
+/* PEEK(0xfde30004) (used target peek value 0x0000000f) */
+
+
+/*
+stx7108_sysconf_0_regs.SYSCONF_0_SYSTEM_CONFIG_0
+*/
+OR32(0xfde30004, 0x00000010)
diff --git a/board/st/mb837/mb837.c b/board/st/mb837/mb837.c
new file mode 100644
index 0000000..319171f
--- /dev/null
+++ b/board/st/mb837/mb837.c
@@ -0,0 +1,258 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7108reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+	/*
+	 * WARNING!  WARNING!  WARNING!  WARNING!  WARNING!
+	 * ------------------------------------------------
+	 *
+	 * The ethernet PHYs may be reset by one of two mechanisms:
+	 *
+	 *	a) the EPLD on the MB705 peripheral board
+	 *
+	 *	b) via the PCF8575 (IC12) PIO Extender.
+	 *
+	 * This code does *not* (currently) make any attempt to
+	 * reset the PHYs, but relies on the MB705 to reset the
+	 * PHYs on power-on, which (thus far) demonstrably works well!
+	 *
+	 * If an MB705 is *not* connected, then additional work
+	 * is required, including fitting J14-A, and J14-B.
+	 * We currently just issue a diagnostic to warn about this ...
+	 */
+#if !defined(CONFIG_SH_MB705)
+#warning Ethernet PHYs not reset without a MB705 present!
+#endif
+
+
+#if defined(CONFIG_SH_MB705)
+	/*
+	 * More recent EPLD versions have the EPLD in EMI space,
+	 * using CSCn (EMI Bank #2), nominally at physical 0x04800000.
+	 */
+#if !defined(CFG_EPLD_PHYSICAL_BASE)
+#	define CFG_EPLD_PHYSICAL_BASE	0x04800000	/* CSCn (EMI Bank #2) */
+#endif /* CFG_EPLD_PHYSICAL_BASE */
+	/* map the physical address to UN-cached virtual address */
+#if !defined(CFG_EPLD_BASE)
+#	define CFG_EPLD_BASE		( 0xa0000000 | (CFG_EPLD_PHYSICAL_BASE) )
+#endif /* CFG_EPLD_BASE */
+	/*
+	 * following are the offsets within the EMI EPLD (IC21),
+	 * for the MB705 Peripheral board.
+	 */
+#define EPLD_IDENT		0x00	/* EPLD Identifier Register */
+#define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
+#define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
+#endif	/* CONFIG_SH_MB705 */
+
+
+#if defined(CONFIG_SH_MB705)
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 16-bit write to EPLD registers */
+	writew(value, CFG_EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 16-bit read from EPLD registers */
+	return readw(CFG_EPLD_BASE + offset);
+}
+
+static int mb705_init_epld(void)
+{
+	const unsigned short test_value = 0x1234u;
+	unsigned short epld_reg;
+	unsigned short epld_version, board_version;
+
+	/* write (anything) to the test register */
+	epld_write(test_value, EPLD_TEST);
+	/* verify we got back an inverted result */
+	epld_reg = epld_read(EPLD_TEST);
+	if (epld_reg != (test_value ^ 0xffffu)) {
+		printf("Failed EPLD test (offset=%02x, result=%04x)\n",
+			EPLD_TEST, epld_reg);
+		return 1;
+		}
+
+	/* Assume we can trust the version register */
+	epld_reg = epld_read(EPLD_IDENT);
+	board_version = epld_reg >> 4 & 0xfu;
+	epld_version = epld_reg & 0xfu;
+
+	/* display the board revision, and EPLD version */
+	printf("MB705: revision %c, EPLD version %02d\n",
+		board_version + 'A' - 1,
+		epld_version);
+
+	/* return a "success" result */
+	return 0;
+}
+#endif	/* CONFIG_SH_MB705 */
+
+void flashWriteEnable(void)
+{
+#if defined(CONFIG_SH_MB705)
+	unsigned short epld_reg;
+
+	/* Enable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg |= 1u << 3;	/* NandFlashWP = MISC[3] = 1 */
+	epld_reg |= 1u << 2;	/* NorFlashVpp = MISC[2] = 1 */
+	epld_write(epld_reg, EPLD_MISC);
+#endif	/* CONFIG_SH_MB705 */
+}
+
+void flashWriteDisable(void)
+{
+#if defined(CONFIG_SH_MB705)
+	unsigned short epld_reg;
+
+	/* Disable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg &= ~(1u << 3);	/* NandFlashWP = MISC[3] = 0 */
+	epld_reg &= ~(1u << 2);	/* NorFlashVpp = MISC[2] = 0 */
+	epld_write(epld_reg, EPLD_MISC);
+#endif	/* CONFIG_SH_MB705 */
+}
+
+
+#define PIOALT(port, pin, alt, dir)			\
+do							\
+{							\
+	stx7108_pioalt_select((port), (pin), (alt));	\
+	stx7108_pioalt_pad((port), (pin), (dir));	\
+} while(0)
+
+static void configPIO(void)
+{
+	/* Setup PIOs for ASC device */
+
+#if CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE
+
+	/* Route UART2 via PIO14 for TX, RX, CTS & RTS (Alternative #1) */
+	PIOALT(14, 4, 1, &stx7108_pioalt_pad_out);	/* UART2-TX */
+	PIOALT(14, 5, 1, &stx7108_pioalt_pad_in);	/* UART2-RX */
+	PIOALT(14, 6, 1, &stx7108_pioalt_pad_out);	/* UART2-RTS */
+	PIOALT(14, 7, 1, &stx7108_pioalt_pad_in);	/* UART2-CTS */
+
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE
+
+	/* Route UART3 via PIO21 for TX, RX, CTS & RTS (Alternative #2) */
+	PIOALT(21, 0, 2, &stx7108_pioalt_pad_out);	/* UART3-TX */
+	PIOALT(21, 1, 2, &stx7108_pioalt_pad_in);	/* UART3-RX */
+	PIOALT(21, 3, 2, &stx7108_pioalt_pad_out);	/* UART3-RTS */
+	PIOALT(21, 4, 2, &stx7108_pioalt_pad_in);	/* UART3-CTS */
+
+#else
+#error Unknown ASC port selected!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#ifdef QQQ	/* QQQ - DELETE */
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+#endif		/* QQQ - DELETE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC	
+#if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0, on CN18 */
+	stx7108_configure_ethernet(0, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0, });
+#elif CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE		/* MII1, on CN19 */
+	stx7108_configure_ethernet(1, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 1, });
+#else
+#error Unknown base address for the STM GMAC
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+#if defined(CONFIG_CMD_I2C)
+	stx7108_configure_i2c();
+#endif	/* CONFIG_CMD_I2C */
+
+	/*
+	 * For accessing the EPLD (on EMI Bank #2 (CSnC)), we need to
+	 * elongate the rising CSn time, otherwise we risk the FET switches
+	 * not being enabled for long enough.
+	 * Failure to do this correctly, can result in the
+	 * mb705_init_epld() function failing to pass the TEST.
+	 *
+	 * The following is (now) known to work:
+	 *
+	 *	set CSE2_TIME_WRITE = 0x1  [19:16] (rising-edge of CSn)
+	 *
+	 * Note with CSE2_TIME_WRITE=0x0, or CSE2_TIME_WRITE=0x2
+	 * then, the EPLD *write* can fail, and this is
+	 * (bizarrely) a function of the PC's offset in the I$!
+	 *
+	 * An alternative solution may be to enable the FET switches
+	 * permanently, by setting J5A and J5B as follows:
+	 * 	J5A: remove	(default is 2-3)
+	 * 	J5B: 1-2	(default is 2-3)
+	 */
+#if 1
+	*ST40_EMI_BANK2_EMICONFIGDATA2 &= ~(0xfu << 16);
+	*ST40_EMI_BANK2_EMICONFIGDATA2 |=  (0x1u << 16);
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7108-Mboard (MB837)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#if defined(CONFIG_SH_MB705)
+	/*
+	 * initialize the EPLD on the MB705.
+	 */
+	mb705_init_epld();
+#endif	/* CONFIG_SH_MB705 */
+
+	return 0;
+}
diff --git a/board/st/mb837/nand.c b/board/st/mb837/nand.c
new file mode 100644
index 0000000..412be09
--- /dev/null
+++ b/board/st/mb837/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2010 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7108reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void mb837_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int mb837_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = mb837_device_ready;
+	nand->hwcontrol     = mb837_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 22bc131..e5c1451 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
- * (C) Copyright 2009 STMicroelectronics.
+ * (C) Copyright 2009-2010 STMicroelectronics.
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
@@ -282,16 +282,23 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 #include "asm/socregs.h"
 
+#if !defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+#define CONFIG_CMD_BDI_DUMP_EMI_BANKS 1
+#endif
+
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	DECLARE_GLOBAL_DATA_PTR;
-#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+#if CONFIG_CMD_BDI_DUMP_EMI_BANKS
+	#if !defined(ST40_EMI_SIZE)
+	#define ST40_EMI_SIZE	(128 << 20)	/* EMI is usually 128 MiB */
+	#endif	/* ST40_EMI_SIZE */
 	#define MAX_EMI_BANKS	6	/* Maximum of 6 EMI Banks */
 	const u32 emi_base = 0xa0000000u;
 	u32 base[MAX_EMI_BANKS+1];	/* Base address for each bank */
 	u32 enabled;			/* number of enabled EMI banks */
 #endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
-#if defined(CONFIG_CMD_NET) || defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+#if defined(CONFIG_CMD_NET) || CONFIG_CMD_BDI_DUMP_EMI_BANKS
 	unsigned int i;
 #endif
 	bd_t *bd = gd->bd;
@@ -329,6 +336,9 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 #elif defined(CONFIG_SH_STX7105)
 	if (STX7105_DEVICEID_7105(bd->bi_devid))
 		printf ("\nSTx7105 version %ld.x", STX7105_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7108)
+	if (STX7108_DEVICEID_7108(bd->bi_devid))
+		printf ("\nSTx7108 version %ld.x", STX7108_DEVICEID_CUT(bd->bi_devid));
 #elif defined(CONFIG_SH_STX7111)
 	if (STX7111_DEVICEID_7111(bd->bi_devid))
 		printf ("\nSTx7111 version %ld.x", STX7111_DEVICEID_CUT(bd->bi_devid));
@@ -341,6 +351,9 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 #elif defined(CONFIG_SH_FLI7510)
 	if (FLI7510_DEVICEID_7510(bd->bi_devid))
 		printf ("\nFLI7510 version %ld.x", FLI7510_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_FLI7540)
+	if (FLI7540_DEVICEID_7540(bd->bi_devid))
+		printf ("\nFLI7540 version %ld.x", FLI7540_DEVICEID_CUT(bd->bi_devid));
 #else
 #error Missing Device Definitions!
 #endif
@@ -367,7 +380,7 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	print_mhz ("EMI",		bd->bi_emifrq);
 #endif	/* CONFIG_SH_STB7100 */
 
-#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+#if CONFIG_CMD_BDI_DUMP_EMI_BANKS
 	enabled = *ST40_EMI_BANK_ENABLE;
 	printf("#EMI Banks  = %u\n", enabled);
 	if (enabled > MAX_EMI_BANKS)
@@ -387,7 +400,7 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		base[i] = emi_base + (start << (22));
 	}
 	/* last valid bank occupies all remaining space */
-	base[i] = emi_base + (128u << (20));	/* total size of EMI is 128MiB */
+	base[i] = emi_base + ST40_EMI_SIZE;	/* total size of EMI is usually 128MiB */
 
 	/*
 	 * Print out the ranges of each bank.
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index f2e629e..c2ce672 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -392,6 +392,14 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			return 1;	/* unable to proceed */
 		}
 
+#if 0
+		printf ("info: Cload = 0x%8x<n\n", PHYSADDR(Cload));
+		printf ("info: Cend  = 0x%8x<n\n", PHYSADDR(Cend) );
+		printf ("info: Uload = 0x%8x<n\n", PHYSADDR(Uload));
+		printf ("info: Uend  = 0x%8x<n\n", PHYSADDR(Uend) );
+		printf ("info: Cload > Uend = %d\n", PHYSADDR(Cload) > PHYSADDR(Uend) );
+		printf ("info: Uload > Cend = %d\n", PHYSADDR(Uload) > PHYSADDR(Cend) );
+#endif
 		/* assert ( (Cload > Uend) || (Uload > Cend) ); */
 		if ( !((PHYSADDR(Cload) > PHYSADDR(Uend)) || (PHYSADDR(Uload) > PHYSADDR(Cend))) )
 		{
diff --git a/common/cmd_eeprom.c b/common/cmd_eeprom.c
index e5000e9..b3f0efe 100644
--- a/common/cmd_eeprom.c
+++ b/common/cmd_eeprom.c
@@ -88,21 +88,45 @@ int do_eeprom ( cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 		if (strcmp (argv[1], "read") == 0) {
 			int rcode;
+#if defined(CONFIG_MEASURE_TIME)
+			ulong duration;			/* measured time in ms */
+#endif	/* CONFIG_MEASURE_TIME */
 
 			printf (fmt, dev_addr, argv[1], addr, off, cnt);
 
+#if defined(CONFIG_MEASURE_TIME)
+			set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 			rcode = eeprom_read (dev_addr, off, (uchar *) addr, cnt);
+#if defined(CONFIG_MEASURE_TIME)
+			duration = get_timer(0);	/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 
 			puts ("done\n");
+#if defined(CONFIG_MEASURE_TIME)
+			PRINT_MEASURED_TRANSFER_RATE(cnt, duration);
+#endif	/* CONFIG_MEASURE_TIME */
 			return rcode;
 		} else if (strcmp (argv[1], "write") == 0) {
 			int rcode;
+#if defined(CONFIG_MEASURE_TIME)
+			ulong duration;			/* measured time in ms */
+#endif	/* CONFIG_MEASURE_TIME */
 
 			printf (fmt, dev_addr, argv[1], addr, off, cnt);
 
+#if defined(CONFIG_MEASURE_TIME)
+			set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 			rcode = eeprom_write (dev_addr, off, (uchar *) addr, cnt);
+#if defined(CONFIG_MEASURE_TIME)
+			duration = get_timer(0);	/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 
 			puts ("done\n");
+#if defined(CONFIG_MEASURE_TIME)
+			PRINT_MEASURED_TRANSFER_RATE(cnt, duration);
+#endif	/* CONFIG_MEASURE_TIME */
 			return rcode;
 		}
 	}
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index 149995c..b0766eb 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -359,6 +359,10 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	addr, dest, count;
 	int	size;
+#if defined(CONFIG_MEASURE_TIME)
+	ulong duration;			/* measured time in ms */
+	ulong num_bytes;		/* total number of bytes to copy */
+#endif	/* CONFIG_MEASURE_TIME */
 
 	if (argc != 4) {
 		printf ("Usage:\n%s\n", cmdtp->usage);
@@ -383,6 +387,9 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		return 1;
 	}
 
+#if defined(CONFIG_MEASURE_TIME)
+	num_bytes = count*size;		/* total number of bytes to copy */
+#endif	/* CONFIG_MEASURE_TIME */
 #ifndef CFG_NO_FLASH
 	/* check if we are copying to Flash */
 	if ( (addr2info(dest) != NULL)
@@ -394,12 +401,21 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 		puts ("Copy to Flash\n");
 
+#if defined(CONFIG_MEASURE_TIME)
+		set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 		rc = flash_write ((char *)addr, dest, count*size);
+#if defined(CONFIG_MEASURE_TIME)
+		duration = get_timer(0);	/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 		if (rc != 0) {
 			flash_perror (rc);
 			return (1);
 		}
 		puts (" done\n");
+#if defined(CONFIG_MEASURE_TIME)
+		PRINT_MEASURED_TRANSFER_RATE(num_bytes, duration);
+#endif	/* CONFIG_MEASURE_TIME */
 		return 0;
 	}
 #endif
@@ -478,6 +494,9 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 #endif
 
+#if defined(CONFIG_MEASURE_TIME)
+	set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 	while (count-- > 0) {
 		if (size == 4)
 			*((ulong  *)dest) = *((ulong  *)addr);
@@ -488,6 +507,10 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		addr += size;
 		dest += size;
 	}
+#if defined(CONFIG_MEASURE_TIME)
+	duration = get_timer(0);	/* stop measuring */
+	PRINT_MEASURED_TRANSFER_RATE(num_bytes, duration);
+#endif	/* CONFIG_MEASURE_TIME */
 	return 0;
 }
 
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 1fdd7a6..6d98220 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -311,6 +311,9 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	/* read write */
 	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
 		int read;
+#if defined(CONFIG_MEASURE_TIME)
+		ulong duration;			/* measured time in ms */
+#endif	/* CONFIG_MEASURE_TIME */
 
 		if (argc < 4)
 			goto usage;
@@ -333,7 +336,13 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 				opts.length	= size;
 				opts.offset	= off;
 				opts.quiet      = quiet;
+#if defined(CONFIG_MEASURE_TIME)
+				set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 				ret = nand_read_opts(nand, &opts);
+#if defined(CONFIG_MEASURE_TIME)
+				duration = get_timer(0);	/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 			} else {
 				/* write */
 				nand_write_options_t opts;
@@ -345,18 +354,33 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 				opts.pad	= 1;
 				opts.blockalign = 1;
 				opts.quiet      = quiet;
+#if defined(CONFIG_MEASURE_TIME)
+				set_timer(0);			/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 				ret = nand_write_opts(nand, &opts);
+#if defined(CONFIG_MEASURE_TIME)
+				duration = get_timer(0);	/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 			}
 		} else {
+#if defined(CONFIG_MEASURE_TIME)
+			set_timer(0);				/* start measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 			if (read)
 				ret = nand_read(nand, off, &size, (u_char *)addr);
 			else
 				ret = nand_write(nand, off, &size, (u_char *)addr);
+#if defined(CONFIG_MEASURE_TIME)
+			duration = get_timer(0);		/* stop measuring */
+#endif	/* CONFIG_MEASURE_TIME */
 		}
 
 		printf(" %d bytes %s: %s\n", size,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
+#if defined(CONFIG_MEASURE_TIME)
+		PRINT_MEASURED_TRANSFER_RATE(size, duration);
+#endif	/* CONFIG_MEASURE_TIME */
 		return ret == 0 ? 0 : 1;
 	}
 
diff --git a/common/usb.c b/common/usb.c
index a30bdf7..897fafc 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -75,7 +75,34 @@ static struct devrequest setup_packet;
 char usb_started; /* flag for the started/stopped USB status */
 
 /**********************************************************************
- * some forward declerations...
+ * The following macro, if TRUE will slow down the
+ * device enumeration, to allow some devices to be
+ * properly enumerated, by waiting up to 15sec to
+ * allow the device to "settle".
+ * For further details see:
+ * https://bugzilla.stlinux.com/show_bug.cgi?id=8941
+ *
+ * Special thanks to Richard Marsh of Marsh Consulting Limited
+ * for providing the basis of this fix in usb_hub_configure().
+ */
+#if !defined(CFG_USB_DODGY_DEVICES_SUPPORT)
+#	define CFG_USB_DODGY_DEVICES_SUPPORT	1
+#endif	/* CFG_USB_DODGY_DEVICES_SUPPORT */
+
+#if CFG_USB_DODGY_DEVICES_SUPPORT
+#if !defined(CFG_USB_DODGY_DEVICES_INITIAL_DELAY)
+#	define CFG_USB_DODGY_DEVICES_INITIAL_DELAY	500	/* in ms */
+#endif	/* CFG_USB_DODGY_DEVICES_INITIAL_DELAY */
+#if !defined(CFG_USB_DODGY_DEVICES_LOOP_DELAY)
+#	define CFG_USB_DODGY_DEVICES_LOOP_DELAY		100	/* in ms */
+#endif	/* CFG_USB_DODGY_DEVICES_LOOP_DELAY */
+#if !defined(CFG_USB_DODGY_DEVICES_MAX_DELAY)
+#	define CFG_USB_DODGY_DEVICES_MAX_DELAY		15000	/* in ms */
+#endif	/* CFG_USB_DODGY_DEVICES_MAX_DELAY */
+#endif	/* CFG_USB_DODGY_DEVICES_SUPPORT */
+
+/**********************************************************************
+ * some forward declarations...
  */
 void usb_scan_devices(void);
 
@@ -404,7 +431,7 @@ int usb_clear_halt(struct usb_device *dev, int pipe)
 int usb_get_descriptor(struct usb_device *dev, unsigned char type, unsigned char index, void *buf, int size)
 {
 	int res;
- 	res = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+	res = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 			USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 			(type << 8) + index, 0,
 			buf, size, USB_CNTL_TIMEOUT);
@@ -416,7 +443,7 @@ int usb_get_descriptor(struct usb_device *dev, unsigned char type, unsigned char
  */
 int usb_get_configuration_no(struct usb_device *dev,unsigned char *buffer,int cfgno)
 {
- 	int result;
+	int result;
 	unsigned int tmp;
 	struct usb_config_descriptor *config;
 
@@ -1184,6 +1211,66 @@ int usb_hub_configure(struct usb_device *dev)
 	USB_HUB_PRINTF("%sover-current condition exists\n",
 		(swap_16(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? "" : "no ");
 	usb_hub_power_on(hub);
+
+#if CFG_USB_DODGY_DEVICES_SUPPORT
+	// Some USB devices take an unknown amount of time before they can be enumerated
+	int t = CFG_USB_DODGY_DEVICES_MAX_DELAY;// this is how long we will wait for
+					// a USB device to become connected (CCS + CSC)
+	int ndevready = 0;		// number of devices connected
+	int ndevin    = 0;		// number of devices detected
+	char devin[USB_MAXCHILDREN];	// array of connected devices
+	char devready[USB_MAXCHILDREN];	// array of devices ready
+	struct usb_port_status portsts;
+	unsigned short portstatus, portchange;
+
+	// Initialize device flags
+	for (i = 0; i < USB_MAXCHILDREN; i++)
+	{
+		devin[i]    = 0;
+		devready[i] = 0;
+	}
+
+	// Initial delay to enable devices to power up (CCS)
+	wait_ms (CFG_USB_DODGY_DEVICES_INITIAL_DELAY);
+
+	// Detect and wait for devices
+	do {
+		// Wait - before looking for USB devices connected and ready to enumerate
+		if (t != CFG_USB_DODGY_DEVICES_MAX_DELAY)
+		{
+			wait_ms (CFG_USB_DODGY_DEVICES_LOOP_DELAY);
+			t -= CFG_USB_DODGY_DEVICES_LOOP_DELAY;
+		}
+		// Check each port in turn
+		for (i = 0; i < dev->maxchild; i++)
+		{
+			if (usb_get_port_status(dev, i + 1, &portsts) < 0)
+			{
+				USB_HUB_PRINTF("get_port_status failed\n");
+			}
+			portstatus = swap_16(portsts.wPortStatus);
+			portchange = swap_16(portsts.wPortChange);
+			// Device connected -> hcRhPortStatus::CCS
+			// (see section 7.4.4 of OpenHCI specification)
+			if ((portchange & USB_PORT_STAT_C_CONNECTION) && (devin[i] == 0))
+			{
+				ndevin++;
+				devin[i] = 1;
+			}
+			// Device connected & ready -> hcRhPortStatus::CSC
+			// (see section 7.4.4 of OpenHCI specification)
+			if ((portstatus & USB_PORT_STAT_CONNECTION) &&
+			   (portchange & USB_PORT_STAT_C_CONNECTION) && (devready[i] == 0))
+			{
+				ndevready++;
+				devready[i] = 1;
+			}
+			USB_HUB_PRINTF ("%d:%x %x\n", i+1, portstatus, portchange);
+		}
+	} while ( (t > 0) && (ndevready < ndevin) );
+	USB_HUB_PRINTF ("A total of %d devices (out of %d) were ready\n", ndevready, ndevin);
+#endif	/* CFG_USB_DODGY_DEVICES_SUPPORT */
+
 	for (i = 0; i < dev->maxchild; i++) {
 		struct usb_port_status portsts;
 		unsigned short portstatus, portchange;
diff --git a/cpu/sh/fli7510/fli7510.c b/cpu/sh/fli7510/fli7510.c
index 5bd7bbf..fe2679f 100644
--- a/cpu/sh/fli7510/fli7510.c
+++ b/cpu/sh/fli7510/fli7510.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008-2009 STMicroelectronics.
+ * (C) Copyright 2008-2010 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -30,40 +30,13 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 #include <asm/stbus.h>
+#include <asm/sysconf.h>
 #include <ata.h>
 #include <spi.h>
 
 
 #define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
 
-#define SET_SYSCONF_BIT(reg,flag,bit)			\
-	do {						\
-		if (flag)				\
-		{	/* set bit 'bit' */		\
-			reg |= (1ul<<(bit));		\
-		}					\
-		else					\
-		{	/* clear bit 'bit' */		\
-			reg &= ~(1ul<<(bit));		\
-		}					\
-	} while (0)
-
-#define SET_SYSCONF_BITS(reg,flag,first,last,yes,no)	\
-	do {						\
-		const unsigned long _mask = 		\
-			(1ul<<((last)-(first)+1))-1ul;	\
-		/* clear all bits in 'first':'last' */	\
-		reg &= ~(_mask<<(first));		\
-		if (flag)				\
-		{	/* set 'yes' in first:last */	\
-			reg |= ((yes)<<(first));	\
-		}					\
-		else					\
-		{	/* set 'no' in first:last */	\
-			reg |= ((no)<<(first));		\
-		}					\
-	} while (0)
-
 
 #define USB_POWERDOWN_REQ	8	/* CFG_COMMS_CONFIG_1[8 ]    = usb_powerdown_req */
 #define USBA_OVRCUR_POLARITY	11	/* CFG_COMMS_CONFIG_1[11]    = usba_ovrcur_polarity */
@@ -78,7 +51,7 @@
 #define PHY_INTF_SEL		26	/* CFG_COMMS_CONFIG_2[28:26] = phy_intf_sel */
 
 
-static void fli7105_clocks(void)
+static void fli7510_clocks(void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
 	bd_t *bd = gd->bd;
@@ -287,40 +260,24 @@ extern void fli7510_configure_ethernet(
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 
-#if defined(CONFIG_USB_OHCI_NEW) && 0	/* QQQ: still to debug this! */
-extern void fli7105_usb_init(const enum fli7510_usb_ovrcur_mode ovrcur_mode)
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void fli7510_usb_init(const enum fli7510_usb_ovrcur_mode ovrcur_mode)
 {
 	unsigned long sysconf;
 
-	printf("QQQ: entered %s(ovrcur_mode=%u)\n", __FUNCTION__, ovrcur_mode);	/* QQQ - DELETE */
-	printf("QQQ: on entry: CFG_COMMS_CONFIG_1 = 0x%08x\n", readl(CFG_COMMS_CONFIG_1));
-
-#if 0
-	/* CFG_COMMS_CONFIG_1[8 ] = usb_powerdown_req */
-	sysconf = readl(CFG_COMMS_CONFIG_1);
-	SET_SYSCONF_BIT(sysconf, 0, USB_POWERDOWN_REQ);
-	writel(sysconf, CFG_COMMS_CONFIG_1);
-#endif
-
-switch (ovrcur_mode) {
+	switch (ovrcur_mode) {
 	case fli7510_usb_ovrcur_disabled:
-	//	sc = sysconf_claim(CFG_COMMS_CONFIG_1, 12, 12, "usba_enable_pad_override");
-	//	sysconf_write(sc, 1);
 		/* CFG_COMMS_CONFIG_1[12] = usba_enable_pad_override */
 		sysconf = readl(CFG_COMMS_CONFIG_1);
 		SET_SYSCONF_BIT(sysconf, 1, USBA_ENABLE_PAD_OVERRIDE);
 		writel(sysconf, CFG_COMMS_CONFIG_1);
 
-	//	sc = sysconf_claim(CFG_COMMS_CONFIG_1, 13, 13, "usba_ovrcur");
-	//	sysconf_write(sc, 1);
 		/* CFG_COMMS_CONFIG_1[13] = usba_ovrcur */
 		sysconf = readl(CFG_COMMS_CONFIG_1);
 		SET_SYSCONF_BIT(sysconf, 1, USBA_OVRCUR);
 		writel(sysconf, CFG_COMMS_CONFIG_1);
 		break;
 	default:
-	//	sc = sysconf_claim(CFG_COMMS_CONFIG_1, 12, 12, "usba_enable_pad_override");
-	//	sysconf_write(sc, 0);
 		/* CFG_COMMS_CONFIG_1[12] = usba_enable_pad_override */
 		sysconf = readl(CFG_COMMS_CONFIG_1);
 		SET_SYSCONF_BIT(sysconf, 0, USBA_ENABLE_PAD_OVERRIDE);
@@ -329,15 +286,11 @@ switch (ovrcur_mode) {
 		/* CFG_COMMS_CONFIG_1[11] = usba_ovrcur_polarity */
 		switch (ovrcur_mode) {
 		case fli7510_usb_ovrcur_active_high:
-	//		sc = sysconf_claim(CFG_COMMS_CONFIG_1, 11, 11, "usba_ovrcur_polarity");
-	//		sysconf_write(sc, 0);
 			sysconf = readl(CFG_COMMS_CONFIG_1);
 			SET_SYSCONF_BIT(sysconf, 0, USBA_OVRCUR_POLARITY);
 			writel(sysconf, CFG_COMMS_CONFIG_1);
 			break;
 		case fli7510_usb_ovrcur_active_low:
-	//		sc = sysconf_claim(CFG_COMMS_CONFIG_1, 11, 11, "usba_ovrcur_polarity");
-	//		sysconf_write(sc, 1);
 			sysconf = readl(CFG_COMMS_CONFIG_1);
 			SET_SYSCONF_BIT(sysconf, 1, USBA_OVRCUR_POLARITY);
 			writel(sysconf, CFG_COMMS_CONFIG_1);
@@ -349,8 +302,7 @@ switch (ovrcur_mode) {
 		break;
 	}
 
-//	stpio_request_pin(27, 1, "USB_A_OVRCUR", STPIO_IN);
-//	stpio_request_pin(27, 2, "USB_A_PWREN", STPIO_ALT_OUT);
+	/* now route the PIOs corectly */
 	SET_PIO_PIN(ST40_PIO_BASE(27), 1, STPIO_IN);		/* USB_A_OVRCUR */
 	SET_PIO_PIN(ST40_PIO_BASE(27), 2, STPIO_ALT_OUT);	/* USB_A_PWREN */
 
@@ -359,7 +311,6 @@ switch (ovrcur_mode) {
 		USB_FLAGS_STRAP_16BIT		|
 		USB_FLAGS_STRAP_PLL		|
 		USB_FLAGS_STBUS_CONFIG_THRESHOLD256);
-	printf("QQQ: on exit : CFG_COMMS_CONFIG_1 = 0x%08x\n", readl(CFG_COMMS_CONFIG_1));
 }
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
 
@@ -435,7 +386,7 @@ extern int soc_init(void)
 	DECLARE_GLOBAL_DATA_PTR;
 	bd_t *bd = gd->bd;
 
-	fli7105_clocks();
+	fli7510_clocks();
 
 	/* obtain the chip cut + device id */
 	bd->bi_devid = readl(CFG_DEVICE_ID);
diff --git a/cpu/sh/fli7540/Makefile b/cpu/sh/fli7540/Makefile
new file mode 100644
index 0000000..dcf917a
--- /dev/null
+++ b/cpu/sh/fli7540/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= fli7540.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/fli7540/fli7540.c b/cpu/sh/fli7540/fli7540.c
new file mode 100644
index 0000000..21dafe9
--- /dev/null
+++ b/cpu/sh/fli7540/fli7540.c
@@ -0,0 +1,446 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/fli7540reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <asm/sysconf.h>
+#include <ata.h>
+#include <spi.h>
+
+
+#define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
+
+
+#define USB_XTAL_VALID		1	/* CFG_SPARE_1[1]            = USB_xtal_valid */
+
+#define USB_POWERDOWN_REQ	8	/* CFG_COMMS_CONFIG_1[8 ]    = usb_powerdown_req */
+#define CONF_PIO24_ALTERNATE	17	/* CFG_COMMS_CONFIG_1[18:17] = conf_pio24_alternate */
+
+#define GMAC_MII_ENABLE		8	/* CFG_COMMS_CONFIG_2[8]     = gmac_mii_enable */
+#define GMAC_PHY_CLOCK_SEL	9	/* CFG_COMMS_CONFIG_2[9]     = gmac_phy_clock_sel */
+#define GMAC_ENABLE		24	/* CFG_COMMS_CONFIG_2[24]    = gmac_enable */
+#define GMAC_MAC_SPEED		25	/* CFG_COMMS_CONFIG_2[25]    = gmac_mac_speed */
+#define PHY_INTF_SEL		26	/* CFG_COMMS_CONFIG_2[28:26] = phy_intf_sel */
+
+
+static void fli7540_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;	/* comms_clk = 100 MHz */
+}
+
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+struct fli7540_gmac_pin {
+	unsigned char port, pin, dir;
+};
+
+static struct fli7540_gmac_pin fli7540_gmac_mii_pins[] = {
+	{ 18, 5, },			/* PHYCLK */
+	{ 18, 0, STPIO_ALT_OUT },	/* MDC */
+	{ 18, 1, STPIO_IN },		/* COL */
+	{ 18, 2, STPIO_IN },		/* CRS */
+	{ 18, 3, STPIO_IN },		/* MDINT */
+	{ 18, 4, STPIO_ALT_BIDIR },	/* MDIO */
+	{ 20, 0, STPIO_ALT_OUT },	/* TXD[0] */
+	{ 20, 1, STPIO_ALT_OUT },	/* TXD[1] */
+	{ 20, 2, STPIO_ALT_OUT },	/* TXD[2] */
+	{ 20, 3, STPIO_ALT_OUT },	/* TXD[3] */
+	{ 20, 4, STPIO_ALT_OUT },	/* TXEN */
+	{ 20, 5, STPIO_IN },		/* TXCLK */
+	{ 21, 0, STPIO_IN },		/* RXD[0] */
+	{ 21, 1, STPIO_IN },		/* RXD[1] */
+	{ 21, 2, STPIO_IN },		/* RXD[2] */
+	{ 21, 3, STPIO_IN },		/* RXD[3] */
+	{ 21, 4, STPIO_IN },		/* RXDV */
+	{ 21, 5, STPIO_IN },		/* RX_ER */
+	{ 21, 6, STPIO_IN },		/* RXCLK */
+};
+
+static struct fli7540_gmac_pin fli7540_gmac_gmii_pins[] = {
+	{ 18, 5, },			/* PHYCLK */
+	{ 18, 0, STPIO_ALT_OUT },	/* MDC */
+	{ 18, 1, STPIO_IN },		/* COL */
+	{ 18, 2, STPIO_IN },		/* CRS */
+	{ 18, 3, STPIO_IN },		/* MDINT */
+	{ 18, 4, STPIO_ALT_BIDIR },	/* MDIO */
+	{ 20, 0, STPIO_ALT_OUT },	/* TXD[0] */
+	{ 20, 1, STPIO_ALT_OUT },	/* TXD[1] */
+	{ 20, 2, STPIO_ALT_OUT },	/* TXD[2] */
+	{ 20, 3, STPIO_ALT_OUT },	/* TXD[3] */
+	{ 24, 4, STPIO_ALT_OUT },	/* TXD[4] */
+	{ 24, 5, STPIO_ALT_OUT },	/* TXD[5] */
+	{ 24, 6, STPIO_ALT_OUT },	/* TXD[6] */
+	{ 24, 7, STPIO_ALT_OUT },	/* TXD[7] */
+	{ 20, 4, STPIO_ALT_OUT },	/* TXEN */
+	{ 20, 5, STPIO_IN },		/* TXCLK */
+	{ 21, 0, STPIO_IN },		/* RXD[0] */
+	{ 21, 1, STPIO_IN },		/* RXD[1] */
+	{ 21, 2, STPIO_IN },		/* RXD[2] */
+	{ 21, 3, STPIO_IN },		/* RXD[3] */
+	{ 24, 0, STPIO_IN },		/* RXD[4] */
+	{ 24, 1, STPIO_IN },		/* RXD[5] */
+	{ 24, 2, STPIO_IN },		/* RXD[6] */
+	{ 24, 3, STPIO_IN },		/* RXD[7] */
+	{ 21, 4, STPIO_IN },		/* RXDV */
+	{ 21, 5, STPIO_IN },		/* RX_ER */
+	{ 21, 6, STPIO_IN },		/* RXCLK */
+};
+
+static struct fli7540_gmac_pin fli7540_gmac_rmii_pins[] = {
+	{ 18, 5, },			/* PHYCLK */
+	{ 18, 0, STPIO_ALT_OUT },	/* MDC */
+	{ 18, 3, STPIO_IN },		/* MDINT */
+	{ 18, 4, STPIO_ALT_BIDIR },	/* MDIO */
+	{ 20, 0, STPIO_ALT_OUT },	/* TXD[0] */
+	{ 20, 1, STPIO_ALT_OUT },	/* TXD[1] */
+	{ 20, 4, STPIO_ALT_OUT },	/* TXEN */
+	{ 21, 0, STPIO_IN },		/* RXD[0] */
+	{ 21, 1, STPIO_IN },		/* RXD[1] */
+	{ 21, 4, STPIO_IN },		/* RXDV */
+	{ 21, 5, STPIO_IN },		/* RX_ER */
+};
+
+static struct fli7540_gmac_pin fli7540_gmac_reverse_mii_pins[] = {
+	{ 18, 5, },			/* PHYCLK */
+	{ 18, 0, STPIO_IN },		/* MDC */
+	{ 18, 1, STPIO_ALT_OUT },	/* COL */
+	{ 18, 2, STPIO_ALT_OUT },	/* CRS */
+	{ 18, 3, STPIO_IN },		/* MDINT */
+	{ 18, 4, STPIO_ALT_BIDIR },	/* MDIO */
+	{ 20, 0, STPIO_ALT_OUT },	/* TXD[0] */
+	{ 20, 1, STPIO_ALT_OUT },	/* TXD[1] */
+	{ 20, 2, STPIO_ALT_OUT },	/* TXD[2] */
+	{ 20, 3, STPIO_ALT_OUT },	/* TXD[3] */
+	{ 20, 4, STPIO_ALT_OUT },	/* TXEN */
+	{ 20, 5, STPIO_IN },		/* TXCLK */
+	{ 21, 0, STPIO_IN },		/* RXD[0] */
+	{ 21, 1, STPIO_IN },		/* RXD[1] */
+	{ 21, 2, STPIO_IN },		/* RXD[2] */
+	{ 21, 3, STPIO_IN },		/* RXD[3] */
+	{ 21, 4, STPIO_IN },		/* RXDV */
+	{ 21, 5, STPIO_IN },		/* RX_ER */
+	{ 21, 6, STPIO_IN },		/* RXCLK */
+};
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(const int speed)
+{
+	unsigned long sysconf;
+
+	/* CFG_COMMS_CONFIG_2[25] = gmac_mac_speed */
+	/* gmac_mac_speed = speed==100 ? 1 : 0 */
+	sysconf = readl(CFG_COMMS_CONFIG_2);
+	SET_SYSCONF_BIT(sysconf, speed==100, GMAC_MAC_SPEED);
+	writel(sysconf, CFG_COMMS_CONFIG_2);
+}
+
+
+	/*
+	 * ETH GMAC PIO configuration
+	 */
+extern void fli7540_configure_ethernet(
+	const enum fli7540_ethernet_mode mode,
+	const int ext_clk,
+	const int phy_bus)
+{
+	struct fli7540_gmac_pin *pins;
+	int pins_num;
+	unsigned char phy_sel, enmii;
+	int i;
+	unsigned long sysconf;
+
+	/* Ethernet interface on */
+	/* CFG_COMMS_CONFIG_2[24] = gmac_enable */
+	sysconf = readl(CFG_COMMS_CONFIG_2);
+	SET_SYSCONF_BIT(sysconf, 1, GMAC_ENABLE);
+	writel(sysconf, CFG_COMMS_CONFIG_2);
+
+	switch (mode) {
+	case fli7540_ethernet_mii:
+		phy_sel = 0;
+		enmii = 1;
+		pins = fli7540_gmac_mii_pins;
+		pins_num = ARRAY_SIZE(fli7540_gmac_mii_pins);
+		break;
+	case fli7540_ethernet_rmii:
+		phy_sel = 4;
+		enmii = 1;
+		pins = fli7540_gmac_rmii_pins;
+		pins_num = ARRAY_SIZE(fli7540_gmac_rmii_pins);
+		break;
+	case fli7540_ethernet_gmii:
+		phy_sel = 0;
+		enmii = 1;
+		pins = fli7540_gmac_gmii_pins;
+		pins_num = ARRAY_SIZE(fli7540_gmac_gmii_pins);
+		/* CFG_COMMS_CONFIG_1[18:17] = conf_pio24_alternate */
+		sysconf = readl(CFG_COMMS_CONFIG_1);
+		sysconf &= ~(0x3ul<<CONF_PIO24_ALTERNATE);
+		sysconf |= (0x2ul<<CONF_PIO24_ALTERNATE);
+		writel(sysconf, CFG_COMMS_CONFIG_1);
+		break;
+	case fli7540_ethernet_reverse_mii:
+		phy_sel = 0;
+		enmii = 0;
+		pins = fli7540_gmac_reverse_mii_pins;
+		pins_num = ARRAY_SIZE(fli7540_gmac_reverse_mii_pins);
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	/* CFG_COMMS_CONFIG_2[28:26] = phy_intf_sel */
+	sysconf = readl(CFG_COMMS_CONFIG_2);
+	sysconf &= ~(0x7ul<<PHY_INTF_SEL);
+	sysconf |= (phy_sel<<PHY_INTF_SEL);
+//	writel(sysconf, CFG_COMMS_CONFIG_2);
+
+	/* CFG_COMMS_CONFIG_2[8]     = gmac_mii_enable */
+//	sysconf = readl(CFG_COMMS_CONFIG_2);
+	SET_SYSCONF_BIT(sysconf, enmii, GMAC_MII_ENABLE);
+//	writel(sysconf, CFG_COMMS_CONFIG_2);
+
+	/* CFG_COMMS_CONFIG_2[9]     = gmac_phy_clock_sel */
+//	sysconf = readl(CFG_COMMS_CONFIG_2);
+	SET_SYSCONF_BIT(sysconf, ext_clk, GMAC_PHY_CLOCK_SEL);
+	writel(sysconf, CFG_COMMS_CONFIG_2);
+
+	/* choose the correct direction for PHYCLK */
+	pins[0].dir = (ext_clk) ? STPIO_IN : STPIO_ALT_OUT;
+
+	/* set all the PIOs correctly */
+	for (i = 0; i < pins_num; i++)
+	{
+		SET_PIO_PIN(ST40_PIO_BASE(pins[i].port), pins[i].pin, pins[i].dir);
+	}
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void fli7540_usb_init(
+	const int port,
+	const enum fli7540_usb_ovrcur_mode ovrcur_mode)
+{
+	static int xtal_initialized;
+	int clken, rstn;
+	int override, ovrcur, polarity;
+	unsigned long sysconf;
+
+	if (!xtal_initialized++)
+	{
+		sysconf = readl(CFG_SPARE_1);
+#if defined(CONFIG_SH_FLI7510)
+		SET_SYSCONF_BIT(sysconf, 0, USB_XTAL_VALID);
+#else
+		SET_SYSCONF_BIT(sysconf, 1, USB_XTAL_VALID);
+#endif	/* CONFIG_SH_FLI7510 */
+		writel(sysconf, CFG_SPARE_1);
+	}
+
+	switch (port) {
+	case 0:
+		clken = 21;
+		rstn = 23;
+		override = 12;
+		ovrcur = 13;
+		polarity = 11;
+#if defined(CONFIG_SH_FLI7510)
+		SET_PIO_PIN(ST40_PIO_BASE(27), 1, STPIO_IN);		/* USB_A_OVRCUR */
+		SET_PIO_PIN(ST40_PIO_BASE(27), 2, STPIO_ALT_OUT);	/* USB_A_PWREN */
+#else
+		SET_PIO_PIN(ST40_PIO_BASE(26), 3, STPIO_IN);		/* USB_A_OVRCUR */
+		SET_PIO_PIN(ST40_PIO_BASE(26), 4, STPIO_ALT_OUT);	/* USB_A_PWREN */
+#endif	/* CONFIG_SH_FLI7510 */
+
+		break;
+	case 1:
+		clken = 22;
+		rstn = 24;
+		override = 15;
+		ovrcur = 16;
+		polarity = 14;
+		SET_PIO_PIN(ST40_PIO_BASE(26), 5, STPIO_IN);		/* USB_C_OVRCUR */
+		SET_PIO_PIN(ST40_PIO_BASE(26), 6, STPIO_ALT_OUT);	/* USB_C_PWREN */
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+#if !defined(CONFIG_SH_FLI7510)
+	sysconf = readl(CFG_COMMS_CONFIG_1);
+		/* CFG_COMMS_CONFIG_1[22,21] = conf_usb_clk_en */
+	SET_SYSCONF_BIT(sysconf, 1, clken);
+		/* CFG_COMMS_CONFIG_1[24,23] = conf_usb_rst_n */
+	SET_SYSCONF_BIT(sysconf, 1, rstn);
+	writel(sysconf, CFG_COMMS_CONFIG_1);
+#endif	/* CONFIG_SH_FLI7510 */
+
+switch (ovrcur_mode) {
+	case fli7540_usb_ovrcur_disabled:
+		/* CFG_COMMS_CONFIG_1[12,15] = usbX_enable_pad_override */
+		sysconf = readl(CFG_COMMS_CONFIG_1);
+		SET_SYSCONF_BIT(sysconf, 1, override);
+		writel(sysconf, CFG_COMMS_CONFIG_1);
+
+		/* CFG_COMMS_CONFIG_1[13,16] = usbX_ovrcur */
+		sysconf = readl(CFG_COMMS_CONFIG_1);
+		SET_SYSCONF_BIT(sysconf, 1, ovrcur);
+		writel(sysconf, CFG_COMMS_CONFIG_1);
+		break;
+	default:
+		/* CFG_COMMS_CONFIG_1[12,15] = usbX_enable_pad_override */
+		sysconf = readl(CFG_COMMS_CONFIG_1);
+		SET_SYSCONF_BIT(sysconf, 0, override);
+		writel(sysconf, CFG_COMMS_CONFIG_1);
+
+		/* CFG_COMMS_CONFIG_1[11,14] = usbX_ovrcur_polarity */
+		switch (ovrcur_mode) {
+		case fli7540_usb_ovrcur_active_high:
+			sysconf = readl(CFG_COMMS_CONFIG_1);
+			SET_SYSCONF_BIT(sysconf, 0, polarity);
+			writel(sysconf, CFG_COMMS_CONFIG_1);
+			break;
+		case fli7540_usb_ovrcur_active_low:
+			sysconf = readl(CFG_COMMS_CONFIG_1);
+			SET_SYSCONF_BIT(sysconf, 1, polarity);
+			writel(sysconf, CFG_COMMS_CONFIG_1);
+			break;
+		default:
+			BUG();
+			break;
+		}
+		break;
+	}
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_8BIT		|
+		USB_FLAGS_STRAP_PLL		|
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD128);
+}
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI)
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void fli7540_spi_scl(const int val)
+{
+	const int pin = 2;	/* PIO21[2] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(21), pin, val ? 1 : 0);
+}
+
+extern void fli7540_spi_sda(const int val)
+{
+	const int pin = 3;	/* PIO21[3] = SPI_MOSI */
+	STPIO_SET_PIN(PIO_PORT(21), pin, val ? 1 : 0);
+}
+
+extern unsigned char fli7540_spi_read(void)
+{
+	const int pin = 5;	/* PIO20[5] = SPI_MISO */
+	return STPIO_GET_PIN(PIO_PORT(20), pin);
+}
+#endif	/* CONFIG_SOFT_SPI */
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 2;	/* PIO20[2] = SPI_CSN */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(20), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(20), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+
+#endif	/* CONFIG_SPI */
+
+
+/**********************************************************************/
+
+
+extern int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	fli7540_clocks();
+
+	/* obtain the chip cut + device id */
+	bd->bi_devid = readl(CFG_DEVICE_ID);
+
+	return 0;
+}
+
diff --git a/cpu/sh/spi.c b/cpu/sh/spi.c
index b2fcf20..00cd1a3 100644
--- a/cpu/sh/spi.c
+++ b/cpu/sh/spi.c
@@ -136,7 +136,7 @@ static unsigned eraseSize;	/* smallest supported erase size */
 static unsigned deviceSize;	/* Size of the device in Bytes */
 static const char * deviceName;	/* Name of the device */
 
-#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC) || defined(CONFIG_SPI_FLASH_WINBOND)
 static unsigned char op_erase = OP_SE;	/* erase command opcode to use */
 #endif
 
@@ -356,7 +356,7 @@ extern void spi_wait_till_ready(
 #if defined(CONFIG_SPI_FLASH_ATMEL)
 	while (!(spi_read_status(chipsel) & SR_READY))
 		;	/* do nothing */
-#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC) || defined(CONFIG_SPI_FLASH_WINBOND)
 	while (spi_read_status(chipsel) & SR_WIP)
 		;	/* do nothing */
 #else
@@ -534,6 +534,48 @@ static int spi_probe_serial_flash(
 		deviceName = "MXIC MX25L12855E";/* 128 Mbit == 16 MiB */
 	}
 
+#elif defined(CONFIG_SPI_FLASH_WINBOND)
+
+	if (
+		(devid[1] != 0xefu)	||	/* Manufacturer ID */
+		(devid[2] != 0x40u)	||	/* Memory Type */
+		(				/* Memory Capacity */
+			(devid[3] != 0x14u) &&	/* W25Q80V */
+			(devid[3] != 0x15u) &&	/* W25Q16V */
+			(devid[3] != 0x16u) &&	/* W25Q32V */
+			(devid[3] != 0x17u) &&	/* W25Q64V */
+			(devid[3] != 0x18u)	/* W25Q128V */
+		)
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize   = 256u;
+	eraseSize  = 4u<<10;			/* 4 KiB, 16 pages/sector */
+	deviceSize = 1u<<devid[3];		/* Memory Capacity */
+	if (devid[3] == 0x14u)
+	{
+		deviceName = "Winbond W25Q80V";	/*  8 Mbit == 1 MiB */
+	}
+	else if (devid[3] == 0x15u)
+	{
+		deviceName = "Winbond W25Q16V";	/* 16 Mbit == 2 MiB */
+	}
+	else if (devid[3] == 0x16u)
+	{
+		deviceName = "Winbond W25Q32V";	/* 32 Mbit == 4 MiB */
+	}
+	else if (devid[3] == 0x17u)
+	{
+		deviceName = "Winbond W25Q64V";	/* 64 Mbit == 8 MiB */
+	}
+	else if (devid[3] == 0x18u)
+	{
+		deviceName = "Winbond W25Q128V";/* 128 Mbit == 16 MiB */
+	}
+
 #else
 #error Please specify which SPI Serial Flash is being used
 #endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
@@ -547,7 +589,7 @@ static int spi_probe_serial_flash(
 		eraseSize);		/* in bytes */
 #endif
 
-#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC) || defined(CONFIG_SPI_FLASH_WINBOND)
 	/* is the device in a write protected mode ? */
 	if (status & SR_BP_MASK)	/* BPx != 0 ? */
 	{
@@ -585,7 +627,7 @@ static int spi_probe_serial_flash(
 }
 #endif	/* unlock it */
 	}
-#endif	/* CONFIG_SPI_FLASH_ST || CONFIG_SPI_FLASH_MXIC */
+#endif	/* CONFIG_SPI_FLASH_ST || CONFIG_SPI_FLASH_MXIC || defined(CONFIG_SPI_FLASH_WINBOND) */
 
 	return 0;
 }
@@ -876,7 +918,7 @@ static void my_spi_write(
 	spi_wait_till_ready(chipsel);
 #endif	/* CONFIG_STM_FSM_SPI */
 }
-#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC) || defined(CONFIG_SPI_FLASH_WINBOND)
 {
 	const unsigned pages       = eraseSize / pageSize;
 	const unsigned long sector = (address / eraseSize) * eraseSize;
@@ -886,7 +928,7 @@ static void my_spi_write(
 	const uchar * ptr;
 #if defined(CONFIG_SPI_FLASH_ST)
 	unsigned char buff[256<<10];	/* maximum of 256 KiB erase size */
-#elif defined(CONFIG_SPI_FLASH_MXIC)
+#elif defined(CONFIG_SPI_FLASH_MXIC) || defined(CONFIG_SPI_FLASH_WINBOND)
 	unsigned char buff[4<<10];	/* maximum of 4 KiB erase size */
 #endif
 #if defined(CONFIG_SOFT_SPI) || defined(CONFIG_STM_SSC_SPI)
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index cf81514..845d746 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -143,7 +143,7 @@ config_spiboot_controller:
 
 	/* Slow (divide) the SPI clock down to improve reliability. */
 	/* Note: for some (?) FSM SPI controllers, diving by 4 fails to boot! */
-#if defined(CONFIG_SH_FLI7510) || defined(CONFIG_SH_STX5206)
+#if defined(CONFIG_SH_FLI7510) || defined(CONFIG_SH_FLI7540) || defined(CONFIG_SH_STX5206)
 	mov	#6, r0			/* *ST40_EMI_SPI_CLOCKDIV = 6 */
 #else
 	mov	#4, r0			/* *ST40_EMI_SPI_CLOCKDIV = 4 */
@@ -211,17 +211,30 @@ invalidate_pmb:
 
 	/* set up the new PMB entries we want to use */
 set_pmb:
-#if defined(CONFIG_SH_STB7100)
-	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
-	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
-	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
-	#error Need to configure PMBs properly when more than 128MiB.
+#if defined(CONFIG_SH_STB7100) && defined(CONFIG_SH_HMP7100) && defined(CONFIG_SH_STB7109_CUT2)
+	SH4_SET_PMB 0 0x80 0x04  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x04  64 0 0 1	/* LMI-Sys UN-cached */
+	#if (CFG_SDRAM_SIZE > (64<<20)) || CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 64MiB.
 	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
 	SH4_SET_PMB 7 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
 	SH4_SET_PMB 8 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+#elif defined(CONFIG_SH_STB7100)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB  4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB  7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB  8 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
+	SH4_SET_PMB  9 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
+	SH4_SET_PMB 10 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
 #elif defined(CONFIG_SH_STX5197) && defined(CONFIG_SH_MB704)
 	SH4_SET_PMB 0 0x80 0x40  64 0 0 1	/* LMI-Sys UN-cached */
 	SH4_SET_PMB 2 0x90 0x40  64 0 0 1	/* LMI-Sys UN-cached */
@@ -251,6 +264,17 @@ set_pmb:
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
 	#endif	/* CFG_BOOT_FROM_NAND */
+#elif defined(CONFIG_SH_STX5206) && defined(CONFIG_SH_HDK5289)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
 #elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_MB680)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
@@ -271,7 +295,6 @@ set_pmb:
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
 	#endif	/* CFG_BOOT_FROM_NAND */
-	SH4_SET_PMB 9 0xb7 0x07  16 0 0 1	/* EPLD UN-cached */
 #elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_PDK7105)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
@@ -297,6 +320,34 @@ set_pmb:
 	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
 	#endif
 	SH4_SET_PMB 4 0xa0 0x00  64 0 0 1	/* FLASH UN-cached */
+#elif defined(CONFIG_SH_STX7108) && defined(CONFIG_SH_MB837)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	#ifdef CFG_BOOT_FROM_NAND /* booting from NAND, so CSA and CSB swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x05  16		/* NOR FLASH CACHED */
+	#else	/* else, CSA and CSB are not swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_NAND */
+#elif defined(CONFIG_SH_STX7108) && defined(CONFIG_SH_HDK7108)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  128 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xb0 0x00  128		/* NOR FLASH CACHED */
+	SH4_SET_PMB 6 0xa8 0x08  128 0 0 1	/* NAND FLASH UN-cached */
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
@@ -397,6 +448,14 @@ set_pmb:
 	#endif
 	SH4_SET_PMB 4 0xa0 0x00  64 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 5 0xa8 0x00  64		/* NOR/NAND FLASH CACHED */
+#elif defined(CONFIG_SH_FLI7540) && defined(CONFIG_SH_FUDB)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  64 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa8 0x00  64		/* NOR/NAND FLASH CACHED */
 #else
 	#error Do not know which board/chip we are using for PMB setup.
 #endif	/* defined(CONFIG_SH_STB7100) */
diff --git a/cpu/sh/stx5197/stx5197.c b/cpu/sh/stx5197/stx5197.c
index 02e8c6b..5c13142 100644
--- a/cpu/sh/stx5197/stx5197.c
+++ b/cpu/sh/stx5197/stx5197.c
@@ -30,39 +30,11 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 #include <asm/stbus.h>
+#include <asm/sysconf.h>
 #include <ata.h>
 #include <spi.h>
 
 
-#define SET_SYSCONF_BIT(reg,flag,bit)			\
-	do {						\
-		if (flag)				\
-		{	/* set bit 'bit' */		\
-			reg |= (1ul<<(bit));		\
-		}					\
-		else					\
-		{	/* clear bit 'bit' */		\
-			reg &= ~(1ul<<(bit));		\
-		}					\
-	} while (0)
-
-#define SET_SYSCONF_BITS(reg,flag,first,last,yes,no)	\
-	do {						\
-		const unsigned long _mask = 		\
-			(1ul<<((last)-(first)+1))-1ul;	\
-		/* clear all bits in 'first':'last' */	\
-		reg &= ~(_mask<<(first));		\
-		if (flag)				\
-		{	/* set 'yes' in first:last */	\
-			reg |= ((yes)<<(first));	\
-		}					\
-		else					\
-		{	/* set 'no' in first:last */	\
-			reg |= ((no)<<(first));		\
-		}					\
-	} while (0)
-
-
 static void stx5197_clocks(void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
diff --git a/cpu/sh/stx5206/stx5206.c b/cpu/sh/stx5206/stx5206.c
index c467543..5b0f14b 100644
--- a/cpu/sh/stx5206/stx5206.c
+++ b/cpu/sh/stx5206/stx5206.c
@@ -30,39 +30,11 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 #include <asm/stbus.h>
+#include <asm/sysconf.h>
 #include <ata.h>
 #include <spi.h>
 
 
-#define SET_SYSCONF_BIT(reg,flag,bit)			\
-	do {						\
-		if (flag)				\
-		{	/* set bit 'bit' */		\
-			reg |= (1ul<<(bit));		\
-		}					\
-		else					\
-		{	/* clear bit 'bit' */		\
-			reg &= ~(1ul<<(bit));		\
-		}					\
-	} while (0)
-
-#define SET_SYSCONF_BITS(reg,flag,first,last,yes,no)	\
-	do {						\
-		const unsigned long _mask = 		\
-			(1ul<<((last)-(first)+1))-1ul;	\
-		/* clear all bits in 'first':'last' */	\
-		reg &= ~(_mask<<(first));		\
-		if (flag)				\
-		{	/* set 'yes' in first:last */	\
-			reg |= ((yes)<<(first));	\
-		}					\
-		else					\
-		{	/* set 'no' in first:last */	\
-			reg |= ((no)<<(first));		\
-		}					\
-	} while (0)
-
-
 static void stx5206_clocks(void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
@@ -108,20 +80,24 @@ extern void stx5206_configure_ethernet(
 	const int phy_bus)
 {
 	unsigned int phy_sel, enmii;
+	unsigned long phy_clk_rate;
 	unsigned long sysconf;
 
 	switch (mode) {
 	case stx5206_ethernet_mii:
 		phy_sel = 0x0;
 		enmii = 1;
+		phy_clk_rate = 25000000;	/* 25 MHz */
 		break;
 	case stx5206_ethernet_rmii:
 		phy_sel = 0x4;
 		enmii = 1;
+		phy_clk_rate = 50000000;	/* 50 MHz */
 		break;
 	case stx5206_ethernet_reverse_mii:
 		phy_sel = 0x0;
 		enmii = 0;
+		phy_clk_rate = 25000000;	/* 25 MHz */
 		break;
 	default:
 		BUG();
@@ -149,15 +125,22 @@ extern void stx5206_configure_ethernet(
 	SET_SYSCONF_BIT(sysconf, enmii, ENMII);
 	writel(sysconf, STX5206_SYSCONF_SYS_CFG07);
 
-#if 0	//QQQ: what about setting the PHY clock frequency ???
 	/* Set PHY clock frequency (if used) */
 	if (!ext_clk)
 	{
-		struct clk *phy_clk = clk_get(NULL, "CLKA_ETH_PHY");
-		BUG_ON(!phy_clk);
-		clk_set_rate(phy_clk, phy_clk_rate);
-	}
+		if (phy_clk_rate == 25000000)	/* 25 MHz */
+		{
+			/* CLKGENA.CLK_DIV_LS[13] = CLK_ETHERNET_PHY = 25 MHz */
+			writel(17, STX5206_CLOCKGENA_PLL0LS_DIV13_CFG);
+		}
+#if 0		/* QQQ: Need to check this! */
+		else				/* 50 MHz */
+		{
+			/* CLKGENA.CLK_DIV_LS[13] = CLK_ETHERNET_PHY = 50 MHz */
+			writel(8, STX5206_CLOCKGENA_PLL0LS_DIV13_CFG);
+		}
 #endif
+	}
 }
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
diff --git a/cpu/sh/stx7108/Makefile b/cpu/sh/stx7108/Makefile
new file mode 100644
index 0000000..01f6dd2
--- /dev/null
+++ b/cpu/sh/stx7108/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2008,2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx7108.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx7108/stx7108.c b/cpu/sh/stx7108/stx7108.c
new file mode 100644
index 0000000..049e185
--- /dev/null
+++ b/cpu/sh/stx7108/stx7108.c
@@ -0,0 +1,881 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ * Pawel Moll <pawel.moll@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7108reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <asm/sysconf.h>
+#include <ata.h>
+#include <spi.h>
+
+#undef  BUG_ON
+#define BUG_ON(condition) do { if ((condition)!=0) BUG(); } while(0)
+
+#define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
+
+#define TRUE			1
+#define FALSE			0
+
+
+static void stx7108_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+
+/*
+ * PIO alternative Function selector
+ */
+extern void stx7108_pioalt_select(const int port, const int pin, const int alt)
+{
+	int num;
+	unsigned long sysconf, *sysconfReg;
+
+#if 0
+	printf("%s(port=%d, pin=%d, alt=%d)\n", __func__, port, pin, alt);
+	BUG_ON(pin < 0 || pin > 7);
+	BUG_ON(alt < 0 || alt > 5);
+#endif
+
+	if (alt == 0) BUG();		/* we do *not* handle this case here! */
+
+	switch (port)
+	{
+	case 0 ... 14:
+		num = port;		/* in Bank #2 */
+		sysconfReg = (unsigned long*)STX7108_BANK2_SYSGFG(num);
+		break;
+	case 15 ... 26:
+		num = port - 15;	/* in Bank #4 */
+		sysconfReg = (unsigned long*)STX7108_BANK4_SYSGFG(num);
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	sysconf = readl(sysconfReg);
+	SET_SYSCONF_BITS(sysconf, TRUE, pin*4,(pin*4)+3, alt,alt);
+	writel(sysconf, sysconfReg);
+}
+
+/* Pad configuration */
+
+const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_in = {
+	.oe = 0,
+	.pu = 0,
+	.od = 0,
+};
+#define IN (&stx7108_pioalt_pad_in)
+
+const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_out = {
+	.oe = 1,
+	.pu = 0,
+	.od = 0,
+};
+#define OUT (&stx7108_pioalt_pad_out)
+
+const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_od = {
+	.oe = 1,
+	.pu = 0,
+	.od = 1,
+};
+#define OD (&stx7108_pioalt_pad_od)
+
+const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_bidir = {
+	.oe = -1,
+	.pu = 0,
+	.od = 0,
+};
+#define BIDIR (&stx7108_pioalt_pad_bidir)
+
+void stx7108_pioalt_pad(int port, const int pin,
+		const struct stx7108_pioalt_pad_cfg * const cfg)
+{
+	int num, bit;
+	unsigned long sysconf, *sysconfReg;
+
+#if 0
+	printf("%s(port=%d, pin=%d, oe=%d, pu=%d, od=%d)\n", __func__, port, pin, cfg->oe, cfg->pu, cfg->od);
+	BUG_ON(pin < 0 || pin > 7);
+	BUG_ON(!cfg);
+#endif
+
+	switch (port)
+	{
+	case 0 ... 14:
+		num = 15 + (port / 4);	/* in Bank #2 */
+		sysconfReg = (unsigned long*)STX7108_BANK2_SYSGFG(num);
+		break;
+	case 15 ... 26:
+		port -= 15;
+		num = 12 + (port / 4);	/* in Bank #4 */
+		sysconfReg = (unsigned long*)STX7108_BANK4_SYSGFG(num);
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	bit = ((port * 8) + pin) % 32;
+
+		/* set the "Output Enable" pad control */
+	if (cfg->oe >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->oe, bit);
+		writel(sysconf, sysconfReg);
+	}
+
+	sysconfReg += 4;	/* skip 4 syscfg registers */
+
+		/* set the "Pull Up" pad control */
+	if (cfg->pu >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->pu, bit);
+		writel(sysconf, sysconfReg);
+	}
+
+	sysconfReg += 4;	/* skip another 4 syscfg registers */
+
+		/* set the "Open Drain Enable" pad control */
+	if (cfg->od >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->od, bit);
+		writel(sysconf, sysconfReg);
+	}
+}
+
+/* PIO retiming setup */
+
+/* Structure aligned to the "STi7108 Generic Retime Padlogic
+ * Application Note" SPEC */
+struct stx7108_pioalt_retime_cfg {
+	int retime:2;
+	int clk1notclk0:2;
+	int clknotdata:2;
+	int double_edge:2;
+	int invertclk:2;
+	int delay_input:2;
+};
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+static void stx7108_pioalt_retime(const int port, const int pin,
+		const struct stx7108_pioalt_retime_cfg * const cfg)
+{
+	int num;
+	unsigned long sysconf, *sysconfReg;
+
+#if 0
+	printf("%s(port=%d, pin=%d, retime=%d, clk1notclk0=%d, "
+			"clknotdata=%d, double_edge=%d, invertclk=%d, "
+			"delay_input=%d)\n", __func__, port, pin,
+			cfg->retime, cfg->clk1notclk0, cfg->clknotdata,
+			cfg->double_edge, cfg->invertclk, cfg->delay_input
+			);
+	BUG_ON(pin < 0 || pin > 7);
+#endif
+
+	switch (port)
+	{
+	case 0 ... 14:
+		switch (port)
+		{
+		case 1:
+			num = 32;
+			break;
+		case 6 ... 14:
+			num = 34 + ((port - 6) * 2);
+			break;
+		default:
+			BUG();
+			return;
+		}
+		sysconfReg = (unsigned long*)STX7108_BANK2_SYSGFG(num);
+		break;
+	case 15 ... 23:
+		num = 48 + ((port - 15) * 2);
+		sysconfReg = (unsigned long*)STX7108_BANK4_SYSGFG(num);
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	sysconfReg += 0;	/* use retime configuration register #0 */
+
+	if (cfg->clk1notclk0 >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->clk1notclk0, 0 + pin);
+		writel(sysconf, sysconfReg);
+	}
+
+	if (cfg->clknotdata >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->clknotdata, 8 + pin);
+		writel(sysconf, sysconfReg);
+	}
+
+	if (cfg->delay_input >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->delay_input, 16 + pin);
+		writel(sysconf, sysconfReg);
+	}
+
+	if (cfg->double_edge >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->double_edge, 24+ pin);
+		writel(sysconf, sysconfReg);
+	}
+
+	sysconfReg += 1;	/* use retime configuration register #1 */
+
+	if (cfg->invertclk >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->invertclk, 0 + pin);
+		writel(sysconf, sysconfReg);
+	}
+
+	if (cfg->retime >= 0)
+	{
+		sysconf = readl(sysconfReg);
+		SET_SYSCONF_BIT(sysconf, cfg->retime, 8 + pin);
+		writel(sysconf, sysconfReg);
+	}
+}
+
+struct stx7108_gmac_pin {
+	struct {
+		unsigned char port, pin, alt;
+	} pio[2];
+	enum { BYPASS = 1, CLOCK, PHY_CLOCK, DATA, DGTX } type;
+	const struct stx7108_pioalt_pad_cfg *dir;
+};
+
+static struct stx7108_gmac_pin stx7108_gmac_mii_pins[] = {
+	{ { { 9, 3, 1 }, { 15, 5, 2 } }, PHY_CLOCK, },		/* PHYCLK */
+	{ { { 6, 0, 1 }, { 16, 0, 2 } }, DATA, OUT},		/* TXD[0] */
+	{ { { 6, 1, 1 }, { 16, 1, 2 } }, DATA, OUT },		/* TXD[1] */
+	{ { { 6, 2, 1 }, { 16, 2, 2 } }, DATA, OUT },		/* TXD[2] */
+	{ { { 6, 3, 1 }, { 16, 3, 2 } }, DATA, OUT },		/* TXD[3] */
+	{ { { 7, 0, 1 }, { 17, 1, 2 } }, DATA, OUT },		/* TXER */
+	{ { { 7, 1, 1 }, { 15, 7, 2 } }, DATA, OUT },		/* TXEN */
+	{ { { 7, 2, 1 }, { 17, 0, 2 } }, CLOCK, IN },		/* TXCLK */
+	{ { { 7, 3, 1 }, { 17, 3, 2 } }, BYPASS, IN },		/* COL */
+	{ { { 7, 4, 1 }, { 17, 4, 2 } }, BYPASS, BIDIR },	/* MDIO */
+	{ { { 7, 5, 1 }, { 17, 5, 2 } }, CLOCK, OUT },		/* MDC */
+	{ { { 7, 6, 1 }, { 17, 2, 2 } }, BYPASS, IN },		/* CRS */
+	{ { { 7, 7, 1 }, { 15, 6, 2 } }, BYPASS, IN },		/* MDINT */
+	{ { { 8, 0, 1 }, { 18, 0, 2 } }, DATA, IN },		/* RXD[0] */
+	{ { { 8, 1, 1 }, { 18, 1, 2 } }, DATA, IN },		/* RXD[1] */
+	{ { { 8, 2, 1 }, { 18, 2, 2 } }, DATA, IN },		/* RXD[2] */
+	{ { { 8, 3, 1 }, { 18, 3, 2 } }, DATA, IN },		/* RXD[3] */
+	{ { { 9, 0, 1 }, { 17, 6, 2 } }, DATA, IN },		/* RXDV */
+	{ { { 9, 1, 1 }, { 17, 7, 2 } }, DATA, IN },		/* RX_ER */
+	{ { { 9, 2, 1 }, { 19, 0, 2 } }, CLOCK, IN },		/* RXCLK */
+};
+
+static struct stx7108_gmac_pin stx7108_gmac_gmii_pins[] = {
+	{ { { 9, 3, 1 }, { 15, 5, 2 } }, PHY_CLOCK, },		/* PHYCLK */
+	{ { { 6, 0, 1 }, { 16, 0, 2 } }, DATA, OUT },		/* TXD[0] */
+	{ { { 6, 1, 1 }, { 16, 1, 2 } }, DATA, OUT },		/* TXD[1] */
+	{ { { 6, 2, 1 }, { 16, 2, 2 } }, DATA, OUT },		/* TXD[2] */
+	{ { { 6, 3, 1 }, { 16, 3, 2 } }, DATA, OUT },		/* TXD[3] */
+	{ { { 6, 4, 1 }, { 16, 4, 2 } }, DATA, OUT },		/* TXD[4] */
+	{ { { 6, 5, 1 }, { 16, 5, 2 } }, DATA, OUT },		/* TXD[5] */
+	{ { { 6, 6, 1 }, { 16, 6, 2 } }, DATA, OUT },		/* TXD[6] */
+	{ { { 6, 7, 1 }, { 16, 7, 2 } }, DATA, OUT },		/* TXD[7] */
+	{ { { 7, 0, 1 }, { 17, 1, 2 } }, DATA, OUT },		/* TXER */
+	{ { { 7, 1, 1 }, { 15, 7, 2 } }, DATA, OUT },		/* TXEN */
+	{ { { 7, 2, 1 }, { 17, 0, 2 } }, CLOCK, IN },		/* TXCLK */
+	{ { { 7, 3, 1 }, { 17, 3, 2 } }, BYPASS, IN },		/* COL */
+	{ { { 7, 4, 1 }, { 17, 4, 2 } }, BYPASS, BIDIR },	/* MDIO */
+	{ { { 7, 5, 1 }, { 17, 5, 2 } }, CLOCK, OUT },		/* MDC */
+	{ { { 7, 6, 1 }, { 17, 2, 2 } }, BYPASS, IN },		/* CRS */
+	{ { { 7, 7, 1 }, { 15, 6, 2 } }, BYPASS, IN },		/* MDINT */
+	{ { { 8, 0, 1 }, { 18, 0, 2 } }, DATA, IN }, 		/* RXD[0] */
+	{ { { 8, 1, 1 }, { 18, 1, 2 } }, DATA, IN }, 		/* RXD[1] */
+	{ { { 8, 2, 1 }, { 18, 2, 2 } }, DATA, IN }, 		/* RXD[2] */
+	{ { { 8, 3, 1 }, { 18, 3, 2 } }, DATA, IN }, 		/* RXD[3] */
+	{ { { 8, 4, 1 }, { 18, 4, 2 } }, DATA, IN }, 		/* RXD[4] */
+	{ { { 8, 5, 1 }, { 18, 5, 2 } }, DATA, IN }, 		/* RXD[5] */
+	{ { { 8, 6, 1 }, { 18, 6, 2 } }, DATA, IN }, 		/* RXD[6] */
+	{ { { 8, 7, 1 }, { 18, 7, 2 } }, DATA, IN }, 		/* RXD[7] */
+	{ { { 9, 0, 1 }, { 17, 6, 2 } }, DATA, IN },		/* RXDV */
+	{ { { 9, 1, 1 }, { 17, 7, 2 } }, DATA, IN },		/* RX_ER */
+	{ { { 9, 2, 1 }, { 19, 0, 2 } }, CLOCK, IN  },		/* RXCLK */
+};
+
+static struct stx7108_gmac_pin stx7108_gmac_gmii_gtx_pins[] = {
+	{ { { 9, 3, 3 }, { 15, 5, 4 } }, PHY_CLOCK, },		/* PHYCLK */
+	{ { { 6, 0, 1 }, { 16, 0, 2 } }, DATA, OUT },		/* TXD[0] */
+	{ { { 6, 1, 1 }, { 16, 1, 2 } }, DATA, OUT },		/* TXD[1] */
+	{ { { 6, 2, 1 }, { 16, 2, 2 } }, DATA, OUT },		/* TXD[2] */
+	{ { { 6, 3, 1 }, { 16, 3, 2 } }, DATA, OUT },		/* TXD[3] */
+	{ { { 6, 4, 1 }, { 16, 4, 2 } }, DGTX, OUT },		/* TXD[4] */
+	{ { { 6, 5, 1 }, { 16, 5, 2 } }, DGTX, OUT },		/* TXD[5] */
+	{ { { 6, 6, 1 }, { 16, 6, 2 } }, DGTX, OUT },		/* TXD[6] */
+	{ { { 6, 7, 1 }, { 16, 7, 2 } }, DGTX, OUT },		/* TXD[7] */
+	{ { { 7, 0, 1 }, { 17, 1, 2 } }, DATA, OUT },		/* TXER */
+	{ { { 7, 1, 1 }, { 15, 7, 2 } }, DATA, OUT },		/* TXEN */
+	{ { { 7, 2, 1 }, { 17, 0, 2 } }, CLOCK, IN },		/* TXCLK */
+	{ { { 7, 3, 1 }, { 17, 3, 2 } }, BYPASS, IN },		/* COL */
+	{ { { 7, 4, 1 }, { 17, 4, 2 } }, BYPASS, BIDIR },	/* MDIO */
+	{ { { 7, 5, 1 }, { 17, 5, 2 } }, CLOCK, OUT },		/* MDC */
+	{ { { 7, 6, 1 }, { 17, 2, 2 } }, BYPASS, IN },		/* CRS */
+	{ { { 7, 7, 1 }, { 15, 6, 2 } }, BYPASS, IN },		/* MDINT */
+	{ { { 8, 0, 1 }, { 18, 0, 2 } }, DATA, IN }, 		/* RXD[0] */
+	{ { { 8, 1, 1 }, { 18, 1, 2 } }, DATA, IN }, 		/* RXD[1] */
+	{ { { 8, 2, 1 }, { 18, 2, 2 } }, DATA, IN }, 		/* RXD[2] */
+	{ { { 8, 3, 1 }, { 18, 3, 2 } }, DATA, IN }, 		/* RXD[3] */
+	{ { { 8, 4, 1 }, { 18, 4, 2 } }, DGTX, IN }, 		/* RXD[4] */
+	{ { { 8, 5, 1 }, { 18, 5, 2 } }, DGTX, IN }, 		/* RXD[5] */
+	{ { { 8, 6, 1 }, { 18, 6, 2 } }, DGTX, IN }, 		/* RXD[6] */
+	{ { { 8, 7, 1 }, { 18, 7, 2 } }, DGTX, IN }, 		/* RXD[7] */
+	{ { { 9, 0, 1 }, { 17, 6, 2 } }, DATA, IN },		/* RXDV */
+	{ { { 9, 1, 1 }, { 17, 7, 2 } }, DATA, IN },		/* RX_ER */
+	{ { { 9, 2, 1 }, { 19, 0, 2 } }, CLOCK, IN  },		/* RXCLK */
+};
+
+/* At the time of writing the suggested retime configuration for
+ * MII pads in RMII mode was "BYPASS"... */
+static struct stx7108_gmac_pin stx7108_gmac_rmii_pins[] = {
+	{ { { 9, 3, 2 }, { 15, 5, 3 } }, BYPASS, },		/* PHYCLK */
+	{ { { 6, 0, 1 }, { 16, 0, 2 } }, BYPASS, OUT },		/* TXD[0] */
+	{ { { 6, 1, 1 }, { 16, 1, 2 } }, BYPASS, OUT },		/* TXD[1] */
+	{ { { 7, 0, 1 }, { 17, 1, 2 } }, BYPASS, OUT },		/* TXER */
+	{ { { 7, 1, 1 }, { 15, 7, 2 } }, BYPASS, OUT },		/* TXEN */
+	{ { { 7, 4, 1 }, { 17, 4, 2 } }, BYPASS, BIDIR },	/* MDIO */
+	{ { { 7, 5, 1 }, { 17, 5, 2 } }, BYPASS, OUT },		/* MDC */
+	{ { { 7, 7, 1 }, { 15, 6, 2 } }, BYPASS, IN  },		/* MDINT */
+	{ { { 8, 0, 1 }, { 18, 0, 2 } }, BYPASS, IN  },		/* RXD[0] */
+	{ { { 8, 1, 1 }, { 18, 1, 2 } }, BYPASS, IN  },		/* RXD[1] */
+	{ { { 9, 0, 1 }, { 17, 6, 2 } }, BYPASS, IN  },		/* RXDV */
+	{ { { 9, 1, 1 }, { 17, 7, 2 } }, BYPASS, IN  },		/* RX_ER */
+};
+
+static struct stx7108_gmac_pin stx7108_gmac_reverse_mii_pins[] = {
+	{ { { 9, 3, 1 }, { 15, 5, 2 } }, PHY_CLOCK, },		/* PHYCLK */
+	{ { { 6, 0, 1 }, { 16, 0, 2 } }, DATA, OUT },		/* TXD[-1] */
+	{ { { 6, 1, 1 }, { 16, 1, 2 } }, DATA, OUT },		/* TXD[1] */
+	{ { { 6, 2, 1 }, { 16, 2, 2 } }, DATA, OUT },		/* TXD[2] */
+	{ { { 6, 3, 1 }, { 16, 3, 2 } }, DATA, OUT },		/* TXD[3] */
+	{ { { 7, 0, 1 }, { 17, 1, 2 } }, DATA, OUT },		/* TXER */
+	{ { { 7, 1, 1 }, { 15, 7, 2 } }, DATA, OUT },		/* TXEN */
+	{ { { 7, 2, 1 }, { 17, 0, 2 } }, CLOCK, IN },		/* TXCLK */
+	{ { { 7, 3, 2 }, { 17, 3, 3 } }, BYPASS, OUT },		/* COL */
+	{ { { 7, 4, 1 }, { 17, 4, 2 } }, BYPASS, BIDIR },	/* MDIO */
+	{ { { 7, 5, 2 }, { 17, 5, 3 } }, CLOCK, IN },		/* MDC */
+	{ { { 7, 6, 2 }, { 17, 2, 3 } }, BYPASS, OUT },		/* CRS */
+	{ { { 7, 7, 1 }, { 15, 6, 2 } }, BYPASS, IN },		/* MDINT */
+	{ { { 8, 0, 1 }, { 18, 0, 2 } }, DATA, IN },		/* RXD[0] */
+	{ { { 8, 1, 1 }, { 18, 1, 2 } }, DATA, IN },		/* RXD[1] */
+	{ { { 8, 2, 1 }, { 18, 2, 2 } }, DATA, IN },		/* RXD[2] */
+	{ { { 8, 3, 1 }, { 18, 3, 2 } }, DATA, IN },		/* RXD[3] */
+	{ { { 9, 0, 1 }, { 17, 6, 2 } }, DATA, IN },		/* RXDV */
+	{ { { 9, 1, 1 }, { 17, 7, 2 } }, DATA, IN },		/* RX_ER */
+	{ { { 9, 2, 1 }, { 19, 0, 2 } }, CLOCK, IN },		/* RXCLK */
+};
+
+#define MAC_SPEED_SEL		1	/* [1:1] */
+#define PHY_SEL			2,4	/* [4:2] */
+#define ENMII			5	/* [5:5] */
+
+#define ENABLE_GMAC		0	/* [0:0] */
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+#if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0 */
+#	define STX7108_MII_SYSGFG(x)	(STX7108_BANK2_SYSGFG(x))
+#elif CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE		/* MII1 */
+#	define STX7108_MII_SYSGFG(x)	(STX7108_BANK4_SYSGFG(x))
+#else
+#error Unknown base address for the STM GMAC
+#endif
+
+extern void stmac_set_mac_speed(int speed)
+{
+#if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0 */
+	unsigned long * const sysconfReg = (void*)STX7108_MII_SYSGFG(27);
+#elif CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE		/* MII1 */
+	unsigned long * const sysconfReg = (void*)STX7108_MII_SYSGFG(23);
+#else
+#error Unknown base address for the STM GMAC
+#endif
+	unsigned long sysconf = *sysconfReg;
+
+	/* MIIx_MAC_SPEED_SEL = 0|1 */
+	SET_SYSCONF_BIT(sysconf, (speed==100), MAC_SPEED_SEL);
+
+	*sysconfReg = sysconf;
+}
+
+/* ETH MAC pad configuration */
+extern void stx7108_configure_ethernet(
+	const int port,
+	const struct stx7108_ethernet_config * const config)
+{
+	unsigned long sysconf;
+
+	int sc_regnum;
+	struct stx7108_gmac_pin *pins;
+	int pins_num;
+	unsigned char phy_sel, enmii;
+	int i;
+
+	switch (port) {
+	case 0:
+		sc_regnum = 27;
+		/* ENABLE_GMAC0 */
+		sysconf = *STX7108_MII_SYSGFG(53);
+		SET_SYSCONF_BIT(sysconf, TRUE, ENABLE_GMAC);
+		*STX7108_MII_SYSGFG(53) = sysconf;
+		break;
+	case 1:
+		sc_regnum = 23;
+		/* ENABLE_GMAC1 */
+		sysconf = *STX7108_MII_SYSGFG(67);
+		SET_SYSCONF_BIT(sysconf, TRUE, ENABLE_GMAC);
+		*STX7108_MII_SYSGFG(67) = sysconf;
+		break;
+	default:
+		BUG();
+		return;
+	};
+
+	switch (config->mode) {
+	case stx7108_ethernet_mode_mii:
+		phy_sel = 0;
+		enmii = 1;
+		pins = stx7108_gmac_mii_pins;
+		pins_num = ARRAY_SIZE(stx7108_gmac_mii_pins);
+		break;
+	case stx7108_ethernet_mode_rmii:
+		phy_sel = 4;
+		enmii = 1;
+		pins = stx7108_gmac_rmii_pins;
+		pins_num = ARRAY_SIZE(stx7108_gmac_rmii_pins);
+		break;
+	case stx7108_ethernet_mode_gmii:
+		phy_sel = 0;
+		enmii = 1;
+		pins = stx7108_gmac_gmii_pins;
+		pins_num = ARRAY_SIZE(stx7108_gmac_gmii_pins);
+		break;
+	case stx7108_ethernet_mode_gmii_gtx:
+		phy_sel = 0;
+		enmii = 1;
+		pins = stx7108_gmac_gmii_gtx_pins;
+		pins_num = ARRAY_SIZE(stx7108_gmac_gmii_gtx_pins);
+		break;
+	case stx7108_ethernet_mode_reverse_mii:
+		phy_sel = 0;
+		enmii = 0;
+		pins = stx7108_gmac_reverse_mii_pins;
+		pins_num = ARRAY_SIZE(stx7108_gmac_reverse_mii_pins);
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	/* MIIx_PHY_SEL */
+	sysconf = *STX7108_MII_SYSGFG(sc_regnum);
+	SET_SYSCONF_BITS(sysconf, TRUE, 2,4, phy_sel,phy_sel);
+	*STX7108_MII_SYSGFG(sc_regnum) = sysconf;
+
+	/* ENMIIx */
+	sysconf = *STX7108_MII_SYSGFG(sc_regnum);
+	SET_SYSCONF_BIT(sysconf, enmii, ENMII);
+	*STX7108_MII_SYSGFG(sc_regnum) = sysconf;
+
+	pins[0].dir = config->ext_clk ? IN : OUT;
+
+	for (i = 0; i < pins_num; i++) {
+		const struct stx7108_gmac_pin *pin = &pins[i];
+		int portno = pin->pio[port].port;
+		int pinno = pin->pio[port].pin;
+		struct stx7108_pioalt_retime_cfg retime_cfg = {
+			-1, -1, -1, -1, -1, -1 /* -1 means "do not set */
+		};
+
+		stx7108_pioalt_select(portno, pinno, pin->pio[port].alt);
+
+		stx7108_pioalt_pad(portno, pinno, pin->dir);
+
+		switch (pin->type) {
+		case BYPASS:
+			retime_cfg.clknotdata = 0;
+			retime_cfg.retime = 0;
+			break;
+		case CLOCK:
+			retime_cfg.clknotdata = 1;
+			retime_cfg.clk1notclk0 = port;
+			break;
+		case PHY_CLOCK:
+			retime_cfg.clknotdata = 1;
+			if (config->mode == stx7108_ethernet_mode_gmii_gtx) {
+				retime_cfg.clk1notclk0 = 1;
+				retime_cfg.double_edge = 0;
+			} else {
+				retime_cfg.clk1notclk0 = 0;
+			}
+			break;
+		case DGTX: /* extra configuration for GMII (GTK CLK) */
+			if (port == 1) {
+				retime_cfg.retime = 1;
+				retime_cfg.clk1notclk0 = 1;
+				retime_cfg.double_edge = 0;
+				retime_cfg.clknotdata = 0;
+			} else {
+				retime_cfg.retime = 1;
+				retime_cfg.clk1notclk0 = 0;
+				retime_cfg.double_edge = 0;
+				retime_cfg.clknotdata = 0;
+			}
+			break;
+		case DATA:
+			retime_cfg.clknotdata = 0;
+			retime_cfg.retime = 1;
+			retime_cfg.clk1notclk0 = port;
+			break;
+		default:
+			BUG();
+			break;
+		}
+		stx7108_pioalt_retime(portno, pinno, &retime_cfg);
+	}
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+extern int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7108_clocks();
+
+	bd->bi_devid = *STX7108_SYSCONF_DEVICEID_0;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern int stx7108_usb_init(int port, int over_current, int power_ctrl)
+{
+#ifdef QQQ	/* QQQ - DELETE */
+	unsigned long reg;
+	const unsigned char oc_pins[2]    = {4, 6};	/* PIO4 */
+	const unsigned char power_pins[2] = {5, 7};	/* PIO4 */
+
+	if (port >= sizeof(oc_pins))	/* invalid port number ? */
+		return -1;		/* failed to initialize! */
+
+	/* Power on the USB */
+	reg = readl(STX7105_SYSCONF_SYS_CFG32);
+	/* Power up USB host controller */
+	/* USBn_HC_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(4+port));
+	/* Power up USB PHY */
+	/* USBn_PHY_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(6+port));
+	writel(reg, STX7105_SYSCONF_SYS_CFG32);
+
+	if (over_current) {
+		/* USB overcurrent enable */
+		reg = readl(STX7105_SYSCONF_SYS_CFG04);
+		/* USB0_PRT_OVCURR_POL = 0 = Active Low */
+		reg &= ~(1ul<<(3+port));
+		/* USBn_PRT_OVCURR_IN = 0 = PIO4[oc_pins[port]] */
+		reg &= ~(1ul<<(5+port));
+		/* CFG_USBn_OVRCURR_ENABLE = 1 = OC Enabled */
+		reg |= 1ul<<(11+port);
+		writel(reg, STX7105_SYSCONF_SYS_CFG04);
+
+		/* Route USBn OC Routing via PIO4[oc_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[oc_pins[port]] CFG34[8+oc_pins[port],oc_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(oc_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for OC as IN */
+		SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
+	}
+
+	if (power_ctrl) {
+		/* Route USBn POWER Routing via PIO4[power_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[power_pins[port]] CFG34[8+power_pins[port],power_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(power_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for POWER as ALT_OUT */
+		SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+	}
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_8BIT |
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD128);
+
+	return 0;
+#endif		/* QQQ - DELETE */
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7108_configure_sata(void)
+{
+#ifdef QQQ	/* QQQ - DELETE */
+	static int initialised_phy = 0;
+	unsigned long sysconf;
+
+	if (!initialised_phy)
+	{
+		/* Power up the SATA PHY */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<9);	/* [11] SATA1_PHY_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* Power up the SATA host */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<11);	/* [9] SATA1_HC_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+#endif		/* QQQ - DELETE */
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
+#if defined(CONFIG_CMD_I2C) && defined(CONFIG_SOFT_I2C)
+struct ssc_pios
+{
+	struct
+	{
+		char port;
+		char pin;
+	}	pio[3];
+};
+static const struct ssc_pios ssc_pios[7] =
+{
+	{ { /* SSC0 */
+		{ 1, 6 }, /* SCLK */
+		{ 1, 7 }, /* MTSR */
+		{ 2, 0 }, /* MRST */
+	} }, { { /* SSC1 */
+		{ 9, 6 }, /* SCLK */
+		{ 9, 7 }, /* MTSR */
+		{ 9, 5 }, /* MRST */
+	} }, { { /* SSC2 */
+#if 1
+		{ 1, 3 }, /* SCLK */	/* Variant A */
+		{ 1, 4 }, /* MTSR */
+		{ 1, 5 }, /* MRST */
+#else
+		{ 14, 4 }, /* SCLK */	/* Variant B */
+		{ 14, 5 }, /* MTSR */
+		{ 14, 6 }, /* MRST */
+#endif
+	} }, { { /* SSC3 */
+		{ 5, 2 }, /* SCLK */
+		{ 5, 3 }, /* MTSR */
+		{ 5, 4 }, /* MRST */
+	} }, { { /* SSC4 */
+		{ 13, 6 }, /* SCLK */
+		{ 13, 7 }, /* MTSR */
+		{ 14, 0 }, /* MRST */
+	} }, { { /* SSC5 */
+		{ 5, 6 }, /* SCLK */
+		{ 5, 7 }, /* MTSR */
+		{ 5, 5 }, /* MRST */
+	} }, { { /* SSC6 */
+		{ 15, 2 }, /* SCLK */
+		{ 15, 3 }, /* MTSR */
+		{ 15, 4 }, /* MRST */
+	} },
+};
+// static const int stx7108_ssc_alt_funcs[] = { 2, 1, 2, 2, 1, 2, 1 };
+
+
+extern void stx7108_configure_i2c(void)
+{
+	/*
+	 * The I2C busses are routed as follows:
+	 *
+	 *	Bus	  SCL		  SDA
+	 *	---	  ---		  ---
+	 *	 0	PIO1[6]		PIO1[7]		SSC #0
+	 *	 1	PIO9[6]		PIO9[7]		SSC #1
+	 *	 2	PIO1[3]		PIO1[4]		SSC #2, Variant A
+	 *	 2	PIO14[4]	PIO14[5]	SSC #2, Variant B
+	 *	 3	PIO5[2]		PIO5[3]		SSC #3
+	 *	 4	PIO13[6]	PIO13[7]	SSC #4
+	 *	 5	PIO5[6]		PIO5[7]		SSC #5
+	 *	 6	PIO15[2]	PIO15[3]	SSC #6
+	 */
+	const int scl_port = ssc_pios[CONFIG_I2C_BUS].pio[0].port;
+	const int scl_pin  = ssc_pios[CONFIG_I2C_BUS].pio[0].pin;
+	const int sda_port = ssc_pios[CONFIG_I2C_BUS].pio[1].port;
+	const int sda_pin  = ssc_pios[CONFIG_I2C_BUS].pio[1].pin;
+
+	if (CONFIG_I2C_BUS >= ARRAY_SIZE(ssc_pios)) BUG();
+
+	SET_PIO_PIN(ST40_PIO_BASE(scl_port), scl_pin, STPIO_BIDIR);	/* I2C_SCL */
+	SET_PIO_PIN(ST40_PIO_BASE(sda_port), sda_pin, STPIO_BIDIR);	/* I2C_SDA */
+}
+
+extern void stx7108_i2c_scl(const int val)
+{
+	/* SSC's SCLK == I2C's SCL */
+	const int port = ssc_pios[CONFIG_I2C_BUS].pio[0].port;
+	const int pin  = ssc_pios[CONFIG_I2C_BUS].pio[0].pin;
+	STPIO_SET_PIN(ST40_PIO_BASE(port), pin, (val) ? 1 : 0);
+}
+
+extern void stx7108_i2c_sda(const int val)
+{
+	/* SSC's MTSR == I2C's SDA */
+	const int port = ssc_pios[CONFIG_I2C_BUS].pio[1].port;
+	const int pin  = ssc_pios[CONFIG_I2C_BUS].pio[1].pin;
+	STPIO_SET_PIN(ST40_PIO_BASE(port), pin, (val) ? 1 : 0);
+}
+
+extern int stx7108_i2c_read(void)
+{
+	/* SSC's MTSR == I2C's SDA */
+	const int port = ssc_pios[CONFIG_I2C_BUS].pio[1].port;
+	const int pin  = ssc_pios[CONFIG_I2C_BUS].pio[1].pin;
+	return STPIO_GET_PIN(ST40_PIO_BASE(port), pin);
+}
+#endif	/* defined(CONFIG_CMD_I2C) && defined(CONFIG_SOFT_I2C) */
+
+#if defined(CONFIG_I2C_CMD_TREE)
+extern unsigned int i2c_get_bus_speed(void)
+{
+	return CFG_I2C_SPEED;
+}
+extern int i2c_set_bus_speed(unsigned int speed)
+{
+	return -1;
+}
+#endif	/* CONFIG_I2C_CMD_TREE */
+
+
+#if defined(CONFIG_SPI)
+#ifdef QQQ	/* QQQ - DELETE */
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void stx7108_spi_scl(const int val)
+{
+	const int pin = 0;	/* PIO15[0] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern void stx7108_spi_sda(const int val)
+{
+	const int pin = 1;	/* PIO15[1] = SPI_DOUT */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern unsigned char stx7108_spi_read(void)
+{
+	const int pin = 3;	/* PIO15[3] = SPI_DIN */
+	return STPIO_GET_PIN(PIO_PORT(15), pin);
+}
+#endif	/* CONFIG_SOFT_SPI */
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 2;	/* PIO15[2] = SPI_NOTCS */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+
+#endif		/* QQQ - DELETE */
+#endif	/* CONFIG_SPI */
+
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 9cadab4..09ad445 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2009 STMicroelectronics Limited
+ * Copyright (C) 2007-2010 STMicroelectronics Limited
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -60,7 +60,13 @@ extern int usb_cpu_init(void)
 #elif defined(CONFIG_SH_STX7200)
 	stx7200_usb_init();
 #elif defined(CONFIG_SH_FLI7510)
-	fli7105_usb_init (fli7510_usb_ovrcur_active_low);
+	fli7510_usb_init (fli7510_usb_ovrcur_active_low);
+#elif defined(CONFIG_SH_FLI7540)
+#if CFG_USB_BASE == CFG_USB_A_BASE	/* USB #1 */
+	fli7540_usb_init (0, fli7540_usb_ovrcur_active_low);
+#elif CFG_USB_BASE == CFG_USB_C_BASE	/* USB #2 */
+	fli7540_usb_init (1, fli7540_usb_ovrcur_active_low);
+#endif	/* CFG_USB_BASE ... */
 #else
 #error Missing Device Definitions!
 #endif
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index 8b914d2..3de854d 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -498,11 +498,17 @@ static unsigned int stmac_mii_read (int phy_addr, int reg)
 static int stmac_miiphy_read (char *devname, unsigned char addr, unsigned char reg, unsigned short *value)
 {
 	*value = stmac_mii_read (addr, reg);
+#if 0
+	printf("QQQ: %s(addr=%u, reg=%u) --> value=0x%04x)\n", __FUNCTION__, addr, reg, *value);
+#endif
 	return 0;
 }
 
 static int stmac_miiphy_write (char *devname, unsigned char addr, unsigned char reg, unsigned short value)
 {
+#if 0
+	printf("QQQ: %s(addr=%u, reg=%u, value=0x%04x)\n", __FUNCTION__, addr, reg, value);
+#endif
 	stmac_mii_write (addr, reg, value);
 	return 0;
 }
diff --git a/drivers/usb/usb_ohci.c b/drivers/usb/usb_ohci.c
index 3c64aba..f70fad5 100644
--- a/drivers/usb/usb_ohci.c
+++ b/drivers/usb/usb_ohci.c
@@ -68,7 +68,8 @@
     defined(CONFIG_S3C2410) || \
     defined(CONFIG_440EP) || \
     defined(CONFIG_PCI_OHCI) || \
-    defined(CONFIG_MPC5200)
+    defined(CONFIG_MPC5200) || \
+    defined(CONFIG_SH_FLI7510)
 # define OHCI_USE_NPS		/* force NoPowerSwitching mode */
 #endif
 
@@ -86,7 +87,7 @@
 #ifdef __SH4__
 #if defined(CONFIG_SH_SE_MODE)
 #	define PHYSICAL_ADDR(addr)	\
-	((__u32)(addr) ? ((0x1ffffffful&(__u32)(addr))|0x40000000ul) : 0ul)
+	((__u32)(addr) ? ((0x1ffffffful&(__u32)(addr))|(CFG_SE_PHYSICAL_BASE)) : 0ul)
 #else
 #	define PHYSICAL_ADDR(addr)	( 0x1ffffffful & (__u32)(addr) )
 #endif	/* CONFIG_SH_SE_MODE */
diff --git a/include/asm-sh/addrspace.h b/include/asm-sh/addrspace.h
index 78c8e54..f00393d 100644
--- a/include/asm-sh/addrspace.h
+++ b/include/asm-sh/addrspace.h
@@ -70,8 +70,23 @@
 #define P2SEGADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_UNACHED_BASE)
 	/*
 	 *	Convert VIRTUAL address to a PHYSICAL one.
+	 *	Our normal convention is that SDRAM is mapped in PMB virtual
+	 *	space between 0x80000000..0x9fffffff. Hence, we wish to map virtual
+	 *	addresses in this range to the appropriate physical address in
+	 *	SDRAM, which we assume is determined by the SDRAM window + base.
+	 *	For *all* other addresses, we assume they are *not* in SDRAM,
+	 *	and hence, we do not map them at all!
+	 *	Note: to do this 'properly', then we would need to loop round
+	 *	all the PMB slots to decode each PMB slot, and the match on the
+	 *	correct one. In practice, the above should suffice!
 	 */
-#define PHYSADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_PHYSICAL_BASE)
+#define PHYSADDR(a)								\
+(										\
+	/* SDRAM is 0x80 to 0x9F, just check the top 3 bits */			\
+	(((unsigned long)(a)&0xE0000000ul)==0x80000000ul)		?	\
+	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_PHYSICAL_BASE)	:	\
+	((unsigned long)(a))							\
+)
 #endif	/* CONFIG_SH_SE_MODE */
 
 #endif /* __ASM_SH_ADDRSPACE_H */
diff --git a/include/asm-sh/fli7510reg.h b/include/asm-sh/fli7510reg.h
index 3217756..cb4e081 100644
--- a/include/asm-sh/fli7510reg.h
+++ b/include/asm-sh/fli7510reg.h
@@ -165,13 +165,13 @@
 /*----------------------------------------------------------------------------*/
 
 /* Device ID values, masks & predicates */
-#define FLI7510_DEVID_7510_VAL		0x23c
+#define FLI7510_DEVID_7510_VAL		0x23c	/* for cut 0.x */
 #define FLI7510_DEVID_ID_SHIFT		12
 #define FLI7510_DEVID_ID_MASK		0x3ff
 #define FLI7510_DEVID_CUT_SHIFT		28
 #define FLI7510_DEVID_CUT_MASK		0xf
 
 #define FLI7510_DEVICEID_7510(ID) ((((ID) >> FLI7510_DEVID_ID_SHIFT) & FLI7510_DEVID_ID_MASK) == FLI7510_DEVID_7510_VAL)
-#define FLI7510_DEVICEID_CUT(ID)  ((((ID) >> FLI7510_DEVID_CUT_SHIFT) & FLI7510_DEVID_CUT_MASK) + 1)
+#define FLI7510_DEVICEID_CUT(ID)  ((((ID) >> FLI7510_DEVID_CUT_SHIFT) & FLI7510_DEVID_CUT_MASK) + 0)
 
 #endif /* __FLI7510REG_H */
diff --git a/include/asm-sh/fli7540reg.h b/include/asm-sh/fli7540reg.h
new file mode 100644
index 0000000..c59fae7
--- /dev/null
+++ b/include/asm-sh/fli7540reg.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2009-2010
+ *
+ * All rights reserved.
+ */
+
+#ifndef __FLI7540REG_H
+#define __FLI7540REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+	/*
+	 *	PIO_BK_5 ... PIO_BK_29
+	 */
+#define ST40_PIO5_REGS_BASE	0xfd5c0000
+#define ST40_PIO6_REGS_BASE	0xfd5c4000
+#define ST40_PIO7_REGS_BASE	0xfd5c8000
+#define ST40_PIO8_REGS_BASE	0xfd5cc000
+#define ST40_PIO9_REGS_BASE	0xfd5d0000
+#define ST40_PIO10_REGS_BASE	0xfd984000
+#define ST40_PIO11_REGS_BASE	0xfd988000
+#define ST40_PIO12_REGS_BASE	0xfd98c000
+#define ST40_PIO13_REGS_BASE	0xfd990000
+#define ST40_PIO14_REGS_BASE	0xfd994000
+#define ST40_PIO15_REGS_BASE	0xfd998000
+#define ST40_PIO16_REGS_BASE	0xfd99c000
+#define ST40_PIO17_REGS_BASE	0xfd9a0000
+#define ST40_PIO18_REGS_BASE	0xfd9a4000
+#define ST40_PIO19_REGS_BASE	0xfd9a8000
+#define ST40_PIO20_REGS_BASE	0xfd9ac000
+#define ST40_PIO21_REGS_BASE	0xfd9b0000
+#define ST40_PIO22_REGS_BASE	0xfd9b4000
+#define ST40_PIO23_REGS_BASE	0xfd9b8000
+#define ST40_PIO24_REGS_BASE	0xfd9bc000
+#define ST40_PIO25_REGS_BASE	0xfd9c0000
+#define ST40_PIO26_REGS_BASE	0xfd9c4000
+#define ST40_PIO27_REGS_BASE	0xfd9c8000
+#define ST40_PIO28_REGS_BASE	0xfd9cc000
+#define ST40_PIO29_REGS_BASE	0xfd9d0000
+
+#define ST40_PIO_BASE(x)					\
+	(((x) < 10)						\
+		? (ST40_PIO5_REGS_BASE +(0x4000*(x-5)))		\
+		: (ST40_PIO10_REGS_BASE+(0x4000*((x)-10))))
+
+/*----------------------------------------------------------------------------*/
+
+
+	/*
+	 * Comms block
+	 */
+#ifndef FLI7540_COMMS_BASE
+#define FLI7540_COMMS_BASE	0xfdb00000
+#endif
+
+#ifndef ST40_ASC0_REGS_BASE	/* UART #1 */
+#define ST40_ASC0_REGS_BASE	(FLI7540_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE	/* UART #2 */
+#define ST40_ASC1_REGS_BASE	(FLI7540_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE	/* UART #3 */
+#define ST40_ASC2_REGS_BASE	(FLI7540_COMMS_BASE + 0x00032000)
+#endif
+
+
+/*----------------------------------------------------------------------------*/
+
+
+	/*
+	 * System Configuration Registers
+	 */
+#define PRB_PU_CFG_1			0xfd220000
+#define PRB_PU_CFG_2			0xfd228000
+#define TRS_PU_CFG_0			0xfd9ec000
+#define TRS_PU_CFG_1			0xfd9f4000
+#define VDEC_PU_CFG_0			0xfd7a0000
+#define VDEC_PU_CFG_1			0xfd7c0000
+#define VOUT_PU_CFG_1			0xfd5e8000
+
+#define CFG_RESET_CTL			(PRB_PU_CFG_1 + 0x00)
+#define CFG_BOOT_CTL			(PRB_PU_CFG_1 + 0x04)
+#define CFG_SYS1			(PRB_PU_CFG_1 + 0x08)
+#define CFG_MPX_CTL			(PRB_PU_CFG_1 + 0x0c)
+#define CFG_PWR_DWN_CTL			(PRB_PU_CFG_1 + 0x10)
+#define CFG_SYS2			(PRB_PU_CFG_1 + 0x14)
+#define CFG_MODE_PIN_STATUS		(PRB_PU_CFG_1 + 0x18)
+#define CFG_PCI_ROPC_STATUS		(PRB_PU_CFG_1 + 0x1c)
+
+#define CFG_ST40_HOST_BOOT_ADDR		(PRB_PU_CFG_2 + 0x00)
+#define CFG_ST40_CTL_BOOT_ADDR		(PRB_PU_CFG_2 + 0x04)
+#define CFG_SYS10			(PRB_PU_CFG_2 + 0x08)
+#define CFG_RNG_BIST_CTL		(PRB_PU_CFG_2 + 0x0c)
+#define CFG_SYS12			(PRB_PU_CFG_2 + 0x10)
+#define CFG_SYS13			(PRB_PU_CFG_2 + 0x14)
+#define CFG_SYS14			(PRB_PU_CFG_2 + 0x18)
+#define CFG_EMI_ROPC_STATUS		(PRB_PU_CFG_2 + 0x1c)
+
+#define CFG_COMMS_CONFIG_1		(TRS_PU_CFG_0 + 0x00)
+#define CFG_TRS_CONFIG			(TRS_PU_CFG_0 + 0x04)
+#define CFG_COMMS_CONFIG_2		(TRS_PU_CFG_0 + 0x08)
+#define CFG_USB_SOFT_JTAG		(TRS_PU_CFG_0 + 0x0c)
+#define CFG_NOTUSED_1			(TRS_PU_CFG_0 + 0x10)
+#define CFG_NOTUSED_2			(TRS_PU_CFG_0 + 0x14)
+#define CFG_COMMS_TRS_STATUS		(TRS_PU_CFG_0 + 0x18)
+#define CFG_EXTRA_ID1_LSB		(TRS_PU_CFG_0 + 0x1c)
+
+#define CFG_SPARE_1			(TRS_PU_CFG_1 + 0x00)
+#define CFG_SPARE_2			(TRS_PU_CFG_1 + 0x04)
+#define CFG_SPARE_3			(TRS_PU_CFG_1 + 0x08)
+#define CFG_NOTUSED_3			(TRS_PU_CFG_1 + 0x0c)
+#define CFG_NOTUSED_4			(TRS_PU_CFG_1 + 0x10)
+#define CFG_NOTUSED_5			(TRS_PU_CFG_1 + 0x14)
+#define CFG_DEVICE_ID			(TRS_PU_CFG_1 + 0x18)
+#define CFG_EXTRA_ID1_MSB		(TRS_PU_CFG_1 + 0x1c)
+
+#define CFG_TOP_SPARE_REG1		(VDEC_PU_CFG_0 + 0x00)
+#define CFG_TOP_SPARE_REG2		(VDEC_PU_CFG_0 + 0x04)
+#define CFG_TOP_SPARE_REG3		(VDEC_PU_CFG_0 + 0x08)
+#define CFG_ST231_DRA2_DEBUG		(VDEC_PU_CFG_0 + 0x0c)
+#define CFG_ST231_AUD1_DEBUG		(VDEC_PU_CFG_0 + 0x10)
+#define CFG_ST231_AUD2_DEBUG		(VDEC_PU_CFG_0 + 0x14)
+
+#define CFG_ST231_DRA2_PERIPH_REG1	(VDEC_PU_CFG_1 + 0x00)
+#define CFG_ST231_DRA2_BOOT_REG2	(VDEC_PU_CFG_1 + 0x04)
+#define CFG_ST231_AUD1_PERIPH_REG3	(VDEC_PU_CFG_1 + 0x08)
+#define CFG_ST231_AUD1_BOOT_REG4	(VDEC_PU_CFG_1 + 0x0c)
+#define CFG_ST231_AUD2_PERIPH_REG5	(VDEC_PU_CFG_1 + 0x10)
+#define CFG_ST231_AUD2_BOOT_REG6	(VDEC_PU_CFG_1 + 0x14)
+
+#define CFG_REG1_PIO_ALT_DATA_SEL	(VOUT_PU_CFG_1 + 0x00)
+#define CFG_REG2_PIO_ALT_DATA_SEL	(VOUT_PU_CFG_1 + 0x04)
+#define CFG_REG3_DEBUG_DATA_SEL		(VOUT_PU_CFG_1 + 0x08)
+#define CFG_REG4_DAC_CTRL		(VOUT_PU_CFG_1 + 0x0c)
+#define CFG_REG5_VOUT_DEBUG_CTL		(VOUT_PU_CFG_1 + 0x10)
+#define CFG_REG6_TVOUT_DEBUG_CTL	(VOUT_PU_CFG_1 + 0x14)
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000	/* QQQ - need this, check it is correct ? */
+#endif
+
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfd100000
+#endif
+
+
+#include "st40reg.h"
+
+
+/*----------------------------------------------------------------------------*/
+
+/* Device ID values, masks & predicates */
+#define FLI7540_DEVID_7540_VAL		0x23c	/* for cut 0.x */
+#define FLI7540_DEVID_ID_SHIFT		12
+#define FLI7540_DEVID_ID_MASK		0x3ff
+#define FLI7540_DEVID_CUT_SHIFT		28
+#define FLI7540_DEVID_CUT_MASK		0xf
+
+#define FLI7540_DEVICEID_7540(ID) ((((ID) >> FLI7540_DEVID_ID_SHIFT) & FLI7540_DEVID_ID_MASK) == FLI7540_DEVID_7540_VAL)
+#define FLI7540_DEVICEID_CUT(ID)  ((((ID) >> FLI7540_DEVID_CUT_SHIFT) & FLI7540_DEVID_CUT_MASK) + 0)
+
+#endif /* __FLI7540REG_H */
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index aae67a4..bc30c5a 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -52,6 +52,7 @@
 
 #if defined(CONFIG_SH_MB411)		|| \
        defined(CONFIG_SH_MB442)		|| \
+       defined(CONFIG_SH_HMP7100)	|| \
        defined(CONFIG_SH_MB448)		|| \
        defined(CONFIG_SH_HMS1)		|| \
        defined(CONFIG_SH_MB519)		|| \
@@ -67,8 +68,12 @@
        defined(CONFIG_SH_5197CAB)	|| \
        defined(CONFIG_SH_CB101)		|| \
        defined(CONFIG_SH_CB102)		|| \
+       defined(CONFIG_SH_MB837)		|| \
+       defined(CONFIG_SH_HDK7108)	|| \
        defined(CONFIG_SH_FLI7510)	|| \
-       defined(CONFIG_SH_MB796)
+       defined(CONFIG_SH_FLI7540)	|| \
+       defined(CONFIG_SH_MB796)		|| \
+       defined(CONFIG_SH_HDK5289)
 #  include "asm/io_stb1eval.h"
 #else
 #  error "What system is this?"
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
index d210500..6b27488 100644
--- a/include/asm-sh/soc.h
+++ b/include/asm-sh/soc.h
@@ -28,6 +28,34 @@
 
 
 /*
+ * PIO data types
+ */
+struct stx7108_pioalt_pad_cfg
+{
+	int oe:2;
+	int pu:2;
+	int od:2;
+};
+extern const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_in;
+extern const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_out;
+extern const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_od;
+extern const struct stx7108_pioalt_pad_cfg stx7108_pioalt_pad_bidir;
+
+
+/*
+ * PIO initialization functions
+ */
+extern void stx7108_pioalt_pad(
+	int port,
+	const int pin,
+	const struct stx7108_pioalt_pad_cfg * const cfg);
+extern void stx7108_pioalt_select(
+	const int port,
+	const int pin,
+	const int alt);
+
+
+/*
  * STMAC data types
  */
 enum fli7510_ethernet_mode
@@ -37,13 +65,31 @@ enum fli7510_ethernet_mode
 	fli7510_ethernet_rmii,
 	fli7510_ethernet_reverse_mii
 };
+enum fli7540_ethernet_mode
+{
+	fli7540_ethernet_mii,
+	fli7540_ethernet_gmii,
+	fli7540_ethernet_rmii,
+	fli7540_ethernet_reverse_mii
+};
 enum stx5206_ethernet_mode
 {
 	stx5206_ethernet_mii,
 	stx5206_ethernet_rmii,
 	stx5206_ethernet_reverse_mii
 };
-
+struct stx7108_ethernet_config
+{
+	enum {
+		stx7108_ethernet_mode_mii,
+		stx7108_ethernet_mode_gmii,
+		stx7108_ethernet_mode_gmii_gtx,
+		stx7108_ethernet_mode_rmii,
+		stx7108_ethernet_mode_reverse_mii
+	} mode;
+	int ext_clk;
+	int phy_bus;
+};
 
 
 /*
@@ -60,6 +106,9 @@ extern void stx5206_configure_ethernet(
 	const enum stx5206_ethernet_mode mode,
 	const int ext_clk,
 	const int phy_bus);
+extern void stx7108_configure_ethernet(
+	const int port,
+	const struct stx7108_ethernet_config * const config);
 extern void stx7141_configure_ethernet(
 	const int port,
 	const int reverse_mii,
@@ -71,6 +120,10 @@ extern void fli7510_configure_ethernet(
 	const enum fli7510_ethernet_mode mode,
 	const int ext_clk,
 	const int phy_bus);
+extern void fli7540_configure_ethernet(
+	const enum fli7540_ethernet_mode mode,
+	const int ext_clk,
+	const int phy_bus);
 
 
 /*
@@ -93,6 +146,11 @@ enum fli7510_usb_ovrcur_mode {
 	fli7510_usb_ovrcur_active_high,
 	fli7510_usb_ovrcur_active_low,
 };
+enum fli7540_usb_ovrcur_mode {
+	fli7540_usb_ovrcur_disabled,
+	fli7540_usb_ovrcur_active_high,
+	fli7540_usb_ovrcur_active_low,
+};
 
 
 /*
@@ -105,7 +163,8 @@ extern int  stx7105_usb_init(int port, int over_current, int power_ctrl);
 extern void stx7111_usb_init(void);
 extern void stx7141_usb_init(void);
 extern void stx7200_usb_init(void);
-extern void fli7105_usb_init(const enum fli7510_usb_ovrcur_mode ovrcur_mode);
+extern void fli7510_usb_init(const enum fli7510_usb_ovrcur_mode ovrcur_mode);
+extern void fli7540_usb_init(const int port, const enum fli7540_usb_ovrcur_mode ovrcur_mode);
 
 
 /*
@@ -123,6 +182,16 @@ extern void		fli7510_spi_scl(const int val);
 extern void		fli7510_spi_sda(const int val);
 extern unsigned char	fli7510_spi_read(void);
 
+extern void		fli7540_spi_scl(const int val);
+extern void		fli7540_spi_sda(const int val);
+extern unsigned char	fli7540_spi_read(void);
+
+
+/*
+ * I2C initialization functions.
+ */
+extern void		stx7108_configure_i2c(void);
+
 
 /*
  * Software "bit-banging" functions for I2C accesses.
@@ -131,10 +200,18 @@ extern void		stx7105_i2c_scl(const int val);
 extern void		stx7105_i2c_sda(const int val);
 extern int		stx7105_i2c_read(void);
 
+extern void		stx7108_i2c_scl(const int val);
+extern void		stx7108_i2c_sda(const int val);
+extern int		stx7108_i2c_read(void);
+
 extern void		fli7510_i2c_scl(const int val);
 extern void		fli7510_i2c_sda(const int val);
 extern int		fli7510_i2c_read(void);
 
+extern void		fli7540_i2c_scl(const int val);
+extern void		fli7540_i2c_sda(const int val);
+extern int		fli7540_i2c_read(void);
+
 
 #endif	/* _SOC_H_ */
 
diff --git a/include/asm-sh/socregs.h b/include/asm-sh/socregs.h
index ba4edf4..79d7e00 100644
--- a/include/asm-sh/socregs.h
+++ b/include/asm-sh/socregs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) STMicroelectronics Ltd. 2004-2009
+ * Copyright (C) STMicroelectronics Ltd. 2004-2010
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -35,6 +35,8 @@
 #	include <asm/stx5206reg.h>
 #elif defined(CONFIG_SH_STX7105)
 #	include <asm/stx7105reg.h>
+#elif defined(CONFIG_SH_STX7108)
+#	include <asm/stx7108reg.h>
 #elif defined(CONFIG_SH_STX7111)
 #	include <asm/stx7111reg.h>
 #elif defined(CONFIG_SH_STX7141)
@@ -43,6 +45,8 @@
 #	include <asm/stx7200reg.h>
 #elif defined(CONFIG_SH_FLI7510)
 #	include <asm/fli7510reg.h>
+#elif defined(CONFIG_SH_FLI7540)
+#	include <asm/fli7540reg.h>
 #else
 #	error Missing Device Definitions!
 #endif
diff --git a/include/asm-sh/spi-commands.h b/include/asm-sh/spi-commands.h
index 4b39b3e..758e9e2 100644
--- a/include/asm-sh/spi-commands.h
+++ b/include/asm-sh/spi-commands.h
@@ -98,6 +98,29 @@
 #define SR_BP_MASK		0x3c		/* Block Protect Bits (BP[3:0]) */
 
 
+#elif defined(CONFIG_SPI_FLASH_WINBOND)	/******************************/
+
+
+/* For Winbond W25Q32V Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#if !defined(CFG_STM_SPI_FREQUENCY)
+#  define CFG_STM_SPI_FREQUENCY	(5*1000*1000)	/* 5 MHz */
+#endif	/* CFG_STM_SPI_FREQUENCY */
+#define CFG_STM_SPI_DEVICE_MASK	0x00u		/* Mask Bits */
+#define CFG_STM_SPI_DEVICE_VAL	0x00u		/* Binary xxxxxxxx */
+
+#define OP_READ_STATUS		0x05u		/* Read Status Register */
+#define OP_WRITE_STATUS		0x01u		/* Write Status Register */
+#define OP_READ_DEVID		0x9fu		/* Read ID */
+#define OP_READ_ARRAY		0x03u		/* Read Data Bytes */
+#define OP_WREN			0x06u		/* Write Enable */
+#define OP_SE			0x20u		/* Sector Erase */
+#define OP_PP			0x02u		/* Page Program */
+
+#define SR_WIP			(1u<<0)		/* Status Register Write In Progress bit */
+#define SR_BP_MASK		0x1c		/* Block Protect Bits (BP[2:0]) */
+
+
 #else					/******************************/
 
 #error Please specify which SPI Serial Flash is being used
diff --git a/include/asm-sh/stx5206reg.h b/include/asm-sh/stx5206reg.h
index 3083958..ba5b69e 100644
--- a/include/asm-sh/stx5206reg.h
+++ b/include/asm-sh/stx5206reg.h
@@ -126,6 +126,8 @@
  * STx5206 control registers
  */
 
+/* Clock Generator control registers (STx5206 variant) */
+#define STX5206_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX5206_CLOCKGENA_REGS_BASE + 0xa34)
 
 /* System configuration registers (STx5206 variant) */
 #define STX5206_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX5206_SYSCONF_REGS_BASE + 0x0000)
diff --git a/include/asm-sh/stx7108reg.h b/include/asm-sh/stx7108reg.h
new file mode 100644
index 0000000..7ee5b37
--- /dev/null
+++ b/include/asm-sh/stx7108reg.h
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008,2010
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7105.h
+ */
+
+
+#ifndef __STX7108REG_H
+#define __STX7108REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE		0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE		0xffc00000		/* QQQ - TO CHECK */
+#endif
+
+/* STx7108 control registers */
+#ifndef STX7108_COMMS_BASE
+#define STX7108_COMMS_BASE		0xfd700000
+#endif
+
+#ifndef STX7108_SYSCONF_BANK0_BASE
+#define STX7108_SYSCONF_BANK0_BASE	0xfde30000
+#endif
+#ifndef STX7108_SYSCONF_BANK1_BASE
+#define STX7108_SYSCONF_BANK1_BASE	0xfde20000
+#endif
+#ifndef STX7108_SYSCONF_BANK2_BASE
+#define STX7108_SYSCONF_BANK2_BASE	0xfda50000
+#endif
+#ifndef STX7108_SYSCONF_BANK3_BASE
+#define STX7108_SYSCONF_BANK3_BASE	0xfd500000
+#endif
+#ifndef STX7108_SYSCONF_BANK4_BASE
+#define STX7108_SYSCONF_BANK4_BASE	0xfe700000
+#endif
+
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE		0xfe900000
+#endif
+
+#ifndef ST40_EMI_SIZE			/* total addressable size of EMI */
+#define ST40_EMI_SIZE			(256 << 20)	/* 256 MiB */
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7108_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7108_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7108_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7108_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7108_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7108_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7108_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE (STX7108_COMMS_BASE + 0x00027000)
+#endif
+#ifndef ST40_PIO8_REGS_BASE
+#define ST40_PIO8_REGS_BASE (STX7108_COMMS_BASE + 0x00028000)
+#endif
+#ifndef ST40_PIO9_REGS_BASE
+#define ST40_PIO9_REGS_BASE (STX7108_COMMS_BASE + 0x00029000)
+#endif
+
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7108_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7108_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7108_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7108_COMMS_BASE + 0x00033000)
+#endif
+
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7108_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7108_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7108_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7108_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_SSC4_REGS_BASE
+#define ST40_SSC4_REGS_BASE (STX7108_COMMS_BASE + 0x00044000)
+#endif
+#ifndef ST40_SSC5_REGS_BASE
+#define ST40_SSC5_REGS_BASE (STX7108_COMMS_BASE + 0x00045000)
+#endif
+#ifndef ST40_SSC6_REGS_BASE
+#define ST40_SSC6_REGS_BASE (STX7108_COMMS_BASE + 0x00046000)
+#endif
+
+#ifndef ST40_PIO10_REGS_BASE
+#define ST40_PIO10_REGS_BASE	0xfda60000
+#endif
+#ifndef ST40_PIO11_REGS_BASE
+#define ST40_PIO11_REGS_BASE	0xfda61000
+#endif
+#ifndef ST40_PIO12_REGS_BASE
+#define ST40_PIO12_REGS_BASE	0xfda62000
+#endif
+#ifndef ST40_PIO13_REGS_BASE
+#define ST40_PIO13_REGS_BASE	0xfda63000
+#endif
+#ifndef ST40_PIO14_REGS_BASE
+#define ST40_PIO14_REGS_BASE	0xfda64000
+#endif
+#ifndef ST40_PIO15_REGS_BASE
+#define ST40_PIO15_REGS_BASE	0xfe740000
+#endif
+#ifndef ST40_PIO16_REGS_BASE
+#define ST40_PIO16_REGS_BASE	0xfe741000
+#endif
+#ifndef ST40_PIO17_REGS_BASE
+#define ST40_PIO17_REGS_BASE	0xfe742000
+#endif
+#ifndef ST40_PIO18_REGS_BASE
+#define ST40_PIO18_REGS_BASE	0xfe743000
+#endif
+#ifndef ST40_PIO19_REGS_BASE
+#define ST40_PIO19_REGS_BASE	0xfe744000
+#endif
+#ifndef ST40_PIO20_REGS_BASE
+#define ST40_PIO20_REGS_BASE	0xfe745000
+#endif
+#ifndef ST40_PIO21_REGS_BASE
+#define ST40_PIO21_REGS_BASE	0xfe746000
+#endif
+#ifndef ST40_PIO22_REGS_BASE
+#define ST40_PIO22_REGS_BASE	0xfe747000
+#endif
+#ifndef ST40_PIO23_REGS_BASE
+#define ST40_PIO23_REGS_BASE	0xfe748000
+#endif
+#ifndef ST40_PIO24_REGS_BASE
+#define ST40_PIO24_REGS_BASE	0xfe749000
+#endif
+#ifndef ST40_PIO25_REGS_BASE
+#define ST40_PIO25_REGS_BASE	0xfe720000
+#endif
+#ifndef ST40_PIO26_REGS_BASE
+#define ST40_PIO26_REGS_BASE	0xfe721000
+#endif
+
+#define ST40_PIO_BASE(x)					\
+	(							\
+		((x) < 10)					\
+		? (ST40_PIO0_REGS_BASE +(0x1000*(x)))		\
+		:						\
+		((x) < 15)					\
+		? (ST40_PIO10_REGS_BASE+(0x1000*((x)-10)))	\
+		:						\
+		((x) < 25)					\
+		? (ST40_PIO15_REGS_BASE+(0x1000*((x)-15)))	\
+		:						\
+		(ST40_PIO25_REGS_BASE+(0x1000*((x)-25)))	\
+	)
+
+/*----------------------------------------------------------------------------*/
+
+/* STx7108 System Configuration "accessors" */
+#define STX7108_BANK0_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK0_BASE + 0x04 + (x)*0x4)
+#define STX7108_BANK1_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK1_BASE + 0x3c + (x)*0x4)
+#define STX7108_BANK2_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK2_BASE + 0x00 + (x)*0x4)
+#define STX7108_BANK3_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK3_BASE + 0x18 + (x)*0x4)
+#define STX7108_BANK4_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK4_BASE + 0x00 + (x)*0x4)
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Device ID register & bitfields
+ */
+
+#define STX7108_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STX7108_SYSCONF_BANK1_BASE + 0x0000)
+
+/* Device ID values, masks & predicates */
+#define STX7108_DEVID_7108_VAL		0x043
+#define STX7108_DEVID_ID_SHIFT		12
+#define STX7108_DEVID_ID_MASK		0x3ff
+#define STX7108_DEVID_CUT_SHIFT		28
+#define STX7108_DEVID_CUT_MASK		0xf
+
+#define STX7108_DEVICEID_7108(ID) ((((ID) >> STX7108_DEVID_ID_SHIFT) & STX7108_DEVID_ID_MASK) == STX7108_DEVID_7108_VAL)
+#define STX7108_DEVICEID_CUT(ID)  ((((ID) >> STX7108_DEVID_CUT_SHIFT) & STX7108_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7108REG_H */
diff --git a/include/asm-sh/sysconf.h b/include/asm-sh/sysconf.h
new file mode 100644
index 0000000..22e746e
--- /dev/null
+++ b/include/asm-sh/sysconf.h
@@ -0,0 +1,75 @@
+/*
+ * (C) Copyright 2009-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __sysconf_h__
+#define __sysconf_h__
+
+	/*
+	 * if ('flag')
+	 *	set bit 'bit' in variable 'reg'
+	 * else
+	 *	clear bit 'bit' in variable 'reg'
+	 */
+#define SET_SYSCONF_BIT(reg,flag,bit)			\
+	do {						\
+		if (flag)				\
+		{	/* set bit 'bit' */		\
+			reg |= (1ul<<(bit));		\
+		}					\
+		else					\
+		{	/* clear bit 'bit' */		\
+			reg &= ~(1ul<<(bit));		\
+		}					\
+	} while (0)
+
+
+	/*
+	 * if ('flag')
+	 *	set bits 'lsb:msb' to 'yes' in variable 'reg'
+	 * else
+	 *	set bits 'lsb:msb' to 'no' in variable 'reg'
+	 *
+	 * Note: 'msb' must be >= 'lsb'.
+	 */
+#define SET_SYSCONF_BITS(reg,flag,lsb,msb,yes,no)	\
+	do {						\
+		const unsigned long _mask = 		\
+			(1ul<<((msb)-(lsb)+1))-1ul;	\
+		/* clear all bits in 'lsb':'msb' */	\
+		reg &= ~(_mask<<(lsb));		\
+		if (flag)				\
+		{	/* set 'yes' in lsb:msb */	\
+			reg |= ((yes)<<(lsb));	\
+		}					\
+		else					\
+		{	/* set 'no' in lsb:msb */	\
+			reg |= ((no)<<(lsb));		\
+		}					\
+	} while (0)
+
+
+#endif	/* __sysconf_h__ */
+
+
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
index 4988587..397c898 100644
--- a/include/asm-sh/u-boot.h
+++ b/include/asm-sh/u-boot.h
@@ -1,7 +1,7 @@
 /*
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
- * (C) Copyright 2004-2009 STMicroelectronics.
+ * (C) Copyright 2004-2010 STMicroelectronics.
  * Andy Sturges <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -56,10 +56,12 @@ typedef struct bd_info
 #if	defined(CONFIG_SH_STX5197) ||	\
 	defined(CONFIG_SH_STX5206) ||	\
 	defined(CONFIG_SH_STX7105) ||	\
+	defined(CONFIG_SH_STX7108) ||	\
 	defined(CONFIG_SH_STX7111) ||	\
 	defined(CONFIG_SH_STX7141) ||	\
 	defined(CONFIG_SH_STX7200) ||	\
-	defined(CONFIG_SH_FLI7510)
+	defined(CONFIG_SH_FLI7510) ||	\
+	defined(CONFIG_SH_FLI7540)
 	unsigned long bi_devid;
 	unsigned long bi_emifrq;
 #endif
diff --git a/include/common.h b/include/common.h
index 25e3c9e..a355cb0 100644
--- a/include/common.h
+++ b/include/common.h
@@ -663,4 +663,22 @@ void inline show_boot_progress (int val);
 #error Read section CONFIG_SKIP_LOWLEVEL_INIT in README.
 #endif
 
+/*
+ * For instrumenting read/write times (e.g. FLASH):
+ *
+ *	void PRINT_MEASURED_TRANSFER_RATE(bytes, ms);
+ *		bytes = number of bytes transfered
+ *		ms    = elapsed time in ms
+ */
+#if defined(CONFIG_MEASURE_TIME) && !defined(PRINT_MEASURED_TRANSFER_RATE)
+#define PRINT_MEASURED_TRANSFER_RATE(bytes, ms)					\
+do {										\
+    if ((ms) != 0)								\
+	printf("info: %lu bytes (%lu MiB) in %lu.%03lu sec => %lu KiB/sec\n",	\
+		(bytes), (bytes)>>20,						\
+		(ms)/1000, (ms)%1000,						\
+		(((bytes)>>10)*1000)/(ms));					\
+} while (0)
+#endif /* CONFIG_MEASURE_TIME */
+
 #endif	/* __COMMON_H_ */
diff --git a/include/configs/fldb.h b/include/configs/fldb.h
index 915b8fb..de541dd 100644
--- a/include/configs/fldb.h
+++ b/include/configs/fldb.h
@@ -214,7 +214,7 @@
  */
 
 /* Choose if we want USB Mass-Storage Support */
-//#define CONFIG_SH_STB7100_USB
+#define CONFIG_SH_STB7100_USB
 
 #ifdef CONFIG_SH_STB7100_USB
 #	define CONFIG_CMD_USB
diff --git a/include/configs/fudb.h b/include/configs/fudb.h
new file mode 100644
index 0000000..962adff
--- /dev/null
+++ b/include/configs/fudb.h
@@ -0,0 +1,447 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ *	Switch settings to select between the SoC's main boot-modes:
+ *		a) boot from 8-bit NAND flash, large-page, long address
+ *		b) boot from SPI serial flash, ST protocol
+ *
+ *	The MODE switches (SWB1) need to be set appropriately,
+ *	depending where we are booting from:
+ *
+ *	SWB1-x	MODE		NAND	SPI
+ *	------	----		----	---
+ *	SW-5	MODE_PIN4	off	ON
+ *	SW-4	MODE_PIN3	ON	off
+ *	SW-3	MODE_PIN2	off	ON
+ *	SW-2	MODE_PIN1	ON	off
+ *
+ *		MODE[4:1]	0101	1010
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. for SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (32MiB) */
+#if defined(CFG_BOOT_FROM_SPI)			/* we are booting from SPI serial flash */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* EMI Bank #0: SPI Flash,  Physical 0x00000000 (32MiB) */
+#endif /* CFG_BOOT_FROM_SPI */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD fudb
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 0
+	/* 9-pin D-type connector - CNB4 (next to JTAG) */
+#	define CFG_STM_ASC_BASE		ST40_ASC0_REGS_BASE	/* UART #3 */
+#else
+	/* 9-pin D-type connector - CNB1 (next to RJ-45) */
+#	define CFG_STM_ASC_BASE		ST40_ASC1_REGS_BASE	/* UART #2 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There is 1 option for ethernet, using the on-chip ST-GMAC,
+ * with the on-board Micrel KSZ8041NL PHY.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd920000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_KSZ8041			/* PHY = Micrel KSZ8041NL */
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_A_BASE			0xfda00000	/* CNG2, USB #1 */
+#	define CFG_USB_C_BASE			0xfdc00000	/* CNG8, USB #2 */
+#	define CFG_USB_BASE			CFG_USB_A_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"FUDB> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ *
+ * Note: On the FUDB, there is no NOR flash.
+ */
+
+#if !defined(CONFIG_CMD_FLASH)			/* no NOR flash present ? */
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ *
+ * Only the FLEX controller can control the ALE and CLE signal.
+ * As a result, it is *not* possible to use "bit-banging" to talk
+ * to the NAND, hence the H/W FLEX controller must be used.
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 * Note: see above - do *not* undef this!
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name		Manuf	Device
+ *	-----		-----	------
+ *	UD3/UD4		Numonyx	M25PX64
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25PXxx */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+	/* choose either the H/W SSC, or S/W "bit-banging" */
+#if 0
+#	define CONFIG_SOFT_SPI			/* Use S/W "bit-banging" PIO (not the SSC) */
+#else
+#	define CONFIG_STM_SSC_SPI		/* Use H/W SSC (not S/W "bit-banging" PIO) */
+#endif
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { fli7540_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { fli7540_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		fli7540_spi_read()
+#elif defined(CONFIG_STM_SSC_SPI)		/* Use the H/W SSC for SPI */
+#	define CFG_STM_SPI_SSC_BASE	0xfdb44000		/* SSC #4 */
+#	define CFG_STM_SPI_FREQUENCY	(7*1000*1000)		/* 7.14 MHz */
+#endif	/* CONFIG_SOFT_SPI */
+
+#endif	/* CONFIG_SPI_FLASH */
+
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 0 && defined(CONFIG_CMD_NAND)
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+/*----------------------------------------------------------------------
+ * I2C configuration
+ */
+
+#define CONFIG_CMD_I2C				/* do we want I2C support ? */
+
+#if defined(CONFIG_CMD_I2C)
+#	define CONFIG_I2C_BUS_2			/* Use I2C Bus "2" */
+#	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
+#	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
+#	define I2C_ACTIVE			/* open-drain, nothing to do */
+#	define I2C_TRISTATE			/* open-drain, nothing to do */
+#	define I2C_SCL(val)		do { fli7540_i2c_scl((val)); } while (0)
+#	define I2C_SDA(val)		do { fli7540_i2c_sda((val)); } while (0)
+#	define I2C_READ			fli7540_i2c_read()
+
+	/*
+	 * The "BOGOS" for NDELAY() may be calibrated using the
+	 * following code fragment, and measuring (using an oscilloscope)
+	 * the frequency of the I2C SCL pin, and adjusting
+	 * NDELAY_BOGOS, until the SCL is approximately 100 kHz.
+	 * (100kHz has a period of 5us + 5us).
+	 *
+	 *	printf("just toggling I2C SCL (100kHz frequency) ...\n");
+	 *	while (1)
+	 *	{
+	 *		I2C_SCL(1); NDELAY(5000);
+	 *		I2C_SCL(0); NDELAY(5000);
+	 *	}
+	 */
+#	define NDELAY_BOGOS		22	/* Empirical measurement for 1ns */
+#	define NDELAY(ns)						\
+		do {							\
+			const unsigned n_bogo = NDELAY_BOGOS;		\
+			const unsigned n_ticks = 			\
+				((ns)<n_bogo) ? 1u : (ns)/n_bogo;	\
+			volatile unsigned n_count;			\
+			for(n_count=0; n_count<n_ticks; n_count++)	\
+				;	/* do nothing */		\
+		} while(0)
+
+	/*
+	 * Note there are 4 * I2C_DELAY per I2C clock cycle
+	 * So, 400 kHz requires an I2C delay of 625 ns.
+	 * However, this calculation only works if the S/W
+	 * overhead in I2C bit-banging is negligible - which it is not!
+	 * So, in practice, either I2C_DELAY or CFG_I2C_SPEED will be lower.
+	 * The higher the clock frequency, the greater the difference.
+	 * Empirical measurement/adjustment is recommended.
+	 */
+#	define CFG_I2C_SPEED	400000				/* I2C speed (Hz) */
+#	define I2C_DELAY	do { NDELAY(625); } while (0)	/* 625 ns */
+#endif	/* CONFIG_CMD_I2C */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hdk5289.h b/include/configs/hdk5289.h
new file mode 100644
index 0000000..41e5e2c
--- /dev/null
+++ b/include/configs/hdk5289.h
@@ -0,0 +1,459 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ *	Switch settings to select between the SoC's main 3 boot-modes:
+ *		a) boot from 16-bit NOR flash
+ *		b) boot from 8-bit NAND flash, small-page, long address
+ *		c) boot from SPI serial flash
+ *
+ *	Board	Switch	NOR	NAND	SPI	Mode
+ *	-----	------	---	----	---	----
+ *
+ *	Note: "X" denotes don't care (i.e. either ON or OFF)
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI, so *DO* swap CSA and CSB in EPLD */
+//QQQ #define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+//QQQ #define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+//QQQ #define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+//QQQ #define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSB */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
+	/*
+	 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
+	 * If so, then who takes responsibility for this???
+	 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
+	 * Should U-Boot read SW8(1) on the MB705, and do something?
+	 */
+//QQQ #define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+//QQQ #define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+//QQQ #define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSB in EPLD */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+	/* in 32-bit mode, default TargetPack's PMB setup is only 128 MiB of RAM! */
+#if defined(CONFIG_SH_SE_MODE) && (TEXT_BASE < 0x8FF00000)
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+#else
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+#endif
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD hdk5289
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* UART #2, on JI3 to daughter board */
+#define CFG_STM_ASC_BASE	ST40_ASC2_REGS_BASE	/* UART2 = JI3 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, all use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041 (UP1)
+ *    External PHY connected via the MII off-board connector (JN8).
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#if 1
+#	define CONFIG_STMAC_KSZ8041			/* PHY = Micrel KSZ8041 */
+#else
+	/* QQQ define for JN8 ... */
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	2	/* Note: TWO root ports */
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HDK5289> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND, NOR & SPI devices),
+ * all three, or none, ao any other combination.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+#if 0 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+	/*
+	 * If we want to store "u-boot.bin" in NAND flash starting at
+	 * physical block #0, but there are Bad Blocks in the first
+	 * few blocks that we need to "skip" over, then we need
+	 * to define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING to allow
+	 * skipping of these bad blocks for u-boot to relocate itself.
+	 * In addition, we also need to tell U-boot the block size,
+	 * and provide it a local abridged copy of the master Bad Block
+	 * Table (BBT), which must also be stored in physical block #0
+	 * - see "cpu/sh/start.S" for details.
+	 * Also, CFG_NAND_SKIP_BLOCK_COUNT defines the number of blocks
+	 * stored in the abridged copy of the master BBT.
+	 */
+#	define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING	/* define for skipping */
+#	define CFG_NAND_SKIP_BLOCK_SIZE		(16<<10)/* Block Size = 16 KiB */
+#	define CFG_NAND_SKIP_BLOCK_COUNT	16	/* entries in the array */
+#endif /* CFG_BOOT_FROM_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	UG1	Winbond	W25Q64V
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_WINBOND		/* Winbond W25Q64V (UG1) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+//#	define CONFIG_CMD_SPI			/* SPI serial bus command support - NOT with FSM! */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+	/* Can only use H/W FSM SPI Controller (not H/W SSC, nor S/W "bit-banging") */
+#	define CONFIG_STM_FSM_SPI		/* Use the H/W FSM for SPI */
+#	define CFG_STM_SPI_FSM_BASE	0xfe702000	/* FSM SPI Controller Base */
+#endif	/* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hdk7108.h b/include/configs/hdk7108.h
new file mode 100644
index 0000000..f9a0a82
--- /dev/null
+++ b/include/configs/hdk7108.h
@@ -0,0 +1,501 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ *	Switch settings to select between the SoC's main 3 boot-modes:
+ *		a) boot from 16-bit NOR flash
+ *		b) boot from 8-bit NAND flash, small-page, long address
+ *		c) boot from SPI serial flash
+ *
+ *	Jumper	NOR	NAND	SPI
+ *	------	---	----	---
+ *	JF2	1-2	2-3	qqq		FLASH_CS#
+ *	JF3	1-2	2-3	qqq		NAND_CS#
+ *	JH4-2	 ON	 ON	off		MODE[5]
+ *	JH4-1	off	off	 ON		MODE[4]
+ *	JH2-2	 ON	 ON	off		MODE[3]
+ *	JH2-1	off	 ON	 ON		MODE[2]
+ *
+ *	For boot-from-NOR, both JF2 and JF3 switches closer to CPU.
+ *	For boot-from-NAND, both JF2 and JF3 switches closer to SCART.
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (128iB) */
+#define CFG_EMI_NOR_BASE	0xA8000000	/* CSB: NOR Flash,  Physical 0x08000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else				/* we are booting from NOR */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (128MiB) */
+#define CFG_EMI_NAND_BASE	0xA8000000	/* CSB: NAND Flash, Physical 0x08000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD hdk7108
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 245 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* JL3, on-board DB9 */
+#else
+#	define CFG_STM_ASC_BASE		ST40_ASC1_REGS_BASE	/* JK1/JB4 off-board */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 on-chip ST-GMACs.
+ *
+ *	GMAC #0 is connected to MII(2x22) (JP2), for a off-board PHY
+ *
+ *	GMAC #1 is connected to a on-board IC+ IP1001 PHY (UP1)
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC0_BASE	0xfda88000ul	/* MII #0 (off-board, JP2) */
+#	define CFG_STM_STMAC1_BASE	0xfe730000ul	/* MII #1 (on-board, IC+ IP1001) */
+#	if 1
+#		define CFG_STM_STMAC_BASE	CFG_STM_STMAC1_BASE
+#		define CONFIG_STMAC_IP1001	/* IC+ IP1001 (UP1) */
+#	else
+#		define CFG_STM_STMAC_BASE	CFG_STM_STMAC0_BASE
+#		define CONFIG_STMAC_xxx		/* NOTE: users need to specify this! */
+#	endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//QQQ #define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* upper */
+#	define CFG_USB1_BASE			0xfea00000	/* lower */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HDK7108> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the MB837 + MB705 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* PC28Fxxx: 128MiB 1024 blocks, 128KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND01GW3B: 1GiB  8-bit, large page (128KiB) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+#if 0 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+	/*
+	 * If we want to store "u-boot.bin" in NAND flash starting at
+	 * physical block #0, but there are Bad Blocks in the first
+	 * few blocks that we need to "skip" over, then we need
+	 * to define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING to allow
+	 * skipping of these bad blocks for u-boot to relocate itself.
+	 * In addition, we also need to tell U-boot the block size,
+	 * and provide it a local abridged copy of the master Bad Block
+	 * Table (BBT), which must also be stored in physical block #0
+	 * - see "cpu/sh/start.S" for details.
+	 * Also, CFG_NAND_SKIP_BLOCK_COUNT defines the number of blocks
+	 * stored in the abridged copy of the master BBT.
+	 */
+#	define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING	/* define for skipping */
+#	define CFG_NAND_SKIP_BLOCK_SIZE		(128<<10)/* Block Size = 128 KiB */
+#	define CFG_NAND_SKIP_BLOCK_COUNT	8	/* entries in the array */
+#endif /* CFG_BOOT_FROM_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+/*----------------------------------------------------------------------
+ * I2C configuration
+ */
+
+#define CONFIG_CMD_I2C				/* do we want I2C support ? */
+
+#if defined(CONFIG_CMD_I2C)
+#	define CONFIG_I2C_BUS		5	/* Use I2C Bus associated with SSC #5 */
+#	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
+#	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
+#	define I2C_ACTIVE			/* open-drain, nothing to do */
+#	define I2C_TRISTATE			/* open-drain, nothing to do */
+#	define I2C_SCL(val)		do { stx7108_i2c_scl((val)); } while (0)
+#	define I2C_SDA(val)		do { stx7108_i2c_sda((val)); } while (0)
+#	define I2C_READ			stx7108_i2c_read()
+
+	/*
+	 * The "BOGOS" for NDELAY() may be calibrated using the
+	 * following code fragment, and measuring (using an oscilloscope)
+	 * the frequency of the I2C SCL pin, and adjusting
+	 * NDELAY_BOGOS, until the SCL is approximately 100 kHz.
+	 * (100kHz has a period of 5us + 5us).
+	 *
+	 *	printf("just toggling I2C SCL (100kHz frequency) ...\n");
+	 *	while (1)
+	 *	{
+	 *		I2C_SCL(1); NDELAY(5000);
+	 *		I2C_SCL(0); NDELAY(5000);
+	 *	}
+	 */
+#	define NDELAY_BOGOS		20	/* Empirical measurement for 1ns on MB837A */
+#	define NDELAY(ns)						\
+		do {							\
+			const unsigned n_bogo = NDELAY_BOGOS;		\
+			const unsigned n_ticks = 			\
+				((ns)<n_bogo) ? 1u : (ns)/n_bogo;	\
+			volatile unsigned n_count;			\
+			for(n_count=0; n_count<n_ticks; n_count++)	\
+				;	/* do nothing */		\
+		} while(0)
+
+	/*
+	 * Note there are 4 * I2C_DELAY per I2C clock cycle
+	 * So, 400 kHz requires an I2C delay of 625 ns.
+	 * However, this calculation only works if the S/W
+	 * overhead in I2C bit-banging is negligible - which it is not!
+	 * So, in practice, either I2C_DELAY or CFG_I2C_SPEED will be lower.
+	 * The higher the clock frequency, the greater the difference.
+	 * Empirical measurement/adjustment is recommended.
+	 */
+#	define CFG_I2C_SPEED	400000				/* I2C speed (Hz) */
+#	define I2C_DELAY	do { NDELAY(625); } while (0)	/* 625 ns */
+#endif	/* CONFIG_CMD_I2C */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hmp7100.h b/include/configs/hmp7100.h
new file mode 100644
index 0000000..e9ed0c2
--- /dev/null
+++ b/include/configs/hmp7100.h
@@ -0,0 +1,277 @@
+/*
+ * (C) Copyright 2004,2010 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27		/* Input clock is 27 MHz */
+
+	/*
+	 * The latests version of the mb442 TargetPack (which
+	 * the HMP7100 uses) differentiates between cut2.0 and
+	 * cut 3.0 STx7109 silicon in SE-mode. One of the key
+	 * differences pertains as to whither the LMI registers
+	 * and LMI base should be moved.
+	 *
+	 * By default, we have the following:
+	 *	cut 2.0 has LMI Physical base at 0x04000000
+	 *	cut 3.0 has LMI Physical base at 0x40000000
+	 *
+	 * Hence, we need to build U-Boot differently, depending
+	 * on which cut of silicon is on the board!
+	 *
+	 * Only define the following macro if you are using
+	 * a cut 2.x STb7109 part, and are *not* moving the
+	 * LMI base to 0x40000000.
+	 */
+#undef CONFIG_SH_STB7109_CUT2	/* define, if it is a STx7109 cut 2.x SoC */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI-Sys via PMB */
+#if defined(CONFIG_SH_STB7109_CUT2)
+#define CFG_SE_PHYSICAL_BASE	0x04000000	/* LMI-Sys Physical Address */
+#else
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI-Sys Physical Address */
+#endif	/* CONFIG_SH_STB7109_CUT2 */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI-Sys un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region */
+#endif
+
+#if defined(CONFIG_SH_HMP7100_128)
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI-Sys SDRAM */
+#else
+#define CFG_SDRAM_SIZE		0x04000000	/*  64 MiB of LMI-Sys SDRAM */
+#endif	/* CONFIG_SH_HMP7100_128 */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD hmp7100
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-8"		/* 9 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-10"	/* 11 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet:
+ *    The on-board SMSC LAN9118
+ *    for STb7109, the on-chip STMAC & PHY (on daughter-board)
+ */
+
+#if 0
+	/* Config for SMSC LAN9118 */
+#	define CONFIG_DRIVER_SMC911X
+#ifdef CONFIG_SH_SE_MODE
+#	define CONFIG_SMC911X_BASE	0xb2000300ul
+#else	/* CONFIG_SH_SE_MODE */
+#	define CONFIG_SMC911X_BASE	0xa2000300ul
+#endif	/* CONFIG_SH_SE_MODE */
+#else
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HMP7100> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_AUTO_COMPLETE       1
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* STb7100 reference board organised as 8 MiB flash with 64 KiB blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	135	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresses, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index 0dcc702..0209dfb 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -368,7 +368,7 @@
 #	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
 #endif	/* CONFIG_CMD_NAND */
 
-#if 1 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+#if 0 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
 	/*
 	 * If we want to store "u-boot.bin" in NAND flash starting at
 	 * physical block #0, but there are Bad Blocks in the first
diff --git a/include/configs/mb837.h b/include/configs/mb837.h
new file mode 100644
index 0000000..419b5a6
--- /dev/null
+++ b/include/configs/mb837.h
@@ -0,0 +1,508 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+	/*
+	 * Define the following macro only if the MB837 CPU board
+	 * will be mated with a MB705 peripheral board.
+	 */
+#undef  CONFIG_SH_MB705		/* MB837 withOUT a MB705 */
+#define CONFIG_SH_MB705		/* MB837 + MB705 */
+
+
+/*-----------------------------------------------------------------------
+ *	Switch settings to select between the SoC's main 3 boot-modes:
+ *		a) boot from 16-bit NOR flash
+ *		b) boot from 8-bit NAND flash, small-page, long address
+ *		c) boot from SPI serial flash
+ *
+ *	Four of these setting are on SW2, on the edge of the CPU board,
+ *	Note: One of these is on the MB705 peripheral board!
+ *
+ *	Board	Switch	NOR	NAND	SPI
+ *	-----	------	---	----	---
+ *	MB837	SW2-1	 ON	 ON	off
+ *	MB837	SW2-2	off	 ON	 ON
+ *	MB837	SW2-3	 ON	off	off
+ *	MB837	SW2-4	off	 ON	 ON
+ *	MB705	SW8-1	 ON	off	QQQ
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
+	/*
+	 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
+	 * If so, then who takes responsibility for this???
+	 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
+	 * Should U-Boot read SW8(1) on the MB705, and do something?
+	 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSB in EPLD */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb837
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use (on MB705 Peripheral Board) */
+#if 1
+#	define CFG_STM_ASC_BASE		ST40_ASC2_REGS_BASE	/* COM0 lower connector */
+#else
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* COM1 upper connector */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 on-chip ST-GMACs (MII0 on CN18, MII1 on CN19).
+ * A daughter-board with a PHY may be connected to either connector.
+ * We assume a MB859 (with a IC+ IP1001 PHY) is used on MII0 (CN18).
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC0_BASE	0xfda88000ul	/* MII #0 (CN18) */
+#	define CFG_STM_STMAC1_BASE	0xfe730000ul	/* MII #1 (CN19) */
+#	define CFG_STM_STMAC_BASE	CFG_STM_STMAC0_BASE
+#	define CONFIG_STMAC_IP1001	/* IC+ IP1001, on MB859 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//QQQ #define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* upper */
+#	define CFG_USB1_BASE			0xfea00000	/* lower */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB837> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the MB837 + MB705 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+#if 0 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+	/*
+	 * If we want to store "u-boot.bin" in NAND flash starting at
+	 * physical block #0, but there are Bad Blocks in the first
+	 * few blocks that we need to "skip" over, then we need
+	 * to define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING to allow
+	 * skipping of these bad blocks for u-boot to relocate itself.
+	 * In addition, we also need to tell U-boot the block size,
+	 * and provide it a local abridged copy of the master Bad Block
+	 * Table (BBT), which must also be stored in physical block #0
+	 * - see "cpu/sh/start.S" for details.
+	 * Also, CFG_NAND_SKIP_BLOCK_COUNT defines the number of blocks
+	 * stored in the abridged copy of the master BBT.
+	 */
+#	define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING	/* define for skipping */
+#	define CFG_NAND_SKIP_BLOCK_SIZE		(16<<10)/* Block Size = 16 KiB */
+#	define CFG_NAND_SKIP_BLOCK_COUNT	16	/* entries in the array */
+#endif /* CFG_BOOT_FROM_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+/*----------------------------------------------------------------------
+ * I2C configuration
+ */
+
+#define CONFIG_CMD_I2C				/* do we want I2C support ? */
+
+#if defined(CONFIG_CMD_I2C)
+#	define CONFIG_I2C_BUS		2	/* Use I2C Bus associated with SSC #2 */
+#	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
+#	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
+#	define I2C_ACTIVE			/* open-drain, nothing to do */
+#	define I2C_TRISTATE			/* open-drain, nothing to do */
+#	define I2C_SCL(val)		do { stx7108_i2c_scl((val)); } while (0)
+#	define I2C_SDA(val)		do { stx7108_i2c_sda((val)); } while (0)
+#	define I2C_READ			stx7108_i2c_read()
+
+	/*
+	 * The "BOGOS" for NDELAY() may be calibrated using the
+	 * following code fragment, and measuring (using an oscilloscope)
+	 * the frequency of the I2C SCL pin, and adjusting
+	 * NDELAY_BOGOS, until the SCL is approximately 100 kHz.
+	 * (100kHz has a period of 5us + 5us).
+	 *
+	 *	printf("just toggling I2C SCL (100kHz frequency) ...\n");
+	 *	while (1)
+	 *	{
+	 *		I2C_SCL(1); NDELAY(5000);
+	 *		I2C_SCL(0); NDELAY(5000);
+	 *	}
+	 */
+#	define NDELAY_BOGOS		20	/* Empirical measurement for 1ns on MB837A */
+#	define NDELAY(ns)						\
+		do {							\
+			const unsigned n_bogo = NDELAY_BOGOS;		\
+			const unsigned n_ticks = 			\
+				((ns)<n_bogo) ? 1u : (ns)/n_bogo;	\
+			volatile unsigned n_count;			\
+			for(n_count=0; n_count<n_ticks; n_count++)	\
+				;	/* do nothing */		\
+		} while(0)
+
+	/*
+	 * Note there are 4 * I2C_DELAY per I2C clock cycle
+	 * So, 400 kHz requires an I2C delay of 625 ns.
+	 * However, this calculation only works if the S/W
+	 * overhead in I2C bit-banging is negligible - which it is not!
+	 * So, in practice, either I2C_DELAY or CFG_I2C_SPEED will be lower.
+	 * The higher the clock frequency, the greater the difference.
+	 * Empirical measurement/adjustment is recommended.
+	 */
+#	define CFG_I2C_SPEED	400000				/* I2C speed (Hz) */
+#	define I2C_DELAY	do { NDELAY(625); } while (0)	/* 625 ns */
+#endif	/* CONFIG_CMD_I2C */
+
+#endif	/* __CONFIG_H */
diff --git a/sh_config.mk b/sh_config.mk
index 1fdc414..ed27c1d 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2010-04-29\""
+SH_IDENT_STRING="\"stm23-2010-07-07\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
