diff --git a/MAKEALL b/MAKEALL
index 4b9934a..5f58efc 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -676,6 +676,8 @@ LIST_sh="		\
 	mb519se		\
 	mb618		\
 	mb618se		\
+	hdk7111		\
+	hdk7111se	\
 	mb671		\
 	mb671se		\
 	mb680		\
diff --git a/Makefile b/Makefile
index 436fd47..d6837c2 100644
--- a/Makefile
+++ b/Makefile
@@ -2672,10 +2672,10 @@ atstk1002_config	:	unconfig
 #########################################################################
 
 mb411_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STB7100 1" >>include/config.h
-	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
-	@./mkconfig -a mb411 sh sh mb411 "" stb7100
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb411 sh sh mb411 st stb7100
 
 mb442_27_config \
 mb442_30_config \
@@ -2685,156 +2685,167 @@ mb442se_27_config \
 mb442se_30_config \
 mb442se_27_128_config \
 mb442se_30_128_config : 	unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB442     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb442
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB442     1" >>$(obj)include/config.h
 	$(if $(findstring 27,$@), \
-	@echo "#define INPUT_CLOCK_RATE    27" >>include/config.h)
+	@echo "#define INPUT_CLOCK_RATE    27" >>$(obj)include/config.h)
 	$(if $(findstring 30,$@), \
-	@echo "#define INPUT_CLOCK_RATE    30" >>include/config.h)
+	@echo "#define INPUT_CLOCK_RATE    30" >>$(obj)include/config.h)
 	$(if $(findstring 128,$@), \
-	@echo "#define CONFIG_SH_MB442_128 1" >>include/config.h)
+	@echo "#define CONFIG_SH_MB442_128 1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/mb442/config.tmp)
-	@./mkconfig -a mb442 sh sh mb442 "" stb7100
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb442/config.tmp)
+	@$(MKCONFIG) -a mb442 sh sh mb442 st stb7100
 
 mb448_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB448     1" >>include/config.h
-	@./mkconfig -a mb448 sh sh mb448 "" stb7100
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB448     1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb448 sh sh mb448 st stb7100
 
 hms1_config \
 hms1_128_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
-	@echo "#define CONFIG_SH_HMS1      1" >>include/config.h
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HMS1      1" >>$(obj)include/config.h
 	$(if $(findstring 128,$@), \
-	@echo "#define CONFIG_SH_HMS1_128  1" >>include/config.h)
-	@./mkconfig -a hms1 sh sh hms1 "" stb7100
+	@echo "#define CONFIG_SH_HMS1_128  1" >>$(obj)include/config.h)
+	@$(MKCONFIG) -a hms1 sh sh hms1 st stb7100
 
 mb519_config \
 mb519se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB519     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb519
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB519     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb519/config.tmp)
-	@./mkconfig -a mb519 sh sh mb519 "" stx7200
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb519/config.tmp)
+	@$(MKCONFIG) -a mb519 sh sh mb519 st stx7200
 
 mb618_config \
 mb618se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7111   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB618     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb618
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB618     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb618/config.tmp)
+	@$(MKCONFIG) -a mb618 sh sh mb618 st stx7111
+
+hdk7111_config \
+hdk7111se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hdk7111
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HDK7111   1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb618/config.tmp)
-	@./mkconfig -a mb618 sh sh mb618 "" stx7111
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/hdk7111/config.tmp)
+	@$(MKCONFIG) -a hdk7111 sh sh hdk7111 st stx7111
 
 mb628_config \
 mb628se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7141   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB628     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb628
+	@echo "#define CONFIG_SH_STX7141   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB628     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x83900000" >$(obj)board/mb628/config.tmp)
-	@./mkconfig -a mb628 sh sh mb628 "" stx7141
+	@echo "TEXT_BASE = 0x83900000" >$(obj)board/st/mb628/config.tmp)
+	@$(MKCONFIG) -a mb628 sh sh mb628 st stx7141
 
 mb671_config \
 mb671se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB671     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb671
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB671     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb671/config.tmp)
-	@./mkconfig -a mb671 sh sh mb671 "" stx7200
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb671/config.tmp)
+	@$(MKCONFIG) -a mb671 sh sh mb671 st stx7200
 
 mb680_config \
 mb680se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7105   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB680     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb680
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB680     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb680/config.tmp)
-	@./mkconfig -a mb680 sh sh mb680 "" stx7105
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb680/config.tmp)
+	@$(MKCONFIG) -a mb680 sh sh mb680 st stx7105
 
 pdk7105_config \
 pdk7105se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7105   1" >>include/config.h
-	@echo "#define CONFIG_SH_PDK7105   1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_PDK7105   1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
-	@./mkconfig -a pdk7105 sh sh pdk7105 "" stx7105
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a pdk7105 sh sh pdk7105 st stx7105
 
 ipidtv7105_config \
 ipidtv7105se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7105    1" >>include/config.h
-	@echo "#define CONFIG_SH_IPIDTV7105 1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_IPIDTV7105 1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE    1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
-	@./mkconfig -a ipidtv7105 sh sh pdk7105 "" stx7105
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a ipidtv7105 sh sh pdk7105 st stx7105
 
 mb704_config \
 mb704se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX5197   1" >>include/config.h
-	@echo "#define CONFIG_SH_MB704     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/mb704
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB704     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/mb704/config.tmp)
-	@./mkconfig -a mb704 sh sh mb704 "" stx5197
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb704/config.tmp)
+	@$(MKCONFIG) -a mb704 sh sh mb704 st stx5197
 
 5197cab_config \
 5197cabse_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX5197   1" >>include/config.h
-	@echo "#define CONFIG_SH_5197CAB   1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/5197cab
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_5197CAB   1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/5197cab/config.tmp)
-	@./mkconfig -a 5197cab sh sh 5197cab "" stx5197
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/5197cab/config.tmp)
+	@$(MKCONFIG) -a 5197cab sh sh 5197cab st stx5197
 
 cb101_config \
 cb101se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
-	@echo "#define CONFIG_SH_CB101     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/cb101
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB101     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/cb101/config.tmp)
-	@./mkconfig -a cb101 sh sh cb101 "" stx7200
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/cb101/config.tmp)
+	@$(MKCONFIG) -a cb101 sh sh cb101 st stx7200
 
 cb102_config \
 cb102se_config :		unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
-	@echo "#define CONFIG_SH_CB102     1" >>include/config.h
+	@mkdir -p $(obj)include $(obj)board/st/cb102
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB102     1" >>$(obj)include/config.h
 	$(if $(findstring se,$@), \
-	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/cb102/config.tmp)
-	@./mkconfig -a cb102 sh sh cb102 "" stx7200
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/cb102/config.tmp)
+	@$(MKCONFIG) -a cb102 sh sh cb102 st stx7200
 
 
 #========================================================================
@@ -2845,32 +2856,32 @@ cb102se_config :		unconfig
 #########################################################################
 
 sti5301mb390_config		: 	unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_STM_MB390   1" >>include/config.h
-	@echo "#define CONFIG_STM_STI5301 1" >>include/config.h
-	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
-	@./mkconfig -a sti5301mb390 st200 st231 sti5301mb390 "" sti5301
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB390   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb390 st200 st231 sti5301mb390 st sti5301
 
 sti5301mb424_config		: 	unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_STM_MB424   1" >>include/config.h
-	@echo "#define CONFIG_STM_STI5301 1" >>include/config.h
-	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
-	@./mkconfig -a sti5301mb424 st200 st231 sti5301mb424 "" sti5301
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB424   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb424 st200 st231 sti5301mb424 st sti5301
 
 stm8010mboard_config		:	unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_STM_STM8010_MBOARD   1" >>include/config.h
-	@echo "#define CONFIG_STM_STM8010 1" >>include/config.h
-	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
-	@./mkconfig -a stm8010mboard st200 st231 stm8010mboard "" stm8010
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_STM8010_MBOARD   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a stm8010mboard st200 st231 stm8010mboard st stm8010
 
 traviata_config		:	unconfig
-	@ >include/config.h
-	@echo "#define CONFIG_STM_TRAVIATA   1" >>include/config.h
-	@echo "#define CONFIG_STM_STM8010 1" >>include/config.h
-	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
-	@./mkconfig -a traviata st200 st231 traviata "" stm8010
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_TRAVIATA   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a traviata st200 st231 traviata st stm8010
 
 
 #########################################################################
diff --git a/board/5197cab/5197cab.c b/board/5197cab/5197cab.c
deleted file mode 100644
index 2b22d5a..0000000
--- a/board/5197cab/5197cab.c
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * (C) Copyright 2009 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/stx5197reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-
-#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
-
-
-	/* Alternate Function Output Selection accessors */
-#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
-#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
-#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
-#define ALTFOP(reg,port,pin,alt)			\
-	do {						\
-		reg &= ~ALT_MASK((port),(pin), 0x3);	\
-		reg |=  ALT_MASK((port),(pin),(alt));	\
-	} while(0)
-
-
-extern void flashWriteEnable (void)
-{
-	/* Enable Vpp for writing to flash */
-}
-
-extern void flashWriteDisable (void)
-{
-	/* Disable Vpp for writing to flash */
-}
-
-
-#ifdef CONFIG_STM_ASC_SERIAL
-static void configSerial (void)
-{
-	unsigned long sysconf;
-
-#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
-	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
-	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
-	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
-	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
-	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
-	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
-	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
-#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
-	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
-	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
-	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
-	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
-	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
-	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
-	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
-#else
-#error Unknown serial port configuration!
-#endif
-}
-#endif /* CONFIG_STM_ASC_SERIAL */
-
-
-extern int board_init (void)
-{
-#ifdef CONFIG_STM_ASC_SERIAL
-	configSerial ();
-#endif /* CONFIG_STM_ASC_SERIAL */
-
-	return 0;
-}
-
-
-extern int checkboard (void)
-{
-	printf ("\n\nBoard: STx5197-CAB"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	return 0;
-}
diff --git a/board/5197cab/5197cab.romgen b/board/5197cab/5197cab.romgen
deleted file mode 100644
index 08fa12f..0000000
--- a/board/5197cab/5197cab.romgen
+++ /dev/null
@@ -1,781 +0,0 @@
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x000000f0)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x0000000f)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-POKE32(0xfdc00110, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG0
-*/
-POKE32(0xfdc00000, 0x00002303)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG0
-*/
-POKE32(0xfdc00008, 0x00002803)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG0
-*/
-POKE32(0xfdc00090, 0x0000366c)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG1
-*/
-POKE32(0xfdc00094, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG2
-*/
-POKE32(0xfdc00098, 0x00000053)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG0
-*/
-POKE32(0xfdc000a0, 0x0000cccc)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG1
-*/
-POKE32(0xfdc000a4, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG2
-*/
-POKE32(0xfdc000a8, 0x00000075)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG0
-*/
-POKE32(0xfdc000ac, 0x0000366c)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG1
-*/
-POKE32(0xfdc000b0, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG2
-*/
-POKE32(0xfdc000b4, 0x00000053)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
-*/
-POKE32(0xfdc000b8, 0x0000739c)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
-*/
-POKE32(0xfdc000bc, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
-*/
-POKE32(0xfdc000c0, 0x00000014)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
-*/
-POKE32(0xfdc000c4, 0x00000aaa)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
-*/
-POKE32(0xfdc000c8, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
-*/
-POKE32(0xfdc000cc, 0x00000071)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG0
-*/
-POKE32(0xfdc000d0, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG1
-*/
-POKE32(0xfdc000d4, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG2
-*/
-POKE32(0xfdc000d8, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
-*/
-POKE32(0xfdc000dc, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
-*/
-POKE32(0xfdc000e0, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
-*/
-POKE32(0xfdc000e4, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
-*/
-POKE32(0xfdc000e8, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
-*/
-POKE32(0xfdc000ec, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
-*/
-POKE32(0xfdc000f0, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
-*/
-POKE32(0xfdc000f4, 0x00000aaa)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
-*/
-POKE32(0xfdc000f8, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
-*/
-POKE32(0xfdc000fc, 0x00000071)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
-*/
-POKE32(0xfdc00100, 0x0000cccc)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
-*/
-POKE32(0xfdc00104, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
-*/
-POKE32(0xfdc00108, 0x00000075)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG
-*/
-POKE32(0xfdc00180, 0x00000844)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-POKE32(0xfdc00180, 0x00001844)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00000000)
-DELAY(200)
-DELAY(20)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
-DELAY(20)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP0
-*/
-POKE32(0xfdc00014, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP0
-*/
-POKE32(0xfdc00020, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP0
-*/
-POKE32(0xfdc00030, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP0
-*/
-POKE32(0xfdc00040, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP0
-*/
-POKE32(0xfdc00054, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
-*/
-POKE32(0xfdc00060, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP0
-*/
-POKE32(0xfdc00070, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP0
-*/
-POKE32(0xfdc00080, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f08)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f08)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f18)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f18)
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP0
-*/
-POKE32(0xfdc00014, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP1
-*/
-POKE32(0xfdc00018, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP0
-*/
-POKE32(0xfdc00020, 0x00000af3)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP1
-*/
-POKE32(0xfdc00024, 0x00003c00)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP0
-*/
-POKE32(0xfdc00030, 0x00000b31)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP1
-*/
-POKE32(0xfdc00034, 0x00004dea)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP0
-*/
-POKE32(0xfdc00040, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP1
-*/
-POKE32(0xfdc00044, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP0
-*/
-POKE32(0xfdc00054, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP1
-*/
-POKE32(0xfdc00058, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
-*/
-POKE32(0xfdc00060, 0x00000a39)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
-*/
-POKE32(0xfdc00064, 0x00003334)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP0
-*/
-POKE32(0xfdc00070, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP1
-*/
-POKE32(0xfdc00074, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP0
-*/
-POKE32(0xfdc00080, 0x00000ab3)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP1
-*/
-POKE32(0xfdc00084, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f10)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f10)
-DELAY(200)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-POKE32(0xfdc00110, 0x00000002)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
-
-
-/*
-LMI.LMI_MIM0
-*/
-POKE32(0xfe000008, 0x061c0203)
-
-
-/*
-LMI.LMI_STR
-*/
-POKE32(0xfe000018, 0x3ff27e7a)
-
-
-/*
-LMI.LMI_SDRA0
-*/
-POKE32(0xfe000030, 0x10001a00)
-
-
-/*
-LMI.LMI_SDRA1
-*/
-POKE32(0xfe000038, 0x10001a00)
-DELAY(200)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000003)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000001)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000002)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000400)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000400)
-DELAY(200)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000133)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000133)
-DELAY(200)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000002)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000033)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000033)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000000)
-
-
-/*
-LMI.LMI_COC_UPPER
-*/
-POKE32(0xfe00002c, 0x00330000)
-
-
-/*
-LMI.LMI_COC_LOWER
-*/
-POKE32(0xfe000028, 0x0003e000)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
-*/
-/* PEEK(0xfd901014) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
-*/
-POKE32(0xfd901014, 0x00000000)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
-*/
-/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
-*/
-POKE32(0xfd901048, 0x400000c0)
-
-
-/*
-LMI.LMI_MIM1
-*/
-POKE32(0xfe00000c, 0x00000075)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
-*/
-/* PEEK(0xfd901000) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
-*/
-POKE32(0xfd901000, 0x00800000)
-
-
-/*
-sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
-*/
-POKE32(0xfdc00188, 0x0000002a)
-
-
-/*
-sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
-*/
-/* PEEK(0xfd002008) (used target peek value 0x38472000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
-*/
-/* PEEK(0xfd901030) (used target peek value 0x00001279) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
-*/
-/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x00000100)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
diff --git a/board/5197cab/Makefile b/board/5197cab/Makefile
deleted file mode 100644
index 70041dd..0000000
--- a/board/5197cab/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/5197cab/config.mk b/board/5197cab/config.mk
deleted file mode 100644
index d83a0ae..0000000
--- a/board/5197cab/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2009 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# STx5197-CAB board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x8FF00000	29-bit mode (Traditional Mode)
-#	0x83F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 63MB in P1 (cachable)
-TEXT_BASE = 0x8FF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/5197cab/init-5197cab.S b/board/5197cab/init-5197cab.S
deleted file mode 100644
index d1c9920..0000000
--- a/board/5197cab/init-5197cab.S
+++ /dev/null
@@ -1,82 +0,0 @@
-#include "asm/stx5197reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "5197cab.romgen"
-
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
-	 */
-	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
-
-	/*
-	 * Change LMI upper bound addresses
-	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
-	 */
-	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
-	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/cb101/Makefile b/board/cb101/Makefile
deleted file mode 100644
index 219443a..0000000
--- a/board/cb101/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o nand.o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/cb101/cb101.c b/board/cb101/cb101.c
deleted file mode 100644
index 1a3b11c..0000000
--- a/board/cb101/cb101.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7200reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-void flashWriteEnable(void)
-{
-	/*  Enable vpp for writing to flash */
-}
-
-void flashWriteDisable(void)
-{
-	/*  Disable vpp for writing to flash */
-}
-
-
-#define PIO_BASE  0xfd020000
-
-
-static void configPIO(void)
-{
-	/*  Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-	/* Reset the on-board STe101P PHY */
-	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
-	udelay(1);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
-	udelay(1);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-
-#if defined(CONFIG_CMD_NAND)
-	/*  Setup PIO for NAND FLASH devices: Ready/Not_Busy */
-	SET_PIO_PIN(PIO_PORT(2), 7, STPIO_IN);
-#endif	/* CONFIG_CMD_NAND */
-}
-
-
-#if defined(CONFIG_CMD_NAND)
-static void nand_emi_init(void)
-{
-	/* setup the EMI configuration for the 2 banks
-	 * containing NAND flash devices. */
-
-	/* NAND FLASH in EMI Bank #1 (128MB) */
-	*ST40_EMI_BANK1_EMICONFIGDATA0 = 0x04100e99;
-	*ST40_EMI_BANK1_EMICONFIGDATA1 = 0x04000200;
-	*ST40_EMI_BANK1_EMICONFIGDATA2 = 0x04000200;
-	*ST40_EMI_BANK1_EMICONFIGDATA3 = 0x00000000;
-
-	/* NAND FLASH in EMI Bank #2 (1GB) */
-	*ST40_EMI_BANK2_EMICONFIGDATA0 = 0x04100e99;
-	*ST40_EMI_BANK2_EMICONFIGDATA1 = 0x04000200;
-	*ST40_EMI_BANK2_EMICONFIGDATA2 = 0x04000200;
-	*ST40_EMI_BANK2_EMICONFIGDATA3 = 0x00000000;
-}
-#endif	/* CONFIG_CMD_NAND */
-
-
-int board_init(void)
-{
-	unsigned long sysconf;
-
-	/* Serial port set up */
-	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG40;
-	sysconf &= ~(1<<16);
-	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
-
-	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<25);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* No idea, more routing: conf_pad_pio[0] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<24);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<2);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_pio[4] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<28);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_clkobs = 1 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf |= (1<<14);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* I2C and USB related routing */
-	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
-	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
-	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Enable SOFT_JTAG mode.
-	 * Taken from OS21, but is this correct?
-	 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG33;
-	sysconf |= (1<<6);
-	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
-	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
-
-#if defined(CONFIG_CMD_NAND)
-	nand_emi_init();
-#endif	/* CONFIG_CMD_NAND */
-
-	configPIO();
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: cb101"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-#if defined(CONFIG_STMAC_MAC0)
-	/* On-board PHY (MII0) in MII mode, using MII_CLK */
-	stx7200_configure_ethernet(0, 0, 0, 0);
-#endif	/* CONFIG_STMAC_MAC0 */
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-	return 0;
-}
diff --git a/board/cb101/config.mk b/board/cb101/config.mk
deleted file mode 100644
index 37f427b..0000000
--- a/board/cb101/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# CB101 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x8FF00000	29-bit mode (Traditional Mode)
-#	0x87F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 127MB in P1 (cachable)
-TEXT_BASE = 0x8FF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/cb101/init-cb101.S b/board/cb101/init-cb101.S
deleted file mode 100644
index 5f6c463..0000000
--- a/board/cb101/init-cb101.S
+++ /dev/null
@@ -1,388 +0,0 @@
-
-#include "asm/stx7200reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-  /* ----- STx7200 Clocks ----- */
-
-  /* Set CLOCKGENA PLL0 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL0... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
-
-  /* Configure CLOCKGENA PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENA PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-  /* Wait for CLOCKGENA PLL0 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-  /* Clear CLOCKGENA PLL0 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENA PLL1 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL1... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
-
-  /* Configure CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-  /* Enable CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-  /* Wait for CLOCKGENA PLL1 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
-
-  /* Clear CLOCKGENA PLL1 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENA PLL2 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL2... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
-
-  /* Configure CLOCKGENA PLL2... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENA PLL2... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
-
-  /* Wait for CLOCKGENA PLL2 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
-
-  /* Clear CLOCKGENA PLL2 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENB PLL0 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
-
-  /* Power down CLOCKGENB PLL0... */
-  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
-
-  /* Configure CLOCKGENB PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENB PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
-
-  /* Wait for CLOCKGENB PLL0 to lock... */
-  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
-
-  /* Clear CLOCKGENB PLL0 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
-
-  /* Power down PLL... */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
-
-  /* Configure PLL... */
-  /* Set LMI clock to 666MHz */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
-  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
-
-  /* Enable CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-
-  /* ----- STx7200 Sysconf ----- */
-
-  /* Exit from reset */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
-  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
-
-  /* Check both DLL on LMI0 are locked */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-  /* Check both DLL on LMI1 are locked */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
-
-  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
-
-  /* Enable AutoPrecharge */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
-  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
-
-  /* Force DLL1 and DLL2 commands of LMI0 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
-
-  /* Force DLL1 and DLL2 commands of LMI1 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
-
-  /* ----- STx7200 EMI configuration ----- */
-
-  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
-
-  /* Bank #0 - NOR FLASH (32MiB) at address 0x00000000 -> 0x01ffffff */
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x04320691)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x8F122300)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x8F122300)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-  /* Bank #1 - NAND FLASH (128MiB), at address 0x02000000 -> 0x02FFFFFF */
-#if 0
-  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
-  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x04100e99);
-  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x04000200);
-  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x04000200);
-  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000);
-#endif
-
-  /* Bank #2 - NAND FLASH (1GB), at address 0x03000000 -> 0x03FFFFFF */
-#if 0
-  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x04100e99);
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x04000200);
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x04000200);
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000);
-#endif
-
-  /* Bank #3 - unused, at address 0x04000000 -> 0x04FFFFFF */
-
-  /* Bank #4 - unused, at address 0x05000000 -> 0x05FFFFFF */
-
-  /* Program other EMI registers */
-  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-
-  /* ----- STx7200 LMI0 configuration ----- */
-
-  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
-/*POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)*/ /* OLD */
-  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
-/*POKE_LONG(ST40_LMI_MIM_1(0), 0xffff1010)*/ /* OLD */
-  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
-
-  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
-  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
-
-  /* lmi base address 0x08000000 + 128MiB 13x10 */
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
-
-  /* lmi base address 0x08000000 + 128MiB 13x10 */
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
-
-  /* Enable clock with NOP command */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Issue EMRS2 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
-
-  /* Issue EMRS3 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
-
-  /* Issue EMRS1 to enable DLL */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
-
-  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
-
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
-  /* 2 CBR (auto refresh) */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
-
-  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
-
-  /* Issue EMRS1 for OCD calibration default */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
-
-  /* Issue EMRS1 for OCD calibration exit */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
-
-  /* Enable auto refresh */
-  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
-
-  /* ----- STx7200 LMI1 configuration ----- */
-
-  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
-  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
-  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
-
-  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
-  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
-
-  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
-
-  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
-
-  /* Enable clock with NOP command */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Issue EMRS2 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
-
-  /* Issue EMRS3 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
-
-  /* Issue EMRS1 to enable DLL */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
-
-  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
-
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
-  /* 2 CBR (auto refresh) */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
-
-  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
-
-  /* Issue EMRS1 for OCD calibration default */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
-
-  /* Issue EMRS1 for OCD calibration exit */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
-
-  /* Enable auto refresh */
-  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
-
-#ifdef CONFIG_SH_SE_MODE
-  /*
-   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-   * their 32-bit SE mode locations as defined in the datasheet and change the
-   * 'upper bound addresses' (in row attribute registers) for the LMIs.
-   */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/cb101/nand.c b/board/cb101/nand.c
deleted file mode 100644
index 697a901..0000000
--- a/board/cb101/nand.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-
-#if defined(CONFIG_CMD_NAND)
-
-#include <nand.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-#include <asm/stx7200reg.h>
-
-#define PIO_BASE  0xfd020000
-
-
-/*
- * hardware specific access to control-lines
- *	CL -> Emi_Addr(17)
- *	AL -> Emi_Addr(18)
- *	nCE is handled by EMI (not s/w controlable)
- */
-static void cb101_hwcontrol(struct mtd_info *mtdinfo, int cmd)
-{
-	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
-
-	switch(cmd) {
-
-	case NAND_CTL_SETCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
-		break;
-
-	case NAND_CTL_CLRCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
-		break;
-
-	case NAND_CTL_SETALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
-		break;
-
-	case NAND_CTL_CLRALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
-		break;
-	}
-}
-
-
-/*
- * hardware specific access to the Ready/not_Busy signal.
- * Signal is routed through GPIO port#2, pin #7.
- */
-static int cb101_device_ready(struct mtd_info *mtd)
-{
-	int ret = STPIO_GET_PIN(2,7);
-	return ret;
-}
-
-
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific (per include/linux/mtd/nand.h):
- * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
- * - hwcontrol: hardwarespecific function for accesing control-lines
- * - dev_ready: hardwarespecific function for  accesing device ready/busy line
- * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
- *   only be provided if a hardware ECC is available
- * - eccmode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- * Members with a "?" were not set in the merged testing-NAND branch,
- * so they are not set here either.
- */
-extern int board_nand_init(struct nand_chip *nand)
-{
-	nand->hwcontrol = cb101_hwcontrol;
-	nand->dev_ready = cb101_device_ready;
-	nand->eccmode = NAND_ECC_SOFT;
-	nand->chip_delay = 25;
-	nand->options = NAND_NO_AUTOINCR;
-	return 0;
-}
-#endif	/* CONFIG_CMD_NAND */
-
diff --git a/board/cb102/Makefile b/board/cb102/Makefile
deleted file mode 100644
index 70041dd..0000000
--- a/board/cb102/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/cb102/cb102.c b/board/cb102/cb102.c
deleted file mode 100644
index f6ecd27..0000000
--- a/board/cb102/cb102.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * (C) Copyright 2007-2008 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
- * Sean McGoogan <Sean.McGoogan@st.com> - added cb102 support
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7200reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-void flashWriteEnable(void)
-{
-	/* Enable Vpp for writing to flash */
-	/* Not under software control on this board. */
-}
-
-void flashWriteDisable(void)
-{
-	/* Disable Vpp for writing to flash */
-	/* Not under software control on this board. */
-}
-
-
-#define PIO_BASE  0xfd020000
-
-
-static void configPIO(void)
-{
-	/*  Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-	/* Reset the on-board SMSC LAN8700 PHY */
-	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
-	udelay(1);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-}
-
-
-int board_init(void)
-{
-	unsigned long sysconf;
-
-	/* Serial port set up */
-	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG40;
-	sysconf &= ~(1<<16);
-	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
-
-	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<25);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* No idea, more routing: conf_pad_pio[0] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<24);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<2);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_pio[4] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<28);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_clkobs = 1 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf |= (1<<14);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* I2C and USB related routing */
-	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
-	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
-	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Enable SOFT_JTAG mode.
-	 * Taken from OS21, but is this correct?
-	 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG33;
-	sysconf |= (1<<6);
-	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
-	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
-
-	configPIO();
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: cb102"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-#if defined(CONFIG_STMAC_MAC0)
-	/* On-board PHY (MII0) in MII mode, using MII_CLK */
-	stx7200_configure_ethernet (0, 0, 0, 0);
-#endif	/* CONFIG_STMAC_MAC0 */
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-	return 0;
-}
diff --git a/board/cb102/config.mk b/board/cb102/config.mk
deleted file mode 100644
index fb571b3..0000000
--- a/board/cb102/config.mk
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007-2008 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# CB102 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x97F00000	29-bit mode (Traditional Mode)
-#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 255MB in P1 (cachable)
-TEXT_BASE = 0x97F00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/cb102/init-cb102.S b/board/cb102/init-cb102.S
deleted file mode 100644
index 688b229..0000000
--- a/board/cb102/init-cb102.S
+++ /dev/null
@@ -1,426 +0,0 @@
-
-#include "asm/stx7200reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/* ----- STx7200 Clocks ----- */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0... to 900MHz */
-	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL2 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL2... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
-
-	/* Configure CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
-
-	/* Wait for CLOCKGENA PLL2 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
-
-	/* Clear CLOCKGENA PLL2 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENB PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENB PLL0... */
-	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
-
-	/* Configure CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
-
-	/* Wait for CLOCKGENB PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENB PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
-
-	/* Power down PLL... */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
-
-#ifdef SLOW_LMI
-	/* Set LMI clock to 666MHz */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-#else	/* !SLOW_LMI */
-	/* Set LMI clock to 800MHz */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
-#endif	/* SLOW_LMI */
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ELSE(1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* ----- STx7200 Sysconf ----- */
-
-	/* PLI_CLOCK_ENABLE set to 0 */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
-	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Check both DLL on LMI1 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
-	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
-
-	/* Force DLL1 and DLL2 command of LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
-
-	/* Force DLL1 and DLL2 command of LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
-
-	/* Set cfg55 and cfg56 */
-	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-
-	/* PDL offsets
-	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
-	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
-	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
-	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
-	 */
-
-	/* TO BE UPDATED FOR 7200/MB671 */
-	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
-
-	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
-
-	/* ----- STx7200 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - Not configured */
-	/* Bank 2 - Not configured */
-	/* Bank 3 - Not configured */
-	/* Bank 4 - Not configured */
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000050)
-
-	/* ----- STx7200 LMI0 configuration ----- */
-
-	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
-
-	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
-
-	/* ----- STx7200 LMI1 configuration ----- */
-
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
-
-	/* SDRAM Timing Register */
-	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
-
-	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
-
-	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/cb103/cb103.romgen b/board/cb103/cb103.romgen
deleted file mode 100644
index 5a1c8b7..0000000
--- a/board/cb103/cb103.romgen
+++ /dev/null
@@ -1,1580 +0,0 @@
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
-/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80101400) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x80101400)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000001)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x00181400) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x00180f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x80000f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x80100a00)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000002)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x00180f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x80000f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x80102803)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000004)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x00182803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x00182803)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x80002803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x80102803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-POKE32(0xfd701058, 0x0000fff8)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x00182803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-POKE32(0xfd701058, 0x00007ff8)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x80002803)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x00001d28)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x000016c0)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x000016c0) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x000006c0)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-/* PEEK(0xfd704014) (used target peek value 0x1e04402b) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA01
-*/
-/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
-/* PEEK(0xa5000000) (used target peek value 0x00110011) */
-/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80002803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x000006c0) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
-*/
-/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
-*/
-/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-POKE32(0xfd7041e8, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x080006a1)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG15
-*/
-POKE32(0xfd70413c, 0x08000001)
-DELAY(200)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-POKE32(0xfd7041e8, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-/* PEEK(0xfd704014) (used target peek value 0x1e175c6b) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA05
-*/
-/* PEEK(0xfd70401c) (used target peek value 0x1e179572) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA05
-*/
-WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG12
-*/
-POKE32(0xfd704130, 0xa200687f)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG16
-*/
-POKE32(0xfd704140, 0xa200687f)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG38
-*/
-POKE32(0xfd704198, 0x002ffd08)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG39
-*/
-POKE32(0xfd70419c, 0x002ffd18)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG13
-*/
-POKE32(0xfd704134, 0x00020000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG14
-*/
-POKE32(0xfd704138, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG17
-*/
-POKE32(0xfd704144, 0x00020000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG18
-*/
-POKE32(0xfd704148, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG55
-*/
-POKE32(0xfd7041dc, 0x07fc0284)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG56
-*/
-POKE32(0xfd7041e0, 0x07fc0284)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG42
-*/
-POKE32(0xfd7041a8, 0x07b7dbed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG43
-*/
-POKE32(0xfd7041ac, 0x980001ed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG44
-*/
-POKE32(0xfd7041b0, 0x87b7dbed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG45
-*/
-POKE32(0xfd7041b4, 0x180001ed)
-/* PEEK(0xfd70412c) (used target peek value 0x080006a1) */
-/* PEEK(0xfd704130) (used target peek value 0xa200687f) */
-/* PEEK(0xfd704134) (used target peek value 0x00020000) */
-/* PEEK(0xfd704138) (used target peek value 0x00000000) */
-/* PEEK(0xfd70413c) (used target peek value 0x08000001) */
-/* PEEK(0xfd704140) (used target peek value 0xa200687f) */
-/* PEEK(0xfd704144) (used target peek value 0x00020000) */
-/* PEEK(0xfd704148) (used target peek value 0x00000000) */
-/* PEEK(0xfd704198) (used target peek value 0x002ffd08) */
-/* PEEK(0xfd70419c) (used target peek value 0x002ffd18) */
-/* PEEK(0xfd7041a8) (used target peek value 0x07b7dbed) */
-/* PEEK(0xfd7041ac) (used target peek value 0x980001ed) */
-/* PEEK(0xfd7041b0) (used target peek value 0x87b7dbed) */
-/* PEEK(0xfd7041b4) (used target peek value 0x180001ed) */
-/* PEEK(0xfd7041cc) (used target peek value 0x00000000) */
-/* PEEK(0xfd7041d0) (used target peek value 0x00000000) */
-/* PEEK(0xfd7041d4) (used target peek value 0x00000000) */
-/* PEEK(0xfd7041d8) (used target peek value 0x00000000) */
-/* PEEK(0xfd7041dc) (used target peek value 0x07fc0284) */
-/* PEEK(0xfd7041e0) (used target peek value 0x07fc0284) */
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfdf00860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfdf00800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfdf00810, 0x00000008)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfdf00820, 0x0000000c)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfdf00830, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfdf00840, 0x00000014)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfdf00100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfdf00108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfdf00110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfdf00118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfdf00180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfdf00188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfdf00190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfdf00198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfdf00200, 0x042086f1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfdf00208, 0x8a002200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfdf00210, 0x8a004200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfdf00218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfdf00028, 0x00000050)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd18008, 0x07f6015b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfdd1800c, 0xffff0500)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfdd18018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfdd1801c, 0x002202d6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfdd18030, 0x18001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfdd18038, 0x18001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd18008, 0x07f6035b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfdd18028, 0x00000000)
-POKE32(0xa8000000, 0x00000000)
-POKE32(0xa8000000, 0xaaaaaaaa)
-/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xa8001000, 0x00000000)
-POKE32(0xa8001000, 0x55555555)
-/* PEEK(0xa8001000) (used target peek value 0x55555555) */
-POKE32(0xa8002000, 0x00000000)
-POKE32(0xa8002000, 0x12345678)
-/* PEEK(0xa8002000) (used target peek value 0x12345678) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd19008, 0x07f6015b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfdd1900c, 0xffff0500)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfdd19018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfdd1901c, 0x002202d6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfdd19030, 0x1c001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfdd19038, 0x1c001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd19008, 0x07f6035b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfdd19028, 0x00000000)
-POKE32(0xb8000000, 0x00000000)
-POKE32(0xb8000000, 0xaaaaaaaa)
-/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xb8001000, 0x00000000)
-POKE32(0xb8001000, 0x55555555)
-/* PEEK(0xb8001000) (used target peek value 0x55555555) */
-POKE32(0xb8002000, 0x00000000)
-POKE32(0xb8002000, 0x12345678)
-/* PEEK(0xb8002000) (used target peek value 0x12345678) */
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-/* PEEK(0xfd704114) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-POKE32(0xfd704114, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-POKE32(0xfd704124, 0x08000a8c)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG28
-*/
-POKE32(0xfd704170, 0x00004001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-POKE32(0xfd704174, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-POKE32(0xfd704174, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-/* PEEK(0xfd704114) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-POKE32(0xfd704114, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-POKE32(0xfd704124, 0x08000a8c)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG26
-*/
-POKE32(0xfd704168, 0x00004001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-POKE32(0xfd70416c, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-POKE32(0xfd70416c, 0x00000000)
diff --git a/board/cb103/init-cb103.S b/board/cb103/init-cb103.S
deleted file mode 100644
index 32770ab..0000000
--- a/board/cb103/init-cb103.S
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "asm/stx7200reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:cb103:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "cb103" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "cb103.romgen"
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/hms1/Makefile b/board/hms1/Makefile
deleted file mode 100644
index 08e99d9..0000000
--- a/board/hms1/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-hms1.o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/hms1/config.mk b/board/hms1/config.mk
deleted file mode 100644
index aff8d30..0000000
--- a/board/hms1/config.mk
+++ /dev/null
@@ -1,30 +0,0 @@
-#
-# (C) Copyright 2005
-# Andy Sturges (andy.sturges@st.com)
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# HMS1 board
-#
-
-# Installs at SDRAM BASE  + 31M in cache region
-TEXT_BASE = 0x86F00000
-PLATFORM_LDFLAGS +=
diff --git a/board/hms1/hms1.c b/board/hms1/hms1.c
deleted file mode 100644
index 82726d9..0000000
--- a/board/hms1/hms1.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stb7100reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-#if defined CFG_JFFS_CUSTOM_PART
-#include <jffs2/jffs2.h>
-#endif
-
-void stb7100_clocks(void);
-
-#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
-
-#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
-
-void flashWriteEnable(void)
-{
-}
-
-void flashWriteDisable(void)
-{
-}
-
-#define PIO_BASE  0xb8024000
-
-static void configPIO(void)
-{
-  SET_PIO_ASC(PIO_BASE, 3, 2, 4, 5);
-}
-
-#if defined(CONFIG_CMD_IDE)
-
-#ifdef CONFIG_SH_STB7100_IDE
-static void stb7100mboard_init_ide(void)
-{
-  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
-}
-#endif
-
-#endif
-
-int board_init(void)
-{
-	unsigned long sysconf;
-	/* Route UART2 instead of SCI to PIO4 */
-	/* Set ssc2_mux_sel = 0 */
-	sysconf = *STB7100_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
-
-	configPIO();
-
-#if defined(CONFIG_CMD_IDE)
-#ifdef CONFIG_SH_STB7100_IDE
-	stb7100mboard_init_ide();
-#endif
-#ifdef CONFIG_SH_STB7100_SATA
-	stb7100_sata_init();
-#endif
-#endif
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: HMS1"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	LED = 1;
-
-	return 0;
-}
-
-#if defined CFG_JFFS_CUSTOM_PART
-
-/*
- * jffs2_part_info - get information about a JFFS2 partition
- *
- * @part_num: number of the partition you want to get info about
- * @return:   struct part_info* in case of success, 0 if failure
- *
- * Reads env variable jff2part for partition info
- *
- */
-
-static struct part_info part;
-static int current_part = -1;
-
-struct part_info* jffs2_part_info(int part_num) {
-	void *jffs2_priv_saved = part.jffs2_priv;
-
-	printf("jffs2_part_info: part_num=%i\n",part_num);
-
-	if (current_part == part_num)
-		return &part;
-
-	/* u-boot partition                                                 */
-	if(part_num==0){
-		ulong offset, size=0;
-		char *f;
-
-		if ((f=getenv("jffs2part"))) {
-			char *p;
-			offset = simple_strtoul(f, &p, 16);
-			size   = simple_strtoul(p+1, NULL, 16);
-		}
-
-		if (size) {
-			memset(&part, 0, sizeof(part));
-
-			part.offset=offset;
-			part.size=size;
-
-			/* Mark the struct as ready */
-			current_part = part_num;
-
-			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
-			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
-		}
-	}
-
-	if (current_part == part_num) {
-/*QQQ-HACK:	part.usr_priv = &current_part;	*/
-		part.jffs2_priv = jffs2_priv_saved;
-		return &part;
-	}
-
-	printf("jffs2_part_info: end of partition table\n");
-	return 0;
-}
-#endif
diff --git a/board/hms1/init-hms1.S b/board/hms1/init-hms1.S
deleted file mode 100644
index fef751a..0000000
--- a/board/hms1/init-hms1.S
+++ /dev/null
@@ -1,224 +0,0 @@
-
-#include "asm/stb7100reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * CLOCKGENA setup PLL0
-	 */
-
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-
-	/*
-	 * CLOCKGENA setup PLL1
-	 */
-
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
-#if CONFIG_SH_STB7100_V1_1
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
-#else
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
-	IF_DEVID(STB7100_CUT3) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-	IF_DEVID(STB7109_CUT2) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-	IF_DEVID(STB7109_CUT3) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-#endif
-	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-
-	/*
-	 * SYSCONF setup
-	 */
-	IF_DEVID(STB7109_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
-	ELSE
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
-	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-	ENDIF
-	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
-
-#ifdef  CONFIG_SH_STB7100_V1_1
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
-#else
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
-	ENDIF
-#endif
-	/*
-	 * LMI SYS setup
-	 */
-#ifdef CONFIG_SH_STB7100_V1_1
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
-#else
-	/*POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)*/
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a0247)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
-#endif
-	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
-
-#if CONFIG_SH_HMS1_128
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
-#else
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
-#endif
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
-
-#if CONFIG_SH_HMS1_128
-	POKE_LONG(SH4_CCN_CCR, 0x8000090d)
-#endif
-
-	/*
-	 * LMI VID setup
-	 */
-#ifdef CONFIG_SH_STB7100_V1_1
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
-#else
-	/*POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)*/
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a0247)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
-#endif
-	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
-	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
-
-	/*
-	 * EMI setup
-	 */
-	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
-	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
-	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
-	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
-	/* FLASH */
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-	/* STEM Module */
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x93001111)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x91001111)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
-#if 0
-	/* DVBCI */
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-#endif
-	/* ATAPI */
-#if defined(CONFIG_SH_STB7100_V1_1)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-#else
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-#endif
-
-#if 0
-	/* EPLD & LAN91C111 */
-
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-#endif
-
-	/* Program other EMI registers */
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7100_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7100_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7109_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb411/Makefile b/board/mb411/Makefile
deleted file mode 100644
index 9c17e88..0000000
--- a/board/mb411/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb411/config.mk b/board/mb411/config.mk
deleted file mode 100644
index 5f44ec6..0000000
--- a/board/mb411/config.mk
+++ /dev/null
@@ -1,30 +0,0 @@
-#
-# (C) Copyright 2005
-# Andy Sturges (andy.sturges@st.com)
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB411 (STb7100 Mboard) board
-#
-
-# Installs at SDRAM BASE  + 31M in cache region
-TEXT_BASE = 0x85F00000
-PLATFORM_LDFLAGS +=
diff --git a/board/mb411/init-mb411.S b/board/mb411/init-mb411.S
deleted file mode 100644
index e926753..0000000
--- a/board/mb411/init-mb411.S
+++ /dev/null
@@ -1,209 +0,0 @@
-
-#include "asm/stb7100reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * CLOCKGENA setup PLL0
-	 */
-
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-
-	/*
-	 * CLOCKGENA setup PLL1
-	 */
-
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
-#if CONFIG_SH_STB7100_V1_1
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
-#else
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
-	IF_DEVID(STB7100_CUT3) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-	IF_DEVID(STB7109_CUT2) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-	IF_DEVID(STB7109_CUT3) /* 400MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-	ENDIF
-#endif
-	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-
-	/*
-	 * SYSCONF setup
-	 */
-	IF_DEVID(STB7109_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
-	ELSE
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
-	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-	ENDIF
-	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
-
-#ifdef  CONFIG_SH_STB7100_V1_1
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
-#else
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
-	ENDIF
-#endif
-	/*
-	 * LMI SYS setup
-	 */
-#ifdef CONFIG_SH_STB7100_V1_1
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
-#else
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
-#endif
-	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
-
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
-
-	/*
-	 * LMI VID setup
-	 */
-#ifdef CONFIG_SH_STB7100_V1_1
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
-#else
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
-#endif
-	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
-	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
-
-	/*
-	 * EMI setup
-	 */
-	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
-	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
-	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
-	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
-	/* FLASH */
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-	/* STEM Module */
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x0e024400)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x0e024400)
-	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
-	/* DVBCI */
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-	/* ATAPI */
-#if defined(CONFIG_SH_STB7100_V1_1)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-#else
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-#endif
-
-	/* EPLD & LAN91C111 */
-
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
-	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7100_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7100_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7109_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb411/mb411.c b/board/mb411/mb411.c
deleted file mode 100644
index 0038b2d..0000000
--- a/board/mb411/mb411.c
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stb7100reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-#if defined CFG_JFFS_CUSTOM_PART
-#include <jffs2/jffs2.h>
-#endif
-
-void stb7100_clocks(void);
-
-#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
-#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
-
-#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
-
-void flashWriteEnable(void)
-{
-  /*  Enable vpp for writing to flash */
-  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
-}
-
-void flashWriteDisable(void)
-{
-  /*  Disable vpp for writing to flash */
-  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
-}
-
-#define PIO_BASE  0xb8020000
-
-static void configPIO(void)
-{
-  /*  Setup PIO of ASC device */
-  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
-}
-
-#if defined(CONFIG_CMD_IDE)
-
-#ifdef CONFIG_SH_STB7100_IDE
-static void stb7100mboard_init_ide(void)
-{
-  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
-}
-#endif
-
-#endif
-
-int board_init(void)
-{
-	unsigned long sysconf;
-	/* Route UART2 instead of SCI to PIO4 */
-	/* Set ssc2_mux_sel = 0 */
-	sysconf = *STB7100_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
-
-	configPIO();
-
-#if defined(CONFIG_CMD_IDE)
-#ifdef CONFIG_SH_STB7100_IDE
-	stb7100mboard_init_ide();
-#endif
-#ifdef CONFIG_SH_STB7100_SATA
-	stb7100_sata_init();
-#endif
-#endif
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STb7100-Mboard (MB411)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	LED = 1;
-
-	return 0;
-}
-
-
-#if defined CFG_JFFS_CUSTOM_PART
-
-/*
- * jffs2_part_info - get information about a JFFS2 partition
- *
- * @part_num: number of the partition you want to get info about
- * @return:   struct part_info* in case of success, 0 if failure
- *
- * Reads env variable jff2part for partition info
- *
- */
-
-static struct part_info part;
-static int current_part = -1;
-
-struct part_info* jffs2_part_info(int part_num) {
-	void *jffs2_priv_saved = part.jffs2_priv;
-
-	printf("jffs2_part_info: part_num=%i\n",part_num);
-
-	if (current_part == part_num)
-		return &part;
-
-	/* u-boot partition                                                 */
-	if(part_num==0){
-		ulong offset, size=0;
-		char *f;
-
-		if ((f=getenv("jffs2part"))) {
-			char *p;
-			offset = simple_strtoul(f, &p, 16);
-			size   = simple_strtoul(p+1, NULL, 16);
-		}
-
-		if (size) {
-			memset(&part, 0, sizeof(part));
-
-			part.offset=offset;
-			part.size=size;
-
-			/* Mark the struct as ready */
-			current_part = part_num;
-
-			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
-			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
-		}
-	}
-
-	if (current_part == part_num) {
-/*QQQ-HACK:	part.usr_priv = &current_part;	*/
-		part.jffs2_priv = jffs2_priv_saved;
-		return &part;
-	}
-
-	printf("jffs2_part_info: end of partition table\n");
-	return 0;
-}
-#endif
diff --git a/board/mb442/Makefile b/board/mb442/Makefile
deleted file mode 100644
index 9c17e88..0000000
--- a/board/mb442/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb442/config.mk b/board/mb442/config.mk
deleted file mode 100644
index 4e73ed4..0000000
--- a/board/mb442/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2005
-# Andy Sturges (andy.sturges@st.com)
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB442 (STb7100REF or Coco) board
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x87F00000	29-bit mode (Traditional Mode)
-#	0x83F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at SDRAM BASE  + 63M in P1 (cachable)
-TEXT_BASE = 0x87F00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb442/init-mb442.S b/board/mb442/init-mb442.S
deleted file mode 100644
index 68c85db..0000000
--- a/board/mb442/init-mb442.S
+++ /dev/null
@@ -1,230 +0,0 @@
-
-#include "asm/stb7100reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * CLOCKGENA setup PLL0
-	 */
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
-#if (INPUT_CLOCK_RATE == 30)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
-#else
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
-#endif
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-	/*
-	 * CLOCKGENA setup PLL1
-	 */
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
-	IF_DEVID(STB7100_CUT1) /* 266 MHz */
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
-#endif
-	ELSE
-#if (INPUT_CLOCK_RATE == 30)   /* 384 MHz */
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
-#endif
-	ENDIF
-	IF_DEVID(STB7100_CUT3) /* 400MHz */
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-#endif
-	ENDIF
-	IF_DEVID(STB7109_CUT2) /* 400MHz */
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-#endif
-	ENDIF
-	IF_DEVID(STB7109_CUT3) /* 400MHz */
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
-#endif
-	ENDIF
-	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-	/*
-	 * SYSCONF setup
-	 */
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
-
-	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
-
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
-	ENDIF
-
-	/*
-	 * LMI SYS setup
-	 */
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a025f)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
-
-	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
-
-#if CONFIG_SH_MB442_128
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
-#else
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
-#endif
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
-
-	/*
-	 * LMI VID setup
-	 */
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a025f)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
-
-	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
-	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
-
-#if CONFIG_SH_MB442_128
-       POKE_LONG(SH4_CCN_CCR, 0x8000090d)
-#endif
-
-	/*
-	 * EMI setup
-	 */
-	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
-	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
-	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
-	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
-	/* FLASH */
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-	/* EPLD & LAN91C111 */
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-	/* ATAPI */
-
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
-	ELSE
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
-	ENDIF
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-
-	/* Program other EMI registers */
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7100_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7100_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	IF_DEVID(STB7109_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7109_CUT3)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-
-#ifdef CONFIG_SH_SE_MODE
-  /*
-   * Note that we also manually need to move the System and Video LMI base
-   * addresses to their 32-bit SE mode locations as defined in the datasheet.
-   */
-        UPDATE_LONG(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
-#ifdef CONFIG_SH_MB442_128
-        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x48001a00)
-        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x48001a00)
-#else
-        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x44001900)
-        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x44001900)
-#endif
-        POKE_LONG(ST40_LMI_SDRA0_0(VID), 0x64001900)
-        POKE_LONG(ST40_LMI_SDRA1_0(VID), 0x64001900)
-
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb442/mb442.c b/board/mb442/mb442.c
deleted file mode 100644
index ee5ea3a..0000000
--- a/board/mb442/mb442.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stb7100reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-void stb7100_clocks(void);
-
-void flashWriteEnable(void)
-{
-  /* Enable Vpp for writing to flash */
-  /* QQQ - to do */
-}
-
-void flashWriteDisable(void)
-{
-  /* Disable Vpp for writing to flash */
-  /* QQQ - to do */
-}
-
-#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
-
-static void configPIO(void)
-{
-  /*  Setup PIO of ASC device */
-  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
-
-  /*  Setup up ethernet reset */
-#ifdef CONFIG_DRIVER_SMC91111
-  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
-#endif
-#ifdef CONFIG_DRIVER_NETSTMAC
-  SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
-#endif
-}
-
-#if defined(CONFIG_CMD_IDE)
-
-#ifdef CONFIG_SH_STB7100_IDE
-static void stb7100ref_init_ide(void)
-{
-  /* Enable ATAPI mode of EMI */
-  /* QQQ - to do */
-}
-#endif
-
-#endif
-
-int board_init(void)
-{
-	unsigned long sysconf;
-	/* Route UART2 instead of SCI to PIO4 */
-	/* Set ssc2_mux_sel = 0 */
-	sysconf = *STB7100_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
-
-	configPIO();
-
-#ifdef CONFIG_DRIVER_SMC91111
-	/*  Reset ethernet chip */
-	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
-#endif
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-	/*  Reset ethernet chip */
-	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(2), 4, 0);
-	udelay(2000);
-	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
-#endif
-
-#if defined(CONFIG_CMD_IDE)
-#ifdef CONFIG_SH_STB7100_IDE
-	stb7100ref_init_ide();
-#endif
-#ifdef CONFIG_SH_STB7100_SATA
-	stb7100_sata_init();
-#endif
-#endif
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STb7100-Reference (MB442)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	return 0;
-}
diff --git a/board/mb448/Makefile b/board/mb448/Makefile
deleted file mode 100644
index 9c17e88..0000000
--- a/board/mb448/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb448/config.mk b/board/mb448/config.mk
deleted file mode 100644
index 9db40e3..0000000
--- a/board/mb448/config.mk
+++ /dev/null
@@ -1,30 +0,0 @@
-#
-# (C) Copyright 2005
-# Andy Sturges (andy.sturges@st.com)
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB448 (STb7109EREF) board
-#
-
-# Installs at SDRAM BASE  + 31M in cache region
-TEXT_BASE = 0x85F00000
-PLATFORM_LDFLAGS +=
diff --git a/board/mb448/init-mb448.S b/board/mb448/init-mb448.S
deleted file mode 100644
index 430e875..0000000
--- a/board/mb448/init-mb448.S
+++ /dev/null
@@ -1,168 +0,0 @@
-
-#include "asm/stb7100reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * CLOCKGENA setup PLL0
-	 */
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
-#if (INPUT_CLOCK_RATE == 30)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
-#else
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
-#endif
-	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-	/*
-	 * CLOCKGENA setup PLL1
-	 */
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
-	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
-	IF_DEVID(STB7100_CUT2)
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
-#endif
-	ENDIF
-	IF_DEVID(STB7100_CUT1)
-#if (INPUT_CLOCK_RATE == 30)
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
-#else
-	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
-#endif
-	ENDIF
-	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
-	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
-	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
-	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
-	/*
-	 * SYSCONF setup
-	 */
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
-
-	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
-
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
-	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
-
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
-	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
-	ENDIF
-
-	/*
-	 * LMI SYS setup
-	 */
-	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
-
-	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
-
-	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
-	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
-
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000400)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
-
-	/*
-	 * LMI VID setup
-	 */
-	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
-	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
-
-	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
-	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
-	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
-	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
-	/*
-	 * EMI setup
-	 */
-	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
-	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
-	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
-	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
-	/* FLASH */
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-	/* EPLD & LAN91C111 */
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
-	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-	/* ATAPI */
-
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
-	ENDIF
-	IF_DEVID(STB7100_CUT2)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
-	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
-	ENDIF
-	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	IF_DEVID(STB7100_CUT1)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
-	ENDIF
-	IF_DEVID(STB7100_CUT2)
-	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-	ENDIF
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb448/mb448.c b/board/mb448/mb448.c
deleted file mode 100644
index 0162801..0000000
--- a/board/mb448/mb448.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * (C) Copyright 2004 STMicroelectronics.
- *
- * Andy Sturges <andy.sturges@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stb7100reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-void stb7100_clocks(void);
-
-#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
-#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
-
-#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
-
-void flashWriteEnable(void)
-{
-  /*  Enable vpp for writing to flash */
-  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
-}
-
-void flashWriteDisable(void)
-{
-  /*  Disable vpp for writing to flash */
-  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
-}
-
-#define PIO_BASE  0xb8020000
-#define PIO2_BASE  0xb8024000
-
-static void configPIO(void)
-{
-  /*  Setup PIO of ASC device */
-  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
-  /*  Setup up ethernet reset */
-  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
-}
-
-#if defined(CONFIG_CMD_IDE)
-
-#ifdef CONFIG_SH_STB7100_IDE
-static void stb7100ref_init_ide(void)
-{
-  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
-}
-#endif
-
-#endif
-
-int board_init(void)
-{
-	unsigned long sysconf;
-	/* Route UART2 instead of SCI to PIO4 */
-	/* Set ssc2_mux_sel = 0 */
-	sysconf = *STB7100_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
-
-	configPIO();
-
-#ifdef CONFIG_DRIVER_SMC91111
-	/*  Reset ethernet chip */
-	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
-	udelay(1000);
-	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
-#endif
-
-#if defined(CONFIG_CMD_IDE)
-#ifdef CONFIG_SH_STB7100_IDE
-	stb7100ref_init_ide();
-#endif
-#ifdef CONFIG_SH_STB7100_SATA
-	stb7100_sata_init();
-#endif
-#endif
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STb7109E-Reference (MB448)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	LED = 1;
-
-	return 0;
-}
diff --git a/board/mb519/Makefile b/board/mb519/Makefile
deleted file mode 100644
index 70041dd..0000000
--- a/board/mb519/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb519/config.mk b/board/mb519/config.mk
deleted file mode 100644
index cf00d78..0000000
--- a/board/mb519/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB519 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x8FF00000	29-bit mode (Traditional Mode)
-#	0x87F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 127MB in P1 (cachable)
-TEXT_BASE = 0x8FF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb519/init-mb519.S b/board/mb519/init-mb519.S
deleted file mode 100644
index 6d91947..0000000
--- a/board/mb519/init-mb519.S
+++ /dev/null
@@ -1,376 +0,0 @@
-
-#include "asm/stx7200reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *       opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-  /* ----- STx7200 Clocks ----- */
-
-  /* Set CLOCKGENA PLL0 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL0... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
-
-  /* Configure CLOCKGENA PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENA PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-  /* Wait for CLOCKGENA PLL0 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-  /* Clear CLOCKGENA PLL0 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENA PLL1 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL1... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
-
-  /* Configure CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-  /* Enable CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-  /* Wait for CLOCKGENA PLL1 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
-
-  /* Clear CLOCKGENA PLL1 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENA PLL2 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
-
-  /* Power down CLOCKGENA PLL2... */
-  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
-
-  /* Configure CLOCKGENA PLL2... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENA PLL2... */
-  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
-
-  /* Wait for CLOCKGENA PLL2 to lock... */
-  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
-
-  /* Clear CLOCKGENA PLL2 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
-
-  /* Set CLOCKGENB PLL0 into BYPASS... */
-  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
-
-  /* Power down CLOCKGENB PLL0... */
-  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
-
-  /* Configure CLOCKGENB PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-  /* Enable CLOCKGENB PLL0... */
-  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
-
-  /* Wait for CLOCKGENB PLL0 to lock... */
-  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
-
-  /* Clear CLOCKGENB PLL0 from BYPASS... */
-  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
-
-  /* Power down PLL... */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
-
-  /* Configure PLL... */
-  /* Set LMI clock to 666MHz */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
-  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
-
-  /* Enable CLOCKGENA PLL1... */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-
-  /* ----- STx7200 Sysconf ----- */
-
-  /* Exit from reset */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
-  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
-
-  /* Check both DLL on LMI0 are locked */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-  /* Check both DLL on LMI1 are locked */
-  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
-
-  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
-
-  /* Enable AutoPrecharge */
-  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
-  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
-
-  /* Force DLL1 and DLL2 commands of LMI0 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
-
-  /* Force DLL1 and DLL2 commands of LMI1 */
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
-  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
-
-  /* ----- STx7200 EMI configuration ----- */
-
-  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
-
-  /* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-  /* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-  /* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
-  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
-  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
-  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
-  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-  /* Program other EMI registers */
-  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
-
-  /* ----- STx7200 LMI0 configuration ----- */
-
-  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
-  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)
-  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
-
-  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
-  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
-
-  /* lmi base address 0x08000000 + 128MiB 13x10 */
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
-
-  /* lmi base address 0x08000000 + 128MiB 13x10 */
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
-
-  /* Enable clock with NOP command */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Issue EMRS2 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
-
-  /* Issue EMRS3 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
-
-  /* Issue EMRS1 to enable DLL */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
-
-  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
-
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
-  /* 2 CBR (auto refresh) */
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
-
-  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
-
-  /* Issue EMRS1 for OCD calibration default */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
-
-  /* Issue EMRS1 for OCD calibration exit */
-  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
-
-  /* Enable auto refresh */
-  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
-
-  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
-
-  /* ----- STx7200 LMI1 configuration ----- */
-
-  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
-  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
-  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
-
-  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
-  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
-
-  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
-
-  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
-
-  /* Enable clock with NOP command */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Issue EMRS2 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
-
-  /* Issue EMRS3 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
-
-  /* Issue EMRS1 to enable DLL */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
-
-  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
-
-  /* Wait NOP command for 400 nsec */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  /* Precharge all */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
-  /* 2 CBR (auto refresh) */
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
-
-  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
-
-  /* Issue EMRS1 for OCD calibration default */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
-
-  /* Issue EMRS1 for OCD calibration exit */
-  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
-
-  /* Enable auto refresh */
-  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
-
-  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
-
-#ifdef CONFIG_SH_SE_MODE
-  /*
-   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-   * their 32-bit SE mode locations as defined in the datasheet and change the
-   * 'upper bound addresses' (in row attribute registers) for the LMIs.
-   */
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
-  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
-  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb519/mb519.c b/board/mb519/mb519.c
deleted file mode 100644
index 7db5570..0000000
--- a/board/mb519/mb519.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * (C) Copyright 2007 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7200reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-#ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
-#else
-#define EPLD_BASE		0xa5000000
-#endif	/* CONFIG_SH_SE_MODE */
-
-#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
-
-void flashWriteEnable(void)
-{
-	/*  Enable vpp for writing to flash */
-	*EPLD_FlashCtrlAddr = 3;
-}
-
-void flashWriteDisable(void)
-{
-	/*  Disable vpp for writing to flash */
-	*EPLD_FlashCtrlAddr = 2;
-}
-
-#define PIO_BASE  0xfd020000
-
-static void configPIO(void)
-{
-  /*  Setup PIO of ASC device */
-  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-  SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
-}
-
-int board_init(void)
-{
-	unsigned long sysconf;
-
-	/* Serial port set up */
-	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG40;
-	sysconf &= ~(1<<16);
-	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
-
-	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<25);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* No idea, more routing: conf_pad_pio[0] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<24);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<2);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_pio[4] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<28);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_clkobs = 1 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf |= (1<<14);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* I2C and USB related routing */
-	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
-	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
-	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Enable SOFT_JTAG mode.
-	 * Taken from OS21, but is this correct?
-	 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG33;
-	sysconf |= (1<<6);
-	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
-	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
-
-	configPIO();
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STx7200-Reference (MB519)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-#if defined(CONFIG_STMAC_MAC0)
-	/* On-board PHY (MII0), in MII mode, using its own clock  */
-	stx7200_configure_ethernet(0, 0, 1, 0);
-#elif defined(CONFIG_STMAC_MAC1)
-	/* External PHY board (MII1), in MII mode, using its own clock */
-	stx7200_configure_ethernet(1, 0, 1, 1);
-#endif
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-
-	return 0;
-}
diff --git a/board/mb618/Makefile b/board/mb618/Makefile
deleted file mode 100644
index 219443a..0000000
--- a/board/mb618/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o nand.o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb618/config.mk b/board/mb618/config.mk
deleted file mode 100644
index ed07dd4..0000000
--- a/board/mb618/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2008 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB618 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x93F00000	29-bit mode (Traditional Mode)
-#	0x87F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 127MB in P1 (cachable)
-TEXT_BASE = 0x93F00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
deleted file mode 100644
index e9d3b27..0000000
--- a/board/mb618/init-mb618.S
+++ /dev/null
@@ -1,366 +0,0 @@
-#include "asm/stx7111reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb618.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/* ----- STx7111 Clocks ----- */
-
-	/* Clockgen A initial setup */
-
-	/* Set PLL0 clock to 450MHz */
-	/* PLL0 of clockgenA = PLL1600 */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-//QQQ	OR32(STX7111_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0... */
-	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7111_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/* Set PLL1 clock to 800MHz */
-	/* PLL1 of clockgenA = PLL800 */
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-//QQQ	OR32(STX7111_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1... */
-	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xfff80000, (0x0 << 16) | (0x28 << 8) | (0x03))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7111_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-	/* Set dividers clocks */
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV1_CFG, 0x00000001)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV2_CFG, 0x00000001)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV5_CFG, 0x00000307)
-	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)
-	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV8_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV9_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV10_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV11_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV12_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV15_CFG, 0x00000307)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV16_CFG, 0x00000103)
-	POKE32(STX7111_CLOCKGENA_PLL1_DIV17_CFG, 0x00000103)
-
-	/* Set clock sources */
-	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
-	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
-
-	/* Clockgen D (LMI) initial setup (lmi2xfreq = 540) */
-	/* Power down PLL... */
-	OR32(STX7111_SYSCONF_SYS_CFG11, 0x00001000)
-
-	/* Configure PLL... */
-	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xfffff001, (0x01 << 9) | (0x12 << 1))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
-	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, 0x00000001, 0)
-
-
-	/* ----- STX7111 SysConf ----- */
-	/* PLI_CLOCK_ENABLE set to 0 */
-	OR32(STX7111_SYSCONF_SYS_CFG04, ~(1 << 2))
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7111_SYSCONF_SYS_CFG11, (0x00000001 | 1 << 27))
-
-	/* Delay ~ 200 microseconds (assume 30MHz CPU clock) */
-	DELAY(200 * 30)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7111_SYSCONF_SYS_CFG04, (1 << 2))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7111_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7111_SYSCONF_SYS_CFG38, 0x000FFE0C)
-
-	/* Force DLL1 and DLL2 command of LMI0 */
-	POKE32(STX7111_SYSCONF_SYS_CFG13, 0x00000000)
-	POKE32(STX7111_SYSCONF_SYS_CFG14, 0x00000000)
-
-	/* Set cfg55 */
-#ifndef LMI_16BITS_MODE
-#define LMI_16BITS_MODE 0
-#endif
-	POKE32(STX7111_SYSCONF_SYS_CFG55, 0x03fc2004 | (LMI_16BITS_MODE << 10) | ((0x7 & 0x7) << 7))
-
-	/* PDL offsets */
-	POKE32(STX7111_SYSCONF_SYS_CFG42, 0x07D7EBF5)
-	POKE32(STX7111_SYSCONF_SYS_CFG43, 0x000001F5)
-
-	/* ----- STX7111 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001C)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - STEM 8 MiB 0x04000000 -> 0x047fffff */
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 2 - DVB-CI at address 0x04000000 -> 0x04FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 3 - 32MiB Boards register and either DVBCI notCe2 or
-		STEM notCS1 (16MiB + 16MiB split bank) 0x05000000 -> 0x06ffffff
-	 */
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000010)
-
-
-	/* ----- STX7111 LMI0 configuration ----- */
-
-	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
-	 # Refresh interval compute (from Ignazio, 11jan08)
-	 # 300 MHz --->  T=3.4ns => MIM[28:16]=2038 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
-	 # 330 MHz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
-	 # 360 MHz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
-	 # 400 MHz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
-	 */
-#if LMI_16BITS_MODE == 0
-	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000017b)
-#else
-	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000013b)
-#endif
-	/* Note: refresh is enabled in later steps */
-
-	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
-
-	/* SDRAM Timing Register
-	 # lmi.LMI_STR_0.poke(0x4c2db41b)
-	 # FCh, 19/mar/08: change according to Raffaele G feebacks
-	 #		1-cycle additional delay between RD and WR
-	 */
-	POKE32(ST40_LMI_STR_0(), 0xcc2db41b)
-	POKE32(ST40_LMI_STR_1(), 0x002202d6)
-
-	/* SDRAM Array Attribute Register
-	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
-	 */
-#if LMI_16BITS_MODE == 0
-	POKE32(ST40_LMI_SDRA0_0(), 0x14000a20)
-#else
-	POKE32(ST40_LMI_SDRA0_0(), 0x10000a20)
-#endif
-
-	/* SDRAM Array Attribute Register
-	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
-	 */
-#if LMI_16BITS_MODE == 0
-	POKE32(ST40_LMI_SDRA1_0(), 0x14000a20)
-#else
-	POKE32(ST40_LMI_SDRA1_0(), 0x10000a20)
-#endif
-
-	/* SDRAM Control Register */
-	/* Delay ~ 200 milliseconds (assume 450MHz CPU clock) */
-	DELAY(200000 * 450)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
-	 # lmi.LMI_SDMR0_0.poke(0x00000953)
-	 # FCh, 19/mar/08: change according to Raffaele G feebacks
-	 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
-	 # lmi.LMI_SDMR0_0.poke(0x00000853)
-	 # FCh, 19/mar/08: change according to Raffaele G feebacks
-	 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
-
-	/* Issue EMRS1 for OCD calibration default */
-	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
-
-	/* Issue EMRS1 for OCD calibration exit */
-	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
-
-	/* Enable auto refresh
-	 # lmi.LMI_MIM_0.poke(0x0c30037b)
-	 # FCh, 12/feb/08: cleaner to modify only refresh bit
-	 */
-	OR32(ST40_LMI_MIM_0(), (1 << 9))
-
-	/* DQS recovery mechanism (1=enabled)
-	 # lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1 << 5))
-	 # FCh, 14/jan/08, NO DQS recovery
-	 */
-	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
-
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(), 0x00000000)
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	/* Change LMI upper bound addresses
-	 * Upper LMI addr=0x40000000 + 128Mbytes=0x48000000, 13x10
-	 */
-	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
-	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb618/mb618.c b/board/mb618/mb618.c
deleted file mode 100644
index ab35eac..0000000
--- a/board/mb618/mb618.c
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * (C) Copyright 2008 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/stx7111reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
-
-#ifndef CONFIG_SH_NO_EPLD
-#ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb6000000	/* Phys 0x06000000 */
-#else
-#define EPLD_BASE		0xa6000000
-#endif	/* CONFIG_SH_SE_MODE */
-
-#define EPLD_IDENT		0x00	/* READ: EPLD Identifier Register */
-#define EPLD_BANK		0x00	/* WRITE: EPLD Bank Register */
-#define EPLD_TEST		0x04	/* EPLD Test Register (Banked) */
-#define EPLD_CTRL		0x04	/* EPLD Control Register (Banked) */
-#define EPLD_SET_BANK_TEST	0x00	/* Bank = EPLD_TEST */
-#define EPLD_SET_BANK_CTRL	0x01	/* Bank = EPLD_CTRL */
-
-static inline void epld_write(unsigned long value, unsigned long offset)
-{
-	/* 8-bit write to EPLD registers */
-	writeb(value, EPLD_BASE + offset);
-}
-
-static inline unsigned long epld_read(unsigned long offset)
-{
-	/* 8-bit read from EPLD registers */
-	return readb(EPLD_BASE + offset);
-}
-#endif	/* CONFIG_SH_NO_EPLD */
-
-void flashWriteEnable(void)
-{
-	/* Enable Vpp for writing to flash */
-	STPIO_SET_PIN(PIO_PORT(3), 4, 1);
-}
-
-void flashWriteDisable(void)
-{
-	/* Disable Vpp for writing to flash */
-	STPIO_SET_PIN(PIO_PORT(3), 4, 0);
-}
-
-static void configPIO(void)
-{
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
-
-	/* Setup up Vpp for NOR FLASH */
-	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_OUT);
-}
-
-extern int board_init(void)
-{
-	configPIO();
-
-	return 0;
-}
-
-#if defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD)
-/*
- * Reset the Ethernet PHY, via the EPLD.
- * This code is only for EPLD version 06 or later.
- */
-static inline void mb618_phy_reset06(void)
-{
-	/* set EPLD Bank = Ctrl */
-	epld_write(EPLD_SET_BANK_CTRL, EPLD_BANK);
-
-	/* Bring the PHY out of reset in MII mode */
-	epld_write(0x4 | 0, EPLD_CTRL);
-	epld_write(0x4 | 1, EPLD_CTRL);
-}
-#endif	/* defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD) */
-
-/*
- * We have several EPLD versions, with slightly different memory
- * maps and features:
- *
- * version 04:
- * off  read        reset
- *  0   Status      undef  (unused)
- *  4   Ctrl        20     (unused)
- *  8   Test        33
- *  c   Ident       0      (should be 1 but broken)
- * (note writes are broken)
- *
- * version 05:
- * off  read     write       reset
- *  0   Ident    Ctrl        45
- *  4   Test     Test        55
- *  8   IntStat  IntMaskSet  -
- *  c   IntMask  IntMaskClr  0
- *
- * version 06:
- * off        read       write         reset
- *  0         Ident      Bank          46 (Bank register defaults to 0)
- *  4 bank=0  Test       Test          55
- *  4 bank=1  Ctrl       Ctrl          0e
- *  4 bank=2  IntPri0    IntPri0  f9
- *  4 bank=3  IntPri1    IntPri1  f0
- *  8         IntStat    IntMaskSet    -
- *  c         IntMask    IntMaskClr    00
- *
- * Ctrl register bits:
- *  0 = Ethernet Phy notReset
- *  1 = RMIInotMIISelect
- *  2 = Mode Select_7111 (ModeSelect when D0 == 1)
- *  3 = Mode Select_8700 (ModeSelect when D0 == 0)
- *
- *  The version 06 map is also applicable to later versions.
- *
- *  NOTE: U-Boot only supports version 06 or later of the EPLD.
- *  Versions of the EPLD prior to this version are NOT supported!
- */
-
-static int mb618_init_epld(void)
-{
-#ifdef CONFIG_SH_NO_EPLD
-	/* we ignore talking to the EPLD, tell the user */
-	printf("info: Disregarding any EPLD\n");
-
-#else	/* CONFIG_SH_NO_EPLD */
-	const unsigned char test_values[2] = {0xa4u, 0x2fu};
-	unsigned char epld_reg, inverted;
-	unsigned char epld_version, board_version;
-	int i;
-
-	/* set EPLD Bank = Test */
-	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
-
-	/* for each test value ... */
-	for (i=0; i<sizeof(test_values)/sizeof(test_values[0]); i++) {
-		/* write (anything) to the test register */
-		epld_write(test_values[i], EPLD_TEST);
-		/* calculate what we expect back */
-		inverted = ~test_values[i];
-		/* now read it back */
-		epld_reg = epld_read(EPLD_TEST);
-		/* verify we got back an inverted result */
-		if (epld_reg != inverted) {
-			printf("Failed EPLD test (offset=%02x, %02x!=%02x)\n",
-				EPLD_TEST, epld_reg, inverted);
-			return 1;	/* Failure! */
-			}
-	}
-
-	/* Assume we can trust the ident register */
-	epld_reg      = epld_read(EPLD_IDENT);
-	board_version = (epld_reg >> 5) & 0x07u;
-	epld_version  = (epld_reg >> 0) & 0x1fu;
-
-	/* is it acceptable ? */
-	if (epld_version < 6) {
-		printf("Unsupported EPLD version (reg=0x%02x)\n",
-			epld_reg);
-		return 1;	/* Failure! */
-	}
-
-	/* display the board revision, and EPLD version */
-	printf("MB618: revision %c, EPLD version %02d\n",
-		board_version + 'A',
-		epld_version);
-
-	/* now perform the EPLD initializations we want */
-#ifdef CONFIG_DRIVER_NET_STM_GMAC
-	mb618_phy_reset06();
-#endif
-
-	/* set the Test register back to RESET conditions (for linux) */
-	/* set EPLD Bank = Test */
-	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
-	/* write inverted 0x55, so it reads back as 0x55 */
-	epld_write(~0x55u, EPLD_TEST);
-
-#endif	/* CONFIG_SH_NO_EPLD */
-
-	/* return a "success" result */
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STx7111-Mboard (MB618)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	/*
-	 * initialize the EPLD.
-	 */
-	return mb618_init_epld();
-}
diff --git a/board/mb618/nand.c b/board/mb618/nand.c
deleted file mode 100644
index 6196ba0..0000000
--- a/board/mb618/nand.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-
-#if defined(CONFIG_CMD_NAND)
-
-#include <nand.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-#include <asm/stx7111reg.h>
-
-
-/*
- * hardware specific access to control-lines
- *	CL -> Emi_Addr(17)
- *	AL -> Emi_Addr(18)
- *	nCE is handled by EMI (not s/w controlable)
- */
-static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
-{
-	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
-
-	switch(cmd) {
-
-	case NAND_CTL_SETCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
-		break;
-
-	case NAND_CTL_CLRCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
-		break;
-
-	case NAND_CTL_SETALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
-		break;
-
-	case NAND_CTL_CLRALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
-		break;
-	}
-}
-
-
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific (per include/linux/mtd/nand.h):
- * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
- * - hwcontrol: hardwarespecific function for accesing control-lines
- * - dev_ready: hardwarespecific function for  accesing device ready/busy line
- * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
- *   only be provided if a hardware ECC is available
- * - eccmode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- * Members with a "?" were not set in the merged testing-NAND branch,
- * so they are not set here either.
- */
-extern int board_nand_init(struct nand_chip *nand)
-{
-	nand->hwcontrol = mb618_hwcontrol;
-	nand->eccmode = NAND_ECC_SOFT;
-	nand->chip_delay = 25;
-	nand->options = NAND_NO_AUTOINCR;
-	return 0;
-}
-#endif	/* CONFIG_CMD_NAND */
-
diff --git a/board/mb628/Makefile b/board/mb628/Makefile
deleted file mode 100644
index 219443a..0000000
--- a/board/mb628/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o nand.o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb628/config.mk b/board/mb628/config.mk
deleted file mode 100644
index c23d067..0000000
--- a/board/mb628/config.mk
+++ /dev/null
@@ -1,56 +0,0 @@
-#
-# (C) Copyright 2008-2009 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB628 board:
-#
-#	Following are *Physical* Addresses:
-#
-#	Region		29-bit		32-bit		Size
-#	------		------		------		----
-#	LMI_BASE	0x0c000000	0x40000000	128MiB
-#	VIDEO_BASE	0x0c000000	0x40000000	  4MiB
-#	AUDIO_BASE	0x0c400000	0x40400000	  4MiB
-#	eSTB_BASE	0x0c800000	0x40800000	 50MiB
-#	eSTB_END	0x0f9fffff	0x439fffff	   ---
-#
-#
-#	Following are *Virtual* Addresses:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x8F900000	29-bit mode (Traditional Mode)
-#	0x83900000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at eSTB BASE + 49MB in P1 (cachable)
-TEXT_BASE = 0x8F900000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb628/init-mb628.S b/board/mb628/init-mb628.S
deleted file mode 100644
index 62933e5..0000000
--- a/board/mb628/init-mb628.S
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "asm/stx7141reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb628.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:mb628:estb
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb628" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "mb628.romgen"
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
-	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
-	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
-	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb628/mb628.c b/board/mb628/mb628.c
deleted file mode 100644
index 8aa355c..0000000
--- a/board/mb628/mb628.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * (C) Copyright 2008-2009 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7141reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-
-/* EPLD registers */
-#ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
-#else
-#define EPLD_BASE		0xa5000000
-#endif	/* CONFIG_SH_SE_MODE */
-#define EPLD_IDENT		0x00010000
-#define EPLD_TEST		0x00020000
-#define EPLD_FLASH		0x00050000
-
-
-static inline void epld_write(unsigned long value, unsigned long offset)
-{
-	/* 8-bit write to EPLD registers */
-	writeb(value, EPLD_BASE + offset);
-}
-
-static inline unsigned long epld_read(unsigned long offset)
-{
-	/* 8-bit read from EPLD registers */
-	return readb(EPLD_BASE + offset);
-}
-
-extern void flashWriteEnable(void)
-{
-	/* Enable Vpp for writing to flash */
-	epld_write(3, EPLD_FLASH);
-}
-
-extern void flashWriteDisable(void)
-{
-	/* Disable Vpp for writing to flash */
-	epld_write(2, EPLD_FLASH);
-}
-
-static void configPIO(void)
-{
-	unsigned long sysconf;
-
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(10), 0, 1, 2, 3);  /* ASC1 */
-	SET_PIO_ASC(PIO_PORT(6),  0, 1, 2, 3);  /* ASC2 */
-
-	/* Enable ASC UARTS */
-	sysconf = *STX7141_SYSCONF_SYS_CFG36;
-	/* CFG36[29] = 0 = UART1_CTRL_NOT_MII_SEL */
-	sysconf &= 1ul << 29;
-	/* CFG36[30] = 1 = UART2_CTS_SEL */
-	/* CFG36[31] = 1 = UART2_RXD_SEL */
-	sysconf |= 1ul << 30 | 1ul << 31;
-	*STX7141_SYSCONF_SYS_CFG36 = sysconf;
-
-	/* Route ASC1 via PIO[10] for TX, RX, CTS & RTS */
-	sysconf = *STX7141_SYSCONF_SYS_CFG46;
-	/* PIO10[0] Selector: CFG46[7:6]   = 3 */
-	/* PIO10[1] Selector: CFG46[9:8]   = 3 */
-	/* PIO10[2] Selector: CFG46[11:10] = 3 */
-	/* PIO10[3] Selector: CFG46[13:12] = 3 */
-	sysconf |= 3ul << 6 | 3ul << 8 | 3ul << 10 | 3ul << 12;
-	*STX7141_SYSCONF_SYS_CFG46 = sysconf;
-
-	/* Route ASC2 via PIO[6] for TX & RX */
-	sysconf = *STX7141_SYSCONF_SYS_CFG20;
-	/* PIO6[0] Selector: CFG20[28:27] = 3 */
-	/* PIO6[0] Selector: CFG20[30:29] = 3 */
-	sysconf |= 3ul << 27 | 3ul << 29;
-	*STX7141_SYSCONF_SYS_CFG20 = sysconf;
-
-	/* Route ASC2 via PIO[6] for CTS & RTS */
-	sysconf = *STX7141_SYSCONF_SYS_CFG25;
-	/* PIO6[0] Selector: CFG25[1:0] = 3 */
-	/* PIO6[0] Selector: CFG25[3:2] = 3 */
-	sysconf |= 3ul << 0 | 3ul << 2;
-	*STX7141_SYSCONF_SYS_CFG25 = sysconf;
-}
-
-extern int board_init(void)
-{
-	configPIO();
-
-#if defined(CONFIG_SH_STM_SATA)
-	stx7141_configure_sata ();
-#endif	/* CONFIG_SH_STM_SATA */
-
-	return 0;
-}
-
-extern int checkboard (void)
-{
-	unsigned version;
-
-	printf ("\n\nBoard: STx7141-Mboard (MB628)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	version = epld_read(EPLD_IDENT);
-	printf("mb628 EPLD version %02d\n", version);
-	return 0;
-}
diff --git a/board/mb628/mb628.romgen b/board/mb628/mb628.romgen
deleted file mode 100644
index 6b96f99..0000000
--- a/board/mb628/mb628.romgen
+++ /dev/null
@@ -1,2423 +0,0 @@
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-/* PEEK(0xfe213020) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80003805) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80103805)
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000001)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x00183805) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x00180f01)
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80000f01)
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80004a05) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80104a05)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV0_CFG
-*/
-POKE32(0xfe213b00, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV1_CFG
-*/
-POKE32(0xfe213b04, 0x00000001)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV2_CFG
-*/
-POKE32(0xfe213b08, 0x00000001)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV3_CFG
-*/
-POKE32(0xfe213b0c, 0x00000001)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
-*/
-POKE32(0xfe213a10, 0x00010100)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
-*/
-POKE32(0xfe213a14, 0x00010100)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
-*/
-POKE32(0xfe213a18, 0x00010100)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
-*/
-POKE32(0xfe213a1c, 0x00010100)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV8_CFG
-*/
-POKE32(0xfe213b20, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV9_CFG
-*/
-POKE32(0xfe213b24, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV10_CFG
-*/
-POKE32(0xfe213b28, 0x00000307)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV11_CFG
-*/
-POKE32(0xfe213b2c, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV12_CFG
-*/
-POKE32(0xfe213b30, 0x00000102)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
-*/
-POKE32(0xfe213a34, 0x00000811)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV14_CFG
-*/
-POKE32(0xfe213b38, 0x0000050b)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV15_CFG
-*/
-POKE32(0xfe213b3c, 0x00000307)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV16_CFG
-*/
-POKE32(0xfe213b40, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_DIV17_CFG
-*/
-POKE32(0xfe213b44, 0x00000103)
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000002)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x00184a05) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x00182803)
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000002) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80002803)
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0xa6aa55aa)
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x0000000a)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x00001d28)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000016a0)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a0)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213a14) (used target peek value 0x00010100) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b0c) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b28) (used target peek value 0x00000307) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
-/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000006) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x00000002)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x081b06a1)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG15
-*/
-/* PEEK(0xfe00113c) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG15
-*/
-POKE32(0xfe00113c, 0x081b0001)
-DELAY(200)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000002) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x00000006)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000787f)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG16
-*/
-POKE32(0xfe001140, 0xa000787f)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x000f000c)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG39
-*/
-POKE32(0xfe00119c, 0x000f0014)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x0042000a)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG17
-*/
-POKE32(0xfe001144, 0x0042000a)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG18
-*/
-POKE32(0xfe001148, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x0800239e)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG37
-*/
-POKE32(0xfe001194, 0x0800039e)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x0000d068)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG44
-*/
-POKE32(0xfe0011b0, 0x0000d068)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG45
-*/
-POKE32(0xfe0011b4, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG53
-*/
-POKE32(0xfe0011d4, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG54
-*/
-POKE32(0xfe0011d8, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfe700860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfe700800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfe700810, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfe700820, 0x00000012)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfe700830, 0x00000014)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfe700840, 0x0000001c)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfe700100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfe700108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfe700110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfe700118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
-*/
-POKE32(0xfe700140, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
-*/
-POKE32(0xfe700148, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
-*/
-POKE32(0xfe700150, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
-*/
-POKE32(0xfe700158, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfe700180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfe700188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfe700190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfe700198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
-*/
-POKE32(0xfe7001c0, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
-*/
-POKE32(0xfe7001c8, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
-*/
-POKE32(0xfe7001d0, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
-*/
-POKE32(0xfe7001d8, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfe700200, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfe700208, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfe700210, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfe700218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfe700028, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30013b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfe90100c, 0xffff0500)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfe901018, 0x4d2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfe90101c, 0x00222ed6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfe901030, 0x14001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfe901038, 0x14001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30033b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30033b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30031b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfe901028, 0x00000000)
-POKE32(0xac000000, 0x00000000)
-POKE32(0xac000000, 0xaaaaaaaa)
-/* PEEK(0xac000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xac001000, 0x00000000)
-POKE32(0xac001000, 0x55555555)
-/* PEEK(0xac001000) (used target peek value 0x55555555) */
-POKE32(0xac002000, 0x00000000)
-POKE32(0xac002000, 0x12345678)
-/* PEEK(0xac002000) (used target peek value 0x12345678) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe902008, 0x0b30013b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfe90200c, 0xffff0500)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfe902018, 0x4d2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfe90201c, 0x00222ed6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfe902030, 0x1c001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfe902038, 0x1c001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe902048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe902048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe902048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe902048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe902048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe902008) (used target peek value 0x0b30013b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe902008, 0x0b30033b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe902008) (used target peek value 0x0b30033b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe902008, 0x0b30031b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe902010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfe902028, 0x00000000)
-POKE32(0xb4000000, 0x00000000)
-POKE32(0xb4000000, 0xaaaaaaaa)
-/* PEEK(0xb4000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xb4001000, 0x00000000)
-POKE32(0xb4001000, 0x55555555)
-/* PEEK(0xb4001000) (used target peek value 0x55555555) */
-POKE32(0xb4002000, 0x00000000)
-POKE32(0xb4002000, 0x12345678)
-/* PEEK(0xb4002000) (used target peek value 0x12345678) */
-POKE32(0xfe2410fc, 0x00000001)
-POKE32(0xfe20a0ec, 0x00000002)
-POKE32(0xfe20a0f0, 0x00000005)
-POKE32(0xfe20a0f4, 0x00000003)
-POKE32(0xfe20a0f8, 0x00000003)
-POKE32(0xfe20a1ec, 0x00000002)
-POKE32(0xfe20a1f0, 0x00000005)
-POKE32(0xfe20a1f4, 0x00000003)
-POKE32(0xfe20a1f8, 0x00000003)
-POKE32(0xfe20a2ec, 0x00000002)
-POKE32(0xfe20a2f0, 0x00000005)
-POKE32(0xfe20a2f4, 0x00000003)
-POKE32(0xfe20a2f8, 0x00000003)
-POKE32(0xfe20a3ec, 0x00000002)
-POKE32(0xfe20a3f0, 0x00000005)
-POKE32(0xfe20a3f4, 0x00000003)
-POKE32(0xfe20a3f8, 0x00000003)
-POKE32(0xfe20aefc, 0x00000005)
-POKE32(0xfe540034, 0x00000003)
-POKE32(0xfe540038, 0x00000000)
-POKE32(0xfe540110, 0x00010303)
-POKE32(0xfe540114, 0x00000000)
-POKE32(0xfe20bb04, 0x00000005)
-POKE32(0xfe20bb08, 0x00000003)
-POKE32(0xfe20bb0c, 0x00000000)
-POKE32(0xfe20bb10, 0x00000002)
-POKE32(0xfe20bb24, 0x00000005)
-POKE32(0xfe20bb28, 0x00000003)
-POKE32(0xfe20bb2c, 0x00000000)
-POKE32(0xfe20bb30, 0x00000002)
-POKE32(0xfe20bb44, 0x00000005)
-POKE32(0xfe20bb48, 0x00000003)
-POKE32(0xfe20bb4c, 0x00000000)
-POKE32(0xfe20bb50, 0x00000002)
-POKE32(0xfe20bb84, 0x00000005)
-POKE32(0xfe20bb88, 0x00000003)
-POKE32(0xfe20bb8c, 0x00000000)
-POKE32(0xfe20bb90, 0x00000002)
-POKE32(0xfe231010, 0x00000008)
-POKE32(0xfe231080, 0x00000221)
-POKE32(0xfd101024, 0x0003c000)
-POKE32(0xfd101824, 0x0003c000)
-POKE32(0xfd104d24, 0x0003c000)
-POKE32(0xfd102024, 0x0003c000)
-POKE32(0xfd103024, 0x0003c000)
-/* PEEK(0xfe001180) (used target peek value 0x00000015) */
-POKE32(0xfe001180, 0x00000015)
-POKE32(0xfe1fff04, 0x00254608)
-/* PEEK(0xfe001180) (used target peek value 0x00000015) */
-POKE32(0xfe001180, 0x00000015)
-POKE32(0xfe209000, 0x00000013)
-POKE32(0xfe209004, 0x00000003)
-POKE32(0xfe209008, 0x00000000)
-/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
-POKE32(0xfe00111c, 0x080b1000)
-POKE32(0xfd117000, 0x0025c608)
-POKE32(0xfd111000, 0x00201004)
-POKE32(0xfd11f000, 0x0025c608)
-POKE32(0xfd119000, 0x00201004)
-/* PEEK(0xfe001180) (used target peek value 0x00000015) */
-POKE32(0xfe001180, 0x00000011)
-POKE32(0xfe401744, 0x0025c005)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000000)
-POKE32(0xfe000010, 0x0000c0de)
-POKE32(0xfe0000b8, 0x00000000)
-POKE32(0xfe000010, 0x0000c1a0)
-/* PEEK(0xfe210000) (used target peek value 0x00000000) */
-POKE32(0xfe210000, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000000) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00000001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x00008001)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00008001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00008001) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x00008011)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00008011) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x0000a011)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x0000a091)
-DELAY(360000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x0000a091) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x0000a891)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x0000a891) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x0000a811)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x0000a811) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x0000a011)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x00008011)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-/* PEEK(0xfe001120) (used target peek value 0x00008011) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG08
-*/
-POKE32(0xfe001120, 0x00008013)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x10000a8c) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x18000a8c)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG28
-*/
-POKE32(0xfe001170, 0xfe604001)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcd)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcc)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x18000a8c) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x18000a8c)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x3f800000)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG26
-*/
-POKE32(0xfe001168, 0xfe804001)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd1)
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
-
-
-/*
-stx7141_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd0)
diff --git a/board/mb628/nand.c b/board/mb628/nand.c
deleted file mode 100644
index ac6dd48..0000000
--- a/board/mb628/nand.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-
-#if defined(CONFIG_CMD_NAND)
-
-#include <nand.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-#include <asm/stx7141reg.h>
-
-
-/*
- * hardware specific access to control-lines
- *	CL -> Emi_Addr(17)
- *	AL -> Emi_Addr(18)
- *	nCE is handled by EMI (not s/w controlable)
- */
-static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
-{
-	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
-
-	switch(cmd) {
-
-	case NAND_CTL_SETCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
-		break;
-
-	case NAND_CTL_CLRCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
-		break;
-
-	case NAND_CTL_SETALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
-		break;
-
-	case NAND_CTL_CLRALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
-		break;
-	}
-}
-
-
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific (per include/linux/mtd/nand.h):
- * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
- * - hwcontrol: hardwarespecific function for accesing control-lines
- * - dev_ready: hardwarespecific function for  accesing device ready/busy line
- * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
- *   only be provided if a hardware ECC is available
- * - eccmode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- * Members with a "?" were not set in the merged testing-NAND branch,
- * so they are not set here either.
- */
-extern int board_nand_init(struct nand_chip *nand)
-{
-	nand->hwcontrol = mb618_hwcontrol;
-	nand->eccmode = NAND_ECC_SOFT;
-	nand->chip_delay = 25;
-	nand->options = NAND_NO_AUTOINCR;
-	return 0;
-}
-#endif	/* CONFIG_CMD_NAND */
-
diff --git a/board/mb671/Makefile b/board/mb671/Makefile
deleted file mode 100644
index 70041dd..0000000
--- a/board/mb671/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb671/config.mk b/board/mb671/config.mk
deleted file mode 100644
index 9870753..0000000
--- a/board/mb671/config.mk
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007-2008 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB671 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x97F00000	29-bit mode (Traditional Mode)
-#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 255MB in P1 (cachable)
-TEXT_BASE = 0x97F00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
deleted file mode 100644
index 1099bc9..0000000
--- a/board/mb671/init-mb671.S
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "asm/stx7200reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:mb671:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb671" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "mb671.romgen"
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
-	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb671/mb671.c b/board/mb671/mb671.c
deleted file mode 100644
index 073fe75..0000000
--- a/board/mb671/mb671.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * (C) Copyright 2007-2009 STMicroelectronics.
- *
- * Stuart Menefy <stuart.menefy@st.com>
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7200reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-#ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
-#else
-#define EPLD_BASE		0xa5000000
-#endif	/* CONFIG_SH_SE_MODE */
-
-#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
-
-extern void flashWriteEnable(void)
-{
-	/*  Enable vpp for writing to flash */
-	*EPLD_FlashCtrlAddr = 3;
-}
-
-extern void flashWriteDisable(void)
-{
-	/*  Disable vpp for writing to flash */
-	*EPLD_FlashCtrlAddr = 2;
-}
-
-#define PIO_BASE  0xfd020000
-
-static void configPIO(void)
-{
-	/*  Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
-}
-
-extern int board_init(void)
-{
-	unsigned long sysconf;
-
-	/* Serial port set up */
-	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG40;
-	sysconf &= ~(1<<16);
-	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
-
-	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<25);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* No idea, more routing: conf_pad_pio[0] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<24);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<2);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_pio[4] = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<28);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~(1<<3);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* conf_pad_clkobs = 1 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf |= (1<<14);
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* I2C and USB related routing */
-	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
-	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
-	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG07;
-	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
-	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Enable SOFT_JTAG mode.
-	 * Taken from OS21, but is this correct?
-	 */
-	sysconf = *STX7200_SYSCONF_SYS_CFG33;
-	sysconf |= (1<<6);
-	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
-	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
-
-	configPIO();
-
-	return 0;
-}
-
-
-extern int checkboard (void)
-{
-	printf ("\n\nBoard: STx7200-Reference (MB671)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-#ifdef CONFIG_DRIVER_NETSTMAC
-#if defined(CONFIG_STMAC_MAC0)
-	/* On-board PHY on MII0 in RMII mode, using MII_CLK */
-	stx7200_configure_ethernet (0, 1, 0, 0);
-#elif defined(CONFIG_STMAC_MAC1)
-	/* External PHY on MII1 in MII mode, using its own clock */
-	stx7200_configure_ethernet (1, 0, 1, 1);
-#endif
-#endif	/* CONFIG_DRIVER_NETSTMAC */
-
-#if defined(CONFIG_SH_STM_SATA)
-	stx7200_configure_sata ();
-#endif	/* CONFIG_SH_STM_SATA */
-
-	return 0;
-}
diff --git a/board/mb671/mb671.romgen b/board/mb671/mb671.romgen
deleted file mode 100644
index 17b91e0..0000000
--- a/board/mb671/mb671.romgen
+++ /dev/null
@@ -1,1572 +0,0 @@
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
-/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80101400) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x80101400)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000001)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x00181400) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x00180f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-POKE32(0xfd700000, 0x80000f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x80100a00)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000002)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x00180f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-POKE32(0xfd700004, 0x80000f01)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x80102803)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000004)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x00182803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x00182803)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
-*/
-POKE32(0xfd70001c, 0x00000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-POKE32(0xfd700008, 0x80002803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x80102803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-POKE32(0xfd701058, 0x0000fff8)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x00182803)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
-*/
-POKE32(0xfd701058, 0x00007ff8)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-POKE32(0xfd70103c, 0x80002803)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x00001d28)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x000016a0)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x000016a0) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x000006a0)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-/* PEEK(0xfd704014) (used target peek value 0x1f10e795) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA01
-*/
-/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
-/* PEEK(0xa5000000) (used target peek value 0x00110011) */
-/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
-*/
-/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
-*/
-/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
-*/
-/* PEEK(0xfd700008) (used target peek value 0x80002803) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
-*/
-/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
-*/
-/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
-*/
-/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
-*/
-/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
-*/
-/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
-*/
-/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-POKE32(0xfd7041e8, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG11
-*/
-POKE32(0xfd70412c, 0x080006a1)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG15
-*/
-/* PEEK(0xfd70413c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG15
-*/
-POKE32(0xfd70413c, 0x08000001)
-DELAY(200)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG58
-*/
-POKE32(0xfd7041e8, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-/* PEEK(0xfd704014) (used target peek value 0x1f13ef95) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA03
-*/
-WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA05
-*/
-/* PEEK(0xfd70401c) (used target peek value 0x1f1bd47a) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_STA05
-*/
-WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG12
-*/
-POKE32(0xfd704130, 0xa200780f)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG16
-*/
-POKE32(0xfd704140, 0xa200780f)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG38
-*/
-POKE32(0xfd704198, 0x000ffd08)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG39
-*/
-POKE32(0xfd70419c, 0x000ffd18)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG13
-*/
-POKE32(0xfd704134, 0x00000002)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG14
-*/
-POKE32(0xfd704138, 0x00000002)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG17
-*/
-POKE32(0xfd704144, 0x00000002)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG18
-*/
-POKE32(0xfd704148, 0x00000002)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG55
-*/
-POKE32(0xfd7041dc, 0x03fc2380)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG56
-*/
-POKE32(0xfd7041e0, 0x03fc2380)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG42
-*/
-POKE32(0xfd7041a8, 0x07b7dbed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG43
-*/
-POKE32(0xfd7041ac, 0x000001ed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG44
-*/
-POKE32(0xfd7041b0, 0x07b7dbed)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG45
-*/
-POKE32(0xfd7041b4, 0x000001ed)
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfdf00860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfdf00800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfdf00810, 0x00000008)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfdf00820, 0x0000000c)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfdf00830, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfdf00840, 0x00000014)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfdf00100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfdf00108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfdf00110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfdf00118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfdf00180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfdf00188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfdf00190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfdf00198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfdf00200, 0x042086f1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfdf00208, 0x8a002200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfdf00210, 0x8a004200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfdf00218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfdf00028, 0x00000050)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd18008, 0x07f6015b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfdd1800c, 0x000000b0)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfdd18018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfdd1801c, 0x002202d6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfdd18030, 0x18001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfdd18038, 0x18001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd18048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd18008, 0x07f6035b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd18010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfdd18028, 0x00000000)
-POKE32(0xa8000000, 0x00000000)
-POKE32(0xa8000000, 0xaaaaaaaa)
-/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xa8001000, 0x00000000)
-POKE32(0xa8001000, 0x55555555)
-/* PEEK(0xa8001000) (used target peek value 0x55555555) */
-POKE32(0xa8002000, 0x00000000)
-POKE32(0xa8002000, 0x12345678)
-/* PEEK(0xa8002000) (used target peek value 0x12345678) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd19008, 0x07f6015b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfdd1900c, 0x000000b0)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfdd19018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfdd1901c, 0x002202d6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfdd19030, 0x1c001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfdd19038, 0x1c001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfdd19048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfdd19008, 0x07f6035b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfdd19010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfdd19028, 0x00000000)
-POKE32(0xb8000000, 0x00000000)
-POKE32(0xb8000000, 0xaaaaaaaa)
-/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
-POKE32(0xb8001000, 0x00000000)
-POKE32(0xb8001000, 0x55555555)
-/* PEEK(0xb8001000) (used target peek value 0x55555555) */
-POKE32(0xb8002000, 0x00000000)
-POKE32(0xb8002000, 0x12345678)
-/* PEEK(0xb8002000) (used target peek value 0x12345678) */
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-/* PEEK(0xfd704114) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-POKE32(0xfd704114, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-POKE32(0xfd704124, 0x08000a8c)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG28
-*/
-POKE32(0xfd704170, 0x00004001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-POKE32(0xfd704174, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-/* PEEK(0xfd704174) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG29
-*/
-POKE32(0xfd704174, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-/* PEEK(0xfd704114) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG05
-*/
-POKE32(0xfd704114, 0x00000000)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG09
-*/
-POKE32(0xfd704124, 0x08000a8c)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG26
-*/
-POKE32(0xfd704168, 0x00004001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-POKE32(0xfd70416c, 0x00000001)
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
-
-
-/*
-sti7200_sysconf_regs.SYSCONF_SYS_CFG27
-*/
-POKE32(0xfd70416c, 0x00000000)
diff --git a/board/mb680/Makefile b/board/mb680/Makefile
deleted file mode 100644
index 219443a..0000000
--- a/board/mb680/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o nand.o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb680/config.mk b/board/mb680/config.mk
deleted file mode 100644
index e79b8e0..0000000
--- a/board/mb680/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2008 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB680 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x9BF00000	29-bit mode (Traditional Mode)
-#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 255MB in P1 (cachable)
-TEXT_BASE = 0x9BF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb680/init-mb680.S b/board/mb680/init-mb680.S
deleted file mode 100644
index 28af5b1..0000000
--- a/board/mb680/init-mb680.S
+++ /dev/null
@@ -1,81 +0,0 @@
-#include "asm/stx7105reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:mb680:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb680" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#if 1
-#include "mb680-stx7105c2.romgen"	/* for STx7105 cut 2.x */
-#else
-#include "mb680-stx7105c1.romgen"	/* for STx7105 cut 1.x */
-#endif
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	/* Change LMI upper bound addresses
-	 # Upper LMI addr=0x40000000 + 256MiB=0x50000000
-	 */
-	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
-	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb680/mb680-stx7105c1.romgen b/board/mb680/mb680-stx7105c1.romgen
deleted file mode 100644
index e93eb56..0000000
--- a/board/mb680/mb680-stx7105c1.romgen
+++ /dev/null
@@ -1,1653 +0,0 @@
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000004)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
-POKE32(0xfe000010, 0x0000c0de)
-POKE32(0xfe0000b8, 0x00000001)
-POKE32(0xfe000010, 0x0000c1a0)
-/* PEEK(0xfe210000) (used target peek value 0x00000000) */
-POKE32(0xfe210000, 0x00800000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000005)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-/* PEEK(0xfe213020) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80101e02)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x00180f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80000f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80102803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
-*/
-POKE32(0xfe213b00, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
-*/
-POKE32(0xfe213b04, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
-*/
-POKE32(0xfe213b08, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
-*/
-POKE32(0xfe213b0c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
-*/
-POKE32(0xfe213a10, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
-*/
-POKE32(0xfe213b14, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
-*/
-POKE32(0xfe213a18, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
-*/
-POKE32(0xfe213a1c, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
-*/
-POKE32(0xfe213b20, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
-*/
-POKE32(0xfe213b24, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
-*/
-POKE32(0xfe213b28, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
-*/
-POKE32(0xfe213b2c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
-*/
-POKE32(0xfe213b30, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
-*/
-POKE32(0xfe213a34, 0x00000811)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
-*/
-POKE32(0xfe213b38, 0x0000050b)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
-*/
-POKE32(0xfe213b3c, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
-*/
-POKE32(0xfe213b40, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
-*/
-POKE32(0xfe213b44, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000002)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x00182803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x00182803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000002) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80002803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0xa6aa59aa)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x0000000a)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x00001d28)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000016a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1f032c9c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b30) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000126) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x00000122)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x080246a1)
-DELAY(200)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000122) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x00000126)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1f13ac9c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000787f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x002f000c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00400002)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000002)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc23dc)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x07afd7eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x00b001eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x01eb01eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x01eb01eb)
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfe700860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfe700800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfe700810, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfe700820, 0x00000012)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfe700830, 0x00000014)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfe700840, 0x0000001c)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfe700100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfe700108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfe700110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfe700118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
-*/
-POKE32(0xfe700140, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
-*/
-POKE32(0xfe700148, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
-*/
-POKE32(0xfe700150, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
-*/
-POKE32(0xfe700158, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfe700180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfe700188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfe700190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfe700198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
-*/
-POKE32(0xfe7001c0, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
-*/
-POKE32(0xfe7001c8, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
-*/
-POKE32(0xfe7001d0, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
-*/
-POKE32(0xfe7001d8, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfe700200, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfe700208, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfe700210, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfe700218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfe700028, 0x00000010)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30017b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfe90100c, 0x000000b0)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfe901018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfe90101c, 0x00222ed6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfe901030, 0x1c001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfe901038, 0x1c001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfe901028, 0x00000000)
-POKE32(0xfe20d200, 0x00000005)
-POKE32(0xfe20d204, 0x00000004)
-POKE32(0xfe20d208, 0x00000003)
-POKE32(0xfe20d20c, 0x00000002)
-POKE32(0xfe20d210, 0x00000001)
-POKE32(0xfe20d214, 0x00000001)
-POKE32(0xfe20d218, 0x00000001)
-POKE32(0xfe20d21c, 0x00000001)
-POKE32(0xfe20d220, 0x00000001)
-POKE32(0xfe2410fc, 0x00000005)
-POKE32(0xfe20a0ec, 0x00000002)
-POKE32(0xfe20a0f0, 0x00000005)
-POKE32(0xfe20a0f4, 0x00000003)
-POKE32(0xfe20a0f8, 0x00000003)
-POKE32(0xfe20a1ec, 0x00000002)
-POKE32(0xfe20a1f0, 0x00000005)
-POKE32(0xfe20a1f4, 0x00000003)
-POKE32(0xfe20a1f8, 0x00000003)
-POKE32(0xfe20a1fc, 0x00000000)
-POKE32(0xfe20a2ec, 0x00000002)
-POKE32(0xfe20a2f0, 0x00000005)
-POKE32(0xfe20a2f4, 0x00000003)
-POKE32(0xfe20a2f8, 0x00000003)
-POKE32(0xfe20a2fc, 0x00000000)
-POKE32(0xfe20a3ec, 0x00000002)
-POKE32(0xfe20a3f0, 0x00000005)
-POKE32(0xfe20a3f4, 0x00000003)
-POKE32(0xfe20a3f8, 0x00000003)
-POKE32(0xfe20a3fc, 0x00000000)
-POKE32(0xfe20aefc, 0x00000005)
-POKE32(0xfe540034, 0x00000003)
-POKE32(0xfe540038, 0x00000000)
-POKE32(0xfe540110, 0x00010303)
-POKE32(0xfe540114, 0x00000000)
-POKE32(0xfe540030, 0x00000005)
-POKE32(0xfe54010c, 0x00000005)
-POKE32(0xfe540600, 0x00000006)
-POKE32(0xfe540604, 0x00000005)
-POKE32(0xfe540608, 0x00000004)
-POKE32(0xfe54060c, 0x00000003)
-POKE32(0xfe540610, 0x00000002)
-POKE32(0xfe540614, 0x00000001)
-POKE32(0xfe540618, 0x00000000)
-POKE32(0xfe540680, 0x00000001)
-POKE32(0xfe540684, 0x00000000)
-POKE32(0xfe20bb04, 0x00000005)
-POKE32(0xfe20bb08, 0x00000003)
-POKE32(0xfe20bb10, 0x00000002)
-POKE32(0xfe20bb24, 0x00000005)
-POKE32(0xfe20bb28, 0x00000003)
-POKE32(0xfe20bb2c, 0x00000000)
-POKE32(0xfe20bb30, 0x00000002)
-POKE32(0xfe20bb44, 0x00000005)
-POKE32(0xfe20bb48, 0x00000003)
-POKE32(0xfe20bb4c, 0x00000000)
-POKE32(0xfe20bb50, 0x00000002)
-POKE32(0xfe20bb84, 0x00000005)
-POKE32(0xfe20bb88, 0x00000003)
-POKE32(0xfe20bb8c, 0x00000000)
-POKE32(0xfe20bb90, 0x00000002)
-POKE32(0xfe20a0fc, 0x00000000)
-POKE32(0xfe20bb0c, 0x00000000)
-POKE32(0xfe231010, 0x00000008)
-POKE32(0xfe231080, 0x00000221)
-POKE32(0xfe261010, 0x00000008)
-POKE32(0xfe261080, 0x00000221)
-POKE32(0xfd101024, 0x0003c000)
-POKE32(0xfd101824, 0x0003c000)
-POKE32(0xfd104d24, 0x0003c000)
-POKE32(0xfd102024, 0x0003c000)
-/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
-POKE32(0xfe001180, 0x00000b05)
-POKE32(0xfe1fff04, 0x00254608)
-POKE32(0xfeafff04, 0x00254608)
-/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
-POKE32(0xfe00111c, 0x08091000)
-POKE32(0xfd117000, 0x0025c608)
-POKE32(0xfd111000, 0x00201004)
-/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
-POKE32(0xfe001180, 0x00000b01)
-POKE32(0xfe401744, 0x0025c005)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x00000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x00000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG26
-*/
-POKE32(0xfe001168, 0xfe804001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd1)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x00000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x00000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG28
-*/
-POKE32(0xfe001170, 0xfe604001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcd)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680-stx7105c2.romgen b/board/mb680/mb680-stx7105c2.romgen
deleted file mode 100644
index fc88679..0000000
--- a/board/mb680/mb680-stx7105c2.romgen
+++ /dev/null
@@ -1,1665 +0,0 @@
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000004)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000126) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a6)
-POKE32(0xfe000010, 0x0000c0de)
-POKE32(0xfe0000b8, 0x00000001)
-POKE32(0xfe000010, 0x0000c1a0)
-/* PEEK(0xfe210000) (used target peek value 0x00000000) */
-POKE32(0xfe210000, 0x00800000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000005)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-/* PEEK(0xfe213020) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80101e02)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x00180f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80000f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80102803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000002)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x00182803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x00182803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000002) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80002803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
-*/
-POKE32(0xfe213b00, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
-*/
-POKE32(0xfe213b04, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
-*/
-POKE32(0xfe213b08, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
-*/
-POKE32(0xfe213b0c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
-*/
-POKE32(0xfe213a10, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
-*/
-POKE32(0xfe213b14, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
-*/
-POKE32(0xfe213a18, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
-*/
-POKE32(0xfe213a1c, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
-*/
-POKE32(0xfe213b20, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
-*/
-POKE32(0xfe213b24, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
-*/
-POKE32(0xfe213b28, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
-*/
-POKE32(0xfe213b2c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
-*/
-POKE32(0xfe213b30, 0x00000102)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
-*/
-POKE32(0xfe213a34, 0x00000811)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
-*/
-POKE32(0xfe213b38, 0x0000050b)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
-*/
-POKE32(0xfe213b3c, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
-*/
-POKE32(0xfe213b40, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
-*/
-POKE32(0xfe213b44, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0xa6aa59aa)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x0000000a)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x00001d28)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000016a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1e020380) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a2)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x080246a1)
-DELAY(200)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a6)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1e161fca) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000787f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x002f000c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00400002)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000002)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc23dc)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x07afd7eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x00b001eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x01eb01eb)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x01eb01eb)
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfe700860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfe700800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfe700810, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfe700820, 0x00000012)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfe700830, 0x00000014)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfe700840, 0x0000001c)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfe700100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfe700108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfe700110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfe700118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
-*/
-POKE32(0xfe700140, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
-*/
-POKE32(0xfe700148, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
-*/
-POKE32(0xfe700150, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
-*/
-POKE32(0xfe700158, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfe700180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfe700188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfe700190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfe700198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
-*/
-POKE32(0xfe7001c0, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
-*/
-POKE32(0xfe7001c8, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
-*/
-POKE32(0xfe7001d0, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
-*/
-POKE32(0xfe7001d8, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfe700200, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfe700208, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfe700210, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfe700218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfe700028, 0x00000010)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30017b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfe90100c, 0x000000b0)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfe901018, 0xcd2db41b)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfe90101c, 0x00222ed6)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfe901030, 0x1c001a20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfe901038, 0x1c001a20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000b53)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00000a53)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfe901028, 0x00000000)
-POKE32(0xfe20d200, 0x00000005)
-POKE32(0xfe20d204, 0x00000004)
-POKE32(0xfe20d208, 0x00000003)
-POKE32(0xfe20d20c, 0x00000002)
-POKE32(0xfe20d210, 0x00000001)
-POKE32(0xfe20d214, 0x00000001)
-POKE32(0xfe20d218, 0x00000001)
-POKE32(0xfe20d21c, 0x00000001)
-POKE32(0xfe20d220, 0x00000001)
-POKE32(0xfe2410fc, 0x00000005)
-POKE32(0xfe20a0ec, 0x00000002)
-POKE32(0xfe20a0f0, 0x00000005)
-POKE32(0xfe20a0f4, 0x00000003)
-POKE32(0xfe20a0f8, 0x00000003)
-POKE32(0xfe20a1ec, 0x00000002)
-POKE32(0xfe20a1f0, 0x00000005)
-POKE32(0xfe20a1f4, 0x00000003)
-POKE32(0xfe20a1f8, 0x00000003)
-POKE32(0xfe20a1fc, 0x00000000)
-POKE32(0xfe20a2ec, 0x00000002)
-POKE32(0xfe20a2f0, 0x00000005)
-POKE32(0xfe20a2f4, 0x00000003)
-POKE32(0xfe20a2f8, 0x00000003)
-POKE32(0xfe20a2fc, 0x00000000)
-POKE32(0xfe20a3ec, 0x00000002)
-POKE32(0xfe20a3f0, 0x00000005)
-POKE32(0xfe20a3f4, 0x00000003)
-POKE32(0xfe20a3f8, 0x00000003)
-POKE32(0xfe20a3fc, 0x00000000)
-POKE32(0xfe20aefc, 0x00000005)
-POKE32(0xfe540034, 0x00000003)
-POKE32(0xfe540038, 0x00000000)
-POKE32(0xfe540110, 0x00010303)
-POKE32(0xfe540114, 0x00000000)
-POKE32(0xfe540030, 0x00000005)
-POKE32(0xfe54010c, 0x00000005)
-POKE32(0xfe540600, 0x00000006)
-POKE32(0xfe540604, 0x00000005)
-POKE32(0xfe540608, 0x00000004)
-POKE32(0xfe54060c, 0x00000003)
-POKE32(0xfe540610, 0x00000002)
-POKE32(0xfe540614, 0x00000001)
-POKE32(0xfe540618, 0x00000000)
-POKE32(0xfe540680, 0x00000001)
-POKE32(0xfe540684, 0x00000000)
-POKE32(0xfe20bb04, 0x00000005)
-POKE32(0xfe20bb08, 0x00000003)
-POKE32(0xfe20bb10, 0x00000002)
-POKE32(0xfe20bb24, 0x00000005)
-POKE32(0xfe20bb28, 0x00000003)
-POKE32(0xfe20bb2c, 0x00000000)
-POKE32(0xfe20bb30, 0x00000002)
-POKE32(0xfe20bb44, 0x00000005)
-POKE32(0xfe20bb48, 0x00000003)
-POKE32(0xfe20bb4c, 0x00000000)
-POKE32(0xfe20bb50, 0x00000002)
-POKE32(0xfe20bb84, 0x00000005)
-POKE32(0xfe20bb88, 0x00000003)
-POKE32(0xfe20bb8c, 0x00000000)
-POKE32(0xfe20bb90, 0x00000002)
-POKE32(0xfe20a0fc, 0x00000000)
-POKE32(0xfe20bb0c, 0x00000000)
-POKE32(0xfe231010, 0x00000008)
-POKE32(0xfe231080, 0x00000221)
-POKE32(0xfe261010, 0x00000008)
-POKE32(0xfe261080, 0x00000221)
-POKE32(0xfd101024, 0x0003c000)
-POKE32(0xfd101824, 0x0003c000)
-POKE32(0xfd104d24, 0x0003c000)
-POKE32(0xfd102024, 0x0003c000)
-/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
-POKE32(0xfe001180, 0x00000b05)
-POKE32(0xfe1fff04, 0x00254608)
-POKE32(0xfeafff04, 0x00254608)
-/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
-POKE32(0xfe00111c, 0x08091508)
-POKE32(0xfd117000, 0x0025c608)
-POKE32(0xfd111000, 0x00201004)
-/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
-POKE32(0xfe001180, 0x00000b01)
-POKE32(0xfe401744, 0x0025c005)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x04000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x04000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG26
-*/
-POKE32(0xfe001168, 0xfe804001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd1)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x04000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x04000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG28
-*/
-POKE32(0xfe001170, 0xfe604001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcd)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680.c b/board/mb680/mb680.c
deleted file mode 100644
index 4d2da9f..0000000
--- a/board/mb680/mb680.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * (C) Copyright 2008-2009 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7105reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-
-#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
-
-
-/* following are the offsets in the EMI functions EPLD (IC21),
- * in the STB Peripheral board (MB705)*/
-#define EPLD_IDENT		0x00	/* EPLD Identifier Register */
-#define EPLD_TEST		0x02	/* EPLD Test Register */
-#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
-#define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
-
-#ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb7000000	/* Phys 0x07000000 */
-#else
-#define EPLD_BASE		0xa7000000	/* EMI Bank E */
-#endif	/* CONFIG_SH_SE_MODE */
-
-
-static inline void epld_write(unsigned long value, unsigned long offset)
-{
-	/* 16-bit write to EPLD registers */
-	writew(value, EPLD_BASE + offset);
-}
-
-static inline unsigned long epld_read(unsigned long offset)
-{
-	/* 16-bit read from EPLD registers */
-	return readw(EPLD_BASE + offset);
-}
-
-void flashWriteEnable(void)
-{
-	unsigned short epld_reg;
-
-	/* Enable Vpp for writing to flash */
-	epld_reg = epld_read(EPLD_MISC);
-	epld_reg |= 1u << 3;	/* NandFlashWP = MISC[3] = 1 */
-	epld_reg |= 1u << 2;	/* NorFlashVpp = MISC[2] = 1 */
-	epld_write(epld_reg, EPLD_MISC);
-}
-
-void flashWriteDisable(void)
-{
-	unsigned short epld_reg;
-
-	/* Disable Vpp for writing to flash */
-	epld_reg = epld_read(EPLD_MISC);
-	epld_reg &= ~(1u << 3);	/* NandFlashWP = MISC[3] = 0 */
-	epld_reg &= ~(1u << 2);	/* NorFlashVpp = MISC[2] = 0 */
-	epld_write(epld_reg, EPLD_MISC);
-}
-
-static int mb680_init_epld(void)
-{
-	const unsigned short test_value = 0x1234u;
-	unsigned short epld_reg;
-	unsigned short epld_version, board_version;
-
-	/* write (anything) to the test register */
-	epld_write(test_value, EPLD_TEST);
-	/* verify we got back an inverted result */
-	epld_reg = epld_read(EPLD_TEST);
-	if (epld_reg != (test_value ^ 0xffffu)) {
-		printf("Failed EPLD test (offset=%02x, result=%04x)\n",
-			EPLD_TEST, epld_reg);
-		return 1;
-		}
-
-	/* Assume we can trust the version register */
-	epld_reg = epld_read(EPLD_IDENT);
-	board_version = epld_reg >> 4 & 0xfu;
-	epld_version = epld_reg & 0xfu;
-
-	/* display the board revision, and EPLD version */
-	printf("MB705: revision %c, EPLD version %02d\n",
-		board_version + 'A' - 1,
-		epld_version);
-
-	/* return a "success" result */
-	return 0;
-}
-
-#ifdef CONFIG_STMAC_LAN8700
-static void phy_reset(void)
-{
-	/* Reset the SMSC LAN8700 PHY */
-	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
-	STPIO_SET_PIN(PIO_PORT(11), 2, 1);
-	udelay(1);
-	STPIO_SET_PIN(PIO_PORT(5), 5, 0);
-	udelay(100);
-	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
-	udelay(1);
-	STPIO_SET_PIN(PIO_PORT(11), 2, 0);
-}
-#endif	/* CONFIG_STMAC_LAN8700 */
-
-static void configPIO(void)
-{
-	unsigned long sysconf;
-
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
-	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
-
-	/* Select UART2 via PIO4 */
-	sysconf = *STX7105_SYSCONF_SYS_CFG07;
-	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
-	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
-	sysconf &= ~(1ul<<2 | 1ul<<1);
-	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
-
-	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
-	sysconf = *STX7105_SYSCONF_SYS_CFG34;
-	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
-	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
-	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
-	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
-	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
-	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
-	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
-
-	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
-	sysconf = *STX7105_SYSCONF_SYS_CFG35;
-	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
-	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
-	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
-	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
-	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
-	sysconf |=  0x000ful;	/* 1,1,1,1 */
-	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
-
-#ifdef CONFIG_STMAC_LAN8700
-	/* Configure SMSC LAN8700 PHY Reset signals */
-	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_OUT);
-	SET_PIO_PIN(PIO_PORT(11), 2, STPIO_OUT);
-#endif	/* CONFIG_STMAC_LAN8700 */
-}
-
-extern int board_init(void)
-{
-	configPIO();
-
-	/* Reset the PHY */
-#ifdef CONFIG_STMAC_LAN8700
-	phy_reset();
-#endif	/* CONFIG_STMAC_LAN8700 */
-
-#if defined(CONFIG_SH_STM_SATA)
-	stx7105_configure_sata ();
-#endif	/* CONFIG_SH_STM_SATA */
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STx7105-Mboard (MB680)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	/*
-	 * initialize the EPLD.
-	 */
-	mb680_init_epld();
-
-#if 0	/* QQQ - DELETE */
-{
-const unsigned long nand_reg = *ST40_EMI_NAND_VERSION_REG;
-const unsigned long epld_reg = epld_read(EPLD_SWITCH);
-	printf ("*ST40_EMI_NAND_VERSION_REG = %u.%u.%u\n",
-		(nand_reg>>8)&0x0ful,
-		(nand_reg>>4)&0x0ful,
-		(nand_reg>>0)&0x0ful);
-	printf("*EPLD_SWITCH = 0x%08x  -->  boot-from-%s\n",
-		epld_reg,
-		(epld_reg & (1ul<<8)) ? "NAND" : "NOR");
-}
-#endif	/* QQQ - DELETE */
-
-	return 0;
-}
diff --git a/board/mb680/nand.c b/board/mb680/nand.c
deleted file mode 100644
index 7abfbf6..0000000
--- a/board/mb680/nand.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-
-#if defined(CONFIG_CMD_NAND)
-
-#include <nand.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-#include <asm/stx7105reg.h>
-#include <asm/stm-nand.h>
-
-
-/*
- * hardware specific access to control-lines for "bit-banging".
- *	CL -> Emi_Addr(17)
- *	AL -> Emi_Addr(18)
- *	nCE is handled by EMI (not s/w controlable)
- */
-#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
-static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
-{
-	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
-
-	switch(cmd) {
-
-	case NAND_CTL_SETCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
-		break;
-
-	case NAND_CTL_CLRCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
-		break;
-
-	case NAND_CTL_SETALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
-		break;
-
-	case NAND_CTL_CLRALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
-		break;
-	}
-}
-#endif /* CFG_NAND_FLEX_MODE */
-
-
-/*
- * hardware specific access to the Ready/not_Busy signal.
- * Signal is routed through the EMI NAND Controller block.
- */
-#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
-static int mb680_device_ready(struct mtd_info *mtd)
-{
-	/* extract bit 1: status of RBn pin on boot bank */
-	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
-}
-#endif /* CFG_NAND_FLEX_MODE */
-
-
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific (per include/linux/mtd/nand.h):
- * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
- * - hwcontrol: hardwarespecific function for accesing control-lines
- * - dev_ready: hardwarespecific function for  accesing device ready/busy line
- * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
- *   only be provided if a hardware ECC is available
- * - eccmode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- * Members with a "?" were not set in the merged testing-NAND branch,
- * so they are not set here either.
- */
-extern int board_nand_init(struct nand_chip *nand)
-{
-	nand->eccmode       = NAND_ECC_SOFT;
-	nand->options       = NAND_NO_AUTOINCR;
-
-#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
-	nand->select_chip   = stm_flex_select_chip;
-	nand->dev_ready     = stm_flex_device_ready;
-	nand->hwcontrol     = stm_flex_hwcontrol;
-	nand->read_byte     = stm_flex_read_byte;
-	nand->write_byte    = stm_flex_write_byte;
-	nand->read_buf      = stm_flex_read_buf;
-	nand->write_buf     = stm_flex_write_buf;
-#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
-	nand->dev_ready     = mb680_device_ready;
-	nand->hwcontrol     = mb680_hwcontrol;
-#endif /* CFG_NAND_FLEX_MODE */
-
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
-	nand->scan_bbt      = stm_nand_default_bbt;
-#endif
-
-	return 0;
-}
-
-
-#endif	/* CONFIG_CMD_NAND */
-
-
diff --git a/board/mb704/Makefile b/board/mb704/Makefile
deleted file mode 100644
index 70041dd..0000000
--- a/board/mb704/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/mb704/config.mk b/board/mb704/config.mk
deleted file mode 100644
index ca02cd3..0000000
--- a/board/mb704/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2009 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# MB704 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x8FF00000	29-bit mode (Traditional Mode)
-#	0x83F00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 63MB in P1 (cachable)
-TEXT_BASE = 0x8FF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/mb704/init-mb704.S b/board/mb704/init-mb704.S
deleted file mode 100644
index e848acc..0000000
--- a/board/mb704/init-mb704.S
+++ /dev/null
@@ -1,82 +0,0 @@
-#include "asm/stx5197reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "mb704.romgen"
-
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
-	 */
-	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
-
-	/*
-	 * Change LMI upper bound addresses
-	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
-	 */
-	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
-	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/mb704/mb704.c b/board/mb704/mb704.c
deleted file mode 100644
index cf40a9a..0000000
--- a/board/mb704/mb704.c
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * (C) Copyright 2009 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/stx5197reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-
-#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
-
-
-	/* Alternate Function Output Selection accessors */
-#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
-#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
-#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
-#define ALTFOP(reg,port,pin,alt)			\
-	do {						\
-		reg &= ~ALT_MASK((port),(pin), 0x3);	\
-		reg |=  ALT_MASK((port),(pin),(alt));	\
-	} while(0)
-
-
-extern void flashWriteEnable (void)
-{
-	/* Enable Vpp for writing to flash */
-}
-
-extern void flashWriteDisable (void)
-{
-	/* Disable Vpp for writing to flash */
-}
-
-
-#ifdef CONFIG_STM_ASC_SERIAL
-static void configSerial (void)
-{
-	unsigned long sysconf;
-
-#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
-	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
-	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
-	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
-	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
-	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
-	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
-	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
-#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
-	/* Setup PIO of ASC device */
-	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
-	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
-	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
-	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
-	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
-	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
-	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
-	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
-#else
-#error Unknown serial port configuration!
-#endif
-}
-#endif /* CONFIG_STM_ASC_SERIAL */
-
-
-extern int board_init (void)
-{
-#ifdef CONFIG_STM_ASC_SERIAL
-	configSerial ();
-#endif /* CONFIG_STM_ASC_SERIAL */
-
-	return 0;
-}
-
-
-extern int checkboard (void)
-{
-	printf ("\n\nBoard: STx5197-Mboard (MB704)"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	return 0;
-}
diff --git a/board/mb704/mb704.romgen b/board/mb704/mb704.romgen
deleted file mode 100644
index 08fa12f..0000000
--- a/board/mb704/mb704.romgen
+++ /dev/null
@@ -1,781 +0,0 @@
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x000000f0)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x0000000f)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-POKE32(0xfdc00110, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG0
-*/
-POKE32(0xfdc00000, 0x00002303)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00002000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG0
-*/
-POKE32(0xfdc00008, 0x00002803)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG0
-*/
-POKE32(0xfdc00090, 0x0000366c)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG1
-*/
-POKE32(0xfdc00094, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.CPU_CLK_CONFIG2
-*/
-POKE32(0xfdc00098, 0x00000053)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG0
-*/
-POKE32(0xfdc000a0, 0x0000cccc)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG1
-*/
-POKE32(0xfdc000a4, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.LMI_CLK_CONFIG2
-*/
-POKE32(0xfdc000a8, 0x00000075)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG0
-*/
-POKE32(0xfdc000ac, 0x0000366c)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG1
-*/
-POKE32(0xfdc000b0, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.BLLITER_CLK_CONFIG2
-*/
-POKE32(0xfdc000b4, 0x00000053)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
-*/
-POKE32(0xfdc000b8, 0x0000739c)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
-*/
-POKE32(0xfdc000bc, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
-*/
-POKE32(0xfdc000c0, 0x00000014)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
-*/
-POKE32(0xfdc000c4, 0x00000aaa)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
-*/
-POKE32(0xfdc000c8, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
-*/
-POKE32(0xfdc000cc, 0x00000071)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG0
-*/
-POKE32(0xfdc000d0, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG1
-*/
-POKE32(0xfdc000d4, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.AV_CLK_CONFIG2
-*/
-POKE32(0xfdc000d8, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
-*/
-POKE32(0xfdc000dc, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
-*/
-POKE32(0xfdc000e0, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
-*/
-POKE32(0xfdc000e4, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
-*/
-POKE32(0xfdc000e8, 0x00003c78)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
-*/
-POKE32(0xfdc000ec, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
-*/
-POKE32(0xfdc000f0, 0x00000013)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
-*/
-POKE32(0xfdc000f4, 0x00000aaa)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
-*/
-POKE32(0xfdc000f8, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
-*/
-POKE32(0xfdc000fc, 0x00000071)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
-*/
-POKE32(0xfdc00100, 0x0000cccc)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
-*/
-POKE32(0xfdc00104, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
-*/
-POKE32(0xfdc00108, 0x00000075)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG
-*/
-POKE32(0xfdc00180, 0x00000844)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-POKE32(0xfdc00180, 0x00001844)
-
-
-/*
-sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
-*/
-UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-POKE32(0xfdc00004, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-POKE32(0xfdc0000c, 0x00000000)
-DELAY(200)
-DELAY(20)
-
-
-/*
-sti5197_system_services_regs.PLLA_CONFIG1
-*/
-/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
-DELAY(20)
-
-
-/*
-sti5197_system_services_regs.PLLB_CONFIG1
-*/
-/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP0
-*/
-POKE32(0xfdc00014, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP0
-*/
-POKE32(0xfdc00020, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP0
-*/
-POKE32(0xfdc00030, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP0
-*/
-POKE32(0xfdc00040, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP0
-*/
-POKE32(0xfdc00054, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
-*/
-POKE32(0xfdc00060, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP0
-*/
-POKE32(0xfdc00070, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP0
-*/
-POKE32(0xfdc00080, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f08)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f08)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f18)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f18)
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP0
-*/
-POKE32(0xfdc00014, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.SPARE1_CLK_SETUP1
-*/
-POKE32(0xfdc00018, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP0
-*/
-POKE32(0xfdc00020, 0x00000af3)
-
-
-/*
-sti5197_system_services_regs.PCM_CLK_SETUP1
-*/
-POKE32(0xfdc00024, 0x00003c00)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP0
-*/
-POKE32(0xfdc00030, 0x00000b31)
-
-
-/*
-sti5197_system_services_regs.SPDIF_CLK_SETUP1
-*/
-POKE32(0xfdc00034, 0x00004dea)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP0
-*/
-POKE32(0xfdc00040, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.SC_CLK_SETUP1
-*/
-POKE32(0xfdc00044, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP0
-*/
-POKE32(0xfdc00054, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.PIX_CLK_SETUP1
-*/
-POKE32(0xfdc00058, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.DCO_MODE_CFG
-*/
-POKE32(0xfdc00170, 0x00000001)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
-*/
-POKE32(0xfdc00060, 0x00000a39)
-
-
-/*
-sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
-*/
-POKE32(0xfdc00064, 0x00003334)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP0
-*/
-POKE32(0xfdc00070, 0x00000af1)
-
-
-/*
-sti5197_system_services_regs.AUX_CLK_SETUP1
-*/
-POKE32(0xfdc00074, 0x00001c72)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP0
-*/
-POKE32(0xfdc00080, 0x00000ab3)
-
-
-/*
-sti5197_system_services_regs.USB_CLK_SETUP1
-*/
-POKE32(0xfdc00084, 0x00000000)
-
-
-/*
-sti5197_system_services_regs.FSA_SETUP
-*/
-POKE32(0xfdc00010, 0x00000f10)
-
-
-/*
-sti5197_system_services_regs.FSB_SETUP
-*/
-POKE32(0xfdc00050, 0x00000f10)
-DELAY(200)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-POKE32(0xfdc00110, 0x00000002)
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
-
-
-/*
-sti5197_system_services_regs.MODE_CONTROL
-*/
-WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
-
-
-/*
-LMI.LMI_MIM0
-*/
-POKE32(0xfe000008, 0x061c0203)
-
-
-/*
-LMI.LMI_STR
-*/
-POKE32(0xfe000018, 0x3ff27e7a)
-
-
-/*
-LMI.LMI_SDRA0
-*/
-POKE32(0xfe000030, 0x10001a00)
-
-
-/*
-LMI.LMI_SDRA1
-*/
-POKE32(0xfe000038, 0x10001a00)
-DELAY(200)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000003)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000001)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000002)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000400)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000400)
-DELAY(200)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000133)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000133)
-DELAY(200)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000002)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000004)
-
-
-/*
-LMI.LMI_SDMR0
-*/
-POKE32(0xfe000048, 0x00000033)
-
-
-/*
-LMI.LMI_SDMR1
-*/
-POKE32(0xfe000050, 0x00000033)
-
-
-/*
-LMI.LMI_SCR
-*/
-POKE32(0xfe000010, 0x00000000)
-
-
-/*
-LMI.LMI_COC_UPPER
-*/
-POKE32(0xfe00002c, 0x00330000)
-
-
-/*
-LMI.LMI_COC_LOWER
-*/
-POKE32(0xfe000028, 0x0003e000)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
-*/
-/* PEEK(0xfd901014) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
-*/
-POKE32(0xfd901014, 0x00000000)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
-*/
-/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
-*/
-POKE32(0xfd901048, 0x400000c0)
-
-
-/*
-LMI.LMI_MIM1
-*/
-POKE32(0xfe00000c, 0x00000075)
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
-*/
-/* PEEK(0xfd901000) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
-*/
-POKE32(0xfd901000, 0x00800000)
-
-
-/*
-sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
-*/
-POKE32(0xfdc00188, 0x0000002a)
-
-
-/*
-sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
-*/
-/* PEEK(0xfd002008) (used target peek value 0x38472000) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
-*/
-/* PEEK(0xfd901030) (used target peek value 0x00001279) */
-
-
-/*
-sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
-*/
-/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-POKE32(0xfdc00300, 0x00000100)
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
-
-
-/*
-sti5197_system_services_regs.REGISTER_LOCK
-*/
-WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
diff --git a/board/pdk7105/Makefile b/board/pdk7105/Makefile
deleted file mode 100644
index 219443a..0000000
--- a/board/pdk7105/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# (C) Copyright 2007 STMicroelectronics.
-# Stuart Menefy <stuart.menefy@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= lib$(BOARD).a
-
-AOBJS	= init-$(BOARD).o
-
-COBJS	= $(BOARD).o nand.o
-
-OBJS	= $(COBJS) $(AOBJS)
-
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
-
-#########################################################################
-
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
-
-sinclude .depend
-
-#########################################################################
diff --git a/board/pdk7105/config.mk b/board/pdk7105/config.mk
deleted file mode 100644
index 86ff620..0000000
--- a/board/pdk7105/config.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# (C) Copyright 2008 STMicroelectronics.
-# Sean McGoogan <Sean.McGoogan@st.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-#
-# PDK-7105 board:
-#
-#	Valid values for TEXT_BASE are:
-#
-#	0x9BF00000	29-bit mode (Traditional Mode)
-#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
-#
-# Note:	Alternative definitions of TEXT_BASE are put into
-#	'config.tmp' from the top-level 'Makefile'.
-#
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef TEXT_BASE
-# Installs at LMI0 BASE + 255MB in P1 (cachable)
-TEXT_BASE = 0x9BF00000
-endif
-
-PLATFORM_LDFLAGS +=
diff --git a/board/pdk7105/init-pdk7105.S b/board/pdk7105/init-pdk7105.S
deleted file mode 100644
index badb26e..0000000
--- a/board/pdk7105/init-pdk7105.S
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "asm/stx7105reg.h"
-#include "../../cpu/sh/init_ram.S"
-
-/*
- * This is derived from STMicroelectronics gnu toolchain example:
- *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
- */
-
-/*
- * The poke table is a series of long words, in the format
- *
- *	opcode, address, operand, ...
- *
- * An opcode of 0 marks the table end
- */
-
-/*
- * For compatibility with old poke table code, we define some of the
- * new names, to map onto the old names. Ultimately, the old poke table
- * code will be updated to the "new order", and we can just delete
- * the following mappings.
- */
-#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
-#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
-#define POKE32(A, VAL)				POKE_LONG(A, VAL)
-#define OR32(A, VAL)				OR_LONG(A, VAL)
-#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
-#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
-#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
-#define DELAY(VAL)				/* do nothing */
-
-
-	.section .data.init, "a"
-
-	.balign 32
-
-__memory_setup_table:
-
-	/*
-	 * include the appropriate set of "GDB pokes", (usually) generated
-	 * using the "romgen" utility, from a known good target-pack.
-	 *
-	 * This file may be regenerated by connecting your specific board
-	 * to an STMC2 (note: currently it must be version 2) and then
-	 * executing the following command (redirecting the output):
-	 *
-	 * host% romgen --target-connect --show-comment <stmc2>:sdk7105:st40
-	 *
-	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "sdk7105" should
-	 * substituted if you have a custom target-pack connect command.
-	 *
-	 * Note: The connect command used with "romgen", should connect
-	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
-	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
-	 */
-#include "pdk7105.romgen"
-
-#ifdef CONFIG_SH_SE_MODE
-	/*
-	 * Note that we also manually need to move the LMI base addresses to
-	 * their 32-bit SE mode locations as defined in the datasheet and change the
-	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
-	 */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
-	/* Change LMI upper bound addresses
-	 * Upper LMI addr=0x40000000 + 512MiB=0x60000000
-	 */
-	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x60000000)
-	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x60000000)
-#endif	/* CONFIG_SH_SE_MODE */
-
-	END_MARKER
-
-__memory_setup_table_end:
-
-	.end
diff --git a/board/pdk7105/nand.c b/board/pdk7105/nand.c
deleted file mode 100644
index 3c2f513..0000000
--- a/board/pdk7105/nand.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-
-#if defined(CONFIG_CMD_NAND)
-
-#include <nand.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-#include <asm/stx7105reg.h>
-#include <asm/stm-nand.h>
-
-
-/*
- * hardware specific access to control-lines for "bit-banging".
- *	CL -> Emi_Addr(17)
- *	AL -> Emi_Addr(18)
- *	nCE is handled by EMI (not s/w controlable)
- */
-#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
-static void pdk7105_hwcontrol(struct mtd_info *mtdinfo, int cmd)
-{
-	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
-
-	switch(cmd) {
-
-	case NAND_CTL_SETCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
-		break;
-
-	case NAND_CTL_CLRCLE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
-		break;
-
-	case NAND_CTL_SETALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
-		break;
-
-	case NAND_CTL_CLRALE:
-		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
-		break;
-	}
-}
-#endif /* CFG_NAND_FLEX_MODE */
-
-
-/*
- * hardware specific access to the Ready/not_Busy signal.
- * Signal is routed through the EMI NAND Controller block.
- */
-#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
-static int pdk7105_device_ready(struct mtd_info *mtd)
-{
-	/* extract bit 1: status of RBn pin on boot bank */
-	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
-}
-#endif /* CFG_NAND_FLEX_MODE */
-
-
-/*
- * Board-specific NAND initialization. The following members of the
- * argument are board-specific (per include/linux/mtd/nand.h):
- * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
- * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
- * - hwcontrol: hardwarespecific function for accesing control-lines
- * - dev_ready: hardwarespecific function for  accesing device ready/busy line
- * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
- *   only be provided if a hardware ECC is available
- * - eccmode: mode of ecc, see defines
- * - chip_delay: chip dependent delay for transfering data from array to
- *   read regs (tR)
- * - options: various chip options. They can partly be set to inform
- *   nand_scan about special functionality. See the defines for further
- *   explanation
- * Members with a "?" were not set in the merged testing-NAND branch,
- * so they are not set here either.
- */
-extern int board_nand_init(struct nand_chip *nand)
-{
-	nand->eccmode       = NAND_ECC_SOFT;
-	nand->options       = NAND_NO_AUTOINCR;
-
-#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
-	nand->select_chip   = stm_flex_select_chip;
-	nand->dev_ready     = stm_flex_device_ready;
-	nand->hwcontrol     = stm_flex_hwcontrol;
-	nand->read_byte     = stm_flex_read_byte;
-	nand->write_byte    = stm_flex_write_byte;
-	nand->read_buf      = stm_flex_read_buf;
-	nand->write_buf     = stm_flex_write_buf;
-#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
-	nand->dev_ready     = pdk7105_device_ready;
-	nand->hwcontrol     = pdk7105_hwcontrol;
-#endif /* CFG_NAND_FLEX_MODE */
-
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
-	nand->scan_bbt      = stm_nand_default_bbt;
-#endif
-
-	return 0;
-}
-
-
-#endif	/* CONFIG_CMD_NAND */
-
-
diff --git a/board/pdk7105/pdk7105.c b/board/pdk7105/pdk7105.c
deleted file mode 100644
index c489b83..0000000
--- a/board/pdk7105/pdk7105.c
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * (C) Copyright 2008-2009 STMicroelectronics.
- *
- * Sean McGoogan <Sean.McGoogan@st.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <command.h>
-#include <asm/soc.h>
-#include <asm/stx7105reg.h>
-#include <asm/io.h>
-#include <asm/pio.h>
-
-
-void flashWriteEnable(void)
-{
-	/* Enable Vpp for writing to flash */
-	/* FLASH_WP# = PIO6[4] = 1 */
-	STPIO_SET_PIN(PIO_PORT(6), 4, 1);
-}
-
-void flashWriteDisable(void)
-{
-	/* Disable Vpp for writing to flash */
-	/* FLASH_WP# = PIO6[4] = 0 */
-	STPIO_SET_PIN(PIO_PORT(6), 4, 0);
-}
-
-static void configEthernet(void)
-{
-	unsigned long sysconf;
-
-	/* Configure & Reset the Ethernet PHY */
-
-	/* Set the GMAC in MII mode */
-	sysconf = *STX7105_SYSCONF_SYS_CFG07;
-	sysconf &= ~0x060f0000ul;
-	sysconf |=  0x08010000ul;
-	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
-
-	sysconf = *STX7105_SYSCONF_SYS_CFG37;
-	/* PIO7[4] CFG37[12,4]  AltFunction = 1 */
-	/* PIO7[5] CFG37[13,5]  AltFunction = 1 */
-	/* PIO7[6] CFG37[14,6]  AltFunction = 1 */
-	/* PIO7[7] CFG37[15,7]  AltFunction = 1 */
-	sysconf &= ~0xf0f0ul;	/* 3,3,3,3,0,0,0,0 */
-	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
-
-	sysconf = *STX7105_SYSCONF_SYS_CFG46;
-	/* PIO8[0] CFG46[8,0]   AltFunction = 1 */
-	/* PIO8[1] CFG46[9,1]   AltFunction = 1 */
-	/* PIO8[2] CFG46[10,2]  AltFunction = 1 */
-	/* PIO8[3] CFG46[11,3]  AltFunction = 1 */
-	/* PIO8[4] CFG46[12,4]  AltFunction = 1 */
-	/* PIO8[5] CFG46[13,5]  AltFunction = 1 */
-	/* PIO8[6] CFG46[14,6]  AltFunction = 1 */
-	/* PIO8[7] CFG46[15,7]  AltFunction = 1 */
-	sysconf &= ~0xfffful;	/* 3,3,3,3,3,3,3,3 */
-	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
-
-	sysconf = *STX7105_SYSCONF_SYS_CFG47;
-	/* PIO9[0] CFG47[8,0]   AltFunction = 1 */
-	/* PIO9[1] CFG47[9,1]   AltFunction = 1 */
-	/* PIO9[2] CFG47[10,2]  AltFunction = 1 */
-	/* PIO9[3] CFG47[11,3]  AltFunction = 1 */
-	/* PIO9[4] CFG47[12,4]  AltFunction = 1 */
-	/* PIO9[5] CFG47[13,5]  AltFunction = 1 */
-	/* PIO9[6] CFG47[14,6]  AltFunction = 1 */
-	sysconf &= ~0x7f7ful;	/* 0,3,3,3,3,3,3,3 */
-	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
-
-	/* Setup PIO for the Ethernet's MII bus */
-	SET_PIO_PIN(PIO_PORT(7),4,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(7),5,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(7),6,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(7),7,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8),0,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8),1,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8),2,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8),3,STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(8),4,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8),5,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(8),6,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(8),7,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),0,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),1,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),2,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),3,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),4,STPIO_IN);
-	SET_PIO_PIN(PIO_PORT(9),5,STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(9),6,STPIO_IN);
-
-	/* Setup PIO for the PHY's reset */
-	SET_PIO_PIN(PIO_PORT(15), 5, STPIO_OUT);
-
-	/* Finally, toggle the PHY Reset pin ("RST#") */
-	STPIO_SET_PIN(PIO_PORT(15), 5, 0);
-	udelay(100);	/* small delay */
-	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
-}
-
-#if defined(CONFIG_SPI)
-static void configSpi(void)
-{
-#if defined(CONFIG_SOFT_SPI)
-	/* Configure SPI Serial Flash for PIO "bit-banging" */
-
-#if 1
-	/*
-	 * On the PDK-7105 board, the following 4 pairs of PIO
-	 * pins are connected together with a 3K3 resistor.
-	 *
-	 *	SPI_CLK  PIO15[0] <-> PIO2[5] COM_CLK
-	 *	SPI_DOUT PIO15[1] <-> PIO2[6] COM_DOUT
-	 *	SPI_NOCS PIO15[2] <-> PIO2[4] COM_NOTCS
-	 *	SPI_DIN  PIO15[3] <-> PIO2[7] COM_DIN
-	 *
-	 * To minimise drive "contention", we may set
-	 * associated pins on PIO2 to be simple inputs.
-	 */
-	SET_PIO_PIN(PIO_PORT(2),4,STPIO_IN);	/* COM_NOTCS */
-	SET_PIO_PIN(PIO_PORT(2),5,STPIO_IN);	/* COM_CLK */
-	SET_PIO_PIN(PIO_PORT(2),6,STPIO_IN);	/* COM_DOUT */
-	SET_PIO_PIN(PIO_PORT(2),7,STPIO_IN);	/* COM_DIN */
-#endif
-
-	/* SPI is on PIO15:[3:0] */
-	SET_PIO_PIN(PIO_PORT(15),3,STPIO_IN);	/* SPI_DIN */
-	SET_PIO_PIN(PIO_PORT(15),0,STPIO_OUT);	/* SPI_CLK */
-	SET_PIO_PIN(PIO_PORT(15),1,STPIO_OUT);	/* SPI_DOUT */
-	SET_PIO_PIN(PIO_PORT(15),2,STPIO_OUT);	/* SPI_NOCS */
-
-	/* drive outputs with sensible initial values */
-	STPIO_SET_PIN(PIO_PORT(15), 2, 1);	/* deassert SPI_NOCS */
-	STPIO_SET_PIN(PIO_PORT(15), 0, 1);	/* assert SPI_CLK */
-	STPIO_SET_PIN(PIO_PORT(15), 1, 0);	/* deassert SPI_DOUT */
-#endif	/* CONFIG_SOFT_SPI */
-}
-#endif	/* CONFIG_SPI */
-
-static void configPIO(void)
-{
-	unsigned long sysconf;
-
-	/* Setup PIO of ASC device */
-#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
-	SET_PIO_ASC(PIO_PORT(0), 0, 1, 4, 3);  /* UART0 */
-#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
-	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 */
-#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
-	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 */
-#else
-#error Unsure which UART to configure!
-#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
-
-#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
-	/* Route UART0 via PIO0 for TX, RX, CTS & RTS */
-	sysconf = *STX7105_SYSCONF_SYS_CFG19;
-	/* PIO0[0] CFG19[16,8,0]   AltFunction = 4 */
-	/* PIO0[1] CFG19[17,9,1]   AltFunction = 4 */
-	/* PIO0[3] CFG19[19,11,3]  AltFunction = 4 */
-	/* PIO0[4] CFG19[20,12,4]  AltFunction = 4 */
-	sysconf &= ~0x1b1b1bul;	/* 7,7,0,7,7 */
-	sysconf |=  0x001b1bul;	/* 3,3,0,3,3 */
-	*STX7105_SYSCONF_SYS_CFG19 = sysconf;
-#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
-	/* Select UART2 via PIO4 */
-	sysconf = *STX7105_SYSCONF_SYS_CFG07;
-	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
-	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
-	sysconf &= ~(1ul<<2 | 1ul<<1);
-	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
-	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
-	sysconf = *STX7105_SYSCONF_SYS_CFG34;
-	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
-	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
-	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
-	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
-	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
-	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
-	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
-#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
-	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
-	sysconf = *STX7105_SYSCONF_SYS_CFG35;
-	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
-	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
-	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
-	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
-	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
-	sysconf |=  0x000ful;	/* 1,1,1,1 */
-	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
-#else
-#error Unsure which UART to configure!
-#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
-
-	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
-	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
-
-	/* Configure & Reset the Ethernet PHY */
-	configEthernet();
-
-#if defined(CONFIG_SPI)
-	/* Configure for SPI Serial Flash */
-	configSpi();
-#endif	/* CONFIG_SPI */
-}
-
-extern int board_init(void)
-{
-	configPIO();
-
-#if defined(CONFIG_SH_STM_SATA)
-	stx7105_configure_sata ();
-#endif	/* CONFIG_SH_STM_SATA */
-
-	return 0;
-}
-
-int checkboard (void)
-{
-	printf ("\n\nBoard: STx7105-PDK"
-#ifdef CONFIG_SH_SE_MODE
-		"  [32-bit mode]"
-#else
-		"  [29-bit mode]"
-#endif
-		"\n");
-
-	return 0;
-}
diff --git a/board/pdk7105/pdk7105.romgen b/board/pdk7105/pdk7105.romgen
deleted file mode 100644
index 4c79ca4..0000000
--- a/board/pdk7105/pdk7105.romgen
+++ /dev/null
@@ -1,2787 +0,0 @@
-/* sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
- */
-/* Initialization TCK frequency set to 1562500 Hz
- */
-/* Device id  0x1d43e041
- */
-/* tapmux connect(): boot mode single core setup
- */
-/* tapmux setup to bypass to core st40, channel 1
- */
-/* sdk7105 initialization start ...
- */
-/* sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
- */
-/* Chip infos
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-/*   Device ID = 0x1D43E041 ==> STi7105 cut 2
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-/*   Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
- */
-/*                              Boot mode ... : ST40 first
- */
-/*                              Boot port size: 16-bits
- */
-/*                              Boot device . : NOR flash
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000005)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000005)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x00000126) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a6)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
-*/
-WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-/* PEEK(0xfe213020) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
-*/
-WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80101e02)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x00180f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000001) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-POKE32(0xfe213000, 0x80000f01)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80102803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
-*/
-POKE32(0xfe213b00, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
-*/
-POKE32(0xfe213b04, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
-*/
-POKE32(0xfe213b08, 0x00000001)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
-*/
-POKE32(0xfe213b0c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
-*/
-POKE32(0xfe213a10, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
-*/
-POKE32(0xfe213b14, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
-*/
-POKE32(0xfe213a18, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
-*/
-POKE32(0xfe213a1c, 0x00010100)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
-*/
-POKE32(0xfe213b20, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
-*/
-POKE32(0xfe213b24, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
-*/
-POKE32(0xfe213b28, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
-*/
-POKE32(0xfe213b2c, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
-*/
-POKE32(0xfe213b30, 0x00000102)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
-*/
-POKE32(0xfe213a34, 0x00000811)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
-*/
-POKE32(0xfe213b38, 0x0000050b)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
-*/
-POKE32(0xfe213b3c, 0x00000307)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
-*/
-POKE32(0xfe213b40, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
-*/
-POKE32(0xfe213b44, 0x00000103)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000002)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x00182803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x00182803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-/* PEEK(0xfe213010) (used target peek value 0x00000002) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_POWER_CFG
-*/
-POKE32(0xfe213010, 0x00000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80102803) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-POKE32(0xfe213004, 0x80002803)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-POKE32(0xfe213014, 0xa6aa59aa)
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-POKE32(0xfe213024, 0x0000000a)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_DEVICEID0
-*/
-/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x00001d28)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000016a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1f1016a4) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
-/* set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50
- */
-/* Clock frequencies
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-/*   CKGA_PLL0HS     = 900.0 MHz
- */
-/*   CKGA_PLL0LS     = 450.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-/*   CKGA_PLL1       = 800.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
-/*   ST40 ICK        = 450.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
-/*   LX DMU          = 450.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
-/*   LX AUD          = 450.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
-/*   FDMA0           = 400.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
-/*   FDMA1           = 400.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
-/*   STNOC           = 400.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
-/*   IC_BDISP_200    = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
-/*   IC_DISP_200     = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
-/*   IC_TS_200       = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
-/*   IC_COMPO_200    = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
-*/
-/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
-/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
-/*   IC_IF_200       = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
-/*   IC_IF_100       = 100.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
-/*   DISP_PIPE_200   = 200.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
-/*   BLIT_PROC       = 266.7 MHz
- */
-/*   IC_DELTA_200    = 266.7 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
-/*   ETHERNET        = 25.0 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
-/*   PCI             = 66.7 MHz
- */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL0_CFG
-*/
-/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_PLL1_CFG
-*/
-/* PEEK(0xfe213004) (used target peek value 0x80002803) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA1
-*/
-/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
-
-
-/*
-stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
-*/
-/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
-/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
-/*   EMI MASTER      = 100.0 MHz
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-/*   LMI2X           = 800.0 MHz
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a2)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x080006a1)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa000380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200380f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200780f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200780f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200680f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200680f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200680f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200680f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200680f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200684f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200684f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200686f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200686f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200687f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200687f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200687f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200687f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG12
-*/
-POKE32(0xfe001130, 0xa200687f)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00400000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00400000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x0000fe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x0000fe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x0000fe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x0020fe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x0020fe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x002cfe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x002cfe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x002ffe00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-/* PEEK(0xfe001198) (used target peek value 0x002ffe00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG38
-*/
-POKE32(0xfe001198, 0x002ffe0c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG40
-*/
-POKE32(0xfe0011a0, 0x00000005)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x20000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x20000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x28000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x28000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fb80000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x2fb80000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fbbdc00)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x2fbbdc00) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fbbddee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x18000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x18000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x18a00000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x18a00000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x18a001ee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x00002000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x00002000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x00002000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc2000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc2000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc2000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc2000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc2280)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc2280) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc22c0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc22c0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc22c4)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a6)
-DELAY(10)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1e166c50) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_STA3
-*/
-/* PEEK(0xfe001014) (used target peek value 0x1e166450) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-/* PEEK(0xfe001134) (used target peek value 0x00600000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG13
-*/
-POKE32(0xfe001134, 0x00600000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-/* PEEK(0xfe001138) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG14
-*/
-POKE32(0xfe001138, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fbbddee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fbbddee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG42
-*/
-POKE32(0xfe0011a8, 0x2fbbddee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x18a001ee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG43
-*/
-POKE32(0xfe0011ac, 0x18a001ee)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG51
-*/
-POKE32(0xfe0011cc, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG52
-*/
-POKE32(0xfe0011d0, 0x00000000)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c4) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG55
-*/
-POKE32(0xfe0011dc, 0x07fc22c4)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a2)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a1)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x000006a0)
-DELAY(10)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x080006a0)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080006a0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-POKE32(0xfe00112c, 0x080006a1)
-DELAY(10)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG04
-*/
-POKE32(0xfe001110, 0x000001a6)
-DELAY(10)
-
-
-/*
-st40_emi_regs.EMI_BANK_ENABLE
-*/
-POKE32(0xfe700860, 0x00000005)
-
-
-/*
-st40_emi_regs.EMI_BANK0_BASEADDRESS
-*/
-POKE32(0xfe700800, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_BASEADDRESS
-*/
-POKE32(0xfe700810, 0x00000010)
-
-
-/*
-st40_emi_regs.EMI_BANK2_BASEADDRESS
-*/
-POKE32(0xfe700820, 0x00000018)
-
-
-/*
-st40_emi_regs.EMI_BANK3_BASEADDRESS
-*/
-POKE32(0xfe700830, 0x0000001a)
-
-
-/*
-st40_emi_regs.EMI_BANK4_BASEADDRESS
-*/
-POKE32(0xfe700840, 0x0000001c)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
-*/
-POKE32(0xfe700100, 0x001016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
-*/
-POKE32(0xfe700108, 0x9d200000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
-*/
-POKE32(0xfe700110, 0x9d220000)
-
-
-/*
-st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
-*/
-POKE32(0xfe700118, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
-*/
-POKE32(0xfe700140, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
-*/
-POKE32(0xfe700148, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
-*/
-POKE32(0xfe700150, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
-*/
-POKE32(0xfe700158, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
-*/
-POKE32(0xfe700180, 0x002046f9)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
-*/
-POKE32(0xfe700188, 0xa5a00000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
-*/
-POKE32(0xfe700190, 0xa5a20000)
-
-
-/*
-st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
-*/
-POKE32(0xfe700198, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
-*/
-POKE32(0xfe7001c0, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
-*/
-POKE32(0xfe7001c8, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
-*/
-POKE32(0xfe7001d0, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
-*/
-POKE32(0xfe7001d8, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
-*/
-POKE32(0xfe700200, 0x002016d1)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
-*/
-POKE32(0xfe700208, 0x9d222200)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
-*/
-POKE32(0xfe700210, 0x9d220044)
-
-
-/*
-st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
-*/
-POKE32(0xfe700218, 0x00000000)
-
-
-/*
-st40_emi_regs.EMI_GENCFG
-*/
-POKE32(0xfe700028, 0x00000010)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG11
-*/
-/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30017b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_1
-*/
-POKE32(0xfe90100c, 0x000000b0)
-
-
-/*
-st40_lmigp_regs.LMI_STR_0
-*/
-POKE32(0xfe901018, 0xcf35b424)
-
-
-/*
-st40_lmigp_regs.LMI_STR_1
-*/
-POKE32(0xfe90101c, 0x00242ed8)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA0_0
-*/
-POKE32(0xfe901030, 0x2c001e20)
-
-
-/*
-st40_lmigp_regs.LMI_SDRA1_0
-*/
-POKE32(0xfe901038, 0x2c001e20)
-DELAY(200000)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020023)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00010000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00018000)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00008004)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00004363)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020022)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020024)
-
-
-/*
-st40_lmigp_regs.LMI_SDMR0_0
-*/
-POKE32(0xfe901048, 0x00004263)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
-
-
-/*
-st40_lmigp_regs.LMI_MIM_0
-*/
-POKE32(0xfe901008, 0x0b30037b)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_SCR_0
-*/
-POKE32(0xfe901010, 0x00020021)
-
-
-/*
-st40_lmigp_regs.LMI_GCC_0
-*/
-POKE32(0xfe901028, 0x00000000)
-/* Info: correcting interco reset setup
- */
-POKE32(0xfe20d200, 0x00000005)
-POKE32(0xfe20d204, 0x00000004)
-POKE32(0xfe20d208, 0x00000003)
-POKE32(0xfe20d20c, 0x00000002)
-POKE32(0xfe20d210, 0x00000001)
-POKE32(0xfe20d214, 0x00000001)
-POKE32(0xfe20d218, 0x00000001)
-POKE32(0xfe20d21c, 0x00000001)
-POKE32(0xfe20d220, 0x00000001)
-POKE32(0xfe2410fc, 0x00000005)
-POKE32(0xfe20a0ec, 0x00000002)
-POKE32(0xfe20a0f0, 0x00000005)
-POKE32(0xfe20a0f4, 0x00000003)
-POKE32(0xfe20a0f8, 0x00000003)
-POKE32(0xfe20a1ec, 0x00000002)
-POKE32(0xfe20a1f0, 0x00000005)
-POKE32(0xfe20a1f4, 0x00000003)
-POKE32(0xfe20a1f8, 0x00000003)
-POKE32(0xfe20a1fc, 0x00000000)
-POKE32(0xfe20a2ec, 0x00000002)
-POKE32(0xfe20a2f0, 0x00000005)
-POKE32(0xfe20a2f4, 0x00000003)
-POKE32(0xfe20a2f8, 0x00000003)
-POKE32(0xfe20a2fc, 0x00000000)
-POKE32(0xfe20a3ec, 0x00000002)
-POKE32(0xfe20a3f0, 0x00000005)
-POKE32(0xfe20a3f4, 0x00000003)
-POKE32(0xfe20a3f8, 0x00000003)
-POKE32(0xfe20a3fc, 0x00000000)
-POKE32(0xfe20aefc, 0x00000005)
-POKE32(0xfe540034, 0x00000003)
-POKE32(0xfe540038, 0x00000000)
-POKE32(0xfe540110, 0x00010303)
-POKE32(0xfe540114, 0x00000000)
-POKE32(0xfe540030, 0x00000005)
-POKE32(0xfe54010c, 0x00000005)
-POKE32(0xfe540600, 0x00000006)
-POKE32(0xfe540604, 0x00000005)
-POKE32(0xfe540608, 0x00000004)
-POKE32(0xfe54060c, 0x00000003)
-POKE32(0xfe540610, 0x00000002)
-POKE32(0xfe540614, 0x00000001)
-POKE32(0xfe540618, 0x00000000)
-POKE32(0xfe540680, 0x00000001)
-POKE32(0xfe540684, 0x00000000)
-POKE32(0xfe20bb04, 0x00000005)
-POKE32(0xfe20bb08, 0x00000003)
-POKE32(0xfe20bb10, 0x00000002)
-POKE32(0xfe20bb24, 0x00000005)
-POKE32(0xfe20bb28, 0x00000003)
-POKE32(0xfe20bb2c, 0x00000000)
-POKE32(0xfe20bb30, 0x00000002)
-POKE32(0xfe20bb44, 0x00000005)
-POKE32(0xfe20bb48, 0x00000003)
-POKE32(0xfe20bb4c, 0x00000000)
-POKE32(0xfe20bb50, 0x00000002)
-POKE32(0xfe20bb84, 0x00000005)
-POKE32(0xfe20bb88, 0x00000003)
-POKE32(0xfe20bb8c, 0x00000000)
-POKE32(0xfe20bb90, 0x00000002)
-POKE32(0xfe20a0fc, 0x00000000)
-POKE32(0xfe20bb0c, 0x00000000)
-POKE32(0xfe231010, 0x00000008)
-POKE32(0xfe231080, 0x00000221)
-POKE32(0xfe261010, 0x00000008)
-POKE32(0xfe261080, 0x00000221)
-POKE32(0xfd101024, 0x0003c000)
-POKE32(0xfd101824, 0x0003c000)
-POKE32(0xfd104d24, 0x0003c000)
-POKE32(0xfd102024, 0x0003c000)
-/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
-POKE32(0xfe001180, 0x00000b05)
-POKE32(0xfe1fff04, 0x00254608)
-POKE32(0xfeafff04, 0x00254608)
-/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
-POKE32(0xfe00111c, 0x08091508)
-POKE32(0xfd117000, 0x0025c608)
-POKE32(0xfd111000, 0x00201004)
-/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
-POKE32(0xfe001180, 0x00000b01)
-POKE32(0xfe401744, 0x0025c005)
-
-
-/*
-st40_ccn_regs.CCN_CCR
-*/
-POKE32(0xff00001c, 0x8000090d)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x04000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x04000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG26
-*/
-POKE32(0xfe001168, 0xfe804001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd1)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG27
-*/
-POKE32(0xfe00116c, 0x00001fd0)
-/* stx7105: booted audio companion
- */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG09
-*/
-POKE32(0xfe001124, 0x08000a8c)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-/* PEEK(0xfe001114) (used target peek value 0x04000040) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG05
-*/
-POKE32(0xfe001114, 0x04000040)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG28
-*/
-POKE32(0xfe001170, 0xfe604001)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcd)
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
-
-
-/*
-stx7105_sysconf_regs.SYSCONF_CFG29
-*/
-POKE32(0xfe001174, 0x00001fcc)
-/* stx7105: booted video companion
- */
-/* TCK frequency set to 12500000 Hz
- */
-/* tapmux complete_connect(): single core setup
- */
-/* sdk7105 initialization complete
- */
diff --git a/board/st/5197cab/5197cab.c b/board/st/5197cab/5197cab.c
new file mode 100644
index 0000000..2b22d5a
--- /dev/null
+++ b/board/st/5197cab/5197cab.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-CAB"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/5197cab/5197cab.romgen b/board/st/5197cab/5197cab.romgen
new file mode 100644
index 0000000..08fa12f
--- /dev/null
+++ b/board/st/5197cab/5197cab.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/st/5197cab/Makefile b/board/st/5197cab/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/5197cab/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/5197cab/config.mk b/board/st/5197cab/config.mk
new file mode 100644
index 0000000..d83a0ae
--- /dev/null
+++ b/board/st/5197cab/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# STx5197-CAB board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/5197cab/init-5197cab.S b/board/st/5197cab/init-5197cab.S
new file mode 100644
index 0000000..07eb584
--- /dev/null
+++ b/board/st/5197cab/init-5197cab.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "5197cab.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb101/Makefile b/board/st/cb101/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/cb101/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/cb101/cb101.c b/board/st/cb101/cb101.c
new file mode 100644
index 0000000..1a3b11c
--- /dev/null
+++ b/board/st/cb101/cb101.c
@@ -0,0 +1,173 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board STe101P PHY */
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#if defined(CONFIG_CMD_NAND)
+	/*  Setup PIO for NAND FLASH devices: Ready/Not_Busy */
+	SET_PIO_PIN(PIO_PORT(2), 7, STPIO_IN);
+#endif	/* CONFIG_CMD_NAND */
+}
+
+
+#if defined(CONFIG_CMD_NAND)
+static void nand_emi_init(void)
+{
+	/* setup the EMI configuration for the 2 banks
+	 * containing NAND flash devices. */
+
+	/* NAND FLASH in EMI Bank #1 (128MB) */
+	*ST40_EMI_BANK1_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK1_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA3 = 0x00000000;
+
+	/* NAND FLASH in EMI Bank #2 (1GB) */
+	*ST40_EMI_BANK2_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK2_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA3 = 0x00000000;
+}
+#endif	/* CONFIG_CMD_NAND */
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+#if defined(CONFIG_CMD_NAND)
+	nand_emi_init();
+#endif	/* CONFIG_CMD_NAND */
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb101"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet(0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+	return 0;
+}
diff --git a/board/st/cb101/config.mk b/board/st/cb101/config.mk
new file mode 100644
index 0000000..37f427b
--- /dev/null
+++ b/board/st/cb101/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# CB101 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/cb101/init-cb101.S b/board/st/cb101/init-cb101.S
new file mode 100644
index 0000000..2898a40
--- /dev/null
+++ b/board/st/cb101/init-cb101.S
@@ -0,0 +1,388 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank #0 - NOR FLASH (32MiB) at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x04320691)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank #1 - NAND FLASH (128MiB), at address 0x02000000 -> 0x02FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #2 - NAND FLASH (1GB), at address 0x03000000 -> 0x03FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #3 - unused, at address 0x04000000 -> 0x04FFFFFF */
+
+  /* Bank #4 - unused, at address 0x05000000 -> 0x05FFFFFF */
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+/*POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+/*POKE_LONG(ST40_LMI_MIM_1(0), 0xffff1010)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb101/nand.c b/board/st/cb101/nand.c
new file mode 100644
index 0000000..4731b25
--- /dev/null
+++ b/board/st/cb101/nand.c
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7200reg.h>
+
+#define PIO_BASE  0xfd020000
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void cb101_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through GPIO port#2, pin #7.
+ */
+static int cb101_device_ready(struct mtd_info *mtd)
+{
+	int ret = STPIO_GET_PIN(PIO_PORT(2), 7);
+	return ret;
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = cb101_hwcontrol;
+	nand->dev_ready = cb101_device_ready;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/cb102/Makefile b/board/st/cb102/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/cb102/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/cb102/cb102.c b/board/st/cb102/cb102.c
new file mode 100644
index 0000000..f6ecd27
--- /dev/null
+++ b/board/st/cb102/cb102.c
@@ -0,0 +1,146 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ * Sean McGoogan <Sean.McGoogan@st.com> - added cb102 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board SMSC LAN8700 PHY */
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+}
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb102"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+	return 0;
+}
diff --git a/board/st/cb102/config.mk b/board/st/cb102/config.mk
new file mode 100644
index 0000000..fb571b3
--- /dev/null
+++ b/board/st/cb102/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# CB102 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/cb102/init-cb102.S b/board/st/cb102/init-cb102.S
new file mode 100644
index 0000000..70a7a05
--- /dev/null
+++ b/board/st/cb102/init-cb102.S
@@ -0,0 +1,426 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/* ----- STx7200 Clocks ----- */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... to 900MHz */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL2 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL2... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+	/* Configure CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+	/* Wait for CLOCKGENA PLL2 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+	/* Clear CLOCKGENA PLL2 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENB PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENB PLL0... */
+	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+	/* Configure CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+	/* Wait for CLOCKGENB PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENB PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+	/* Power down PLL... */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+#ifdef SLOW_LMI
+	/* Set LMI clock to 666MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+#else	/* !SLOW_LMI */
+	/* Set LMI clock to 800MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
+#endif	/* SLOW_LMI */
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ELSE(1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* ----- STx7200 Sysconf ----- */
+
+	/* PLI_CLOCK_ENABLE set to 0 */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
+	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Check both DLL on LMI1 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
+	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+	/* Force DLL1 and DLL2 command of LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+	/* Set cfg55 and cfg56 */
+	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+
+	/* PDL offsets
+	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
+	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
+	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
+	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	 */
+
+	/* TO BE UPDATED FOR 7200/MB671 */
+	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
+
+	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
+
+	/* ----- STx7200 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - Not configured */
+	/* Bank 2 - Not configured */
+	/* Bank 3 - Not configured */
+	/* Bank 4 - Not configured */
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000050)
+
+	/* ----- STx7200 LMI0 configuration ----- */
+
+	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
+
+	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
+
+	/* lmi base address 0x08000000 + 256MiB */
+	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
+
+	/* lmi base address 0x08000000 + 256MiB */
+	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
+
+	/* ----- STx7200 LMI1 configuration ----- */
+
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
+
+	/* SDRAM Timing Register */
+	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
+
+	/* SDRAM Row Attribute 0 */
+	/* lmi base address 0x18000000 + 64MiB */
+	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
+
+	/* SDRAM Row Attribute 1 */
+	/* lmi base address 0x18000000 + 64MiB */
+	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb103/cb103.romgen b/board/st/cb103/cb103.romgen
new file mode 100644
index 0000000..5a1c8b7
--- /dev/null
+++ b/board/st/cb103/cb103.romgen
@@ -0,0 +1,1580 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016c0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e04402b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006c0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e175c6b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1e179572) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x002ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x002ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x980001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x87b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x180001ed)
+/* PEEK(0xfd70412c) (used target peek value 0x080006a1) */
+/* PEEK(0xfd704130) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704134) (used target peek value 0x00020000) */
+/* PEEK(0xfd704138) (used target peek value 0x00000000) */
+/* PEEK(0xfd70413c) (used target peek value 0x08000001) */
+/* PEEK(0xfd704140) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704144) (used target peek value 0x00020000) */
+/* PEEK(0xfd704148) (used target peek value 0x00000000) */
+/* PEEK(0xfd704198) (used target peek value 0x002ffd08) */
+/* PEEK(0xfd70419c) (used target peek value 0x002ffd18) */
+/* PEEK(0xfd7041a8) (used target peek value 0x07b7dbed) */
+/* PEEK(0xfd7041ac) (used target peek value 0x980001ed) */
+/* PEEK(0xfd7041b0) (used target peek value 0x87b7dbed) */
+/* PEEK(0xfd7041b4) (used target peek value 0x180001ed) */
+/* PEEK(0xfd7041cc) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d0) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d4) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d8) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041dc) (used target peek value 0x07fc0284) */
+/* PEEK(0xfd7041e0) (used target peek value 0x07fc0284) */
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/st/cb103/init-cb103.S b/board/st/cb103/init-cb103.S
new file mode 100644
index 0000000..5c979f2
--- /dev/null
+++ b/board/st/cb103/init-cb103.S
@@ -0,0 +1,77 @@
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:cb103:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "cb103" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "cb103.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk7111/Makefile b/board/st/hdk7111/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/hdk7111/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hdk7111/config.mk b/board/st/hdk7111/config.mk
new file mode 100644
index 0000000..3ef944d
--- /dev/null
+++ b/board/st/hdk7111/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HDK-7111 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hdk7111/hdk7111.c b/board/st/hdk7111/hdk7111.c
new file mode 100644
index 0000000..35b00c2
--- /dev/null
+++ b/board/st/hdk7111/hdk7111.c
@@ -0,0 +1,114 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Vpp is tied HIGH, so nothing to be done */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Vpp is tied HIGH, so nothing can be done */
+}
+
+static void configEthernet(void)
+{
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(1),6,STPIO_OUT);	/* PHY_RES is on PIO1[6] */
+
+	/* Finally, just toggle the PHY Reset pin */
+	STPIO_SET_PIN(PIO_PORT(1), 6, 0);	/* Assert PHY_RES */
+	udelay(100);				/* small delay (100us) */
+	STPIO_SET_PIN(PIO_PORT(1), 6, 1);	/* de-assert PHY_RES */
+}
+
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+#if defined(CONFIG_SOFT_SPI)
+	/* Configure SPI Serial Flash for PIO "bit-banging" */
+
+	/* SPI is on PIO2[2:0], with CS on PIO6[7] */
+	SET_PIO_PIN(PIO_PORT(2),0,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(2),1,STPIO_OUT);	/* SPI_DOUT */
+	SET_PIO_PIN(PIO_PORT(2),2,STPIO_IN);	/* SPI_DIN */
+	SET_PIO_PIN(PIO_PORT(6),7,STPIO_OUT);	/* SPI_NOTCS */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(6), 7, 1);	/* deassert SPI_NOCS */
+	STPIO_SET_PIN(PIO_PORT(2), 0, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(2), 1, 0);	/* deassert SPI_DOUT */
+#else
+#error Still to impliment SPI via SSC for the STx7111.
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
+static void configPIO(void)
+{
+	/* Setup PIO of ASC device */
+#if CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);	/* UART2 - AS0 */
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE */
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+
+#if defined(CONFIG_SPI)
+	/* Configure for SPI Serial Flash */
+	configSpi();
+#endif	/* CONFIG_SPI */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7111-HDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/hdk7111/hdk7111.romgen b/board/st/hdk7111/hdk7111.romgen
new file mode 100644
index 0000000..a269c33
--- /dev/null
+++ b/board/st/hdk7111/hdk7111.romgen
@@ -0,0 +1,1867 @@
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001402) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101402)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181402) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000007)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000002)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000011)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000000b)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000007)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000003)
+POKE32(0xfe702010, 0x00000004)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x101005a6) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x0000c0de)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfe0000b8, 0x00000000)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x0000c1a0)
+
+
+/*
+stx7111_audio_regs.AUDCFG_FSYNA_CFG
+*/
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_audio_regs.AUDCFG_FSYNA_CFG
+*/
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000007) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000011) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000000b) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000007) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(200)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1015f5ee) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00200000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07bbddee)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x180001ee)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001A)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+/* PEEK(0xfe90100c) (used target peek value 0xffff0500) */
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242e58)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x2c001e20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008006)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b63)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a63)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008386)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008006)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000003)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000004)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000003)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000005)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000005) */
+POKE32(0xfe001180, 0x00000001)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG25
+*/
+POKE32(0xfe001164, 0x00000001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG25
+*/
+POKE32(0xfe001164, 0x00000000)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x205265c0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x285265c0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x285265c0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x285265c0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/hdk7111/init-hdk7111.S b/board/st/hdk7111/init-hdk7111.S
new file mode 100644
index 0000000..5f47655
--- /dev/null
+++ b/board/st/hdk7111/init-hdk7111.S
@@ -0,0 +1,77 @@
+#include "asm/stx7111reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:hdk7111:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "hdk7111" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "hdk7111.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk7111/nand.c b/board/st/hdk7111/nand.c
new file mode 100644
index 0000000..39b28c8
--- /dev/null
+++ b/board/st/hdk7111/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7111reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void hdk7111_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int hdk7111_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardware specific function for accessing control-lines
+ * - dev_ready: hardware specific function for accessing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transferring data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = hdk7111_device_ready;
+	nand->hwcontrol     = hdk7111_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/hms1/Makefile b/board/st/hms1/Makefile
new file mode 100644
index 0000000..80745c0
--- /dev/null
+++ b/board/st/hms1/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hms1/config.mk b/board/st/hms1/config.mk
new file mode 100644
index 0000000..aff8d30
--- /dev/null
+++ b/board/st/hms1/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HMS1 board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x86F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hms1/hms1.c b/board/st/hms1/hms1.c
new file mode 100644
index 0000000..82726d9
--- /dev/null
+++ b/board/st/hms1/hms1.c
@@ -0,0 +1,163 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_clocks(void);
+
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+}
+
+void flashWriteDisable(void)
+{
+}
+
+#define PIO_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  SET_PIO_ASC(PIO_BASE, 3, 2, 4, 5);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: HMS1"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/st/hms1/init-hms1.S b/board/st/hms1/init-hms1.S
new file mode 100644
index 0000000..ee5a59d
--- /dev/null
+++ b/board/st/hms1/init-hms1.S
@@ -0,0 +1,224 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x93001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x91001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+#if 0
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+#endif
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+#if 0
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb411/Makefile b/board/st/mb411/Makefile
new file mode 100644
index 0000000..80745c0
--- /dev/null
+++ b/board/st/mb411/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb411/config.mk b/board/st/mb411/config.mk
new file mode 100644
index 0000000..5f44ec6
--- /dev/null
+++ b/board/st/mb411/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB411 (STb7100 Mboard) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb411/init-mb411.S b/board/st/mb411/init-mb411.S
new file mode 100644
index 0000000..52def4d
--- /dev/null
+++ b/board/st/mb411/init-mb411.S
@@ -0,0 +1,209 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb411/mb411.c b/board/st/mb411/mb411.c
new file mode 100644
index 0000000..0038b2d
--- /dev/null
+++ b/board/st/mb411/mb411.c
@@ -0,0 +1,171 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Mboard (MB411)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/st/mb442/Makefile b/board/st/mb442/Makefile
new file mode 100644
index 0000000..80745c0
--- /dev/null
+++ b/board/st/mb442/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb442/config.mk b/board/st/mb442/config.mk
new file mode 100644
index 0000000..4e73ed4
--- /dev/null
+++ b/board/st/mb442/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB442 (STb7100REF or Coco) board
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at SDRAM BASE  + 63M in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb442/init-mb442.S b/board/st/mb442/init-mb442.S
new file mode 100644
index 0000000..d8403ae
--- /dev/null
+++ b/board/st/mb442/init-mb442.S
@@ -0,0 +1,230 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT1) /* 266 MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ELSE
+#if (INPUT_CLOCK_RATE == 30)   /* 384 MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_MB442_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+#if CONFIG_SH_MB442_128
+       POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ELSE
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the System and Video LMI base
+   * addresses to their 32-bit SE mode locations as defined in the datasheet.
+   */
+        UPDATE_LONG(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
+#ifdef CONFIG_SH_MB442_128
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x48001a00)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x48001a00)
+#else
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x44001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x44001900)
+#endif
+        POKE_LONG(ST40_LMI_SDRA0_0(VID), 0x64001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(VID), 0x64001900)
+
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb442/mb442.c b/board/st/mb442/mb442.c
new file mode 100644
index 0000000..ee5ea3a
--- /dev/null
+++ b/board/st/mb442/mb442.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_clocks(void);
+
+void flashWriteEnable(void)
+{
+  /* Enable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+void flashWriteDisable(void)
+{
+  /* Disable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+  /*  Setup up ethernet reset */
+#ifdef CONFIG_DRIVER_SMC91111
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+#endif
+#ifdef CONFIG_DRIVER_NETSTMAC
+  SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+#endif
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  /* Enable ATAPI mode of EMI */
+  /* QQQ - to do */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 0);
+	udelay(2000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Reference (MB442)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/mb448/Makefile b/board/st/mb448/Makefile
new file mode 100644
index 0000000..80745c0
--- /dev/null
+++ b/board/st/mb448/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb448/config.mk b/board/st/mb448/config.mk
new file mode 100644
index 0000000..9db40e3
--- /dev/null
+++ b/board/st/mb448/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB448 (STb7109EREF) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb448/init-mb448.S b/board/st/mb448/init-mb448.S
new file mode 100644
index 0000000..3b56fde
--- /dev/null
+++ b/board/st/mb448/init-mb448.S
@@ -0,0 +1,168 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT2)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT1)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000400)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb448/mb448.c b/board/st/mb448/mb448.c
new file mode 100644
index 0000000..0162801
--- /dev/null
+++ b/board/st/mb448/mb448.c
@@ -0,0 +1,118 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+#define PIO2_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+  /*  Setup up ethernet reset */
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7109E-Reference (MB448)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
diff --git a/board/st/mb519/Makefile b/board/st/mb519/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/mb519/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb519/config.mk b/board/st/mb519/config.mk
new file mode 100644
index 0000000..cf00d78
--- /dev/null
+++ b/board/st/mb519/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB519 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb519/init-mb519.S b/board/st/mb519/init-mb519.S
new file mode 100644
index 0000000..5ca2c28
--- /dev/null
+++ b/board/st/mb519/init-mb519.S
@@ -0,0 +1,376 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb519/mb519.c b/board/st/mb519/mb519.c
new file mode 100644
index 0000000..7db5570
--- /dev/null
+++ b/board/st/mb519/mb519.c
@@ -0,0 +1,143 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB519)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0), in MII mode, using its own clock  */
+	stx7200_configure_ethernet(0, 0, 1, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY board (MII1), in MII mode, using its own clock */
+	stx7200_configure_ethernet(1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	return 0;
+}
diff --git a/board/st/mb618/Makefile b/board/st/mb618/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/mb618/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb618/config.mk b/board/st/mb618/config.mk
new file mode 100644
index 0000000..ed07dd4
--- /dev/null
+++ b/board/st/mb618/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB618 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x93F00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x93F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb618/init-mb618.S b/board/st/mb618/init-mb618.S
new file mode 100644
index 0000000..5dd0fbf
--- /dev/null
+++ b/board/st/mb618/init-mb618.S
@@ -0,0 +1,366 @@
+#include "asm/stx7111reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb618.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/* ----- STx7111 Clocks ----- */
+
+	/* Clockgen A initial setup */
+
+	/* Set PLL0 clock to 450MHz */
+	/* PLL0 of clockgenA = PLL1600 */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set PLL1 clock to 800MHz */
+	/* PLL1 of clockgenA = PLL800 */
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xfff80000, (0x0 << 16) | (0x28 << 8) | (0x03))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set dividers clocks */
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV1_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV2_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV5_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV8_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV9_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV10_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV11_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV12_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV15_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV16_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV17_CFG, 0x00000103)
+
+	/* Set clock sources */
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
+
+	/* Clockgen D (LMI) initial setup (lmi2xfreq = 540) */
+	/* Power down PLL... */
+	OR32(STX7111_SYSCONF_SYS_CFG11, 0x00001000)
+
+	/* Configure PLL... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xfffff001, (0x01 << 9) | (0x12 << 1))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+
+	/* ----- STX7111 SysConf ----- */
+	/* PLI_CLOCK_ENABLE set to 0 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, ~(1 << 2))
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7111_SYSCONF_SYS_CFG11, (0x00000001 | 1 << 27))
+
+	/* Delay ~ 200 microseconds (assume 30MHz CPU clock) */
+	DELAY(200 * 30)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, (1 << 2))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7111_SYSCONF_SYS_CFG38, 0x000FFE0C)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG13, 0x00000000)
+	POKE32(STX7111_SYSCONF_SYS_CFG14, 0x00000000)
+
+	/* Set cfg55 */
+#ifndef LMI_16BITS_MODE
+#define LMI_16BITS_MODE 0
+#endif
+	POKE32(STX7111_SYSCONF_SYS_CFG55, 0x03fc2004 | (LMI_16BITS_MODE << 10) | ((0x7 & 0x7) << 7))
+
+	/* PDL offsets */
+	POKE32(STX7111_SYSCONF_SYS_CFG42, 0x07D7EBF5)
+	POKE32(STX7111_SYSCONF_SYS_CFG43, 0x000001F5)
+
+	/* ----- STX7111 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001C)
+
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - STEM 8 MiB 0x04000000 -> 0x047fffff */
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 2 - DVB-CI at address 0x04000000 -> 0x04FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 3 - 32MiB Boards register and either DVBCI notCe2 or
+		STEM notCS1 (16MiB + 16MiB split bank) 0x05000000 -> 0x06ffffff
+	 */
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000010)
+
+
+	/* ----- STX7111 LMI0 configuration ----- */
+
+	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
+	 # Refresh interval compute (from Ignazio, 11jan08)
+	 # 300 MHz --->  T=3.4ns => MIM[28:16]=2038 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
+	 # 330 MHz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
+	 # 360 MHz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
+	 # 400 MHz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000017b)
+#else
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000013b)
+#endif
+	/* Note: refresh is enabled in later steps */
+
+	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
+
+	/* SDRAM Timing Register
+	 # lmi.LMI_STR_0.poke(0x4c2db41b)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 #		1-cycle additional delay between RD and WR
+	 */
+	POKE32(ST40_LMI_STR_0(), 0xcc2db41b)
+	POKE32(ST40_LMI_STR_1(), 0x002202d6)
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA0_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA0_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA1_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA1_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Control Register */
+	/* Delay ~ 200 milliseconds (assume 450MHz CPU clock) */
+	DELAY(200000 * 450)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000953)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000853)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
+
+	/* Issue EMRS1 for OCD calibration default */
+	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
+
+	/* Issue EMRS1 for OCD calibration exit */
+	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
+
+	/* Enable auto refresh
+	 # lmi.LMI_MIM_0.poke(0x0c30037b)
+	 # FCh, 12/feb/08: cleaner to modify only refresh bit
+	 */
+	OR32(ST40_LMI_MIM_0(), (1 << 9))
+
+	/* DQS recovery mechanism (1=enabled)
+	 # lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1 << 5))
+	 # FCh, 14/jan/08, NO DQS recovery
+	 */
+	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
+
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 128Mbytes=0x48000000, 13x10
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb618/mb618.c b/board/st/mb618/mb618.c
new file mode 100644
index 0000000..ab35eac
--- /dev/null
+++ b/board/st/mb618/mb618.c
@@ -0,0 +1,225 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+#ifndef CONFIG_SH_NO_EPLD
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb6000000	/* Phys 0x06000000 */
+#else
+#define EPLD_BASE		0xa6000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_IDENT		0x00	/* READ: EPLD Identifier Register */
+#define EPLD_BANK		0x00	/* WRITE: EPLD Bank Register */
+#define EPLD_TEST		0x04	/* EPLD Test Register (Banked) */
+#define EPLD_CTRL		0x04	/* EPLD Control Register (Banked) */
+#define EPLD_SET_BANK_TEST	0x00	/* Bank = EPLD_TEST */
+#define EPLD_SET_BANK_CTRL	0x01	/* Bank = EPLD_CTRL */
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+#endif	/* CONFIG_SH_NO_EPLD */
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 0);
+}
+
+static void configPIO(void)
+{
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+	/* Setup up Vpp for NOR FLASH */
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_OUT);
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+#if defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD)
+/*
+ * Reset the Ethernet PHY, via the EPLD.
+ * This code is only for EPLD version 06 or later.
+ */
+static inline void mb618_phy_reset06(void)
+{
+	/* set EPLD Bank = Ctrl */
+	epld_write(EPLD_SET_BANK_CTRL, EPLD_BANK);
+
+	/* Bring the PHY out of reset in MII mode */
+	epld_write(0x4 | 0, EPLD_CTRL);
+	epld_write(0x4 | 1, EPLD_CTRL);
+}
+#endif	/* defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD) */
+
+/*
+ * We have several EPLD versions, with slightly different memory
+ * maps and features:
+ *
+ * version 04:
+ * off  read        reset
+ *  0   Status      undef  (unused)
+ *  4   Ctrl        20     (unused)
+ *  8   Test        33
+ *  c   Ident       0      (should be 1 but broken)
+ * (note writes are broken)
+ *
+ * version 05:
+ * off  read     write       reset
+ *  0   Ident    Ctrl        45
+ *  4   Test     Test        55
+ *  8   IntStat  IntMaskSet  -
+ *  c   IntMask  IntMaskClr  0
+ *
+ * version 06:
+ * off        read       write         reset
+ *  0         Ident      Bank          46 (Bank register defaults to 0)
+ *  4 bank=0  Test       Test          55
+ *  4 bank=1  Ctrl       Ctrl          0e
+ *  4 bank=2  IntPri0    IntPri0  f9
+ *  4 bank=3  IntPri1    IntPri1  f0
+ *  8         IntStat    IntMaskSet    -
+ *  c         IntMask    IntMaskClr    00
+ *
+ * Ctrl register bits:
+ *  0 = Ethernet Phy notReset
+ *  1 = RMIInotMIISelect
+ *  2 = Mode Select_7111 (ModeSelect when D0 == 1)
+ *  3 = Mode Select_8700 (ModeSelect when D0 == 0)
+ *
+ *  The version 06 map is also applicable to later versions.
+ *
+ *  NOTE: U-Boot only supports version 06 or later of the EPLD.
+ *  Versions of the EPLD prior to this version are NOT supported!
+ */
+
+static int mb618_init_epld(void)
+{
+#ifdef CONFIG_SH_NO_EPLD
+	/* we ignore talking to the EPLD, tell the user */
+	printf("info: Disregarding any EPLD\n");
+
+#else	/* CONFIG_SH_NO_EPLD */
+	const unsigned char test_values[2] = {0xa4u, 0x2fu};
+	unsigned char epld_reg, inverted;
+	unsigned char epld_version, board_version;
+	int i;
+
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+
+	/* for each test value ... */
+	for (i=0; i<sizeof(test_values)/sizeof(test_values[0]); i++) {
+		/* write (anything) to the test register */
+		epld_write(test_values[i], EPLD_TEST);
+		/* calculate what we expect back */
+		inverted = ~test_values[i];
+		/* now read it back */
+		epld_reg = epld_read(EPLD_TEST);
+		/* verify we got back an inverted result */
+		if (epld_reg != inverted) {
+			printf("Failed EPLD test (offset=%02x, %02x!=%02x)\n",
+				EPLD_TEST, epld_reg, inverted);
+			return 1;	/* Failure! */
+			}
+	}
+
+	/* Assume we can trust the ident register */
+	epld_reg      = epld_read(EPLD_IDENT);
+	board_version = (epld_reg >> 5) & 0x07u;
+	epld_version  = (epld_reg >> 0) & 0x1fu;
+
+	/* is it acceptable ? */
+	if (epld_version < 6) {
+		printf("Unsupported EPLD version (reg=0x%02x)\n",
+			epld_reg);
+		return 1;	/* Failure! */
+	}
+
+	/* display the board revision, and EPLD version */
+	printf("MB618: revision %c, EPLD version %02d\n",
+		board_version + 'A',
+		epld_version);
+
+	/* now perform the EPLD initializations we want */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	mb618_phy_reset06();
+#endif
+
+	/* set the Test register back to RESET conditions (for linux) */
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+	/* write inverted 0x55, so it reads back as 0x55 */
+	epld_write(~0x55u, EPLD_TEST);
+
+#endif	/* CONFIG_SH_NO_EPLD */
+
+	/* return a "success" result */
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7111-Mboard (MB618)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	return mb618_init_epld();
+}
diff --git a/board/st/mb618/nand.c b/board/st/mb618/nand.c
new file mode 100644
index 0000000..01426a6
--- /dev/null
+++ b/board/st/mb618/nand.c
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7111reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/mb628/Makefile b/board/st/mb628/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/mb628/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb628/config.mk b/board/st/mb628/config.mk
new file mode 100644
index 0000000..c23d067
--- /dev/null
+++ b/board/st/mb628/config.mk
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2008-2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB628 board:
+#
+#	Following are *Physical* Addresses:
+#
+#	Region		29-bit		32-bit		Size
+#	------		------		------		----
+#	LMI_BASE	0x0c000000	0x40000000	128MiB
+#	VIDEO_BASE	0x0c000000	0x40000000	  4MiB
+#	AUDIO_BASE	0x0c400000	0x40400000	  4MiB
+#	eSTB_BASE	0x0c800000	0x40800000	 50MiB
+#	eSTB_END	0x0f9fffff	0x439fffff	   ---
+#
+#
+#	Following are *Virtual* Addresses:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8F900000	29-bit mode (Traditional Mode)
+#	0x83900000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at eSTB BASE + 49MB in P1 (cachable)
+TEXT_BASE = 0x8F900000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb628/init-mb628.S b/board/st/mb628/init-mb628.S
new file mode 100644
index 0000000..490cb3a
--- /dev/null
+++ b/board/st/mb628/init-mb628.S
@@ -0,0 +1,77 @@
+#include "asm/stx7141reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb628.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb628:estb
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb628" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb628.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb628/mb628.c b/board/st/mb628/mb628.c
new file mode 100644
index 0000000..8aa355c
--- /dev/null
+++ b/board/st/mb628/mb628.c
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7141reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+/* EPLD registers */
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+#define EPLD_IDENT		0x00010000
+#define EPLD_TEST		0x00020000
+#define EPLD_FLASH		0x00050000
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+
+extern void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	epld_write(3, EPLD_FLASH);
+}
+
+extern void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	epld_write(2, EPLD_FLASH);
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(10), 0, 1, 2, 3);  /* ASC1 */
+	SET_PIO_ASC(PIO_PORT(6),  0, 1, 2, 3);  /* ASC2 */
+
+	/* Enable ASC UARTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG36;
+	/* CFG36[29] = 0 = UART1_CTRL_NOT_MII_SEL */
+	sysconf &= 1ul << 29;
+	/* CFG36[30] = 1 = UART2_CTS_SEL */
+	/* CFG36[31] = 1 = UART2_RXD_SEL */
+	sysconf |= 1ul << 30 | 1ul << 31;
+	*STX7141_SYSCONF_SYS_CFG36 = sysconf;
+
+	/* Route ASC1 via PIO[10] for TX, RX, CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG46;
+	/* PIO10[0] Selector: CFG46[7:6]   = 3 */
+	/* PIO10[1] Selector: CFG46[9:8]   = 3 */
+	/* PIO10[2] Selector: CFG46[11:10] = 3 */
+	/* PIO10[3] Selector: CFG46[13:12] = 3 */
+	sysconf |= 3ul << 6 | 3ul << 8 | 3ul << 10 | 3ul << 12;
+	*STX7141_SYSCONF_SYS_CFG46 = sysconf;
+
+	/* Route ASC2 via PIO[6] for TX & RX */
+	sysconf = *STX7141_SYSCONF_SYS_CFG20;
+	/* PIO6[0] Selector: CFG20[28:27] = 3 */
+	/* PIO6[0] Selector: CFG20[30:29] = 3 */
+	sysconf |= 3ul << 27 | 3ul << 29;
+	*STX7141_SYSCONF_SYS_CFG20 = sysconf;
+
+	/* Route ASC2 via PIO[6] for CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG25;
+	/* PIO6[0] Selector: CFG25[1:0] = 3 */
+	/* PIO6[0] Selector: CFG25[3:2] = 3 */
+	sysconf |= 3ul << 0 | 3ul << 2;
+	*STX7141_SYSCONF_SYS_CFG25 = sysconf;
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7141_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+extern int checkboard (void)
+{
+	unsigned version;
+
+	printf ("\n\nBoard: STx7141-Mboard (MB628)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	version = epld_read(EPLD_IDENT);
+	printf("mb628 EPLD version %02d\n", version);
+	return 0;
+}
diff --git a/board/st/mb628/mb628.romgen b/board/st/mb628/mb628.romgen
new file mode 100644
index 0000000..6b96f99
--- /dev/null
+++ b/board/st/mb628/mb628.romgen
@@ -0,0 +1,2423 @@
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80003805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80103805)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00183805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80104a05)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
+*/
+POKE32(0xfe213a14, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa55aa)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a14) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b0c) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x081b06a1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+/* PEEK(0xfe00113c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+POKE32(0xfe00113c, 0x081b0001)
+DELAY(200)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG16
+*/
+POKE32(0xfe001140, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x000f000c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG39
+*/
+POKE32(0xfe00119c, 0x000f0014)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG17
+*/
+POKE32(0xfe001144, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG18
+*/
+POKE32(0xfe001148, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x0800239e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG37
+*/
+POKE32(0xfe001194, 0x0800039e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG44
+*/
+POKE32(0xfe0011b0, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG45
+*/
+POKE32(0xfe0011b4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG53
+*/
+POKE32(0xfe0011d4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG54
+*/
+POKE32(0xfe0011d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x14001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x14001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xac000000, 0x00000000)
+POKE32(0xac000000, 0xaaaaaaaa)
+/* PEEK(0xac000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xac001000, 0x00000000)
+POKE32(0xac001000, 0x55555555)
+/* PEEK(0xac001000) (used target peek value 0x55555555) */
+POKE32(0xac002000, 0x00000000)
+POKE32(0xac002000, 0x12345678)
+/* PEEK(0xac002000) (used target peek value 0x12345678) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90200c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe902018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90201c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe902030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe902038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe902028, 0x00000000)
+POKE32(0xb4000000, 0x00000000)
+POKE32(0xb4000000, 0xaaaaaaaa)
+/* PEEK(0xb4000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb4001000, 0x00000000)
+POKE32(0xb4001000, 0x55555555)
+/* PEEK(0xb4001000) (used target peek value 0x55555555) */
+POKE32(0xb4002000, 0x00000000)
+POKE32(0xb4002000, 0x12345678)
+/* PEEK(0xb4002000) (used target peek value 0x12345678) */
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+POKE32(0xfd103024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe209000, 0x00000013)
+POKE32(0xfe209004, 0x00000003)
+POKE32(0xfe209008, 0x00000000)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x080b1000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+POKE32(0xfd11f000, 0x0025c608)
+POKE32(0xfd119000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000011)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000000)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a091)
+DELAY(360000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a091) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a891)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a891) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a811)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008013)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x10000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x18000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
diff --git a/board/st/mb628/nand.c b/board/st/mb628/nand.c
new file mode 100644
index 0000000..5f098e5
--- /dev/null
+++ b/board/st/mb628/nand.c
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7141reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/mb671/Makefile b/board/st/mb671/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/mb671/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb671/config.mk b/board/st/mb671/config.mk
new file mode 100644
index 0000000..9870753
--- /dev/null
+++ b/board/st/mb671/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB671 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb671/init-mb671.S b/board/st/mb671/init-mb671.S
new file mode 100644
index 0000000..9e2f9fd
--- /dev/null
+++ b/board/st/mb671/init-mb671.S
@@ -0,0 +1,77 @@
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb671:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb671" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb671.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb671/mb671.c b/board/st/mb671/mb671.c
new file mode 100644
index 0000000..073fe75
--- /dev/null
+++ b/board/st/mb671/mb671.c
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2007-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+extern void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+extern void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+extern int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB671)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY on MII0 in RMII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 1, 0, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY on MII1 in MII mode, using its own clock */
+	stx7200_configure_ethernet (1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7200_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
diff --git a/board/st/mb671/mb671.romgen b/board/st/mb671/mb671.romgen
new file mode 100644
index 0000000..17b91e0
--- /dev/null
+++ b/board/st/mb671/mb671.romgen
@@ -0,0 +1,1572 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f10e795) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+/* PEEK(0xfd70413c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f13ef95) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1f1bd47a) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x000ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x000ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x000001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x000001ed)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/st/mb680/Makefile b/board/st/mb680/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/mb680/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb680/config.mk b/board/st/mb680/config.mk
new file mode 100644
index 0000000..e79b8e0
--- /dev/null
+++ b/board/st/mb680/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB680 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb680/init-mb680.S b/board/st/mb680/init-mb680.S
new file mode 100644
index 0000000..dd070ee
--- /dev/null
+++ b/board/st/mb680/init-mb680.S
@@ -0,0 +1,81 @@
+#include "asm/stx7105reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb680:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb680" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#if 1
+#include "mb680-stx7105c2.romgen"	/* for STx7105 cut 2.x */
+#else
+#include "mb680-stx7105c1.romgen"	/* for STx7105 cut 1.x */
+#endif
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 # Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb680/mb680-stx7105c1.romgen b/board/st/mb680/mb680-stx7105c1.romgen
new file mode 100644
index 0000000..e93eb56
--- /dev/null
+++ b/board/st/mb680/mb680-stx7105c1.romgen
@@ -0,0 +1,1653 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f032c9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000122)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000122) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000126)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f13ac9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x08091000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/mb680/mb680-stx7105c2.romgen b/board/st/mb680/mb680-stx7105c2.romgen
new file mode 100644
index 0000000..fc88679
--- /dev/null
+++ b/board/st/mb680/mb680-stx7105c2.romgen
@@ -0,0 +1,1665 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e020380) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e161fca) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/mb680/mb680.c b/board/st/mb680/mb680.c
new file mode 100644
index 0000000..4d2da9f
--- /dev/null
+++ b/board/st/mb680/mb680.c
@@ -0,0 +1,217 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+
+/* following are the offsets in the EMI functions EPLD (IC21),
+ * in the STB Peripheral board (MB705)*/
+#define EPLD_IDENT		0x00	/* EPLD Identifier Register */
+#define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
+#define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb7000000	/* Phys 0x07000000 */
+#else
+#define EPLD_BASE		0xa7000000	/* EMI Bank E */
+#endif	/* CONFIG_SH_SE_MODE */
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 16-bit write to EPLD registers */
+	writew(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 16-bit read from EPLD registers */
+	return readw(EPLD_BASE + offset);
+}
+
+void flashWriteEnable(void)
+{
+	unsigned short epld_reg;
+
+	/* Enable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg |= 1u << 3;	/* NandFlashWP = MISC[3] = 1 */
+	epld_reg |= 1u << 2;	/* NorFlashVpp = MISC[2] = 1 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+void flashWriteDisable(void)
+{
+	unsigned short epld_reg;
+
+	/* Disable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg &= ~(1u << 3);	/* NandFlashWP = MISC[3] = 0 */
+	epld_reg &= ~(1u << 2);	/* NorFlashVpp = MISC[2] = 0 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+static int mb680_init_epld(void)
+{
+	const unsigned short test_value = 0x1234u;
+	unsigned short epld_reg;
+	unsigned short epld_version, board_version;
+
+	/* write (anything) to the test register */
+	epld_write(test_value, EPLD_TEST);
+	/* verify we got back an inverted result */
+	epld_reg = epld_read(EPLD_TEST);
+	if (epld_reg != (test_value ^ 0xffffu)) {
+		printf("Failed EPLD test (offset=%02x, result=%04x)\n",
+			EPLD_TEST, epld_reg);
+		return 1;
+		}
+
+	/* Assume we can trust the version register */
+	epld_reg = epld_read(EPLD_IDENT);
+	board_version = epld_reg >> 4 & 0xfu;
+	epld_version = epld_reg & 0xfu;
+
+	/* display the board revision, and EPLD version */
+	printf("MB705: revision %c, EPLD version %02d\n",
+		board_version + 'A' - 1,
+		epld_version);
+
+	/* return a "success" result */
+	return 0;
+}
+
+#ifdef CONFIG_STMAC_LAN8700
+static void phy_reset(void)
+{
+	/* Reset the SMSC LAN8700 PHY */
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 0);
+	udelay(100);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 0);
+}
+#endif	/* CONFIG_STMAC_LAN8700 */
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
+
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+#ifdef CONFIG_STMAC_LAN8700
+	/* Configure SMSC LAN8700 PHY Reset signals */
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(11), 2, STPIO_OUT);
+#endif	/* CONFIG_STMAC_LAN8700 */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	/* Reset the PHY */
+#ifdef CONFIG_STMAC_LAN8700
+	phy_reset();
+#endif	/* CONFIG_STMAC_LAN8700 */
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-Mboard (MB680)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	mb680_init_epld();
+
+#if 0	/* QQQ - DELETE */
+{
+const unsigned long nand_reg = *ST40_EMI_NAND_VERSION_REG;
+const unsigned long epld_reg = epld_read(EPLD_SWITCH);
+	printf ("*ST40_EMI_NAND_VERSION_REG = %u.%u.%u\n",
+		(nand_reg>>8)&0x0ful,
+		(nand_reg>>4)&0x0ful,
+		(nand_reg>>0)&0x0ful);
+	printf("*EPLD_SWITCH = 0x%08x  -->  boot-from-%s\n",
+		epld_reg,
+		(epld_reg & (1ul<<8)) ? "NAND" : "NOR");
+}
+#endif	/* QQQ - DELETE */
+
+	return 0;
+}
diff --git a/board/st/mb680/nand.c b/board/st/mb680/nand.c
new file mode 100644
index 0000000..19391cc
--- /dev/null
+++ b/board/st/mb680/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int mb680_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = mb680_device_ready;
+	nand->hwcontrol     = mb680_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/mb704/Makefile b/board/st/mb704/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/mb704/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb704/config.mk b/board/st/mb704/config.mk
new file mode 100644
index 0000000..ca02cd3
--- /dev/null
+++ b/board/st/mb704/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB704 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb704/init-mb704.S b/board/st/mb704/init-mb704.S
new file mode 100644
index 0000000..a837882
--- /dev/null
+++ b/board/st/mb704/init-mb704.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb704.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb704/mb704.c b/board/st/mb704/mb704.c
new file mode 100644
index 0000000..cf40a9a
--- /dev/null
+++ b/board/st/mb704/mb704.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-Mboard (MB704)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/mb704/mb704.romgen b/board/st/mb704/mb704.romgen
new file mode 100644
index 0000000..08fa12f
--- /dev/null
+++ b/board/st/mb704/mb704.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/st/pdk7105/Makefile b/board/st/pdk7105/Makefile
new file mode 100644
index 0000000..e71bce4
--- /dev/null
+++ b/board/st/pdk7105/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/pdk7105/config.mk b/board/st/pdk7105/config.mk
new file mode 100644
index 0000000..86ff620
--- /dev/null
+++ b/board/st/pdk7105/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# PDK-7105 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/pdk7105/init-pdk7105.S b/board/st/pdk7105/init-pdk7105.S
new file mode 100644
index 0000000..19b3c32
--- /dev/null
+++ b/board/st/pdk7105/init-pdk7105.S
@@ -0,0 +1,77 @@
+#include "asm/stx7105reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:sdk7105:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "sdk7105" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "pdk7105.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 512MiB=0x60000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x60000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x60000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/pdk7105/nand.c b/board/st/pdk7105/nand.c
new file mode 100644
index 0000000..78e1e26
--- /dev/null
+++ b/board/st/pdk7105/nand.c
@@ -0,0 +1,120 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void pdk7105_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int pdk7105_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = pdk7105_device_ready;
+	nand->hwcontrol     = pdk7105_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/pdk7105/pdk7105.c b/board/st/pdk7105/pdk7105.c
new file mode 100644
index 0000000..c489b83
--- /dev/null
+++ b/board/st/pdk7105/pdk7105.c
@@ -0,0 +1,248 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 1 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 0 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 0);
+}
+
+static void configEthernet(void)
+{
+	unsigned long sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+
+	/* Set the GMAC in MII mode */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	sysconf &= ~0x060f0000ul;
+	sysconf |=  0x08010000ul;
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	/* PIO7[4] CFG37[12,4]  AltFunction = 1 */
+	/* PIO7[5] CFG37[13,5]  AltFunction = 1 */
+	/* PIO7[6] CFG37[14,6]  AltFunction = 1 */
+	/* PIO7[7] CFG37[15,7]  AltFunction = 1 */
+	sysconf &= ~0xf0f0ul;	/* 3,3,3,3,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	/* PIO8[0] CFG46[8,0]   AltFunction = 1 */
+	/* PIO8[1] CFG46[9,1]   AltFunction = 1 */
+	/* PIO8[2] CFG46[10,2]  AltFunction = 1 */
+	/* PIO8[3] CFG46[11,3]  AltFunction = 1 */
+	/* PIO8[4] CFG46[12,4]  AltFunction = 1 */
+	/* PIO8[5] CFG46[13,5]  AltFunction = 1 */
+	/* PIO8[6] CFG46[14,6]  AltFunction = 1 */
+	/* PIO8[7] CFG46[15,7]  AltFunction = 1 */
+	sysconf &= ~0xfffful;	/* 3,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	/* PIO9[0] CFG47[8,0]   AltFunction = 1 */
+	/* PIO9[1] CFG47[9,1]   AltFunction = 1 */
+	/* PIO9[2] CFG47[10,2]  AltFunction = 1 */
+	/* PIO9[3] CFG47[11,3]  AltFunction = 1 */
+	/* PIO9[4] CFG47[12,4]  AltFunction = 1 */
+	/* PIO9[5] CFG47[13,5]  AltFunction = 1 */
+	/* PIO9[6] CFG47[14,6]  AltFunction = 1 */
+	sysconf &= ~0x7f7ful;	/* 0,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+
+	/* Setup PIO for the Ethernet's MII bus */
+	SET_PIO_PIN(PIO_PORT(7),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),6,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7),7,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),0,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),1,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),2,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),3,STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8),4,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),6,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),7,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),0,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),1,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),2,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),3,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),5,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9),6,STPIO_IN);
+
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(15), 5, STPIO_OUT);
+
+	/* Finally, toggle the PHY Reset pin ("RST#") */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 0);
+	udelay(100);	/* small delay */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
+}
+
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+#if defined(CONFIG_SOFT_SPI)
+	/* Configure SPI Serial Flash for PIO "bit-banging" */
+
+#if 1
+	/*
+	 * On the PDK-7105 board, the following 4 pairs of PIO
+	 * pins are connected together with a 3K3 resistor.
+	 *
+	 *	SPI_CLK  PIO15[0] <-> PIO2[5] COM_CLK
+	 *	SPI_DOUT PIO15[1] <-> PIO2[6] COM_DOUT
+	 *	SPI_NOCS PIO15[2] <-> PIO2[4] COM_NOTCS
+	 *	SPI_DIN  PIO15[3] <-> PIO2[7] COM_DIN
+	 *
+	 * To minimise drive "contention", we may set
+	 * associated pins on PIO2 to be simple inputs.
+	 */
+	SET_PIO_PIN(PIO_PORT(2),4,STPIO_IN);	/* COM_NOTCS */
+	SET_PIO_PIN(PIO_PORT(2),5,STPIO_IN);	/* COM_CLK */
+	SET_PIO_PIN(PIO_PORT(2),6,STPIO_IN);	/* COM_DOUT */
+	SET_PIO_PIN(PIO_PORT(2),7,STPIO_IN);	/* COM_DIN */
+#endif
+
+	/* SPI is on PIO15:[3:0] */
+	SET_PIO_PIN(PIO_PORT(15),3,STPIO_IN);	/* SPI_DIN */
+	SET_PIO_PIN(PIO_PORT(15),0,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(15),1,STPIO_OUT);	/* SPI_DOUT */
+	SET_PIO_PIN(PIO_PORT(15),2,STPIO_OUT);	/* SPI_NOCS */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(15), 2, 1);	/* deassert SPI_NOCS */
+	STPIO_SET_PIN(PIO_PORT(15), 0, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), 1, 0);	/* deassert SPI_DOUT */
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	SET_PIO_ASC(PIO_PORT(0), 0, 1, 4, 3);  /* UART0 */
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 */
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 */
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	/* Route UART0 via PIO0 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG19;
+	/* PIO0[0] CFG19[16,8,0]   AltFunction = 4 */
+	/* PIO0[1] CFG19[17,9,1]   AltFunction = 4 */
+	/* PIO0[3] CFG19[19,11,3]  AltFunction = 4 */
+	/* PIO0[4] CFG19[20,12,4]  AltFunction = 4 */
+	sysconf &= ~0x1b1b1bul;	/* 7,7,0,7,7 */
+	sysconf |=  0x001b1bul;	/* 3,3,0,3,3 */
+	*STX7105_SYSCONF_SYS_CFG19 = sysconf;
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
+	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+
+#if defined(CONFIG_SPI)
+	/* Configure for SPI Serial Flash */
+	configSpi();
+#endif	/* CONFIG_SPI */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-PDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/pdk7105/pdk7105.romgen b/board/st/pdk7105/pdk7105.romgen
new file mode 100644
index 0000000..4c79ca4
--- /dev/null
+++ b/board/st/pdk7105/pdk7105.romgen
@@ -0,0 +1,2787 @@
+/* sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+ */
+/* Initialization TCK frequency set to 1562500 Hz
+ */
+/* Device id  0x1d43e041
+ */
+/* tapmux connect(): boot mode single core setup
+ */
+/* tapmux setup to bypass to core st40, channel 1
+ */
+/* sdk7105 initialization start ...
+ */
+/* sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+ */
+/* Chip infos
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+/*   Device ID = 0x1D43E041 ==> STi7105 cut 2
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+/*   Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+ */
+/*                              Boot mode ... : ST40 first
+ */
+/*                              Boot port size: 16-bits
+ */
+/*                              Boot device . : NOR flash
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f1016a4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+/* set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50
+ */
+/* Clock frequencies
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+/*   CKGA_PLL0HS     = 900.0 MHz
+ */
+/*   CKGA_PLL0LS     = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+/*   CKGA_PLL1       = 800.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+/*   ST40 ICK        = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+/*   LX DMU          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+/*   LX AUD          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+/*   FDMA0           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+/*   FDMA1           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+/*   STNOC           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+/*   IC_BDISP_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+/*   IC_DISP_200     = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+/*   IC_TS_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+/*   IC_COMPO_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+/*   IC_IF_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+/*   IC_IF_100       = 100.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+/*   DISP_PIPE_200   = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+/*   BLIT_PROC       = 266.7 MHz
+ */
+/*   IC_DELTA_200    = 266.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+/*   ETHERNET        = 25.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+/*   PCI             = 66.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+/*   EMI MASTER      = 100.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+/*   LMI2X           = 800.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200684f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200684f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200686f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200686f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00400000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002cfe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002cfe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002ffe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x20000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x20000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x28000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x28000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fb80000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fb80000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbdc00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbdc00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a00000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a00000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2280)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2280) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166c50) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166450) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001a)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242ed8)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x2c001e20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004363)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004263)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+/* Info: correcting interco reset setup
+ */
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+/* stx7105: booted audio companion
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+/* stx7105: booted video companion
+ */
+/* TCK frequency set to 12500000 Hz
+ */
+/* tapmux complete_connect(): single core setup
+ */
+/* sdk7105 initialization complete
+ */
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 7661160..f2e629e 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -29,7 +29,7 @@
 #include <command.h>
 #include <image.h>
 #include <malloc.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <bzlib.h>
 #include <environment.h>
 #include <asm/byteorder.h>
@@ -68,6 +68,9 @@ extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 #include <dataflash.h>
 #endif
 
+#if defined(CONFIG_SH4)
+#include <asm/addrspace.h>
+#endif	/* CONFIG_SH4 */
 /*
  * Some systems (for example LWMON) have very short watchdog periods;
  * we must make sure to split long operations like memmove() or
@@ -345,6 +348,61 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		break;
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
+#if defined(CONFIG_SH4)
+{
+		const uchar * const isizep =		/* pointer to ISIZE */
+			(uchar *)data + ntohl(hdr->ih_size) - 4;
+		const ulong isize =			/* ISIZE (gzip's Input Size) */
+			(ulong)(isizep[0]) << 0*8 |	/* i.e. the ORIGINAL UN-compressed size */
+			(ulong)(isizep[1]) << 1*8 |
+			(ulong)(isizep[2]) << 2*8 |
+			(ulong)(isizep[3]) << 3*8;
+		const ulong Cload = data;		/* compressed load address */
+		const ulong Csize = ntohl(hdr->ih_size);/* compressed size */
+		const ulong Cend  = Cload + Csize - 1;	/* compressed end address */
+		const ulong Uload = ntohl(hdr->ih_load);/* un-compressed load address */
+		const ulong Usize = isize;		/* un-compressed size */
+		const ulong Uend  = Uload + Usize - 1;	/* un-compressed end address */
+
+#if !defined(CONFIG_SH_SE_MODE)
+		/* assert ( IS_IN_P1_REGION(Uload) ); */
+		if ( (Uload < P1SEG) || (Uend >= P2SEG) )
+		{
+			printf ("\nwarning: Uncompressing to non-P1 region (0x%08x..0x%08x)\n",
+				Uload, Uend);
+			/* just a warning, so carry on! */
+		}
+#endif	/* CONFIG_SH_SE_MODE */
+
+		/* assert (Uload >= CFG_SDRAM_BASE); */
+		if ( PHYSADDR(Uload) < PHYSADDR(CFG_SDRAM_BASE) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is below RAM (0x%08x)\n",
+				Uload,
+				CFG_SDRAM_BASE);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert (Uend < CFG_MEMTEST_END); */
+		if ( PHYSADDR(Uend) >= PHYSADDR(CFG_MEMTEST_END) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is beyond safe RAM (0x%08x)\n",
+				Uend,
+				CFG_MEMTEST_END);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert ( (Cload > Uend) || (Uload > Cend) ); */
+		if ( !((PHYSADDR(Cload) > PHYSADDR(Uend)) || (PHYSADDR(Uload) > PHYSADDR(Cend))) )
+		{
+			printf ("\nERROR: Overlapping images (0x%08x..0x%08x) and (0x%08x..0x%08x)\n",
+				Cload, Cend,
+				Uload, Uend);
+			return 1;	/* unable to proceed */
+		}
+		unc_len = Usize;	/* we now know that it will fit okay */
+}
+#endif	/* CONFIG_SH4 */
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
 			    (uchar *)data, &len) != 0) {
 			puts ("GUNZIP ERROR - must RESET board to recover\n");
diff --git a/common/main.c b/common/main.c
index 379695c..4253eac 100644
--- a/common/main.c
+++ b/common/main.c
@@ -696,7 +696,7 @@ static void cread_add_str(char *str, int strsize, int insert, unsigned long *num
 	}
 }
 
-static int cread_line(char *buf, unsigned int *len)
+static int cread_line(const char *const prompt, char *buf, unsigned int *len)
 {
 	unsigned long num = 0;
 	unsigned long eol_num = 0;
@@ -818,6 +818,7 @@ static int cread_line(char *buf, unsigned int *len)
 			insert = !insert;
 			break;
 		case CTL_CH('x'):
+		case CTL_CH('u'):
 			BEGINNING_OF_LINE();
 			ERASE_TO_EOL();
 			break;
@@ -867,6 +868,27 @@ static int cread_line(char *buf, unsigned int *len)
 			REFRESH_TO_EOL();
 			continue;
 		}
+#ifdef CONFIG_AUTO_COMPLETE
+		case '\t': {
+			int num2, col;
+
+			/* do not autocomplete when in the middle */
+			if (num < eol_num) {
+				getcmd_cbeep();
+				break;
+			}
+
+			buf[num] = '\0';
+			col = strlen(prompt) + eol_num;
+			num2 = num;
+			if (cmd_auto_complete(prompt, buf, &num2, &col)) {
+				col = num2 - num;
+				num += col;
+				eol_num += col;
+			}
+			break;
+		}
+#endif
 		default:
 			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
 			break;
@@ -909,7 +931,7 @@ int readline (const char *const prompt)
 
 	puts (prompt);
 
-	rc = cread_line(p, &len);
+	rc = cread_line(prompt, p, &len);
 	return rc < 0 ? rc : len;
 #else
 	char   *p = console_buffer;
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
index 10e506c..2835bc9 100644
--- a/cpu/sh/Makefile
+++ b/cpu/sh/Makefile
@@ -23,25 +23,29 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(CPU).a
+LIB	= $(obj)lib$(CPU).a
 
 START	= start.o
-OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
-OBJS	+= ecc.o stm-nand.o cmd_copybbt.o	# NAND
-OBJS	+= sata-init.o sata-probe.o		# SATA
-OBJS	+= spi.o env_eeprom.o			# SPI
+COBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
+COBJS	+= ecc.o stm-nand.o cmd_copybbt.o	# NAND
+COBJS	+= sata-init.o sata-probe.o		# SATA
+COBJS	+= spi.o env_eeprom.o			# SPI
 SOBJS	=
 
-all:	.depend $(START) $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(OBJS) $(SOBJS)
-	$(AR) crv $@ $(OBJS) $(SOBJS)
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/config.mk b/cpu/sh/config.mk
index 2589ae2..b16c9b5 100644
--- a/cpu/sh/config.mk
+++ b/cpu/sh/config.mk
@@ -29,5 +29,4 @@
 PLATFORM_CPPFLAGS += -m4-nofpu -U__sh3__ -D__SH4__=1
 
 # all SH (ST40) CPUs will use the same linker script file
-LDSCRIPT := $(TOPDIR)/cpu/$(CPU)/u-boot.lds
-
+LDSCRIPT := $(SRCTREE)/cpu/$(CPU)/u-boot.lds
diff --git a/cpu/sh/spi.c b/cpu/sh/spi.c
index 969bac7..d7acf33 100644
--- a/cpu/sh/spi.c
+++ b/cpu/sh/spi.c
@@ -27,6 +27,7 @@
 #include <asm/socregs.h>
 #include <asm/io.h>
 #include <spi.h>
+#include <asm/clk.h>
 
 
 /**********************************************************************/
@@ -594,7 +595,7 @@ extern void spi_init(void)
 	unsigned long reg;
 	const unsigned long bits_per_word = 8;	/* one word == 8-bits */
 	const unsigned long mode = CFG_STM_SPI_MODE /* | SPI_LOOP */;
-	const unsigned long fcomms = gd->bd->bi_emifrq*1000*1000;
+	const unsigned long fcomms = get_peripheral_clk_rate();
 	const unsigned long hz = CFG_STM_SPI_FREQUENCY;
 	      unsigned long sscbrg = fcomms/(2*hz);
 
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 9918d8e..7d1b13c 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -283,6 +283,19 @@ set_pmb:
 #ifndef CONFIG_SH_NO_EPLD
 	SH4_SET_PMB 8 0xb6 0x06  16 0 0 1	/* EPLD UN-cached */
 #endif	/* CONFIG_SH_NO_EPLD */
+#elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_HDK7111)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  64 0 0 1	/* NOR/NAND/SPI FLASH UN-cached */
+	SH4_SET_PMB 5 0xa8 0x00  64		/* NOR/NAND/SPI FLASH CACHED */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NOR/NAND     FLASH UN-cached */
+	SH4_SET_PMB 7 0xa5 0x05  16 0 0 1	/* NOR/NAND     FLASH UN-cached */
+	SH4_SET_PMB 8 0xac 0x04  16		/* NOR/NAND     FLASH CACHED */
+	SH4_SET_PMB 9 0xad 0x05  16		/* NOR/NAND     FLASH CACHED */
 #elif defined(CONFIG_SH_STX7141) && defined(CONFIG_SH_MB628)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
diff --git a/cpu/sh/stb7100/Makefile b/cpu/sh/stb7100/Makefile
index 02ae195..fb2691f 100644
--- a/cpu/sh/stb7100/Makefile
+++ b/cpu/sh/stb7100/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stb7100.o
+COBJS	= stb7100.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/stx5197/Makefile b/cpu/sh/stx5197/Makefile
index 9c483e8..4458d80 100644
--- a/cpu/sh/stx5197/Makefile
+++ b/cpu/sh/stx5197/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stx5197.o
+COBJS	= stx5197.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/stx7105/Makefile b/cpu/sh/stx7105/Makefile
index 35cd852..4d165a4 100644
--- a/cpu/sh/stx7105/Makefile
+++ b/cpu/sh/stx7105/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stx7105.o
+COBJS	= stx7105.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
index 47280ee..d2b3b4f 100644
--- a/cpu/sh/stx7105/stx7105.c
+++ b/cpu/sh/stx7105/stx7105.c
@@ -184,7 +184,11 @@ int soc_init(void)
 	stx7105_clocks();
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
+#ifdef CONFIG_SYS_STM_GMAC_NOT_EXT_CLK
+	stmac_eth_hw_setup (0, 0, 0, 0, 0, 0);
+#else
 	stmac_eth_hw_setup (0, 0, 0, 0, 1, 0);
+#endif
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	bd->bi_devid = *STX7105_SYSCONF_DEVICEID_0;
@@ -204,18 +208,14 @@ int soc_init(void)
 
 
 #if defined(CONFIG_USB_OHCI_NEW)
-extern void stx7105_usb_init(void)
+extern int stx7105_usb_init(int port, int over_current, int power_ctrl)
 {
 	unsigned long reg;
 	const unsigned char oc_pins[2]    = {4, 6};	/* PIO4 */
 	const unsigned char power_pins[2] = {5, 7};	/* PIO4 */
-#if CFG_USB_BASE == CFG_USB0_BASE
-	const size_t port = 0;
-#elif CFG_USB_BASE == CFG_USB1_BASE
-	const size_t port = 1;
-#else
-#error Unknown USB Host Controller Base Address
-#endif
+
+	if (port >= sizeof(oc_pins))	/* invalid port number ? */
+		return -1;		/* failed to initialize! */
 
 	/* Power on the USB */
 	reg = readl(STX7105_SYSCONF_SYS_CFG32);
@@ -227,38 +227,44 @@ extern void stx7105_usb_init(void)
 	reg &= ~(1ul<<(6+port));
 	writel(reg, STX7105_SYSCONF_SYS_CFG32);
 
-	/* USB overcurrent enable */
-	reg = readl(STX7105_SYSCONF_SYS_CFG04);
-	/* USB0_PRT_OVCURR_POL = 0 = Active Low */
-	reg &= ~(1ul<<(3+port));
-	/* USBn_PRT_OVCURR_IN = 0 = PIO4[oc_pins[port]] */
-	reg &= ~(1ul<<(5+port));
-	/* CFG_USBn_OVRCURR_ENABLE = 1 = OC Enabled */
-	reg |= 1ul<<(11+port);
-	writel(reg, STX7105_SYSCONF_SYS_CFG04);
-
-	/* Route USBn OC Routing via PIO4[oc_pins[port]] */
-	reg = *STX7105_SYSCONF_SYS_CFG34;
-	/* PIO4[oc_pins[port]] CFG34[8+oc_pins[port],oc_pins[port]] = Alternate4 */
-	reg &= ~(0x0101ul<<(oc_pins[port]));	/* Mask=3 */
-	reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
-	*STX7105_SYSCONF_SYS_CFG34 = reg;
-	/* set PIO directionality, for OC as IN */
-	SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
-
-	/* Route USBn POWER Routing via PIO4[power_pins[port]] */
-	reg = *STX7105_SYSCONF_SYS_CFG34;
-	/* PIO4[power_pins[port]] CFG34[8+power_pins[port],power_pins[port]] = Alternate4 */
-	reg &= ~(0x0101ul<<(power_pins[port]));	/* Mask=3 */
-	reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
-	*STX7105_SYSCONF_SYS_CFG34 = reg;
-	/* set PIO directionality, for POWER as ALT_OUT */
-	SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+	if (over_current) {
+		/* USB overcurrent enable */
+		reg = readl(STX7105_SYSCONF_SYS_CFG04);
+		/* USB0_PRT_OVCURR_POL = 0 = Active Low */
+		reg &= ~(1ul<<(3+port));
+		/* USBn_PRT_OVCURR_IN = 0 = PIO4[oc_pins[port]] */
+		reg &= ~(1ul<<(5+port));
+		/* CFG_USBn_OVRCURR_ENABLE = 1 = OC Enabled */
+		reg |= 1ul<<(11+port);
+		writel(reg, STX7105_SYSCONF_SYS_CFG04);
+
+		/* Route USBn OC Routing via PIO4[oc_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[oc_pins[port]] CFG34[8+oc_pins[port],oc_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(oc_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for OC as IN */
+		SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
+	}
+
+	if (power_ctrl) {
+		/* Route USBn POWER Routing via PIO4[power_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[power_pins[port]] CFG34[8+power_pins[port],power_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(power_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for POWER as ALT_OUT */
+		SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+	}
 
 	/* start the USB Wrapper Host Controller */
 	ST40_start_host_control(
 		USB_FLAGS_STRAP_8BIT |
 		USB_FLAGS_STBUS_CONFIG_THRESHOLD128);
+
+	return 0;
 }
 
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
@@ -310,7 +316,7 @@ extern void stx7105_spi_sda(const int val)
 extern unsigned char stx7105_spi_read(void)
 {
 	const int pin = 3;	/* PIO15[3] = SPI_DIN */
-	return STPIO_GET_PIN(15, pin);
+	return STPIO_GET_PIN(PIO_PORT(15), pin);
 }
 
 /*
diff --git a/cpu/sh/stx7111/Makefile b/cpu/sh/stx7111/Makefile
index 8a78032..22e0ae0 100644
--- a/cpu/sh/stx7111/Makefile
+++ b/cpu/sh/stx7111/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stx7111.o
+COBJS	= stx7111.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/stx7111/stx7111.c b/cpu/sh/stx7111/stx7111.c
index 70ea7de..a9f43cf 100644
--- a/cpu/sh/stx7111/stx7111.c
+++ b/cpu/sh/stx7111/stx7111.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -31,6 +31,7 @@
 #include <asm/pio.h>
 #include <asm/stbus.h>
 #include <ata.h>
+#include <spi.h>
 
 #define PIO_BASE  ST40_PIO0_REGS_BASE
 
@@ -42,7 +43,7 @@ static void stx7111_clocks(void)
 	/*
 	 * FIXME
 	 * Gross hack to get the serial port working.
-	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * See the definition of PCLK in drivers/stm-asc.c
 	 * for where this is used.
 	 */
 	bd->bi_emifrq = 100;
@@ -65,10 +66,8 @@ extern int stmac_default_pbl(void)
 
 extern void stmac_set_mac_speed(int speed)
 {
-	/* QQQ: check this code is actually correct for the 7111 */
 	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
 
-//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
 	/* MAC_SPEED_SEL = 0|1 */
 	if (speed == 100)
 		sysconf |= MAC_SPEED_SEL;
@@ -96,7 +95,7 @@ static void stmac_eth_hw_setup(void)
 	else
 		sysconf &= ~PHY_CLK_EXT;
 
-	/* Default GMII/MII slection */
+	/* Default GMII/MII selection */
 	sysconf &= ~PHY_INTF_SEL_MASK;
 	sysconf |= ((sel<<24) & PHY_INTF_SEL_MASK);
 
@@ -143,7 +142,7 @@ extern void stx7111_usb_init(void)
 	/* Work around for USB over-current detection chip being
 	 * active low, and the 7111 being active high.
 	 * Note this is an undocumented bit, which apparently enables
-	 * an inverter on the overcurrent signal.
+	 * an inverter on the over-current signal.
 	 */
 	reg = readl(STX7111_SYSCONF_SYS_CFG06);
 	reg |= 1ul<<29;
@@ -189,3 +188,71 @@ extern void stx7111_usb_init(void)
 
 #endif /* defined(CONFIG_USB_OHCI_NEW) */
 
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI)
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void stx7111_spi_scl(const int val)
+{
+	const int pin = 0;	/* PIO2[0] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(2), pin, val ? 1 : 0);
+}
+
+extern void stx7111_spi_sda(const int val)
+{
+	const int pin = 1;	/* PIO2[1] = SPI_DOUT */
+	STPIO_SET_PIN(PIO_PORT(2), pin, val ? 1 : 0);
+}
+
+extern unsigned char stx7111_spi_read(void)
+{
+	const int pin = 2;	/* PIO2[2] = SPI_DIN */
+	return STPIO_GET_PIN(PIO_PORT(2), pin);
+}
+#else
+#error Still to impliment SPI via SSC for the STx7111.
+#endif	/* CONFIG_SOFT_SPI */
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ *
+ * this is used for both S/W bit-banging, and H/W SSC.
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 7;	/* PIO6[7] = SPI_NOTCS */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(6), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(6), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+
+#endif	/* CONFIG_SPI */
+
+
diff --git a/cpu/sh/stx7141/Makefile b/cpu/sh/stx7141/Makefile
index d053c92..e400ff6 100644
--- a/cpu/sh/stx7141/Makefile
+++ b/cpu/sh/stx7141/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stx7141.o
+COBJS	= stx7141.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/stx7200/Makefile b/cpu/sh/stx7200/Makefile
index 51950cf..4727902 100644
--- a/cpu/sh/stx7200/Makefile
+++ b/cpu/sh/stx7200/Makefile
@@ -23,21 +23,25 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(SOC).a
+LIB	= $(obj)lib$(SOC).a
 
-OBJS	= stx7200.o
+COBJS	= stx7200.o
 SOBJS	=
 
-all:	.depend $(LIB)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
 
-$(LIB):	$(SOBJS) $(OBJS)
-	$(AR) crv $@ $(SOBJS) $(OBJS)
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
diff --git a/cpu/sh/u-boot.lds b/cpu/sh/u-boot.lds
index 04595d9..2b60636 100644
--- a/cpu/sh/u-boot.lds
+++ b/cpu/sh/u-boot.lds
@@ -4,6 +4,10 @@
  * Stuart Menefy <stuart.menefy@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 6470f22..1f9bcc6 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -36,7 +36,7 @@ extern void stb7100_usb_init(void);
 #elif defined(CONFIG_SH_STX5197)
 extern void stx5197_usb_init(void);
 #elif defined(CONFIG_SH_STX7105)
-extern void stx7105_usb_init(void);
+extern int stx7105_usb_init(int port, int over_current, int power_ctrl);
 #elif defined(CONFIG_SH_STX7111)
 extern void stx7111_usb_init(void);
 #elif defined(CONFIG_SH_STX7141)
@@ -56,7 +56,16 @@ extern int usb_cpu_init(void)
 #elif defined(CONFIG_SH_STX5197)
 	stx5197_usb_init();
 #elif defined(CONFIG_SH_STX7105)
-	stx7105_usb_init();
+#ifdef CONFIG_SH_STX_STX7105_USB_PORT0
+	stx7105_usb_init(0,
+			 CONFIG_SH_STX_STX7105_USB_OC,
+			 CONFIG_SH_STX_STX7105_USB_PW);
+#endif
+#ifdef CONFIG_SH_STX_STX7105_USB_PORT1
+	stx7105_usb_init(1,
+			 CONFIG_SH_STX_STX7105_USB_OC,
+			 CONFIG_SH_STX_STX7105_USB_PW);
+#endif
 #elif defined(CONFIG_SH_STX7111)
 	stx7111_usb_init();
 #elif defined(CONFIG_SH_STX7141)
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index b552e0a..4dbeb03 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -936,6 +936,19 @@ static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset
 	volatile cfiptr_t addr;
 	cfiword_t cword;
 
+	/*
+	 *	We need to ensure that sizeof(cword) >= info->portwidth,
+	 *	otherwise, flash_make_cmd() will scribble over memory
+	 *	it should not! This results in a stack corruption,
+	 *	and madness follows...	Sean McGoogan 2009-08-20.
+	 */
+	if ( info->portwidth > sizeof(cword) ) {
+		printf("ERROR: %s() ignoring write request (info->portwidth=%u)\n",
+			__FUNCTION__,
+			info->portwidth);
+		return;
+	}
+
 	addr.cp = flash_make_addr (info, sect, offset);
 	flash_make_cmd (info, cmd, &cword);
 	switch (info->portwidth) {
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index d7504c0..9b9ee10 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -45,6 +45,11 @@
 /* do we want to put the PHY in loop-back mode ? */
 /* #define CONFIG_PHY_LOOPBACK */
 
+/* do we want to dump the first 14-bytes of each
+ * RX/TX ethernet packet (i.e. the IEEE 802.3 MAC,
+ * (or RFC 894/1042) encapsulation header ? */
+/* #define DUMP_ENCAPSULATION_HEADER */
+
 /* prefix to use for diagnostics */
 #ifdef CONFIG_DRIVER_NETSTMAC
 #	define STMAC	"STM-MAC: "
@@ -160,6 +165,18 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define KSZ8041FTL_PHY_ID	0x00221512u
 #define KSZ8041FTL_PHY_ID_MASK	0x01ffffffu
 
+#elif defined(CONFIG_STMAC_IP1001)	/* IC+ IP1001 */
+
+/* IC+ IP1001 phy identifier values */
+#define IP1001_PHY_ID		0x02430d90u
+#define IP1001_PHY_ID_MASK	0xfffffff0u
+
+#elif defined(CONFIG_STMAC_78Q2123)	/* TERIDIAN 78Q2123 */
+
+/* TERIDIAN 78Q2123 phy identifier values */
+#define TERIDIAN_PHY_ID		0x000e7230u
+#define TERIDIAN_PHY_ID_MASK	0xfffffff0u
+
 #else
 #error Need to define which PHY to use
 #endif
@@ -169,6 +186,7 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define MII_ADVERTISE_PAUSE 0x0400	/* supports the pause command */
 
 
+#ifndef CONFIG_PHY_LOOPBACK
 static int stmac_phy_negotiate (int phy_addr)
 {
 	uint now, tmp, status;
@@ -246,17 +264,17 @@ static unsigned int stmac_phy_check_speed (int phy_addr)
 	stmac_set_mac_mii_cap (full_duplex, speed);
 	return 0;
 }
+#endif	/* CONFIG_PHY_LOOPBACK */
 
 /* Automatically gets and returns the PHY device */
 static unsigned int stmac_phy_get_addr (void)
 {
-	unsigned int i;
+	unsigned int i, id;
 
 	for (i = 0; i < 32; i++) {
-		unsigned int id1, id2, id;
 		unsigned int phyaddr = (i + 1u) % 32u;
-		id1 = stmac_mii_read (phyaddr, MII_PHYSID1);
-		id2 = stmac_mii_read (phyaddr, MII_PHYSID2);
+		unsigned int id1 = stmac_mii_read (phyaddr, MII_PHYSID1);
+		unsigned int id2 = stmac_mii_read (phyaddr, MII_PHYSID2);
 		id  = (id1 << 16) | (id2);
 		/* Make sure it is a valid (known) identifier */
 #if defined(CONFIG_STMAC_STE10XP)
@@ -282,10 +300,22 @@ static unsigned int stmac_phy_get_addr (void)
 			printf (STMAC "KSZ8041FTL found\n");
 			return phyaddr;
 		}
+#elif defined(CONFIG_STMAC_IP1001)
+		if ((id & IP1001_PHY_ID_MASK) == IP1001_PHY_ID) {
+			printf (STMAC "IC+ IP1001 found\n");
+			return phyaddr;
+		}
+#elif defined(CONFIG_STMAC_78Q2123)
+		if ((id & TERIDIAN_PHY_ID_MASK) == TERIDIAN_PHY_ID) {
+			printf (STMAC "TERIDIAN 78Q2123 found\n");
+			return phyaddr;
+		}
+#else
+#error Need to define which PHY to use
 #endif	/* CONFIG_STMAC_STE10XP */
 	}
 
-	printf (STMAC "Unable to find a PHY (unknown ID?)\n");
+	printf (STMAC "Unable to find a known PHY (ID=0x%08x)\n", id);
 	return (-1);
 }
 
@@ -313,13 +343,20 @@ static int stmac_phy_init (void)
 	value = stmac_mii_read (eth_phy_addr, PHY_SUP_REG);
 #elif defined(CONFIG_STMAC_KSZ8041FTL)
 	/* The Micrel KSZ8041FTL does not appear to support
-	 * reading the H/W PHY address from any register.
-	 * So, we bypass the following test.
-	 */
+	 * reading the H/W PHY address from any register.  */
+#	define CONFIG_STMAC_BYPASS_ADDR_MISMATCH
+#elif defined(CONFIG_STMAC_IP1001)
+	/* The IC+ IP1001 does not appear to support
+	 * reading the H/W PHY address from any register.  */
+#	define CONFIG_STMAC_BYPASS_ADDR_MISMATCH
+#elif defined(CONFIG_STMAC_78Q2123)
+	/* The TERIDIAN 78Q2123 does not appear to support
+	 * reading the H/W PHY address from any register.  */
+#	define CONFIG_STMAC_BYPASS_ADDR_MISMATCH
 #else
-#error Need to define PHY
+#error Need to define which PHY to use
 #endif
-#if !defined(CONFIG_STMAC_KSZ8041FTL)
+#if !defined(CONFIG_STMAC_BYPASS_ADDR_MISMATCH)
 	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
 	if (value != eth_phy_addr) {
 		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
@@ -355,14 +392,40 @@ static int stmac_phy_init (void)
 	/* Update our Auto-Neg Advertisement Register */
 	stmac_mii_write (eth_phy_addr, MII_ADVERTISE, advertised_caps);
 
-	stmac_phy_negotiate (eth_phy_addr);
-	stmac_phy_check_speed (eth_phy_addr);
+	/*
+	 * For Gigabit capable PHYs, then we will disable the
+	 * ability to auto-negotiate at 1000BASE-T (Gigabit).
+	 * Once ST's SoCs are capable of Gigabit, then we will review!
+	 */
+#if defined(CONFIG_STMAC_IP1001)
+	value = stmac_mii_read (eth_phy_addr, MII_GBCR);
+	value &= ~(GBCR_1000HALF|GBCR_1000FULL);
+	stmac_mii_write (eth_phy_addr, MII_GBCR, value);
+#endif
 
 #ifdef CONFIG_PHY_LOOPBACK
+
 	/* put the PHY in loop-back mode, if required */
+	printf ( STMAC "Forcing PHY loop-back at full-duplex, 100Mbps\n");
 	value = stmac_mii_read (eth_phy_addr, MII_BMCR);
-	value |= BMCR_LOOPBACK;
+	value |= BMCR_LOOPBACK;		/* enable loop-back mode (in the PHY) */
+	value &= ~BMCR_ANENABLE;	/* disable auto-negotiation */
+	value &= ~BMCR_SPEED_MASK;	/* clear all speed bits */
+	value |= BMCR_SPEED100;		/* set speed to 100Mbps */
+	value |= BMCR_FULLDPLX;		/* enable full-duplex */
 	stmac_mii_write (eth_phy_addr, MII_BMCR, value);
+	/* ensure the write completes! */
+	(void)stmac_mii_read (eth_phy_addr, MII_BMCR);
+
+	/* set the MAC capabilities appropriately */
+	stmac_set_mac_mii_cap (1, 100);	/* 100Mbps, full-duplex */
+
+#else	/* CONFIG_PHY_LOOPBACK */
+
+	/* auto-negotiate with remote link partner */
+	stmac_phy_negotiate (eth_phy_addr);
+	stmac_phy_check_speed (eth_phy_addr);
+
 #endif	/* CONFIG_PHY_LOOPBACK */
 
 	return 0;
@@ -1082,7 +1145,7 @@ static void stmac_eth_rx (void)
 			 * the CRC */
 			frame_len = drx->des01.rx.frame_length;
 			if ((frame_len >= 0) && (frame_len <= PKTSIZE_ALIGN)) {
-#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK) || defined(DUMP_ENCAPSULATION_HEADER)
 				const unsigned char *p = rx_packets[cur_rx];
 				printf("\nRX[%d]:  0x%08x ", cur_rx, p);
 				printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
@@ -1260,7 +1323,7 @@ extern int eth_rx (void)
 extern int eth_send (volatile void *packet, int length)
 {
 	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
-#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK) || defined(DUMP_ENCAPSULATION_HEADER)
 	const unsigned char * p = (const unsigned char*)packet;
 	printf("TX   :  0x%08x ", p);
 	printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
diff --git a/drivers/net/stm-stmac.h b/drivers/net/stm-stmac.h
index 6890f70..b871e97 100644
--- a/drivers/net/stm-stmac.h
+++ b/drivers/net/stm-stmac.h
@@ -208,18 +208,22 @@
 #define MII_ADVERTISE			0x04		/* AN Advertisement Control Register */
 #define MII_LPA				0x05		/* AN Link Partner Ability Register */
 //#define MII_EXPANSION			0x06		/* AN Expansion Register */
+#define MII_GBCR			0x09		/* 1000BASE-T Control Register */
+//#define MII_GBSR			0x0A		/* 1000BASE-T Status Register */
 
 /* Basic Mode Control Register defines */
-//#define BMCR_SPEED1000		0x0040		/* MSB of Speed (1000) */
 //#define BMCR_CTST			0x0080		/* Collision Test */
-//#define BMCR_FULLDPLX			0x0100		/* Full Duplex */
+#define BMCR_FULLDPLX			0x0100		/* Full Duplex */
 #define BMCR_ANRESTART			0x0200		/* Auto-Negotiation Restart */
 //#define BMCR_ISOLATE			0x0400		/* Disconnect from the MII */
 //#define BMCR_PDOWN			0x0800		/* Power-down */
 #define BMCR_ANENABLE			0x1000		/* Enable Auto-Negotiation */
-//#define BMCR_SPEED100			0x2000		/* Select 100Mbps */
 #define BMCR_LOOPBACK			0x4000		/* Enable Loop-back Mode */
 //#define BMCR_RESET			0x8000		/* Software Reset */
+#define BMCR_SPEED1000			0x0040		/* Select 1000Mbps */
+#define BMCR_SPEED100			0x2000		/* Select 100Mbps */
+#define BMCR_SPEED10			0x0000		/* Select 10Mbps */
+#define BMCR_SPEED_MASK			(BMCR_SPEED100|BMCR_SPEED1000)
 
 /* Basic Mode Status Register defines */
 //#define BMSR_ERCAP			0x0001		/* Extended Capabilities Registers */
@@ -261,6 +265,10 @@
 //#define LPA_DUPLEX			(LPA_10FULL | LPA_100FULL)
 //#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
 
+/* 1000BASE-T Control Register defines */
+#define GBCR_1000HALF			0x0100		/* Try for 1000Mbps half-duplex */
+#define GBCR_1000FULL			0x0200		/* Try for 1000Mbps full-duplex */
+
 
 /*----------------------------------------------------------------------------
  *			Descriptor Structure
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
index d84c54f..fec4bbc 100644
--- a/drivers/serial/stm-asc.c
+++ b/drivers/serial/stm-asc.c
@@ -21,6 +21,7 @@
 #include "asm/io.h"
 #include "asm/pio.h"
 #include "asm/socregs.h"
+#include "asm/clk.h"
 
 #define CS7		0000040
 #define CS8		0000060
@@ -85,7 +86,7 @@
 /*---- Values for the BAUDRATE Register -----------------------*/
 
 #if defined(__SH4__)
-#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define PCLK			(get_peripheral_clk_rate())
 #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
 #define BAUDRATE_VAL_M1(bps)	((((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
 #else	/* !defined(__SH4__) */
diff --git a/drivers/usb/usb_ohci.c b/drivers/usb/usb_ohci.c
index cb06316..3c64aba 100644
--- a/drivers/usb/usb_ohci.c
+++ b/drivers/usb/usb_ohci.c
@@ -122,11 +122,11 @@
  * e.g. PCI controllers need this
  */
 #ifdef CFG_OHCI_SWAP_REG_ACCESS
-# define readl(a) __swap_32(*((vu_long *)(a)))
-# define writel(a, b) (*((vu_long *)(b)) = __swap_32((vu_long)a))
+# define readl(a) __swap_32(*((volatile u32 *)(a)))
+# define writel(a, b) (*((volatile u32 *)(b)) = __swap_32((volatile u32)a))
 #else
-# define readl(a) (*((vu_long *)(a)))
-# define writel(a, b) (*((vu_long *)(b)) = ((vu_long)a))
+# define readl(a) (*((volatile u32 *)(a)))
+# define writel(a, b) (*((volatile u32 *)(b)) = ((volatile u32)a))
 #endif /* CFG_OHCI_SWAP_REG_ACCESS */
 
 #define min_t(type,x,y) ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
diff --git a/examples/Makefile b/examples/Makefile
index 9aa829b..b2d448e 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -62,12 +62,8 @@ LOAD_ADDR = 0x00000000
 endif
 
 ifeq ($(ARCH),sh)
-include $(TOPDIR)/include/config.mk
-ifneq (,$(findstring $(BOARD),mb411 mb442))
-LOAD_ADDR = 0x84000000
-else
-LOAD_ADDR = 0x88000000
-endif
+include $(OBJTREE)/include/autoconf.mk
+LOAD_ADDR = $(CFG_SDRAM_BASE)
 endif
 
 include $(TOPDIR)/config.mk
diff --git a/examples/stubs.c b/examples/stubs.c
index 3f965b0..7dc686a 100644
--- a/examples/stubs.c
+++ b/examples/stubs.c
@@ -153,22 +153,23 @@ gd_t *global_data;
 		: "r8");
 #elif defined(CONFIG_SH4)
 /*
- * r13 holds the pointer to the global_data. r0 is a call-clobbered.
+ * r13 holds the pointer to the global_data (read-only).
+ * r0 & r1 are call-clobbered (clobbered).
  */
 #define EXPORT_FUNC(x)				\
-do {						\
-	int o;					\
 	asm volatile (				\
-	".globl " #x "\n"			\
-	#x ":");				\
-	o=offsetof(gd_t, jt);			\
-	asm volatile (				\
-		"mov.l	@(%0, r13), r0\n"	\
-	"	mov.l	@(r0, %1), r0\n"	\
-	"	jmp	@r0\n"			\
-	"	nop\n"				\
-	: "+z"(o) : "r"(XF_ ## x * sizeof(void *))) ; \
-} while (0);
+"	.globl " #x "\n"			\
+#x ":\n"					\
+"	mov	%[jt], r0\n"			\
+"	mov.l	@(r0, r13), r1\n"		\
+"	mov	%[func], r0\n"			\
+"	mov.l	@(r0, r1), r0\n"		\
+"	jmp	@r0\n"				\
+"	  nop\n"				\
+	: /* No outputs */			\
+	: [jt]   "i"(offsetof(gd_t, jt)),	\
+	  [func] "i"(XF_ ## x * sizeof(void *))	\
+	: "r0", "r1");
 #else
 #error stubs definition missing for this architecture
 #endif
diff --git a/fs/cramfs/uncompress.c b/fs/cramfs/uncompress.c
index 2e906eb..fc26f93 100644
--- a/fs/cramfs/uncompress.c
+++ b/fs/cramfs/uncompress.c
@@ -23,7 +23,7 @@
 #include <common.h>
 #include <malloc.h>
 #include <watchdog.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 
 #if defined(CONFIG_CMD_JFFS2)
 
diff --git a/include/asm-sh/clk.h b/include/asm-sh/clk.h
new file mode 100644
index 0000000..0fbf721
--- /dev/null
+++ b/include/asm-sh/clk.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2009 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_SH_CLK_H__
+#define __ASM_SH_CLK_H__
+
+static inline unsigned long get_peripheral_clk_rate(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	const bd_t * const bd = gd->bd;
+
+	/* Return Peripheral Clock in Hz. */
+	return bd->bi_emifrq * 1000000;
+}
+
+static inline unsigned long get_tmu0_clk_rate(void)
+{
+
+	/* Return Clock in Hz. */
+	return get_peripheral_clk_rate();
+}
+
+#endif /* __ASM_SH_CLK_H__ */
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index ba0bd4b..76821ea 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -56,6 +56,7 @@
        defined(CONFIG_SH_HMS1)		|| \
        defined(CONFIG_SH_MB519)		|| \
        defined(CONFIG_SH_MB618)		|| \
+       defined(CONFIG_SH_HDK7111)	|| \
        defined(CONFIG_SH_MB628)		|| \
        defined(CONFIG_SH_MB671)		|| \
        defined(CONFIG_SH_MB680)		|| \
diff --git a/include/asm-sh/pio.h b/include/asm-sh/pio.h
index 845157c..f92d4f7 100644
--- a/include/asm-sh/pio.h
+++ b/include/asm-sh/pio.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright STMicroelectronics 2005, 2008
+ * (C) Copyright STMicroelectronics 2005, 2008, 2009
  * Andy Stugres, <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -83,8 +83,8 @@ do {								\
 		(PIO_ADDR) + STPIO_POUT_OFFSET +		\
 		((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));	\
 } while (0)
-#define STPIO_GET_PIN(PORT, PIN)				\
-	((readl(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
+#define STPIO_GET_PIN(PIO_ADDR, PIN)				\
+	((readl((PIO_ADDR)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
 
 #define SET_PIO_ASC_OUTDIR(PIO_ADDR, TX, RX, CTS, RTS, OUTDIR)	\
 do {								\
diff --git a/include/asm-sh/sh4reg.h b/include/asm-sh/sh4reg.h
index 2c128de..41e8704 100644
--- a/include/asm-sh/sh4reg.h
+++ b/include/asm-sh/sh4reg.h
@@ -106,18 +106,18 @@
  */
 
 /* Timer Unit control registers (common to all SH4 variants) */
-#define SH4_TMU_TOCR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x00)
-#define SH4_TMU_TSTR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x04)
-#define SH4_TMU_TCOR0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x08)
-#define SH4_TMU_TCNT0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x0c)
-#define SH4_TMU_TCR0	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x10)
-#define SH4_TMU_TCOR1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x14)
-#define SH4_TMU_TCNT1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x18)
-#define SH4_TMU_TCR1	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x1c)
-#define SH4_TMU_TCOR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x20)
-#define SH4_TMU_TCNT2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x24)
-#define SH4_TMU_TCR2	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x28)
-#define SH4_TMU_TCPR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x2c)
+#define TOCR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x00)
+#define TSTR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x04)
+#define TCOR0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x08)
+#define TCNT0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x0c)
+#define TCR0	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x10)
+#define TCOR1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x14)
+#define TCNT1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x18)
+#define TCR1	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x1c)
+#define TCOR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x20)
+#define TCNT2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x24)
+#define TCR2	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x28)
+#define TCPR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x2c)
 
 /* Real Time Clock control registers (common to all SH4 variants) */
 #define SH4_RTC_R64CNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x00)
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
index 5b5ac45..ea25be4 100644
--- a/include/asm-sh/soc.h
+++ b/include/asm-sh/soc.h
@@ -60,5 +60,9 @@ extern void		stx7105_spi_scl(const int val);
 extern void		stx7105_spi_sda(const int val);
 extern unsigned char	stx7105_spi_read(void);
 
+extern void		stx7111_spi_scl(const int val);
+extern void		stx7111_spi_sda(const int val);
+extern unsigned char	stx7111_spi_read(void);
+
 #endif	/* _SOC_H_ */
 
diff --git a/include/common.h b/include/common.h
index 72ca995..25e3c9e 100644
--- a/include/common.h
+++ b/include/common.h
@@ -583,6 +583,7 @@ void	wait_ticks    (unsigned long);
 
 /* lib_$(ARCH)/time.c */
 void	udelay	      (unsigned long);
+void	ndelay        (unsigned long nsec);
 ulong	usec2ticks    (unsigned long usec);
 ulong	ticks2usec    (unsigned long ticks);
 int	init_timebase (void);
diff --git a/include/configs/5197cab.h b/include/configs/5197cab.h
index 18a7069..93c5573 100644
--- a/include/configs/5197cab.h
+++ b/include/configs/5197cab.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Are we booting directly from a SPI Serial Flash device ?
@@ -178,14 +176,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"5197CAB> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/cb101.h b/include/configs/cb101.h
index 547b337..a715b7c 100644
--- a/include/configs/cb101.h
+++ b/include/configs/cb101.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -191,14 +189,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"CB101> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/cb102.h b/include/configs/cb102.h
index cb48bee..5b996e0 100644
--- a/include/configs/cb102.h
+++ b/include/configs/cb102.h
@@ -34,8 +34,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -176,14 +174,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"CB102> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/hdk7111.h b/include/configs/hdk7111.h
new file mode 100644
index 0000000..a4bdd10
--- /dev/null
+++ b/include/configs/hdk7111.h
@@ -0,0 +1,424 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ *
+ * NOTE: it is the user's responsibility to ensure that
+ * EMI Bank #1 (CSB) is programmed to be large enough
+ * to access all of the NOR flash (32MiB), when it is "swapped"
+ * with EMI Bank #1 (CBA), when booting from NAND.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI serial flash */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND flash */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else					/* else, we are booting from NOR flash */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD hdk7111
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use (UART2 == JD1) */
+#define CFG_STM_ASC_BASE	ST40_ASC2_REGS_BASE	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There is only 1 option for ethernet:
+ * using the on-chip ST-GMAC, with the on-board Teridian PHY.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_78Q2123			/* PHY = TERIDIAN 78Q2123 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HDK7111> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND or NOR devices)
+ * With the HDK7111 board, we may use all three of
+ * SPI, NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* NOR Flash: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	UD4	ST	M25P16
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (UD4) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+	/* NOTE: Not yet implemented SPI over SSC for STx7111 */
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7111_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7111_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7111_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hms1.h b/include/configs/hms1.h
index 6cf3054..63cf6e7 100644
--- a/include/configs/hms1.h
+++ b/include/configs/hms1.h
@@ -35,7 +35,6 @@
 
 #define INPUT_CLOCK_RATE 27
 
-#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -224,7 +223,7 @@
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024)		/* HZ for timer ticks		*/
+#define CFG_HZ			1000		/* HZ for timer ticks		*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/ipidtv7105.h b/include/configs/ipidtv7105.h
index 29ab450..8f85dc0 100644
--- a/include/configs/ipidtv7105.h
+++ b/include/configs/ipidtv7105.h
@@ -33,9 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
-
 
 /*-----------------------------------------------------------------------
  * Are we booting directly from a NAND Flash device ?
@@ -186,6 +183,9 @@
 #	define CFG_USB0_BASE			0xfe100000	/* CN10 upper slot */
 #	define CFG_USB1_BASE			0xfea00000	/* CN10 lower slot */
 #	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
 #	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
 #	define CFG_USB_OHCI_SLOT_NAME		"ohci"
 #	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
@@ -224,14 +224,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"IPIDTV7105> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
index d92710a..0a7a5d3 100644
--- a/include/configs/mb411.h
+++ b/include/configs/mb411.h
@@ -35,7 +35,6 @@
 
 #define INPUT_CLOCK_RATE 27
 
-#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -247,7 +246,7 @@
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024)		/* HZ for timer ticks		*/
+#define CFG_HZ			1000		/* HZ for timer ticks		*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
index 9620048..e03fb93 100644
--- a/include/configs/mb442.h
+++ b/include/configs/mb442.h
@@ -38,7 +38,6 @@
 #define INPUT_CLOCK_RATE 30
 #endif
 
-#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -241,7 +240,7 @@
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
index cdbcf20..428021a 100644
--- a/include/configs/mb448.h
+++ b/include/configs/mb448.h
@@ -35,7 +35,6 @@
 
 #define INPUT_CLOCK_RATE 27
 
-#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -212,14 +211,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB448> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index 2cb7da9..fd60ad9 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -221,14 +219,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB519> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
index faa67d5..e0cef67 100644
--- a/include/configs/mb618.h
+++ b/include/configs/mb618.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -198,14 +196,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB618> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
index 1d6b531..5ce3021 100644
--- a/include/configs/mb628.h
+++ b/include/configs/mb628.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -218,14 +216,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB628> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
index 0c4ff2d..d1d94c1 100644
--- a/include/configs/mb671.h
+++ b/include/configs/mb671.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
@@ -218,14 +216,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB671> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index 21c1fe9..f27e9cf 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Are we booting directly from a NAND Flash device ?
@@ -207,6 +205,9 @@
 #	define CFG_USB0_BASE			0xfe100000	/* upper */
 #	define CFG_USB1_BASE			0xfea00000	/* lower */
 #	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
 #	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
 #	define CFG_USB_OHCI_SLOT_NAME		"ohci"
 #	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
@@ -245,14 +246,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB680> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/mb704.h b/include/configs/mb704.h
index f0cdfde..3bdd870 100644
--- a/include/configs/mb704.h
+++ b/include/configs/mb704.h
@@ -33,8 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
  * Are we booting directly from a SPI Serial Flash device ?
@@ -191,14 +189,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"MB704> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
index 61cd318..bac7f0b 100644
--- a/include/configs/pdk7105.h
+++ b/include/configs/pdk7105.h
@@ -33,9 +33,6 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
 
-/* This should really be replaced with something which uses bd->...	*/
-#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
-
 
 /*-----------------------------------------------------------------------
  *	Jumper settings to select between the SoC's 3 boot-modes:
@@ -225,6 +222,9 @@
 #	define CFG_USB0_BASE			0xfe100000	/* rear (adjacent to RJ-45) */
 #	define CFG_USB1_BASE			0xfea00000	/* front (near corner) */
 #	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
 #	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
 #	define CFG_USB_OHCI_SLOT_NAME		"ohci"
 #	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
@@ -263,14 +263,14 @@
  */
 
 #define CFG_HUSH_PARSER		1
-#define CFG_AUTO_COMPLETE	1
+#define CONFIG_AUTO_COMPLETE	1
 #define CFG_LONGHELP		1		/* undef to save memory		*/
 #define CFG_PROMPT		"PDK7105> "	/* Monitor Command Prompt	*/
 #define CFG_PROMPT_HUSH_PS2	"> "
 #define CFG_CBSIZE		1024
 #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
 #define CFG_MAXARGS		16		/* max number of command args	*/
-#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
 #define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
 #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
 #define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
diff --git a/include/sh-sci.h b/include/sh-sci.h
index 083e8ae..ace813b 100644
--- a/include/sh-sci.h
+++ b/include/sh-sci.h
@@ -11,6 +11,7 @@
  */
 
 #include "common.h"
+#include <asm/clk.h>
 
 #include <linux/config.h>
 
@@ -347,9 +348,9 @@ SCIx_FNS (SCSMR, 0x00, 8, 0x00, 8, 0x00, 8, 0x00, 16)
  * -- Mitch Davis - 15 Jul 2000
  */
 #if defined(CONFIG_CPU_SUBTYPE_SH7300)
-#define SCBRR_VALUE(bps) ((P_CLOCK_RATE+16*bps)/(16*bps)-1)
+#define SCBRR_VALUE(bps) ((get_peripheral_clk_rate()+16*bps)/(16*bps)-1)
 #else
-#define SCBRR_VALUE(bps) ((P_CLOCK_RATE+16*bps)/(32*bps)-1)
+#define SCBRR_VALUE(bps) ((get_peripheral_clk_rate()+16*bps)/(32*bps)-1)
 #endif
 #define BPS_2400       SCBRR_VALUE(2400)
 #define BPS_4800       SCBRR_VALUE(4800)
diff --git a/include/u-boot/zlib.h b/include/u-boot/zlib.h
new file mode 100644
index 0000000..ef9be07
--- /dev/null
+++ b/include/u-boot/zlib.h
@@ -0,0 +1,698 @@
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-1.2.3
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+ /*
+  * ==FILEVERSION 960122==
+  *
+  * This marker is used by the Linux installation script to determine
+  * whether an up-to-date version of this file is already installed.
+  */
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230
+
+/* #include "zconf.h" */        /* included directly here */
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* Begin of new zconf.h */
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+/* End of new zconf.h */
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt size));
+typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+	Bytef	*next_in; /* next input byte */
+	uInt	avail_in; /* number of bytes available at next_in */
+	uLong	total_in; /* total nb of input bytes read so far */
+	Bytef	*next_out; /* next output byte should be put there */
+	uInt	avail_out; /* remaining free space at next_out */
+	uLong	total_out; /* total nb of bytes output so far */
+	char	*msg;	/* last error message, NULL if no error */
+	struct	internal_state FAR *state; /* not visible by applications */
+	alloc_func	zalloc;	/* used to allocate the internal state */
+	free_func	zfree;	/* used to free the internal state */
+	voidpf	opaque;	/* private data object passed to zalloc and zfree */
+	int	data_type;	/* best guess about the data type:
+					binary or text */
+	cb_func	outcb;	/* called regularly just before blocks of output */
+	uLong	adler;	/* adler32 value of the uncompressed data */
+	uLong	reserved;	/* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+	int	text;	/* true if compressed data believed to be text */
+	uLong	time;	/* modification time */
+	int	xflags;	/* extra flags (not used when writing a gzip file) */
+	int	os;	/* operating system */
+	Bytef	*extra;	/* pointer to extra field or Z_NULL if none */
+	uInt	extra_len; /* extra field length (valid if extra != Z_NULL) */
+	uInt	extra_max; /* space at extra (only when reading header) */
+	Bytef	*name; /* pointer to zero-terminated file name or Z_NULL */
+	uInt	name_max; /* space at name (only when reading header) */
+	Bytef	*comment; /* pointer to zero-terminated comment or Z_NULL */
+	uInt	comm_max; /* space at comment (only when reading header) */
+	int	hcrc; /* true if there was or will be a header crc */
+	int	done; /* true when done reading gzip header (not used
+			when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+                        /* constants */
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+                        /* basic functions */
+
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm, const char *version,
+				int stream_size));
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+#define inflateInit(strm) \
+	inflateInit_((strm), ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+	struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
diff --git a/include/zlib.h b/include/zlib.h
deleted file mode 100644
index e441494..0000000
--- a/include/zlib.h
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * This file is derived from zlib.h and zconf.h from the zlib-0.95
- * distribution by Jean-loup Gailly and Mark Adler, with some additions
- * by Paul Mackerras to aid in implementing Deflate compression and
- * decompression for PPP packets.
- */
-
-/*
- *  ==FILEVERSION 960122==
- *
- * This marker is used by the Linux installation script to determine
- * whether an up-to-date version of this file is already installed.
- */
-
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 0.95, Aug 16th, 1995.
-
-  Copyright (C) 1995 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
- */
-
-#ifndef _ZLIB_H
-#define _ZLIB_H
-
-/* #include "zconf.h" */	/* included directly here */
-
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* From: zconf.h,v 1.12 1995/05/03 17:27:12 jloup Exp */
-
-/*
-     The library does not install any signal handler. It is recommended to
-  add at least a handler for SIGSEGV when decompressing; the library checks
-  the consistency of the input data whenever possible but may go nuts
-  for some forms of corrupted input.
- */
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- * Compile with -DUNALIGNED_OK if it is OK to access shorts or ints
- * at addresses which are not a multiple of their size.
- * Under DOS, -DFAR=far or -DFAR=__far may be needed.
- */
-
-#ifndef STDC
-#  if defined(MSDOS) || defined(__STDC__) || defined(__cplusplus)
-#    define STDC
-#  endif
-#endif
-
-#ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
-#  include <unix.h>
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-	    1 << (windowBits+2)   +  1 << (memLevel+9)
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-			/* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-typedef unsigned char  Byte;  /* 8 bits */
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-typedef Byte FAR Bytef;
-typedef char FAR charf;
-typedef int FAR intf;
-typedef uInt FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void FAR *voidpf;
-   typedef void     *voidp;
-#else
-   typedef Byte FAR *voidpf;
-   typedef Byte     *voidp;
-#endif
-
-/* end of original zconf.h */
-
-#define ZLIB_VERSION "0.95P"
-
-/*
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms may be added later and will have the same
-  stream interface.
-
-     For compression the application must provide the output buffer and
-  may optionally provide the input buffer for optimization. For decompression,
-  the application must provide the input buffer and may optionally provide
-  the output buffer for optimization.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt nbytes));
-
-typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidp      opaque;  /* private data object passed to zalloc and zfree */
-
-    Byte     data_type; /* best guess about the data type: ascii or binary */
-
-    cb_func  outcb;	/* called regularly just before blocks of output */
-
-} z_stream;
-
-/*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   opaque value.
-
-   zalloc must return Z_NULL if there is not enough memory for the object.
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
-*/
-
-			/* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_FULL_FLUSH    2
-#define Z_SYNC_FLUSH    3 /* experimental: partial_flush + byte align */
-#define Z_FINISH        4
-#define Z_PACKET_FLUSH	5
-/* See deflate() below for the usage of these constants */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-/* error codes for the compression/decompression functions */
-
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_DEFAULT_STRATEGY    0
-
-#define Z_BINARY   0
-#define Z_ASCII    1
-#define Z_UNKNOWN  2
-/* Used to set the data_type field */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-extern char *zlib_version;
-/* The application can compare zlib_version and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
- */
-
-			/* basic functions */
-
-extern int inflateInit OF((z_stream *strm));
-/*
-     Initializes the internal stream state for decompression. The fields
-   zalloc and zfree must be initialized before by the caller.  If zalloc and
-   zfree are set to Z_NULL, inflateInit updates them to use default allocation
-   functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory.  msg is set to null if there is no error message.
-   inflateInit does not perform any decompression: this will be done by
-   inflate().
-*/
-
-
-extern int inflate OF((z_stream *strm, int flush));
-/*
-  Performs one or both of the following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() always provides as much output as possible
-    (until there is no more input data or no more space in the output buffer).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate().
-
-    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
-  inflate flushes as much output as possible to the output buffer. The
-  flushing behavior of inflate is not specified for values of the flush
-  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
-  current implementation actually flushes as much output as possible
-  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
-  has been consumed, it is expecting to see the length field of a stored
-  block; if not, it returns Z_DATA_ERROR.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster routine
-  may be used for the single inflate() call.
-
-    inflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if the end of the
-  compressed data has been reached and all uncompressed output has been
-  produced, Z_DATA_ERROR if the input data was corrupted, Z_STREAM_ERROR if
-  the stream structure was inconsistent (for example if next_in or next_out
-  was NULL), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR if no
-  progress is possible or if there was not enough room in the output buffer
-  when Z_FINISH is used. In the Z_DATA_ERROR case, the application may then
-  call inflateSync to look for a good compression block.  */
-
-
-extern int inflateEnd OF((z_stream *strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-			/* advanced functions */
-
-extern int inflateInit2 OF((z_stream *strm,
-			    int  windowBits));
-/*
-     This is another version of inflateInit with more compression options. The
-   fields next_out, zalloc and zfree must be initialized before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library (the value 16 will be allowed soon). The
-   default value is 15 if inflateInit is used instead. If a compressed stream
-   with a larger window size is given as input, inflate() will return with
-   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     If next_out is not null, the library will use this buffer for the history
-   buffer; the buffer must either be large enough to hold the entire output
-   data, or have at least 1<<windowBits bytes.  If next_out is null, the
-   library will allocate its own buffer (and leave next_out null). next_in
-   need not be provided here but must be provided by the application for the
-   next call of inflate().
-
-     If the history buffer is provided by the application, next_out must
-   never be changed by the application since the decompressor maintains
-   history information inside this buffer from call to call; the application
-   can only reset next_out to the beginning of the history buffer when
-   avail_out is zero and all output has been consumed.
-
-      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
-   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
-   windowBits < 8). msg is set to null if there is no error message.
-   inflateInit2 does not perform any decompression: this will be done by
-   inflate().
-*/
-
-extern int inflateSync OF((z_stream *strm));
-/*
-    Skips invalid compressed data until the special marker (see deflate()
-  above) can be found, or until all available input is skipped. No output
-  is provided.
-
-    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no marker has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
-*/
-
-extern int inflateReset OF((z_stream *strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
-
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-extern int inflateIncomp OF((z_stream *strm));
-/*
-     This function adds the data at next_in (avail_in bytes) to the output
-   history without performing any output.  There must be no pending output,
-   and the decompressor must be expecting to see the start of a block.
-   Calling this function is equivalent to decompressing a stored block
-   containing the data at next_in (except that the data is not output).
-*/
-
-			/* checksum functions */
-
-/*
-     This function is not related to compression but is exported
-   anyway because it might be useful in applications using the
-   compression library.
-*/
-
-extern uLong adler32 OF((uLong adler, Bytef *buf, uInt len));
-
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-#ifndef _Z_UTIL_H
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
-#endif
-
-#endif /* _ZLIB_H */
diff --git a/lib_arm/armlinux.c b/lib_arm/armlinux.c
index 6d32a41..24ba39b 100644
--- a/lib_arm/armlinux.c
+++ b/lib_arm/armlinux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
diff --git a/lib_avr32/avr32_linux.c b/lib_avr32/avr32_linux.c
index 62afbd2..6e85923 100644
--- a/lib_avr32/avr32_linux.c
+++ b/lib_avr32/avr32_linux.c
@@ -22,7 +22,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 #include <asm/io.h>
diff --git a/lib_blackfin/bf533_linux.c b/lib_blackfin/bf533_linux.c
index 80a3dc7..d666cfd 100644
--- a/lib_blackfin/bf533_linux.c
+++ b/lib_blackfin/bf533_linux.c
@@ -30,7 +30,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 
 #define	LINUX_MAX_ENVS		256
diff --git a/lib_generic/Makefile b/lib_generic/Makefile
index 9713353..52db2dc 100644
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -38,14 +38,16 @@ COBJS-y += ldiv.o
 COBJS-y += sha1.o
 COBJS-y += string.o
 COBJS-y += vsprintf.o
-COBJS-y += zlib.o
 
 COBJS	:= $(COBJS-y)
 SRCS 	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
+OBJS	+= $(addprefix $(obj),zlib.o)
 
 $(LIB):	$(obj).depend $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
+zlib.o: zlib.c
+	$(CC) $(CFLAGS) -O2 -c -o $@ $<
 
 #########################################################################
 
diff --git a/lib_generic/crc32.c b/lib_generic/crc32.c
index df0dbca..16e43f6 100644
--- a/lib_generic/crc32.c
+++ b/lib_generic/crc32.c
@@ -12,7 +12,7 @@
 #include <common.h>
 #endif
 
-#include "zlib.h"
+#include "u-boot/zlib.h"
 
 #define local static
 #define ZEXPORT	/* empty */
diff --git a/lib_generic/zlib.c b/lib_generic/zlib.c
index 668ac8f..8fe3bd0 100644
--- a/lib_generic/zlib.c
+++ b/lib_generic/zlib.c
@@ -1,5 +1,5 @@
 /*
- * This file is derived from various .h and .c files from the zlib-0.95
+ * This file is derived from various .h and .c files from the zlib-1.2.3
  * distribution by Jean-loup Gailly and Mark Adler, with some additions
  * by Paul Mackerras to aid in implementing Deflate compression and
  * decompression for PPP packets.  See zlib.h for conditions of
@@ -14,7 +14,7 @@
 
 /*+++++*/
 /* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995 Jean-loup Gailly.
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -23,28 +23,29 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* From: zutil.h,v 1.9 1995/05/03 17:27:12 jloup Exp */
+#define ZUTIL_H
+#define ZLIB_INTERNAL
 
-#define _Z_UTIL_H
-
-#include "zlib.h"
+#include "u-boot/zlib.h"
+#include <common.h>
+/* To avoid a build time warning */
+#ifdef STDC
+#include <malloc.h>
+#endif
 
 #ifndef local
-#  define local static
+#define local static
 #endif
 /* compile with -Dlocal if your debugger can't find static symbols */
 
-#define FAR
-
-typedef unsigned char  uch;
+typedef unsigned char uch;
 typedef uch FAR uchf;
 typedef unsigned short ush;
 typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern char *z_errmsg[]; /* indexed by 1-zlib_error */
+typedef unsigned long ulg;
 
-#define ERR_RETURN(strm,err) return (strm->msg=z_errmsg[1-err], err)
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+#define ERR_RETURN(strm,err) return (strm->msg = (char*)ERR_MSG(err), (err))
 /* To be used only when the state is known to be valid */
 
 #ifndef NULL
@@ -53,17 +54,15 @@ extern char *z_errmsg[]; /* indexed by 1-zlib_error */
 
 	/* common constants */
 
-#define DEFLATED   8
-
 #ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
+#define DEF_WBITS MAX_WBITS
 #endif
 /* default windowBits for decompression. MAX_WBITS is for compression only */
 
 #if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
+#define DEF_MEM_LEVEL 8
 #else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#define DEF_MEM_LEVEL  MAX_MEM_LEVEL
 #endif
 /* default memLevel */
 
@@ -72,51 +71,47 @@ extern char *z_errmsg[]; /* indexed by 1-zlib_error */
 #define DYN_TREES    2
 /* The three kinds of block type */
 
-#define MIN_MATCH  3
-#define MAX_MATCH  258
+#define MIN_MATCH 3
+#define MAX_MATCH 258
 /* The minimum and maximum match lengths */
 
 	 /* functions */
 
 #include <linux/string.h>
 #define zmemcpy memcpy
-#define zmemzero(dest, len)	memset(dest, 0, len)
+#define zmemcmp memcmp
+#define zmemzero(dest, len) memset(dest, 0, len)
 
 /* Diagnostic functions */
-#ifdef DEBUG_ZLIB
-#  include <stdio.h>
-#  ifndef verbose
-#    define verbose 0
-#  endif
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) fprintf x
-#  define Tracev(x) {if (verbose) fprintf x ;}
-#  define Tracevv(x) {if (verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#ifdef DEBUG
+	extern int z_verbose;
+	extern void z_error    OF((char *m));
+#define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#define fprintf(fp,...)	printf(__VA_ARGS__)
+#define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
 #else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
 #endif
 
-
-typedef uLong (*check_func) OF((uLong check, Bytef *buf, uInt len));
-
-/* voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size)); */
-/* void   zcfree  OF((voidpf opaque, voidpf ptr)); */
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void zcfree  OF((voidpf opaque, voidpf ptr, unsigned size));
 
 #define ZALLOC(strm, items, size) \
-	   (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr, size)	\
-	   (*((strm)->zfree))((strm)->opaque, (voidpf)(addr), (size))
-#define TRY_FREE(s, p, n) {if (p) ZFREE(s, p, n);}
+	(*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr), 0)
 
-/* deflate.h -- internal compression state
- * Copyright (C) 1995 Jean-loup Gailly
+/*+++++*/
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-2005 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -125,9 +120,47 @@ typedef uLong (*check_func) OF((uLong check, Bytef *buf, uInt len));
    subject to change. Applications should only use zlib.h.
  */
 
+/* Structure for decoding tables.  Each entry provides either the
+   information needed to do the operation requested by the code that
+   indexed that table entry, or it provides a pointer to another
+   table that indexes more bits of the code.  op indicates whether
+   the entry is a pointer to another table, a literal, a length or
+   distance, an end-of-block, or an invalid code.  For a table
+   pointer, the low four bits of op is the number of index bits of
+   that table.  For a length or distance, the low four bits of op
+   is the number of extra bits to get after the code.  bits is
+   the number of bits in this code or part of the code to drop off
+   of the bit buffer.  val is the actual byte to output in the case
+   of a literal, the base length or distance, or the offset from
+   the current table to the next table.  Each entry is four bytes. */
+
+typedef struct {
+	unsigned char op;           /* operation, extra bits, table bits */
+	unsigned char bits;         /* bits in this part of the code */
+	unsigned short val;         /* offset in table or code value */
+} code;
+
+/* Maximum size of dynamic tree.  The maximum found in a long but non-
+   exhaustive search was 1444 code structures (852 for length/literals
+   and 592 for distances, the latter actually the result of an
+   exhaustive search).  The true maximum is not known, but the value
+   below is more than safe. */
+#define ENOUGH 2048
+#define MAXD 592
+
+/* Type of code to build for inftable() */
+typedef enum {
+	CODES,
+	LENS,
+	DISTS
+} codetype;
+
+extern int inflate_table OF((codetype type, unsigned short FAR *lens,
+				unsigned codes, code FAR * FAR *table,
+				unsigned FAR *bits, unsigned short FAR *work));
 /*+++++*/
-/* infblock.h -- header to use infblock.c
- * Copyright (C) 1995 Mark Adler
+/* inflate.h -- internal inflate state definition
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -136,101 +169,113 @@ typedef uLong (*check_func) OF((uLong check, Bytef *buf, uInt len));
    subject to change. Applications should only use zlib.h.
  */
 
-struct inflate_blocks_state;
-typedef struct inflate_blocks_state FAR inflate_blocks_statef;
-
-local inflate_blocks_statef * inflate_blocks_new OF((
-    z_stream *z,
-    check_func c,               /* check function */
-    uInt w));                   /* window size */
-
-local int inflate_blocks OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));                      /* initial return code */
-
-local void inflate_blocks_reset OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    uLongf *));                  /* check value on output */
-
-local int inflate_blocks_free OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    uLongf *));                  /* check value on output */
-
-local int inflate_addhistory OF((
-    inflate_blocks_statef *,
-    z_stream *));
-
-local int inflate_packet_flush OF((
-    inflate_blocks_statef *));
+#define GUNZIP
+
+/* Possible inflate modes between inflate() calls */
+typedef enum {
+	HEAD, /* i: waiting for magic header */
+	FLAGS, /* i: waiting for method and flags (gzip) */
+	TIME, /* i: waiting for modification time (gzip) */
+	OS, /* i: waiting for extra flags and operating system (gzip) */
+	EXLEN, /* i: waiting for extra length (gzip) */
+	EXTRA, /* i: waiting for extra bytes (gzip) */
+	NAME, /* i: waiting for end of file name (gzip) */
+	COMMENT, /* i: waiting for end of comment (gzip) */
+	HCRC, /* i: waiting for header crc (gzip) */
+	DICTID, /* i: waiting for dictionary check value */
+	DICT, /* waiting for inflateSetDictionary() call */
+	TYPE, /* i: waiting for type bits, including last-flag bit */
+	TYPEDO, /* i: same, but skip check to exit inflate on new block */
+	STORED, /* i: waiting for stored size (length and complement) */
+	COPY, /* i/o: waiting for input or output to copy stored block */
+	TABLE, /* i: waiting for dynamic block table lengths */
+	LENLENS, /* i: waiting for code length code lengths */
+	CODELENS, /* i: waiting for length/lit and distance code lengths */
+	LEN, /* i: waiting for length/lit code */
+	LENEXT, /* i: waiting for length extra bits */
+	DIST, /* i: waiting for distance code */
+	DISTEXT, /* i: waiting for distance extra bits */
+	MATCH, /* o: waiting for output space to copy string */
+	LIT, /* o: waiting for output space to write literal */
+	CHECK, /* i: waiting for 32-bit check value */
+	LENGTH, /* i: waiting for 32-bit length (gzip) */
+	DONE, /* finished check, done -- remain here until reset */
+	BAD, /* got a data error -- remain here until reset */
+	MEM, /* got an inflate() memory error -- remain here until reset */
+	SYNC, /* looking for synchronization bytes to restart inflate() */
+	START,
+	WASH,
+	END,
+	BADCODE
+} inflate_mode;
 
-/*+++++*/
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
+/*
+    State transitions between above modes -
+
+    (most modes can go to the BAD or MEM mode -- not shown for clarity)
+
+    Process header:
+        HEAD -> (gzip) or (zlib)
+        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
+        NAME -> COMMENT -> HCRC -> TYPE
+        (zlib) -> DICTID or TYPE
+        DICTID -> DICT -> TYPE
+    Read deflate blocks:
+            TYPE -> STORED or TABLE or LEN or CHECK
+            STORED -> COPY -> TYPE
+            TABLE -> LENLENS -> CODELENS -> LEN
+    Read deflate codes:
+                LEN -> LENEXT or LIT or TYPE
+                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
+                LIT -> LEN
+    Process trailer:
+        CHECK -> LENGTH -> DONE
  */
 
-/* Huffman code lookup table entry--this entry is four bytes for machines
-   that have 16-bit pointers (e.g. PC's in the small or medium model). */
-
-typedef struct inflate_huft_s FAR inflate_huft;
-
-struct inflate_huft_s {
-  union {
-    struct {
-      Byte Exop;        /* number of extra bits or operation */
-      Byte Bits;        /* number of bits in this code or subcode */
-    } what;
-    uInt Nalloc;	/* number of these allocated here */
-    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
-  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
-  union {
-    uInt Base;          /* literal, length base, or distance base */
-    inflate_huft *Next; /* pointer to next level of table */
-  } more;
+/* state maintained between inflate() calls.  Approximately 7K bytes. */
+struct inflate_state {
+	inflate_mode mode; /* current inflate mode */
+	int last; /* true if processing last block */
+	int wrap; /* bit 0 true for zlib, bit 1 true for gzip */
+	int havedict; /* true if dictionary provided */
+	int flags; /* gzip header method and flags (0 if zlib) */
+	unsigned dmax; /* zlib header max distance (INFLATE_STRICT) */
+	unsigned long check; /* protected copy of check value */
+	unsigned long total; /* protected copy of output count */
+	gz_headerp head; /* where to save gzip header information */
+        /* sliding window */
+	unsigned wbits; /* log base 2 of requested window size */
+	unsigned wsize; /* window size or zero if not using window */
+	unsigned whave; /* valid bytes in the window */
+	unsigned write; /* window write index */
+	unsigned char FAR *window; /* allocated sliding window, if needed */
+        /* bit accumulator */
+	unsigned long hold; /* input bit accumulator */
+	unsigned bits; /* number of bits in "in" */
+        /* for string and stored block copying */
+	unsigned length; /* literal or length of data to copy */
+	unsigned offset; /* distance back to copy string from */
+        /* for table and code decoding */
+	unsigned extra; /* extra bits needed */
+        /* fixed and dynamic code tables */
+	code const FAR *lencode; /* starting table for length/literal codes */
+	code const FAR *distcode; /* starting table for distance codes */
+	unsigned lenbits; /* index bits for lencode */
+	unsigned distbits; /* index bits for distcode */
+        /* dynamic table building */
+	unsigned ncode; /* number of code length code lengths */
+	unsigned nlen; /* number of length code lengths */
+	unsigned ndist; /* number of distance code lengths */
+	unsigned have; /* number of code lengths in lens[] */
+	code FAR *next; /* next available space in codes[] */
+	unsigned short lens[320]; /* temporary storage for code lengths */
+	unsigned short work[288]; /* work area for code table building */
+	code codes[ENOUGH]; /* space for code tables */
 };
 
-#ifdef DEBUG_ZLIB
-  local uInt inflate_hufts;
-#endif
-
-local int inflate_trees_bits OF((
-    uIntf *,                    /* 19 code lengths */
-    uIntf *,                    /* bits tree desired/actual depth */
-    inflate_huft * FAR *,       /* bits tree result */
-    z_stream *));               /* for zalloc, zfree functions */
-
-local int inflate_trees_dynamic OF((
-    uInt,                       /* number of literal/length codes */
-    uInt,                       /* number of distance codes */
-    uIntf *,                    /* that many (total) code lengths */
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    z_stream *));               /* for zalloc, zfree functions */
-
-local int inflate_trees_fixed OF((
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *));     /* distance tree result */
-
-local int inflate_trees_free OF((
-    inflate_huft *,             /* tables to free */
-    z_stream *));               /* for zfree function */
-
-
 /*+++++*/
-/* infcodes.h -- header to use infcodes.c
- * Copyright (C) 1995 Mark Adler
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-2003 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -239,1923 +284,1902 @@ local int inflate_trees_free OF((
    subject to change. Applications should only use zlib.h.
  */
 
-struct inflate_codes_state;
-typedef struct inflate_codes_state FAR inflate_codes_statef;
-
-local inflate_codes_statef *inflate_codes_new OF((
-    uInt, uInt,
-    inflate_huft *, inflate_huft *,
-    z_stream *));
-
-local int inflate_codes OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));
+void inflate_fast OF((z_streamp strm, unsigned start));
+/*+++++*/
+    /* inffixed.h -- table for decoding fixed codes
+     * Generated automatically by makefixed().
+     */
 
-local void inflate_codes_free OF((
-    inflate_codes_statef *,
-    z_stream *));
+    /* WARNING: this file should *not* be used by applications. It
+       is part of the implementation of the compression library and
+       is subject to change. Applications should only use zlib.h.
+     */
 
+	static const code lenfix[512] = {
+	{96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
+	{0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
+	{0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
+	{0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
+	{0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
+	{21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
+	{0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
+	{0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
+	{18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
+	{0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
+	{0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
+	{0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
+	{20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
+	{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
+	{0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
+	{0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
+	{16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
+	{0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
+	{0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
+	{0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
+	{0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
+	{0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
+	{0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
+	{0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
+	{17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
+	{0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
+	{0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
+	{0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
+	{19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
+	{0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
+	{0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
+	{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
+	{16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
+	{0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
+	{0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
+	{0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
+	{0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
+	{20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
+	{0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
+	{0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
+	{17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
+	{0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
+	{0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
+	{0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
+	{20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
+	{0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
+	{0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
+	{0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
+	{16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
+	{0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
+	{0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
+	{0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
+	{0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
+	{0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
+	{0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
+	{0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
+	{16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
+	{0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
+	{0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
+	{0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
+	{19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
+	{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
+	{0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
+	{0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
+	{16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
+	{0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
+	{0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
+	{0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
+	{0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
+	{64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
+	{0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
+	{0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
+	{18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
+	{0,9,255}
+	};
+
+	static const code distfix[32] = {
+	{16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
+	{21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
+	{18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
+	{19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
+	{16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
+	{22,5,193},{64,5,0}
+	};
 
 /*+++++*/
-/* inflate.c -- zlib interface to inflate modules
- * Copyright (C) 1995 Mark Adler
+/* inffast.c -- fast decoding
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* inflate private state */
-struct internal_state {
-
-  /* mode */
-  enum {
-      METHOD,   /* waiting for method byte */
-      FLAG,     /* waiting for flag byte */
-      BLOCKS,   /* decompressing blocks */
-      CHECK4,   /* four check bytes to go */
-      CHECK3,   /* three check bytes to go */
-      CHECK2,   /* two check bytes to go */
-      CHECK1,   /* one check byte to go */
-      DONE,     /* finished check, done */
-      BAD}      /* got an error--stay here */
-    mode;               /* current inflate mode */
-
-  /* mode dependent information */
-  union {
-    uInt method;        /* if FLAGS, method byte */
-    struct {
-      uLong was;                /* computed check value */
-      uLong need;               /* stream check value */
-    } check;            /* if CHECK, check values to compare */
-    uInt marker;        /* if BAD, inflateSync's marker bytes count */
-  } sub;        /* submode */
-
-  /* mode independent information */
-  int  nowrap;          /* flag for no wrapper */
-  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
-  inflate_blocks_statef
-    *blocks;            /* current inflate_blocks state */
-
-};
-
-
-int inflateReset(z)
-z_stream *z;
-{
-  uLong c;
-
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->total_in = z->total_out = 0;
-  z->msg = Z_NULL;
-  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
-  inflate_blocks_reset(z->state->blocks, z, &c);
-  Trace((stderr, "inflate: reset\n"));
-  return Z_OK;
-}
-
-
-int inflateEnd(z)
-z_stream *z;
-{
-  uLong c;
-
-  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->blocks != Z_NULL)
-    inflate_blocks_free(z->state->blocks, z, &c);
-  ZFREE(z, z->state, sizeof(struct internal_state));
-  z->state = Z_NULL;
-  Trace((stderr, "inflate: end\n"));
-  return Z_OK;
-}
-
-
-int inflateInit2(z, w)
-z_stream *z;
-int w;
-{
-  /* initialize state */
-  if (z == Z_NULL)
-    return Z_STREAM_ERROR;
-/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
-/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
-  if ((z->state = (struct internal_state FAR *)
-       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
-    return Z_MEM_ERROR;
-  z->state->blocks = Z_NULL;
-
-  /* handle undocumented nowrap option (no zlib header or check) */
-  z->state->nowrap = 0;
-  if (w < 0)
-  {
-    w = - w;
-    z->state->nowrap = 1;
-  }
-
-  /* set window size */
-  if (w < 8 || w > 15)
-  {
-    inflateEnd(z);
-    return Z_STREAM_ERROR;
-  }
-  z->state->wbits = (uInt)w;
-
-  /* create inflate_blocks state */
-  if ((z->state->blocks =
-       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, 1 << w))
-      == Z_NULL)
-  {
-    inflateEnd(z);
-    return Z_MEM_ERROR;
-  }
-  Trace((stderr, "inflate: allocated\n"));
-
-  /* reset state */
-  inflateReset(z);
-  return Z_OK;
-}
-
-
-int inflateInit(z)
-z_stream *z;
-{
-  return inflateInit2(z, DEF_WBITS);
-}
-
-
-#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
-#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
-
-int inflate(z, f)
-z_stream *z;
-int f;
-{
-  int r;
-  uInt b;
-
-  if (z == Z_NULL || z->next_in == Z_NULL)
-    return Z_STREAM_ERROR;
-  r = Z_BUF_ERROR;
-  while (1) switch (z->state->mode)
-  {
-    case METHOD:
-      NEEDBYTE
-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
-      {
-	z->state->mode = BAD;
-	z->msg = "unknown compression method";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
-      {
-	z->state->mode = BAD;
-	z->msg = "invalid window size";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      z->state->mode = FLAG;
-    case FLAG:
-      NEEDBYTE
-      if ((b = NEXTBYTE) & 0x20)
-      {
-	z->state->mode = BAD;
-	z->msg = "invalid reserved bit";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      if (((z->state->sub.method << 8) + b) % 31)
-      {
-	z->state->mode = BAD;
-	z->msg = "incorrect header check";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      Trace((stderr, "inflate: zlib header ok\n"));
-      z->state->mode = BLOCKS;
-    case BLOCKS:
-      r = inflate_blocks(z->state->blocks, z, r);
-      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
-	  r = inflate_packet_flush(z->state->blocks);
-      if (r == Z_DATA_ERROR)
-      {
-	z->state->mode = BAD;
-	z->state->sub.marker = 0;       /* can try inflateSync */
-	break;
-      }
-      if (r != Z_STREAM_END)
-	return r;
-      r = Z_OK;
-      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
-      if (z->state->nowrap)
-      {
-	z->state->mode = DONE;
-	break;
-      }
-      z->state->mode = CHECK4;
-    case CHECK4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = CHECK3;
-    case CHECK3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = CHECK2;
-    case CHECK2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = CHECK1;
-    case CHECK1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-
-      if (z->state->sub.check.was != z->state->sub.check.need)
-      {
-	z->state->mode = BAD;
-	z->msg = "incorrect data check";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      Trace((stderr, "inflate: zlib check ok\n"));
-      z->state->mode = DONE;
-    case DONE:
-      return Z_STREAM_END;
-    case BAD:
-      return Z_DATA_ERROR;
-    default:
-      return Z_STREAM_ERROR;
-  }
-
- empty:
-  if (f != Z_PACKET_FLUSH)
-    return r;
-  z->state->mode = BAD;
-  z->state->sub.marker = 0;       /* can try inflateSync */
-  return Z_DATA_ERROR;
-}
+/* Allow machine dependent optimization for post-increment or pre-increment.
+   Based on testing to date,
+   Pre-increment preferred for:
+   - PowerPC G3 (Adler)
+   - MIPS R5000 (Randers-Pehrson)
+   Post-increment preferred for:
+   - none
+   No measurable difference:
+   - Pentium III (Anderson)
+   - M68060 (Nikl)
+ */
+#define OFF 1
+#define PUP(a) *++(a)
 
 /*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
+
+   Entry assumptions:
+
+        state->mode == LEN
+        strm->avail_in >= 6
+        strm->avail_out >= 258
+        start >= strm->avail_out
+        state->bits < 8
+
+   On return, state->mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
+
+   Notes:
+
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm->avail_in >= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm->avail_out >= 258 for each loop to avoid checking for
+      output space.
  */
-
-int inflateIncomp(z)
-z_stream *z;
+void inflate_fast(strm, start)
+z_streamp strm;
+unsigned start;         /* inflate()'s starting value for strm->avail_out */
 {
-    if (z->state->mode != BLOCKS)
-	return Z_DATA_ERROR;
-    return inflate_addhistory(z->state->blocks, z);
-}
-
-
-int inflateSync(z)
-z_stream *z;
-{
-  uInt n;       /* number of bytes to look at */
-  Bytef *p;     /* pointer to bytes */
-  uInt m;       /* number of marker bytes found in a row */
-  uLong r, w;   /* temporaries to save total_in and total_out */
-
-  /* set up */
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->mode != BAD)
-  {
-    z->state->mode = BAD;
-    z->state->sub.marker = 0;
-  }
-  if ((n = z->avail_in) == 0)
-    return Z_BUF_ERROR;
-  p = z->next_in;
-  m = z->state->sub.marker;
-
-  /* search */
-  while (n && m < 4)
-  {
-    if (*p == (Byte)(m < 2 ? 0 : 0xff))
-      m++;
-    else if (*p)
-      m = 0;
-    else
-      m = 4 - m;
-    p++, n--;
-  }
-
-  /* restore */
-  z->total_in += p - z->next_in;
-  z->next_in = p;
-  z->avail_in = n;
-  z->state->sub.marker = m;
-
-  /* return no joy or set up to restart on a new block */
-  if (m != 4)
-    return Z_DATA_ERROR;
-  r = z->total_in;  w = z->total_out;
-  inflateReset(z);
-  z->total_in = r;  z->total_out = w;
-  z->state->mode = BLOCKS;
-  return Z_OK;
+    struct inflate_state FAR *state;
+    unsigned char FAR *in;      /* local strm->next_in */
+    unsigned char FAR *last;    /* while in < last, enough input available */
+    unsigned char FAR *out;     /* local strm->next_out */
+    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
+    unsigned char FAR *end;     /* while out < end, enough space available */
+#ifdef INFLATE_STRICT
+    unsigned dmax;              /* maximum distance from zlib header */
+#endif
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned write;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
+    unsigned long hold;         /* local strm->hold */
+    unsigned bits;              /* local strm->bits */
+    code const FAR *lcode;      /* local strm->lencode */
+    code const FAR *dcode;      /* local strm->distcode */
+    unsigned lmask;             /* mask for first level of length codes */
+    unsigned dmask;             /* mask for first level of distance codes */
+    code this;                  /* retrieved table entry */
+    unsigned op;                /* code bits, operation, extra bits, or */
+                                /*  window position, window bytes to copy */
+    unsigned len;               /* match length, unused bytes */
+    unsigned dist;              /* match distance */
+    unsigned char FAR *from;    /* where to copy match from */
+
+    /* copy state to local variables */
+    state = (struct inflate_state FAR *)strm->state;
+    in = strm->next_in - OFF;
+    last = in + (strm->avail_in - 5);
+    out = strm->next_out - OFF;
+    beg = out - (start - strm->avail_out);
+    end = out + (strm->avail_out - 257);
+#ifdef INFLATE_STRICT
+    dmax = state->dmax;
+#endif
+    wsize = state->wsize;
+    whave = state->whave;
+    write = state->write;
+    window = state->window;
+    hold = state->hold;
+    bits = state->bits;
+    lcode = state->lencode;
+    dcode = state->distcode;
+    lmask = (1U << state->lenbits) - 1;
+    dmask = (1U << state->distbits) - 1;
+
+    /* decode literals and length/distances until end-of-block or not enough
+       input data or output space */
+    do {
+        if (bits < 15) {
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+        }
+        this = lcode[hold & lmask];
+      dolen:
+        op = (unsigned)(this.bits);
+        hold >>= op;
+        bits -= op;
+        op = (unsigned)(this.op);
+        if (op == 0) {                          /* literal */
+            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                    "inflate:         literal '%c'\n" :
+                    "inflate:         literal 0x%02x\n", this.val));
+            PUP(out) = (unsigned char)(this.val);
+        }
+        else if (op & 16) {                     /* length base */
+            len = (unsigned)(this.val);
+            op &= 15;                           /* number of extra bits */
+            if (op) {
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                }
+                len += (unsigned)hold & ((1U << op) - 1);
+                hold >>= op;
+                bits -= op;
+            }
+            Tracevv((stderr, "inflate:         length %u\n", len));
+            if (bits < 15) {
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+            }
+            this = dcode[hold & dmask];
+          dodist:
+            op = (unsigned)(this.bits);
+            hold >>= op;
+            bits -= op;
+            op = (unsigned)(this.op);
+            if (op & 16) {                      /* distance base */
+                dist = (unsigned)(this.val);
+                op &= 15;                       /* number of extra bits */
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                    if (bits < op) {
+                        hold += (unsigned long)(PUP(in)) << bits;
+                        bits += 8;
+                    }
+                }
+                dist += (unsigned)hold & ((1U << op) - 1);
+#ifdef INFLATE_STRICT
+                if (dist > dmax) {
+                    strm->msg = (char *)"invalid distance too far back";
+                    state->mode = BAD;
+                    break;
+                }
+#endif
+                hold >>= op;
+                bits -= op;
+                Tracevv((stderr, "inflate:         distance %u\n", dist));
+                op = (unsigned)(out - beg);     /* max distance in output */
+                if (dist > op) {                /* see if copy from window */
+                    op = dist - op;             /* distance back in window */
+                    if (op > whave) {
+                        strm->msg = (char *)"invalid distance too far back";
+                        state->mode = BAD;
+                        break;
+                    }
+                    from = window - OFF;
+                    if (write == 0) {           /* very common case */
+                        from += wsize - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    else if (write < op) {      /* wrap around window */
+                        from += wsize + write - op;
+                        op -= write;
+                        if (op < len) {         /* some from end of window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = window - OFF;
+                            if (write < len) {  /* some from start of window */
+                                op = write;
+                                len -= op;
+                                do {
+                                    PUP(out) = PUP(from);
+                                } while (--op);
+                                from = out - dist;      /* rest from output */
+                            }
+                        }
+                    }
+                    else {                      /* contiguous in window */
+                        from += write - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    while (len > 2) {
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    }
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+                else {
+                    from = out - dist;          /* copy direct from output */
+                    do {                        /* minimum length is three */
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    } while (len > 2);
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+            }
+            else if ((op & 64) == 0) {          /* 2nd level distance code */
+                this = dcode[this.val + (hold & ((1U << op) - 1))];
+                goto dodist;
+            }
+            else {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+        }
+        else if ((op & 64) == 0) {              /* 2nd level length code */
+            this = lcode[this.val + (hold & ((1U << op) - 1))];
+            goto dolen;
+        }
+        else if (op & 32) {                     /* end-of-block */
+            Tracevv((stderr, "inflate:         end of block\n"));
+            state->mode = TYPE;
+            break;
+        }
+        else {
+            strm->msg = (char *)"invalid literal/length code";
+            state->mode = BAD;
+            break;
+        }
+    } while (in < last && out < end);
+
+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
+    len = bits >> 3;
+    in -= len;
+    bits -= len << 3;
+    hold &= (1U << bits) - 1;
+
+    /* update state and return */
+    strm->next_in = in + OFF;
+    strm->next_out = out + OFF;
+    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
+    strm->avail_out = (unsigned)(out < end ?
+                                 257 + (end - out) : 257 - (out - end));
+    state->hold = hold;
+    state->bits = bits;
+    return;
 }
 
-#undef NEEDBYTE
-#undef NEXTBYTE
-
-/*+++++*/
-/* infutil.h -- types and macros common to blocks and codes
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* inflate blocks semi-private state */
-struct inflate_blocks_state {
-
-  /* mode */
-  enum {
-      TYPE,     /* get type bits (3, including end bit) */
-      LENS,     /* get lengths for stored */
-      STORED,   /* processing stored block */
-      TABLE,    /* get table lengths */
-      BTREE,    /* get bit lengths tree for a dynamic block */
-      DTREE,    /* get length, distance trees for a dynamic block */
-      CODES,    /* processing fixed or dynamic block */
-      DRY,      /* output remaining window bytes */
-      DONEB,     /* finished last block, done */
-      BADB}      /* got a data error--stuck here */
-    mode;               /* current inflate_block mode */
-
-  /* mode dependent information */
-  union {
-    uInt left;          /* if STORED, bytes left to copy */
-    struct {
-      uInt table;               /* table lengths (14 bits) */
-      uInt index;               /* index into blens (or border) */
-      uIntf *blens;             /* bit lengths of codes */
-      uInt bb;                  /* bit length tree depth */
-      inflate_huft *tb;         /* bit length decoding tree */
-      int nblens;		/* # elements allocated at blens */
-    } trees;            /* if DTREE, decoding info for trees */
-    struct {
-      inflate_huft *tl, *td;    /* trees to free */
-      inflate_codes_statef
-	 *codes;
-    } decode;           /* if CODES, current state */
-  } sub;                /* submode */
-  uInt last;            /* true if this block is the last block */
-
-  /* mode independent information */
-  uInt bitk;            /* bits in bit buffer */
-  uLong bitb;           /* bit buffer */
-  Bytef *window;        /* sliding window */
-  Bytef *end;           /* one byte after sliding window */
-  Bytef *read;          /* window read pointer */
-  Bytef *write;         /* window write pointer */
-  check_func checkfn;   /* check function */
-  uLong check;          /* check on output */
-
-};
-
-
-/* defines for inflate input/output */
-/*   update pointers and return */
-#define UPDBITS {s->bitb=b;s->bitk=k;}
-#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
-#define UPDOUT {s->write=q;}
-#define UPDATE {UPDBITS UPDIN UPDOUT}
-#define LEAVE {UPDATE return inflate_flush(s,z,r);}
-/*   get bytes and bits */
-#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
-#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
-#define NEXTBYTE (n--,*p++)
-#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define DUMPBITS(j) {b>>=(j);k-=(j);}
-/*   output bytes */
-#define WAVAIL (q<s->read?s->read-q-1:s->end-q)
-#define LOADOUT {q=s->write;m=WAVAIL;}
-#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=WAVAIL;}}
-#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
-#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
-#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
-/*   load local pointers */
-#define LOAD {LOADIN LOADOUT}
-
 /*
- * The IBM 150 firmware munges the data right after _etext[].  This
- * protects it. -- Cort
+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
+   - Using bit fields for code structure
+   - Different op definition to avoid & for extra bits (do & for table bits)
+   - Three separate decoding do-loops for direct, window, and write == 0
+   - Special case for distance > 1 copies to do overlapped load and store copy
+   - Explicit branch predictions (based on measured branch probabilities)
+   - Deferring match copy and interspersed it with decoding subsequent codes
+   - Swapping literal/length else
+   - Swapping window/direct else
+   - Larger unrolled copy loops (three is about right)
+   - Moving len -= 3 statement into middle of loop
  */
-#if 0
-local uInt protect_mask[] = {0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0 ,0};
-#endif
-/* And'ing with mask[n] masks the lower n bits */
-local uInt inflate_mask[] = {
-    0x0000,
-    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
-};
-
-/* copy as much as possible from the sliding window to the output area */
-local int inflate_flush OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));
 
 /*+++++*/
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995 Mark Adler
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-2005 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-local int inflate_fast OF((
-    uInt,
-    uInt,
-    inflate_huft *,
-    inflate_huft *,
-    inflate_blocks_statef *,
-    z_stream *));
-
-
-/*+++++*/
-/* infblock.c -- interpret and process block types to last block
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
+#define MAXBITS 15
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
  */
 
-/* Table for deflate from PKZIP's appnote.txt. */
-local uInt border[] = { /* Order of the bit length code lengths */
-	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
 /*
-   Notes beyond the 1.93a appnote.txt:
-
-   1. Distance pointers never point before the beginning of the output
-      stream.
-   2. Distance pointers can point back across blocks, up to 32k away.
-   3. There is an implied maximum of 7 bits for the bit length table and
-      15 bits for the actual data.
-   4. If only one code exists, then it is encoded using one bit.  (Zero
-      would be more efficient, but perhaps a little confusing.)  If two
-      codes exist, they are coded using one bit each (0 and 1).
-   5. There is no way of sending zero distance codes--a dummy must be
-      sent if there are none.  (History: a pre 2.0 version of PKZIP would
-      store blocks with no distance codes, but this was discovered to be
-      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
-      zero distance codes, which is sent as one code of zero bits in
-      length.
-   6. There are up to 286 literal/length codes.  Code 256 represents the
-      end-of-block.  Note however that the static length tree defines
-      288 codes just to fill out the Huffman codes.  Codes 286 and 287
-      cannot be used though, since there is no length base or extra bits
-      defined for them.  Similarily, there are up to 30 distance codes.
-      However, static trees define 32 codes (all 5 bits) to fill out the
-      Huffman codes, but the last two had better not show up in the data.
-   7. Unzip can check dynamic Huffman blocks for complete code sets.
-      The exception is that a single code would not be complete (see #4).
-   8. The five bits following the block type is really the number of
-      literal codes sent minus 257.
-   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
-      (1+6+6).  Therefore, to output three times the length, you output
-      three codes (1+1+1), whereas to output four times the same length,
-      you only need two codes (1+3).  Hmm.
-  10. In the tree reconstruction algorithm, Code = Code + Increment
-      only if BitLength(i) is not zero.  (Pretty obvious.)
-  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
-  12. Note: length code 284 can represent 227-258, but length code 285
-      really is 258.  The last length deserves its own, short code
-      since it gets used a lot in very redundant files.  The length
-      258 is special since 258 - 3 (the min match length) is 255.
-  13. The literal/length and distance code bit lengths are read as a
-      single stream of lengths.  It is possible (and advantageous) for
-      a repeat code (16, 17, or 18) to go across the boundary between
-      the two sets of lengths.
+   Build a set of tables to decode the provided canonical Huffman code.
+   The code lengths are lens[0..codes-1].  The result starts at *table,
+   whose indices are 0..2^bits-1.  work is a writable array of at least
+   lens shorts, which is used as a work area.  type is the type of code
+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
+   on return points to the next available entry's address.  bits is the
+   requested root table index bits, and on return it is the actual root
+   table index bits.  It will differ if the request is greater than the
+   longest code or if it is less than the shortest code.
  */
-
-
-local void inflate_blocks_reset(s, z, c)
-inflate_blocks_statef *s;
-z_stream *z;
-uLongf *c;
+int inflate_table(type, lens, codes, table, bits, work)
+codetype type;
+unsigned short FAR *lens;
+unsigned codes;
+code FAR * FAR *table;
+unsigned FAR *bits;
+unsigned short FAR *work;
 {
-  if (s->checkfn != Z_NULL)
-    *c = s->check;
-  if (s->mode == BTREE || s->mode == DTREE)
-    ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
-  if (s->mode == CODES)
-  {
-    inflate_codes_free(s->sub.decode.codes, z);
-    inflate_trees_free(s->sub.decode.td, z);
-    inflate_trees_free(s->sub.decode.tl, z);
-  }
-  s->mode = TYPE;
-  s->bitk = 0;
-  s->bitb = 0;
-  s->read = s->write = s->window;
-  if (s->checkfn != Z_NULL)
-    s->check = (*s->checkfn)(0L, Z_NULL, 0);
-  if (z->outcb != Z_NULL)
-    (*z->outcb)(Z_NULL, 0);
-  Trace((stderr, "inflate:   blocks reset\n"));
-}
-
-
-local inflate_blocks_statef *inflate_blocks_new(z, c, w)
-z_stream *z;
-check_func c;
-uInt w;
-{
-  inflate_blocks_statef *s;
-
-  if ((s = (inflate_blocks_statef *)ZALLOC
-       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
-    return s;
-  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
-  {
-    ZFREE(z, s, sizeof(struct inflate_blocks_state));
-    return Z_NULL;
-  }
-  s->end = s->window + w;
-  s->checkfn = c;
-  s->mode = TYPE;
-  Trace((stderr, "inflate:   blocks allocated\n"));
-  inflate_blocks_reset(s, z, &s->check);
-  return s;
-}
+    unsigned len;               /* a code's length in bits */
+    unsigned sym;               /* index of code symbols */
+    unsigned min, max;          /* minimum and maximum code lengths */
+    unsigned root;              /* number of index bits for root table */
+    unsigned curr;              /* number of index bits for current table */
+    unsigned drop;              /* code bits to drop for sub-table */
+    int left;                   /* number of prefix codes available */
+    unsigned used;              /* code entries in table used */
+    unsigned huff;              /* Huffman code */
+    unsigned incr;              /* for incrementing code, index */
+    unsigned fill;              /* index for replicating entries */
+    unsigned low;               /* low bits for current root entry */
+    unsigned mask;              /* mask for low root bits */
+    code this;                  /* table entry for duplication */
+    code FAR *next;             /* next available space in table */
+    const unsigned short FAR *base;     /* base value table to use */
+    const unsigned short FAR *extra;    /* extra bits table to use */
+    int end;                    /* use base and extra for symbol > end */
+    unsigned short count[MAXBITS+1];    /* number of codes of each length */
+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577, 0, 0};
+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+        28, 28, 29, 29, 64, 64};
+
+    /*
+       Process a set of code lengths to create a canonical Huffman code.  The
+       code lengths are lens[0..codes-1].  Each length corresponds to the
+       symbols 0..codes-1.  The Huffman code is generated by first sorting the
+       symbols by length from short to long, and retaining the symbol order
+       for codes with equal lengths.  Then the code starts with all zero bits
+       for the first code of the shortest length, and the codes are integer
+       increments for the same length, and zeros are appended as the length
+       increases.  For the deflate format, these bits are stored backwards
+       from their more natural integer increment ordering, and so when the
+       decoding tables are built in the large loop below, the integer codes
+       are incremented backwards.
+
+       This routine assumes, but does not check, that all of the entries in
+       lens[] are in the range 0..MAXBITS.  The caller must assure this.
+       1..MAXBITS is interpreted as that code length.  zero means that that
+       symbol does not occur in this code.
+
+       The codes are sorted by computing a count of codes for each length,
+       creating from that a table of starting indices for each length in the
+       sorted table, and then entering the symbols in order in the sorted
+       table.  The sorted table is work[], with that space being provided by
+       the caller.
+
+       The length counts are used for other purposes as well, i.e. finding
+       the minimum and maximum length codes, determining if there are any
+       codes at all, checking for a valid set of lengths, and looking ahead
+       at length counts to determine sub-table sizes when building the
+       decoding tables.
+     */
 
+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+    for (len = 0; len <= MAXBITS; len++)
+        count[len] = 0;
+    for (sym = 0; sym < codes; sym++)
+        count[lens[sym]]++;
+
+    /* bound code lengths, force root to be within code lengths */
+    root = *bits;
+    for (max = MAXBITS; max >= 1; max--)
+        if (count[max] != 0) break;
+    if (root > max) root = max;
+    if (max == 0) {                     /* no symbols to code at all */
+        this.op = (unsigned char)64;    /* invalid code marker */
+        this.bits = (unsigned char)1;
+        this.val = (unsigned short)0;
+        *(*table)++ = this;             /* make a table to force an error */
+        *(*table)++ = this;
+        *bits = 1;
+        return 0;     /* no symbols, but wait for decoding to report error */
+    }
+    for (min = 1; min <= MAXBITS; min++)
+        if (count[min] != 0) break;
+    if (root < min) root = min;
+
+    /* check for an over-subscribed or incomplete set of lengths */
+    left = 1;
+    for (len = 1; len <= MAXBITS; len++) {
+        left <<= 1;
+        left -= count[len];
+        if (left < 0) return -1;        /* over-subscribed */
+    }
+    if (left > 0 && (type == CODES || max != 1))
+        return -1;                      /* incomplete set */
+
+    /* generate offsets into symbol table for each length for sorting */
+    offs[1] = 0;
+    for (len = 1; len < MAXBITS; len++)
+        offs[len + 1] = offs[len] + count[len];
+
+    /* sort symbols by length, by symbol order within each length */
+    for (sym = 0; sym < codes; sym++)
+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
+
+    /*
+       Create and fill in decoding tables.  In this loop, the table being
+       filled is at next and has curr index bits.  The code being used is huff
+       with length len.  That code is converted to an index by dropping drop
+       bits off of the bottom.  For codes where len is less than drop + curr,
+       those top drop + curr - len bits are incremented through all values to
+       fill the table with replicated entries.
+
+       root is the number of index bits for the root table.  When len exceeds
+       root, sub-tables are created pointed to by the root entry with an index
+       of the low root bits of huff.  This is saved in low to check for when a
+       new sub-table should be started.  drop is zero when the root table is
+       being filled, and drop is root when sub-tables are being filled.
+
+       When a new sub-table is needed, it is necessary to look ahead in the
+       code lengths to determine what size sub-table is needed.  The length
+       counts are used for this, and so count[] is decremented as codes are
+       entered in the tables.
+
+       used keeps track of how many table entries have been allocated from the
+       provided *table space.  It is checked when a LENS table is being made
+       against the space in *table, ENOUGH, minus the maximum space needed by
+       the worst case distance code, MAXD.  This should never happen, but the
+       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
+       This assumes that when type == LENS, bits == 9.
+
+       sym increments through all symbols, and the loop terminates when
+       all codes of length max, i.e. all codes, have been processed.  This
+       routine permits incomplete codes, so another loop after this one fills
+       in the rest of the decoding tables with invalid code markers.
+     */
 
-local int inflate_blocks(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
-{
-  uInt t;               /* temporary storage */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input based on current state */
-  while (1) switch (s->mode)
-  {
-    case TYPE:
-      NEEDBITS(3)
-      t = (uInt)b & 7;
-      s->last = t & 1;
-      switch (t >> 1)
-      {
-	case 0:                         /* stored */
-	  Trace((stderr, "inflate:     stored block%s\n",
-		 s->last ? " (last)" : ""));
-	  DUMPBITS(3)
-	  t = k & 7;                    /* go to byte boundary */
-	  DUMPBITS(t)
-	  s->mode = LENS;               /* get length of stored block */
-	  break;
-	case 1:                         /* fixed */
-	  Trace((stderr, "inflate:     fixed codes block%s\n",
-		 s->last ? " (last)" : ""));
-	  {
-	    uInt bl, bd;
-	    inflate_huft *tl, *td;
-
-	    inflate_trees_fixed(&bl, &bd, &tl, &td);
-	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
-	    if (s->sub.decode.codes == Z_NULL)
-	    {
-	      r = Z_MEM_ERROR;
-	      LEAVE
-	    }
-	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
-	    s->sub.decode.td = Z_NULL;
-	  }
-	  DUMPBITS(3)
-	  s->mode = CODES;
-	  break;
-	case 2:                         /* dynamic */
-	  Trace((stderr, "inflate:     dynamic codes block%s\n",
-		 s->last ? " (last)" : ""));
-	  DUMPBITS(3)
-	  s->mode = TABLE;
-	  break;
-	case 3:                         /* illegal */
-	  DUMPBITS(3)
-	  s->mode = BADB;
-	  z->msg = "invalid block type";
-	  r = Z_DATA_ERROR;
-	  LEAVE
-      }
-      break;
-    case LENS:
-      NEEDBITS(32)
-      if (((~b) >> 16) != (b & 0xffff))
-      {
-	s->mode = BADB;
-	z->msg = "invalid stored block lengths";
-	r = Z_DATA_ERROR;
-	LEAVE
-      }
-      s->sub.left = (uInt)b & 0xffff;
-      b = k = 0;                      /* dump bits */
-      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
-      s->mode = s->sub.left ? STORED : TYPE;
-      break;
-    case STORED:
-      if (n == 0)
-	LEAVE
-      NEEDOUT
-      t = s->sub.left;
-      if (t > n) t = n;
-      if (t > m) t = m;
-      zmemcpy(q, p, t);
-      p += t;  n -= t;
-      q += t;  m -= t;
-      if ((s->sub.left -= t) != 0)
-	break;
-      Tracev((stderr, "inflate:       stored end, %lu total out\n",
-	      z->total_out + (q >= s->read ? q - s->read :
-	      (s->end - s->read) + (q - s->window))));
-      s->mode = s->last ? DRY : TYPE;
-      break;
-    case TABLE:
-      NEEDBITS(14)
-      s->sub.trees.table = t = (uInt)b & 0x3fff;
-#ifndef PKZIP_BUG_WORKAROUND
-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
-      {
-	s->mode = BADB;
-	z->msg = "too many length or distance symbols";
-	r = Z_DATA_ERROR;
-	LEAVE
-      }
-#endif
-      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
-      if (t < 19)
-	t = 19;
-      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
-      {
-	r = Z_MEM_ERROR;
-	LEAVE
-      }
-      s->sub.trees.nblens = t;
-      DUMPBITS(14)
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       table sizes ok\n"));
-      s->mode = BTREE;
-    case BTREE:
-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
-      {
-	NEEDBITS(3)
-	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
-	DUMPBITS(3)
-      }
-      while (s->sub.trees.index < 19)
-	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
-      s->sub.trees.bb = 7;
-      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
-			     &s->sub.trees.tb, z);
-      if (t != Z_OK)
-      {
-	r = t;
-	if (r == Z_DATA_ERROR)
-	  s->mode = BADB;
-	LEAVE
-      }
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       bits tree ok\n"));
-      s->mode = DTREE;
-    case DTREE:
-      while (t = s->sub.trees.table,
-	     s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
-      {
-	inflate_huft *h;
-	uInt i, j, c;
-
-	t = s->sub.trees.bb;
-	NEEDBITS(t)
-	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
-	t = h->word.what.Bits;
-	c = h->more.Base;
-	if (c < 16)
-	{
-	  DUMPBITS(t)
-	  s->sub.trees.blens[s->sub.trees.index++] = c;
-	}
-	else /* c == 16..18 */
-	{
-	  i = c == 18 ? 7 : c - 14;
-	  j = c == 18 ? 11 : 3;
-	  NEEDBITS(t + i)
-	  DUMPBITS(t)
-	  j += (uInt)b & inflate_mask[i];
-	  DUMPBITS(i)
-	  i = s->sub.trees.index;
-	  t = s->sub.trees.table;
-	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
-	      (c == 16 && i < 1))
-	  {
-	    s->mode = BADB;
-	    z->msg = "invalid bit length repeat";
-	    r = Z_DATA_ERROR;
-	    LEAVE
-	  }
-	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
-	  do {
-	    s->sub.trees.blens[i++] = c;
-	  } while (--j);
-	  s->sub.trees.index = i;
-	}
-      }
-      inflate_trees_free(s->sub.trees.tb, z);
-      s->sub.trees.tb = Z_NULL;
-      {
-	uInt bl, bd;
-	inflate_huft *tl, *td;
-	inflate_codes_statef *c;
-
-	bl = 9;         /* must be <= 9 for lookahead assumptions */
-	bd = 6;         /* must be <= 9 for lookahead assumptions */
-	t = s->sub.trees.table;
-	t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
-				  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
-	if (t != Z_OK)
-	{
-	  if (t == (uInt)Z_DATA_ERROR)
-	    s->mode = BADB;
-	  r = t;
-	  LEAVE
-	}
-	Tracev((stderr, "inflate:       trees ok\n"));
-	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
-	{
-	  inflate_trees_free(td, z);
-	  inflate_trees_free(tl, z);
-	  r = Z_MEM_ERROR;
-	  LEAVE
-	}
-	ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
-	s->sub.decode.codes = c;
-	s->sub.decode.tl = tl;
-	s->sub.decode.td = td;
-      }
-      s->mode = CODES;
+    /* set up for code type */
+    switch (type) {
     case CODES:
-      UPDATE
-      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
-	return inflate_flush(s, z, r);
-      r = Z_OK;
-      inflate_codes_free(s->sub.decode.codes, z);
-      inflate_trees_free(s->sub.decode.td, z);
-      inflate_trees_free(s->sub.decode.tl, z);
-      LOAD
-      Tracev((stderr, "inflate:       codes end, %lu total out\n",
-	      z->total_out + (q >= s->read ? q - s->read :
-	      (s->end - s->read) + (q - s->window))));
-      if (!s->last)
-      {
-	s->mode = TYPE;
-	break;
-      }
-      if (k > 7)              /* return unused byte, if any */
-      {
-	Assert(k < 16, "inflate_codes grabbed too many bytes")
-	k -= 8;
-	n++;
-	p--;                    /* can always return one */
-      }
-      s->mode = DRY;
-    case DRY:
-      FLUSH
-      if (s->read != s->write)
-	LEAVE
-      s->mode = DONEB;
-    case DONEB:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADB:
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-}
-
+        base = extra = work;    /* dummy value--not used */
+        end = 19;
+        break;
+    case LENS:
+        base = lbase;
+        base -= 257;
+        extra = lext;
+        extra -= 257;
+        end = 256;
+        break;
+    default:            /* DISTS */
+        base = dbase;
+        extra = dext;
+        end = -1;
+    }
 
-local int inflate_blocks_free(s, z, c)
-inflate_blocks_statef *s;
-z_stream *z;
-uLongf *c;
-{
-  inflate_blocks_reset(s, z, c);
-  ZFREE(z, s->window, s->end - s->window);
-  ZFREE(z, s, sizeof(struct inflate_blocks_state));
-  Trace((stderr, "inflate:   blocks freed\n"));
-  return Z_OK;
-}
+    /* initialize state for loop */
+    huff = 0;                   /* starting code */
+    sym = 0;                    /* starting code symbol */
+    len = min;                  /* starting code length */
+    next = *table;              /* current table to fill in */
+    curr = root;                /* current table index bits */
+    drop = 0;                   /* current bits to drop from code for index */
+    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
+    used = 1U << root;          /* use root table entries */
+    mask = used - 1;            /* mask for comparing low */
+
+    /* check available table space */
+    if (type == LENS && used >= ENOUGH - MAXD)
+        return 1;
+
+    /* process all codes and make table entries */
+    for (;;) {
+        /* create table entry */
+        this.bits = (unsigned char)(len - drop);
+        if ((int)(work[sym]) < end) {
+            this.op = (unsigned char)0;
+            this.val = work[sym];
+        }
+        else if ((int)(work[sym]) > end) {
+            this.op = (unsigned char)(extra[work[sym]]);
+            this.val = base[work[sym]];
+        }
+        else {
+            this.op = (unsigned char)(32 + 64);         /* end of block */
+            this.val = 0;
+        }
+
+        /* replicate for those indices with low len bits equal to huff */
+        incr = 1U << (len - drop);
+        fill = 1U << curr;
+        min = fill;                 /* save offset to next table */
+        do {
+            fill -= incr;
+            next[(huff >> drop) + fill] = this;
+        } while (fill != 0);
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+
+        /* go to next symbol, update count, len */
+        sym++;
+        if (--(count[len]) == 0) {
+            if (len == max) break;
+            len = lens[work[sym]];
+        }
+
+        /* create new sub-table if needed */
+        if (len > root && (huff & mask) != low) {
+            /* if first time, transition to sub-tables */
+            if (drop == 0)
+                drop = root;
+
+            /* increment past last table */
+            next += min;            /* here min is 1 << curr */
+
+            /* determine length of next table */
+            curr = len - drop;
+            left = (int)(1 << curr);
+            while (curr + drop < max) {
+                left -= count[curr + drop];
+                if (left <= 0) break;
+                curr++;
+                left <<= 1;
+            }
+
+            /* check for enough space */
+            used += 1U << curr;
+            if (type == LENS && used >= ENOUGH - MAXD)
+                return 1;
+
+            /* point entry in root table to sub-table */
+            low = huff & mask;
+            (*table)[low].op = (unsigned char)curr;
+            (*table)[low].bits = (unsigned char)root;
+            (*table)[low].val = (unsigned short)(next - *table);
+        }
+    }
 
-/*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
- */
-local int inflate_addhistory(s, z)
-inflate_blocks_statef *s;
-z_stream *z;
-{
-    uLong b;              /* bit buffer */  /* NOT USED HERE */
-    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
-    uInt t;               /* temporary storage */
-    Bytef *p;             /* input data pointer */
-    uInt n;               /* bytes available there */
-    Bytef *q;             /* output window write pointer */
-    uInt m;               /* bytes to end of window or read pointer */
-
-    if (s->read != s->write)
-	return Z_STREAM_ERROR;
-    if (s->mode != TYPE)
-	return Z_DATA_ERROR;
-
-    /* we're ready to rock */
-    LOAD
-    /* while there is input ready, copy to output buffer, moving
-     * pointers as needed.
+    /*
+       Fill in rest of table for incomplete codes.  This loop is similar to the
+       loop above in incrementing huff for table indices.  It is assumed that
+       len is equal to curr + drop, so there is no loop needed to increment
+       through high index bits.  When the current sub-table is filled, the loop
+       drops back to the root table to fill in any remaining entries there.
      */
-    while (n) {
-	t = n;  /* how many to do */
-	/* is there room until end of buffer? */
-	if (t > m) t = m;
-	/* update check information */
-	if (s->checkfn != Z_NULL)
-	    s->check = (*s->checkfn)(s->check, q, t);
-	/* output callback */
-	if (z->outcb != Z_NULL)
-	    (*z->outcb)(q, t);
-	zmemcpy(q, p, t);
-	q += t;
-	p += t;
-	n -= t;
-	z->total_out += t;
-	s->read = q;    /* drag read pointer forward */
-/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
-	if (q == s->end) {
-	    s->read = q = s->window;
-	    m = WAVAIL;
-	}
+    this.op = (unsigned char)64;                /* invalid code marker */
+    this.bits = (unsigned char)(len - drop);
+    this.val = (unsigned short)0;
+    while (huff != 0) {
+        /* when done with sub-table, drop back to root table */
+        if (drop != 0 && (huff & mask) != low) {
+            drop = 0;
+            len = root;
+            next = *table;
+            this.bits = (unsigned char)len;
+        }
+
+        /* put invalid code marker in table */
+        next[huff >> drop] = this;
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
     }
-    UPDATE
-    return Z_OK;
-}
 
-
-/*
- * At the end of a Deflate-compressed PPP packet, we expect to have seen
- * a `stored' block type value but not the (zero) length bytes.
- */
-local int inflate_packet_flush(s)
-    inflate_blocks_statef *s;
-{
-    if (s->mode != LENS)
-	return Z_DATA_ERROR;
-    s->mode = TYPE;
-    return Z_OK;
+    /* set return parameters */
+    *table += used;
+    *bits = root;
+    return 0;
 }
 
-
 /*+++++*/
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995 Mark Adler
+/* inflate.c -- zlib decompression
+ * Copyright (C) 1995-2005 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
+local void fixedtables OF((struct inflate_state FAR *state));
+local int updatewindow OF((z_streamp strm, unsigned out));
 
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-
-local int huft_build OF((
-    uIntf *,            /* code lengths in bits */
-    uInt,               /* number of codes */
-    uInt,               /* number of "simple" codes */
-    uIntf *,            /* list of base values for non-simple codes */
-    uIntf *,            /* list of extra bits for non-simple codes */
-    inflate_huft * FAR*,/* result: starting table */
-    uIntf *,            /* maximum lookup bits (returns actual) */
-    z_stream *));       /* for zalloc function */
-
-local voidpf falloc OF((
-    voidpf,             /* opaque pointer (not used) */
-    uInt,               /* number of items */
-    uInt));             /* size of item */
-
-local void ffree OF((
-    voidpf q,           /* opaque pointer (not used) */
-    voidpf p,           /* what to free (not used) */
-    uInt n));		/* number of bytes (not used) */
-
-/* Tables for deflate from PKZIP's appnote.txt. */
-local uInt cplens[] = { /* Copy lengths for literal codes 257..285 */
-	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-	/* actually lengths - 2; also see note #13 above about 258 */
-local uInt cplext[] = { /* Extra bits for literal codes 257..285 */
-	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 192, 192}; /* 192==invalid */
-local uInt cpdist[] = { /* Copy offsets for distance codes 0..29 */
-	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-	8193, 12289, 16385, 24577};
-local uInt cpdext[] = { /* Extra bits for distance codes */
-	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-	12, 12, 13, 13};
-
-/*
-   Huffman code decoding is performed using a multi-level table lookup.
-   The fastest way to decode is to simply build a lookup table whose
-   size is determined by the longest code.  However, the time it takes
-   to build this table can also be a factor if the data being decoded
-   is not very long.  The most common codes are necessarily the
-   shortest codes, so those codes dominate the decoding time, and hence
-   the speed.  The idea is you can have a shorter table that decodes the
-   shorter, more probable codes, and then point to subsidiary tables for
-   the longer codes.  The time it costs to decode the longer codes is
-   then traded against the time it takes to make longer tables.
-
-   This results of this trade are in the variables lbits and dbits
-   below.  lbits is the number of bits the first level table for literal/
-   length codes can decode in one step, and dbits is the same thing for
-   the distance codes.  Subsequent tables are also less than or equal to
-   those sizes.  These values may be adjusted either when all of the
-   codes are shorter than that, in which case the longest code length in
-   bits is used, or when the shortest code is *longer* than the requested
-   table size, in which case the length of the shortest code in bits is
-   used.
-
-   There are two different values for the two tables, since they code a
-   different number of possibilities each.  The literal/length table
-   codes 286 possible values, or in a flat code, a little over eight
-   bits.  The distance table codes 30 possible values, or a little less
-   than five bits, flat.  The optimum values for speed end up being
-   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
-   The optimum values may differ though from machine to machine, and
-   possibly even between compilers.  Your mileage may vary.
- */
-
-
-/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
-#define BMAX 15         /* maximum bit length of any code */
-#define N_MAX 288       /* maximum number of codes in any set */
-
-#ifdef DEBUG_ZLIB
-  uInt inflate_hufts;
-#endif
-
-local int huft_build(b, n, s, d, e, t, m, zs)
-uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
-uInt n;                 /* number of codes (assumed <= N_MAX) */
-uInt s;                 /* number of simple-valued codes (0..s-1) */
-uIntf *d;               /* list of base values for non-simple codes */
-uIntf *e;               /* list of extra bits for non-simple codes */
-inflate_huft * FAR *t;  /* result: starting table */
-uIntf *m;               /* maximum lookup bits, returns actual */
-z_stream *zs;           /* for zalloc function */
-/* Given a list of code lengths and a maximum table size, make a set of
-   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
-   if the given code set is incomplete (the tables are still built in this
-   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
-   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
+int ZEXPORT inflateReset(strm)
+z_streamp strm;
 {
-
-  uInt a;                       /* counter for codes of length k */
-  uInt c[BMAX+1];               /* bit length count table */
-  uInt f;                       /* i repeats in table every f entries */
-  int g;                        /* maximum code length */
-  int h;                        /* table level */
-  register uInt i;              /* counter, current code */
-  register uInt j;              /* counter */
-  register int k;               /* number of bits in current code */
-  int l;                        /* bits per table (returned in m) */
-  register uIntf *p;            /* pointer into c[], b[], or v[] */
-  inflate_huft *q;              /* points to current table */
-  struct inflate_huft_s r;      /* table entry for structure assignment */
-  inflate_huft *u[BMAX];        /* table stack */
-  uInt v[N_MAX];                /* values in order of bit length */
-  register int w;               /* bits before this table == (l * h) */
-  uInt x[BMAX+1];               /* bit offsets, then code stack */
-  uIntf *xp;                    /* pointer into x */
-  int y;                        /* number of dummy codes added */
-  uInt z;                       /* number of entries in current table */
-
-
-  /* Generate counts for each bit length */
-  p = c;
-#define C0 *p++ = 0;
-#define C2 C0 C0 C0 C0
-#define C4 C2 C2 C2 C2
-  C4                            /* clear c[]--assume BMAX+1 is 16 */
-  p = b;  i = n;
-  do {
-    c[*p++]++;                  /* assume all entries <= BMAX */
-  } while (--i);
-  if (c[0] == n)                /* null input--all zero length codes */
-  {
-    *t = (inflate_huft *)Z_NULL;
-    *m = 0;
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    strm->total_in = strm->total_out = state->total = 0;
+    strm->msg = Z_NULL;
+    strm->adler = 1;        /* to support ill-conceived Java test suite */
+    state->mode = HEAD;
+    state->last = 0;
+    state->havedict = 0;
+    state->dmax = 32768U;
+    state->head = Z_NULL;
+    state->wsize = 0;
+    state->whave = 0;
+    state->write = 0;
+    state->hold = 0;
+    state->bits = 0;
+    state->lencode = state->distcode = state->next = state->codes;
+    if (strm->outcb != Z_NULL)
+	(*strm->outcb)(Z_NULL, 0);
+    Tracev((stderr, "inflate: reset\n"));
     return Z_OK;
-  }
-
-
-  /* Find minimum and maximum length, bound *m by those */
-  l = *m;
-  for (j = 1; j <= BMAX; j++)
-    if (c[j])
-      break;
-  k = j;                        /* minimum code length */
-  if ((uInt)l < j)
-    l = j;
-  for (i = BMAX; i; i--)
-    if (c[i])
-      break;
-  g = i;                        /* maximum code length */
-  if ((uInt)l > i)
-    l = i;
-  *m = l;
-
-
-  /* Adjust last length count to fill out codes, if needed */
-  for (y = 1 << j; j < i; j++, y <<= 1)
-    if ((y -= c[j]) < 0)
-      return Z_DATA_ERROR;
-  if ((y -= c[i]) < 0)
-    return Z_DATA_ERROR;
-  c[i] += y;
-
-
-  /* Generate starting offsets into the value table for each length */
-  x[1] = j = 0;
-  p = c + 1;  xp = x + 2;
-  while (--i) {                 /* note that i == g from above */
-    *xp++ = (j += *p++);
-  }
-
-
-  /* Make a table of values in order of bit lengths */
-  p = b;  i = 0;
-  do {
-    if ((j = *p++) != 0)
-      v[x[j]++] = i;
-  } while (++i < n);
-
-
-  /* Generate the Huffman codes and for each, make the table entries */
-  x[0] = i = 0;                 /* first Huffman code is zero */
-  p = v;                        /* grab values in bit order */
-  h = -1;                       /* no tables yet--level -1 */
-  w = -l;                       /* bits decoded == (l * h) */
-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
-  q = (inflate_huft *)Z_NULL;   /* ditto */
-  z = 0;                        /* ditto */
-
-  /* go through the bit lengths (k already is bits in shortest code) */
-  for (; k <= g; k++)
-  {
-    a = c[k];
-    while (a--)
-    {
-      /* here i is the Huffman code of length k bits for value *p */
-      /* make tables up to required level */
-      while (k > w + l)
-      {
-	h++;
-	w += l;                 /* previous table always l bits */
-
-	/* compute minimum size table less than or equal to l bits */
-	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
-	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
-	{                       /* too few codes for k-w bit table */
-	  f -= a + 1;           /* deduct codes from patterns left */
-	  xp = c + k;
-	  if (j < z)
-	    while (++j < z)     /* try smaller tables up to z bits */
-	    {
-	      if ((f <<= 1) <= *++xp)
-		break;          /* enough codes to use up j bits */
-	      f -= *xp;         /* else deduct codes from patterns */
-	    }
-	}
-	z = 1 << j;             /* table entries for j-bit table */
-
-	/* allocate and link in new table */
-	if ((q = (inflate_huft *)ZALLOC
-	     (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
-	{
-	  if (h)
-	    inflate_trees_free(u[0], zs);
-	  return Z_MEM_ERROR;   /* not enough memory */
-	}
-	q->word.Nalloc = z + 1;
-#ifdef DEBUG_ZLIB
-	inflate_hufts += z + 1;
-#endif
-	*t = q + 1;             /* link to list for huft_free() */
-	*(t = &(q->next)) = Z_NULL;
-	u[h] = ++q;             /* table starts after link */
-
-	/* connect to last table, if there is one */
-	if (h)
-	{
-	  x[h] = i;             /* save pattern for backing up */
-	  r.bits = (Byte)l;     /* bits to dump before this table */
-	  r.exop = (Byte)j;     /* bits in this table */
-	  r.next = q;           /* pointer to this table */
-	  j = i >> (w - l);     /* (get around Turbo C bug) */
-	  u[h-1][j] = r;        /* connect to last table */
-	}
-      }
-
-      /* set up table entry in r */
-      r.bits = (Byte)(k - w);
-      if (p >= v + n)
-	r.exop = 128 + 64;      /* out of values--invalid code */
-      else if (*p < s)
-      {
-	r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
-	r.base = *p++;          /* simple code is just the value */
-      }
-      else
-      {
-	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
-	r.base = d[*p++ - s];
-      }
-
-      /* fill code-like entries with r */
-      f = 1 << (k - w);
-      for (j = i >> w; j < z; j += f)
-	q[j] = r;
-
-      /* backwards increment the k-bit code i */
-      for (j = 1 << (k - 1); i & j; j >>= 1)
-	i ^= j;
-      i ^= j;
-
-      /* backup over finished tables */
-      while ((i & ((1 << w) - 1)) != x[h])
-      {
-	h--;                    /* don't need to update q */
-	w -= l;
-      }
-    }
-  }
-
-
-  /* Return Z_BUF_ERROR if we were given an incomplete table */
-  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
-}
-
-
-local int inflate_trees_bits(c, bb, tb, z)
-uIntf *c;               /* 19 code lengths */
-uIntf *bb;              /* bits tree desired/actual depth */
-inflate_huft * FAR *tb; /* bits tree result */
-z_stream *z;            /* for zfree function */
-{
-  int r;
-
-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
-  if (r == Z_DATA_ERROR)
-    z->msg = "oversubscribed dynamic bit lengths tree";
-  else if (r == Z_BUF_ERROR)
-  {
-    inflate_trees_free(*tb, z);
-    z->msg = "incomplete dynamic bit lengths tree";
-    r = Z_DATA_ERROR;
-  }
-  return r;
 }
 
-
-local int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
-uInt nl;                /* number of literal/length codes */
-uInt nd;                /* number of distance codes */
-uIntf *c;               /* that many (total) code lengths */
-uIntf *bl;              /* literal desired/actual bit depth */
-uIntf *bd;              /* distance desired/actual bit depth */
-inflate_huft * FAR *tl; /* literal/length tree result */
-inflate_huft * FAR *td; /* distance tree result */
-z_stream *z;            /* for zfree function */
+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
 {
-  int r;
-
-  /* build literal/length tree */
-  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = "oversubscribed literal/length tree";
-    else if (r == Z_BUF_ERROR)
-    {
-      inflate_trees_free(*tl, z);
-      z->msg = "incomplete literal/length tree";
-      r = Z_DATA_ERROR;
-    }
-    return r;
-  }
-
-  /* build distance tree */
-  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = "oversubscribed literal/length tree";
-    else if (r == Z_BUF_ERROR) {
-#ifdef PKZIP_BUG_WORKAROUND
-      r = Z_OK;
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    strm->msg = Z_NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0) {
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
     }
-#else
-      inflate_trees_free(*td, z);
-      z->msg = "incomplete literal/length tree";
-      r = Z_DATA_ERROR;
+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    state = (struct inflate_state FAR *)
+            ZALLOC(strm, 1, sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, "inflate: allocated\n"));
+    strm->state = (struct internal_state FAR *)state;
+    if (windowBits < 0) {
+        state->wrap = 0;
+        windowBits = -windowBits;
     }
-    inflate_trees_free(*tl, z);
-    return r;
+    else {
+        state->wrap = (windowBits >> 4) + 1;
+#ifdef GUNZIP
+        if (windowBits < 48) windowBits &= 15;
 #endif
-  }
-
-  /* done */
-  return Z_OK;
-}
-
-
-/* build fixed tables only once--keep them here */
-local int fixed_lock = 0;
-local int fixed_built = 0;
-#define FIXEDH 530      /* number of hufts used by fixed tables */
-local uInt fixed_left = FIXEDH;
-local inflate_huft fixed_mem[FIXEDH];
-local uInt fixed_bl;
-local uInt fixed_bd;
-local inflate_huft *fixed_tl;
-local inflate_huft *fixed_td;
-
-
-local voidpf falloc(q, n, s)
-voidpf q;        /* opaque pointer (not used) */
-uInt n;         /* number of items */
-uInt s;         /* size of item */
-{
-  Assert(s == sizeof(inflate_huft) && n <= fixed_left,
-	 "inflate_trees falloc overflow");
-  if (q) s++; /* to make some compilers happy */
-  fixed_left -= n;
-  return (voidpf)(fixed_mem + fixed_left);
-}
-
-
-local void ffree(q, p, n)
-voidpf q;
-voidpf p;
-uInt n;
-{
-  Assert(0, "inflate_trees ffree called!");
-  if (q) q = p; /* to make some compilers happy */
+    }
+    if (windowBits < 8 || windowBits > 15) {
+        ZFREE(strm, state);
+        strm->state = Z_NULL;
+        return Z_STREAM_ERROR;
+    }
+    state->wbits = (unsigned)windowBits;
+    state->window = Z_NULL;
+    return inflateReset(strm);
 }
 
-
-local int inflate_trees_fixed(bl, bd, tl, td)
-uIntf *bl;               /* literal desired/actual bit depth */
-uIntf *bd;               /* distance desired/actual bit depth */
-inflate_huft * FAR *tl;  /* literal/length tree result */
-inflate_huft * FAR *td;  /* distance tree result */
+int ZEXPORT inflateInit_(strm, version, stream_size)
+z_streamp strm;
+const char *version;
+int stream_size;
 {
-  /* build fixed tables if not built already--lock out other instances */
-  while (++fixed_lock > 1)
-    fixed_lock--;
-  if (!fixed_built)
-  {
-    int k;              /* temporary variable */
-    unsigned c[288];    /* length list for huft_build */
-    z_stream z;         /* for falloc function */
-
-    /* set up fake z_stream for memory routines */
-    z.zalloc = falloc;
-    z.zfree = ffree;
-    z.opaque = Z_NULL;
-
-    /* literal table */
-    for (k = 0; k < 144; k++)
-      c[k] = 8;
-    for (; k < 256; k++)
-      c[k] = 9;
-    for (; k < 280; k++)
-      c[k] = 7;
-    for (; k < 288; k++)
-      c[k] = 8;
-    fixed_bl = 7;
-    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
-
-    /* distance table */
-    for (k = 0; k < 30; k++)
-      c[k] = 5;
-    fixed_bd = 5;
-    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
-
-    /* done */
-    fixed_built = 1;
-  }
-  fixed_lock--;
-  *bl = fixed_bl;
-  *bd = fixed_bd;
-  *tl = fixed_tl;
-  *td = fixed_td;
-  return Z_OK;
+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
 }
 
-
-local int inflate_trees_free(t, z)
-inflate_huft *t;        /* table to free */
-z_stream *z;            /* for zfree function */
-/* Free the malloc'ed tables built by huft_build(), which makes a linked
-   list of the tables it made, with the links in a dummy first entry of
-   each table. */
+local void fixedtables(state)
+struct inflate_state FAR *state;
 {
-  register inflate_huft *p, *q;
-
-  /* Go through linked list, freeing from the malloced (t[-1]) address. */
-  p = t;
-  while (p != Z_NULL)
-  {
-    q = (--p)->next;
-    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
-    p = q;
-  }
-  return Z_OK;
+    state->lencode = lenfix;
+    state->lenbits = 9;
+    state->distcode = distfix;
+    state->distbits = 5;
 }
 
-/*+++++*/
-/* infcodes.c -- process literals and length/distance pairs
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
+/*
+   Update the window with the last wsize (normally 32K) bytes written before
+   returning.  If window does not exist yet, create it.  This is only called
+   when a window is already in use, or when output has been written during this
+   inflate call, but the end of the deflate stream has not been reached yet.
+   It is also called to create a window for dictionary data when a dictionary
+   is loaded.
+
+   Providing output buffers larger than 32K to inflate() should provide a speed
+   advantage, since only the last 32K of output is copied to the sliding window
+   upon return from inflate(), and since all distances after the first 32K of
+   output will fall in the output data, making match copies simpler and faster.
+   The advantage may be dependent on the size of the processor's data caches.
  */
+local int updatewindow(strm, out)
+z_streamp strm;
+unsigned out;
+{
+    struct inflate_state FAR *state;
+    unsigned copy, dist;
 
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* inflate codes private state */
-struct inflate_codes_state {
-
-  /* mode */
-  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-      START,    /* x: set up for LEN */
-      LEN,      /* i: get length/literal/eob next */
-      LENEXT,   /* i: getting length extra (have base) */
-      DIST,     /* i: get distance next */
-      DISTEXT,  /* i: getting distance extra */
-      COPY,     /* o: copying bytes in window, waiting for space */
-      LIT,      /* o: got literal, waiting for output space */
-      WASH,     /* o: got eob, possibly still output waiting */
-      END,      /* x: got eob and all data flushed */
-      BADCODE}  /* x: got error */
-    mode;               /* current inflate_codes mode */
-
-  /* mode dependent information */
-  uInt len;
-  union {
-    struct {
-      inflate_huft *tree;       /* pointer into tree */
-      uInt need;                /* bits needed */
-    } code;             /* if LEN or DIST, where in tree */
-    uInt lit;           /* if LIT, literal */
-    struct {
-      uInt get;                 /* bits to get for extra */
-      uInt dist;                /* distance back to copy from */
-    } copy;             /* if EXT or COPY, where and how much */
-  } sub;                /* submode */
-
-  /* mode independent information */
-  Byte lbits;           /* ltree bits decoded per branch */
-  Byte dbits;           /* dtree bits decoder per branch */
-  inflate_huft *ltree;          /* literal/length/eob tree */
-  inflate_huft *dtree;          /* distance tree */
+    state = (struct inflate_state FAR *)strm->state;
 
-};
+    /* if it hasn't been done already, allocate space for the window */
+    if (state->window == Z_NULL) {
+        state->window = (unsigned char FAR *)
+                        ZALLOC(strm, 1U << state->wbits,
+                               sizeof(unsigned char));
+        if (state->window == Z_NULL) return 1;
+    }
 
+    /* if window not in use yet, initialize */
+    if (state->wsize == 0) {
+        state->wsize = 1U << state->wbits;
+        state->write = 0;
+        state->whave = 0;
+    }
 
-local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
-uInt bl, bd;
-inflate_huft *tl, *td;
-z_stream *z;
-{
-  inflate_codes_statef *c;
-
-  if ((c = (inflate_codes_statef *)
-       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
-  {
-    c->mode = START;
-    c->lbits = (Byte)bl;
-    c->dbits = (Byte)bd;
-    c->ltree = tl;
-    c->dtree = td;
-    Tracev((stderr, "inflate:       codes new\n"));
-  }
-  return c;
+    /* copy state->wsize or less output bytes into the circular window */
+    copy = out - strm->avail_out;
+    if (copy >= state->wsize) {
+        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
+        state->write = 0;
+        state->whave = state->wsize;
+    }
+    else {
+        dist = state->wsize - state->write;
+        if (dist > copy) dist = copy;
+        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
+        copy -= dist;
+        if (copy) {
+            zmemcpy(state->window, strm->next_out - copy, copy);
+            state->write = copy;
+            state->whave = state->wsize;
+        }
+        else {
+            state->write += dist;
+            if (state->write == state->wsize) state->write = 0;
+            if (state->whave < state->wsize) state->whave += dist;
+        }
+    }
+    return 0;
 }
 
+/* Macros for inflate(): */
+
+/* check function to use adler32() for zlib or crc32() for gzip */
+#define UPDATE(check, buf, len) \
+	(state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
+
+/* check macros for header crc */
+#define CRC2(check, word) \
+	do { \
+		hbuf[0] = (unsigned char)(word); \
+		hbuf[1] = (unsigned char)((word) >> 8); \
+		check = crc32(check, hbuf, 2); \
+	} while (0)
+
+#define CRC4(check, word) \
+	do { \
+		hbuf[0] = (unsigned char)(word); \
+		hbuf[1] = (unsigned char)((word) >> 8); \
+		hbuf[2] = (unsigned char)((word) >> 16); \
+		hbuf[3] = (unsigned char)((word) >> 24); \
+		check = crc32(check, hbuf, 4); \
+	} while (0)
+
+/* Load registers with state in inflate() for speed */
+#define LOAD() \
+	do { \
+		put = strm->next_out; \
+		left = strm->avail_out; \
+		next = strm->next_in; \
+		have = strm->avail_in; \
+		hold = state->hold; \
+		bits = state->bits; \
+	} while (0)
+
+/* Restore state from registers in inflate() */
+#define RESTORE() \
+	do { \
+		strm->next_out = put; \
+		strm->avail_out = left; \
+		strm->next_in = next; \
+		strm->avail_in = have; \
+		state->hold = hold; \
+		state->bits = bits; \
+	} while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+	do { \
+		hold = 0; \
+		bits = 0; \
+	} while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflate()
+   if there is no input available. */
+#define PULLBYTE() \
+	do { \
+		if (have == 0) goto inf_leave; \
+		have--; \
+		hold += (unsigned long)(*next++) << bits; \
+		bits += 8; \
+	} while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflate(). */
+#define NEEDBITS(n) \
+	do { \
+		while (bits < (unsigned)(n)) \
+			PULLBYTE(); \
+	} while (0)
+
+/* Return the low n bits of the bit accumulator (n < 16) */
+#define BITS(n) \
+	((unsigned)hold & ((1U << (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+	do { \
+		hold >>= (n); \
+		bits -= (unsigned)(n); \
+	} while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+	do { \
+		hold >>= bits & 7; \
+		bits -= bits & 7; \
+	} while (0)
+
+/* Reverse the bytes in a 32-bit value */
+#define REVERSE(q) \
+	((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
+		(((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
 
-local int inflate_codes(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
+/*
+   inflate() uses a state machine to process as much input data and generate as
+   much output data as possible before returning.  The state machine is
+   structured roughly as follows:
+
+    for (;;) switch (state) {
+    ...
+    case STATEn:
+        if (not enough input data or output space to make progress)
+            return;
+        ... make progress ...
+        state = STATEm;
+        break;
+    ...
+    }
+
+   so when inflate() is called again, the same case is attempted again, and
+   if the appropriate resources are provided, the machine proceeds to the
+   next state.  The NEEDBITS() macro is usually the way the state evaluates
+   whether it can proceed or should return.  NEEDBITS() does the return if
+   the requested bits are not available.  The typical use of the BITS macros
+   is:
+
+        NEEDBITS(n);
+        ... do something with BITS(n) ...
+        DROPBITS(n);
+
+   where NEEDBITS(n) either returns from inflate() if there isn't enough
+   input left to load n bits into the accumulator, or it continues.  BITS(n)
+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
+   the low n bits off the accumulator.  INITBITS() clears the accumulator
+   and sets the number of available bits to zero.  BYTEBITS() discards just
+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
+
+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
+   if there is no input available.  The decoding of variable length codes uses
+   PULLBYTE() directly in order to pull just enough bytes to decode the next
+   code, and no more.
+
+   Some states loop until they get enough input, making sure that enough
+   state information is maintained to continue the loop where it left off
+   if NEEDBITS() returns in the loop.  For example, want, need, and keep
+   would all have to actually be part of the saved state in case NEEDBITS()
+   returns:
+
+    case STATEw:
+        while (want < need) {
+            NEEDBITS(n);
+            keep[want++] = BITS(n);
+            DROPBITS(n);
+        }
+        state = STATEx;
+    case STATEx:
+
+   As shown above, if the next state is also the next case, then the break
+   is omitted.
+
+   A state may also return if there is not enough output space available to
+   complete that state.  Those states are copying stored data, writing a
+   literal byte, and copying a matching string.
+
+   When returning, a "goto inf_leave" is used to update the total counters,
+   update the check value, and determine whether any progress has been made
+   during that inflate() call in order to return the proper return code.
+   Progress is defined as a change in either strm->avail_in or strm->avail_out.
+   When there is a window, goto inf_leave will update the window with the last
+   output written.  If a goto inf_leave occurs in the middle of decompression
+   and there is no window currently, goto inf_leave will create one and copy
+   output to the window for the next call of inflate().
+
+   In this implementation, the flush parameter of inflate() only affects the
+   return code (per zlib.h).  inflate() always writes as much as possible to
+   strm->next_out, given the space available and the provided input--the effect
+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
+   the allocation of and copying into a sliding window until necessary, which
+   provides the effect documented in zlib.h for Z_FINISH when the entire input
+   stream available.  So the only thing the flush parameter actually does is:
+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
+   will return Z_BUF_ERROR if it has not reached the end of the stream.
+ */
+int ZEXPORT inflate(strm, flush)
+z_streamp strm;
+int flush;
 {
-  uInt j;               /* temporary storage */
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  Bytef *f;             /* pointer to copy strings from */
-  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input and output based on current state */
-  while (1) switch (c->mode)
-  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-    case START:         /* x: set up for LEN */
-#ifndef SLOW
-      if (m >= 258 && n >= 10)
-      {
-	UPDATE
-	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
-	LOAD
-	if (r != Z_OK)
-	{
-	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
-	  break;
-	}
-      }
-#endif /* !SLOW */
-      c->sub.code.need = c->lbits;
-      c->sub.code.tree = c->ltree;
-      c->mode = LEN;
-    case LEN:           /* i: get length/literal/eob next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e == 0)               /* literal */
-      {
-	c->sub.lit = t->base;
-	Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		 "inflate:         literal '%c'\n" :
-		 "inflate:         literal 0x%02x\n", t->base));
-	c->mode = LIT;
-	break;
-      }
-      if (e & 16)               /* length */
-      {
-	c->sub.copy.get = e & 15;
-	c->len = t->base;
-	c->mode = LENEXT;
-	break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-	c->sub.code.need = e;
-	c->sub.code.tree = t->next;
-	break;
-      }
-      if (e & 32)               /* end of block */
-      {
-	Tracevv((stderr, "inflate:         end of block\n"));
-	c->mode = WASH;
-	break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = "invalid literal/length code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case LENEXT:        /* i: getting length extra (have base) */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->len += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      c->sub.code.need = c->dbits;
-      c->sub.code.tree = c->dtree;
-      Tracevv((stderr, "inflate:         length %u\n", c->len));
-      c->mode = DIST;
-    case DIST:          /* i: get distance next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e & 16)               /* distance */
-      {
-	c->sub.copy.get = e & 15;
-	c->sub.copy.dist = t->base;
-	c->mode = DISTEXT;
-	break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-	c->sub.code.need = e;
-	c->sub.code.tree = t->next;
-	break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = "invalid distance code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case DISTEXT:       /* i: getting distance extra */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->sub.copy.dist += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
-      c->mode = COPY;
-    case COPY:          /* o: copying bytes in window, waiting for space */
-#ifndef __TURBOC__ /* Turbo C bug for following expression */
-      f = (uInt)(q - s->window) < c->sub.copy.dist ?
-	  s->end - (c->sub.copy.dist - (q - s->window)) :
-	  q - c->sub.copy.dist;
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned in, out;           /* save starting available input and output */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code this;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+#ifdef GUNZIP
+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
+#endif
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0))
+        return Z_STREAM_ERROR;
+
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
+    LOAD();
+    in = have;
+    out = left;
+    ret = Z_OK;
+    for (;;)
+        switch (state->mode) {
+        case HEAD:
+            if (state->wrap == 0) {
+                state->mode = TYPEDO;
+                break;
+            }
+            NEEDBITS(16);
+#ifdef GUNZIP
+            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
+                state->check = crc32(0L, Z_NULL, 0);
+                CRC2(state->check, hold);
+                INITBITS();
+                state->mode = FLAGS;
+                break;
+            }
+            state->flags = 0;           /* expect zlib header */
+            if (state->head != Z_NULL)
+                state->head->done = -1;
+            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
 #else
-      f = q - c->sub.copy.dist;
-      if ((uInt)(q - s->window) < c->sub.copy.dist)
-	f = s->end - (c->sub.copy.dist - (q - s->window));
+            if (
+#endif
+                ((BITS(8) << 8) + (hold >> 8)) % 31) {
+                strm->msg = (char *)"incorrect header check";
+                state->mode = BAD;
+                break;
+            }
+            if (BITS(4) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            DROPBITS(4);
+            len = BITS(4) + 8;
+            if (len > state->wbits) {
+                strm->msg = (char *)"invalid window size";
+                state->mode = BAD;
+                break;
+            }
+            state->dmax = 1U << len;
+            Tracev((stderr, "inflate:   zlib header ok\n"));
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = hold & 0x200 ? DICTID : TYPE;
+            INITBITS();
+            break;
+#ifdef GUNZIP
+        case FLAGS:
+            NEEDBITS(16);
+            state->flags = (int)(hold);
+            if ((state->flags & 0xff) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            if (state->flags & 0xe000) {
+                strm->msg = (char *)"unknown header flags set";
+                state->mode = BAD;
+                break;
+            }
+            if (state->head != Z_NULL)
+                state->head->text = (int)((hold >> 8) & 1);
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = TIME;
+        case TIME:
+            NEEDBITS(32);
+            if (state->head != Z_NULL)
+                state->head->time = hold;
+            if (state->flags & 0x0200) CRC4(state->check, hold);
+            INITBITS();
+            state->mode = OS;
+        case OS:
+            NEEDBITS(16);
+            if (state->head != Z_NULL) {
+                state->head->xflags = (int)(hold & 0xff);
+                state->head->os = (int)(hold >> 8);
+            }
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = EXLEN;
+        case EXLEN:
+            if (state->flags & 0x0400) {
+                NEEDBITS(16);
+                state->length = (unsigned)(hold);
+                if (state->head != Z_NULL)
+                    state->head->extra_len = (unsigned)hold;
+                if (state->flags & 0x0200) CRC2(state->check, hold);
+                INITBITS();
+            }
+            else if (state->head != Z_NULL)
+                state->head->extra = Z_NULL;
+            state->mode = EXTRA;
+        case EXTRA:
+            if (state->flags & 0x0400) {
+                copy = state->length;
+                if (copy > have) copy = have;
+                if (copy) {
+                    if (state->head != Z_NULL &&
+                        state->head->extra != Z_NULL) {
+                        len = state->head->extra_len - state->length;
+                        zmemcpy(state->head->extra + len, next,
+                                len + copy > state->head->extra_max ?
+                                state->head->extra_max - len : copy);
+                    }
+                    if (state->flags & 0x0200)
+                        state->check = crc32(state->check, next, copy);
+                    have -= copy;
+                    next += copy;
+                    state->length -= copy;
+                }
+                if (state->length) goto inf_leave;
+            }
+            state->length = 0;
+            state->mode = NAME;
+        case NAME:
+            if (state->flags & 0x0800) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->name != Z_NULL &&
+                            state->length < state->head->name_max)
+                        state->head->name[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->name = Z_NULL;
+            state->length = 0;
+            state->mode = COMMENT;
+        case COMMENT:
+            if (state->flags & 0x1000) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->comment != Z_NULL &&
+                            state->length < state->head->comm_max)
+                        state->head->comment[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->comment = Z_NULL;
+            state->mode = HCRC;
+        case HCRC:
+            if (state->flags & 0x0200) {
+                NEEDBITS(16);
+                if (hold != (state->check & 0xffff)) {
+                    strm->msg = (char *)"header crc mismatch";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+            }
+            if (state->head != Z_NULL) {
+                state->head->hcrc = (int)((state->flags >> 9) & 1);
+                state->head->done = 1;
+            }
+            strm->adler = state->check = crc32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+            break;
+#endif
+        case DICTID:
+            NEEDBITS(32);
+            strm->adler = state->check = REVERSE(hold);
+            INITBITS();
+            state->mode = DICT;
+        case DICT:
+            if (state->havedict == 0) {
+                RESTORE();
+                return Z_NEED_DICT;
+            }
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+        case TYPE:
+            if (flush == Z_BLOCK) goto inf_leave;
+        case TYPEDO:
+            if (state->last) {
+                BYTEBITS();
+                state->mode = CHECK;
+                break;
+            }
+            NEEDBITS(3);
+            state->last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, "inflate:     stored block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, "inflate:     fixed codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = LEN;              /* decode codes */
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = TABLE;
+                break;
+            case 3:
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+        case STORED:
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
+                break;
+            }
+            state->length = (unsigned)hold & 0xffff;
+            Tracev((stderr, "inflate:       stored length %u\n",
+                    state->length));
+            INITBITS();
+            state->mode = COPY;
+        case COPY:
+            copy = state->length;
+            if (copy) {
+                if (copy > have) copy = have;
+                if (copy > left) copy = left;
+                if (copy == 0) goto inf_leave;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state->length -= copy;
+                break;
+            }
+            Tracev((stderr, "inflate:       stored end\n"));
+            state->mode = TYPE;
+            break;
+        case TABLE:
+            NEEDBITS(14);
+            state->nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state->ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state->ncode = BITS(4) + 4;
+            DROPBITS(4);
+#ifndef PKZIP_BUG_WORKAROUND
+            if (state->nlen > 286 || state->ndist > 30) {
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            Tracev((stderr, "inflate:       table sizes ok\n"));
+            state->have = 0;
+            state->mode = LENLENS;
+        case LENLENS:
+            while (state->have < state->ncode) {
+                NEEDBITS(3);
+                state->lens[order[state->have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state->have < 19)
+                state->lens[order[state->have++]] = 0;
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 7;
+            ret = inflate_table(CODES, state->lens, 19, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       code lengths ok\n"));
+            state->have = 0;
+            state->mode = CODELENS;
+        case CODELENS:
+            while (state->have < state->nlen + state->ndist) {
+                for (;;) {
+                    this = state->lencode[BITS(state->lenbits)];
+                    if ((unsigned)(this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                if (this.val < 16) {
+                    NEEDBITS(this.bits);
+                    DROPBITS(this.bits);
+                    state->lens[state->have++] = this.val;
+                }
+                else {
+                    if (this.val == 16) {
+                        NEEDBITS(this.bits + 2);
+                        DROPBITS(this.bits);
+                        if (state->have == 0) {
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
+                            break;
+                        }
+                        len = state->lens[state->have - 1];
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (this.val == 17) {
+                        NEEDBITS(this.bits + 3);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(this.bits + 7);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state->have + copy > state->nlen + state->ndist) {
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state->lens[state->have++] = (unsigned short)len;
+                }
+            }
+
+            /* handle error breaks in while */
+            if (state->mode == BAD) break;
+
+            /* build code tables */
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 9;
+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
+                break;
+            }
+            state->distcode = (code const FAR *)(state->next);
+            state->distbits = 6;
+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
+                            &(state->next), &(state->distbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       codes ok\n"));
+            state->mode = LEN;
+        case LEN:
+            if (strm->outcb != Z_NULL) /* for watchdog (U-Boot) */
+                (*strm->outcb)(Z_NULL, 0);
+            if (have >= 6 && left >= 258) {
+                RESTORE();
+                inflate_fast(strm, out);
+                LOAD();
+                break;
+            }
+            for (;;) {
+                this = state->lencode[BITS(state->lenbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if (this.op && (this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->lencode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            state->length = (unsigned)this.val;
+            if ((int)(this.op) == 0) {
+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                        "inflate:         literal '%c'\n" :
+                        "inflate:         literal 0x%02x\n", this.val));
+                state->mode = LIT;
+                break;
+            }
+            if (this.op & 32) {
+                Tracevv((stderr, "inflate:         end of block\n"));
+                state->mode = TYPE;
+                break;
+            }
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
+                break;
+            }
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = LENEXT;
+        case LENEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->length += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+            Tracevv((stderr, "inflate:         length %u\n", state->length));
+            state->mode = DIST;
+        case DIST:
+            for (;;) {
+                this = state->distcode[BITS(state->distbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if ((this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->distcode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+            state->offset = (unsigned)this.val;
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = DISTEXT;
+        case DISTEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->offset += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+#ifdef INFLATE_STRICT
+            if (state->offset > state->dmax) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            if (state->offset > state->whave + out - left) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
+            state->mode = MATCH;
+        case MATCH:
+            if (left == 0) goto inf_leave;
+            copy = out - left;
+            if (state->offset > copy) {         /* copy from window */
+                copy = state->offset - copy;
+                if (copy > state->write) {
+                    copy -= state->write;
+                    from = state->window + (state->wsize - copy);
+                }
+                else
+                    from = state->window + (state->write - copy);
+                if (copy > state->length) copy = state->length;
+            }
+            else {                              /* copy from output */
+                from = put - state->offset;
+                copy = state->length;
+            }
+            if (copy > left) copy = left;
+            left -= copy;
+            state->length -= copy;
+            do {
+                *put++ = *from++;
+            } while (--copy);
+            if (state->length == 0) state->mode = LEN;
+            break;
+        case LIT:
+            if (left == 0) goto inf_leave;
+            *put++ = (unsigned char)(state->length);
+            left--;
+            state->mode = LEN;
+            break;
+        case CHECK:
+            if (state->wrap) {
+                NEEDBITS(32);
+                out -= left;
+                strm->total_out += out;
+                state->total += out;
+                if (out)
+                    strm->adler = state->check =
+                        UPDATE(state->check, put - out, out);
+                out = left;
+                if ((
+#ifdef GUNZIP
+                     state->flags ? hold :
+#endif
+                     REVERSE(hold)) != state->check) {
+                    strm->msg = (char *)"incorrect data check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   check matches trailer\n"));
+            }
+#ifdef GUNZIP
+            state->mode = LENGTH;
+        case LENGTH:
+            if (state->wrap && state->flags) {
+                NEEDBITS(32);
+                if (hold != (state->total & 0xffffffffUL)) {
+                    strm->msg = (char *)"incorrect length check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   length matches trailer\n"));
+            }
 #endif
-      while (c->len)
-      {
-	NEEDOUT
-	OUTBYTE(*f++)
-	if (f == s->end)
-	  f = s->window;
-	c->len--;
-      }
-      c->mode = START;
-      break;
-    case LIT:           /* o: got literal, waiting for output space */
-      NEEDOUT
-      OUTBYTE(c->sub.lit)
-      c->mode = START;
-      break;
-    case WASH:          /* o: got eob, possibly more output */
-      FLUSH
-      if (s->read != s->write)
-	LEAVE
-      c->mode = END;
-    case END:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADCODE:       /* x: got error */
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
+            state->mode = DONE;
+        case DONE:
+            ret = Z_STREAM_END;
+            goto inf_leave;
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+        case MEM:
+            return Z_MEM_ERROR;
+        case SYNC:
+        default:
+            return Z_STREAM_ERROR;
+        }
+
+    /*
+       Return from inflate(), updating the total counts and the check value.
+       If there was no progress during the inflate() call, return a buffer
+       error.  Call updatewindow() to create and/or update the window state.
+       Note: a memory error from inflate() is non-recoverable.
+     */
+  inf_leave:
+    RESTORE();
+    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
+        if (updatewindow(strm, out)) {
+            state->mode = MEM;
+            return Z_MEM_ERROR;
+        }
+    in -= strm->avail_in;
+    out -= strm->avail_out;
+    strm->total_in += in;
+    strm->total_out += out;
+    state->total += out;
+    if (state->wrap && out)
+        strm->adler = state->check =
+            UPDATE(state->check, strm->next_out - out, out);
+    strm->data_type = state->bits + (state->last ? 64 : 0) +
+                      (state->mode == TYPE ? 128 : 0);
+    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
+        ret = Z_BUF_ERROR;
+    return ret;
 }
 
-
-local void inflate_codes_free(c, z)
-inflate_codes_statef *c;
-z_stream *z;
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
 {
-  ZFREE(z, c, sizeof(struct inflate_codes_state));
-  Tracev((stderr, "inflate:       codes free\n"));
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->window != Z_NULL) {
+	if (strm->outcb != Z_NULL)
+		(*strm->outcb)(Z_NULL, 0);
+	ZFREE(strm, state->window);
+    }
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+    Tracev((stderr, "inflate: end\n"));
+    return Z_OK;
 }
 
 /*+++++*/
-/* inflate_util.c -- data and routines common to blocks and codes
- * Copyright (C) 1995 Mark Adler
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* copy as much as possible from the sliding window to the output area */
-local int inflate_flush(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
-{
-  uInt n;
-  Bytef *p, *q;
-
-  /* local copies of source and destination pointers */
-  p = z->next_out;
-  q = s->read;
-
-  /* compute number of bytes to copy as far as end of window */
-  n = (uInt)((q <= s->write ? s->write : s->end) - q);
-  if (n > z->avail_out) n = z->avail_out;
-  if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-  /* update counters */
-  z->avail_out -= n;
-  z->total_out += n;
-
-  /* update check information */
-  if (s->checkfn != Z_NULL)
-    s->check = (*s->checkfn)(s->check, q, n);
-
-  /* output callback */
-  if (z->outcb != Z_NULL)
-    (*z->outcb)(q, n);
-
-  /* copy as far as end of window */
-  zmemcpy(p, q, n);
-  p += n;
-  q += n;
-
-  /* see if more to copy at beginning of window */
-  if (q == s->end)
-  {
-    /* wrap pointers */
-    q = s->window;
-    if (s->write == s->end)
-      s->write = s->window;
-
-    /* compute bytes to copy */
-    n = (uInt)(s->write - q);
-    if (n > z->avail_out) n = z->avail_out;
-    if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-    /* update counters */
-    z->avail_out -= n;
-    z->total_out += n;
-
-    /* update check information */
-    if (s->checkfn != Z_NULL)
-      s->check = (*s->checkfn)(s->check, q, n);
-
-    /* output callback */
-    if (z->outcb != Z_NULL)
-	(*z->outcb)(q, n);
-
-    /* copy */
-    zmemcpy(p, q, n);
-    p += n;
-    q += n;
-  }
-
-  /* update pointers */
-  z->next_out = p;
-  s->read = q;
-
-  /* done */
-  return r;
-}
+/* @(#) $Id$ */
 
+#ifndef NO_DUMMY_DECL
+struct internal_state	{int dummy;}; /* for buggy compilers */
+#endif
 
-/*+++++*/
-/* inffast.c -- process literals and length/distance pairs fast
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
+const char * const z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
 
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* macros for bit input with no checking and for returning unused bytes */
-#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}
-
-/* Called with number of bytes left to write in window at least 258
-   (the maximum string length) and number of input bytes available
-   at least ten.  The ten bytes are six bytes for the longest length/
-   distance pair plus four bytes for overloading the bit buffer. */
-
-local int inflate_fast(bl, bd, tl, td, s, z)
-uInt bl, bd;
-inflate_huft *tl, *td;
-inflate_blocks_statef *s;
-z_stream *z;
+#ifdef DEBUG
+
+#ifndef verbose
+#define verbose 0
+#endif
+int z_verbose = verbose;
+
+void z_error (m)
+    char *m;
 {
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  uInt ml;              /* mask for literal/length tree */
-  uInt md;              /* mask for distance tree */
-  uInt c;               /* bytes to copy */
-  uInt d;               /* distance back to copy from */
-  Bytef *r;             /* copy source pointer */
-
-  /* load input, output, bit values */
-  LOAD
-
-  /* initialize masks */
-  ml = inflate_mask[bl];
-  md = inflate_mask[bd];
-
-  /* do until not enough input or output space for fast loop */
-  do {                          /* assume called with m >= 258 && n >= 10 */
-    /* get literal/length code */
-    GRABBITS(20)                /* max bits for literal/length code */
-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
-    {
-      DUMPBITS(t->bits)
-      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		"inflate:         * literal '%c'\n" :
-		"inflate:         * literal 0x%02x\n", t->base));
-      *q++ = (Byte)t->base;
-      m--;
-      continue;
-    }
-    do {
-      DUMPBITS(t->bits)
-      if (e & 16)
-      {
-	/* get extra bits for length */
-	e &= 15;
-	c = t->base + ((uInt)b & inflate_mask[e]);
-	DUMPBITS(e)
-	Tracevv((stderr, "inflate:         * length %u\n", c));
-
-	/* decode distance base of block to copy */
-	GRABBITS(15);           /* max bits for distance code */
-	e = (t = td + ((uInt)b & md))->exop;
-	do {
-	  DUMPBITS(t->bits)
-	  if (e & 16)
-	  {
-	    /* get extra bits to add to distance base */
-	    e &= 15;
-	    GRABBITS(e)         /* get extra bits (up to 13) */
-	    d = t->base + ((uInt)b & inflate_mask[e]);
-	    DUMPBITS(e)
-	    Tracevv((stderr, "inflate:         * distance %u\n", d));
-
-	    /* do the copy */
-	    m -= c;
-	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
-	    {                                   /*  just copy */
-	      r = q - d;
-	      *q++ = *r++;  c--;        /* minimum count is three, */
-	      *q++ = *r++;  c--;        /*  so unroll loop a little */
-	    }
-	    else                        /* else offset after destination */
-	    {
-	      e = d - (q - s->window);  /* bytes from offset to end */
-	      r = s->end - e;           /* pointer to offset */
-	      if (c > e)                /* if source crosses, */
-	      {
-		c -= e;                 /* copy to end of window */
-		do {
-		  *q++ = *r++;
-		} while (--e);
-		r = s->window;          /* copy rest from start of window */
-	      }
-	    }
-	    do {                        /* copy all or what's left */
-	      *q++ = *r++;
-	    } while (--c);
-	    break;
-	  }
-	  else if ((e & 64) == 0)
-	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
-	  else
-	  {
-	    z->msg = "invalid distance code";
-	    UNGRAB
-	    UPDATE
-	    return Z_DATA_ERROR;
-	  }
-	} while (1);
-	break;
-      }
-      if ((e & 64) == 0)
-      {
-	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
-	{
-	  DUMPBITS(t->bits)
-	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		    "inflate:         * literal '%c'\n" :
-		    "inflate:         * literal 0x%02x\n", t->base));
-	  *q++ = (Byte)t->base;
-	  m--;
-	  break;
-	}
-      }
-      else if (e & 32)
-      {
-	Tracevv((stderr, "inflate:         * end of block\n"));
-	UNGRAB
-	UPDATE
-	return Z_STREAM_END;
-      }
-      else
-      {
-	z->msg = "invalid literal/length code";
-	UNGRAB
-	UPDATE
-	return Z_DATA_ERROR;
-      }
-    } while (1);
-  } while (m >= 258 && n >= 10);
-
-  /* not enough input or output--restore pointers and return */
-  UNGRAB
-  UPDATE
-  return Z_OK;
+	fprintf(stderr, "%s\n", m);
+	hang ();
 }
+#endif
 
-
-/*+++++*/
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
  */
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
 
-/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
-
-char *zlib_version = ZLIB_VERSION;
+#ifndef STDC
+extern voidp    malloc OF((uInt size));
+extern voidp    calloc OF((uInt items, uInt size));
+extern void     free   OF((voidpf ptr));
+#endif
 
-char *z_errmsg[] = {
-"stream end",          /* Z_STREAM_END    1 */
-"",                    /* Z_OK            0 */
-"file error",          /* Z_ERRNO        (-1) */
-"stream error",        /* Z_STREAM_ERROR (-2) */
-"data error",          /* Z_DATA_ERROR   (-3) */
-"insufficient memory", /* Z_MEM_ERROR    (-4) */
-"buffer error",        /* Z_BUF_ERROR    (-5) */
-""};
+voidpf zcalloc (opaque, items, size)
+	voidpf opaque;
+	unsigned items;
+	unsigned size;
+{
+	if (opaque)
+		items += size - size; /* make compiler happy */
+	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
+		(voidpf)calloc(items, size);
+}
 
+void  zcfree (opaque, ptr, nb)
+	voidpf opaque;
+	voidpf ptr;
+	unsigned nb;
+{
+	free(ptr);
+	if (opaque)
+		return; /* make compiler happy */
+}
 
+#endif /* MY_ZCALLOC */
 /*+++++*/
 /* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995 Mark Adler
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */
+/* @(#) $Id$ */
 
-#define BASE 65521L /* largest prime smaller than 65536 */
+#define BASE 65521UL    /* largest prime smaller than 65536 */
 #define NMAX 5552
 /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
 
-#define DO1(buf)  {s1 += *buf++; s2 += s1;}
-#define DO2(buf)  DO1(buf); DO1(buf);
-#define DO4(buf)  DO2(buf); DO2(buf);
-#define DO8(buf)  DO4(buf); DO4(buf);
-#define DO16(buf) DO8(buf); DO8(buf);
+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* use NO_DIVIDE if your processor does not do division in hardware */
+#ifdef NO_DIVIDE
+#define MOD(a) \
+	do { \
+		if (a >= (BASE << 16)) \
+			a -= (BASE << 16); \
+		if (a >= (BASE << 15)) \
+			a -= (BASE << 15); \
+		if (a >= (BASE << 14)) \
+			a -= (BASE << 14); \
+		if (a >= (BASE << 13)) \
+			a -= (BASE << 13); \
+		if (a >= (BASE << 12)) \
+			a -= (BASE << 12); \
+		if (a >= (BASE << 11)) \
+			a -= (BASE << 11); \
+		if (a >= (BASE << 10)) \
+			a -= (BASE << 10); \
+		if (a >= (BASE << 9)) \
+			a -= (BASE << 9); \
+		if (a >= (BASE << 8)) \
+			a -= (BASE << 8); \
+		if (a >= (BASE << 7)) \
+			a -= (BASE << 7); \
+		if (a >= (BASE << 6)) \
+			a -= (BASE << 6); \
+		if (a >= (BASE << 5)) \
+			a -= (BASE << 5); \
+		if (a >= (BASE << 4)) \
+			a -= (BASE << 4); \
+		if (a >= (BASE << 3)) \
+			a -= (BASE << 3); \
+		if (a >= (BASE << 2)) \
+			a -= (BASE << 2); \
+		if (a >= (BASE << 1)) \
+			a -= (BASE << 1); \
+		if (a >= BASE) \
+			a -= BASE; \
+	} while (0)
+#define MOD4(a) \
+	do { \
+		if (a >= (BASE << 4)) \
+			a -= (BASE << 4); \
+		if (a >= (BASE << 3)) \
+			a -= (BASE << 3); \
+		if (a >= (BASE << 2)) \
+			a -= (BASE << 2); \
+		if (a >= (BASE << 1)) \
+			a -= (BASE << 1); \
+		if (a >= BASE) \
+			a -= BASE; \
+	} while (0)
+#else
+#define MOD(a) a %= BASE
+#define MOD4(a) a %= BASE
+#endif
 
 /* ========================================================================= */
-uLong adler32(adler, buf, len)
+uLong ZEXPORT adler32(adler, buf, len)
     uLong adler;
-    Bytef *buf;
+    const Bytef *buf;
     uInt len;
 {
-    unsigned long s1 = adler & 0xffff;
-    unsigned long s2 = (adler >> 16) & 0xffff;
-    int k;
-
-    if (buf == Z_NULL) return 1L;
-
-    while (len > 0) {
-	k = len < NMAX ? len : NMAX;
-	len -= k;
-	while (k >= 16) {
-	    DO16(buf);
-	    k -= 16;
-	}
-	if (k != 0) do {
-	    DO1(buf);
-	} while (--k);
-	s1 %= BASE;
-	s2 %= BASE;
+    unsigned long sum2;
+    unsigned n;
+
+    /* split Adler-32 into component sums */
+    sum2 = (adler >> 16) & 0xffff;
+    adler &= 0xffff;
+
+    /* in case user likes doing a byte at a time, keep it fast */
+    if (len == 1) {
+        adler += buf[0];
+        if (adler >= BASE)
+            adler -= BASE;
+        sum2 += adler;
+        if (sum2 >= BASE)
+            sum2 -= BASE;
+        return adler | (sum2 << 16);
     }
-    return (s2 << 16) | s1;
+
+    /* initial Adler-32 value (deferred check for len == 1 speed) */
+    if (buf == Z_NULL)
+        return 1L;
+
+    /* in case short lengths are provided, keep it somewhat fast */
+    if (len < 16) {
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        if (adler >= BASE)
+            adler -= BASE;
+        MOD4(sum2);             /* only added so many BASE's */
+        return adler | (sum2 << 16);
+    }
+
+    /* do length NMAX blocks -- requires just one modulo operation */
+    while (len >= NMAX) {
+        len -= NMAX;
+        n = NMAX / 16;          /* NMAX is divisible by 16 */
+        do {
+            DO16(buf);          /* 16 sums unrolled */
+            buf += 16;
+        } while (--n);
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* do remaining bytes (less than NMAX, still just one modulo) */
+    if (len) {                  /* avoid modulos if none remaining */
+        while (len >= 16) {
+            len -= 16;
+            DO16(buf);
+            buf += 16;
+        }
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* return recombined sums */
+    return adler | (sum2 << 16);
 }
diff --git a/lib_i386/i386_linux.c b/lib_i386/i386_linux.c
index b4a6f5a..2c4c786 100644
--- a/lib_i386/i386_linux.c
+++ b/lib_i386/i386_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/zimage.h>
 
diff --git a/lib_m68k/m68k_linux.c b/lib_m68k/m68k_linux.c
index cc974c2..a938e26 100644
--- a/lib_m68k/m68k_linux.c
+++ b/lib_m68k/m68k_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <bzlib.h>
 #include <watchdog.h>
 #include <environment.h>
diff --git a/lib_microblaze/microblaze_linux.c b/lib_microblaze/microblaze_linux.c
index 68b58d4..fbc1ab7 100644
--- a/lib_microblaze/microblaze_linux.c
+++ b/lib_microblaze/microblaze_linux.c
@@ -27,7 +27,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/lib_mips/mips_linux.c b/lib_mips/mips_linux.c
index 556b180..c2f9e42 100644
--- a/lib_mips/mips_linux.c
+++ b/lib_mips/mips_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 
diff --git a/lib_sh/Makefile b/lib_sh/Makefile
index e1b477f..6241503 100644
--- a/lib_sh/Makefile
+++ b/lib_sh/Makefile
@@ -23,23 +23,24 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	= lib$(ARCH).a
+LIB	= $(obj)lib$(ARCH).a
 
-AOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
+SOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
 
-COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o sconsole.o
+COBJS-y = board.o sh_linux.o time.o io_generic.o udivdi3.o sconsole.o
+COBJS-$(CONFIG_CMD_STTESTS) += cmd_sttests.o st_mtests.o
 
-OBJS	= $(AOBJS) $(COBJS)
+SRCS 	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS-y))
 
-$(LIB):	.depend $(OBJS)
-	$(AR) crv $@ $(OBJS)
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
 
-.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
-		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
 
-sinclude .depend
+sinclude $(obj).depend
 
 #########################################################################
-
diff --git a/lib_sh/cmd_sttests.c b/lib_sh/cmd_sttests.c
new file mode 100644
index 0000000..e113484
--- /dev/null
+++ b/lib_sh/cmd_sttests.c
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Pierre Morel, WYPLAY, pmorel@wyplay.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+extern int do_st_memory_test(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+int do_st_mtest(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	ulong i, count;
+
+	if (argc !=4) {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	count = simple_strtoul(argv[3], NULL, 10);
+
+	for (;;) {
+		do_st_memory_test(NULL, 0, 3, argv);
+
+		printf("Type CTRL-C to Abort...");
+		/* delay for <count> ms... */
+		for (i = 0; i < count; i++)
+		{
+			udelay(1000);	/* 1 ms */
+			/* check for ctrl-c to abort... */
+			if (ctrlc()) {
+				puts("Abort\n");
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	st_mtest, 4, 1, do_st_mtest,
+	"st_mtest- STMicro Memory tests\n",
+	"start length delay\n"
+	"    - STMicro memory tests\n"
+	"      all values in decimal (prepend '0x' for hex)\n"
+	"      delay specified in ms\n"
+);
diff --git a/lib_sh/st_mtests.c b/lib_sh/st_mtests.c
new file mode 100644
index 0000000..dd992f9
--- /dev/null
+++ b/lib_sh/st_mtests.c
@@ -0,0 +1,755 @@
+/*
+ * (C) Copyright 2006
+ * Pierre Morel, WYPLAY, pmorel@wyplay.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#define STATS_ON
+
+int memory_test(unsigned long *block_start, unsigned long block_length);
+
+int do_st_memory_test(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned long *start;
+	unsigned long length;
+	int ret;
+
+	start = (unsigned long *)simple_strtoul(argv[1], NULL, 10);
+	length = simple_strtoul(argv[2], NULL, 10);
+
+	printf("\ndo_st_memory_test: Start: 0x%08x - Length: 0x%08x\n",
+	       start, length);
+	ret = memory_test(start, length);
+	return(ret);
+}
+
+#define CONTROL_BITS(x) ((unsigned long)(x) & 0xFFF80000ul)
+#define ADDRESS_BITS(x) ((unsigned long)(x) & 0x00F7FFFFul)
+
+#define ALL_ZERO 0x00000000ul
+#define ALL_FIVE 0x55555555ul
+#define ALL_AAAA 0xAAAAAAAAul
+#define ALL_ONES 0xFFFFFFFFul
+
+#ifdef STATS_ON
+static int stats_run_fails;
+static int stats_run_pattern_fails;
+static int stats_run_no_write_fails;
+static int stats_run_write_00000000_fails;
+static int stats_run_write_FFFFFFFF_fails;
+static int stats_run_write_AAAAAAAA_fails;
+static int stats_run_wrote_00000000_fails;
+static int stats_run_move_00000000_fails;
+static int stats_run_move_FFFFFFFF_fails;
+
+static int stats_adj_move_00000000_fails;
+static int stats_adj_move_FFFFFFFF_fails;
+
+static int stats_total_fails;
+static int stats_total_pattern_fails;
+static int stats_total_no_write_fails;
+static int stats_total_write_00000000_fails;
+static int stats_total_write_FFFFFFFF_fails;
+static int stats_total_write_AAAAAAAA_fails;
+static int stats_total_wrote_00000000_fails;
+static int stats_total_move_00000000_fails;
+static int stats_total_move_FFFFFFFF_fails;
+static int stats_total_adj_move_00000000_fails;
+static int stats_total_adj_move_FFFFFFFF_fails;
+static int stats_runs;
+
+static int stats_first_test = 0;
+#endif
+
+/*{{{ void Report(*Address, Pattern, Value, *Message)*/
+void report(volatile unsigned long *address, unsigned long pattern,
+	    unsigned long value, char *message)
+{
+	printf("\r@ 0x%08x  W 0x%08x  R 0x%08x  D 0x%08x   %s\n",
+	       address, pattern, value, (pattern ^ value), message);
+}
+/*}}}  */
+
+/*{{{  int TestPattern(unsigned long *BlockStart, unsigned long BlockLength, unsigned long Pattern, char *Message)*/
+int test_pattern(unsigned long *block_start, unsigned long block_length,
+		 unsigned long pattern, char *message)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	unsigned long value;
+	int error = 0;
+
+	start_address = block_start;
+	end_address = start_address + (block_length / sizeof (unsigned int));
+
+	printf("Data Bus Pattern test (0x%08lx) Address from 0x%08x to 0x%08x\n",
+		pattern, start_address, end_address);
+
+	/* Write Pattern */
+	for (address = start_address; address < end_address - 1; address++)
+		*address = pattern;
+
+	*(address) = ~pattern ;	/* To change value on the bus */
+	/* Verify Pattern */
+	for (address = start_address; address < end_address-1; address++) {
+		value = *address;
+		if (value != pattern) {
+			if(error < 5)
+				report(address, pattern, value, message);
+			error++;
+			/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+			/*}}}  */
+		}
+	}
+	printf ("Found %X errors for Pattern %x\n", error, pattern);
+	return error;
+}
+/*}}}  */
+
+/*{{{  int SlidingTest(unsigned long *BlockStart, int Buswidth)*/
+int sliding_test(unsigned long *block_start, int buswidth)
+{
+	volatile unsigned long *address;
+	unsigned long value;
+	unsigned long pattern;
+	int error = 0;
+	int i;
+
+	address = block_start;
+	/*Sliding One*/
+	printf("Sliding one test\n");
+	pattern = 0x1;
+	for (i = 0; i < buswidth; i++) {
+		*address = pattern;
+		*(address + 1) = 0;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "sliding one");
+			error++;
+		}
+		pattern = pattern << 1;
+	}
+
+	/*Sliding Zero*/
+	printf("Sliding zero test\n");
+	pattern = 0xFFFFFFFE;
+	for (i = 0; i < buswidth; i++) {
+		*address = pattern;
+		*(address +1) = ~pattern;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "sliding zero");
+			error++;
+		/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+		/*}}}  */
+		}
+		pattern = (pattern << 1) | 1;
+	}
+	return error;
+}
+/*}}}  */
+
+
+/*{{{  int AddressTests(unsigned long *BlockStart, unsigned long BlockLength)*/
+int address_tests(unsigned long *block_start, unsigned long block_length)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	unsigned long memory_size;
+	unsigned long value, pattern;
+	int error = 0, error_verify =0;
+	int dot_count;
+
+	/* Work out start and end addresses */
+	start_address = block_start;
+	memory_size = block_length;
+	end_address = start_address + (memory_size / sizeof (unsigned int));
+	printf("Testing memory address bus from 0x%08x to 0x%08x\n",
+	       start_address, end_address);
+
+	/*Alternate location */
+	printf("Alternate address test\n");
+	*start_address = ALL_FIVE;
+	*(start_address + 1) = ALL_AAAA;
+	value = *start_address;
+	if (value != ALL_FIVE) {
+		if(error < 20)
+			report(start_address, ALL_FIVE, value, "Alternate address test");
+	/*{{{  stats*/
+#ifdef STATS_ON
+		stats_run_fails++;
+		stats_run_pattern_fails++;
+#endif
+	/*}}}  */
+		error++;
+	}
+	value = *(start_address + 1);
+	if (value != ALL_AAAA) {
+		if(error < 20)
+			report((start_address + 1), ALL_AAAA, value, "Alternate address test");
+	/*{{{  stats*/
+#ifdef STATS_ON
+		stats_run_fails++;
+		stats_run_pattern_fails++;
+#endif
+	/*}}}  */
+		error++;
+	}
+#ifdef FAST_TEST
+
+	/*Fast Address Test */
+	printf("Fast address test\n");
+
+	address = start_address +1 ;
+
+	for (address = start_address + 1; address < end_address;
+	     address = (unsigned long *)(start_address + (ADDRESS_BITS(Address) << 2))) {
+/*	     address = (unsigned long *)(CONTROL_BITS(address) | (ADDRESS_BITS(address) << 2))) {*/
+		*address = ~(unsigned long)address;
+		printf("checking address 0x%X\n", Address);
+	}
+	for (address = start_address + 1; address < end_address;
+	     address = (unsigned long *)(start_address + (ADDRESS_BITS(address) << 2))) {
+/*	     address = (unsigned long *)(CONTROL_BITS(address) | (ADDRESS_BITS(address) << 2))) {*/
+		pattern = ~((unsigned long)address);
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Fast address test");
+		/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+		/*}}}  */
+			error++;
+		}
+	}
+#endif
+
+	/* Address Test */
+	printf("Address test ... may take a while ...\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address += 0x20) {
+		*address = ~((unsigned long)address);
+		pattern = ~((unsigned long)address);
+		value = *address ;
+		if (value != pattern) {
+			if(error_verify < 20)
+				report(address, pattern, value, "Address test");
+			error_verify++;
+		}
+		dot_count++;
+		if (dot_count >= 0x4000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	printf("\n");
+	if (error_verify !=0)
+		printf("Immediate verify after write show %x error(s)\n", error_verify) ;
+
+	dot_count = 0;
+	for (address = start_address; address < end_address; address += 0x20) {
+		pattern = ~((unsigned long)address);
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Address test");
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x4000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+
+	return error;
+}
+/*}}}  */
+
+/*{{{  int BlockMoveTests(unsigned long *BlockStart, unsigned long BlockLength)*/
+int block_move_tests(unsigned long *block_start, unsigned long block_length)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	volatile unsigned long *src_start;
+	volatile unsigned long *src_end;
+	volatile unsigned long *dst_start;
+	volatile unsigned long *dst_end;
+	unsigned long memory_size, pattern, value;
+	int error = 0;
+	int totalerrors = 0;
+	int dot_count;
+	/*int i;
+	int seed=5;*/
+
+	/*Block Move Test */
+	printf("\nBlock Move test ---------------------------------------------\n");
+	/*Set up Block address pointers*/
+	start_address = block_start;
+	end_address = (start_address + (block_length / sizeof (unsigned int))-1);
+	memory_size = block_length / 2 / sizeof(long);
+	src_start = start_address;
+	src_end = (start_address + memory_size) - 1;
+	dst_start = (src_end + 1);
+	dst_end = end_address;
+	printf("Source Block from 0x%08x to 0x%08x\n", src_start, src_end);
+	printf("Destination Block from 0x%08x to 0x%08x\n", dst_start, dst_end);
+
+	/*{{{	Initialise Memory*/
+	/*Initialise Memory*/
+	printf("Fill Memory with 0x01020304\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address++) {
+		*address = 0x01020304;
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+	/*{{{	Verify Memory*/
+	printf("\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address++) {
+		pattern = 0x01020304;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Block Move test init 0x01020304");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			if (value == 0)
+				stats_run_write_00000000_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	/*}}}	*/
+
+	/*{{{	Fill source block with alternating F's and 0's*/
+	/*Fill Source Block*/
+	printf("\nFill Source Block of Memory with F's and 0's\n");
+	dot_count = 0;
+	for (address = src_start; address < src_end;) {
+		*address++ = 0x0;
+		*address++ = 0x0;
+		*address++ = 0xFFFFFFFF;
+		*address++ = 0xFFFFFFFF;
+		dot_count+=4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+
+	/*{{{	Fill destination block with A's*/
+	/*Fill Destination Block*/
+	printf("\nFill Destination Block of Memory with A's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		*address++ = 0xAAAAAAAA;
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+
+	printf("\n");
+
+	/*{{{	Verify source block with alternating F's and 0's*/
+	/*Verify Source block*/
+	printf("Verifying source block F's and 0's\n");
+	dot_count = 0;
+	for (address = src_start; address < src_end;) {
+		pattern = 0x0;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		pattern = 0xFFFFFFFF;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count += 4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors = error;
+	error = 0;
+	/*}}}	*/
+
+	/*{{{	Verify destination block with A's*/
+	/*Verify destination block*/
+	printf("\n");
+	printf("Verifying Destination block with A's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		pattern = 0xAAAAAAAA;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Destination block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_AAAAAAAA_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors += error;
+	error = 0;
+	/*}}}	*/
+
+
+	/*{{{	move source block to destination block*/
+	/*Move Block*/
+	printf("\nMove Block of Memory\n");
+	memcpy((unsigned long *)dst_start, (unsigned long *)src_start, (int)block_length / 2);
+	/*}}}	*/
+
+	/*{{{	Verify destination block with F's and 0's*/
+	/*Verify Destination Block*/
+	printf("Verify Destination Block F's and 0's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		pattern = 0x0;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		pattern = 0xFFFFFFFF;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count += 4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors += error;
+	error = 0;
+	/*}}}	*/
+
+	return totalerrors;
+}
+
+/*}}}	*/
+
+/*{{{	int MemoryTest(unsigned long *BlockStart, unsigned long BlockLength)*/
+int memory_test(unsigned long *block_start, unsigned long block_length)
+{
+	unsigned long error = 0;
+	unsigned long *start_address;
+	unsigned long *end_address;
+	unsigned long memory_size;
+	int buswidth;
+
+
+	printf("\nRunning memory tester ... V1.1\n\n");
+
+#ifdef STATS_ON
+	/*{{{	init stats*/
+	if (stats_first_test == 0) {
+		printf("STATS: Initialising stat counters ... \n\n");
+		stats_first_test = 1;
+		stats_runs = 0;
+
+		stats_total_fails = 0;
+		stats_total_pattern_fails = 0;
+		stats_total_no_write_fails = 0;
+		stats_total_write_00000000_fails = 0;
+		stats_total_write_FFFFFFFF_fails = 0;
+		stats_total_write_AAAAAAAA_fails = 0;
+		stats_total_wrote_00000000_fails = 0;
+		stats_total_move_00000000_fails = 0;
+		stats_total_move_FFFFFFFF_fails = 0;
+
+	}
+	stats_run_fails = 0;
+	stats_run_pattern_fails = 0;
+	stats_run_no_write_fails = 0;
+	stats_run_write_00000000_fails = 0;
+	stats_run_write_FFFFFFFF_fails = 0;
+	stats_run_write_AAAAAAAA_fails = 0;
+	stats_run_wrote_00000000_fails = 0;
+	stats_run_move_00000000_fails = 0;
+	stats_run_move_FFFFFFFF_fails = 0;
+	/*}}}	*/
+#endif
+
+/*{{{	data bus tests*/
+#ifndef NO_PATTERN_TEST
+	/* Work out start and end addresses */
+	start_address = block_start;
+	memory_size = 1024;
+	end_address = start_address + (memory_size / sizeof (unsigned int));
+
+	/* Pattern Tests */
+	error += test_pattern(start_address, memory_size, 0x00000000, "Test pattern (00)");
+	error += test_pattern(start_address, memory_size, 0xFFFFFFFF, "Test pattern (FF)");
+	error += test_pattern(start_address, memory_size, 0x55555555, "Test pattern (55)");
+	error += test_pattern(start_address, memory_size, 0xAAAAAAAA, "Test pattern (AA)");
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	if (error !=0)
+		return ((int) (error=1)) ;
+#endif
+
+/*{{{	Sliding tests*/
+#ifndef NO_SLIDING_TEST
+	start_address = block_start;
+	buswidth = 32;
+	error+=sliding_test(start_address, buswidth);
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	if (error !=0)
+		return ((int)(error=1)) ;
+#endif
+
+/*{{{	address tests*/
+#ifndef NO_ADDRESS_TEST
+	start_address = block_start;
+	memory_size = block_length;
+	error += address_tests(start_address, memory_size);
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	printf("\nMemory test completed with [%ld] errors!\n\n",error);
+	if (error !=0)
+		return ((int)(error=1)) ;
+	else return ((int)(error=0)) ;
+#endif
+
+/*{{{	Block move tests*/
+#ifndef NO_BLOCK_MOVE_TEST
+	start_address = block_start;
+	memory_size = block_length;
+	error += block_move_tests(start_address, memory_size);
+#endif
+/*}}}	*/
+
+	printf("\nMemory test completed with [%ld] errors!\n\n",error);
+	/*{{{	print stats*/
+	#ifdef STATS_ON
+	stats_runs++;
+	stats_total_fails += stats_run_fails;
+	stats_total_pattern_fails += stats_run_pattern_fails;
+	stats_total_no_write_fails += stats_run_no_write_fails;
+	stats_total_write_00000000_fails += stats_run_write_00000000_fails;
+	stats_total_write_FFFFFFFF_fails += stats_run_write_FFFFFFFF_fails;
+	stats_total_write_AAAAAAAA_fails += stats_run_write_AAAAAAAA_fails;
+	stats_total_wrote_00000000_fails += stats_run_wrote_00000000_fails;
+	stats_total_move_00000000_fails	+= stats_run_move_00000000_fails;
+	stats_total_move_FFFFFFFF_fails	+= stats_run_move_FFFFFFFF_fails;
+
+	stats_adj_move_00000000_fails =	stats_run_move_00000000_fails - stats_run_write_00000000_fails;
+	stats_adj_move_FFFFFFFF_fails =	stats_run_move_FFFFFFFF_fails - stats_run_write_FFFFFFFF_fails;
+	stats_total_adj_move_00000000_fails += stats_adj_move_00000000_fails;
+	stats_total_adj_move_FFFFFFFF_fails += stats_adj_move_FFFFFFFF_fails;
+
+
+	printf("============================================================================================\n");
+	printf("STATS:                        \tLast\tTotal\tAverage(over %d runs)\n", stats_runs);
+	printf("STATS:                        \t    \t     \tNumber\t%%\n");
+	printf("STATS: Total fails:           \t%d\t%d\t%d\n", stats_run_fails, stats_total_fails, (stats_total_fails / stats_runs));
+	if (stats_total_fails != 0)	/* ensure we avoid divide by zero! */
+	{
+		printf("STATS: Pattern fails:         \t%d\t%d\t%d\t%d\n", stats_run_pattern_fails, stats_total_pattern_fails, (stats_total_pattern_fails / stats_runs), ((stats_total_pattern_fails * 100) / stats_total_fails));
+		printf("STATS: No write fails:        \t%d\t%d\t%d\t%d\n", stats_run_no_write_fails, stats_total_no_write_fails, (stats_total_no_write_fails / stats_runs), ((stats_total_no_write_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0x00000000\t%d\t%d\t%d\t%d\n", stats_run_write_00000000_fails, stats_total_write_00000000_fails, (stats_total_write_00000000_fails / stats_runs), ((stats_total_write_00000000_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_run_write_FFFFFFFF_fails, stats_total_write_FFFFFFFF_fails, (stats_total_write_FFFFFFFF_fails / stats_runs), ((stats_total_write_FFFFFFFF_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0xAAAAAAAA\t%d\t%d\t%d\t%d\n", stats_run_write_AAAAAAAA_fails, stats_total_write_AAAAAAAA_fails, (stats_total_write_AAAAAAAA_fails / stats_runs), ((stats_total_write_AAAAAAAA_fails * 100) / stats_total_fails));
+		printf("STATS: Wrote 0x00000000       \t%d\t%d\t%d\t%d\n", stats_run_wrote_00000000_fails, stats_total_wrote_00000000_fails, (stats_total_wrote_00000000_fails / stats_runs), ((stats_total_wrote_00000000_fails * 100) / stats_total_fails));
+		printf("STATS: Fail moving  0x00000000\t%d\t%d\t%d\t%d\n", stats_run_move_00000000_fails, stats_total_move_00000000_fails, (stats_total_move_00000000_fails / stats_runs), ((stats_total_move_00000000_fails * 100) / stats_total_fails) );
+		printf("STATS: Fail moving  0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_run_move_FFFFFFFF_fails, stats_total_move_FFFFFFFF_fails, (stats_total_move_FFFFFFFF_fails / stats_runs), ((stats_total_move_FFFFFFFF_fails * 100) / stats_total_fails) );
+		printf("STATS: Adj  moving  0x00000000\t%d\t%d\t%d\t%d\n", stats_adj_move_00000000_fails, stats_total_adj_move_00000000_fails, (stats_total_adj_move_00000000_fails / stats_runs), ((stats_total_adj_move_00000000_fails * 100) / stats_total_fails) );
+		printf("STATS: Adj  moving  0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_adj_move_FFFFFFFF_fails, stats_total_adj_move_FFFFFFFF_fails, (stats_total_adj_move_FFFFFFFF_fails / stats_runs), ((stats_total_adj_move_FFFFFFFF_fails * 100) / stats_total_fails) );
+	}
+	printf("============================================================================================\n");
+	#endif
+	/*}}}	*/
+
+	if (error >= 1)
+		return 1;
+	else
+		return 0;
+}
+
+/*}}}	*/
diff --git a/lib_sh/time.c b/lib_sh/time.c
index 2dbc7cf..1d4af56 100644
--- a/lib_sh/time.c
+++ b/lib_sh/time.c
@@ -1,9 +1,17 @@
 /*
- * (C) Copyright 2004,2009 STMicroelectronics.
+ * (C) Copyright 2009
+ * Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
  *
+ * (C) Copyright 2004,2009 STMicroelectronics.
  * Andy Sturges <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
+ * (C) Copyright 2007-2008
+ * Nobobuhiro Iwamatsu <iwamatsu@nigauri.org>
+ *
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -25,62 +33,142 @@
 
 #include <common.h>
 #include <asm/socregs.h>
+#include <div64.h>
+#include <asm/processor.h>
+#include <asm/clk.h>
+#include <asm/io.h>
 
-#define TMU_TICKS_PER_SEC CFG_HZ
-#define TMU_START0 0x01
 #define TMU_MAX_COUNTER (~0UL)
-#define TMU_INPUT 0x0006
 
-#define TMU_OFF() *SH4_TMU_TSTR = 0;
-#define TMU_ON() *SH4_TMU_TSTR = *SH4_TMU_TSTR | 1;
-#define TMU_CLEAR() *SH4_TMU_TCOR0 = TMU_MAX_COUNTER; *SH4_TMU_TCNT0 = TMU_MAX_COUNTER;
-#define TMU_SET(v) *SH4_TMU_TCNT0 = (v ^ TMU_MAX_COUNTER);
-#define TMU_GET()  (*SH4_TMU_TCNT0 ^ TMU_MAX_COUNTER)
+#if !defined(TMU_CLK_DIVIDER)
+#define TMU_CLK_DIVIDER		4	/* Clock divided by 4 is FASTEST */
+#endif	/* TMU_CLK_DIVIDER */
+
+static ulong timer_freq;
+
+static inline unsigned long long tick_to_time(unsigned long long tick)
+{
+	tick *= CFG_HZ;
+	do_div(tick, timer_freq);
+
+	return tick;
+}
+
+static inline unsigned long long usec_to_tick(unsigned long long usec)
+{
+	usec *= timer_freq;
+	do_div(usec, 1000000);
+
+	return usec;
+}
+
+static void tmu_timer_start (unsigned int timer)
+{
+	if (timer > 2)
+		return;
+	writeb(readb(TSTR) | (1 << timer), TSTR);
+}
+
+static void tmu_timer_stop (unsigned int timer)
+{
+	if (timer > 2)
+		return;
+	writeb(readb(TSTR) & ~(1 << timer), TSTR);
+}
 
-/* RTC clock not connected on this board use pclock */
 int timer_init (void)
 {
-	TMU_OFF ();
-	/* Take clock from PCLOCK/1024 */
-	*SH4_TMU_TCR0 = *SH4_TMU_TCR0 & 0xfff8;
-	*SH4_TMU_TCR0 = *SH4_TMU_TCR0 | 0x4;
-	*SH4_TMU_TCOR0 = TMU_MAX_COUNTER;
-	TMU_ON ();
+	/* Divide clock by TMU_CLK_DIVIDER */
+	u16 bit = 0;
+
+	switch (TMU_CLK_DIVIDER) {
+	case 1024:
+		bit = 4;
+		break;
+	case 256:
+		bit = 3;
+		break;
+	case 64:
+		bit = 2;
+		break;
+	case 16:
+		bit = 1;
+		break;
+	case 4:
+	default:
+		break;
+	}
+	writew(readw(TCR0) | bit, TCR0);
+
+	/* Clock frequency calc */
+	timer_freq = get_tmu0_clk_rate() >> ((bit + 1) * 2);
+
+	tmu_timer_stop(0);
+	tmu_timer_start(0);
+
 	return 0;
 }
-void reset_timer (void)
+
+unsigned long long get_ticks (void)
 {
-	TMU_OFF ();
-	TMU_CLEAR ();
-	TMU_ON ();
+	return 0 - readl(TCNT0);
 }
 
-ulong get_timer (ulong base)
+static inline void tick_delay (const unsigned long long delta)
 {
-  ulong now = TMU_GET();
-	return ((int)now - base) < 0 ? (TMU_MAX_COUNTER - (base - now)) : (now - base);
+	const u64 start = get_ticks();		/* get timestamp on entry */
+	u64 tmp = start + delta;		/* calculate end timestamp */
+
+	if (delta == 0)				/* zero delay ? */
+		tmp++;				/* minimum of ONE tick */
+
+	if (tmp > TMU_MAX_COUNTER)		/* overflows 32-bits ? */
+	{
+		while (get_ticks() >= start)	/* loop till overflowed */
+			/*NOP*/;
+		tmp &= TMU_MAX_COUNTER;		/* mask off upper 32-bits */
+	}
+
+	while (get_ticks() < tmp)		/* loop till event */
+		/*NOP*/;
 }
 
-void set_timer (ulong t)
+void udelay (unsigned long usec)		/* delay in micro-seconds */
 {
-	TMU_SET (t);
+	u64 delta = usec_to_tick(usec);		/* time to wait */
+
+	tick_delay (delta);			/* wait ... */
 }
 
-void udelay (unsigned long usec)
+void ndelay (unsigned long nsec)		/* delay in nano-seconds */
 {
-  ulong tmo;
-  ulong start = TMU_GET ();
-  if (usec > 1000000)
-    tmo = ((usec/100000) * CFG_HZ) / 10;
-  else if (usec > 1000)
-    tmo = ((usec/100) * CFG_HZ) / 10000;
-  else
-    tmo = (usec * CFG_HZ) / 1000000;
-  while (get_timer(start) < tmo)
-		/*NOP*/;
+	u64 delta = usec_to_tick(nsec);		/* time to wait */
+
+	delta /= 1000ull;			/* remember: nsec not usec ! */
+
+	tick_delay (delta);			/* wait ... */
+}
+
+unsigned long get_timer (unsigned long base)
+{
+	/* return msec */
+	return tick_to_time(get_ticks()) - base;
+}
+
+void set_timer (unsigned long t)
+{
+	/* Note: timer must be STOPPED to update it */
+	tmu_timer_stop(0);
+	writel((0 - t), TCNT0);
+	tmu_timer_start(0);
+}
+
+void reset_timer (void)
+{
+	set_timer (0);
 }
 
-ulong get_tbclk (void)
+unsigned long get_tbclk (void)
 {
-	return CFG_HZ;
+	return timer_freq;
 }
diff --git a/sh_config.mk b/sh_config.mk
index fd7b172..52a0c9b 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2009-08-05\""
+SH_IDENT_STRING="\"stm23-2009-09-21\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
diff --git a/tools/scripts/define2mk.sed b/tools/scripts/define2mk.sed
index 6464627..d66de86 100644
--- a/tools/scripts/define2mk.sed
+++ b/tools/scripts/define2mk.sed
@@ -27,3 +27,28 @@
 	# print the line
 	p
 }
+
+# Also, add the definition for "CFG_SDRAM_BASE".
+# This is for the SH boards, where the address of SDRAM can vary
+# depending on the exact board, and if it is in 29 or 32-bit mode.
+# Used by examples/Makefile
+/^#define CFG_SDRAM_BASE/ {
+	# Strip the #define prefix
+	s/#define *//;
+	# Change to form CONFIG_*=VALUE
+	s/ \+/=/;
+	# Drop trailing spaces
+	s/ *$//;
+	# drop quotes around string values
+	s/="\(.*\)"$/=\1/;
+	# Concatenate string values
+	s/" *"//g;
+	# Wrap non-numeral values with quotes
+	s/=\(.*\?[^0-9].*\)$/=\"\1\"/;
+	# Change '1' and empty values to "y" (not perfect, but
+	# supports conditional compilation in the makefiles
+	s/=$/=y/;
+	s/=1$/=y/;
+	# print the line
+	p
+}
