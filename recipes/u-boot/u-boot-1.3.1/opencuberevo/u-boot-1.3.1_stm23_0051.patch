diff --git a/MAKEALL b/MAKEALL
index ecfdfd0..f0048be 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -710,6 +710,7 @@ LIST_sh="		\
 	eud7141se	\
 	mb837se		\
 	hdk7108se	\
+	mb903se		\
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index bb42360..6b5bfba 100644
--- a/Makefile
+++ b/Makefile
@@ -2855,6 +2855,16 @@ hdk7108se_config :		unconfig
 	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/hdk7108/config.tmp)
 	@$(MKCONFIG) -a hdk7108 sh sh hdk7108 st stx7108
 
+mb903se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb903
+	@echo "#define CONFIG_SH_STX7108    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB903      1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb903/config.tmp)
+	@$(MKCONFIG) -a mb903 sh sh mb903 st stx7108
+
 mb704_config \
 mb704se_config :		unconfig
 	@mkdir -p $(obj)include $(obj)board/st/mb704
diff --git a/board/st/eud7141/eud7141.c b/board/st/eud7141/eud7141.c
index 845780c..b46bcd4 100644
--- a/board/st/eud7141/eud7141.c
+++ b/board/st/eud7141/eud7141.c
@@ -43,7 +43,7 @@ extern void flashWriteDisable(void)
 }
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-static void phy_reset(void)
+extern void stmac_phy_reset(void)
 {
 #if CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE	/* MAC = STM GMAC#1 */
 	/* Reset the on-board IC+ IP1001 PHY (U51) */
@@ -87,7 +87,7 @@ extern int board_init(void)
 	configPIO();
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-	phy_reset();	/* Reset the PHY */
+	stmac_phy_reset();	/* Reset the PHY */
 #if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE	/* MAC = STM GMAC#0 */
 	/* QQQ TODO: No H/W provided to test this! */
 	stx7141_configure_ethernet(0, 0, 0, 0);
diff --git a/board/st/eud7141/nand.c b/board/st/eud7141/nand.c
index 7cdc735..68b092f 100644
--- a/board/st/eud7141/nand.c
+++ b/board/st/eud7141/nand.c
@@ -110,10 +110,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = eud7141_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/fldb/nand.c b/board/st/fldb/nand.c
index 01f0a85..2c44017 100644
--- a/board/st/fldb/nand.c
+++ b/board/st/fldb/nand.c
@@ -110,10 +110,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = fldb_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/fudb/nand.c b/board/st/fudb/nand.c
index 793881c..0458b83 100644
--- a/board/st/fudb/nand.c
+++ b/board/st/fudb/nand.c
@@ -61,10 +61,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->read_buf      = stm_flex_read_buf;
 	nand->write_buf     = stm_flex_write_buf;
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/hdk5289/hdk5289-stx5206.romgen b/board/st/hdk5289/hdk5289-stx5206.romgen
new file mode 100644
index 0000000..d5662b2
--- /dev/null
+++ b/board/st/hdk5289/hdk5289-stx5206.romgen
@@ -0,0 +1,2032 @@
+/*
+This file was automatically generated on Wed 04 Aug 10 at 16:40:45 by user mcgoogan, host hoiho.bri.st.com using romgen R1.4.0 with the ST TargetPack hdk5289stx5206 using the option --target-connect with the ST Micro Connect hesiod-hti
+
+TargetPack files used:
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk5289stx5206/hdk5289stx5206.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk5289stx5206/hdk5289stx5206.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/hdk5289stx5206/hdk5289stx5206_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_ccn_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_addr_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_data_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_regs.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/debug/tapmux.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_emi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_lmigp_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_pio.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/tapmux.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206_audio_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206_clockgena_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206_clockgenb_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx5206/stx5206_sysconf_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/__init__.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/jtag.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/utilities/utilities.py
+*/
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+OR32(0xfe213000, 0x00100000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+OR32(0xfe213010, 0x00000001)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+UPDATE32(0xfe213000, 0xfff80000, 0x00000f01)
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+UPDATE32(0xfe213010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+UPDATE32(0xfe213000, 0xffefffff, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+OR32(0xfe213004, 0x00100000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+OR32(0xfe213010, 0x00000002)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+UPDATE32(0xfe213004, 0xfff80000, 0x00002803)
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_POWER_CFG
+*/
+UPDATE32(0xfe213010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+UPDATE32(0xfe213004, 0xffefffff, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+WHILE_NE32(0xfe213b00, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+WHILE_NE32(0xfe213b04, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+WHILE_NE32(0xfe213b08, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000004)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+/* PEEK(0xfe213b0c) (used target peek value 0x00000004) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+WHILE_NE32(0xfe213b0c, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+/* PEEK(0xfe213a10) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+WHILE_NE32(0xfe213a10, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000007)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+/* PEEK(0xfe213b14) (used target peek value 0x00000007) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+WHILE_NE32(0xfe213b14, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+/* PEEK(0xfe213a18) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+WHILE_NE32(0xfe213a18, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+/* PEEK(0xfe213a1c) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+WHILE_NE32(0xfe213a1c, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+/* PEEK(0xfe213b20) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+WHILE_NE32(0xfe213b20, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+/* PEEK(0xfe213b24) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+WHILE_NE32(0xfe213b24, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+/* PEEK(0xfe213b28) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+WHILE_NE32(0xfe213b28, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+/* PEEK(0xfe213b2c) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+WHILE_NE32(0xfe213b2c, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000002)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+/* PEEK(0xfe213b30) (used target peek value 0x00000002) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+WHILE_NE32(0xfe213b30, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000008)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+/* PEEK(0xfe213a34) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+WHILE_NE32(0xfe213a34, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000000b)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+/* PEEK(0xfe213b38) (used target peek value 0x0000000b) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+WHILE_NE32(0xfe213b38, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000007)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+/* PEEK(0xfe213b3c) (used target peek value 0x00000007) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+WHILE_NE32(0xfe213b3c, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+/* PEEK(0xfe213b40) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+WHILE_NE32(0xfe213b40, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000003)
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+/* PEEK(0xfe213b44) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+WHILE_NE32(0xfe213b44, 0x80000000, 0x00000000)
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG40
+*/
+UPDATE32(0xfe0011a0, 0xfffffffc, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+OR32(0xfe00112c, 0x00001000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+UPDATE32(0xfe00112c, 0xfffff001, 0x000006a0)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+UPDATE32(0xfe00112c, 0xffffefff, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x0000c0de)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NPDA [offset 4, size 1]
+*/
+/* PEEK(0xfe000014) (used target peek value 0x00000018) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NPDA [offset 4, size 1]
+*/
+UPDATE32(0xfe000014, 0xffffffef, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NRST [offset 3, size 1]
+*/
+/* PEEK(0xfe000014) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NRST [offset 3, size 1]
+*/
+UPDATE32(0xfe000014, 0xfffffff7, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NRST [offset 3, size 1]
+*/
+/* PEEK(0xfe000014) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NRST [offset 3, size 1]
+*/
+UPDATE32(0xfe000014, 0xfffffff7, 0x00000008)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NPDA [offset 4, size 1]
+*/
+/* PEEK(0xfe000014) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS0_CTRL .NPDA [offset 4, size 1]
+*/
+UPDATE32(0xfe000014, 0xffffffef, 0x00000010)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NPDA [offset 4, size 1]
+*/
+/* PEEK(0xfe00005c) (used target peek value 0x00000018) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NPDA [offset 4, size 1]
+*/
+UPDATE32(0xfe00005c, 0xffffffef, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NRST [offset 3, size 1]
+*/
+/* PEEK(0xfe00005c) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NRST [offset 3, size 1]
+*/
+UPDATE32(0xfe00005c, 0xfffffff7, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NRST [offset 3, size 1]
+*/
+/* PEEK(0xfe00005c) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NRST [offset 3, size 1]
+*/
+UPDATE32(0xfe00005c, 0xfffffff7, 0x00000008)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NPDA [offset 4, size 1]
+*/
+/* PEEK(0xfe00005c) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_FS1_CTRL .NPDA [offset 4, size 1]
+*/
+UPDATE32(0xfe00005c, 0xffffffef, 0x00000010)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfe0000b8, 0x00000000)
+
+
+/*
+stx5206_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+stx5206_audio_regs.AUDCFG_FSYNA_CFG
+*/
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_audio_regs.AUDCFG_FSYNA_CFG
+*/
+UPDATE32(0xfe210000, 0xfe7fffff, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG40
+*/
+UPDATE32(0xfe0011a0, 0xfffffff3, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d442041) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x00000020)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x00c447f9)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x0000000a)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG04
+*/
+UPDATE32(0xfe001110, 0xfffffffb, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG11
+*/
+UPDATE32(0xfe00112c, 0x00000ffe, 0x08010001)
+DELAY(200)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG04
+*/
+OR32(0xfe001110, 0x00000004)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000687f)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x000f000c)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x0042000a)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x0800239e)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x0000fa88)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG00
+*/
+/* PEEK(0xfe001100) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_CFG00
+*/
+OR32(0xfe001100, 0x00000001)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2d741b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00221ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x14001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_1
+*/
+POKE32(0xfe901034, 0x14001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008042)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x000083c2)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008042)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+OR32(0xfe901008, 0x00000200)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00000000) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b0c) (used target peek value 0x00000004) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000007) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000003) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000002) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000008) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000000b) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx5206_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002828) */
+
+
+/*
+stx5206_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000007) */
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000003)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000004)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000003)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+UPDATE32(0xfe001180, 0xffffffef, 0x00000000)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfe00111c, 0x00010000)
+POKE32(0xfd117000, 0x0025c608)
+/* PEEK(0xfe001180) (used target peek value 0x00000005) */
+UPDATE32(0xfe001180, 0xfffffffb, 0x00000000)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/st/hdk5289/hdk5289.c b/board/st/hdk5289/hdk5289.c
index 13b95ee..43e0479 100644
--- a/board/st/hdk5289/hdk5289.c
+++ b/board/st/hdk5289/hdk5289.c
@@ -44,7 +44,7 @@ void flashWriteDisable(void)
 
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-static void phy_reset(void)
+extern void stmac_phy_reset(void)
 {
 	/*
 	 * Reset the Ethernet PHY.
@@ -100,7 +100,7 @@ extern int board_init(void)
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
 	/* Reset the PHY */
-	phy_reset();
+	stmac_phy_reset();
 
 	stx5206_configure_ethernet(stx5206_ethernet_mii, 0, 0);
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
diff --git a/board/st/hdk5289/init-hdk5289.S b/board/st/hdk5289/init-hdk5289.S
index 5c0858e..b24e19b 100644
--- a/board/st/hdk5289/init-hdk5289.S
+++ b/board/st/hdk5289/init-hdk5289.S
@@ -27,7 +27,6 @@
 
 __memory_setup_table:
 
-#ifdef QQQ	/* QQQ - DELETE */
 	/*
 	 * include the appropriate set of "GDB pokes", (usually) generated
 	 * using the "romgen" utility, from a known good target-pack.
@@ -36,10 +35,10 @@ __memory_setup_table:
 	 * to an STMC2 (note: currently it must be version 2) and then
 	 * executing the following command (redirecting the output):
 	 *
-	 * host% romgen --show-comment <stmc2>:mb796stx5206:st40,boot_companions=0
+	 * host% romgen --show-comment --target-connect <stmc2>:hdk5289stx5206:st40,boot_companions=0
 	 *
 	 * Where "<stmc2>" should be replaced with the IP address
-	 * (or the DNS name) of the STMC2 box.  Also the "mb796stx5206" should
+	 * (or the DNS name) of the STMC2 box.  Also the "hdk5289stx5206" should
 	 * substituted if you have a custom target-pack connect command.
 	 *
 	 * Note: The connect command used with "romgen", should connect
@@ -61,7 +60,6 @@ __memory_setup_table:
 	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
 	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
 #endif	/* CONFIG_SH_SE_MODE */
-#endif		/* QQQ - DELETE */
 
 	END_MARKER
 
diff --git a/board/st/hdk5289/nand.c b/board/st/hdk5289/nand.c
index 954e2bd..644a1d9 100644
--- a/board/st/hdk5289/nand.c
+++ b/board/st/hdk5289/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = hdk5289_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/hdk7108/hdk7108.c b/board/st/hdk7108/hdk7108.c
index 9540153..59f79cd 100644
--- a/board/st/hdk7108/hdk7108.c
+++ b/board/st/hdk7108/hdk7108.c
@@ -79,7 +79,7 @@ static void configPIO(void)
 	 * Configure the Ethernet PHY Reset signal
 	 *	PIO15[4] == POWER_ON_ETH (a.k.a. ETH_RESET)
 	 */
-	SET_PIO_PIN(PIO_PORT(15), 4, STPIO_OUT);
+	SET_PIO_PIN(ST40_PIO_BASE(15), 4, STPIO_OUT);
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	/*
@@ -87,12 +87,12 @@ static void configPIO(void)
 	 * controlled by the following PIO line...
 	 *	PIO5[0] == POWER_ON
 	 */
-	SET_PIO_PIN(PIO_PORT(5), 0, STPIO_OUT);
-	STPIO_SET_PIN(PIO_PORT(5), 0, 1);
+	SET_PIO_PIN(ST40_PIO_BASE(5), 0, STPIO_OUT);
+	STPIO_SET_PIN(ST40_PIO_BASE(5), 0, 1);
 }
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-static void phy_reset(void)
+extern void stmac_phy_reset(void)
 {
 	/*
 	 * Reset the Ethernet PHY.
@@ -100,9 +100,9 @@ static void phy_reset(void)
 	 *
 	 *	PIO15[4] = POWER_ON_ETH (a.k.a. ETH_RESET)
 	 */
-	STPIO_SET_PIN(PIO_PORT(15), 4, 0);
+	STPIO_SET_PIN(ST40_PIO_BASE(15), 4, 0);
 	udelay(10000);				/* 10 ms */
-	STPIO_SET_PIN(PIO_PORT(15), 4, 1);
+	STPIO_SET_PIN(ST40_PIO_BASE(15), 4, 1);
 }
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
@@ -118,7 +118,7 @@ extern int board_init(void)
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
 	/* Reset the PHY */
-	phy_reset();
+	stmac_phy_reset();
 #if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0, on MII JP2 */
 	stx7108_configure_ethernet(0, &(struct stx7108_ethernet_config) {
 			.mode = stx7108_ethernet_mode_mii,
diff --git a/board/st/hdk7108/nand.c b/board/st/hdk7108/nand.c
index 30cbe03..cbdf69b 100644
--- a/board/st/hdk7108/nand.c
+++ b/board/st/hdk7108/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = hdk7108_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/hdk7111/nand.c b/board/st/hdk7111/nand.c
index 39b28c8..ae45605 100644
--- a/board/st/hdk7111/nand.c
+++ b/board/st/hdk7111/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = hdk7111_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/mb680/mb680.c b/board/st/mb680/mb680.c
index 41938ba..f376226 100644
--- a/board/st/mb680/mb680.c
+++ b/board/st/mb680/mb680.c
@@ -127,7 +127,7 @@ void flashWriteDisable(void)
 }
 
 #ifdef CONFIG_STMAC_LAN8700
-static void phy_reset(void)
+extern void stmac_phy_reset(void)
 {
 	/* Reset the SMSC LAN8700 PHY */
 	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
@@ -189,7 +189,7 @@ extern int board_init(void)
 
 	/* Reset the PHY */
 #ifdef CONFIG_STMAC_LAN8700
-	phy_reset();
+	stmac_phy_reset();
 #endif	/* CONFIG_STMAC_LAN8700 */
 
 #if defined(CONFIG_SH_STM_SATA)
diff --git a/board/st/mb680/nand.c b/board/st/mb680/nand.c
index 19391cc..5b51f49 100644
--- a/board/st/mb680/nand.c
+++ b/board/st/mb680/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = mb680_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/mb796/mb796.c b/board/st/mb796/mb796.c
index 7896488..6ae7949 100644
--- a/board/st/mb796/mb796.c
+++ b/board/st/mb796/mb796.c
@@ -125,7 +125,7 @@ void flashWriteDisable(void)
 
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-static void phy_reset(void)
+extern void stmac_phy_reset(void)
 {
 	/*
 	 * Reset the Ethernet PHY.
@@ -200,7 +200,7 @@ extern int board_init(void)
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
 	/* Reset the PHY */
-	phy_reset();
+	stmac_phy_reset();
 
 	/*
 	 * The following works, with the jumpers connected as:
diff --git a/board/st/mb796/nand.c b/board/st/mb796/nand.c
index d9eb94f..70675a0 100644
--- a/board/st/mb796/nand.c
+++ b/board/st/mb796/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = mb796_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/mb837/nand.c b/board/st/mb837/nand.c
index 412be09..3cf918e 100644
--- a/board/st/mb837/nand.c
+++ b/board/st/mb837/nand.c
@@ -111,10 +111,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = mb837_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/board/st/mb903/Makefile b/board/st/mb903/Makefile
new file mode 100644
index 0000000..c99b16c
--- /dev/null
+++ b/board/st/mb903/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb903/config.mk b/board/st/mb903/config.mk
new file mode 100644
index 0000000..d1b7191
--- /dev/null
+++ b/board/st/mb903/config.mk
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2008,2010 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB903 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255 MiB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb903/init-mb903.S b/board/st/mb903/init-mb903.S
new file mode 100644
index 0000000..6096de1
--- /dev/null
+++ b/board/st/mb903/init-mb903.S
@@ -0,0 +1,61 @@
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+/*
+ * Only define the following if you want to use the "old"
+ * poke loop table interpreter. This should *not* be
+ * defined if you are now using the "romgen" tool to
+ * generate contemporary poke tables. The latest generation
+ * targetpacks may be incompatible with the old interpreter.
+ */
+#undef CONFIG_SH_OLD_POKE_LOOP_PARADIGM
+
+
+#include "asm/stx7108reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --show-comment <stmc2>:mb903stx7108:host,boot_companions=0
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb903stx7108" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * At the time of writing this (July 2010) the output from "romgen"
+	 * needs to be edited slightly.  The edit is just two add two lines
+	 * to comment out all the PMB + 32-bit mode configuration. The lines
+	 * to comment out start with the pokes that setup the PMB arrays,
+	 * and end with pokes that configure the CCN registers.
+	 * That is, the following two lines should be added:
+	 *		#if 0
+	 *		#endif
+	 * See the supplied version of the ".romgen" file, to see where
+	 * these have been added, if there is any doubt.
+	 */
+#include "mb903-stx7108.romgen"
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb903/mb903-stx7108.romgen b/board/st/mb903/mb903-stx7108.romgen
new file mode 100644
index 0000000..f8d7c98
--- /dev/null
+++ b/board/st/mb903/mb903-stx7108.romgen
@@ -0,0 +1,2147 @@
+/*
+This file was automatically generated on Wed 28 Jul 10 at 18:08:24 by user mcgoogan, host hoiho.bri.st.com using romgen R1.4.0 with the ST TargetPack mb903stx7108
+
+TargetPack files used:
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb903stx7108/mb903stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb903stx7108/mb903stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb903stx7108/mb903stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/jtag_core.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st231.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_300_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_ccn_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_addr_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_data_array_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/cores/st40_pmb_regs.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/debug/tapmux.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/st40_emi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/peripherals/tapmux.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/clk_common.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/l2_cache_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3mixer_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3pctl_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/st40_ddr3phy_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgena_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_clockgenb_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_ddrdbg.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_design.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_interco_init.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_spi_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_0_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_1_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_2_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_3_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7108/stx7108_sysconf_4_regs.xml
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/__init__.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/socs/tap/jtag.py
+/opt/STM/STLinux-2.3/host/stmc/targetpack/utilities/utilities.py
+*/
+
+
+/*
+stx7108_spi_regs.SPI_CLOCKDIV
+*/
+POKE32(0xfe902010, 0x00000006)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfde98014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfde98024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfde98000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xfff80000, 0x00003203)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfde98000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfde98000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfde98004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfde98010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xfff80000, 0x00000f02)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfde98010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfde98004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfde98004, 0xffefffff, 0x00000000)
+POKE32(0xfde98908, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffffcf, 0x00000010)
+POKE32(0xfde9890c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffff3f, 0x00000040)
+POKE32(0xfde98a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffffcff, 0x00000100)
+POKE32(0xfde98a14, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffff3ff, 0x00000400)
+POKE32(0xfde98b18, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffffcfff, 0x00002000)
+POKE32(0xfde98a1c, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffff3fff, 0x00004000)
+POKE32(0xfde98a20, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfffcffff, 0x00010000)
+POKE32(0xfde98a24, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfff3ffff, 0x00040000)
+POKE32(0xfde98a28, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xffcfffff, 0x00100000)
+POKE32(0xfde98a2c, 0x0000000e)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xff3fffff, 0x00400000)
+POKE32(0xfde98a30, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xfcffffff, 0x01000000)
+POKE32(0xfde98a34, 0x00000009)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xf3ffffff, 0x04000000)
+POKE32(0xfde98b38, 0x00000011)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0xcfffffff, 0x20000000)
+POKE32(0xfde98a3c, 0x00000004)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfde98014, 0x3fffffff, 0x40000000)
+POKE32(0xfde98b40, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffffc, 0x00000002)
+POKE32(0xfde98b44, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfde98024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfdab8014, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfdab8024, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+OR32(0xfdab8000, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xfff80000, 0x00000b01)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfdab8000, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+UPDATE32(0xfdab8000, 0xffefffff, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+OR32(0xfdab8004, 0x00100000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+OR32(0xfdab8010, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xfff80000, 0x00002803)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+UPDATE32(0xfdab8010, 0xfffffffd, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfdab8004, 0x80000000, 0x80000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+UPDATE32(0xfdab8004, 0xffefffff, 0x00000000)
+POKE32(0xfdab8b04, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffff3, 0x00000008)
+POKE32(0xfdab8b08, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffffcf, 0x00000020)
+POKE32(0xfdab8b0c, 0x00000001)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffffff3f, 0x00000080)
+POKE32(0xfdab8a10, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffffcff, 0x00000100)
+POKE32(0xfdab8b14, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffff3ff, 0x00000800)
+POKE32(0xfdab8b1c, 0x00000002)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffff3fff, 0x00008000)
+POKE32(0xfdab8b20, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfffcffff, 0x00020000)
+POKE32(0xfdab8b24, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfff3ffff, 0x00080000)
+POKE32(0xfdab8b28, 0x0000001f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xffcfffff, 0x00200000)
+POKE32(0xfdab8b2c, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xff3fffff, 0x00800000)
+POKE32(0xfdab8b30, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xfcffffff, 0x02000000)
+POKE32(0xfdab8b34, 0x00000007)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xf3ffffff, 0x08000000)
+POKE32(0xfdab8a38, 0x00000000)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0xcfffffff, 0x10000000)
+POKE32(0xfdab8b3c, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG
+*/
+UPDATE32(0xfdab8014, 0x3fffffff, 0x80000000)
+POKE32(0xfdab8b40, 0x0000000f)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffffc, 0x00000002)
+POKE32(0xfdab8b44, 0x00000003)
+
+
+/*
+stx7108_clockgena_regs.CLOCKGENA_CLKOPSRC_SWITCH_CFG2
+*/
+UPDATE32(0xfdab8024, 0xfffffff3, 0x00000008)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c0de)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfd5460b8, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_MD3
+*/
+POKE32(0xfd546080, 0x00000013)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_PE3
+*/
+POKE32(0xfd546084, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_SDIV3
+*/
+POKE32(0xfd54608c, 0x00000002)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000001)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_FS1_EN_PRG3
+*/
+POKE32(0xfd546088, 0x00000000)
+
+
+/*
+stx7108_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfd546010, 0x0000c1a0)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_STATUS0
+*/
+IF_GT32(1, 0xfde20000, 0xf0000000, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x01850f00)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_STATUS5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_STATUS0
+*/
+ELSE(1)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  UPDATE32(0xfde2004c, 0xfffffffe, 0x00000000)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  UPDATE32(0xfde2004c, 0xfe0000ff, 0x00040100)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG4
+*/
+  OR32(0xfde2004c, 0x00000001)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_STATUS5
+*/
+  WHILE_NE32(0xfde20014, 0x00000001, 0x00000001)
+ENDIF(1)
+POKE32(0x10008000, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe900860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe900800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe900810, 0x00000020)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe900820, 0x00000022)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe900830, 0x0000002c)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe900840, 0x00000030)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe900100, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe900108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe900110, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe900118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe900140, 0x041016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe900148, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe900150, 0x9d224400)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe900158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe900180, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe900188, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe900190, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe900198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe9001c0, 0x00c447f9)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe9001c8, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe9001d0, 0xff86a8a8)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe9001d8, 0x0000000a)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe900028, 0x00000010)
+
+
+/*
+stx7108_sysconf_0_regs.SYSTEM_CONFIG12
+*/
+UPDATE32(0xfde30028, 0xfffffffd, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSTEM_CONFIG12
+*/
+OR32(0xfde30028, 0x00000002)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde52030, 0x00500040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde52038, 0x23220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde521c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde52000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde520a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde52028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde500c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde500c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde500cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde500c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde50410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde50434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+POKE32(0xfde5031c, 0x00004305)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde50044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde50048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde50080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde50084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde5008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde50090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde500d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde500d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde500d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde500dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde500e0, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde500e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde500e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde500ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde500f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde500f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde500f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde500fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde50100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde50104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde50108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde5010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde50110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde50114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde50118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde5011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde50120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde50124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde50128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde5012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde50130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde50134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde50138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00144083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00120003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde50040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde50040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde50040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde50484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde50484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde50484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde50300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde50320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PVTTUPDWAIT
+*/
+POKE32(0xfde50324, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde50004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde50008, 0x00000007, 0x00000003)
+
+
+/*
+stx7108_sysconf_0_regs.SYSTEM_CONFIG12
+*/
+UPDATE32(0xfde30028, 0xfffffffb, 0x00000000)
+DELAY(100000)
+
+
+/*
+stx7108_sysconf_0_regs.SYSTEM_CONFIG12
+*/
+OR32(0xfde30028, 0x00000004)
+
+
+/*
+stx7108_sysconf_1_regs.SYSTEM_CONFIG18
+*/
+OR32(0xfde20084, 0x00000003)
+DELAY(10000)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_BASE_ADDR
+*/
+POKE32(0xfde72030, 0x00900080)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_DDR_PARAMETER
+*/
+POKE32(0xfde72038, 0x23220e29)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_PURPOSE_REG0
+*/
+POKE32(0xfde721c0, 0x104020ca)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_GEN_CTRL
+*/
+POKE32(0xfde72000, 0x00080710)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_HI_PRI_PORT_FLOW_REG1
+*/
+POKE32(0xfde720a0, 0x1f034040)
+
+
+/*
+st40_ddr3mixer_regs.DDR3MIXER_ROW_ADDR_MASK
+*/
+POKE32(0xfde72028, 0xfffffc00)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT1U
+*/
+POKE32(0xfde700c0, 0x000000f0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TINIT
+*/
+POKE32(0xfde700c4, 0x000000c8)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TOGCNT100N
+*/
+POKE32(0xfde700cc, 0x00000018)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTH
+*/
+POKE32(0xfde700c8, 0x000001f4)
+DELAY(10000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PGSR0
+*/
+WHILE_NE32(0xfde70410, 0x00000027, 0x00000027)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00010000, 0x00010000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_DXCCR
+*/
+OR32(0xfde70434, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYIOCRV1
+*/
+POKE32(0xfde7031c, 0x00004305)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0xbfd80002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWCTL
+*/
+POKE32(0xfde70044, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_POWSTAT
+*/
+WHILE_NE32(0xfde70048, 0x00000001, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCFG
+*/
+POKE32(0xfde70080, 0x000a0061)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PPCFG
+*/
+POKE32(0xfde70084, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_ODTCFG
+*/
+POKE32(0xfde7008c, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_DQSECFG
+*/
+POKE32(0xfde70090, 0x00111111)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TREFI
+*/
+POKE32(0xfde700d0, 0x0000004e)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMRD
+*/
+POKE32(0xfde700d4, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRFC
+*/
+POKE32(0xfde700d8, 0x0000003b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRP
+*/
+POKE32(0xfde700dc, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTW
+*/
+POKE32(0xfde700e0, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TAL
+*/
+POKE32(0xfde700e4, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCL
+*/
+POKE32(0xfde700e8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCWL
+*/
+POKE32(0xfde700ec, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRAS
+*/
+POKE32(0xfde700f0, 0x00000014)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRC
+*/
+POKE32(0xfde700f4, 0x0000001b)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRCD
+*/
+POKE32(0xfde700f8, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRRD
+*/
+POKE32(0xfde700fc, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRTP
+*/
+POKE32(0xfde70100, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWR
+*/
+POKE32(0xfde70104, 0x00000008)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TWTR
+*/
+POKE32(0xfde70108, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TEXSR
+*/
+POKE32(0xfde7010c, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXP
+*/
+POKE32(0xfde70110, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TXPDLL
+*/
+POKE32(0xfde70114, 0x0000000d)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCS
+*/
+POKE32(0xfde70118, 0x00000040)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCSI
+*/
+POKE32(0xfde7011c, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TDQS
+*/
+POKE32(0xfde70120, 0x00000004)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRE
+*/
+POKE32(0xfde70124, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKSRX
+*/
+POKE32(0xfde70128, 0x00000006)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TCKE
+*/
+POKE32(0xfde7012c, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TMOD
+*/
+POKE32(0xfde70130, 0x0000000c)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TRSTL
+*/
+POKE32(0xfde70134, 0x0000007f)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_TZQCL
+*/
+POKE32(0xfde70138, 0x00000200)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x07100000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00144083)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00160003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00120003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00109403)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+POKE32(0xfde70040, 0x00100005)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+OR32(0xfde70040, 0x80000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_MCMD
+*/
+WHILE_NE32(0xfde70040, 0x80000000, 0x00000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000001)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000001)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+UPDATE32(0xfde70484, 0xfffffffd, 0x00000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+OR32(0xfde70484, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00020000, 0x00020000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00040000, 0x00040000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00080000, 0x00080000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00200000, 0x00200000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x00400000, 0x00400000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x01000000, 0x01000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x02000000, 0x02000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x08000000, 0x08000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x10000000, 0x10000000)
+
+
+/*
+st40_ddr3phy_regs.DDR3PHY_PUB_SMCTL
+*/
+WHILE_NE32(0xfde70484, 0x40000000, 0x40000000)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYPVTCFG
+*/
+POKE32(0xfde70300, 0x000045d0)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PHYTUPDWAIT
+*/
+POKE32(0xfde70320, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_PVTTUPDWAIT
+*/
+POKE32(0xfde70324, 0x00000003)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_SCTL
+*/
+POKE32(0xfde70004, 0x00000002)
+
+
+/*
+st40_ddr3pctl_regs.DDR3PCTL_STAT
+*/
+WHILE_NE32(0xfde70008, 0x00000007, 0x00000003)
+UPDATE32(0xfdea3a00, 0x00000000, 0x0a0d0b0c)
+UPDATE32(0xfdea3a0c, 0x0000ffff, 0x0b0c0000)
+UPDATE32(0xfdea3a10, 0xffff0000, 0x00000a0d)
+UPDATE32(0xfd2e1004, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd2e1008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd2e100c, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd2e1010, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd2e1014, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd2e1018, 0x0000ffff, 0x00060000)
+UPDATE32(0xfd2e3004, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd2e3008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd2e300c, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd2e3010, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd2e3014, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd2e3018, 0x0000ffff, 0x00060000)
+UPDATE32(0xfd544010, 0xfc00ff00, 0x000600a3)
+UPDATE32(0xfd5440b0, 0xfc00ff00, 0x000600a3)
+UPDATE32(0xfe76b0fc, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5450ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5450f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5450f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5450f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5450fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5451ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5451f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5451f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5451f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5451fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5452ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5452f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5452f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5452f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5452fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd5453ec, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd5453f0, 0xfffffff8, 0x00000005)
+UPDATE32(0xfd5453f4, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd5453f8, 0xfffffff8, 0x00000002)
+UPDATE32(0xfd5453fc, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd545efc, 0xfffffff8, 0x00000005)
+UPDATE32(0xfde00030, 0xfffffff8, 0x00000006)
+UPDATE32(0xfde00034, 0xfffffff8, 0x00000001)
+UPDATE32(0xfde00038, 0xfffffff8, 0x00000000)
+UPDATE32(0xfde0004c, 0xfffffc00, 0x00000000)
+UPDATE32(0xfde00050, 0xfffffc00, 0x00000000)
+UPDATE32(0xfde00108, 0x1fffffff, 0xa0000000)
+UPDATE32(0xfde0010c, 0xfffffff8, 0x00000005)
+UPDATE32(0xfde00110, 0xfff8f8f8, 0x00010202)
+UPDATE32(0xfde00114, 0xfff8f8f8, 0x00000000)
+UPDATE32(0xfde20044, 0xfffffffc, 0x00000000)
+UPDATE32(0xfdabeb04, 0xfffffff8, 0x00000006)
+UPDATE32(0xfdabeb08, 0xfffffff8, 0x00000001)
+UPDATE32(0xfdabeb0c, 0x0000fff8, 0x00000000)
+UPDATE32(0xfdabeb10, 0xfffffff0, 0x00000001)
+UPDATE32(0xfdabeb24, 0xfffffff8, 0x00000006)
+UPDATE32(0xfdabeb28, 0xfffffff8, 0x00000001)
+UPDATE32(0xfdabeb2c, 0x0000fff8, 0x00000000)
+UPDATE32(0xfdabeb30, 0xfffffff0, 0x00000001)
+UPDATE32(0xfdabeb44, 0xfffffff8, 0x00000006)
+UPDATE32(0xfdabeb48, 0xfffffff8, 0x00000001)
+UPDATE32(0xfdabeb4c, 0x0000fff8, 0x00000000)
+UPDATE32(0xfdabeb50, 0xfffffff0, 0x00000001)
+UPDATE32(0xfdabeb84, 0xfffffff8, 0x00000006)
+UPDATE32(0xfdabeb88, 0xfffffff8, 0x00000001)
+UPDATE32(0xfdabeb8c, 0x0000fff8, 0x00000000)
+UPDATE32(0xfdabeb90, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd002024, 0xfff01fff, 0x0003c000)
+UPDATE32(0xfd003024, 0xfff01fff, 0x0003c000)
+UPDATE32(0xfd004024, 0xfff01fff, 0x0003c000)
+IF_EQ32(1, 0xfe7000b8, 0x00000001, 0x00000000)
+  UPDATE32(0xfe0fff04, 0xffc00000, 0x00264006)
+ENDIF(1)
+IF_EQ32(1, 0xfe7000b8, 0x00000002, 0x00000000)
+  UPDATE32(0xfe1fff04, 0xffc00000, 0x00264006)
+ENDIF(1)
+IF_EQ32(1, 0xfe7000b8, 0x00000004, 0x00000000)
+  UPDATE32(0xfe2fff04, 0xffc00000, 0x00264006)
+ENDIF(1)
+IF_EQ32(1, 0xfda500d4, 0x00000001, 0x00000001)
+  UPDATE32(0xfda8f000, 0xffd00000, 0x00264006)
+  UPDATE32(0xfda89000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+IF_EQ32(1, 0xfe70010c, 0x00000001, 0x00000001)
+  UPDATE32(0xfe737000, 0xffd00000, 0x00264006)
+  UPDATE32(0xfe731000, 0xfffec0ff, 0x00000800)
+ENDIF(1)
+IF_EQ32(1, 0xfda50078, 0x00000004, 0x00000000)
+  UPDATE32(0xfdaa9744, 0xffd00000, 0x00264006)
+ENDIF(1)
+UPDATE32(0xfe768000, 0xffffffe8, 0x00000004)
+UPDATE32(0xfe768004, 0xfffffff0, 0x00000001)
+UPDATE32(0xfe768008, 0xfffffff0, 0x00000001)
+UPDATE32(0xfe769000, 0xffffffe8, 0x00000004)
+UPDATE32(0xfe769004, 0xfffffff0, 0x00000001)
+UPDATE32(0xfe769008, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd62a000, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd62a004, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd62a008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd62a00c, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd62a010, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd628000, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd628004, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd628008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd62800c, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd628010, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd6aa000, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd6aa004, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd6aa008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd6aa00c, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd6aa010, 0xfffffff8, 0x00000000)
+UPDATE32(0xfd6a8000, 0xfffffff0, 0x00000001)
+UPDATE32(0xfd6a8004, 0xfffffff8, 0x00000006)
+UPDATE32(0xfd6a8008, 0xfffffff8, 0x00000003)
+UPDATE32(0xfd6a800c, 0xfffffff8, 0x00000001)
+UPDATE32(0xfd6a8010, 0xfffffff8, 0x00000000)
+UPDATE32(0xfda40c18, 0xfffffff0, 0x00000002)
+
+
+#if 0		/* added by Sean McGoogan <Sean.McGoogan@st.com> */
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY2
+*/
+POKE32(0xf7100200, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY2
+*/
+POKE32(0xf6100200, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY3
+*/
+POKE32(0xf7100300, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY3
+*/
+POKE32(0xf6100300, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY4
+*/
+POKE32(0xf7100400, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY4
+*/
+POKE32(0xf6100400, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY5
+*/
+POKE32(0xf7100500, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY5
+*/
+POKE32(0xf6100500, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY6
+*/
+POKE32(0xf7100600, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY6
+*/
+POKE32(0xf6100600, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY7
+*/
+POKE32(0xf7100700, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY7
+*/
+POKE32(0xf6100700, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY8
+*/
+POKE32(0xf7100800, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY8
+*/
+POKE32(0xf6100800, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY9
+*/
+POKE32(0xf7100900, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY9
+*/
+POKE32(0xf6100900, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY10
+*/
+POKE32(0xf7100a00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY10
+*/
+POKE32(0xf6100a00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY11
+*/
+POKE32(0xf7100b00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY11
+*/
+POKE32(0xf6100b00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY12
+*/
+POKE32(0xf7100c00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY12
+*/
+POKE32(0xf6100c00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY13
+*/
+POKE32(0xf7100d00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY13
+*/
+POKE32(0xf6100d00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY14
+*/
+POKE32(0xf7100e00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY14
+*/
+POKE32(0xf6100e00, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY15
+*/
+POKE32(0xf7100f00, 0x00000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY15
+*/
+POKE32(0xf6100f00, 0x80000000)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY0
+*/
+POKE32(0xf6100000, 0x80000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY0
+*/
+POKE32(0xf7100000, 0x40000188)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY1
+*/
+POKE32(0xf6100100, 0x88000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY1
+*/
+POKE32(0xf7100100, 0x48000188)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY2
+*/
+POKE32(0xf6100200, 0xa0000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY2
+*/
+POKE32(0xf7100200, 0x80000188)
+
+
+/*
+st40_pmb_addr_array_regs.PMB_ADDR_ARRAY_ENTRY3
+*/
+POKE32(0xf6100300, 0xa8000000)
+
+
+/*
+st40_pmb_data_array_regs.PMB_DATA_ARRAY_ENTRY3
+*/
+POKE32(0xf7100300, 0x88000188)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+OR32(0xff000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+IF_EQ32(1, 0xff000010, 0x00000010, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+  UPDATE32(0xff000010, 0xffffffef, 0x00000010)
+
+
+/*
+st40_ccn_regs.CCN_MMUCR
+*/
+ELSE(1)
+
+
+/*
+st40_ccn_regs.CCN_PASCR
+*/
+  UPDATE32(0xff000070, 0x7fffffff, 0x80000000)
+ENDIF(1)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+#endif	/* added by Sean McGoogan <Sean.McGoogan@st.com> */
+
diff --git a/board/st/mb903/mb903.c b/board/st/mb903/mb903.c
new file mode 100644
index 0000000..a4fe5ed
--- /dev/null
+++ b/board/st/mb903/mb903.c
@@ -0,0 +1,156 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7108reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Nothing to do. */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Nothing to do. */
+}
+
+
+#define PIOALT(port, pin, alt, dir)			\
+do							\
+{							\
+	stx7108_pioalt_select((port), (pin), (alt));	\
+	stx7108_pioalt_pad((port), (pin), (dir));	\
+} while(0)
+
+static void configPIO(void)
+{
+	/* Setup PIOs for ASC device */
+
+#if CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE
+
+	/*
+	 * Route UART3 via PIO24/25 for TX, RX, RTS & CTS (Alternative #1).
+	 *
+	 * Note: on the MB903A, RS232_RTS is connected (incorrectly)
+	 *       to PIO24[6], this is corrected in MB903B.
+	 */
+	PIOALT(24, 4, 1, &stx7108_pioalt_pad_out);	/* UART3-TX */
+	PIOALT(24, 5, 1, &stx7108_pioalt_pad_in);	/* UART3-RX */
+	PIOALT(24, 7, 1, &stx7108_pioalt_pad_out);	/* UART3-RTS */
+	PIOALT(25, 0, 1, &stx7108_pioalt_pad_in);	/* UART3-CTS */
+
+#else
+#error Unknown ASC port selected!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/*
+	 * Configure the Ethernet PHY Reset signal
+	 *	PIO20[0] == GMII0_notRESET
+	 *	PIO15[4] == GMII1_notRESET
+	 */
+	SET_PIO_PIN(ST40_PIO_BASE(15), 4, STPIO_OUT);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+extern void stmac_phy_reset(void)
+{
+	/*
+	 * Reset the Ethernet PHY.
+	 *	PIO20[0] == GMII0_notRESET
+	 *	PIO15[4] == GMII1_notRESET
+	 */
+	STPIO_SET_PIN(ST40_PIO_BASE(15), 4, 0);
+	udelay(10000);				/* 10 ms */
+	STPIO_SET_PIN(ST40_PIO_BASE(15), 4, 1);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+
+extern int board_init(void)
+{
+	configPIO();
+
+#ifdef QQQ	/* QQQ - DELETE */
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+#endif		/* QQQ - DELETE */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/* Reset the PHY */
+	stmac_phy_reset();
+#if CFG_STM_STMAC_BASE == CFG_STM_STMAC0_BASE		/* MII0, via MoCA Module */
+#error U-Boot does not support MoCA!
+	stx7108_configure_ethernet(0, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0, });
+#elif CFG_STM_STMAC_BASE == CFG_STM_STMAC1_BASE		/* MII1, IC+ IP1001 (U17) */
+	stx7108_configure_ethernet(1, &(struct stx7108_ethernet_config) {
+			.mode = stx7108_ethernet_mode_mii,
+			.ext_clk = 0,
+			.phy_bus = 1, });
+#else
+#error Unknown base address for the STM GMAC
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+#if defined(CONFIG_CMD_I2C)
+	stx7108_configure_i2c();
+#endif	/* CONFIG_CMD_I2C */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: MB903 (STx7108M)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#if defined(CONFIG_SPI)
+	/*
+	 * Configure for the SPI Serial Flash.
+	 * Note: for CFG_BOOT_FROM_SPI + CFG_ENV_IS_IN_EEPROM, this
+	 * needs to be done after env_init(), hence it is done
+	 * here, and not in board_init().
+	 */
+	stx7108_configure_spi();
+#endif	/* CONFIG_SPI */
+
+	return 0;
+}
diff --git a/board/st/pdk7105/nand.c b/board/st/pdk7105/nand.c
index 78e1e26..be77a01 100644
--- a/board/st/pdk7105/nand.c
+++ b/board/st/pdk7105/nand.c
@@ -110,10 +110,11 @@ extern int board_nand_init(struct nand_chip *nand)
 	nand->hwcontrol     = pdk7105_hwcontrol;
 #endif /* CFG_NAND_FLEX_MODE */
 
-#if 1
-	/* Enable the following to use a Bad Block Table (BBT) */
-	nand->options      |= NAND_USE_FLASH_BBT;
+	/* override scan_bbt(), even if not using a Bad Block Table (BBT) */
 	nand->scan_bbt      = stm_nand_default_bbt;
+
+#if 1	/* Enable to use a NAND-resident (non-volatile) Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
 #endif
 
 	return 0;
diff --git a/cpu/sh/ecc.c b/cpu/sh/ecc.c
index 1f17e8c..bd32b84 100644
--- a/cpu/sh/ecc.c
+++ b/cpu/sh/ecc.c
@@ -1,7 +1,7 @@
 /*
  * Synopsis : Error Correction Codes (ECC) Algorithms.
  *
- * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ * Copyright (c) 2008-2010 STMicroelectronics Limited.  All right reserved.
  *
  * See ecc.h for a description of this module.
  *
@@ -31,6 +31,45 @@
 #include <asm/ecc.h>
 
 
+const unsigned char  ecc_bit_count_table[256] =   /* Parity look up table */
+{
+  0, 1, 1, 2, 1, 2, 2, 3,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  5, 6, 6, 7, 6, 7, 7, 8
+};
+
+
+#if defined(CFG_NAND_ECC_HW3_128)
+
 static const unsigned char byte_parity_table[] =   /* Parity look up table */
 {
   0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
@@ -67,42 +106,6 @@ static const unsigned char byte_parity_table[] =   /* Parity look up table */
   0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00
 };
 
-static const unsigned char  bit_count_table[] =   /* Parity look up table */
-{
-  0, 1, 1, 2, 1, 2, 2, 3,
-  1, 2, 2, 3, 2, 3, 3, 4,
-  1, 2, 2, 3, 2, 3, 3, 4,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  1, 2, 2, 3, 2, 3, 3, 4,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  1, 2, 2, 3, 2, 3, 3, 4,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  4, 5, 5, 6, 5, 6, 6, 7,
-  1, 2, 2, 3, 2, 3, 3, 4,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  4, 5, 5, 6, 5, 6, 6, 7,
-  2, 3, 3, 4, 3, 4, 4, 5,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  4, 5, 5, 6, 5, 6, 6, 7,
-  3, 4, 4, 5, 4, 5, 5, 6,
-  4, 5, 5, 6, 5, 6, 6, 7,
-  4, 5, 5, 6, 5, 6, 6, 7,
-  5, 6, 6, 7, 6, 7, 7, 8
-};
-
 /*******************************************************************************/
 #define COL_LOOP_STEP(c__f, c__e, c__o, c__t) \
   c__o ^= (c__f ? c__t : 1); \
@@ -287,16 +290,16 @@ enum ecc_check ecc_correct(unsigned char* p_data,
        0xAA = 10101010
        0x55 = 01010101
      */
-    bit_cnt02  = bit_count_table[ ((ecc_xor[0] & 0xAA) >> 1) ^ (ecc_xor[0] & 0x55) ];
-    bit_cnt02 += bit_count_table[ ((ecc_xor[1] & 0xAA) >> 1) ^ (ecc_xor[1] & 0x55) ];
-    bit_cnt02 += bit_count_table[ ((ecc_xor[2] & 0xAA) >> 1) ^ (ecc_xor[2] & 0x55) ];
+    bit_cnt02  = ecc_bit_count_table[ ((ecc_xor[0] & 0xAA) >> 1) ^ (ecc_xor[0] & 0x55) ];
+    bit_cnt02 += ecc_bit_count_table[ ((ecc_xor[1] & 0xAA) >> 1) ^ (ecc_xor[1] & 0x55) ];
+    bit_cnt02 += ecc_bit_count_table[ ((ecc_xor[2] & 0xAA) >> 1) ^ (ecc_xor[2] & 0x55) ];
   }
   else
   {
     /* Counts the number of bits set in ecc code */
-    bit_cnt02  = bit_count_table[ ecc_xor[0] ];
-    bit_cnt02 += bit_count_table[ ecc_xor[1] ];
-    bit_cnt02 += bit_count_table[ ecc_xor[2] ];
+    bit_cnt02  = ecc_bit_count_table[ ecc_xor[0] ];
+    bit_cnt02 += ecc_bit_count_table[ ecc_xor[1] ];
+    bit_cnt02 += ecc_bit_count_table[ ecc_xor[2] ];
   }
 
   if (bit_cnt02 == error_bit_count)
@@ -485,5 +488,6 @@ int main()
 
   return 0;
 }
-#endif
+#endif	/* TESTING */
+#endif	/* CFG_NAND_ECC_HW3_128 */
 #endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 845d746..c4b775e 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -270,11 +270,20 @@ set_pmb:
 	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
 	#error Need to configure PMBs properly when more than 128MiB.
 	#endif
+	#if defined(CFG_BOOT_FROM_NAND) || defined(CFG_BOOT_FROM_SPI)
+		/* booting from NAND or SPI, so CSA and CSB are swapped */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x05  16		/* NOR FLASH CACHED */
+	#else	/* else, CSA and CSB are not swapped */
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_NAND */
 #elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_MB680)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
@@ -339,6 +348,20 @@ set_pmb:
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
 	#endif	/* CFG_BOOT_FROM_NAND */
+#elif defined(CONFIG_SH_STX7108) && defined(CONFIG_SH_MB903)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	#if !defined(CFG_BOOT_FROM_SPI)
+	SH4_SET_PMB 4 0xa0 0x00  128 0 0 1	/* NOR FLASH UN-cached (lower 64MiB) */
+	SH4_SET_PMB 5 0xb0 0x00  128		/* NOR FLASH CACHED */
+	#else
+	SH4_SET_PMB 4 0xa0 0x08  128 0 0 1	/* NOR FLASH UN-cached (upper 64MiB) */
+	SH4_SET_PMB 5 0xb0 0x08  128		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_SPI */
 #elif defined(CONFIG_SH_STX7108) && defined(CONFIG_SH_HDK7108)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
diff --git a/cpu/sh/stm-nand.c b/cpu/sh/stm-nand.c
index f47ea1c..c4c7f32 100644
--- a/cpu/sh/stm-nand.c
+++ b/cpu/sh/stm-nand.c
@@ -43,6 +43,14 @@
 #define VERBOSE_ECC		0	/* Enable for verbose ECC information  */
 
 
+#if !defined(CFG_STM_NAND_BOOT_MODE_ECC_WITH_B)
+#	define CFG_STM_NAND_BOOT_MODE_ECC_WITH_B	1	/* Enable 'B' tagging */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
+#if !defined(CFG_STM_NAND_AFM4_ECC_WITH_AFM)
+#	define CFG_STM_NAND_AFM4_ECC_WITH_AFM		1	/* Enable "AFM" tagging */
+#endif	/* CFG_STM_NAND_AFM4_ECC_WITH_AFM */
+
+
 /*
  * Define the bad/good block scan pattern which are used while scanning
  * the NAND device for any factory marked good/bad blocks.
@@ -80,41 +88,73 @@ struct nand_bbt_descr stm_nand_badblock_pattern_64 = {
 	/* for SMALL-page devices */
 static struct nand_oobinfo stm_nand_oobinfo_16 = {
 	.useecc = MTD_NANDECC_AUTOPLACE,
-	.eccbytes = 12,
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B
+	.eccbytes = 16,			/* 16 out of 16 bytes = 100% of OOB */
+	.eccpos = {
+		 0,  1,  2,  3,		/* 128-byte Record 0: ECC0, ECC1, ECC2, 'B' */
+		 4,  5,  6,  7,		/* 128-byte Record 1: ECC0, ECC1, ECC2, 'B' */
+		 8,  9, 10, 11,		/* 128-byte Record 2: ECC0, ECC1, ECC2, 'B' */
+		12, 13, 14, 15},	/* 128-byte Record 3: ECC0, ECC1, ECC2, 'B' */
+	.oobfree = { {0, 0} }		/* No free space in OOB! */
+#else	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
+	.eccbytes = 12,			/* 12 out of 16 bytes = 75% of OOB */
 	.eccpos = {
-		 0,  1,  2,	/* ECC for 1st 128-byte record */
-		 4,  5,  6,	/* ECC for 2nd 128-byte record */
-		 8,  9, 10,	/* ECC for 3rd 128-byte record */
-		12, 13, 14},	/* ECC for 4th 128-byte record */
-	.oobfree = { {3, 1}, {7, 1}, {11, 1}, {15, 1} }
+		 0,  1,  2,		/* 128-byte Record 0: ECC0, ECC1, ECC2 */
+		 4,  5,  6,		/* 128-byte Record 1: ECC0, ECC1, ECC2 */
+		 8,  9, 10,		/* 128-byte Record 2: ECC0, ECC1, ECC2 */
+		12, 13, 14}		/* 128-byte Record 3: ECC0, ECC1, ECC2 */
+	.oobfree = { {3, 1}, {7, 1}, {11, 1}, {15, 1} }	/* 4 free bytes in the OOB */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
 };
 
 	/* for LARGE-page devices */
 static struct nand_oobinfo stm_nand_oobinfo_64 = {
 	.useecc = MTD_NANDECC_AUTOPLACE,
-	.eccbytes = 48,
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B
+	.eccbytes = 64,			/* 64 out of 64 bytes = 100% of OOB */
 	.eccpos = {
-		 0,  1,  2,	/* ECC for  1st 128-byte record */
-		 4,  5,  6,	/* ECC for  2nd 128-byte record */
-		 8,  9, 10,	/* ECC for  3rd 128-byte record */
-		12, 13, 14,	/* ECC for  4th 128-byte record */
-		16, 17, 18,	/* ECC for  5th 128-byte record */
-		20, 21, 22,	/* ECC for  6th 128-byte record */
-		24, 25, 26,	/* ECC for  7th 128-byte record */
-		28, 29, 30,	/* ECC for  8th 128-byte record */
-		32, 33, 34,	/* ECC for  9th 128-byte record */
-		36, 37, 38,	/* ECC for 10th 128-byte record */
-		40, 41, 42,	/* ECC for 11th 128-byte record */
-		44, 45, 46,	/* ECC for 12th 128-byte record */
-		48, 49, 50,	/* ECC for 13th 128-byte record */
-		52, 53, 54,	/* ECC for 14th 128-byte record */
-		56, 57, 58,	/* ECC for 15th 128-byte record */
-		60, 61, 62},	/* ECC for 16th 128-byte record */
+		 0,  1,  2,  3,		/* 128-byte Record  0: ECC0, ECC1, ECC2, 'B' */
+		 4,  5,  6,  7,		/* 128-byte Record  1: ECC0, ECC1, ECC2, 'B' */
+		 8,  9, 10, 11,		/* 128-byte Record  2: ECC0, ECC1, ECC2, 'B' */
+		12, 13, 14, 15,		/* 128-byte Record  3: ECC0, ECC1, ECC2, 'B' */
+		16, 17, 18, 19,		/* 128-byte Record  4: ECC0, ECC1, ECC2, 'B' */
+		20, 21, 22, 23,		/* 128-byte Record  5: ECC0, ECC1, ECC2, 'B' */
+		24, 25, 26, 27,		/* 128-byte Record  6: ECC0, ECC1, ECC2, 'B' */
+		28, 29, 30, 31,		/* 128-byte Record  7: ECC0, ECC1, ECC2, 'B' */
+		32, 33, 34, 35,		/* 128-byte Record  8: ECC0, ECC1, ECC2, 'B' */
+		36, 37, 38, 39,		/* 128-byte Record  9: ECC0, ECC1, ECC2, 'B' */
+		40, 41, 42, 43,		/* 128-byte Record 10: ECC0, ECC1, ECC2, 'B' */
+		44, 45, 46, 47,		/* 128-byte Record 11: ECC0, ECC1, ECC2, 'B' */
+		48, 49, 50, 51,		/* 128-byte Record 12: ECC0, ECC1, ECC2, 'B' */
+		52, 53, 54, 55,		/* 128-byte Record 13: ECC0, ECC1, ECC2, 'B' */
+		56, 57, 58, 59,		/* 128-byte Record 14: ECC0, ECC1, ECC2, 'B' */
+		60, 61, 62, 63},	/* 128-byte Record 15: ECC0, ECC1, ECC2, 'B' */
+	.oobfree = { {0, 0} }		/* No free space in OOB! */
+#else	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
+	.eccbytes = 48,			/* 48 out of 64 bytes = 75% of OOB */
+	.eccpos = {
+		 0,  1,  2,		/* 128-byte Record  0: ECC0, ECC1, ECC2 */
+		 4,  5,  6,		/* 128-byte Record  1: ECC0, ECC1, ECC2 */
+		 8,  9, 10,		/* 128-byte Record  2: ECC0, ECC1, ECC2 */
+		12, 13, 14,		/* 128-byte Record  3: ECC0, ECC1, ECC2 */
+		16, 17, 18,		/* 128-byte Record  4: ECC0, ECC1, ECC2 */
+		20, 21, 22,		/* 128-byte Record  5: ECC0, ECC1, ECC2 */
+		24, 25, 26,		/* 128-byte Record  6: ECC0, ECC1, ECC2 */
+		28, 29, 30,		/* 128-byte Record  7: ECC0, ECC1, ECC2 */
+		32, 33, 34,		/* 128-byte Record  8: ECC0, ECC1, ECC2 */
+		36, 37, 38,		/* 128-byte Record  9: ECC0, ECC1, ECC2 */
+		40, 41, 42,		/* 128-byte Record 10: ECC0, ECC1, ECC2 */
+		44, 45, 46,		/* 128-byte Record 11: ECC0, ECC1, ECC2 */
+		48, 49, 50,		/* 128-byte Record 12: ECC0, ECC1, ECC2 */
+		52, 53, 54,		/* 128-byte Record 13: ECC0, ECC1, ECC2 */
+		56, 57, 58,		/* 128-byte Record 14: ECC0, ECC1, ECC2 */
+		60, 61, 62},		/* 128-byte Record 15: ECC0, ECC1, ECC2 */
 	.oobfree = {
 		{ 3, 1}, { 7, 1}, {11, 1}, {15, 1},
 		{19, 1}, {23, 1}, {27, 1}, {31, 1},
 		{35, 1}, {39, 1}, {43, 1}, {47, 1},
-		{51, 1}, {55, 1}, {59, 1}, {63, 1} },
+		{51, 1}, {55, 1}, {59, 1}, {63, 1} }	/* 16 free bytes in the OOB */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
 };
 
 
@@ -145,6 +185,7 @@ struct stm_mtd_nand_ecc
 	{
 		int			eccmode;
 		int			eccsize;
+		int			eccbytes;	/* for ECC + ID tags */
 		int			eccsteps;
 		struct nand_oobinfo	*autooob;
 		int (*calculate_ecc)(struct mtd_info *, const u_char *, u_char *);
@@ -287,6 +328,23 @@ extern int stm_nand_default_bbt (struct mtd_info *mtd)
 	else
 		this->badblock_pattern = &stm_nand_badblock_pattern_16;	/* SMALL-page */
 
+	/*
+	 * For the "boot-mode+B" ECC (i.e. 3+1/128) scheme, and for
+	 * the "AFM4" ECC (i.e. 4+3/512) scheme, then we wish to
+	 * be compatible with the way linux scans NAND devices.
+	 * So, we do not want to scan all pages, nor all the in-band data!
+	 * Play with the options to make it so...
+	 */
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B || CFG_STM_NAND_AFM4_ECC_WITH_AFM
+	this->badblock_pattern->options &= ~(NAND_BBT_SCANEMPTY|NAND_BBT_SCANALLPAGES);
+#endif
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B	/* Additional "B" tag in OOB ? */
+	this->badblock_pattern->options |= NAND_BBT_SCANSTMBOOTECC;
+#endif
+#if CFG_STM_NAND_AFM4_ECC_WITH_AFM	/* Additional "AFM" tag in OOB ? */
+	this->badblock_pattern->options |= NAND_BBT_SCANSTMAFMECC;
+#endif
+
 	/* now call the generic BBT function */
 	return nand_default_bbt (mtd);
 }
@@ -317,6 +375,9 @@ extern int stm_nand_calculate_ecc (
 		ecc_code[0] = 'B';
 		ecc_code[1] = 'A';
 		ecc_code[2] = 'D';
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B
+		ecc_code[3] = 'B';	/* append ASCII 'B', for Boot-mode */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
 		return -1;	/* Note: caller ignores this value! */
 	}
 	else
@@ -326,6 +387,9 @@ extern int stm_nand_calculate_ecc (
 		ecc_code[0] = computed_ecc.byte[0];
 		ecc_code[1] = computed_ecc.byte[1];
 		ecc_code[2] = computed_ecc.byte[2];
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B
+		ecc_code[3] = 'B';	/* append ASCII 'B', for Boot-mode */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
 	}
 
 	return 0;
@@ -434,6 +498,7 @@ static void initialize_ecc_diffs (
 	/* fill in "default_ecc" from the current "live" (default) structures */
 	default_ecc.nand.eccmode	= this->eccmode;
 	default_ecc.nand.eccsize	= this->eccsize;
+	default_ecc.nand.eccbytes	= this->eccbytes;
 	default_ecc.nand.eccsteps	= this->eccsteps;
 	default_ecc.nand.autooob	= this->autooob;
 	default_ecc.nand.calculate_ecc	= this->calculate_ecc;
@@ -445,6 +510,11 @@ static void initialize_ecc_diffs (
 	/* fill in "special_ecc" for our special "hybrid" ECC paradigm */
 	special_ecc.nand.eccmode	= NAND_ECC_HW3_128;
 	special_ecc.nand.eccsize	= 128;
+#if CFG_STM_NAND_BOOT_MODE_ECC_WITH_B
+	special_ecc.nand.eccbytes	= 3 + 1;	/* ECC 3+1/128, '+1' for 'B' */
+#else	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
+	special_ecc.nand.eccbytes	= 3;		/* ECC 3/128 */
+#endif	/* CFG_STM_NAND_BOOT_MODE_ECC_WITH_B */
 	special_ecc.nand.eccsteps	= mtd->oobblock / special_ecc.nand.eccsize;
 	special_ecc.nand.autooob	= autooob;
 	special_ecc.nand.calculate_ecc	= stm_nand_calculate_ecc;
@@ -472,6 +542,7 @@ static void set_ecc_diffs (
 
 	this->eccmode		= diffs->nand.eccmode;
 	this->eccsize		= diffs->nand.eccsize;
+	this->eccbytes		= diffs->nand.eccbytes;
 	this->eccsteps		= diffs->nand.eccsteps;
 	this->autooob		= diffs->nand.autooob;
 	this->calculate_ecc	= diffs->nand.calculate_ecc;
diff --git a/cpu/sh/stx7108/stx7108.c b/cpu/sh/stx7108/stx7108.c
index 049e185..528493f 100644
--- a/cpu/sh/stx7108/stx7108.c
+++ b/cpu/sh/stx7108/stx7108.c
@@ -73,8 +73,6 @@ extern void stx7108_pioalt_select(const int port, const int pin, const int alt)
 	BUG_ON(alt < 0 || alt > 5);
 #endif
 
-	if (alt == 0) BUG();		/* we do *not* handle this case here! */
-
 	switch (port)
 	{
 	case 0 ... 14:
@@ -604,6 +602,9 @@ extern int soc_init(void)
 
 	bd->bi_devid = *STX7108_SYSCONF_DEVICEID_0;
 
+	/* Make sure reset period is shorter than WDT time-out */
+	*STX7108_BANK0_SYSGFG(14) = 3000;	/* about 100 us */
+
 	return 0;
 }
 
@@ -647,7 +648,7 @@ extern int stx7108_usb_init(int port, int over_current, int power_ctrl)
 		reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
 		writel(reg, STX7105_SYSCONF_SYS_CFG34);
 		/* set PIO directionality, for OC as IN */
-		SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
+		SET_PIO_PIN(ST40_PIO_BASE(4), oc_pins[port], STPIO_IN);
 	}
 
 	if (power_ctrl) {
@@ -658,7 +659,7 @@ extern int stx7108_usb_init(int port, int over_current, int power_ctrl)
 		reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
 		writel(reg, STX7105_SYSCONF_SYS_CFG34);
 		/* set PIO directionality, for POWER as ALT_OUT */
-		SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+		SET_PIO_PIN(ST40_PIO_BASE(4), power_pins[port], STPIO_ALT_OUT);
 	}
 
 	/* start the USB Wrapper Host Controller */
@@ -820,24 +821,51 @@ extern int i2c_set_bus_speed(unsigned int speed)
 
 
 #if defined(CONFIG_SPI)
-#ifdef QQQ	/* QQQ - DELETE */
+extern void stx7108_configure_spi(void)
+{
+	/*
+	 *	We set up the PIO pins correctly for SPI
+	 */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+	/* route PIO (alternate #0) */
+	stx7108_pioalt_select(2, 1, 0);			/* SPI_MISO */
+	stx7108_pioalt_select(2, 0, 0);			/* SPI_MOSI */
+	stx7108_pioalt_select(1, 7, 0);			/* SPI_notCS */
+	stx7108_pioalt_select(1, 6, 0);			/* SPI_CLK */
+
+	/* set PIO directionality */
+	SET_PIO_PIN(ST40_PIO_BASE(2), 1, STPIO_IN);	/* SPI_MISO */
+	SET_PIO_PIN(ST40_PIO_BASE(2), 0, STPIO_OUT);	/* SPI_MOSI */
+	SET_PIO_PIN(ST40_PIO_BASE(1), 7, STPIO_OUT);	/* SPI_notCS */
+	SET_PIO_PIN(ST40_PIO_BASE(1), 6, STPIO_OUT);	/* SPI_CLK */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(ST40_PIO_BASE(2), 0, 0);		/* deassert SPI_MOSI */
+	STPIO_SET_PIN(ST40_PIO_BASE(1), 7, 1);		/* deassert SPI_notCS */
+	STPIO_SET_PIN(ST40_PIO_BASE(1), 6, 1);		/* assert SPI_CLK */
+#else
+#error Currently only S/W bit-banging for SPI is supported.
+#endif	/* CONFIG_SOFT_SPI */
+}
+
 #if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
 extern void stx7108_spi_scl(const int val)
 {
-	const int pin = 0;	/* PIO15[0] = SPI_CLK */
-	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+	const int pin = 6;	/* PIO1[6] = SPI_CLK */
+	STPIO_SET_PIN(ST40_PIO_BASE(1), pin, val ? 1 : 0);
 }
 
 extern void stx7108_spi_sda(const int val)
 {
-	const int pin = 1;	/* PIO15[1] = SPI_DOUT */
-	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+	const int pin = 0;	/* PIO2[0] = SPI_MOSI */
+	STPIO_SET_PIN(ST40_PIO_BASE(2), pin, val ? 1 : 0);
 }
 
 extern unsigned char stx7108_spi_read(void)
 {
-	const int pin = 3;	/* PIO15[3] = SPI_DIN */
-	return STPIO_GET_PIN(PIO_PORT(15), pin);
+	const int pin = 1;	/* PIO2[1] = SPI_MISO */
+	return STPIO_GET_PIN(ST40_PIO_BASE(2), pin);
 }
 #endif	/* CONFIG_SOFT_SPI */
 
@@ -848,15 +876,15 @@ extern unsigned char stx7108_spi_read(void)
  */
 static void spi_chip_select(const int cs)
 {
-	const int pin = 2;	/* PIO15[2] = SPI_NOTCS */
+	const int pin = 7;	/* PIO1[7] = SPI_notCS */
 
 	if (cs)
 	{	/* assert SPI CSn */
-		STPIO_SET_PIN(PIO_PORT(15), pin, 0);
+		STPIO_SET_PIN(ST40_PIO_BASE(1), pin, 0);
 	}
 	else
 	{	/* DE-assert SPI CSn */
-		STPIO_SET_PIN(PIO_PORT(15), pin, 1);
+		STPIO_SET_PIN(ST40_PIO_BASE(1), pin, 1);
 	}
 
 	if (cs)
@@ -876,6 +904,5 @@ spi_chipsel_type spi_chipsel[] =
 };
 int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
 
-#endif		/* QQQ - DELETE */
 #endif	/* CONFIG_SPI */
 
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index 19a9bc2..8a719a6 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -63,6 +63,10 @@
 
 #include <asm/errno.h>
 
+#if defined(CONFIG_SH4)
+#include <asm-sh/ecc.h>
+#endif	/* CONFIG_SH4 */
+
 /**
  * check_pattern - [GENERIC] check if a pattern is in the buffer
  * @buf:	the buffer to search
@@ -93,7 +97,7 @@ static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_des
 	/* Compare the pattern */
 	for (i = 0; i < td->len; i++) {
 		if (p[i] != td->pattern[i])
-			return -1;
+			goto check_failed;
 	}
 
 	p += td->len;
@@ -105,6 +109,45 @@ static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_des
 		}
 	}
 	return 0;
+
+check_failed:
+#if defined(CONFIG_SH4)
+	if (td->options & NAND_BBT_SCANSTMBOOTECC)	/* is it "Boot-Mode+B" (3+1/128) ? */
+	{	/* Check for STM "Boot-Mode+B" ECC... */
+		int e = 0;
+		for (i = paglen+3; i < len; i += 4)
+		{	/* check: OOB[n*4+3] == 'B', for n=0,1,2,... */
+			e += ecc_bit_count_table[buf[i] ^ 'B'];
+		}
+		/* Tolerate a single bit-error across all the 'B' markers in one page */
+		if (e <= 1)
+		{
+#if 0
+			printf("info: page recognised as good \"Boot-Mode+B\" (e=%u)\n", e);
+#endif
+			return 0;	/* treat as a "good" match */
+		}
+	}
+	if (td->options & NAND_BBT_SCANSTMAFMECC)	/* is it "AFM4" (4+3/512) ? */
+	{	/* Check for STM "AFM4" ECC... */
+		int e = 0;
+		for (i = paglen+3; i < len; i += 16)
+		{	/* check: OOB[n*16+3:n*16+5] == "AFM", for n=0,1,2,... */
+			e += ecc_bit_count_table[buf[i+0] ^ 'A'];
+			e += ecc_bit_count_table[buf[i+1] ^ 'F'];
+			e += ecc_bit_count_table[buf[i+2] ^ 'M'];
+		}
+		/* Tolerate a single bit-error across all the "AFM" markers in one page */
+		if (e <= 1)
+		{
+#if 0
+			printf("info: page recognised as good \"AFM4\" (e=%u)\n", e);
+#endif
+			return 0;	/* treat as a "good" match */
+		}
+	}
+#endif	/* CONFIG_SH4 */
+	return -1;	/* patterns failed to match! */
 }
 
 /**
@@ -590,8 +633,13 @@ static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
 	struct nand_chip *this = mtd->priv;
 
-	/* Ensure that we only scan for the pattern and nothing else */
-	bd->options = 0;
+	/*
+	 * Ensure that we only scan for the pattern and nothing else.
+	 * Although, we also permit a block to be recognised as "good"
+	 * even if the bad block marker says otherwise, *if* it matches
+	 * one of other known "special" OOB signatures.
+	 */
+	bd->options &= NAND_BBT_SCANSTMBOOTECC|NAND_BBT_SCANSTMAFMECC;
 	create_bbt (mtd, this->data_buf, bd, -1);
 	return 0;
 }
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 4fd4e16..0698421 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -80,6 +80,23 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 	int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
 	const char *mtd_device = meminfo->name;
 
+	/*
+	 * it is best (to minimise confusion) if the erase length
+	 * and the erase start addresses *ARE* both explicitly
+	 * aligned by the user to the erase block boundary.
+	 * It saves the user erasing more than he expected!
+	 */
+	if (opts->length % meminfo->erasesize) {
+		printf("ERROR: erase length is not block aligned (0x%x)\n",
+			meminfo->erasesize);
+		return -1;
+	}
+	if (opts->offset % meminfo->erasesize) {
+		printf("ERROR: erase address is not block aligned (0x%x)\n",
+			meminfo->erasesize);
+		return -1;
+	}
+
 	memset(&erase, 0, sizeof(erase));
 
 	erase.mtd = meminfo;
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index e98e50a..b2beaad 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -5,6 +5,7 @@
  *
  * 2002-07-28 - rjones@nexus-tech.net - ported to ppcboot v1.1.6
  * 2003-03-10 - kharris@nexus-tech.net - ported to uboot
+ * 2010-08-11 - Sean.McGoogan@st.com - added invalid_cluster()
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -33,6 +34,32 @@
 
 #if defined(CONFIG_CMD_FAT)
 
+
+/*
+ * return TRUE if cluster number is "invalid", i.e.
+ * out of range for "normal" data clusters.
+ * Note, the upper range depends on the FAT size (12,16,32).
+ */
+static inline int
+invalid_cluster(const fsdata * const mydata, const __u32 cluster)
+{
+	int result;
+
+	result = cluster <= 0x00000001ul ||
+		 cluster >= ((mydata->fatsize==32) ? 0x0ffffff0ul :
+			     (mydata->fatsize==16) ? 0x0000fff0ul :
+			     /* else, for FAT12 */   0x00000ff0ul);
+
+#if 0
+	printf("info: with FAT%2u, cluster=0x%06x is %s\n",
+		mydata->fatsize,
+		cluster,
+		result ? "INVALID!!!" : "okay.");
+#endif
+
+	return result;
+}
+
 /*
  * Convert a string to lowercase.
  */
@@ -357,7 +384,7 @@ get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
 			newclust = get_fatent(mydata, endclust);
 			if((newclust -1)!=endclust)
 				goto getit;
-			if (newclust <= 0x0001 || newclust >= 0xfff0) {
+			if (invalid_cluster(mydata, newclust)) {
 				FAT_DPRINT("curclust: 0x%x\n", newclust);
 				FAT_DPRINT("Invalid FAT entry\n");
 				return gotsize;
@@ -392,7 +419,7 @@ getit:
 		filesize -= actsize;
 		buffer += actsize;
 		curclust = get_fatent(mydata, endclust);
-		if (curclust <= 0x0001 || curclust >= 0xfff0) {
+		if (invalid_cluster(mydata, curclust)) {
 			FAT_DPRINT("curclust: 0x%x\n", curclust);
 			FAT_ERROR("Invalid FAT entry\n");
 			return gotsize;
@@ -464,7 +491,7 @@ get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
 
 		slotptr--;
 		curclust = get_fatent(mydata, curclust);
-		if (curclust <= 0x0001 || curclust >= 0xfff0) {
+		if (invalid_cluster(mydata, curclust)) {
 			FAT_DPRINT("curclust: 0x%x\n", curclust);
 			FAT_ERROR("Invalid FAT entry\n");
 			return -1;
@@ -657,7 +684,7 @@ static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
 	    return retdent;
 	}
 	curclust = get_fatent (mydata, curclust);
-	if (curclust <= 0x0001 || curclust >= 0xfff0) {
+	if (invalid_cluster(mydata, curclust)) {
 	    FAT_DPRINT ("curclust: 0x%x\n", curclust);
 	    FAT_ERROR ("Invalid FAT entry\n");
 	    return NULL;
diff --git a/include/asm-sh/ecc.h b/include/asm-sh/ecc.h
index 014601c..ad78373 100644
--- a/include/asm-sh/ecc.h
+++ b/include/asm-sh/ecc.h
@@ -117,6 +117,9 @@
 #ifndef ECC_H
 #define ECC_H
 
+/* Parity look up table (number of ones in a byte) */
+extern const unsigned char ecc_bit_count_table[256];
+
 /* The ECC algorithms support three different data sizes. */
 enum ecc_size
 {
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index bc30c5a..e8bb74b 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -70,6 +70,7 @@
        defined(CONFIG_SH_CB102)		|| \
        defined(CONFIG_SH_MB837)		|| \
        defined(CONFIG_SH_HDK7108)	|| \
+       defined(CONFIG_SH_MB903)		|| \
        defined(CONFIG_SH_FLI7510)	|| \
        defined(CONFIG_SH_FLI7540)	|| \
        defined(CONFIG_SH_MB796)		|| \
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
index 6b27488..0023ef8 100644
--- a/include/asm-sh/soc.h
+++ b/include/asm-sh/soc.h
@@ -97,6 +97,7 @@ struct stx7108_ethernet_config
  */
 extern int  stmac_default_pbl (void);
 extern void stmac_set_mac_speed (int speed);
+extern void stmac_phy_reset (void);
 
 
 /*
@@ -168,12 +169,22 @@ extern void fli7540_usb_init(const int port, const enum fli7540_usb_ovrcur_mode
 
 
 /*
+ * SPI initialization functions.
+ */
+extern void		stx7108_configure_spi(void);
+
+
+/*
  * Software "bit-banging" functions for SPI accesses.
  */
 extern void		stx7105_spi_scl(const int val);
 extern void		stx7105_spi_sda(const int val);
 extern unsigned char	stx7105_spi_read(void);
 
+extern void		stx7108_spi_scl(const int val);
+extern void		stx7108_spi_sda(const int val);
+extern unsigned char	stx7108_spi_read(void);
+
 extern void		stx7111_spi_scl(const int val);
 extern void		stx7111_spi_sda(const int val);
 extern unsigned char	stx7111_spi_read(void);
diff --git a/include/asm-sh/stx7108reg.h b/include/asm-sh/stx7108reg.h
index 7ee5b37..029c034 100644
--- a/include/asm-sh/stx7108reg.h
+++ b/include/asm-sh/stx7108reg.h
@@ -197,8 +197,12 @@
 
 /*----------------------------------------------------------------------------*/
 
-/* STx7108 System Configuration "accessors" */
-#define STX7108_BANK0_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK0_BASE + 0x04 + (x)*0x4)
+/*
+ * STx7108 System Configuration "accessors"
+ *
+ * Note: for Bank#0, there are no SYSCFG9, SYSCFG10, nor SYSCFG11 registers!
+ */
+#define STX7108_BANK0_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK0_BASE + 0x04 + (((x)>8)?(x)-3:(x))*0x4)
 #define STX7108_BANK1_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK1_BASE + 0x3c + (x)*0x4)
 #define STX7108_BANK2_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK2_BASE + 0x00 + (x)*0x4)
 #define STX7108_BANK3_SYSGFG(x)		SH4_DWORD_REG(STX7108_SYSCONF_BANK3_BASE + 0x18 + (x)*0x4)
diff --git a/include/configs/5197cab.h b/include/configs/5197cab.h
index 256f4f0..fa02115 100644
--- a/include/configs/5197cab.h
+++ b/include/configs/5197cab.h
@@ -260,6 +260,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif
 
 #endif	/* __CONFIG_H */
diff --git a/include/configs/eud7141.h b/include/configs/eud7141.h
index 171b0a2..6907326 100644
--- a/include/configs/eud7141.h
+++ b/include/configs/eud7141.h
@@ -158,7 +158,7 @@
 	 * has *not* been tested, as no suitable H/W was
 	 * provided to use with the supplied 7141EUD board.
 	 * The GMAC #0 functionally is provided only on a
-	 * "best-endeavours" basis. Also, phy_reset() will
+	 * "best-endeavours" basis. Also, stmac_phy_reset() will
 	 * need to be modified to reset the external PHY!
 	 */
 #	define CFG_STM_STMAC_BASE	 CFG_STM_STMAC0_BASE	/* MAC = STM GMAC#0 */
@@ -361,6 +361,7 @@
 #	endif /* if CFG_ENV_SIZE < 0x20000 */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/fldb.h b/include/configs/fldb.h
index de541dd..893d8f0 100644
--- a/include/configs/fldb.h
+++ b/include/configs/fldb.h
@@ -413,6 +413,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
@@ -455,7 +456,7 @@
 #if defined(CONFIG_CMD_I2C)
 #	define CONFIG_I2C_BUS_2			/* Use I2C Bus "2" */
 #	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
-#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
 #	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
 #	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
 #	define I2C_ACTIVE			/* open-drain, nothing to do */
diff --git a/include/configs/fudb.h b/include/configs/fudb.h
index 962adff..5fc6698 100644
--- a/include/configs/fudb.h
+++ b/include/configs/fudb.h
@@ -368,6 +368,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
@@ -397,7 +398,7 @@
 #if defined(CONFIG_CMD_I2C)
 #	define CONFIG_I2C_BUS_2			/* Use I2C Bus "2" */
 #	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
-#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
 #	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
 #	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
 #	define I2C_ACTIVE			/* open-drain, nothing to do */
diff --git a/include/configs/hdk5289.h b/include/configs/hdk5289.h
index 41e5e2c..24d4601 100644
--- a/include/configs/hdk5289.h
+++ b/include/configs/hdk5289.h
@@ -37,13 +37,25 @@
 /*-----------------------------------------------------------------------
  *	Switch settings to select between the SoC's main 3 boot-modes:
  *		a) boot from 16-bit NOR flash
- *		b) boot from 8-bit NAND flash, small-page, long address
+ *		b) boot from 8-bit NAND flash, large-page, long address
  *		c) boot from SPI serial flash
  *
- *	Board	Switch	NOR	NAND	SPI	Mode
- *	-----	------	---	----	---	----
+ *	Switch	NOR	NAND	SPI	Mode
+ *	------	---	----	---	----
+ *	JE1-2	X	ON	X	MODE[11]
+ *	JE1-1	X	off	X	MODE[10]
+ *
+ *	JE2-2	ON	off	X	MODE[13]
+ *	JE2-1	X	X	off	MODE[12]
+ *
+ *	JE3-2	ON	off	ON	MODE[16]
+ *	JE3-1	ON	ON	off	MODE[15]
+ *
+ *	JH1	NORTH	SOUTH	SOUTH	Swap CSA and CSB
  *
  *	Note: "X" denotes don't care (i.e. either ON or OFF)
+ *
+ *	Note: "NORTH" and "SOUTH" denotes board orientation with LEDs facing user.
  */
 
 
@@ -68,21 +80,15 @@
  * Assume we run out of uncached memory for the moment
  */
 
-#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI, so *DO* swap CSA and CSB in EPLD */
-//QQQ #define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
-//QQQ #define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
-//QQQ #define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
-//QQQ #define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSB */
-#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
-	/*
-	 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
-	 * If so, then who takes responsibility for this???
-	 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
-	 * Should U-Boot read SW8(1) on the MB705, and do something?
-	 */
-//QQQ #define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
-//QQQ #define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
-//QQQ #define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI, so *DO* swap CSA and CSB */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSB */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND, so *DO* swap CSA and CSB */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
 #else		/* else, do *NOT* swap CSA and CSB in EPLD */
 #define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
 #define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
@@ -392,7 +398,6 @@
 #if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
 #	define CONFIG_SPI_FLASH_WINBOND		/* Winbond W25Q64V (UG1) */
 #	define CONFIG_SPI			/* enable the SPI driver */
-//#	define CONFIG_CMD_SPI			/* SPI serial bus command support - NOT with FSM! */
 #	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
 #	define CFG_I2C_FRAM			/* to minimize performance degradation */
 #	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
@@ -400,6 +405,7 @@
 	/* Can only use H/W FSM SPI Controller (not H/W SSC, nor S/W "bit-banging") */
 #	define CONFIG_STM_FSM_SPI		/* Use the H/W FSM for SPI */
 #	define CFG_STM_SPI_FSM_BASE	0xfe702000	/* FSM SPI Controller Base */
+#	undef CONFIG_CMD_SPI			/* SPI serial bus command support - NOT with FSM! */
 #endif	/* CONFIG_SPI_FLASH */
 
 /*-----------------------------------------------------------------------
@@ -424,6 +430,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/hdk7108.h b/include/configs/hdk7108.h
index f9a0a82..d4328db 100644
--- a/include/configs/hdk7108.h
+++ b/include/configs/hdk7108.h
@@ -409,6 +409,7 @@
 #	endif /* if CFG_ENV_SIZE < 0x20000 */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
@@ -451,7 +452,7 @@
 #if defined(CONFIG_CMD_I2C)
 #	define CONFIG_I2C_BUS		5	/* Use I2C Bus associated with SSC #5 */
 #	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
-#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
 #	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
 #	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
 #	define I2C_ACTIVE			/* open-drain, nothing to do */
diff --git a/include/configs/hdk7111.h b/include/configs/hdk7111.h
index a4bdd10..9c9588f 100644
--- a/include/configs/hdk7111.h
+++ b/include/configs/hdk7111.h
@@ -389,6 +389,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/ipidtv7105.h b/include/configs/ipidtv7105.h
index 311e817..c95ca42 100644
--- a/include/configs/ipidtv7105.h
+++ b/include/configs/ipidtv7105.h
@@ -359,6 +359,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
index e0cef67..444ec92 100644
--- a/include/configs/mb618.h
+++ b/include/configs/mb618.h
@@ -281,12 +281,15 @@
  * Addresss, size, & location of U-boot's Environment Sector
  */
 
-#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#if 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
 #	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
-#else
+#elif 1 && defined(CONFIG_CMD_FLASH)
 #	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
 #define CFG_ENV_SIZE		0x10000
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
index 5608dd4..223231b 100644
--- a/include/configs/mb628.h
+++ b/include/configs/mb628.h
@@ -303,12 +303,15 @@
  * Addresss, size, & location of U-boot's Environment Sector
  */
 
-#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#if 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
 #	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
-#else
+#elif 1 && defined(CONFIG_CMD_FLASH)
 #	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
 #define CFG_ENV_SIZE		0x10000
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index 0209dfb..f9a6838 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -393,15 +393,16 @@
 
 #define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
 
-#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
 #	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
-#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
 #	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/mb704.h b/include/configs/mb704.h
index 2433671..c3a6c51 100644
--- a/include/configs/mb704.h
+++ b/include/configs/mb704.h
@@ -278,6 +278,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif
 
 #endif	/* __CONFIG_H */
diff --git a/include/configs/mb796.h b/include/configs/mb796.h
index fe65517..eba1d9b 100644
--- a/include/configs/mb796.h
+++ b/include/configs/mb796.h
@@ -448,6 +448,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
diff --git a/include/configs/mb837.h b/include/configs/mb837.h
index 419b5a6..70c7f2f 100644
--- a/include/configs/mb837.h
+++ b/include/configs/mb837.h
@@ -416,6 +416,7 @@
 #	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
@@ -458,7 +459,7 @@
 #if defined(CONFIG_CMD_I2C)
 #	define CONFIG_I2C_BUS		2	/* Use I2C Bus associated with SSC #2 */
 #	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
-#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
 #	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
 #	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
 #	define I2C_ACTIVE			/* open-drain, nothing to do */
diff --git a/include/configs/mb903.h b/include/configs/mb903.h
new file mode 100644
index 0000000..b6b591a
--- /dev/null
+++ b/include/configs/mb903.h
@@ -0,0 +1,422 @@
+/*
+ * (C) Copyright 2008-2010 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ *	Switch settings to select between the SoC's main boot-modes:
+ *		a) boot from 16-bit NOR flash
+ *		b) boot from SPI serial flash
+ *
+ *	Jumper	NOR	SPI
+ *	------	---	---
+ *	SW1-4	 ON	off		MODE[5]
+ *	SW1-3	off	 ON		MODE[4]
+ *	SW1-2	 ON	off		MODE[3]
+ *	SW1-1	off	 ON		MODE[2]
+ *
+ *	Note: There is no NAND flash on the MB903.
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR Flash booting), do not define it.
+ *
+ * Note: when in boot-from-SPI, the lower 64MiB of the NOR
+ * flash is inaccessible, only the upper 64MiB is accessible.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 */
+#if defined(CFG_BOOT_FROM_SPI)			/* we are booting from SPI serial flash */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* EMI Bank #0: SPI Flash,  Physical 0x00000000 */
+#endif /* CFG_BOOT_FROM_SPI */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb903
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 245 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#define CFG_STM_ASC_BASE	ST40_ASC3_REGS_BASE	/* UART #3, on CN1 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 on-chip ST-GMACs.
+ *
+ *	GMAC #0 is connected to the MoCA Module.
+ *
+ *	GMAC #1 is connected to a on-board IC+ IP1001 PHY (U17)
+ *
+ *	Note: U-Boot does *not* support MoCA.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC0_BASE	0xfda88000ul	/* MII #0 (MoCA module) */
+#	define CFG_STM_STMAC1_BASE	0xfe730000ul	/* MII #1 (on-board, IC+ IP1001) */
+#	define CFG_STM_STMAC_BASE	CFG_STM_STMAC1_BASE
+#	define CONFIG_STMAC_IP1001	/* IC+ IP1001 (U17) */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//QQQ #define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* upper */
+#	define CFG_USB1_BASE			0xfea00000	/* lower */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB903> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* S29GL01GP: 128MiB 1024 blocks, 128KiB block size
+ * Note: in boot-from-SPI, only the upper 64MiB is accessible!
+ */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name		Manuf	Device
+ *	-----		-----	------
+ *	U48		Numonyx	M25P128
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use S/W "bit-banging" PIO (not the SSC) */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7108_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7108_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7108_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+#endif	/* CONFIG_SPI_FLASH */
+
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	if defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	endif	/* defined(CONFIG_CMD_FLASH) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+/*----------------------------------------------------------------------
+ * I2C configuration
+ */
+
+#define CONFIG_CMD_I2C				/* do we want I2C support ? */
+
+#if defined(CONFIG_CMD_I2C)
+#	define CONFIG_I2C_BUS		6	/* Use I2C Bus associated with SSC #6 */
+#	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
+#	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
+#	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
+#	define I2C_ACTIVE			/* open-drain, nothing to do */
+#	define I2C_TRISTATE			/* open-drain, nothing to do */
+#	define I2C_SCL(val)		do { stx7108_i2c_scl((val)); } while (0)
+#	define I2C_SDA(val)		do { stx7108_i2c_sda((val)); } while (0)
+#	define I2C_READ			stx7108_i2c_read()
+
+	/*
+	 * The "BOGOS" for NDELAY() may be calibrated using the
+	 * following code fragment, and measuring (using an oscilloscope)
+	 * the frequency of the I2C SCL pin, and adjusting
+	 * NDELAY_BOGOS, until the SCL is approximately 100 kHz.
+	 * (100kHz has a period of 5us + 5us).
+	 *
+	 *	printf("just toggling I2C SCL (100kHz frequency) ...\n");
+	 *	while (1)
+	 *	{
+	 *		I2C_SCL(1); NDELAY(5000);
+	 *		I2C_SCL(0); NDELAY(5000);
+	 *	}
+	 */
+#	define NDELAY_BOGOS		20	/* Empirical measurement for 1ns on MB837A */
+#	define NDELAY(ns)						\
+		do {							\
+			const unsigned n_bogo = NDELAY_BOGOS;		\
+			const unsigned n_ticks = 			\
+				((ns)<n_bogo) ? 1u : (ns)/n_bogo;	\
+			volatile unsigned n_count;			\
+			for(n_count=0; n_count<n_ticks; n_count++)	\
+				;	/* do nothing */		\
+		} while(0)
+
+	/*
+	 * Note there are 4 * I2C_DELAY per I2C clock cycle
+	 * So, 400 kHz requires an I2C delay of 625 ns.
+	 * However, this calculation only works if the S/W
+	 * overhead in I2C bit-banging is negligible - which it is not!
+	 * So, in practice, either I2C_DELAY or CFG_I2C_SPEED will be lower.
+	 * The higher the clock frequency, the greater the difference.
+	 * Empirical measurement/adjustment is recommended.
+	 */
+#	define CFG_I2C_SPEED	400000				/* I2C speed (Hz) */
+#	define I2C_DELAY	do { NDELAY(625); } while (0)	/* 625 ns */
+#endif	/* CONFIG_CMD_I2C */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
index 603c72f..36799f2 100644
--- a/include/configs/pdk7105.h
+++ b/include/configs/pdk7105.h
@@ -437,6 +437,7 @@
 #	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#	undef CONFIG_CMD_ENV			/* no need for "saveenv" */
 #endif	/* CONFIG_CMD_NAND */
 
 /*----------------------------------------------------------------------
@@ -479,7 +480,7 @@
 #if defined(CONFIG_CMD_I2C)
 #	define CONFIG_I2C_BUS_C			/* Use I2C Bus "C" */
 #	define CONFIG_I2C_CMD_TREE		/* use a "i2c" root command */
-#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address	*/	/* QQQ - TO CHECK */
+#	define CFG_I2C_SLAVE		0x7F	/* I2C slave address - Bogus: master-only in U-Boot */
 #	define CONFIG_SOFT_I2C			/* I2C with S/W bit-banging	*/
 #	undef  CONFIG_HARD_I2C			/* I2C withOUT hardware support	*/
 #	define I2C_ACTIVE			/* open-drain, nothing to do */
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 4ba5cd2..184c885 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -90,7 +90,7 @@ struct region_info_user {
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
 
 #define MTD_NANDECC_MAX_OOBFREE	16	/* 16 for STMicroelectronics STi7xxx */
-#define MTD_NANDECC_MAX_ECCPOS	48	/* 48 for STMicroelectronics STi7xxx */
+#define MTD_NANDECC_MAX_ECCPOS	64	/* 64 for STMicroelectronics "Boot-Mode+B" (3+1/128) */
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 95f2bd1..fb69a7b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -460,6 +460,9 @@ struct nand_bbt_descr {
 #define NAND_BBT_SAVECONTENT	0x00002000
 /* Search good / bad pattern on the first and the second page */
 #define NAND_BBT_SCAN2NDPAGE	0x00004000
+/* Handle STMicroelectronics H/W ECC schemes (boot-mode, AFM4) */
+#define NAND_BBT_SCANSTMBOOTECC	0x00010000
+#define NAND_BBT_SCANSTMAFMECC	0x00020000
 
 /* The maximum number of blocks to scan for a bbt */
 #define NAND_BBT_SCAN_MAXBLOCKS 4
diff --git a/lib_sh/board.c b/lib_sh/board.c
index 2e8d30b..9b2397b 100644
--- a/lib_sh/board.c
+++ b/lib_sh/board.c
@@ -381,17 +381,13 @@ void hang (void)
 static void sh_reset (void) __attribute__ ((noreturn));
 static void sh_reset (void)
 {
-#if 1
+#if defined(CONFIG_CPU_SUBTYPE_SH4_2XX)		/* SH4-200 series */
 	/*
 	 * We will use the on-chip watchdog timer to force a
 	 * power-on-reset of the device.
 	 * A power-on-reset is required to guarantee all SH4-200 cores
 	 * will reset back into 29-bit mode, if they were in SE mode.
-	 * However, on SH4-300 series parts, issuing a TRAP instruction
-	 * with SR.BL=1 is sufficient. However, we will use a "one size fits
-	 * all" solution here, and use the watchdog for all SH parts.
 	 */
-
 		/* WTCNT          = FF	counter to overflow next tick */
 	*ST40_CPG_WTCNT = 0x5AFF;
 
@@ -403,19 +399,23 @@ static void sh_reset (void)
 		/* WTCSR.RSTS     = 0	enable power-on reset */
 		/* WTCSR.CKS[2:0] = 2	clock division ratio 1:128 */
 		/* NOTE: we need CKS to be big enough to allow
-		 * U-boot to disable the watchdog, AFTER the reset,
+		 * U-Boot to disable the watchdog, AFTER the reset,
 		 * otherwise, we enter an infinite-loop of resetting! */
 	*ST40_CPG_WTCSR = 0xA5C2;
-
-	/* wait for H/W reset to kick in ... */
-	for (;;);
-#else
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_3XX)	/* SH4-300 series */
+	/*
+	 * However, on SH4-300 series parts, issuing a TRAP instruction
+	 * with SR.BL=1 should always be sufficient.
+	 */
 	ulong sr;
 	asm ("stc sr, %0":"=r" (sr));
-	sr |= (1 << 28);	/* set block bit */
+	sr |= (1 << 28);	/* set block bit, SR.BL=1 */
 	asm ("ldc %0, sr": :"r" (sr));
 	asm volatile ("trapa #0");
 #endif
+
+	/* wait for H/W reset to kick in ... */
+	for (;;);
 }
 
 
diff --git a/lib_sh/sh_linux.c b/lib_sh/sh_linux.c
index 8875288..7b5b47d 100644
--- a/lib_sh/sh_linux.c
+++ b/lib_sh/sh_linux.c
@@ -30,6 +30,7 @@
 #include <asm/sh4reg.h>
 #include <asm/addrspace.h>
 #include <asm/pmb.h>
+#include <asm/soc.h>
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
@@ -292,6 +293,34 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 	/* Invalidate both instruction and data caches */
 	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_ICI);
 
+#if 0
+	/*
+	 * In order to measure boot-times reasonably accurately,
+	 * it is desirable to toggle some pin/signal to indicate
+	 * that the period we wish to measure has started and
+	 * terminated. We can then attach some probes from a
+	 * digital oscilloscope (or logic analyser) and measure
+	 * the time between the two transitions.
+	 *
+	 * In the case of measuring the time for U-Boot from "reset"
+	 * to "ready to pass control to linux", then *now* would be a
+	 * good opportunity to toggle a PIO pin to indicate that
+	 * we can stop measuring time. We ideally want to do this
+	 * before we irretrievably "damage" the PMB configuration.
+	 *
+	 * In this case, we call stmac_phy_reset() before retuning
+	 * to the caller. It should be noted that although we are calling
+	 * stmac_phy_reset(), our intention is *not* to reset the PHY,
+	 * but it is purely to effect a transition on a pin that we can
+	 * easily add a probe to. The fact that the PHY has been reset
+	 * is just be a benign by-product of this "signalling" mechanism.
+	 */
+	stmac_phy_reset();
+	printf("info: Not passing control to linux "
+		"- just called stmac_phy_reset() instead!\n");
+	return;
+#endif
+
 #ifdef CONFIG_SH_SE_MODE
 	/*
 	 * Before we can jump into the kernel, we need to invalidate all
diff --git a/sh_config.mk b/sh_config.mk
index ed27c1d..5c2d77f 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2010-07-07\""
+SH_IDENT_STRING="\"stm23-2010-08-17\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
