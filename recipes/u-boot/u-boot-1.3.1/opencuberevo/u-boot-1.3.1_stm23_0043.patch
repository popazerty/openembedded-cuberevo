diff --git a/MAKEALL b/MAKEALL
index 383c14a..931ea5e 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -680,6 +680,8 @@ LIST_sh="		\
 	mb671se		\
 	mb680		\
 	mb680se		\
+	pdk7105		\
+	pdk7105se	\
 	cb101		\
 	cb101se		\
 	cb102		\
diff --git a/Makefile b/Makefile
index f569360..24e239d 100644
--- a/Makefile
+++ b/Makefile
@@ -2745,7 +2745,7 @@ mb628se_config :		unconfig
 	$(if $(findstring se,$@), \
 	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb628/config.tmp)
+	@echo "TEXT_BASE = 0x83900000" >$(obj)board/mb628/config.tmp)
 	@./mkconfig -a mb628 sh sh mb628 "" stx7141
 
 mb671_config \
@@ -2770,6 +2770,17 @@ mb680se_config :		unconfig
 	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb680/config.tmp)
 	@./mkconfig -a mb680 sh sh mb680 "" stx7105
 
+pdk7105_config \
+pdk7105se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7105   1" >>include/config.h
+	@echo "#define CONFIG_SH_PDK7105   1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
+	@./mkconfig -a pdk7105 sh sh pdk7105 "" stx7105
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
diff --git a/board/cb101/Makefile b/board/cb101/Makefile
index ff0f69a..219443a 100644
--- a/board/cb101/Makefile
+++ b/board/cb101/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/cb101/sconsole.c b/board/cb101/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/cb101/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/cb101/sconsole.h b/board/cb101/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/cb101/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/cb102/Makefile b/board/cb102/Makefile
index 1f1f703..70041dd 100644
--- a/board/cb102/Makefile
+++ b/board/cb102/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/cb102/sconsole.c b/board/cb102/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/cb102/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/cb102/sconsole.h b/board/cb102/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/cb102/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/cb103/cb103.romgen b/board/cb103/cb103.romgen
new file mode 100644
index 0000000..5a1c8b7
--- /dev/null
+++ b/board/cb103/cb103.romgen
@@ -0,0 +1,1580 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016c0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e04402b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006c0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e175c6b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1e179572) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x002ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x002ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x980001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x87b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x180001ed)
+/* PEEK(0xfd70412c) (used target peek value 0x080006a1) */
+/* PEEK(0xfd704130) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704134) (used target peek value 0x00020000) */
+/* PEEK(0xfd704138) (used target peek value 0x00000000) */
+/* PEEK(0xfd70413c) (used target peek value 0x08000001) */
+/* PEEK(0xfd704140) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704144) (used target peek value 0x00020000) */
+/* PEEK(0xfd704148) (used target peek value 0x00000000) */
+/* PEEK(0xfd704198) (used target peek value 0x002ffd08) */
+/* PEEK(0xfd70419c) (used target peek value 0x002ffd18) */
+/* PEEK(0xfd7041a8) (used target peek value 0x07b7dbed) */
+/* PEEK(0xfd7041ac) (used target peek value 0x980001ed) */
+/* PEEK(0xfd7041b0) (used target peek value 0x87b7dbed) */
+/* PEEK(0xfd7041b4) (used target peek value 0x180001ed) */
+/* PEEK(0xfd7041cc) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d0) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d4) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d8) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041dc) (used target peek value 0x07fc0284) */
+/* PEEK(0xfd7041e0) (used target peek value 0x07fc0284) */
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/cb103/init-cb103.S b/board/cb103/init-cb103.S
new file mode 100644
index 0000000..5a1b661
--- /dev/null
+++ b/board/cb103/init-cb103.S
@@ -0,0 +1,75 @@
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:cb103:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "cb103" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "cb103.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/hms1/Makefile b/board/hms1/Makefile
index c2c83a3..08e99d9 100644
--- a/board/hms1/Makefile
+++ b/board/hms1/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-hms1.o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/hms1/sconsole.c b/board/hms1/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/hms1/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/hms1/sconsole.h b/board/hms1/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/hms1/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb411/Makefile b/board/mb411/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb411/Makefile
+++ b/board/mb411/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb411/sconsole.c b/board/mb411/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb411/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb411/sconsole.h b/board/mb411/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb411/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb442/Makefile b/board/mb442/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb442/Makefile
+++ b/board/mb442/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb442/sconsole.c b/board/mb442/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb442/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb442/sconsole.h b/board/mb442/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb442/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb448/Makefile b/board/mb448/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb448/Makefile
+++ b/board/mb448/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb448/sconsole.c b/board/mb448/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb448/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb448/sconsole.h b/board/mb448/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb448/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb519/Makefile b/board/mb519/Makefile
index 1f1f703..70041dd 100644
--- a/board/mb519/Makefile
+++ b/board/mb519/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb519/sconsole.c b/board/mb519/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb519/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb519/sconsole.h b/board/mb519/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb519/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb618/Makefile b/board/mb618/Makefile
index ff0f69a..219443a 100644
--- a/board/mb618/Makefile
+++ b/board/mb618/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
index 273f471..1cc7e31 100644
--- a/board/mb618/init-mb618.S
+++ b/board/mb618/init-mb618.S
@@ -156,9 +156,6 @@ __memory_setup_table:
 
 	/* ----- STX7111 EMI configuration ----- */
 
-//#define APRIL_2008_FILES	/* Define if using targetpacks from April'08 vintage */
-#ifdef APRIL_2008_FILES
-
 	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
 
 	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
@@ -203,46 +200,6 @@ __memory_setup_table:
 	/* Program other EMI registers */
 	POKE32(ST40_EMI_GENCFG, 0x00000010)
 
-#else	/* else, pre- APRIL_2008_FILES */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000012)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - Not configured */
-
-	/* Bank 2 - 16MiB DVB-CI at address 0x03000000 -> 0x03FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 3 - EPLD Registers at address 0x04000000 -> 0x04FFFFFF */
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - 8MiB STEM at address 0x04800000 -> 0x04ffffff */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000000)
-#endif	/* APRIL_2008_FILES */
 
 	/* ----- STX7111 LMI0 configuration ----- */
 
@@ -393,8 +350,11 @@ __memory_setup_table:
 	 */
 	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
 	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(), 0x48000a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(), 0x48000a00)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 128Mbytes=0x48000000, 13x10
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/mb618/sconsole.c b/board/mb618/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb618/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb618/sconsole.h b/board/mb618/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb618/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb628/Makefile b/board/mb628/Makefile
index ff0f69a..219443a 100644
--- a/board/mb628/Makefile
+++ b/board/mb628/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb628/config.mk b/board/mb628/config.mk
index 9e31df5..c23d067 100644
--- a/board/mb628/config.mk
+++ b/board/mb628/config.mk
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2008 STMicroelectronics.
+# (C) Copyright 2008-2009 STMicroelectronics.
 # Sean McGoogan <Sean.McGoogan@st.com>
 #
 # See file CREDITS for list of people who contributed to this
@@ -24,10 +24,23 @@
 #
 # MB628 board:
 #
+#	Following are *Physical* Addresses:
+#
+#	Region		29-bit		32-bit		Size
+#	------		------		------		----
+#	LMI_BASE	0x0c000000	0x40000000	128MiB
+#	VIDEO_BASE	0x0c000000	0x40000000	  4MiB
+#	AUDIO_BASE	0x0c400000	0x40400000	  4MiB
+#	eSTB_BASE	0x0c800000	0x40800000	 50MiB
+#	eSTB_END	0x0f9fffff	0x439fffff	   ---
+#
+#
+#	Following are *Virtual* Addresses:
+#
 #	Valid values for TEXT_BASE are:
 #
-#	0x8F700000	29-bit mode (Traditional Mode)
-#	0x87F00000	32-bit mode (Space-Enhancement Mode)	QQQ
+#	0x8F900000	29-bit mode (Traditional Mode)
+#	0x83900000	32-bit mode (Space-Enhancement Mode)
 #
 # Note:	Alternative definitions of TEXT_BASE are put into
 #	'config.tmp' from the top-level 'Makefile'.
@@ -36,8 +49,8 @@
 sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
 
 ifndef TEXT_BASE
-# Installs at eSTB BASE + 47MB in P1 (cachable)
-TEXT_BASE = 0x8F700000
+# Installs at eSTB BASE + 49MB in P1 (cachable)
+TEXT_BASE = 0x8F900000
 endif
 
 PLATFORM_LDFLAGS +=
diff --git a/board/mb628/init-mb628.S b/board/mb628/init-mb628.S
index b315e05..9f65bb5 100644
--- a/board/mb628/init-mb628.S
+++ b/board/mb628/init-mb628.S
@@ -29,15 +29,43 @@
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-/* QQQ - TO DO */
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb628:estb
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb628" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb628.romgen"
 
 #ifdef CONFIG_SH_SE_MODE
-#error QQQ
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/mb628/mb628.c b/board/mb628/mb628.c
index 71e7c20..0a72207 100644
--- a/board/mb628/mb628.c
+++ b/board/mb628/mb628.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -31,7 +31,7 @@
 
 /* EPLD registers */
 #ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb5000000	/* Phys 0x05050000 */
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
 #else
 #define EPLD_BASE		0xa5000000
 #endif	/* CONFIG_SH_SE_MODE */
diff --git a/board/mb628/mb628.romgen b/board/mb628/mb628.romgen
new file mode 100644
index 0000000..6b96f99
--- /dev/null
+++ b/board/mb628/mb628.romgen
@@ -0,0 +1,2423 @@
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80003805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80103805)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00183805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80104a05)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
+*/
+POKE32(0xfe213a14, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa55aa)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a14) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b0c) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x081b06a1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+/* PEEK(0xfe00113c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+POKE32(0xfe00113c, 0x081b0001)
+DELAY(200)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG16
+*/
+POKE32(0xfe001140, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x000f000c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG39
+*/
+POKE32(0xfe00119c, 0x000f0014)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG17
+*/
+POKE32(0xfe001144, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG18
+*/
+POKE32(0xfe001148, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x0800239e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG37
+*/
+POKE32(0xfe001194, 0x0800039e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG44
+*/
+POKE32(0xfe0011b0, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG45
+*/
+POKE32(0xfe0011b4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG53
+*/
+POKE32(0xfe0011d4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG54
+*/
+POKE32(0xfe0011d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x14001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x14001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xac000000, 0x00000000)
+POKE32(0xac000000, 0xaaaaaaaa)
+/* PEEK(0xac000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xac001000, 0x00000000)
+POKE32(0xac001000, 0x55555555)
+/* PEEK(0xac001000) (used target peek value 0x55555555) */
+POKE32(0xac002000, 0x00000000)
+POKE32(0xac002000, 0x12345678)
+/* PEEK(0xac002000) (used target peek value 0x12345678) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90200c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe902018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90201c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe902030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe902038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe902028, 0x00000000)
+POKE32(0xb4000000, 0x00000000)
+POKE32(0xb4000000, 0xaaaaaaaa)
+/* PEEK(0xb4000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb4001000, 0x00000000)
+POKE32(0xb4001000, 0x55555555)
+/* PEEK(0xb4001000) (used target peek value 0x55555555) */
+POKE32(0xb4002000, 0x00000000)
+POKE32(0xb4002000, 0x12345678)
+/* PEEK(0xb4002000) (used target peek value 0x12345678) */
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+POKE32(0xfd103024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe209000, 0x00000013)
+POKE32(0xfe209004, 0x00000003)
+POKE32(0xfe209008, 0x00000000)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x080b1000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+POKE32(0xfd11f000, 0x0025c608)
+POKE32(0xfd119000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000011)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000000)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a091)
+DELAY(360000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a091) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a891)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a891) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a811)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008013)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x10000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x18000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
diff --git a/board/mb628/sconsole.c b/board/mb628/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb628/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb628/sconsole.h b/board/mb628/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb628/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb671/Makefile b/board/mb671/Makefile
index 1f1f703..70041dd 100644
--- a/board/mb671/Makefile
+++ b/board/mb671/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
index 2fd9536..89c6597 100644
--- a/board/mb671/init-mb671.S
+++ b/board/mb671/init-mb671.S
@@ -1,4 +1,3 @@
-
 #include "asm/stx7200reg.h"
 #include "../../cpu/sh/init_ram.S"
 
@@ -10,12 +9,11 @@
 /*
  * The poke table is a series of long words, in the format
  *
- *       opcode, address, operand, ...
+ *	opcode, address, operand, ...
  *
  * An opcode of 0 marks the table end
  */
 
-#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
 /*
  * For compatibility with old poke table code, we define some of the
  * new names, to map onto the old names. Ultimately, the old poke table
@@ -30,420 +28,31 @@
 #define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-	/* ----- STx7200 Clocks ----- */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-	ELSE(1)
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL2 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL2... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
-
-	/* Configure CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
-
-	/* Wait for CLOCKGENA PLL2 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
-
-	/* Clear CLOCKGENA PLL2 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENB PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENB PLL0... */
-	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
-
-	/* Configure CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
-
-	/* Wait for CLOCKGENB PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENB PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
-
-	/* Power down PLL... */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
-
-	/* Configure PLL... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  /* On cut 2 set LMI clock to 800MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
-	ELSE(1)
-	  /* For cut 1 */
-	  IF_EQ32(2, 0xa5020000, 0x000000ff, 0x0000000a)
-	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
-	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
-	  ELSE(2)
-	    /* Set LMI clock to 666MHz */
-	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-	  ENDIF(2)
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	    /* on cut 1, set LMI clock to 666MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
-	  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  /* On cut 2, set LMI clock to 800MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ELSE(1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* ----- STx7200 Sysconf ----- */
-
-	/* PLI_CLOCK_ENABLE set to 0 */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
-	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Check both DLL on LMI1 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
-	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
-
-	/* Force DLL1 and DLL2 command of LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
-
-	/* Force DLL1 and DLL2 command of LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
-
-	/* Set cfg55 and cfg56 */
-	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-
-	/* PDL offsets
-	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
-	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
-	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
-	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb671:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb671" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
 	 */
-
-	/* TO BE UPDATED FOR 7200/MB671 */
-	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
-
-	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
-
-	/* ----- STx7200 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000050)
-
-	/* ----- STx7200 LMI0 configuration ----- */
-
-	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
-
-	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
-
-	/* ----- STx7200 LMI1 configuration ----- */
-
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
-
-	/* SDRAM Timing Register */
-	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
-
-	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
-
-	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+#include "mb671.romgen"
 
 #ifdef CONFIG_SH_SE_MODE
 	/*
diff --git a/board/mb671/mb671.romgen b/board/mb671/mb671.romgen
new file mode 100644
index 0000000..17b91e0
--- /dev/null
+++ b/board/mb671/mb671.romgen
@@ -0,0 +1,1572 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f10e795) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+/* PEEK(0xfd70413c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f13ef95) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1f1bd47a) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x000ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x000ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x000001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x000001ed)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/mb671/sconsole.c b/board/mb671/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb671/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb671/sconsole.h b/board/mb671/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb671/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb680/Makefile b/board/mb680/Makefile
index ff0f69a..219443a 100644
--- a/board/mb680/Makefile
+++ b/board/mb680/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb680/init-mb680.S b/board/mb680/init-mb680.S
index 21a4d67..811b362 100644
--- a/board/mb680/init-mb680.S
+++ b/board/mb680/init-mb680.S
@@ -29,340 +29,34 @@
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-	/* ----- STx7105 Clocks ----- */
-
-	/* Set source clocks to OSC */
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0x00000000)
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x00000000)
-
-	/* Wait for CLOCKGENA PLL0 to stop ... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL0_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
-
-	/* Wait for CLOCKGENA PLL1 to stop ... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL1_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
-
-	/*  Clockgen A PLL0 setup */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-	OR32(STX7105_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0LS to 450MHz (PLL0HS to 900MHz): mdiv = 0x01, ndiv = 0x0f */
-	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/*  Clockgen A PLL1 setup */
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-	OR32(STX7105_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1 to 800MHz: mdiv = 0x03, ndiv = 0x28, pdiv = 0x0 */
-	/* UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (0 << 16) | (0x28 << 8) | (0x03)) */
-	/* Configure CLOCKGENA PLL1 to 400MHz: mdiv = 0x09, ndiv = 0x78, pdiv = 0x1 */
-	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (1 << 16) | (0x78 << 8) | (0x09))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-
-	/*  Clockgen A divider setup */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)    /* STNOC=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV1_CFG, 0x00000000)    /* FDMA0=400 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV2_CFG, 0x00000000)    /* FDMA1=400 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)    /* Not used */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)  /* ST40_ICK=450 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV5_CFG, 0x00000103)    /* IC_IF_100=100  - for Comms */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)  /* LX_DMU_CPU=450 */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)  /* LX_AUD_CPU=450 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV8_CFG, 0x00000001)    /* IC_BDISP_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV9_CFG, 0x00000001)    /* IC_DISP_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV10_CFG, 0x00000001)   /* IC_TS_200=200  - for Crypto */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV11_CFG, 0x00000001)   /* DISP_PIPE_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV12_CFG, 0x00000001)   /* BLIT_PROC/IC_DELTA_200=266 */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811) /* ETH_PHY=25 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)   /* PCI=33.3 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV15_CFG, 0x00000103)   /* EMI_MASTER=100 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV16_CFG, 0x00000001)   /* IC_COMPO_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV17_CFG, 0x00000001)   /* IC_IF_200=200 */
-
-	/* Route clocks to ... */
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
-
-	/* SPI.CLOCK_DIV: divide emi_master_clk by 4 for spi boot clock */
-	POKE32(0xfe702010, 0x00000004)
-
-	/* ClockGen B for Audio */
-	/*  No setup            */
-
-
-	/* ClockGen D for LMI */
-
-	/* Power down PLL... */
-	OR32(STX7105_SYSCONF_SYS_CFG11, 0x00001000)
-
-	/* Configure PLL... */
-	/* Set LMI clock to 800MHz */
-	/* UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1)) */
-	/* Cut 1.0 restriction -> Set LMI clock to 400MHz */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
-	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, 0x00000001, 0)
-
-
-	/* ----- STx7105 SysConf ----- */
-
-	/* PLI_CLOCK_ENABLE set to 0 */
-	/* OR32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2))	- Steve Punter misinterpretted? */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2), 0)
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7105_SYSCONF_SYS_CFG11, (0x00000001 | (1 << 14) | 1 << 27))
-
-	/* Delay ~ 200 microseconds (assume 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7105_SYSCONF_SYS_CFG04, (1 << 2))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7105_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7105_SYSCONF_SYS_CFG38, 0x002FFE0C)
-
-	/* Force DLL1 and DLL2 commands of LMI0 */
-	/* POKE32(STX7105_SYSCONF_SYS_CFG13, 0x00000000) */
-	/* POKE32(STX7105_SYSCONF_SYS_CFG14, 0x00000000) */
-
-	/* LMI Padlogic Control */
-	POKE32(STX7105_SYSCONF_SYS_CFG55, 0x03fc2384)
-
-	/* Include DUMMY PCB track */
-	OR32(STX7105_SYSCONF_SYS_CFG55, (1 << 6))
-
-	/* TO BE UPDATED FOR 7105/MB680 */
-	/* sysconf.SYSCONF_CFG42.poke(sysconf.SYSCONF_CFG42.peek() | (0 << 18) | (0 << 9) | (0 << 0) ) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG42, 0xfffbfdfe, 0)
-	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0) ) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffffffe, 0)
-
-	/* Coarse settings (-T/4) */
-	OR32(STX7105_SYSCONF_SYS_CFG42, (5 << 27))
-	OR32(STX7105_SYSCONF_SYS_CFG13, (1 << 22))
-
-	/* DQS Valid Window */
-	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0 << 18)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffbffff, 0)
-
-	/* DQS270_DEL offsets */
-	/* sysconf.SYSCONF_CFG51.poke(sysconf.SYSCONF_CFG51.peek() | (0 << 16) | (0 << 0)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG51, 0xfffefffe, 0)
-	/* sysconf.SYSCONF_CFG52.poke(sysconf.SYSCONF_CFG52.peek() | (0 << 16) | (0 << 0)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG52, 0xfffefffe, 0)
-
-
-	/* ----- STx7105 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001c)
-
-	/* Bank 0 - 32MiB: NOR, NAND & Serial Flash at address 0x00000000 -> 0x03ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - 8MiB at address 0x04000000 -> 0x047fffff */
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 2 - 8MiB at address 0x04800000 -> 0x04FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 3 - 32MiB at address 0x05000000 -> 0x06FFFFFF */
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - 16MiB EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000010)
-
-
-	/* ----- STx7105 LMI0 configuration ----- */
-
-	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
-
-	   SDRAM Mode Register
-	   Refresh Interval:  NOTE: Using Lmi=200 (LMI2X=400).
-	 # 300 Mhz --->  T=3.4ns => MIM[28:16]=2038=0x7F6 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
-	 # 330 Mhz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
-	 # 360 Mhz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
-	 # 400 Mhz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
-	 */
-	POKE32(ST40_LMI_MIM_0(), 0x07F6017b)
-
-	/* set bandwidth limiter */
-	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
-
-	/* SDRAM Timing Register */
-	POKE32(ST40_LMI_STR_0(), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(), 0x00202ed6)
-
-	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x0C000000 +
-	    256 MiB   0x10000000
-	              ----------
-	              0x1C000000
-	   Size: 13x10, 8 banks
-	 */
-	POKE32(ST40_LMI_SDRA0_0(), 0x1c001a20)
-
-	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x0C000000 +
-	    256 MiB   0x10000000
-	              ----------
-	              0x1C000000
-	   Size: 13x10, 8 banks
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb680:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb680" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
 	 */
-	POKE32(ST40_LMI_SDRA1_0(), 0x1c001a20)
-
-	/* SDRAM Control Register */
-	/* Delay ~ 200 milliseconds (assume 400MHz CPU clock) */
-	DELAY(200000 * 400)
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequential, Burst length 8 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 5, Sequential, Burst length 8 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
-
-	/* Issue EMRS1 for OCD calibration default */
-	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
-
-	/* Issue EMRS1 for OCD calibration exit */
-	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
-
-	/* Enable auto refresh */
-	OR32(ST40_LMI_MIM_0(), (1 << 9))
-
-	/* DQS recovery mechanism (bit 5) */
-	/* OR32(ST40_LMI_MIM_0(), (1 << 5)) - Steve Punter misinterpretted? */
-	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
-	/* NO DQS recovery */
-	/* UPDATE32(ST40_LMI_MIM_0(), 0xffffffdf, 0) */
-
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+#if 1
+#include "mb680-stx7105c2.romgen"	/* for STx7105 cut 2.x */
+#else
+#include "mb680-stx7105c1.romgen"	/* for STx7105 cut 1.x */
+#endif
 
 #ifdef CONFIG_SH_SE_MODE
 	/*
diff --git a/board/mb680/mb680-stx7105c1.romgen b/board/mb680/mb680-stx7105c1.romgen
new file mode 100644
index 0000000..e93eb56
--- /dev/null
+++ b/board/mb680/mb680-stx7105c1.romgen
@@ -0,0 +1,1653 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f032c9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000122)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000122) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000126)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f13ac9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x08091000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680-stx7105c2.romgen b/board/mb680/mb680-stx7105c2.romgen
new file mode 100644
index 0000000..fc88679
--- /dev/null
+++ b/board/mb680/mb680-stx7105c2.romgen
@@ -0,0 +1,1665 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e020380) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e161fca) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680.c b/board/mb680/mb680.c
index ed8d87a..c7cd953 100644
--- a/board/mb680/mb680.c
+++ b/board/mb680/mb680.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -36,6 +36,7 @@
  * in the STB Peripheral board (MB705)*/
 #define EPLD_IDENT		0x00	/* EPLD Identifier Register */
 #define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
 #define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
 
 #ifdef CONFIG_SH_SE_MODE
@@ -109,6 +110,21 @@ static int mb680_init_epld(void)
 	return 0;
 }
 
+#ifdef CONFIG_STMAC_LAN8700
+static void phy_reset(void)
+{
+	/* Reset the SMSC LAN8700 PHY */
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 0);
+	udelay(100);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 0);
+}
+#endif	/* CONFIG_STMAC_LAN8700 */
+
 static void configPIO(void)
 {
 	unsigned long sysconf;
@@ -143,12 +159,23 @@ static void configPIO(void)
 	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
 	sysconf |=  0x000ful;	/* 1,1,1,1 */
 	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+#ifdef CONFIG_STMAC_LAN8700
+	/* Configure SMSC LAN8700 PHY Reset signals */
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(11), 2, STPIO_OUT);
+#endif	/* CONFIG_STMAC_LAN8700 */
 }
 
 extern int board_init(void)
 {
 	configPIO();
 
+	/* Reset the PHY */
+#ifdef CONFIG_STMAC_LAN8700
+	phy_reset();
+#endif	/* CONFIG_STMAC_LAN8700 */
+
 	return 0;
 }
 
@@ -167,5 +194,19 @@ int checkboard (void)
 	 */
 	mb680_init_epld();
 
+#if 0	/* QQQ - DELETE */
+{
+const unsigned long nand_reg = *ST40_EMI_NAND_VERSION_REG;
+const unsigned long epld_reg = epld_read(EPLD_SWITCH);
+	printf ("*ST40_EMI_NAND_VERSION_REG = %u.%u.%u\n",
+		(nand_reg>>8)&0x0ful,
+		(nand_reg>>4)&0x0ful,
+		(nand_reg>>0)&0x0ful);
+	printf("*EPLD_SWITCH = 0x%08x  -->  boot-from-%s\n",
+		epld_reg,
+		(epld_reg & (1ul<<8)) ? "NAND" : "NOR");
+}
+#endif	/* QQQ - DELETE */
+
 	return 0;
 }
diff --git a/board/mb680/nand.c b/board/mb680/nand.c
index c013fe1..7abfbf6 100644
--- a/board/mb680/nand.c
+++ b/board/mb680/nand.c
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -30,14 +30,16 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 #include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
 
 
 /*
- * hardware specific access to control-lines
+ * hardware specific access to control-lines for "bit-banging".
  *	CL -> Emi_Addr(17)
  *	AL -> Emi_Addr(18)
  *	nCE is handled by EMI (not s/w controlable)
  */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
 static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
 {
 	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
@@ -61,6 +63,20 @@ static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
 		break;
 	}
 }
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int mb680_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
 
 
 /*
@@ -83,11 +99,32 @@ static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
  */
 extern int board_nand_init(struct nand_chip *nand)
 {
-	nand->hwcontrol = mb680_hwcontrol;
-	nand->eccmode = NAND_ECC_SOFT;
-	nand->chip_delay = 25;
-	nand->options = NAND_NO_AUTOINCR;
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = mb680_device_ready;
+	nand->hwcontrol     = mb680_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
 	return 0;
 }
+
+
 #endif	/* CONFIG_CMD_NAND */
 
+
diff --git a/board/mb680/sconsole.c b/board/mb680/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb680/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb680/sconsole.h b/board/mb680/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb680/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/pdk7105/Makefile b/board/pdk7105/Makefile
new file mode 100644
index 0000000..219443a
--- /dev/null
+++ b/board/pdk7105/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/pdk7105/config.mk b/board/pdk7105/config.mk
new file mode 100644
index 0000000..86ff620
--- /dev/null
+++ b/board/pdk7105/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# PDK-7105 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/pdk7105/init-pdk7105.S b/board/pdk7105/init-pdk7105.S
new file mode 100644
index 0000000..25bca4d
--- /dev/null
+++ b/board/pdk7105/init-pdk7105.S
@@ -0,0 +1,75 @@
+#include "asm/stx7105reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:sdk7105:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "sdk7105" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "pdk7105.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 512MiB=0x60000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x60000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x60000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/pdk7105/nand.c b/board/pdk7105/nand.c
new file mode 100644
index 0000000..3c2f513
--- /dev/null
+++ b/board/pdk7105/nand.c
@@ -0,0 +1,130 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void pdk7105_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int pdk7105_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = pdk7105_device_ready;
+	nand->hwcontrol     = pdk7105_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
+
+
+#endif	/* CONFIG_CMD_NAND */
+
+
diff --git a/board/pdk7105/pdk7105.c b/board/pdk7105/pdk7105.c
new file mode 100644
index 0000000..29df917
--- /dev/null
+++ b/board/pdk7105/pdk7105.c
@@ -0,0 +1,182 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 1 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 0 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 0);
+}
+
+static void configEthernet(void)
+{
+	unsigned long sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+
+	/* Set the GMAC in MII mode */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	sysconf &= ~0x060f0000ul;
+	sysconf |=  0x08010000ul;
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	/* PIO7[4] CFG37[12,4]  AltFunction = 1 */
+	/* PIO7[5] CFG37[13,5]  AltFunction = 1 */
+	/* PIO7[6] CFG37[14,6]  AltFunction = 1 */
+	/* PIO7[7] CFG37[15,7]  AltFunction = 1 */
+	sysconf &= ~0xf0f0ul;	/* 3,3,3,3,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	/* PIO8[0] CFG46[8,0]   AltFunction = 1 */
+	/* PIO8[1] CFG46[9,1]   AltFunction = 1 */
+	/* PIO8[2] CFG46[10,2]  AltFunction = 1 */
+	/* PIO8[3] CFG46[11,3]  AltFunction = 1 */
+	/* PIO8[4] CFG46[12,4]  AltFunction = 1 */
+	/* PIO8[5] CFG46[13,5]  AltFunction = 1 */
+	/* PIO8[6] CFG46[14,6]  AltFunction = 1 */
+	/* PIO8[7] CFG46[15,7]  AltFunction = 1 */
+	sysconf &= ~0xfffful;	/* 3,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	/* PIO9[0] CFG47[8,0]   AltFunction = 1 */
+	/* PIO9[1] CFG47[9,1]   AltFunction = 1 */
+	/* PIO9[2] CFG47[10,2]  AltFunction = 1 */
+	/* PIO9[3] CFG47[11,3]  AltFunction = 1 */
+	/* PIO9[4] CFG47[12,4]  AltFunction = 1 */
+	/* PIO9[5] CFG47[13,5]  AltFunction = 1 */
+	/* PIO9[6] CFG47[14,6]  AltFunction = 1 */
+	sysconf &= ~0x7f7ful;	/* 0,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+
+	/* Setup PIO for the Ethernet's MII bus */
+	SET_PIO_PIN(PIO_PORT(7),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),6,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7),7,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),0,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),1,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),2,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),3,STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8),4,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),6,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),7,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),0,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),1,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),2,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),3,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),5,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9),6,STPIO_IN);
+
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(15), 5, STPIO_OUT);
+
+	/* Finally, toggle the PHY Reset pin ("RST#") */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 0);
+	udelay(100);	/* small delay */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
+
+	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
+	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
+
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-PDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/pdk7105/pdk7105.romgen b/board/pdk7105/pdk7105.romgen
new file mode 100644
index 0000000..4c79ca4
--- /dev/null
+++ b/board/pdk7105/pdk7105.romgen
@@ -0,0 +1,2787 @@
+/* sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+ */
+/* Initialization TCK frequency set to 1562500 Hz
+ */
+/* Device id  0x1d43e041
+ */
+/* tapmux connect(): boot mode single core setup
+ */
+/* tapmux setup to bypass to core st40, channel 1
+ */
+/* sdk7105 initialization start ...
+ */
+/* sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+ */
+/* Chip infos
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+/*   Device ID = 0x1D43E041 ==> STi7105 cut 2
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+/*   Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+ */
+/*                              Boot mode ... : ST40 first
+ */
+/*                              Boot port size: 16-bits
+ */
+/*                              Boot device . : NOR flash
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f1016a4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+/* set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50
+ */
+/* Clock frequencies
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+/*   CKGA_PLL0HS     = 900.0 MHz
+ */
+/*   CKGA_PLL0LS     = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+/*   CKGA_PLL1       = 800.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+/*   ST40 ICK        = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+/*   LX DMU          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+/*   LX AUD          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+/*   FDMA0           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+/*   FDMA1           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+/*   STNOC           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+/*   IC_BDISP_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+/*   IC_DISP_200     = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+/*   IC_TS_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+/*   IC_COMPO_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+/*   IC_IF_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+/*   IC_IF_100       = 100.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+/*   DISP_PIPE_200   = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+/*   BLIT_PROC       = 266.7 MHz
+ */
+/*   IC_DELTA_200    = 266.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+/*   ETHERNET        = 25.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+/*   PCI             = 66.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+/*   EMI MASTER      = 100.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+/*   LMI2X           = 800.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200684f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200684f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200686f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200686f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00400000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002cfe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002cfe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002ffe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x20000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x20000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x28000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x28000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fb80000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fb80000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbdc00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbdc00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a00000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a00000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2280)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2280) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166c50) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166450) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001a)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242ed8)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x2c001e20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004363)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004263)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+/* Info: correcting interco reset setup
+ */
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+/* stx7105: booted audio companion
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+/* stx7105: booted video companion
+ */
+/* TCK frequency set to 12500000 Hz
+ */
+/* tapmux complete_connect(): single core setup
+ */
+/* sdk7105 initialization complete
+ */
diff --git a/board/pdk7105/u-boot.lds b/board/pdk7105/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/pdk7105/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 49cf608..0fb7229 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -2,6 +2,9 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -294,8 +297,15 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	DECLARE_GLOBAL_DATA_PTR;
-
-	int i;
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	#define MAX_EMI_BANKS	6	/* Maximum of 6 EMI Banks */
+	const u32 emi_base = 0xa0000000u;
+	u32 base[MAX_EMI_BANKS+1];	/* Base address for each bank */
+	u32 enabled;			/* number of enabled EMI banks */
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+#if defined(CONFIG_CMD_NET) || defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	unsigned int i;
+#endif
 	bd_t *bd = gd->bd;
 
 	print_num ("boot_params",	(ulong)bd->bi_boot_params);
@@ -358,6 +368,44 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	print_mhz ("EMI",		bd->bi_emifrq);
 #endif	/* CONFIG_SH_STB7100 */
 
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	enabled = *ST40_EMI_BANK_ENABLE;
+	printf("#EMI Banks  = %u\n", enabled);
+	if (enabled > MAX_EMI_BANKS)
+	{
+		printf("Error: Maximum Number of Enabled Banks should be %u\n", MAX_EMI_BANKS);
+		enabled = MAX_EMI_BANKS;
+	}
+
+	/*
+	 * EmiBaseAddress[5:0] == Address[27:22] (Multiple of 4MiB)
+	 *
+	 * Retreive all the configured EMI bank bases into base[].
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 start = *ST40_EMI_BASEADDRESS(i) & 0x3fu;
+		base[i] = emi_base + (start << (22));
+	}
+	/* last valid bank occupies all remaining space */
+	base[i] = emi_base + (128u << (20));	/* total size of EMI is 128MiB */
+
+	/*
+	 * Print out the ranges of each bank.
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 lower = base[i];
+		const u32 upper = base[i+1];
+		printf ("EMI #%u CS%c  = 0x%08X ... 0x%08X (",
+			i,
+			'A' + i,
+			lower,
+			upper-1u);
+		print_size (upper-lower, ")\n");
+	}
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+
 	return 0;
 }
 
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
index 71308cc..b66a274 100644
--- a/cpu/sh/Makefile
+++ b/cpu/sh/Makefile
@@ -26,7 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	= lib$(CPU).a
 
 START	= start.o
-OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
+OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o ecc.o stm-nand.o
 SOBJS	=
 
 all:	.depend $(START) $(LIB)
diff --git a/cpu/sh/ecc.c b/cpu/sh/ecc.c
new file mode 100644
index 0000000..1f17e8c
--- /dev/null
+++ b/cpu/sh/ecc.c
@@ -0,0 +1,489 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See ecc.h for a description of this module.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <asm/ecc.h>
+
+
+static const unsigned char byte_parity_table[] =   /* Parity look up table */
+{
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00
+};
+
+static const unsigned char  bit_count_table[] =   /* Parity look up table */
+{
+  0, 1, 1, 2, 1, 2, 2, 3,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  5, 6, 6, 7, 6, 7, 7, 8
+};
+
+/*******************************************************************************/
+#define COL_LOOP_STEP(c__f, c__e, c__o, c__t) \
+  c__o ^= (c__f ? c__t : 1); \
+  c__e ^= (c__f ? 1 : c__t);
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+ecc_t ecc_gen(const unsigned char* p_data, const enum ecc_size size)
+{
+  const unsigned long* const p_data_long = (unsigned long*)p_data;
+  unsigned long parity_bits[18];  /* maximum number */
+  unsigned long reg32;
+  unsigned long temp;
+  unsigned long int_cnt;
+  unsigned long bit_cnt;
+
+  unsigned int num_parity_bits;
+
+  unsigned char* p_byt;
+  unsigned char byte_reg;
+  unsigned char byte_a;
+  unsigned char byte_b;
+  unsigned char byte_c;
+  unsigned char byte_d;
+
+  ecc_t result;
+  if ( (size!=128) || (((unsigned long)p_data)%4!=0) )	/* QQQ - DELETE */
+  {							/* QQQ - DELETE */
+	printf("ERROR: %s(p_data=%p, size=%u)\n",	/* QQQ - DELETE */
+		__FUNCTION__, p_data, (unsigned)size);	/* QQQ - DELETE */
+  }							/* QQQ - DELETE */
+
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      num_parity_bits = 14;
+      break;
+    case ECC_256:
+      num_parity_bits = 16;
+      break;
+    case ECC_512:
+      num_parity_bits = 18;
+      break;
+  }
+
+  /* Initialize variables */
+  byte_reg = 0;
+  reg32 = 0;
+
+  result.byte[0] = result.byte[1] = result.byte[2] = 0;
+
+  for(bit_cnt = 0; bit_cnt < num_parity_bits; bit_cnt ++)
+  {
+    parity_bits[bit_cnt] = 0;
+  } /* for bit_cnt */
+
+  /* Build up column parity */
+  for(int_cnt = 0; int_cnt < size/sizeof(unsigned long); int_cnt++)
+  {
+    temp = p_data_long[int_cnt];
+
+    switch (size)
+    {
+      case ECC_512:
+        COL_LOOP_STEP((int_cnt & 0x40), parity_bits[16], parity_bits[17], temp);
+        /* fall through */
+      case ECC_256:
+        COL_LOOP_STEP((int_cnt & 0x20), parity_bits[14], parity_bits[15], temp);
+        /* fall through */
+      case ECC_128:
+        COL_LOOP_STEP((int_cnt & 0x01), parity_bits[4], parity_bits[5], temp);
+        COL_LOOP_STEP((int_cnt & 0x02), parity_bits[6], parity_bits[7], temp);
+        COL_LOOP_STEP((int_cnt & 0x04), parity_bits[8], parity_bits[9], temp);
+        COL_LOOP_STEP((int_cnt & 0x08), parity_bits[10], parity_bits[11], temp);
+        COL_LOOP_STEP((int_cnt & 0x10), parity_bits[12], parity_bits[13], temp);
+    }
+  } /* for int_cnt */
+
+  reg32 = parity_bits[12] ^ parity_bits[13];
+
+  p_byt = (unsigned char*)&reg32;
+#if __LITTLE_ENDIAN__
+  byte_a = p_byt[3];
+  byte_b = p_byt[2];
+  byte_c = p_byt[1];
+  byte_d = p_byt[0];
+#else
+  byte_a = p_byt[0];
+  byte_b = p_byt[1];
+  byte_c = p_byt[2];
+  byte_d = p_byt[3];
+#endif
+
+  byte_reg = byte_a ^ byte_b ^ byte_c ^ byte_d;
+
+  byte_reg = byte_parity_table[byte_reg] >> 1;
+
+
+  /* Create line parity */
+  parity_bits[0] = byte_d ^ byte_b;
+  parity_bits[1] = byte_c ^ byte_a;
+  parity_bits[2] = byte_d ^ byte_c;
+  parity_bits[3] = byte_b ^ byte_a;
+
+  for(bit_cnt = 4; bit_cnt < num_parity_bits; bit_cnt++)
+  {
+    p_byt = (unsigned char*)(parity_bits + bit_cnt);
+    p_byt[0] ^= (p_byt[1] ^ p_byt[2] ^ p_byt[3]); /* NB Only LS Byte of parity_bits used from now on */
+  } /* for bit_cnt */
+
+  /* Calculate final ECC code */
+  for(bit_cnt = 0; bit_cnt < 8; bit_cnt ++)
+    result.byte[0] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << bit_cnt;
+  for(; bit_cnt < 16 && bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[1] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 8);
+  for(; bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[2] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 16);
+
+  result.byte[2] = (unsigned char)(byte_reg << 2) | (result.byte[2] & 0x03);
+
+  return result;
+} /* ecc_gen */
+
+
+/*******************************************************************************/
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+enum ecc_check ecc_correct(unsigned char* p_data,
+                           ecc_t old_ecc,
+                           ecc_t new_ecc,
+                           enum ecc_size size)
+{
+  unsigned char bit_cnt02;
+  unsigned char bit_addr02;
+  unsigned int byte_addr02;
+
+  unsigned char ecc_xor[3];
+
+  unsigned char error_bit_count;
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      error_bit_count = 10;
+      break;
+    case ECC_256:
+      error_bit_count = 11;
+      break;
+    case ECC_512:
+      error_bit_count = 12;
+      break;
+  }
+
+  /* Basic Error Detection phase */
+  ecc_xor[0] = new_ecc.byte[0] ^ old_ecc.byte[0];
+  ecc_xor[1] = new_ecc.byte[1] ^ old_ecc.byte[1];
+  ecc_xor[2] = new_ecc.byte[2] ^ old_ecc.byte[2];
+
+  if ((ecc_xor[0] | ecc_xor[1] | ecc_xor[2]) == 0)
+  {
+    return E_NO_CHK;  /* No errors */
+  }
+  /* If we get here then there were errors */
+
+  if (size == ECC_512)
+  {
+    /* 512-byte error correction requires a little more than 128 or 256.
+       If there is a correctable error then the xor will have 12 bits set,
+       but there can also be 12 bits set in some uncorrectable errors.
+       This can be solved by xoring the odd and even numbered bits.
+
+       0xAA = 10101010
+       0x55 = 01010101
+     */
+    bit_cnt02  = bit_count_table[ ((ecc_xor[0] & 0xAA) >> 1) ^ (ecc_xor[0] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[1] & 0xAA) >> 1) ^ (ecc_xor[1] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[2] & 0xAA) >> 1) ^ (ecc_xor[2] & 0x55) ];
+  }
+  else
+  {
+    /* Counts the number of bits set in ecc code */
+    bit_cnt02  = bit_count_table[ ecc_xor[0] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[1] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[2] ];
+  }
+
+  if (bit_cnt02 == error_bit_count)
+  {
+    /* Set the bit address */
+    bit_addr02 = ((ecc_xor[2] >> 3) & 0x01) |
+                 ((ecc_xor[2] >> 4) & 0x02) |
+                 ((ecc_xor[2] >> 5) & 0x04);
+
+    /* Evaluate 2 LS bits of address */
+    byte_addr02 = ((ecc_xor[0] >> 1) & 0x01) | ((ecc_xor[0] >> 2) & 0x02);
+
+    /* Add in remaining bits of address */
+    switch (size)
+    {
+      case ECC_512:
+        byte_addr02 |= (((unsigned int)ecc_xor[2]) << 7) & 0x100;
+        /* Fall through */
+      case ECC_256:
+        byte_addr02 |= (ecc_xor[1] & 0x80);
+        /* Fall through */
+      case ECC_128:
+        byte_addr02 |= ((ecc_xor[0] >> 3) & 0x04) |
+                       ((ecc_xor[0] >> 4) & 0x08) |
+                       ((ecc_xor[1] << 3) & 0x10) |
+                       ((ecc_xor[1] << 2) & 0x20) |
+                       ((ecc_xor[1] << 1) & 0x40);
+    }
+
+
+    /* Correct bit error in the data */
+    p_data[byte_addr02] ^= (0x01 << bit_addr02);
+
+    /* NB p_old_code is okay, p_new_code is corrupt */
+
+    return E_D1_CHK;  /* Data had 1-bit error (now corrected) */
+  } /* if (bit_cnt02 == 11) */
+  else
+  {
+    if (bit_cnt02 == 1)
+    {
+      return E_C1_CHK;  /* ECC code has 1-bit error, data is okay */
+    } /* if (bit_cnt02 == 1) */
+    else
+    {
+      return E_UN_CHK;  /* Uncorrectable Error */
+    } /* else !(bit_cnt02 == 1) */
+  } /* else !(bit_cnt02 == 11) */
+} /* ecc_correct */
+/*******************************************************************************/
+
+
+#ifdef TESTING
+/* To test this code, compile as follows:
+
+       sh4gcc -mboard=<board> -g ecc.c -DTESTING
+
+   This provides a sanity test ONLY. It gives complete coverage of the code,
+   but does not fully exercise the mathmatics behind the algorithm.
+ */
+#include <stdlib.h>
+#include <time.h>
+
+int main()
+{
+  unsigned char data[512];
+  ecc_t ecc1;
+  ecc_t ecc2;
+  int i, size;
+
+  for (size = 128; size <= 512; size *= 2)
+  {
+    /* Create a data set */
+    for (i = 0; i < size; i++)
+      data[i] = i & 0xFF;
+
+    /* Create the initial ecc */
+    ecc1 = ecc_gen(data, size);
+
+    /* Make sure that it doesn't try to "correct" it before it's corrupted */
+    if (ecc_correct(data, ecc1, ecc1, size) != E_NO_CHK)
+    {
+      printf("Error: failed to detect good data.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+  printf("Error: corrupted good data.\n");
+  exit(1);
+      }
+
+    /* Deliberately corrupt the data with 1 bit error only */
+    data[size-42] ^= 1;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Make sure that it can fix the issues */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_D1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit data error.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+        printf("Error: did not correct bad data.\n");
+        exit(1);
+      }
+    /* Data is now GOOD */
+
+    /* Deliberately corrupt the ECC with 1 bit error */
+    ecc2.byte[0] = ecc1.byte[0];
+    ecc2.byte[1] = ecc1.byte[1] ^ 4;
+    ecc2.byte[2] = ecc1.byte[2];
+
+    /* Simulate reading bad ECC from flash, but calculating good ECC from data */
+    if (ecc_correct(data, ecc2, ecc1, size) != E_C1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit ECC error.\n");
+      exit(1);
+    }
+
+    /* Deliberately corrupt the data with a 2-bit error */
+    data[size-42] ^= 3;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Check that it reports that it cannot correct the issue */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_UN_CHK)
+    {
+      printf("Error: failed to diagnose 2-bit corruption.\n");
+      exit(1);
+    }
+
+    printf("ECC %d working as expected\n", size);
+  }
+
+  /* The above tests show that all is well with the various code paths.
+     However, it does not test detection of 2-bit error detection so well.
+     These tests generate and corrupt random data sets and ensures that
+     the algorithm does not mis-diagnose the condition.
+
+     Notes:
+     1. There is nothing to stop it corrupting the same bit twice - in which
+     case it will correctly diagnose a 1-bit error.
+     2. 3-bit errors and worse cause undefined behaviour, so we don't test those.
+   */
+  printf("\nECC 512 random data tests (interrupt when satisfied)\n");
+
+  srand(time(NULL));
+  while (1)
+  {
+    for (i = 0; i < 512; i++)
+      /* Random number 0..255 */
+      data[i] = (unsigned char)(256.0 * rand() / (RAND_MAX + 1.0));
+
+    ecc1 = ecc_gen(data, ECC_512);
+
+    for (i = 0; i < 2; i++)
+    {
+      /* Random number 0..514 */
+      int corruptbyte = (int)(515.0 * rand() / (RAND_MAX + 1.0));
+      /* Random number 0..7 */
+      int corruptbit = (int)(8.0 * rand() / (RAND_MAX + 1.0));
+
+      if (corruptbyte < 512)
+        data[corruptbyte] ^= 1 << corruptbit;
+      else
+        ecc1.byte[corruptbyte - 512] ^= 1 << corruptbit;
+
+      printf("%3d:%d ", corruptbyte, corruptbit);
+    }
+
+    ecc2 = ecc_gen(data, ECC_512);
+
+    if (ecc_correct(data, ecc1, ecc2, ECC_512) != E_UN_CHK)
+      printf("Error: failed to diagnose 2-bit-corruption\n");
+    else
+      printf("OK\n");
+  }
+
+  return 0;
+}
+#endif
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 5ee33f7..590d9db 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2004-2008 STMicroelectronics.
+ * (C) Copyright 2004-2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -71,6 +71,31 @@ disable_watchdog:
 	MOV_CONST16_R0 0xA500	/* WTCSR.TME=0 */
 	mov.w   r0, @r1
 
+
+	/*
+	 * If were are going to boot U-boot from NAND flash, then
+	 * we need add a special "signature" pattern in the first
+	 * logical block (block zero).
+	 */
+#ifdef CFG_BOOT_FROM_NAND
+skip_signature:
+	bra	skipped_signature	/* skip over the "block 0 signature" */
+	 nop
+
+	/*
+	 * Write out the 64-byte preamble signature pattern, to identify
+	 * the current NAND flash block, as the good "logical block ZERO".
+	 * This signature must start at offset +0x0080 in the block.
+	 */
+	.balign 0x80, 0x00		/* starts 128 bytes into "Block Zero" */
+preamble_signature_pattern:
+	bytes 0x00 0x3f			/* 64-bytes: 0x00, 0x01, ..., 0x3f */
+
+skipped_signature:
+					/* resume from here */
+#endif	/* CFG_BOOT_FROM_NAND */
+
+
 	/*
 	 * Determine if we are in the correct location ? (i.e. RAM)
 	 *  r8 == 1 in RAM, assume initialization already done by GDB.
@@ -132,6 +157,9 @@ set_pmb:
 #if defined(CONFIG_SH_STB7100)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
@@ -144,15 +172,43 @@ set_pmb:
 	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
 	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
 	#endif
+	#ifdef CFG_BOOT_FROM_NAND /* booting from NAND, so CSA and CSB swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x05  16		/* NOR FLASH CACHED */
+	#else	/* else, CSA and CSB are not swapped in EPLD */
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_NAND */
 	SH4_SET_PMB 9 0xb7 0x07  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_PDK7105)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB  4 0xa0 0x00  64 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  7 0xa6 0x06  16 0 0 1	/* NAND + CI UN-cached */
+	SH4_SET_PMB  8 0xa7 0x07  16 0 0 1	/* PCI UN-cached */
+	SH4_SET_PMB  9 0xa8 0x00  64		/* NOR FLASH CACHED */
+	SH4_SET_PMB 10 0xac 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 11 0xad 0x05  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 12 0xae 0x06  16		/* NAND + CI CACHED */
+	SH4_SET_PMB 13 0xaf 0x07  16		/* PCI CACHED */
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
@@ -161,10 +217,22 @@ set_pmb:
 	SH4_SET_PMB 8 0xb6 0x06  16 0 0 1	/* EPLD UN-cached */
 #endif	/* CONFIG_SH_NO_EPLD */
 #elif defined(CONFIG_SH_STX7141) && defined(CONFIG_SH_MB628)
-#error QQQ - to do!
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
 #elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB519)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
@@ -173,6 +241,9 @@ set_pmb:
 #elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB101)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
diff --git a/cpu/sh/stm-nand.c b/cpu/sh/stm-nand.c
new file mode 100644
index 0000000..ae7880c
--- /dev/null
+++ b/cpu/sh/stm-nand.c
@@ -0,0 +1,1040 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/stm-nand.h>
+#include <asm/ecc.h>
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Definitions!
+#endif
+
+
+#define isprint(x)	( ((x)>=0x20u) && ((x)<0x7fu) )
+
+
+#define DEBUG_FLEX		0	/* Enable additional debugging of the FLEX controller */
+#define VERBOSE_ECC		0	/* Enable for verbose ECC information  */
+
+
+/*
+ * Define the bad/good block scan pattern which are used while scanning
+ * the NAND device for any factory marked good/bad blocks.
+ *
+ * For small page devices, factory bad block markers are in byte 5.
+ * For large page devices, factory bad block markers are in bytes 0 & 1.
+ * Any bit in those bytes being a zero, implies the entire block is bad.
+ *
+ * Using "SCANALLPAGES" takes a significant performance hit - tens of seconds!
+ * So, we override the default structures (which is to scan *all* pages),
+ * and instead, we only scan the first & 2nd pages in each block.
+ * However, we do also check the entire data area in those 2 pages,
+ * to see if they are properly erased. Improperly erased pages
+ * result in the entire bock also being treated as bad.
+ */
+static uint8_t scan_pattern[] = { 0xffu, 0xffu };
+
+struct nand_bbt_descr stm_nand_badblock_pattern_16 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,	/* Byte 5 */
+	.len = 1
+};
+
+struct nand_bbt_descr stm_nand_badblock_pattern_64 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 0,	/* Bytes 0-1 */
+	.len = 2
+};
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+	/* for SMALL-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_16 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 12,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for 1st 128-byte record */
+		 4,  5,  6,	/* ECC for 2nd 128-byte record */
+		 8,  9, 10,	/* ECC for 3rd 128-byte record */
+		12, 13, 14},	/* ECC for 4th 128-byte record */
+	.oobfree = { {3, 1}, {7, 1}, {11, 1}, {15, 1} }
+};
+
+	/* for LARGE-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 48,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for  1st 128-byte record */
+		 4,  5,  6,	/* ECC for  2nd 128-byte record */
+		 8,  9, 10,	/* ECC for  3rd 128-byte record */
+		12, 13, 14,	/* ECC for  4th 128-byte record */
+		16, 17, 18,	/* ECC for  5th 128-byte record */
+		20, 21, 22,	/* ECC for  6th 128-byte record */
+		24, 25, 26,	/* ECC for  7th 128-byte record */
+		28, 29, 30,	/* ECC for  8th 128-byte record */
+		32, 33, 34,	/* ECC for  9th 128-byte record */
+		36, 37, 38,	/* ECC for 10th 128-byte record */
+		40, 41, 42,	/* ECC for 11th 128-byte record */
+		44, 45, 46,	/* ECC for 12th 128-byte record */
+		48, 49, 50,	/* ECC for 13th 128-byte record */
+		52, 53, 54,	/* ECC for 14th 128-byte record */
+		56, 57, 58,	/* ECC for 15th 128-byte record */
+		60, 61, 62},	/* ECC for 16th 128-byte record */
+	.oobfree = {
+		{ 3, 1}, { 7, 1}, {11, 1}, {15, 1},
+		{19, 1}, {23, 1}, {27, 1}, {31, 1},
+		{35, 1}, {39, 1}, {43, 1}, {47, 1},
+		{51, 1}, {55, 1}, {59, 1}, {63, 1} },
+};
+
+
+/*
+ * define a structure to hold the fields in the "struct mtd_info"
+ * and "struct nand_chip" structures that we need to over-write
+ * to allow 2 (incompatible) ECC configurations to exist on
+ * the same physical NAND flash device at the same time!
+ *
+ * This is required as some of the STi7xxx devices, have a property
+ * that when in NAND "boot-mode" (i.e. boot-from-NAND) that an ECC
+ * configuration of 3 ECC bytes per 128 byte record *must* be used.
+ * However, when not in "boot-mode", less aggressive ECC configuration
+ * of either 3 ECC bytes per 256 or 512 bytes may be used.
+ *
+ * When using this "hybrid" of 2 different ECC configurations on the
+ * same physical device, we use 2 instances of this structure:
+ *	1) based on the normal (default) configuration (e.g. S/W ECC)
+ *	2) the "boot-mode" 'special' with 3/128 H/W compatibility.
+ *
+ * Various functions are intercepted to ensure that the mtd_info
+ * and nand_chip structures always have the correct "view" of the ECC
+ * configurations, then the default functions can be safely used as is.
+ */
+struct stm_mtd_nand_ecc
+{
+	struct	/* holds differences in "struct nand_chip" */
+	{
+		int			eccmode;
+		int			eccsize;
+		int			eccsteps;
+		struct nand_oobinfo	*autooob;
+		int (*calculate_ecc)(struct mtd_info *, const u_char *, u_char *);
+		int (*correct_data)(struct mtd_info *, u_char *, u_char *, u_char *);
+	}	nand;
+	struct	/* holds differences in "struct mtd_info" */
+	{
+		u_int32_t		oobavail;
+		u_int32_t		eccsize;
+		struct nand_oobinfo	oobinfo;
+	}	mtd;
+};
+
+
+static struct stm_mtd_nand_ecc default_ecc;	/* ECC diffs for the normal SW case */
+static struct stm_mtd_nand_ecc special_ecc;	/* ECC diffs for the "special" hybrid case */
+static int done_ecc_info = 0;			/* are the 2 ECC structures initialized ? */
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+/* Flex-Mode Data {Read,Write} Config Registers & Flex-Mode {Command,Address} Registers */
+#define FLEX_WAIT_RBn			( 1u << 27 )	/* wait for RBn to be asserted (i.e. ready) */
+#define FLEX_BEAT_COUNT_1		( 1u << 28 )	/* One Beat */
+#define FLEX_BEAT_COUNT_2		( 2u << 28 )	/* Two Beats */
+#define FLEX_BEAT_COUNT_3		( 3u << 28 )	/* Three Beats */
+#define FLEX_BEAT_COUNT_4		( 0u << 28 )	/* Four Beats */
+#define FLEX_CSn_STATUS			( 1u << 31 )	/* Deasserts CSn after current operation completes */
+
+/* Flex-Mode Data-{Read,Write} Config Registers */
+#define FLEX_1_BYTE_PER_BEAT		( 0u << 30 )	/* One Byte per Beat */
+#define FLEX_2_BYTES_PER_BEAT		( 1u << 30 )	/* Two Bytes per Beat */
+
+/* Flex-Mode Configuration Register */
+#define FLEX_CFG_ENABLE_FLEX_MODE	( 1u <<  0 )	/* Enable Flex-Mode operations */
+#define FLEX_CFG_ENABLE_AFM		( 2u <<  0 )	/* Enable Advanced-Flex-Mode operations */
+#define FLEX_CFG_SW_RESET		( 1u <<  3 )	/* Enable Software Reset */
+#define FLEX_CFG_CSn_STATUS		( 1u <<  4 )	/* Deasserts CSn in current Flex bank */
+
+
+enum stm_nand_flex_mode {
+	flex_quiecent,		/* next byte_write is *UNEXPECTED* */
+	flex_command,		/* next byte_write is a COMMAND */
+	flex_address		/* next byte_write is a ADDRESS */
+};
+
+
+/*
+ * NAND device connected to STM NAND Controller operating in FLEX mode.
+ * There may be several NAND device connected to the NAND controller.
+ */
+struct stm_nand_flex_device {
+	int			csn;
+	struct nand_chip	*chip;
+	struct mtd_info		*mtd;
+	struct nand_timing_data *timing_data;
+};
+
+
+/*
+ * STM NAND Controller operating in FLEX mode.
+ * There is only a single one of these.
+ */
+static struct stm_nand_flex_controller {
+	int			initialized;	/* is the FLEX controller initialized ? */
+	int			current_csn;	/* Currently Selected Device (CSn) */
+	int			next_csn;	/* First free NAND Device (CSn) */
+	enum stm_nand_flex_mode mode;
+	struct stm_nand_flex_device device[CFG_MAX_NAND_DEVICE];
+	uint8_t			*buf;		/* Bounce buffer for non-aligned xfers */
+} flex;
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+extern int stm_nand_default_bbt (struct mtd_info *mtd)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	/* over-write the default "badblock_pattern", with our one */
+	/* choose the correct pattern struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		this->badblock_pattern = &stm_nand_badblock_pattern_64;	/* LARGE-page */
+	else
+		this->badblock_pattern = &stm_nand_badblock_pattern_16;	/* SMALL-page */
+
+	/* now call the generic BBT function */
+	return nand_default_bbt (mtd);
+}
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code)
+{
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not calculate ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else if ((((unsigned long)dat)%4)!=0)	/* data *must* be 4-bytes aligned */
+	{
+		/* QQQ: change this case to use a properly aligned bounce buffer */
+		printf("ERROR: Can not calculate ECC: data (%08lx) must be 4-byte aligned!\n",
+			(unsigned long)dat);
+		ecc_code[0] = 'B';
+		ecc_code[1] = 'A';
+		ecc_code[2] = 'D';
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else
+	{	/* calculate 3 ECC bytes per 128 bytes of data */
+		const ecc_t computed_ecc = ecc_gen(dat, ECC_128);
+		/* poke them into the right place */
+		ecc_code[0] = computed_ecc.byte[0];
+		ecc_code[1] = computed_ecc.byte[1];
+		ecc_code[2] = computed_ecc.byte[2];
+	}
+
+	return 0;
+}
+
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc)
+{
+	ecc_t read, calc;
+	enum ecc_check result;
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not correct ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;
+	}
+
+	/* do we need to try and correct anything ? */
+	if (    (read_ecc[0] == calc_ecc[0]) &&
+		(read_ecc[1] == calc_ecc[1]) &&
+		(read_ecc[2] == calc_ecc[2])    )
+	{
+		return 0;		/* ECCs agree, nothing to do */
+	}
+
+#if VERBOSE_ECC
+	printf("warning: ECC error detected!  "
+		"read_ecc %02x:%02x:%02x (%c%c%c) != "
+		"calc_ecc %02x:%02x:%02x (%c%c%c)\n",
+		(unsigned)read_ecc[0],
+		(unsigned)read_ecc[1],
+		(unsigned)read_ecc[2],
+		isprint(read_ecc[0]) ? read_ecc[0] : '.',
+		isprint(read_ecc[1]) ? read_ecc[1] : '.',
+		isprint(read_ecc[2]) ? read_ecc[2] : '.',
+		(unsigned)calc_ecc[0],
+		(unsigned)calc_ecc[1],
+		(unsigned)calc_ecc[2],
+		isprint(calc_ecc[0]) ? calc_ecc[0] : '.',
+		isprint(calc_ecc[1]) ? calc_ecc[1] : '.',
+		isprint(calc_ecc[2]) ? calc_ecc[2] : '.');
+#endif	/* VERBOSE_ECC */
+
+	/* put ECC bytes into required structure */
+	read.byte[0] = read_ecc[0];
+	read.byte[1] = read_ecc[1];
+	read.byte[2] = read_ecc[2];
+	calc.byte[0] = calc_ecc[0];
+	calc.byte[1] = calc_ecc[1];
+	calc.byte[2] = calc_ecc[2];
+
+	/* correct a 1-bit error (if we can) */
+	result = ecc_correct(dat, read, calc, ECC_128);
+
+	/* let the user know if we were able to recover it or not! */
+	switch (result)
+	{
+		case E_D1_CHK:
+			printf("info: 1-bit error in data was corrected\n");
+			break;
+		case E_C1_CHK:
+			printf("info: 1-bit error in ECC ignored (data was okay)\n");
+			break;
+		default:
+#if VERBOSE_ECC
+			/* QQQ: filter out genuinely ERASED pages - TO DO */
+			printf("ERROR: uncorrectable ECC error not corrected!\n");
+#endif	/* VERBOSE_ECC */
+			break;
+	}
+
+	/* return zero if all okay, and -1 if we have an uncorrectable issue */
+	if ((result==E_D1_CHK)||(result==E_C1_CHK))
+	{
+		return 0;	/* okay (correctable) */
+	}
+	else
+	{
+		return -1;	/* uncorrectable */
+	}
+}
+
+
+/*
+ * fill in the "default_ecc" and "special_ecc" structures.
+ */
+static void initialize_ecc_diffs (
+	const struct mtd_info * const mtd)
+{
+	const struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+	struct nand_oobinfo * autooob;
+
+	/* choose the correct OOB info struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		autooob = &stm_nand_oobinfo_64;	/* LARGE-page */
+	else
+		autooob = &stm_nand_oobinfo_16;	/* SMALL-page */
+
+	/* fill in "default_ecc" from the current "live" (default) structures */
+	default_ecc.nand.eccmode	= this->eccmode;
+	default_ecc.nand.eccsize	= this->eccsize;
+	default_ecc.nand.eccsteps	= this->eccsteps;
+	default_ecc.nand.autooob	= this->autooob;
+	default_ecc.nand.calculate_ecc	= this->calculate_ecc;
+	default_ecc.nand.correct_data	= this->correct_data;
+	default_ecc.mtd.oobavail	= mtd->oobavail;
+	default_ecc.mtd.eccsize		= mtd->eccsize;
+	memcpy(&default_ecc.mtd.oobinfo, &mtd->oobinfo, sizeof(struct nand_oobinfo));
+
+	/* fill in "special_ecc" for our special "hybrid" ECC paradigm */
+	special_ecc.nand.eccmode	= NAND_ECC_HW3_128;
+	special_ecc.nand.eccsize	= 128;
+	special_ecc.nand.eccsteps	= mtd->oobblock / special_ecc.nand.eccsize;
+	special_ecc.nand.autooob	= autooob;
+	special_ecc.nand.calculate_ecc	= stm_nand_calculate_ecc;
+	special_ecc.nand.correct_data	= stm_nand_correct_data;
+	if (this->options & NAND_BUSWIDTH_16) {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 2);
+		special_ecc.mtd.oobavail= special_ecc.mtd.oobavail & ~0x01;
+	} else {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 1);
+	}
+	special_ecc.mtd.eccsize		= special_ecc.nand.eccsize;
+	memcpy(&special_ecc.mtd.oobinfo, autooob, sizeof(struct nand_oobinfo));
+}
+
+
+/*
+ * Make the "live" MTD structures use the ECC configuration
+ * as described in the passed "diffs" structure.
+ */
+static void set_ecc_diffs (
+	struct mtd_info * const mtd,
+	const struct stm_mtd_nand_ecc * const diffs)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	this->eccmode		= diffs->nand.eccmode;
+	this->eccsize		= diffs->nand.eccsize;
+	this->eccsteps		= diffs->nand.eccsteps;
+	this->autooob		= diffs->nand.autooob;
+	this->calculate_ecc	= diffs->nand.calculate_ecc;
+	this->correct_data	= diffs->nand.correct_data;
+
+	mtd->oobavail		= diffs->mtd.oobavail;
+	mtd->eccsize		= diffs->mtd.eccsize;
+	memcpy(&mtd->oobinfo, &diffs->mtd.oobinfo, sizeof(struct nand_oobinfo));
+
+	/* also, we need to reinitialize oob_buf */
+	this->oobdirty		= 1;
+
+#if VERBOSE_ECC
+	printf("info: switching to NAND \"%s\" ECC (%u/%u)\n",
+		(diffs==&special_ecc) ? "BOOT-mode" : "NON-boot-mode",
+		this->eccbytes,
+		this->eccsize);
+#endif	/* VERBOSE_ECC */
+}
+
+
+static int set_ecc_mode (
+	struct mtd_info * const mtd,
+	const loff_t addr,
+	const size_t len)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	if (!done_ecc_info)		/* first time ? */
+	{
+		initialize_ecc_diffs (mtd);
+		done_ecc_info = 1;	/* do not do this again */
+	}
+
+	/* do we need to switch ECC mode ? */
+	if ( addr >= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is *not* in "boot-mode" (i.e. default ECC) */
+		if (this->eccmode == NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &default_ecc);
+		}
+	}
+	else if ( addr + len <= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is in "boot-mode" (i.e. 3 bytes of ECC per 128 record */
+		if (this->eccmode != NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &special_ecc);
+		}
+	}
+	else
+	{	/* the range is split over *both* "boot" and "non-boot" modes! */
+		printf("ERROR: NAND range crosses \"boot-mode\" boundary (0x%08x)\n",
+			CFG_NAND_STM_BOOT_MODE_BOUNDARY);
+		return -EINVAL;
+	}
+
+	return 0;	/* success */
+}
+
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode)
+{
+	/* do nothing - we are only emulating HW in SW */
+}
+
+
+extern int stm_nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+	size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_oob (mtd, from, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+	size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_oob (mtd, to, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+/* Configure NAND controller timing registers */
+/* QQQ: to write & use this function (for performance reasons!) */
+#ifdef QQQ
+static void flex_set_timings(struct nand_timing_data * const tm)
+{
+	uint32_t n;
+	uint32_t reg;
+	uint32_t emi_clk;
+	uint32_t emi_t_ns;
+
+	/* Timings are set in units of EMI clock cycles */
+	emi_clk = clk_get_rate(clk_get(NULL, "emi_master"));
+	emi_t_ns = 1000000000UL / emi_clk;
+
+	/* CONTROL_TIMING */
+	n = (tm->sig_setup + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->sig_hold + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+	n = (tm->CE_deassert + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 16;
+
+	n = (tm->WE_to_RBn + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 24;
+
+#if DEBUG_FLEX
+	printf("info: CONTROL_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_CTL_TIMING = reg;
+
+	/* WEN_TIMING */
+	n = (tm->wr_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->wr_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: WEN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_WEN_TIMING = reg;
+
+	/* REN_TIMING */
+	n = (tm->rd_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->rd_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: REN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_REN_TIMING = reg;
+}
+#endif
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+extern int stm_flex_device_ready(struct mtd_info * const mtd)
+{
+	/* Apply a small delay before sampling the RBn signal */
+#if 1
+	ndelay(500);	/* QQQ: do we really need this ??? */
+#endif
+	/* extract bit 2: status of RBn pin on the FLEX bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<2)) ? 1 : 0;
+}
+
+
+static void init_flex_mode(void)
+{
+	u_int32_t reg;
+
+	/* Disable the BOOT-mode controller */
+	*ST40_EMI_NAND_BOOTBANK_CFG = 0;
+
+	/* Perform a S/W reset the FLEX-mode controller */
+	/* need to assert it for at least one (EMI) clock cycle. */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_SW_RESET;
+	udelay(1);	/* QQQ: can we do something shorter ??? */
+	*ST40_EMI_NAND_FLEXMODE_CFG = 0;
+
+	/* Disable all interrupts in FLEX mode */
+	*ST40_EMI_NAND_INT_EN = 0;
+
+	/* Set FLEX-mode controller to enable FLEX-mode */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_ENABLE_FLEX_MODE;
+
+	/*
+	 * Configure (pervading) FLEX_DATA to write 4-bytes at a time.
+	 * DATA is only written by write_buf(), not write_byte().
+	 * Hence, we only need to configure this once (ever)!
+	 * As we may be copying directly from NOR flash to NAND flash,
+	 * we need to deassert the CSn after *each* access, as we
+	 * can not guarantee the buffer is in RAM (or not in the EMI).
+	 * Note: we could run memcpy() in write_buf() instead.
+	 */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data write */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATAWRT_CFG = reg;
+}
+
+
+/* FLEX mode chip select: For now we only support 1 chip per
+ * 'stm_nand_flex_device' so chipnr will be 0 for select, -1 for deselect.
+ *
+ * So, if we change device:
+ *   - Set bank in mux_control_reg to data->csn
+ *   - Update read/write timings (to do)
+ */
+extern void stm_flex_select_chip(
+	struct mtd_info * const mtd,
+	const int chipnr)
+{
+	struct nand_chip * const chip = mtd->priv;
+	struct stm_nand_flex_device * data = chip->priv;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t---- SELECT = %2d ----\n", chipnr);
+#endif
+
+	if (!flex.initialized)		/* is the H/W yet to be initialized ? */
+	{
+		/* initialize the FLEX mode controller H/W */
+		init_flex_mode();
+		/* initialize the "flex" software structure */
+		flex.mode          = flex_quiecent;	/* nothing pending */
+		flex.next_csn      = 0;			/* start with first EMI CSn */
+		flex.current_csn   = -1;		/* no NAND device selected */
+							/* allocate a bounce buffer */
+		flex.buf = malloc(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE);
+		if (flex.buf==NULL)
+		{
+			printf("ERROR: Unable to allocate memory for a bounce buffer\n");
+			BUG();
+		}
+		flex.initialized   = 1;			/* initialization done */
+	}
+
+	if (data == NULL)		/* device not yet scanned ? */
+	{
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		const int csn_map[CFG_MAX_NAND_DEVICE] = CFG_NAND_FLEX_CSn_MAP;
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+		int csn            = flex.next_csn++;		/* first free CSn */
+		chip->priv = data  = &(flex.device[csn]);	/* first free "private" structure */
+		if (csn >= CFG_MAX_NAND_DEVICE) BUG();
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		csn                = csn_map[csn];		/* Re-map to different CSn if needed */
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+#if DEBUG_FLEX
+		printf("info: stm_nand_flex_device.csn = %u\n", csn);
+#endif
+
+		data->csn          = csn;			/* fill in the private structure ... */
+		data->mtd          = mtd;
+		data->chip         = chip;
+		data->timing_data  = NULL;			/* QQQ: to do */
+#ifdef CFG_NAND_ECC_HW3_128
+		mtd->read          = stm_nand_read;
+		mtd->write         = stm_nand_write;
+		mtd->read_ecc      = stm_nand_read_ecc;
+		mtd->write_ecc     = stm_nand_write_ecc;
+		mtd->read_oob      = stm_nand_read_oob;
+		mtd->write_oob     = stm_nand_write_oob;
+		chip->enable_hwecc = stm_nand_enable_hwecc;
+#endif /* CFG_NAND_ECC_HW3_128 */
+	}
+
+	/* Deselect, do nothing */
+	if (chipnr == -1) {
+		return;
+
+	} else if (chipnr == 0) {
+		/* If same chip as last time, no need to change anything */
+		if (data->csn == flex.current_csn)
+			return;
+
+		/* Set correct EMI Chip Select (CSn) on FLEX controller */
+		flex.current_csn = data->csn;
+		*ST40_EMI_NAND_FLEX_MUXCTRL = 1ul << data->csn;
+
+		/* Set up timing parameters */
+#if 0
+		/* The default times will work for 200MHz (or slower) */
+		/* QQQ: to do - BUT this is also the WRONG place to do this! */
+		flex_set_timings(data->timing_data);
+#endif
+
+	} else {
+		printf("ERROR: In %s() attempted to select chipnr = %d\n",
+			__FUNCTION__,
+			chipnr);
+	}
+}
+
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control)
+{
+	switch(control) {
+
+	case NAND_CTL_SETCLE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START COMMAND----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_command;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRCLE:
+		printf("\t\t\t\t\t\t---- end  command----\n");
+		if (flex.mode != flex_command) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+	case NAND_CTL_SETALE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START ADDRESS----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_address;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRALE:
+		printf("\t\t\t\t\t\t---- end  address----\n");
+		if (flex.mode != flex_address) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+#if DEBUG_FLEX
+	default:
+		printf("ERROR: Unexpected parameter (control=0x%x) in %s()\n",
+			control,
+			__FUNCTION__);
+		BUG();
+#endif
+	}
+}
+
+
+/**
+ * nand_read_byte - [DEFAULT] read one byte from the chip
+ * @mtd:	MTD device structure
+ */
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd)
+{
+	u_char byte;
+	u_int32_t reg;
+
+	/* read 1-byte at a time */
+	reg = FLEX_BEAT_COUNT_1 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* read it */
+	byte = (u_char)*ST40_EMI_NAND_FLEX_DATA;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\t READ = 0x%02x\n", byte);
+#endif
+
+	/* return it */
+	return byte;
+}
+
+
+/**
+ * nand_write_byte - [DEFAULT] write one byte to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ */
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte)
+{
+	u_int32_t reg;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\tWRITE = 0x%02x\t%s\n", byte,
+		(flex.mode==flex_command) ? "command" :
+		((flex.mode==flex_address) ? "address" : "*UNKNOWN*"));
+#endif
+
+	switch (flex.mode)
+	{
+		case flex_command:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex command write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_CMD = reg;
+			break;
+
+		case flex_address:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex address write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_ADD_REG = reg;
+#if 0			/* QQQ: do we need this - I think not! */
+			while (!nand_device_ready()) ;	/* wait till NAND is ready */
+#endif
+			break;
+
+		default:
+			BUG();
+	}
+}
+
+
+/**
+ * nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store data
+ * @len:	number of bytes to read
+ */
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+	u_int32_t reg;
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+#if DEBUG_FLEX
+	printf("info: stm_flex_read_buf( buf=%p, len=0x%x )\t\tp=%p%s\n",
+		buf, len, p,
+		((uint32_t)buf & 0x3) ? "\t\t**** UN-ALIGNED *****" : "");
+#endif
+
+	/* configure to read 4-bytes at a time */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* copy the data (from NAND) as 4-byte words ... */
+	for(i=0; i<len/4; i++)
+	{
+		p[i] = *ST40_EMI_NAND_FLEX_DATA;
+	}
+
+	/* copy back into user-supplied buffer, if it was unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(buf, p, len);
+
+#if DEBUG_FLEX
+	printf("READ BUF\t\t\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+}
+
+
+/**
+ * nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ */
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+
+#if DEBUG_FLEX
+	printf("WRITE BUF\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+	/* copy from user-supplied buffer, if it is unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(p, buf, len);
+
+	/* configured to write 4-bytes at a time */
+	/* copy the data (to NAND) as 32-bit words ... */
+	for(i=0; i<len/4; i++)
+	{
+		*ST40_EMI_NAND_FLEX_DATA = p[i];
+	}
+}
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
index 8306f37..7d56225 100644
--- a/cpu/sh/stx7105/stx7105.c
+++ b/cpu/sh/stx7105/stx7105.c
@@ -91,16 +91,18 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 		sysconf |= (EXT_MDIO);
 	else
 		sysconf &= ~(EXT_MDIO);
-	/* RMII pin multiplexing: 0: RMII interface active, 1: MII interface */
+	/* RMII pin multiplexing: 0: MII interface active, 1: RMII interface */
+	/* cut 1: This register was not connected, so only MII available */
 	if (rmii_mode)
-		sysconf &= ~(RMII_MODE);
-	else
 		sysconf |= (RMII_MODE);
-	/* PHY EXT CLOCK: 0: provided by STx7105; 1: external */
-	if (ext_clk)
-		sysconf |= (PHY_CLK_EXT);
 	else
-		sysconf &= ~(PHY_CLK_EXT);
+		sysconf &= ~(RMII_MODE);
+	/*
+	 * PHY EXT CLOCK: 0: provided by STx7105; 1: external
+	 * cut 1: sysconf7[19], however this was not connected, so only
+	 * input supported.
+	 * cut 2: direction now based on PIO direction, so this code removed.
+	 */
 	/* Default GMII/MII selection */
 	sysconf &= ~(PHY_INTF_SEL_MASK);
 	sysconf |= ((mode&3ul)<<25);
@@ -121,8 +123,8 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	sysconf &= ~(0xf0f0ul);	/* Mask=3,3,3,3 */
 	sysconf |=   0x0000ul;	/* OR  =0,0,0,0 */
 	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
-	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_IN);
 	SET_PIO_PIN(PIO_PORT(7), 6, STPIO_ALT_OUT);
 	SET_PIO_PIN(PIO_PORT(7), 7, STPIO_ALT_OUT);
 
@@ -143,9 +145,9 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	SET_PIO_PIN(PIO_PORT(8), 2, STPIO_ALT_OUT);
 	SET_PIO_PIN(PIO_PORT(8), 3, STPIO_ALT_BIDIR);
 	SET_PIO_PIN(PIO_PORT(8), 4, STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_IN);
 
 	/* PIO9[0] CFG47[8+0,0] = Alternate1 = MIIRXD[2] */
 	/* PIO9[1] CFG47[8+1,1] = Alternate1 = MIIRXD[3] */
@@ -158,13 +160,19 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	sysconf &= ~(0x7f7ful);	/* Mask=3,3,3,3,3,3,3 */
 	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0 */
 	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
-	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_IN);
+	/* MIIPHYCLK */
+	/* Not implemented in cut 1 (DDTS GNBvd69906) - clock never output */
+	/* In cut 2 PIO direction used to control input or output. */
+	if (ext_clk)
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_IN);
+	else
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_IN);
 }
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
@@ -176,15 +184,20 @@ int soc_init(void)
 	stx7105_clocks();
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-	stmac_eth_hw_setup (0, 0, 0, 1, 0, 0);
+	stmac_eth_hw_setup (0, 0, 0, 0, 1, 0);
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	bd->bi_devid = *STX7105_SYSCONF_DEVICEID_0;
 
-#if QQQ	/* QQQ - TO FIX */
-	/*  Make sure reset period is shorter than WDT timeout */
-	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
-#endif	/* QQQ - TO FIX */
+	/*
+	 * Make sure the reset period is shorter than WDT time-out,
+	 * and that the reset loop-back chain is *not* bypassed.
+	 *	SYS_CFG09[29]    = long_reset_mode
+	 *	SYS_CFG09[28:27] = cpu_rst_out_bypass(1:0)
+	 *	SYS_CFG09[25:0]  = ResetOut_period
+	 */
+//QQQ	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF7000000) | 0x000A8C;
+	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF4000000ul) | 0x000A8Cul;
 
 	return 0;
 }
diff --git a/cpu/sh/stx7141/stx7141.c b/cpu/sh/stx7141/stx7141.c
index 51af6d8..cdd42ae 100644
--- a/cpu/sh/stx7141/stx7141.c
+++ b/cpu/sh/stx7141/stx7141.c
@@ -117,6 +117,7 @@ int soc_init(void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
 	bd_t *bd = gd->bd;
+	unsigned long reg;
 
 	stx7141_clocks();
 
@@ -126,11 +127,40 @@ int soc_init(void)
 
 	bd->bi_devid = *STX7141_SYSCONF_DEVICEID_0;
 
-#ifdef QQQ	/* QQQ - TO DO */
-	/*  Make sure reset period is shorter than WDT timeout */
-	*STX7141_SYSCONF_SYS_CFG09 = (*STX7141_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+	/*
+	 * Reset Generation Configuration
+	 * Make sure reset period is shorter than WDT time-out,
+	 * and that the reset is not bypassed.
+	 *
+	 *	[28:27] = CPU_RST_OUT_BYPASS[1:0]
+	 *	[25:0]  = RESETOUT_PERIOD
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG09;
+	/* Propagate the reset signal */
+	reg = (reg & (~(3ul<<27))) | ((0ul)<<27);
+	/* use the default "short" reset time of 100us */
+	reg = (reg & (~0x03FFFFFFul)) | 0x00000A8Cul;
+	*STX7141_SYSCONF_SYS_CFG09 = reg;
+
+	/*
+	 * SH4 Boot Configuration
+	 * Unmask the reset signal from the SH4 core.
+	 *
+	 *	[4:3] = SH4_MASK_RST_OUT[1:0]
+	 *
+	 * SH4_MASK_RST_OUT[1]: mask rst_out signal from SH4-eCM core
+	 * SH4_MASK_RST_OUT[0]: mask rst_out signal from SH4-eSTB core
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG08;
+#if 1
+	/* Unmask the reset signal from the SH4-eSTB core */
+	reg = (reg & (~(1ul<<3))) | ((0ul)<<3);
+#else
+	/* Unmask the reset signal from the SH4-eCM core */
+	reg = (reg & (~(1ul<<4))) | ((0ul)<<4);
+#endif
+	*STX7141_SYSCONF_SYS_CFG08 = reg;
 
-#endif		/* QQQ - TO DO */
 	return 0;
 }
 
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 1362ed0..b552e0a 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -1293,6 +1293,20 @@ ulong flash_get_size (ulong base, int banknum)
 			erase_region_count = (tmp & 0xffff) + 1;
 			debug ("erase_region_count = %d erase_region_size = %d\n",
 				erase_region_count, erase_region_size);
+
+				/*
+				 * ensure we do not violate array bounds, specifically:
+				 *	flash_info_t.start[CFG_MAX_FLASH_SECT];
+				 *	flash_info_t.protect[CFG_MAX_FLASH_SECT];
+				 */
+			if (erase_region_count > CFG_MAX_FLASH_SECT) {
+				printf ("Error: Number of Sectors (%d) > CFG_MAX_FLASH_SECT (%d)\n",
+					erase_region_count,
+					CFG_MAX_FLASH_SECT);
+				flash_write_cmd (info, 0, 0, info->cmd_reset);
+				return 0;	/* return, to avoid corrupting any memory */
+			}
+
 			for (j = 0; j < erase_region_count; j++) {
 				info->start[sect_cnt] = sector;
 				sector += (erase_region_size * size_ratio);
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 151f535..810f92e 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -11,6 +11,10 @@
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
+ *		  2009 STMicroelectronics. (Sean McGoogan <Sean.McGoogan@st.com>)
+ *
+ *
+ *  02-06-2009  SMG: added support for 3 bytes of ECC per 128 byte record.
  *
  *  02-08-2004  tglx: support for strange chips, which cannot auto increment
  *		pages on read / read_oob
@@ -133,13 +137,8 @@ static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len);
 static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len);
 
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
-			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
+
 /* XXX U-BOOT XXX */
 #if 0
 static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs,
@@ -538,6 +537,11 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/*
@@ -643,6 +647,11 @@ static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column,
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
 		column += mtd->oobblock;
@@ -891,7 +900,7 @@ static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int pa
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
-	u_char	ecc_code[32];
+	u_char	ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	uint  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
@@ -1105,15 +1114,15 @@ static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * re
  *
  * NAND read with ECC
  */
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
 	u_char *data_poi, *oob_data = oob_buf;
-	u_char ecc_calc[32];
-	u_char ecc_code[32];
+	u_char ecc_calc[MTD_NANDECC_MAX_ECCPOS];
+	u_char ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int eccmode, eccsteps;
 	unsigned *oob_config;
 	int	datidx;
@@ -1122,7 +1131,6 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 	int	compareecc = 1;
 	int	oobreadlen;
 
-
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
@@ -1374,7 +1382,7 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
 	int i, col, page, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -1609,7 +1617,7 @@ static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * ret
  *
  * NAND write with ECC
  */
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
 			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
 	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
@@ -1762,7 +1770,7 @@ out:
  *
  * NAND write out-of-band
  */
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
 {
 	int column, page, status, ret = -EIO, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -2528,6 +2536,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	case NAND_ECC_HW3_256:
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsize = 128;	/* set eccsize to 128 bytes/record */
+		break;
+
 	case NAND_ECC_NONE:
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
@@ -2555,6 +2567,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccbytes += 3;
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW3_256:
+	case NAND_ECC_HW3_128:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
@@ -2578,6 +2591,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccsteps = mtd->oobblock / 256;
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsteps = mtd->oobblock / 128;
+		break;
+
 	case NAND_ECC_NONE:
 		this->eccsteps = 1;
 		break;
@@ -2604,12 +2621,20 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	mtd->erase = nand_erase;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
-	mtd->read = nand_read;
-	mtd->write = nand_write;
-	mtd->read_ecc = nand_read_ecc;
-	mtd->write_ecc = nand_write_ecc;
-	mtd->read_oob = nand_read_oob;
-	mtd->write_oob = nand_write_oob;
+	/* allow board-specific init to overwrite some MTD functions */
+	if (!mtd->read)
+		mtd->read = nand_read;
+	if (!mtd->write)
+		mtd->write = nand_write;
+	if (!mtd->read_ecc)
+		mtd->read_ecc = nand_read_ecc;
+	if (!mtd->write_ecc)
+		mtd->write_ecc = nand_write_ecc;
+	if (!mtd->read_oob)
+		mtd->read_oob = nand_read_oob;
+	if (!mtd->write_oob)
+		mtd->write_oob = nand_write_oob;
+
 /* XXX U-BOOT XXX */
 #if 0
 	mtd->readv = NULL;
@@ -2633,6 +2658,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 #if 0
 	mtd->owner = THIS_MODULE;
 #endif
+
 	/* Build bad block table */
 	return this->scan_bbt (mtd);
 }
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index cd8034a..d7504c0 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2006-2008  STMicroelectronics Limited
+ *  Copyright (c) 2006-2009 STMicroelectronics Limited
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -140,9 +140,9 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define LAN8700_PHY_ID		0x0007c0c0u
 #define LAN8700_PHY_ID_MASK	0xfffffff0u
 
-#define SPECIAL_MODE_REG	0x12		/* Special Modes Register */
-#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
-#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+#define SPECIAL_MODE_REG	0x12	/* Special Modes Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
 
 #elif defined(CONFIG_STMAC_DP83865)	/* Nat Semi DP83865 */
 
@@ -150,9 +150,15 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define DP83865_PHY_ID		0x20005c70u
 #define DP83865_PHY_ID_MASK	0xfffffff0u
 
-#define PHY_SUP_REG		0x1f		/* PHY Support Register */
-#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
-#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+#define PHY_SUP_REG		0x1f	/* PHY Support Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
+
+#elif defined(CONFIG_STMAC_KSZ8041FTL)	/* Micrel KSZ8041FTL */
+
+/* Micrel KSZ8041FTL phy identifier values */
+#define KSZ8041FTL_PHY_ID	0x00221512u
+#define KSZ8041FTL_PHY_ID_MASK	0x01ffffffu
 
 #else
 #error Need to define which PHY to use
@@ -271,6 +277,11 @@ static unsigned int stmac_phy_get_addr (void)
 			printf (STMAC "NS DP83865 found\n");
 			return phyaddr;
 		}
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+		if ((id & KSZ8041FTL_PHY_ID_MASK) == KSZ8041FTL_PHY_ID) {
+			printf (STMAC "KSZ8041FTL found\n");
+			return phyaddr;
+		}
 #endif	/* CONFIG_STMAC_STE10XP */
 	}
 
@@ -300,15 +311,22 @@ static int stmac_phy_init (void)
 	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
 #elif defined(CONFIG_STMAC_DP83865)
 	value = stmac_mii_read (eth_phy_addr, PHY_SUP_REG);
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+	/* The Micrel KSZ8041FTL does not appear to support
+	 * reading the H/W PHY address from any register.
+	 * So, we bypass the following test.
+	 */
 #else
 #error Need to define PHY
 #endif
+#if !defined(CONFIG_STMAC_KSZ8041FTL)
 	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
 	if (value != eth_phy_addr) {
 		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
 			value,
 			eth_phy_addr);
 	}
+#endif
 
 	/* Read the ANE Advertisement register */
 	advertised_caps = stmac_mii_read (eth_phy_addr, MII_ADVERTISE);
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index d95f67b..d5b35c6 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -37,6 +37,7 @@ COBJS-y += serial_pl011.o
 COBJS-y += serial_xuartlite.o
 COBJS-y += sh-sci.o
 COBJS-y += stm-asc.o
+COBJS-y += stm-dtf.o
 COBJS-y += usbtty.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/serial/stm-dtf.c b/drivers/serial/stm-dtf.c
new file mode 100644
index 0000000..700cfeb
--- /dev/null
+++ b/drivers/serial/stm-dtf.c
@@ -0,0 +1,187 @@
+/*
+ * drivers/serial/stm-dtf.c
+ *
+ * Support for emulated serial console I/O using STMicroelectronics'
+ * DTF (Data Transfer Format) mechanism, over a JTAG link, to
+ * a remote GDB debugger on a host machine.
+ *
+ *  Copyright (c) 2009  STMicroelectronics Limited
+ *  Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+
+
+#ifdef CONFIG_STM_DTF_SERIAL
+
+
+#ifdef CONFIG_SH_SCIF_SERIAL
+#error Can not define CONFIG_SH_SCIF_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+#ifdef CONFIG_STM_ASC_SERIAL
+#error Can not define CONFIG_STM_ASC_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+
+static int dtf_transfer(
+	volatile void * const data,
+	volatile int * const numBytes,
+	const size_t maxPacketSize)
+{
+	static unsigned char dtfPacket[8+sizeof(short)] __attribute__((aligned(4)));
+	unsigned short pktSize = *numBytes;
+
+	/* Ensure our DTF packet buffer is big enough */
+	if (pktSize+sizeof(short) > sizeof(dtfPacket))
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* pack the DTF request */
+	*(unsigned short *)dtfPacket = pktSize;
+	memcpy((char*)dtfPacket+sizeof(short), (void*)data, pktSize);
+
+	/*
+	 * Signal to the host that an I/O request is ready. When control returns
+	 * the packet will have been updated with the result of the request.
+	 */
+	__asm__ __volatile__ (
+		"	mov	%0, r8;"
+		".short	0x003b;"
+		".short	0x0000;"
+		"1:	mov.w	@%0, r8;"
+		"	tst	r8, r8;"
+		"	bt	1b"
+		: : "r" (dtfPacket) : "r8", "t");
+
+	/*
+	 * Unpack the DTF response packet.
+	 * Check that the packet size is valid, if not then return immediately.
+	 */
+	pktSize = *(unsigned short *)dtfPacket;
+	if (pktSize > maxPacketSize)
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* Extract results */
+	*numBytes = pktSize;
+	memcpy((void*)data, (char*)dtfPacket+sizeof(short), pktSize);
+
+	return 0;	/* Okay */
+}
+
+
+/*
+ * The following are used to retain results whilst
+ * polling for a key-stroke in tstc() and getc().
+ */
+static int CachedKeyCode;	/* Key-stroke that is cached */
+static int CachedKey = 0;	/* is "CachedKeyCode" valid */
+
+
+/* returns TRUE if a char is available, ready to be read */
+extern int serial_tstc (void)
+{
+	volatile unsigned char buff[8] __attribute__((aligned(4))) = {24};
+	int buffLen = 1;
+
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		return 1;	/* cached key ready to be read */
+	}
+
+	/* Send request to and receive reply from host */
+	if (dtf_transfer(buff, &buffLen, sizeof(buff)) == -1)
+	{
+		return 0;	/* Error */
+	}
+
+	/* Extract result */
+	CachedKey     = *(volatile int*)&buff[0];
+	CachedKeyCode = *(volatile unsigned int*)&buff[4];
+
+	/* return TRUE if a char is available, else FALSE */
+	return CachedKey;
+}
+
+
+/* blocking function, that returns next char */
+extern int serial_getc (void)
+{
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		CachedKey = 0;		/* empty the cache */
+		return CachedKeyCode;	/* cached key ready to be read */
+	}
+
+	/* polling wait: for a char to be read */
+	while (!serial_tstc ());
+
+	/* return the key just read */
+	CachedKey = 0;			/* empty the cache */
+	return CachedKeyCode;		/* return it */
+}
+
+
+/* write out a single char */
+extern void serial_putc (const char ch)
+{
+	unsigned char buff[6] = { 7, 1, 0, 0, 0 };
+	int buffLen = sizeof(buff);
+
+	/* put the char to write in buffer */
+	buff[5] = ch;
+
+	/* Send DTF request to the host */
+	dtf_transfer (buff, &buffLen, sizeof(buff));
+}
+
+
+/* write an entire (NUL-terminated) string */
+extern void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+/* initialize the serial device */
+extern int serial_init (void)
+{
+	/* do nothing */
+	return 0;
+}
+
+
+/* called to adjust baud-rate */
+extern void serial_setbrg (void)
+{
+	/* do nothing */
+}
+
+
+#endif	/* CONFIG_STM_DTF_SERIAL */
diff --git a/include/asm-sh/asmdefs.h b/include/asm-sh/asmdefs.h
index 7163fd5..3f6385c 100644
--- a/include/asm-sh/asmdefs.h
+++ b/include/asm-sh/asmdefs.h
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004, 2007, 2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -182,3 +183,21 @@ where <index> is the PMB entry
 	MOV_CONST32_R0	(P4SEG_PMB_DATA | (\i<<8))
 	mov.l	r1,@r0
 .endm
+
+/*
+ * Write out a series of bytes, monotonically increasing
+ * in value from "first" to "last" (inclusive).
+ *
+ * Usage:	BYTES <first> <last>
+ * where <first> is the first byte to generate
+ * where <last>  is the last byte to generate
+ *
+ * Note: this macro uses recursion (one level per byte)
+ */
+.macro BYTES first=0, last=63
+	.byte \first
+	.if \last-\first
+	BYTES "(\first+1)",\last	/* note: recursion */
+	.endif
+.endm
+
diff --git a/include/asm-sh/ecc.h b/include/asm-sh/ecc.h
new file mode 100644
index 0000000..014601c
--- /dev/null
+++ b/include/asm-sh/ecc.h
@@ -0,0 +1,168 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* An ECC is a 3-byte code which can be used to detect and correct 1-bit
+ * errors (perhaps introduced by NAND flash defects) in a 128, 256, or
+ * 512-byte block of data.
+ *
+ * Features:
+ *   - Correction of any 1-bit error in the data.
+ *   - Detection of any 1-bit error in the ECC and whether the data is OK.
+ *   - Detection of any 2-bit error in the data.
+ *
+ * Limitations:
+ *   - CANNOT correct 2-bit errors.
+ *   - Results for 3-bit errors (or worse) are UNDEFINED.
+ *
+ * This algorithm is only intended for use with data corrupted by a NAND
+ * flash - in which anything more than a 1-bit error is highly unlikely.
+ *
+ * DO NOT attempt to use it where the data may be more seriously corrupted.
+ * The algorithm WILL NOT always correct serious defects and may even report
+ * that the data is good.
+ *
+ * Usage
+ * =====
+ *
+ * Writing flash:
+ *
+ *   1) Prepare the data.
+ *   2) Generate an ECC for each 128, 256, or 512 bytes.
+ *        ecc = ecc_gen (data, ECC_256)
+ *   3) Write both to flash.
+ *
+ * Reading flash:
+ *
+ *   1) Read both data and ECC from flash.
+ *   2) Generate a fresh ECC for the read data.
+ *        new_ecc = ecc_gen (read_data, ECC_256)
+ *   3) Compare the two ECCs and correct the data, if necessary.
+ *        ecc_correct (read_data, read_ecc, new_ecc, ECC_256)
+ *   4) Check the return code:
+ *        E_UN_CHK
+ *            Data cannot be used - too badly corrupted.
+ *        E_NO_CHK
+ *            All is well.
+ *        E_D1_CHK
+ *            Data has been corrected, but the flash block contains an error.
+ *        E_C1_CHK
+ *            Data is OK, but the flash block contains an error in the ECC.
+ *
+ * If a read error occurs then you may want to consider moving the data to
+ * another flash block. If the read error is in the ECC then don't forget
+ * to generate a correct ECC before rewriting.
+ *
+ * ECC Format
+ * ==========
+ *
+ * Basic Format:
+ *
+ *      		byte 0		byte 1		byte2
+ *
+ *      bit 0		LP0		LP8		LP16
+ *      bit 1		LP1		LP9		LP17
+ *      bit 2		LP2		LP10	`	CP0
+ *      bit 3		LP3		LP11		CP1
+ *      bit 4		LP4		LP12		CP2
+ *      bit 5		LP5		LP13		CP3
+ *      bit 6		LP6		LP14		CP4
+ *      bit 7		LP7		LP15		CP5
+ *
+ *      CP = Column parity
+ *      LP = Line parity
+ *
+ * ECC_128:
+ *
+ *      LP14-17 are not used. The unused bits are set to zero.
+ *
+ *      This format is designed to match the format used by the error
+ *      correcting EMI NAND Controller. It may NOT be compatible with other
+ *      128 byte ECCs.
+ *
+ * ECC_256:
+ *
+ *      LP16-17 are not used. The unused bits are set to zero.
+ *
+ * ECC_512:
+ *
+ *      All bits are used.
+ *
+ *      This format is NOT compatible with the 512 byte ECC used by OSPlus.
+ *      (At the time of writing, this can be resolved merely by inverting each
+ *      bit in the ECC, but this may not be the case in future.)
+ *
+ */
+
+#ifndef ECC_H
+#define ECC_H
+
+/* The ECC algorithms support three different data sizes. */
+enum ecc_size
+{
+  ECC_128 = 128,
+  ECC_256 = 256,
+  ECC_512 = 512
+};
+
+/* This type represents a 3-byte ECC. */
+typedef struct ecc
+{
+  unsigned char byte[3];
+} ecc_t;
+
+/* Return values from check function */
+enum ecc_check 
+{
+  E_UN_CHK = -1, /* uncorrectable error. */
+  E_NO_CHK = 0,  /* No Errors. */
+  E_D1_CHK = 1,  /* 1-bit data error. */
+  E_C1_CHK = 2   /* 1-bit code error. */
+};
+
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+extern ecc_t ecc_gen(
+	const unsigned char* p_data,
+	const enum ecc_size size);
+
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+extern enum ecc_check ecc_correct(
+	unsigned char *p_data,
+	ecc_t old_ecc,
+	ecc_t new_ecc,
+	enum ecc_size size);
+
+#endif /* ifndef ECC_H */
+
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index 96458d7..62d17eb 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -50,16 +50,17 @@
 
 #define __WANT_IO_DEF
 
-#if defined(CONFIG_SH_MB411)	|| \
-       defined(CONFIG_SH_MB442)	|| \
-       defined(CONFIG_SH_MB448)	|| \
-       defined(CONFIG_SH_HMS1)	|| \
-       defined(CONFIG_SH_MB519)	|| \
-       defined(CONFIG_SH_MB618)	|| \
-       defined(CONFIG_SH_MB628)	|| \
-       defined(CONFIG_SH_MB671)	|| \
-       defined(CONFIG_SH_MB680)	|| \
-       defined(CONFIG_SH_CB101)	|| \
+#if defined(CONFIG_SH_MB411)		|| \
+       defined(CONFIG_SH_MB442)		|| \
+       defined(CONFIG_SH_MB448)		|| \
+       defined(CONFIG_SH_HMS1)		|| \
+       defined(CONFIG_SH_MB519)		|| \
+       defined(CONFIG_SH_MB618)		|| \
+       defined(CONFIG_SH_MB628)		|| \
+       defined(CONFIG_SH_MB671)		|| \
+       defined(CONFIG_SH_MB680)		|| \
+       defined(CONFIG_SH_PDK7105)	|| \
+       defined(CONFIG_SH_CB101)		|| \
        defined(CONFIG_SH_CB102)
 #  include "asm/io_stb1eval.h"
 #else
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
index 796e39d..c807842 100644
--- a/include/asm-sh/st40reg.h
+++ b/include/asm-sh/st40reg.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007, 2008
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007-2009
  *
  * andy.sturges@st.com
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -383,14 +383,60 @@
 #define ST40_EMI_BANK5_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0250)
 #define ST40_EMI_BANK5_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0258)
 
-#define ST40_EMI_BANK0_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800)
-#define ST40_EMI_BANK1_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0810)
-#define ST40_EMI_BANK2_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0820)
-#define ST40_EMI_BANK3_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0830)
-#define ST40_EMI_BANK4_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0840)
-#define ST40_EMI_BANK5_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0850)
+#define ST40_EMI_BASEADDRESS(bank)	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800 + (bank)*0x0010)
+#define ST40_EMI_BANK0_BASEADDRESS	ST40_EMI_BASEADDRESS(0)
+#define ST40_EMI_BANK1_BASEADDRESS	ST40_EMI_BASEADDRESS(1)
+#define ST40_EMI_BANK2_BASEADDRESS	ST40_EMI_BASEADDRESS(2)
+#define ST40_EMI_BANK3_BASEADDRESS	ST40_EMI_BASEADDRESS(3)
+#define ST40_EMI_BANK4_BASEADDRESS	ST40_EMI_BASEADDRESS(4)
+#define ST40_EMI_BANK5_BASEADDRESS	ST40_EMI_BASEADDRESS(5)
 #define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
 
+/* EMI NAND flash registers */
+#define ST40_EMI_NAND_REGS_BASE			(ST40_EMI_REGS_BASE + 0x1000)
+#define ST40_EMI_NAND_BOOTBANK_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0000)
+#define ST40_EMI_NAND_RBN_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0004)
+#define ST40_EMI_NAND_INT_EN			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0010)
+#define ST40_EMI_NAND_INT_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0014)
+#define ST40_EMI_NAND_INT_CLR			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0018)
+#define ST40_EMI_NAND_INT_EDGE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x001c)
+#define ST40_EMI_NAND_CTL_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0040)
+#define ST40_EMI_NAND_WEN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0044)
+#define ST40_EMI_NAND_REN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0048)
+#define ST40_EMI_NAND_BLOCK_ZERO_REMAP_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x004C)
+#define ST40_EMI_NAND_FLEXMODE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0100)
+#define ST40_EMI_NAND_FLEX_MUXCTRL		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0104)
+#define ST40_EMI_NAND_FLEX_CS_ALT		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0108)
+#define ST40_EMI_NAND_FLEX_DATAWRT_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x010c)
+#define ST40_EMI_NAND_FLEX_DATA_RD_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0110)
+#define ST40_EMI_NAND_FLEX_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0114)
+#define ST40_EMI_NAND_FLEX_ADD_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0118)
+#define ST40_EMI_NAND_FLEX_DATA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0120)
+#define ST40_EMI_NAND_VERSION_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0144)
+#define ST40_EMI_NAND_ADDRESS_REG_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E0)
+#define ST40_EMI_NAND_ADDRESS_REG_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E4)
+#define ST40_EMI_NAND_ADDRESS_REG_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E8)
+#define ST40_EMI_NAND_MULTI_CS_CONFIG_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01EC)
+#define ST40_EMI_NAND_SEQ_REG1			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0200)
+#define ST40_EMI_NAND_SEQ_REG2			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0204)
+#define ST40_EMI_NAND_SEQ_REG3			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0208)
+#define ST40_EMI_NAND_SEQ_REG4			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x020c)
+#define ST40_EMI_NAND_ADD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0210)
+#define ST40_EMI_NAND_EXTRA_REG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0214)
+#define ST40_EMI_NAND_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0218)
+#define ST40_EMI_NAND_SEQ_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x021c)
+#define ST40_EMI_NAND_GEN_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0220)
+#define ST40_EMI_NAND_SEQ_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0240)
+#define ST40_EMI_NAND_ECC_CHECKCODE_0		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0280)
+#define ST40_EMI_NAND_ECC_CHECKCODE_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0284)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0288)
+#define ST40_EMI_NAND_ECC_CHECKCODE_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x028c)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_0	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0290)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_1	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0294)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_2	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0298)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_3	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x029C)
+#define ST40_EMI_NAND_DATA_FIFO_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0300)
+
 /* Peripheral Component Interconnect control registers (all ST40 variants) */
 /* PCI Local Registers */
 #define ST40_PCI_VCR_STATUS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000000)
diff --git a/include/asm-sh/stm-nand.h b/include/asm-sh/stm-nand.h
new file mode 100644
index 0000000..e0136a0
--- /dev/null
+++ b/include/asm-sh/stm-nand.h
@@ -0,0 +1,139 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <nand.h>
+
+
+extern struct nand_bbt_descr stm_nand_badblock_pattern_16;
+extern struct nand_bbt_descr stm_nand_badblock_pattern_64;
+
+extern int stm_nand_default_bbt (
+	struct mtd_info *mtd);
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code);
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc);
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode);
+
+
+extern int stm_nand_read (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+extern int stm_nand_read_ecc (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_read_oob (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+
+extern int stm_nand_write (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf);
+
+extern int stm_nand_write_ecc (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_write_oob (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char *buf);
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+extern int stm_flex_device_ready(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_select_chip (
+	struct mtd_info * const mtd,
+	const int chipnr);
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control);
+
+
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte);
+
+
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len);
+
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char *buf,
+	const int len);
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
index 7f6cb1f..d92710a 100644
--- a/include/configs/mb411.h
+++ b/include/configs/mb411.h
@@ -102,10 +102,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
index b95c9d9..9620048 100644
--- a/include/configs/mb442.h
+++ b/include/configs/mb442.h
@@ -112,10 +112,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
index 342a49e..cdbcf20 100644
--- a/include/configs/mb448.h
+++ b/include/configs/mb448.h
@@ -101,10 +101,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
 
 /*---------------------------------------------------------------
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index 3723d9d..2cb7da9 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -108,10 +108,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
 //#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
 
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
index fdd9a13..faa67d5 100644
--- a/include/configs/mb618.h
+++ b/include/configs/mb618.h
@@ -71,10 +71,16 @@
 
 #define BOARD mb618
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
 #endif
@@ -108,10 +114,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
index ccfc5ad..ef5f65e 100644
--- a/include/configs/mb628.h
+++ b/include/configs/mb628.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -39,12 +39,14 @@
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
  * Assume we run out of uncached memory for the moment
+ *
+ * See board/mb628/config.mk for details of the memory map.
  */
 
 #ifdef CONFIG_SH_SE_MODE
 #define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
 #define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
-#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SDRAM_BASE		0x80800000      /* LMI    Cached addr via PMB */
 #define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
 #define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
 #else
@@ -52,7 +54,7 @@
 #define CFG_SDRAM_BASE		0x8C800000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x03000000	/* 48 MiB of LMI SDRAM */
+#define CFG_SDRAM_SIZE		0x03200000	/* 50 MiB of LMI SDRAM */
 
 #define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
@@ -114,10 +116,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 	/* ASC1	(left-most)	"RS232 1" */
 #	define CFG_STM_ASC_BASE		0xfd031000
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
index ef0ebf3..a3626c9 100644
--- a/include/configs/mb671.h
+++ b/include/configs/mb671.h
@@ -108,10 +108,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
 //#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
 
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index 6700e1b..cb89d0e 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -37,18 +37,42 @@
 #define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
  * Assume we run out of uncached memory for the moment
  */
 
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
+		/*
+		 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
+		 * If so, then who takes responsibility for this???
+		 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
+		 * Should U-Boot read SW8(1) on the MB705, and do something?
+		 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSB in EPLD */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
 #ifdef CONFIG_SH_SE_MODE
-#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH (uncached) via PMB */
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
 #define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
 #define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
 #define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
 #define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
 #else
-#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH in P2 region */
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
 #define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
 #endif
 
@@ -114,10 +138,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
 #else
@@ -129,9 +162,10 @@
  */
 
 /*
- * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * There are 3 options for ethernet, all use the on-chip ST-GMAC.
  * The choice in PHYs are:
- *    The on-board Nat Semi DP83865
+ *    The on-board Nat Semi DP83865	(only on Rev A, B)
+ *    The on-board SMSC LAN8700		(only on Rev C)		(NOW the DEFAULT)
  *    External PHY connected via the MII off-board connector.
  */
 
@@ -144,7 +178,11 @@
  */
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
 #	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
-#	define CONFIG_STMAC_DP83865			/* PHY = NS DP83865 */
+#if 0							/* Choose NS or SMSC PHY */
+#	define CONFIG_STMAC_DP83865	/* Rev A,B */	/* PHY = NS DP83865 */
+#else
+#	define CONFIG_STMAC_LAN8700	/* Rev C */	/* PHY = SMSC LAN8700 */
+#endif
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 /*  If this board does not have eeprom for ethernet address so allow the user
@@ -254,7 +292,7 @@
 #ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
 #	define CFG_MAX_NAND_DEVICE	1
 #	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
-#	define CFG_NAND0_BASE		0xA4000000	/* Physical 0x04000000 */
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
 #	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
 #	define MTDPARTS_NAND						\
 	"gen_nand.1:"		/* First NAND flash device */		\
@@ -264,6 +302,45 @@
 		",-(RestOfNand0)"	/* last partition */
 #	define MTDIDS_NAND						\
 	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
 #endif	/* CONFIG_CMD_NAND */
 
 /*-----------------------------------------------------------------------
@@ -278,7 +355,7 @@
 #	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
 #elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
-#	define CFG_ENV_OFFSET	0		/* beginning of NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
 #endif	/* CONFIG_CMD_NAND */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
new file mode 100644
index 0000000..b0c16f1
--- /dev/null
+++ b/include/configs/pdk7105.h
@@ -0,0 +1,380 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSC with JE2 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSC using JE2 */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD pdk7105
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* 9-pin D-type connector on STi7105-SDK-SB daughter board */
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
+#else
+	/* JN5, 6-way connector - QQQ NOT TESTED */
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041FTL
+ *    External PHY connected via the MII off-board 15x2 header.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_KSZ8041FTL			/* PHY = Micrel KSZ8041FTL */
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* rear (adjacent to RJ-45) */
+#	define CFG_USB1_BASE			0xfea00000	/* front (near corner) */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"PDK7105> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the PDK7105 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* S29GL01GP: 128MiB, 1024 blocks * 128KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* HY27UH08AG5B : 2GiB  8-bit, 16384 Blocks (128KiB+4KiB) of 64 Pages (2048+64) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 3d1d416..4ba5cd2 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -89,11 +89,13 @@ struct region_info_user {
 #define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
 
+#define MTD_NANDECC_MAX_OOBFREE	16	/* 16 for STMicroelectronics STi7xxx */
+#define MTD_NANDECC_MAX_ECCPOS	48	/* 48 for STMicroelectronics STi7xxx */
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
-	uint32_t oobfree[8][2];
-	uint32_t eccpos[32];
+	uint32_t oobfree[MTD_NANDECC_MAX_OOBFREE][2];
+	uint32_t eccpos[MTD_NANDECC_MAX_ECCPOS];
 };
 
 #endif /* __MTD_ABI_H__ */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 49ff80f..95f2bd1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -64,12 +64,20 @@ extern void nand_release (struct mtd_info *mtd);
 /* Read raw data from the device without ECC */
 extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
 
+/* read/write with ECC functions */
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
 
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
 #define NAND_MAX_OOBSIZE	64
+#define NAND_MAX_PAGESIZE	2048
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -135,6 +143,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_ECC_HW8_512	6
 /* Hardware ECC 12 byte ECC per 2048 Byte data */
 #define NAND_ECC_HW12_2048	7
+/* Hardware ECC 3 byte ECC per 128 Byte data */
+#define NAND_ECC_HW3_128	8
 
 /*
  * Constants for Hardware ECC
diff --git a/lib_sh/Makefile b/lib_sh/Makefile
index 5ee9b8e..e1b477f 100644
--- a/lib_sh/Makefile
+++ b/lib_sh/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(ARCH).a
 
 AOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
 
-COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o
+COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o sconsole.o
 
 OBJS	= $(AOBJS) $(COBJS)
 
diff --git a/lib_sh/sconsole.c b/lib_sh/sconsole.c
new file mode 100644
index 0000000..4408e86
--- /dev/null
+++ b/lib_sh/sconsole.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if	!defined(CONFIG_SH_SCIF_SERIAL) &&	\
+	!defined(CONFIG_STM_ASC_SERIAL) &&	\
+	!defined(CONFIG_STM_DTF_SERIAL)
+
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/lib_sh/sconsole.h b/lib_sh/sconsole.h
new file mode 100644
index 0000000..a387584
--- /dev/null
+++ b/lib_sh/sconsole.h
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+
+/*
+ * set the address and size of the SCONSOLE_BUFFER,
+ * if not explicitly defined in the config.h file.
+ */
+#ifndef CFG_SCONSOLE_ADDR
+#define CFG_SCONSOLE_ADDR		CFG_SDRAM_BASE
+#endif	/* CFG_SCONSOLE_ADDR */
+#ifndef CFG_SCONSOLE_SIZE
+#define CFG_SCONSOLE_SIZE		0x2000	/* 8 KiB */
+#endif	/* CFG_SCONSOLE_SIZE */
+
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/sh_config.mk b/sh_config.mk
index 30b7ecb..6129e52 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2008-10-13\""
+SH_IDENT_STRING="\"stm23-2009-04-27\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
