diff -urN u-boot-1.3.1/board/dgstation/common/chap_9.h u-boot-1.3.1_st2.3-32/board/dgstation/common/chap_9.h
--- u-boot-1.3.1/board/dgstation/common/chap_9.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/chap_9.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef __CHAP_9_H__
+#define __CHAP_9_H__
+
+//*************************************************************************
+// USB Protocol Layer
+//*************************************************************************
+
+//*************************************************************************
+// USB standard device requests
+//*************************************************************************
+void get_status(void);
+void clear_feature(void);
+void set_feature(void);
+void set_address(void);
+void get_descriptor(void);
+void get_configuration(void);
+void set_configuration(void);
+void get_interface(void);
+void set_interface(void);
+
+void reserved(void);
+
+#ifdef CONFIG_NET2270
+void Configuration_Handler (void);
+#endif
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/cmd_bootmenu.c u-boot-1.3.1_st2.3-32/board/dgstation/common/cmd_bootmenu.c
--- u-boot-1.3.1/board/dgstation/common/cmd_bootmenu.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/cmd_bootmenu.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,147 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+#ifndef CONFIG_DGS_FRONT
+#error "CONFIG_DGS_FRONT is needed with CONFIG_DGS_BOOTMENU."
+#endif
+
+#include <command.h>
+#include <asm/processor.h>
+#ifdef CFG_HUSH_PARSER
+#include <hush.h>
+#endif
+
+#include "front.h"
+#include "cmd_bootmenu.h"
+
+//#define DEBUG
+
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define MAX_KEY	60
+
+static int dgs_bootmenu( int timeout )	/* timeout in ms */
+{
+	int i, j;
+	int presskey[MAX_KEY];
+	int key;
+	char *cmd;
+	char *s;
+	long long start_tick;
+
+	/* essential env vars */
+	s = getenv( "menu_upgusbhost");
+	if( s == NULL)
+	{
+		setenv("menu_upgusbhost", "setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0");
+	}
+
+	memset( presskey, 0, sizeof(presskey) );
+
+	for( i=0; dgs_bootmenu_cmds[i].cmd!=NULL; i++ )
+		if( dgs_bootmenu_cmds[i].repeat > MAX_KEY )
+			dgs_bootmenu_cmds[i].repeat = MAX_KEY;
+
+	start_tick = get_ticks();
+
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if( tstc() )
+		{
+			if(getc()==0x1a) /* Ctrl-z to enter boot debug mode */
+			{
+				cmd = "menu_serialbreak";
+				goto exec_cmd;
+			}
+		}
+
+		if( front_tstc() )
+		{
+			key = front_getkey();
+
+			if( key != key_null )
+			{
+				fdebug( "get front key %d\n", key );
+				for( i=MAX_KEY-1; i>0; i-- )
+					presskey[i] = presskey[i-1];
+				presskey[0] = key;
+
+				for( i=0; dgs_bootmenu_cmds[i].cmd!=NULL; i++ )
+				{
+					if( dgs_bootmenu_cmds[i].repeat )
+					{
+						for( j=0; j<dgs_bootmenu_cmds[i].repeat; j++ )
+							if( presskey[j] != dgs_bootmenu_cmds[i].pattern[0] )
+								break;
+
+						if( j == dgs_bootmenu_cmds[i].repeat )
+						{
+							fdebug( "got cmd %d repeat %d\n",
+									i, dgs_bootmenu_cmds[i].repeat );
+							cmd = dgs_bootmenu_cmds[i].cmd;
+							goto exec_cmd;
+						}
+					}
+					else
+					{
+						for( j=0; dgs_bootmenu_cmds[i].pattern[j] != key_null; j++ )
+							if( presskey[j] != dgs_bootmenu_cmds[i].pattern[j] )
+								break;
+
+						if( dgs_bootmenu_cmds[i].pattern[j] == key_null )
+						{
+							fdebug( "got cmd %d no repeat\n", i );
+							cmd = dgs_bootmenu_cmds[i].cmd;
+							goto exec_cmd;
+						}
+					}
+				}
+
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+	cmd = "menu_timeout";
+
+exec_cmd:
+	s = getenv( cmd );
+	if( s )
+	{
+		fdebug( "excute \"%s\"\n", s );
+
+# ifndef CFG_HUSH_PARSER
+		run_command (s, 0);
+# else
+		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
+				    FLAG_EXIT_FROM_LOOP);
+# endif
+	}
+	else
+		fdebug( "no command.(%s)\n", cmd );
+
+	return 0;
+}
+
+static int do_bootmenu( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 500;
+
+	if( argc > 1 )
+		timeout = simple_strtoul( argv[1], NULL, 10 );
+
+	return dgs_bootmenu(timeout);
+}
+
+U_BOOT_CMD(
+		bootmenu, 12, 0, do_bootmenu,
+		"bootmenu- check boot key.\n",
+		"bootmenu timeout(ms)\n"
+		" check user input and excute the menu.\n"
+		);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/cmd_bootmenu.h u-boot-1.3.1_st2.3-32/board/dgstation/common/cmd_bootmenu.h
--- u-boot-1.3.1/board/dgstation/common/cmd_bootmenu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/cmd_bootmenu.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef _CMD_BOOTMENU_H
+#define _CMD_BOOTMENU_H
+
+#include "front.h"
+
+typedef struct
+{
+	enum front_key pattern[3];
+	int repeat;
+	char *cmd;
+} dgs_bootmenu_t;
+
+extern dgs_bootmenu_t dgs_bootmenu_cmds[];
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/eeprom_db.c u-boot-1.3.1_st2.3-32/board/dgstation/common/eeprom_db.c
--- u-boot-1.3.1/board/dgstation/common/eeprom_db.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/eeprom_db.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,477 @@
+
+#include <common.h>
+
+#ifdef CONFIG_DGS_EEPROM_DB
+
+#include <command.h>
+#include "common/eeprom_db.h"
+
+#ifdef CFG_I2C_EEPROM_ADDR
+#define CFG_EEPROM_ADD		CFG_I2C_EEPROM_ADDR
+#else
+#define CFG_EEPROM_ADD		0
+#endif
+
+static struct
+{
+	db_key key;
+	char *name;
+} db_name_tbl[] =
+{
+	{ db_key_null,		"null" },
+	{ db_key_end,		"end" },
+	{ db_key_ethaddr,	"ethaddr" },
+	{ db_key_prodnum,	"prodnum" },
+	{ db_key_vol,		"volume" },
+	{ db_key_lch,		"lastch" },
+	{ db_key_pcbver,	"pcbver" },
+	{ db_key_tvmode,	"tvmode" },
+	{ db_key_tuner,		"tuner" },
+	{ db_key_time,		"time" },
+};
+#define db_name_tbl_size	(sizeof(db_name_tbl)/sizeof(db_name_tbl[0]))
+
+static int get_keyname( db_key key, char **name )
+{
+	int a;
+
+	for( a=0; a<db_name_tbl_size; a++ )
+	{
+		if( db_name_tbl[a].key == key )
+		{
+			*name = db_name_tbl[a].name;
+			return 0;
+		}
+	}
+
+	*name = "unknown";
+
+	return 1;
+}
+
+int get_keyvalue( const char *name, db_key *key )
+{
+	int a;
+
+	for( a=0; a<db_name_tbl_size; a++ )
+	{
+		if( !strcmp(db_name_tbl[a].name,name) )
+		{
+			*key = db_name_tbl[a].key;
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int read_item( int offset, db_key *key, char *buf, int *buflen )
+{
+	int rcode;
+	db_item item;
+
+	if( offset >= CFG_EEPROM_SIZE - DB_HEADE_SIZE )
+		return -1;
+
+	rcode = eeprom_read( CFG_EEPROM_ADD, offset, (unsigned char*)&item, sizeof(item) );
+	if( rcode )
+		return -1;
+
+	if( item.len > 0 && buf != NULL )
+	{
+		if( *buflen > item.len )
+			*buflen = item.len;
+
+		rcode = eeprom_read( CFG_EEPROM_ADD, offset + DB_HEADE_SIZE, buf, *buflen );
+		if( rcode )
+			return -1;
+
+		buf[*buflen] = 0;
+	}
+
+	*key = item.key;
+
+	return item.len;
+}
+
+int search_item( int offset, db_key key, char *buf, int *buflen, int *offret, int *lenret )
+{
+	int rcode;
+	int len;
+	db_key keytmp;
+
+	do
+	{
+		len = read_item( offset, &keytmp, NULL, NULL );
+		if( len < 0 )
+			return 1;
+
+		if( keytmp == key )
+		{
+			/* found it */
+			if( offret != NULL )
+				*offret = offset;
+			if( lenret != NULL )
+				*lenret = len;
+
+			if( len > 0 && buf != NULL )
+			{
+				if( *buflen > len )
+					*buflen = len;
+
+				rcode = eeprom_read(
+						CFG_EEPROM_ADD,
+						offset + DB_HEADE_SIZE,
+						buf,
+						*buflen );
+				if( rcode )
+					return 1;
+
+				buf[*buflen] = 0;
+			}
+
+			return 0;
+		}
+
+		offset += DB_HEADE_SIZE + len;
+	}
+	while( keytmp != db_key_end );
+
+	/* we coundn`t find the key.
+	 * return the end key
+	 */
+	if( offret != NULL )
+		*offret = offset - (DB_HEADE_SIZE + len);
+	if( lenret != NULL )
+		*lenret = len;
+
+	return 2;
+}
+
+static int save_item( int offset, db_key key, const char *buf, int len )
+{
+	int rcode;
+	db_item item;
+
+	/* write item data */
+	if( buf != NULL && len != 0 )
+	{
+		rcode = eeprom_write(
+				CFG_EEPROM_ADD,
+				offset+DB_HEADE_SIZE,
+				(unsigned char*)buf,
+				len );
+		if( rcode )
+			return rcode;
+	}
+
+	/* write item header */
+	item.key = key;
+	item.len = len;
+	rcode = eeprom_write( CFG_EEPROM_ADD, offset, (unsigned char*)&item, sizeof(item) );
+
+	return rcode;
+}
+
+static int del_item( db_key key )
+{
+	int offset;
+	db_key keytmp;
+	int len;
+
+	int last_offset;
+	db_key last_keytmp;
+	int last_len;
+
+	int next_offset;
+	db_key next_keytmp;
+	int next_len;
+
+	/* find the item */
+	offset = DB_MAGIC_SIZE;
+	last_offset = 0;
+	last_keytmp = db_key_end;
+	last_len = 0;
+	do
+	{
+		len = read_item( offset, &keytmp, NULL, NULL );
+		if( len < 0 )
+			return -1;
+
+		if( keytmp == key )
+		{
+			/* merge with next one if it is null item */
+			next_offset = offset + DB_HEADE_SIZE + len;
+			next_len = read_item( next_offset, &next_keytmp, NULL, NULL );
+			if( next_len >= 0 )
+			{
+				if( next_keytmp == db_key_null )
+					len += DB_HEADE_SIZE + next_len;
+			}
+
+			/* merge with privious one if it was null item */
+			if( last_keytmp == db_key_null )
+			{
+				offset = last_offset;
+				len += last_len + DB_HEADE_SIZE;
+			}
+
+			return save_item( offset, db_key_null, NULL, len );
+		}
+
+		last_offset = offset;
+		last_keytmp = keytmp;
+		last_len = len;
+
+		offset += DB_HEADE_SIZE + len;
+	}
+	while( key != db_key_end );
+
+	return 0;
+}
+
+int add_item( db_key key, const char *data )
+{
+	int data_len;
+	int rcode;
+
+	int offset;
+	int len;
+
+	if( data )
+		data_len = strlen( data );
+	else
+		data_len = 0;
+
+	/* delete same key */
+	del_item( key );
+
+	/* search enough space to store the item */
+	offset = DB_MAGIC_SIZE;
+	do
+	{
+		rcode = search_item( offset, db_key_null, NULL, NULL, &offset, &len );
+		if( rcode == 1 )	/* device error */
+			return 1;
+		if( rcode == 2 )	/* it`s the end */
+			break;
+
+		if( len == data_len || len >= data_len + DB_HEADE_SIZE )
+		{
+			rcode = save_item( offset, key, data, data_len );
+			if( rcode )
+				return rcode;
+
+			if( len > data_len )
+				rcode = save_item(
+						offset + DB_HEADE_SIZE + data_len,
+						db_key_null,
+						NULL,
+						len - data_len - DB_HEADE_SIZE
+						);
+
+			return rcode;
+		}
+
+		offset += DB_HEADE_SIZE + len;
+	}
+	while( 1 );
+
+	/* store at the end */
+	rcode = save_item( offset, key, data, data_len );
+	if( rcode )
+	{
+		save_item( offset, db_key_end, NULL, 0 );
+		return 1;
+	}
+	else
+	{
+		offset += DB_HEADE_SIZE + data_len;
+
+		rcode = save_item( offset, db_key_end, NULL, 0 );
+	}
+
+	return rcode;
+}
+
+static int do_edb( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int rcode;
+	int try = 0;
+	unsigned short magic;
+
+	/* read magic */
+	do 
+	{
+		rcode = eeprom_read( CFG_EEPROM_ADD, 0, (unsigned char*)&magic, sizeof(magic) );
+		if( rcode ) goto failed;
+		magic = be16_to_cpu( magic );
+
+		if(magic == DB_MAGIC) break;
+
+		udelay(500000);
+	} while(try++ < 5);
+
+	if( magic != DB_MAGIC )
+	{
+		/* if it is not initialized */
+		printf( "initialize empty eeprom db.(%04X)\n", magic);
+
+		/* set the final key */
+		rcode = save_item( DB_MAGIC_SIZE, db_key_end, NULL, 0 );
+		if( rcode )
+			goto failed;
+
+		/* initialize magic */
+		magic = cpu_to_be16( DB_MAGIC );
+		rcode = eeprom_write( CFG_EEPROM_ADD, 0, (unsigned char*)&magic, sizeof(magic) );
+		if( rcode )
+			goto failed;
+	}
+
+	if( argc > 1 )
+	{
+		db_key key;
+
+		if( !strcmp(argv[1],"exec") )
+		{
+		}
+		else if( !strcmp(argv[1],"toenv") && argc > 2 )
+		{
+			rcode = get_keyvalue( argv[2], &key );
+			if( rcode )
+				puts( "unknown key.\n" );
+			else
+			{
+				char buf[256];
+				int buflen;
+				int res = 0;
+
+				buflen = 255;
+				rcode = search_item( DB_MAGIC_SIZE, key, buf, &buflen, NULL, NULL );
+				if( rcode == 1 )
+					goto failed;
+				if( rcode == 2 )
+				{
+					printf( "no such a key.(%s)\n", argv[2] );
+					res = 1;
+				}
+				else
+				{
+					if( buflen != 0 && key != db_key_null)
+					{
+						if(buflen<CONFIG_DGS_ETHADDR_HEADER_LEN || 
+								memcmp(buf, CONFIG_DGS_ETHADDR, CONFIG_DGS_ETHADDR_HEADER_LEN))
+						{
+							printf("Invalid mac address.\n");
+							res = 1;
+						}
+						else
+						{
+							setenv( argv[2], buf );
+							res = 0;
+						}
+					}
+					else
+					{
+						printf( "no data on the key.(%s)\n", argv[2] );
+						res = 1;
+					}
+				}
+
+				if( res )
+				{
+					sprintf(buf, "00:13:18:00:00:%02X", get_ticks()%256);
+					setenv( argv[2], buf );
+				}
+
+				return res;
+			}
+		}
+		else if( !strcmp(argv[1],"add") && argc > 2 )
+		{
+			rcode = get_keyvalue( argv[2], &key );
+			if( rcode )
+				puts( "unknown key.\n" );
+			else
+			{
+				if( argc > 3 )
+					rcode = add_item( key, argv[3] );
+				else
+					rcode = add_item( key, argv[3] );
+
+				if( rcode )
+					goto failed;
+
+				return rcode;
+			}
+		}
+		else if( !strcmp(argv[1],"del") && argc > 2 )
+		{
+			rcode = get_keyvalue( argv[2], &key );
+			if( rcode )
+				puts( "unknown key.\n" );
+			else
+			{
+				rcode = del_item( key );
+
+				if( rcode )
+					goto failed;
+
+				return rcode;
+			}
+		}
+
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+	else
+	{
+		db_key key;
+
+		/* dump all of database */
+		int offset = DB_MAGIC_SIZE;
+
+		printf( "offset\tkey\tlen\tdata\n" );
+		do
+		{
+			char *name;
+			char buf[256];
+			int buflen;
+
+			buf[0] = 0;
+			buflen = 255;
+			rcode = read_item( offset, &key, buf, &buflen );
+			if( rcode < 0 )
+			{
+				rcode = 1;
+				goto failed;
+			}
+			get_keyname( key, &name );
+
+			printf( "%d\t%s\t%d\t%s\n", offset, name, rcode, (key==db_key_null)?"":buf );
+
+			offset += DB_HEADE_SIZE + rcode;
+		}
+		while( key != db_key_end );
+	}
+
+	return 0;
+
+failed:
+	printf( "failed.\n" );
+	return rcode;
+}
+
+
+U_BOOT_CMD(
+		edb, 4, 0, do_edb,
+		"edb     - manage database on eeprom\n",
+		"add key data\n"
+		"edb del key\n"
+		"              - add/del database key.\n"
+		"edb toenv key - set the key to environment.\n"
+		"edb           - display all database key.\n"
+	  );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/eeprom_db.h u-boot-1.3.1_st2.3-32/board/dgstation/common/eeprom_db.h
--- u-boot-1.3.1/board/dgstation/common/eeprom_db.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/eeprom_db.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,33 @@
+#ifndef _EEPROM_DB_H
+#define _EEPROM_DB_H
+
+#define DB_MAGIC		0x1234		/* magic */
+
+typedef enum
+{
+	db_key_null = 0,
+	db_key_end,
+	db_key_ethaddr,
+	db_key_prodnum,
+	db_key_vol,
+	db_key_lch,
+	db_key_pcbver,
+	db_key_tvmode,
+	db_key_tuner,
+	db_key_time,
+} db_key;
+
+typedef struct
+{
+	unsigned short key;
+	unsigned short len;
+	unsigned char data[0];
+} db_item;
+
+#define DB_MAGIC_SIZE		sizeof(unsigned short)
+#define DB_HEADE_SIZE		sizeof(db_item)
+
+
+#endif
+
+
diff -urN u-boot-1.3.1/board/dgstation/common/flash.c u-boot-1.3.1_st2.3-32/board/dgstation/common/flash.c
--- u-boot-1.3.1/board/dgstation/common/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/flash.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,799 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Modified 4/5/2001
+ * Wait for completion of each sector erase command issued
+ * 4/5/2001
+ * Chris Hallinan - DS4.COM, Inc. - clh@net1plus.com
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+static int write_word (flash_info_t *info, ulong dest, ulong data);
+
+unsigned int flash_progress_now;
+unsigned int flash_progress_total;
+
+#define ADDR0           0x5555
+#define ADDR1           0x2aaa
+#define FLASH_WORD_SIZE unsigned short
+
+#ifdef FLASH_DEBUG
+#define fdebug(fmt, arg...) printf( fmt, ##arg )
+#else
+#define fdebug(fmt, arg...) do{}while(0)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Flash partition for JFFS2
+ */
+#ifdef CFG_JFFS_CUSTOM_PART
+#include <jffs2/load_kernel.h>
+#include "common/flash_img_info.h"
+
+extern flash_img_info_t dgs_flash_imgs[];
+
+static struct part_info part;
+
+struct part_info* jffs2_part_info(int part_num)
+{
+	int i;
+
+	if(part.usr_priv==(void*)1)
+		return &part;
+
+	memset(&part, 0, sizeof(part));
+
+	for( i=0; i<part_num; i++ )
+	{
+		if( !dgs_flash_imgs[i].name )
+		{
+			printf( "out of partition table.(%d)\n", part_num );
+			return NULL;
+		}
+	}
+	part.offset = dgs_flash_imgs[i].start;
+	part.size = dgs_flash_imgs[i].size;
+
+	printf( "partition \"%s\" selected.(%08x,%06x)\n",
+			dgs_flash_imgs[i].name,
+			dgs_flash_imgs[i].start,
+			dgs_flash_imgs[i].size );
+
+	/* unused in current jffs2 loader */
+	part.erasesize = 0;
+
+	/* Mark the struct as ready */
+	part.usr_priv=(void*)1;
+
+	return &part;
+}
+
+#endif
+
+
+/*-----------------------------------------------------------------------
+ */
+
+unsigned long flash_init (void)
+{
+	int i;
+	unsigned long size=0;
+
+	/* Init: no FLASHes known */
+	for (i=0; i<CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	flash_get_size((vu_long *)FLASH_BASE0_PRELIM, &flash_info[0]);
+	if (flash_info[0].flash_id == FLASH_UNKNOWN)
+		printf ("## Unknown FLASH on Bank 0\n");
+
+#if CFG_MAX_FLASH_BANKS > 1
+	flash_get_size((vu_long *)FLASH_BASE1_PRELIM, &flash_info[1]);
+	if (flash_info[1].flash_id == FLASH_UNKNOWN)
+		printf ("## Unknown FLASH on Bank 1\n");
+#elif CFG_MAX_FLASH_BANKS > 2
+#error "unsupported flash banks..."
+#endif
+
+	for( i=0,size=0; i<CFG_MAX_FLASH_BANKS; i++ )
+		size += flash_info[i].size;
+
+	return size;
+}
+
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info  (flash_info_t *info)
+{
+	int i;
+	int k;
+	int size;
+	int erased;
+	volatile unsigned long *flash;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+#ifdef CFG_FLASH_SUP_AMD
+		case FLASH_MAN_AMD:	printf ("AMD ");		break;
+#endif
+#ifdef CFG_FLASH_SUP_SPA
+		case FLASH_MAN_SPA:	printf ("Spansion ");		break;
+#endif
+#ifdef CFG_FLASH_SUP_FUJ
+		case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+#endif
+#ifdef CFG_FLASH_SUP_SST
+		case FLASH_MAN_SST:	printf ("SST ");		break;
+#endif
+#ifdef CFG_FLASH_SUP_STM
+		case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+#ifdef CFG_FLASH_SUP_MX
+		case FLASH_MAN_MX:	printf ("MX ");			break;
+#endif
+		default:		printf ("Unknown Vendor ");	break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+#ifdef CFG_FLASH_SUP_AMD_F040B
+		case FLASH_AM040:	printf ("AM29F040 (512 Kbit, uniform sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV400T
+		case FLASH_AM400T:	printf ("AM29LV400T (4 Mbit, top boot sector)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV400B
+		case FLASH_AM400B:	printf ("AM29LV400B (4 Mbit, bottom boot sect)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV800B
+		case FLASH_AM800B:	printf ("AM29LV800B (8 Mbit, bottom boot sect)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV800T
+		case FLASH_AM800T:	printf ("AM29LV800T (8 Mbit, top boot sector)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV160B
+		case FLASH_AM160B:	printf ("AM29LV160B (16 Mbit, bottom boot sect)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV160T
+		case FLASH_AM160T:	printf ("AM29LV160T (16 Mbit, top boot sector)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV320B
+		case FLASH_AM320B:	printf ("AM29LV320B (32 Mbit, bottom boot sect)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_AMD_LV320T
+		case FLASH_AM320T:	printf ("AM29LV320T (32 Mbit, top boot sector)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_SST_xF800A
+		case FLASH_SST800A:	printf ("SST39LF/VF800 (8 Mbit, uniform sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_SST_xF160A
+		case FLASH_SST160A:	printf ("SST39LF/VF160 (16 Mbit, uniform sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_STM_29W320DB
+		case FLASH_STMW320DB:	printf ("STM29W320DB (32 Mbit, bottom sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_STM_29W640DT	
+		case FLASH_STMW640DT:	printf("STM29W640DT (64M bit, top sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_MX_29LV320AB
+		case FLASH_MXLV320B:	printf ("MX29LV320AB (32 Mbit, bottom sector size)\n");
+				break;
+#endif
+#ifdef CFG_FLASH_SUP_MX_29LV640MT
+		case FLASH_MXLV640MT:	printf ("MX29LV640MT (64 Mbit, top sector size)\n");
+					break;
+#endif			
+#ifdef CFG_FLASH_SUP_MX_29LV640BT
+		case FLASH_MXLV640BT:	printf ("MX29LV640BT (64 Mbit, top sector size)\n");
+					break;
+#endif			
+#ifdef CFG_FLASH_SUP_SPA_S29GL064M
+		case FLASH_SPA064MR3:	printf ("SPA29GL064MR3 (64 Mbit, top sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_SPA_S29GL064MR4
+		case FLASH_SPA064MR4:	printf ("SPA29GL064MR4 (64 Mbit, bottom sector size)\n");
+					break;
+#endif
+#ifdef CFG_FLASH_SUP_SPA_S29GL128N
+		case FLASH_SPA128N:	printf ("SPA29GL128N (128 Mbit, uniform)\n");
+					break;
+
+#endif
+#ifdef CFG_FLASH_SUP_SPA_S29GL256N
+		case FLASH_SPA256N:	printf ("SPA29GL256N (256 Mbit, uniform)\n");
+					break;
+
+#endif
+		default:		printf ("Unknown Chip Type\n");
+					break;
+	}
+
+	printf ("  Size: %ld KB in %d Sectors\n",
+			info->size >> 10, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i=0; i<info->sector_count; ++i) {
+		/*
+		 * Check if whole sector is erased
+		 */
+		if (i != (info->sector_count-1))
+			size = info->start[i+1] - info->start[i];
+		else
+			size = info->start[0] + info->size - info->start[i];
+		erased = 1;
+		flash = (volatile unsigned long *)info->start[i];
+		size = size >> 2;        /* divide by 4 for longword access */
+		for (k=0; k<size; k++)
+		{
+			if (*flash++ != 0xffffffff)
+			{
+				erased = 0;
+				break;
+			}
+		}
+
+		if ((i % 5) == 0)
+			printf ("\n   ");
+			printf (" %08lX%s%s",
+			info->start[i],
+			erased ? " E" : "  ",
+			info->protect[i] ? "RO " : "   "
+		);
+	}
+	printf ("\n");
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	short i;
+	FLASH_WORD_SIZE manufacture_id;
+	FLASH_WORD_SIZE device_id1, device_id2, device_id3;
+	ulong base = (ulong)addr;
+	volatile FLASH_WORD_SIZE *addr2 = (FLASH_WORD_SIZE *)addr;
+	int fail = 0;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr2[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+	addr2[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+	addr2[ADDR0] = (FLASH_WORD_SIZE)0x00900090;
+	manufacture_id = addr2[0];
+
+	/* Write auto select command: read device ID */
+	addr2[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+	addr2[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+	addr2[ADDR0] = (FLASH_WORD_SIZE)0x00900090;
+	device_id1 = addr2[0x02>>1];
+	device_id2 = addr2[0x1c>>1];
+	device_id3 = addr2[0x1e>>1];
+
+	switch (manufacture_id)
+	{
+#if defined(CFG_FLASH_SUP_MX)
+		case (FLASH_WORD_SIZE)MX_MANUFACT :
+			info->flash_id = FLASH_MAN_MX;
+
+			if(0) 
+			{
+				// dummy
+			}
+#if defined(CFG_FLASH_SUP_MX_29LV640MT)
+			else if(device_id1 == (FLASH_WORD_SIZE)MX_ID_LV640MT &&	/* 29LV640MT */
+					device_id2 == 0x2210 &&		/* must be 0x10 */
+					device_id3 == 0x2201)		/* TOP : 0x01 */
+			{
+				info->flash_id += FLASH_MXLV640MT;
+				info->sector_count = 135;
+				info->size = 0x00800000;
+
+				/* set sector offset for top boot block type */
+				for(i=0; i<127;i++)
+					info->start[i] = base + i*0x10000;
+				for(; i<info->sector_count; i++)
+					info->start[i] = base + 0x7f0000  + (i-127)*0x2000;
+			}
+#endif
+#if defined(CFG_FLASH_SUP_MX_29LV640DT)
+			else if(device_id1 == (FLASH_WORD_SIZE)MX_ID_LV640DT)
+			{
+				info->flash_id += FLASH_MXLV640DT;
+				info->sector_count = 135;
+				info->size = 0x00800000;
+
+				/* set sector offset for top boot block type */
+				for(i=0; i<127;i++)
+					info->start[i] = base + i*0x10000;
+				for(; i<info->sector_count; i++)
+					info->start[i] = base + 0x7f0000  + (i-127)*0x2000;
+			}
+#endif
+			else
+			{
+				fail++;
+			}
+			break;
+#endif
+#if defined(CFG_FLASH_SUP_STM)
+		case (FLASH_WORD_SIZE)STM_MANUFACT:
+			info->flash_id = FLASH_MAN_STM;
+
+			if(0)
+			{
+
+			}
+#if defined(CFG_FLASH_SUP_STM_29W640DT)
+			else if(device_id1 == (FLASH_WORD_SIZE)STM_ID_29W640DT)
+			{
+				info->flash_id += FLASH_STMW640DT;
+				info->sector_count = 135;
+				info->size = 0x00800000;
+
+				/* set sector offset for top boot block type */
+				for(i=0; i<127;i++)
+					info->start[i] = base + i*0x10000;
+				for(; i<info->sector_count; i++)
+					info->start[i] = base + 0x7f0000  + (i-127)*0x2000;
+			}
+#endif
+			else
+			{
+				fail++;
+			}
+
+			break;
+#endif
+#if defined(CFG_FLASH_SUP_SPA)
+		case (FLASH_WORD_SIZE)SPA_MANUFACT :
+			info->flash_id = FLASH_MAN_SPA;
+
+			if(0)
+			{
+
+			}
+#if defined(CFG_FLASH_SUP_SPA_S29GL064MR4)
+			else if(device_id1 == (FLASH_WORD_SIZE)SPA_ID_S29GL064M &&
+					device_id2 == 0x2210 &&
+					device_id3 == 0x2200 ) /* BOTTOM : 0x00 */
+			{
+				info->flash_id += FLASH_SPA064MR4;
+				info->sector_count = 135;
+				info->size = 0x00800000;
+
+				for(i=0; i<8; i++)
+					info->start[i] = base + i*0x2000;
+				for(; i<info->sector_count; i++)
+					info->start[i] = base + 8*0x2000 + (i-8)*0x10000;
+			}
+#endif
+#if defined(CFG_FLASH_SUP_SPA_S29GL128N)
+			else if(device_id1 == (FLASH_WORD_SIZE)SPA_ID_S29GL128N &&
+					device_id2 == 0x2221 &&
+					device_id3 == 0x2201)
+			{
+				info->flash_id += FLASH_SPA128N;
+				info->sector_count = 128;
+				info->size = 0x01000000;
+
+				for(i=0; i<info->sector_count; i++)
+					info->start[i] = base + 0x20000*i;
+			}
+#endif
+#if defined(CFG_FLASH_SUP_SPA_S29GL256N)
+			else if(device_id1 == (FLASH_WORD_SIZE)SPA_ID_S29GL256N &&
+					device_id2 == 0x2222 &&
+					device_id3 == 0x2201)
+			{
+				info->flash_id += FLASH_SPA256N;
+				info->sector_count = 256;
+				info->size = 0x02000000;
+
+				for(i=0; i<info->sector_count; i++)
+					info->start[i] = base + 0x20000*i;
+			}
+#endif
+			else
+			{
+				fail++;
+			}
+			break;
+#endif
+		default :
+			fail++;
+	}
+
+
+	if(fail)
+	{
+		printf( "unknown.(manufacture:%04x, device:%04x, %04x, %04x)\n", 
+				manufacture_id, 
+				device_id1,
+				device_id2,
+				device_id3);
+		info->flash_id = FLASH_UNKNOWN;
+		return (0);			/* => no or unknown flash */
+	}
+
+	/* check for protected sectors */
+	for (i = 0; i < info->sector_count; i++) {
+		/* read sector protection at sector address, (A7 .. A0) = 0x02 */
+		/* D0 = 1 if protected */
+		addr2 = (volatile FLASH_WORD_SIZE *)(info->start[i]);
+		addr2[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+		addr2[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+		addr2[ADDR0] = (FLASH_WORD_SIZE)0x00900090;
+		info->protect[i] = addr2[2] & 1;
+	}
+
+	/*
+	 * Prevent writes to uninitialized FLASH.
+	 */
+	if (info->flash_id != FLASH_UNKNOWN) {
+		addr2 = (FLASH_WORD_SIZE *)info->start[0];
+		*addr2 = (FLASH_WORD_SIZE)0x00F000F0;	/* reset bank */
+	}
+
+	return (info->size);
+}
+
+int wait_for_DQ7(flash_info_t *info, int sect)
+{
+	ulong start, now, last;
+	volatile FLASH_WORD_SIZE *addr = (FLASH_WORD_SIZE *)(info->start[sect]);
+	
+	
+	start = get_timer (0);
+	last  = start;
+	while ((addr[0] & (FLASH_WORD_SIZE)0x00800080) != (FLASH_WORD_SIZE)0x00800080) {
+		if ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {
+			printf ("Timeout\n");
+			return -1;
+		}
+		/* show that we're waiting */
+		if ((now - last) > 1000000) {  /* every second */
+			putc ('.');
+
+			last = now;
+		}
+	}
+	return 0;
+}
+
+int wait_for_Data(flash_info_t *info, int sect)
+{
+	ulong start, now, last;
+	FLASH_WORD_SIZE dat;
+	volatile FLASH_WORD_SIZE *addr = (FLASH_WORD_SIZE *)(info->start[sect]);
+	
+	
+	start = get_timer (0);
+	last  = start;
+	while ((dat=addr[0]) != 0xffff) {
+		if ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {
+			printf ("Timeout\n");
+			return -1;
+		}
+		/* show that we're waiting */
+		if ((now - last) > 1000000) {  /* every second */
+			putc ('.');
+			//fdebug(".(0x%X)", dat);
+			last = now;
+		}
+	}
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	volatile FLASH_WORD_SIZE *addr = (FLASH_WORD_SIZE *)(info->start[0]);
+	volatile FLASH_WORD_SIZE *addr2;
+	int flag, prot, sect, l_sect;
+	int i;
+
+	/*
+	 * announce progress of erase.
+	 */
+	flash_progress_now = 0;
+	flash_progress_total = s_last-s_first+1;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	l_sect = -1;
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			/* Disable interrupts which might cause a timeout here */
+			flag = disable_interrupts();
+
+			addr2 = (FLASH_WORD_SIZE *)(info->start[sect]);
+			fdebug("Erasing sector %p\n", addr2);	/* CLH */
+
+			if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) {
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+				addr[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00800080;
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+				addr[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+				addr2[0] = (FLASH_WORD_SIZE)0x00500050;  /* block erase */
+				for (i=0; i<50; i++)
+					udelay(1000);  /* wait 1 ms */
+			} else {
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+				addr[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00800080;
+				addr[ADDR0] = (FLASH_WORD_SIZE)0x00AA00AA;
+				addr[ADDR1] = (FLASH_WORD_SIZE)0x00550055;
+				addr2[0] = (FLASH_WORD_SIZE)0x00300030;  /* sector erase */
+			}
+			l_sect = sect;
+			/*
+			 * Wait for each sector to complete, it's more
+			 * reliable.  According to AMD Spec, you must
+			 * issue all erase commands within a specified
+			 * timeout.  This has been seen to fail, especially
+			 * if printf()s are included (for debug)!!
+			 */
+			//wait_for_DQ7(info, sect);
+			wait_for_Data(info,sect);
+
+			/* set progress */
+			flash_progress_now = sect - s_first + 1;
+
+			/* re-enable interrupts if necessary */
+			if (flag)
+				enable_interrupts();
+		}
+	}
+
+	/* wait at least 80us - let's wait 1 ms */
+	udelay (1000);
+
+#if 0
+	/*
+	 * We wait for the last triggered sector
+	 */
+	if (l_sect < 0)
+		goto DONE;
+	wait_for_DQ7(info, l_sect);
+
+DONE:
+#endif
+	/* reset to read mode */
+	addr = (FLASH_WORD_SIZE *)info->start[0];
+	addr[0] = (FLASH_WORD_SIZE)0x00F000F0;	/* reset bank */
+
+	printf ("\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp, data;
+	int i, l, rc;
+	unsigned long total_cnt = cnt;
+
+	wp = (addr & ~3);	/* get lower word aligned address */
+
+	/*
+	 * announce progress of writing... flash.
+	 */
+	flash_progress_now = 0;
+	flash_progress_total = cnt;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i=0, cp=wp; i<l; ++i, ++cp) 
+		{
+			data = (data>>8) | ((ulong)(*(uchar *)cp)<<24);
+		}
+		for (; i<4 && cnt>0; ++i) 
+		{
+			data = (data >> 8) | ((ulong)(*src++)<<24);
+			--cnt;
+			++cp;
+		}
+		for (; cnt==0 && i<4; ++i, ++cp) 
+		{
+			data = (data >> 8) | ((ulong)(*(uchar *)cp)<<24);
+		}
+
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 4;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 4) 
+	{
+		data = 0;
+		for (i=0; i<4; ++i) 
+		{
+			data = (data >> 8) | ((ulong)(*src++)<<24);
+		}
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp  += 4;
+		cnt -= 4;
+
+		/* set progress */
+		flash_progress_now = total_cnt - cnt;
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i=0, cp=wp; i<4 && cnt>0; ++i, ++cp) 
+	{
+		data = (data >> 8) | ((ulong)(*src++)<<24);
+		--cnt;
+	}
+	for (; i<4; ++i, ++cp) {
+		data = (data >> 8) | ((ulong)(*(uchar *)cp)<<24);
+	}
+
+	return (write_word(info, wp, data));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t * info, ulong dest, ulong data)
+{
+	volatile FLASH_WORD_SIZE *addr2 = (FLASH_WORD_SIZE *) (info->start[0]);
+	volatile FLASH_WORD_SIZE *dest2 = (FLASH_WORD_SIZE *) dest;
+	volatile FLASH_WORD_SIZE *data2 = (FLASH_WORD_SIZE *) & data;
+	ulong start;
+	int i;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*((volatile FLASH_WORD_SIZE *) dest) &
+	    (FLASH_WORD_SIZE) data) != (FLASH_WORD_SIZE) data) {
+		printf( "is not erased... 0x%08x:0x%x\n", (unsigned int)dest, *((volatile FLASH_WORD_SIZE*)dest) );
+		return 2;
+	}
+
+	for (i = 0; i < 4 / sizeof (FLASH_WORD_SIZE); i++) 
+	{
+		int flag;
+
+		/* Disable interrupts which might cause a timeout here */
+		flag = disable_interrupts ();
+
+		addr2[ADDR0] = (FLASH_WORD_SIZE) 0x00AA00AA;
+		addr2[ADDR1] = (FLASH_WORD_SIZE) 0x00550055;
+		addr2[ADDR0] = (FLASH_WORD_SIZE) 0x00A000A0;
+
+		dest2[i] = data2[i];
+
+		/* re-enable interrupts if necessary */
+		if (flag)
+			enable_interrupts ();
+
+		/* data polling for D7 */
+		start = get_timer (0);
+		while ((dest2[i] & (FLASH_WORD_SIZE) 0x00800080) != (data2[i] & (FLASH_WORD_SIZE) 0x00800080)) 
+		{
+
+			if (get_timer (start) > CFG_FLASH_WRITE_TOUT) 
+			{
+				fdebug("write time out\n");
+				return (1);
+			}
+		}
+	}
+
+	return (0);
+}
+
+/*-----------------------------------------------------------------------
+ */
diff -urN u-boot-1.3.1/board/dgstation/common/flash_img_info.h u-boot-1.3.1_st2.3-32/board/dgstation/common/flash_img_info.h
--- u-boot-1.3.1/board/dgstation/common/flash_img_info.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/flash_img_info.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FLASH_IMG_INFO_H
+#define _FLASH_IMG_INFO_H
+
+typedef struct
+{
+	const char *name;
+	unsigned int start;
+	unsigned int size;
+} flash_img_info_t;
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/front.c u-boot-1.3.1_st2.3-32/board/dgstation/common/front.c
--- u-boot-1.3.1/board/dgstation/common/front.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/front.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,91 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+
+#include "front.h"
+
+//#define DEBUG
+
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+
+int front_waitkey( int *keys, int timeout )
+{
+	unsigned long long end;
+	int key;
+	int a;
+
+	end = get_ticks() + timeout*get_tbclk();
+
+	while( 1 )
+	{
+		if( timeout && get_ticks() > end )
+			break;
+
+		key = front_getkey();
+		if( key == key_null )
+			continue;
+
+		for( a=0; keys[a]!=key_null; a++ )
+		{
+			if( key == keys[a] )
+			{
+				while( 1 )
+				{
+					if( key == key_release || key == key_front_release )
+						return keys[a];
+					key = front_getkey();
+				}
+			}
+		}
+	}
+
+	return -1;
+}
+
+int front_singlekey( int timeout )
+{
+	unsigned long long end;
+	int key, oldkey = key_null;
+
+	end = get_ticks() + timeout*get_tbclk();
+
+	while( 1 )
+	{
+		if( timeout && get_ticks() > end )
+			return key_null;
+
+		key = front_getkey();
+		if( key == key_null )
+			continue;
+
+		if( oldkey != key_null && ( key == key_release || key == key_front_release ) )
+			return oldkey;
+
+		oldkey = key;
+	}
+}
+
+int do_front_puts( cmd_tbl_t *cmd, int flag, int argc, char *argv[] )
+{
+	if( argc > 1 )
+		front_puts( argv[1] );
+	else
+		front_puts( "" );
+
+	return 0;
+}
+
+U_BOOT_CMD(
+		front_puts, 10, 0, do_front_puts,
+		"front_puts- put string to front display.\n",
+		"put string to front VFD.\n" );
+
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/front.h u-boot-1.3.1_st2.3-32/board/dgstation/common/front.h
--- u-boot-1.3.1/board/dgstation/common/front.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/front.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,53 @@
+#ifndef _DGS_FRONT_H
+#define _DGS_FRONT_H
+
+extern int front_waitkey( int *keys, int timeout );
+extern int front_singlekey( int timeout );
+extern void front_puts (const char *s);
+extern int front_getkey (void);
+extern int front_tstc (void);
+extern int front_persent( int now, int total );
+
+enum front_key
+{
+	key_null = 0,
+	key_power,
+	key_left,
+	key_right,
+	key_up,
+	key_down,
+	key_ok,
+	key_menu,
+
+	key_0,
+	key_1,
+	key_2,
+	key_3,
+	key_4,
+	key_5,
+	key_6,
+	key_7,
+	key_8,
+	key_9,
+
+	key_release,
+
+	key_front_power,
+	key_front_left,
+	key_front_right,
+	key_front_up,
+	key_front_down,
+	key_front_ok,
+	key_front_menu,
+
+	key_front_p_left,	/* power + left */
+	key_front_p_right,	/* power + right */
+	key_front_p_up,		/* power + up */
+	key_front_p_down,	/* power + down */
+	key_front_p_ok,		/* power + ok */
+	key_front_p_menu,	
+
+	key_front_release,
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/chap_9.c u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/chap_9.c
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/chap_9.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/chap_9.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,326 @@
+#include <common.h>
+
+#ifdef CONFIG_PDIUSB12
+
+#include "epphal.h"
+#include "d12ci.h"
+#include "mainloop.h"
+#include "common/usb100.h"
+#include "common/chap_9.h"
+#include "common/vendor.h"
+#include "common/upgrade.h"
+
+#define NUM_ENDPOINTS	4
+
+#define CONFIG_DESCRIPTOR_LENGTH    sizeof(USB_CONFIGURATION_DESCRIPTOR) \
+				+ sizeof(USB_INTERFACE_DESCRIPTOR) \
+				+ (NUM_ENDPOINTS * sizeof(USB_ENDPOINT_DESCRIPTOR))
+
+extern CONTROL_XFER ControlData;
+extern EPPFLAGS bEPPflags;
+
+USB_DEVICE_DESCRIPTOR DeviceDescr =
+{
+	sizeof(USB_DEVICE_DESCRIPTOR),
+	USB_DEVICE_DESCRIPTOR_TYPE,
+	SWAP(0x0100),
+	USB_CLASS_CODE_TEST_CLASS_DEVICE,
+	0, 0,
+	EP0_PACKET_SIZE,
+	SWAP(0x4761),
+	SWAP(0x0001),
+	SWAP(0x0100),
+	0, 0, 0,
+	1
+};
+
+USB_CONFIGURATION_DESCRIPTOR ConfigDescr =
+{
+	sizeof(USB_CONFIGURATION_DESCRIPTOR),
+	USB_CONFIGURATION_DESCRIPTOR_TYPE,
+	SWAP(CONFIG_DESCRIPTOR_LENGTH),
+	1,
+	1,
+	0,
+//	0x60,
+	0xe0,	// by parkhw00
+//	0x1
+	0x0	// by parkhw00
+};
+
+USB_INTERFACE_DESCRIPTOR InterfaceDescr =
+{
+	sizeof(USB_INTERFACE_DESCRIPTOR),
+	USB_INTERFACE_DESCRIPTOR_TYPE,
+	0,
+	0,
+	NUM_ENDPOINTS,
+	USB_CLASS_CODE_TEST_CLASS_DEVICE,
+	USB_SUBCLASS_CODE_TEST_CLASS_D12,
+	USB_PROTOCOL_CODE_TEST_CLASS_D12,
+	0
+};
+
+USB_ENDPOINT_DESCRIPTOR EP1_TXDescr =
+{
+	sizeof(USB_ENDPOINT_DESCRIPTOR),
+	USB_ENDPOINT_DESCRIPTOR_TYPE,
+	0x81,
+	USB_ENDPOINT_TYPE_INTERRUPT,
+	SWAP(EP1_PACKET_SIZE),
+	10
+};
+
+USB_ENDPOINT_DESCRIPTOR EP1_RXDescr =
+{
+	sizeof(USB_ENDPOINT_DESCRIPTOR),
+	USB_ENDPOINT_DESCRIPTOR_TYPE,
+	0x1,
+	USB_ENDPOINT_TYPE_INTERRUPT,
+	SWAP(EP1_PACKET_SIZE),
+	10
+};
+
+USB_ENDPOINT_DESCRIPTOR EP2_TXDescr =
+{
+	sizeof(USB_ENDPOINT_DESCRIPTOR),
+	USB_ENDPOINT_DESCRIPTOR_TYPE,
+	0x82,
+	USB_ENDPOINT_TYPE_BULK,
+	SWAP(EP2_PACKET_SIZE),
+	10
+};
+
+USB_ENDPOINT_DESCRIPTOR EP2_RXDescr =
+{
+	sizeof(USB_ENDPOINT_DESCRIPTOR),
+	USB_ENDPOINT_DESCRIPTOR_TYPE,
+	0x2,
+	USB_ENDPOINT_TYPE_BULK,
+	SWAP(EP2_PACKET_SIZE),
+	10
+};
+
+//*************************************************************************
+// USB Protocol Layer
+//*************************************************************************
+
+void reserved(void)
+{
+	printf( "called reserved function.\n" );
+
+	stall_ep0();
+}
+
+//*************************************************************************
+// USB standard device requests
+//*************************************************************************
+
+void get_status(void)
+{
+	unsigned char endp, txdat[2];
+	unsigned char bRecipient = ControlData.DeviceRequest.bmRequestType & USB_RECIPIENT;
+	unsigned char c;
+
+	if (bRecipient == USB_RECIPIENT_DEVICE) {
+		if(bEPPflags.bits.remote_wakeup == 1)
+			txdat[0] = 3;
+		else
+			txdat[0] = 1;
+		txdat[1]=0;
+		single_transmit(txdat, 2);
+	} else if (bRecipient == USB_RECIPIENT_INTERFACE) {
+		txdat[0]=0;
+		txdat[1]=0;
+		single_transmit(txdat, 2);
+	} else if (bRecipient == USB_RECIPIENT_ENDPOINT) {
+		endp = (unsigned char)(ControlData.DeviceRequest.wIndex & MAX_ENDPOINTS);
+		if (ControlData.DeviceRequest.wIndex & (unsigned char)USB_ENDPOINT_DIRECTION_MASK)
+			c = D12_SelectEndpoint(endp*2 + 1);	/* Control-in */
+		else
+			c = D12_SelectEndpoint(endp*2);	/* Control-out */
+		if(c & D12_STALL)
+			txdat[0] = 1;
+		else
+			txdat[0] = 0;
+		txdat[1] = 0;
+		single_transmit(txdat, 2);
+	} else
+		stall_ep0();
+}
+
+void clear_feature(void)
+{
+	unsigned char endp;
+	unsigned char bRecipient = ControlData.DeviceRequest.bmRequestType & USB_RECIPIENT;
+
+	return;	// by parkhw00 for debug.
+
+	if (bRecipient == USB_RECIPIENT_DEVICE
+		&& ControlData.DeviceRequest.wValue == USB_FEATURE_REMOTE_WAKEUP) {
+		DISABLE;
+		bEPPflags.bits.remote_wakeup = 0;
+		ENABLE;
+		single_transmit(0, 0);
+	}
+	else if (bRecipient == USB_RECIPIENT_ENDPOINT
+		&& ControlData.DeviceRequest.wValue == USB_FEATURE_ENDPOINT_STALL) {
+		endp = (unsigned char)(ControlData.DeviceRequest.wIndex & MAX_ENDPOINTS);
+		if (ControlData.DeviceRequest.wIndex & (unsigned char)USB_ENDPOINT_DIRECTION_MASK)
+			/* clear TX stall for IN on EPn. */
+			D12_SetEndpointStatus(endp*2 + 1, 0);
+		else
+			/* clear RX stall for OUT on EPn. */
+			D12_SetEndpointStatus(endp*2, 0);
+		single_transmit(0, 0);
+	} else
+		stall_ep0();
+}
+
+void set_feature(void)
+{
+	unsigned char endp;
+	unsigned char bRecipient = ControlData.DeviceRequest.bmRequestType & USB_RECIPIENT;
+
+	if (bRecipient == USB_RECIPIENT_DEVICE
+		&& ControlData.DeviceRequest.wValue == USB_FEATURE_REMOTE_WAKEUP) {
+		DISABLE;
+		bEPPflags.bits.remote_wakeup = 1;
+		ENABLE;
+		single_transmit(0, 0);
+	}
+	else if (bRecipient == USB_RECIPIENT_ENDPOINT
+		&& ControlData.DeviceRequest.wValue == USB_FEATURE_ENDPOINT_STALL) {
+		endp = (unsigned char)(ControlData.DeviceRequest.wIndex & MAX_ENDPOINTS);
+		if (ControlData.DeviceRequest.wIndex & (unsigned char)USB_ENDPOINT_DIRECTION_MASK)
+			/* clear TX stall for IN on EPn. */
+			D12_SetEndpointStatus(endp*2 + 1, 1);
+		else
+			/* clear RX stall for OUT on EPn. */
+			D12_SetEndpointStatus(endp*2, 1);
+		single_transmit(0, 0);
+	} else
+		stall_ep0();
+}
+
+void set_address(void)
+{
+//	printf( "set address %d\n", ControlData.DeviceRequest.wValue & DEVICE_ADDRESS_MASK );
+	D12_SetAddressEnable((unsigned char)(ControlData.DeviceRequest.wValue &
+		DEVICE_ADDRESS_MASK), 1);
+	single_transmit(0, 0);
+}
+
+void get_descriptor(void)
+{
+	unsigned char bDescriptor = MSB(ControlData.DeviceRequest.wValue);
+
+	if (bDescriptor == USB_DEVICE_DESCRIPTOR_TYPE) {
+		code_transmit((unsigned char *)&DeviceDescr, sizeof(USB_DEVICE_DESCRIPTOR));
+#if 0
+		if( bEPPflags.bits.verbose )
+		{
+			int a;
+			for( a=0; a<sizeof(USB_DEVICE_DESCRIPTOR); )
+			{
+				printf( " %02x", ((unsigned char*)&DeviceDescr)[a] );
+				a ++;
+				if( !(a%16) )
+					printf( "\n" );
+			}
+			printf( "\n" );
+		}
+#endif
+	} else if (bDescriptor == USB_CONFIGURATION_DESCRIPTOR_TYPE) {
+//		unsigned char buf[CONFIG_DESCRIPTOR_LENGTH];
+		unsigned char *buf = upg_buffer;	// we use usb data buffer for temp.
+							// usb_data_buffer dont have any valid data yet.
+
+
+		memcpy( &buf[0],
+				&ConfigDescr,
+				sizeof(USB_CONFIGURATION_DESCRIPTOR) );
+		memcpy( &buf[sizeof(USB_CONFIGURATION_DESCRIPTOR)],
+				&InterfaceDescr,
+				sizeof(USB_INTERFACE_DESCRIPTOR) );
+		memcpy( &buf[sizeof(USB_CONFIGURATION_DESCRIPTOR)+sizeof(USB_INTERFACE_DESCRIPTOR)+0*sizeof(USB_ENDPOINT_DESCRIPTOR)],
+				&EP1_TXDescr,
+				sizeof(USB_ENDPOINT_DESCRIPTOR) );
+		memcpy( &buf[sizeof(USB_CONFIGURATION_DESCRIPTOR)+sizeof(USB_INTERFACE_DESCRIPTOR)+1*sizeof(USB_ENDPOINT_DESCRIPTOR)],
+				&EP1_RXDescr,
+				sizeof(USB_ENDPOINT_DESCRIPTOR) );
+		memcpy( &buf[sizeof(USB_CONFIGURATION_DESCRIPTOR)+sizeof(USB_INTERFACE_DESCRIPTOR)+2*sizeof(USB_ENDPOINT_DESCRIPTOR)],
+				&EP2_TXDescr,
+				sizeof(USB_ENDPOINT_DESCRIPTOR) );
+		memcpy( &buf[sizeof(USB_CONFIGURATION_DESCRIPTOR)+sizeof(USB_INTERFACE_DESCRIPTOR)+3*sizeof(USB_ENDPOINT_DESCRIPTOR)],
+				&EP2_RXDescr,
+				sizeof(USB_ENDPOINT_DESCRIPTOR) );
+
+#if 0
+		if( bEPPflags.bits.verbose )
+		{
+			int a;
+			for( a=0; a<CONFIG_DESCRIPTOR_LENGTH; )
+			{
+				printf( " %02x", buf[a] );
+				a ++;
+				if( !(a%16) )
+					printf( "\n" );
+			}
+			printf( "\n" );
+		}
+#endif
+
+		code_transmit(buf, CONFIG_DESCRIPTOR_LENGTH);
+	} else
+	{
+		printf( "stall ep0\n" );
+		stall_ep0();
+	}
+}
+
+void get_configuration(void)
+{
+	unsigned char c = bEPPflags.bits.configuration;
+
+	single_transmit(&c, 1);
+}
+
+void set_configuration(void)
+{
+	if (ControlData.DeviceRequest.wValue == 0) {
+		/* put device in unconfigured state */
+		single_transmit(0, 0);
+		DISABLE;
+		bEPPflags.bits.configuration = 0;
+		ENABLE;
+		init_unconfig();
+	} else if (ControlData.DeviceRequest.wValue == 1) {
+		/* Configure device */
+		single_transmit(0, 0);
+
+		init_unconfig();
+		init_config();
+		
+		DISABLE;
+		bEPPflags.bits.configuration = 1;
+		ENABLE;
+	} else
+		stall_ep0();
+}
+
+void get_interface(void)
+{
+	unsigned char txdat = 0;        /* Only/Current interface = 0 */
+	single_transmit(&txdat, 1);
+}
+
+void set_interface(void)
+{
+	if (ControlData.DeviceRequest.wValue == 0 && ControlData.DeviceRequest.wIndex == 0)
+		single_transmit(0, 0);
+	else
+		stall_ep0();
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/d12ci.c u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/d12ci.c
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/d12ci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/d12ci.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,313 @@
+/* PDIUSBD12 Command Interface */
+
+#include <common.h>
+
+#ifdef CONFIG_PDIUSB12
+
+#include "epphal.h"
+#include "mainloop.h"
+#include "d12ci.h"
+
+extern EPPFLAGS bEPPflags;
+
+void D12_SetAddressEnable(unsigned char bAddress, unsigned char bEnable)
+{
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0xD0);
+	if(bEnable)
+		bAddress |= 0x80;
+	outportb(D12_DATA, bAddress);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+}
+
+void D12_SetEndpointEnable(unsigned char bEnable)
+{
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0xD8);
+	if(bEnable)
+		outportb(D12_DATA, 1);
+	else
+		outportb(D12_DATA, 0);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+}
+
+void D12_SetMode(unsigned char bConfig, unsigned char bClkDiv)
+{
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0xF3);
+	outportb(D12_DATA, bConfig);
+	outportb(D12_DATA, bClkDiv);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+}
+
+void D12_SetDMA(unsigned char bMode)
+{
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0xFB);
+	outportb(D12_DATA, bMode);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+}
+
+unsigned short D12_ReadInterruptRegister(void)
+{
+	unsigned char b1;
+	unsigned int j;
+
+	outportb(D12_COMMAND, 0xF4);
+	b1 = inportb(D12_DATA);
+	j = inportb(D12_DATA);
+
+	j <<= 8;
+	j += b1;
+
+	return j;
+}
+
+unsigned char D12_SelectEndpoint(unsigned char bEndp)
+{
+	unsigned char c;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, bEndp);
+	c = inportb(D12_DATA);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return c;
+}
+
+unsigned char D12_ReadLastTransactionStatus(unsigned char bEndp)
+{
+	outportb(D12_COMMAND, 0x40 + bEndp);
+	return inportb(D12_DATA);
+}
+
+unsigned char D12_ReadEndpointStatus(unsigned char bEndp)
+{
+	unsigned char c;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0x80 + bEndp);
+	c = inportb(D12_DATA);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return c;
+}
+
+void D12_SetEndpointStatus(unsigned char bEndp, unsigned char bStalled)
+{
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0x40 + bEndp);
+	outportb(D12_DATA, bStalled);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+}
+
+void D12_SendResume(void)
+{
+	outportb(D12_COMMAND, 0xF6);
+}
+
+unsigned short D12_ReadCurrentFrameNumber(void)
+{
+	unsigned short i,j;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0xF5);
+	i= inportb(D12_DATA);
+	j = inportb(D12_DATA);
+
+	i += (j<<8);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return i;
+}
+
+unsigned short D12_ReadChipID(void)
+{
+	unsigned short i,j;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(portbase+D12_COMMAND, 0xFD);
+	i=inportb(portbase+D12_DATA);
+	j=inportb(portbase+D12_DATA);
+	i += (j<<8);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return i;
+}
+
+unsigned char D12_ReadEndpoint(unsigned char endp, unsigned char * buf, unsigned char len)
+{
+	unsigned char i, j;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, endp);
+	if((inportb(D12_DATA) & D12_FULLEMPTY) == 0) {
+		if(bEPPflags.bits.in_isr == 0)
+			ENABLE;
+		return 0;
+	}
+
+	outportb(D12_COMMAND, 0xF0);
+	j = inportb(D12_DATA);
+	j = inportb(D12_DATA);
+
+	if(j > len)
+		j = len;
+
+	for(i=0; i<j; i++)
+		*(buf+i) = inportb(D12_DATA);
+
+	outportb(D12_COMMAND, 0xF2);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return j;
+}
+
+// D12_ReadMainEndpoint() added by V2.2 to support double-buffering.
+// Caller should assume maxium 128 bytes of returned data.
+unsigned char D12_ReadMainEndpoint(unsigned char * buf)
+{
+	unsigned char i, j, k = 0, bDblBuf = 1;
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, 0x84);
+	if( (inportb(D12_DATA) & 0x60) == 0x60)
+		bDblBuf = 2;
+
+	while(bDblBuf) {
+		outportb(D12_COMMAND, 4);
+		if((inportb(D12_DATA) & D12_FULLEMPTY) == 0)
+			break;
+
+		outportb(D12_COMMAND, 0xF0);
+		j = inportb(D12_DATA);
+		j = inportb(D12_DATA);
+
+		for(i=0; i<j; i++)
+			*(buf+i+k) = inportb(D12_DATA);
+
+		k += j;
+
+		outportb(D12_COMMAND, 0xF2);
+
+		bDblBuf --;
+	}
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return k;
+}
+
+unsigned char D12_WriteEndpoint(unsigned char endp, unsigned char * buf, unsigned char len)
+{
+	unsigned char i;
+
+#if 0
+	{
+		int a;
+
+		printf( "WE%d (%3d)", endp, len );
+		for( a=0; a<len; a++ )
+			printf( " %02x", buf[a] );
+		printf( "\n" );
+	}
+#endif
+
+	if(bEPPflags.bits.in_isr == 0)
+		DISABLE;
+
+	outportb(D12_COMMAND, endp);
+	inportb(D12_DATA);
+
+	outportb(D12_COMMAND, 0xF0);
+	outportb(D12_DATA, 0);
+	outportb(D12_DATA, len);
+
+	for(i=0; i<len; i++)
+		outportb(D12_DATA, *(buf+i));
+
+#if 0
+	{
+		int a;
+		int len;
+		unsigned char tmp;
+
+		outportb( D12_COMMAND, 0xF0 );
+		inportb( D12_DATA );
+		len = inportb( D12_DATA );
+
+//		printf( "v %2d", len );
+
+		for( a=0; a<len; a++ )
+		{
+//			printf( " %02x", inportb(D12_DATA) );
+			tmp = inportb( D12_DATA );
+			if( tmp != buf[a] )
+			{
+				printf( "Oops!! written data is differ. %02x!=%02x. %d\n", tmp, buf[a], a );
+			}
+		}
+//		printf( "\n" );
+	}
+#endif
+
+	outportb(D12_COMMAND, 0xFA);
+
+	if(bEPPflags.bits.in_isr == 0)
+		ENABLE;
+
+	return len;
+}
+
+void D12_AcknowledgeEndpoint(unsigned char endp)
+{
+	outportb(D12_COMMAND, endp);
+	outportb(D12_COMMAND, 0xF1);
+	if(endp == 0)
+		outportb(D12_COMMAND, 0xF2);
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/d12ci.h u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/d12ci.h
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/d12ci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/d12ci.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef __D12CI_H__
+#define __D12CI_H__
+
+#define D12_NOLAZYCLOCK			0x02
+#define D12_CLOCKRUNNING		0x04
+#define D12_INTERRUPTMODE		0x08
+#define D12_SOFTCONNECT			0x10
+#define D12_ENDP_NONISO			0x00
+#define D12_ENDP_ISOOUT			0x40
+#define D12_ENDP_ISOIN			0x80
+#define D12_ENDP_ISOIO			0xC0
+
+#define D12_CLOCK_12M			0x03
+#define D12_CLOCK_4M			0x0b
+#define D12_SETTOONE			0x40
+#define D12_SOFONLY			0x80
+
+#define D12_DMASINGLE			0x00
+#define D12_BURST_4			0x01
+#define D12_BURST_8			0x02
+#define D12_BURST_16			0x03
+#define D12_DMAENABLE			0x04
+#define D12_DMA_INTOKEN			0x08
+#define D12_AUTOLOAD			0x10
+#define D12_NORMALPLUSSOF		0x20
+#define D12_ENDP4INTENABLE		0x40
+#define D12_ENDP5INTENABLE		0x80	// bug fixed in V2.1
+
+#define D12_INT_ENDP0OUT		0x01
+#define D12_INT_ENDP0IN			0x02
+#define D12_INT_ENDP1OUT		0x04
+#define D12_INT_ENDP1IN			0x08
+#define D12_INT_ENDP2OUT		0x10
+#define D12_INT_ENDP2IN			0x20
+#define D12_INT_BUSRESET		0x40
+#define D12_INT_SUSPENDCHANGE		0x80
+#define D12_INT_EOT			0x0100
+
+#define D12_SETUPPACKET			0x20
+
+#define D12_BUFFER0FULL			0x20
+#define D12_BUFFER1FULL			0x40
+
+#define D12_FULLEMPTY			0x01
+#define D12_STALL			0x02
+
+void D12_SetAddressEnable(unsigned char bAddress, unsigned char bEnable);
+void D12_SetEndpointEnable(unsigned char bEnable);
+void D12_SetMode(unsigned char bConfig, unsigned char bClkDiv);
+void D12_SetDMA(unsigned char bMode);
+unsigned short D12_ReadInterruptRegister(void);
+unsigned char D12_SelectEndpoint(unsigned char bEndp);
+unsigned char D12_ReadLastTransactionStatus(unsigned char bEndp);
+unsigned char D12_ReadEndpointStatus(unsigned char bEndp);
+void D12_SetEndpointStatus(unsigned char bEndp, unsigned char bStalled);
+void D12_SendResume(void);
+unsigned short D12_ReadCurrentFrameNumber(void);
+unsigned short D12_ReadChipID(void);
+
+unsigned char D12_ReadEndpoint(unsigned char endp, unsigned char * buf, unsigned char len);
+unsigned char D12_WriteEndpoint(unsigned char endp, unsigned char * buf, unsigned char len);
+void D12_AcknowledgeEndpoint(unsigned char endp);
+
+unsigned char D12_ReadMainEndpoint(unsigned char * buf); // V2.2
+
+#if 0
+unsigned char D12Eval_inportb(void);
+void D12Eval_outportb(unsigned char val, unsigned char mask);
+#endif
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/epphal.c u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/epphal.c
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/epphal.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/epphal.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,25 @@
+#include <common.h>
+
+#ifdef CONFIG_PDIUSB12
+
+#include "epphal.h"
+#include "d12ci.h"
+#include "mainloop.h"
+
+#ifndef PDIUSB_BUSTYPE
+#define PDIUSB_BUSTYPE unsigned char
+#endif
+
+extern EPPFLAGS bEPPflags;
+
+void outportb(unsigned long port, unsigned char val)
+{
+	*((volatile PDIUSB_BUSTYPE*)(PDIUSB_IOBASE+port)) = val;
+}
+
+unsigned char inportb(unsigned long port)
+{
+	return *((volatile PDIUSB_BUSTYPE*)(PDIUSB_IOBASE+port));
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/epphal.h u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/epphal.h
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/epphal.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/epphal.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef __EPPHAL_H__
+#define __EPPHAL_H__
+
+#include <common.h>
+
+#define portbase 0
+
+#define D12_COMMAND	(0x1<<(PDIUSB_AD_ADDRESS))
+#define D12_DATA	(0)
+
+extern void outportb(unsigned long, unsigned char);
+extern unsigned char inportb(unsigned long);
+
+#define DISABLE	disable_interrupts()
+#define ENABLE	enable_interrupts()
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/isr.c u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/isr.c
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/isr.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/isr.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,466 @@
+#include <common.h>
+
+#ifdef CONFIG_PDIUSB12
+
+#include "epphal.h"
+#include "d12ci.h"
+#include "mainloop.h"
+#include "common/usb100.h"
+#include "common/vendor.h"
+#include "common/upgrade.h"
+
+extern void bus_reset(void);
+
+extern void ep0_txdone(void);
+extern void ep0_rxdone(void);
+
+extern void ep1_txdone(void);
+extern void ep1_rxdone(void);
+
+extern void main_txdone(void);
+extern void main_rxdone(void);
+
+extern void dma_eot(void);
+
+//*************************************************************************
+//  Public static data
+//*************************************************************************
+
+EPPFLAGS bEPPflags =
+{
+value:	0,
+};
+
+/* Control endpoint TX/RX buffers */
+extern CONTROL_XFER ControlData;
+
+/* ISR static vars */
+unsigned char GenEpBuf[EP1_PACKET_SIZE];
+
+void usb_isr( void *arg )
+{
+	fn_usb_isr();
+}
+
+void fn_usb_isr( void )
+{
+	unsigned int i_st;
+
+	bEPPflags.bits.in_isr = 1;
+
+	i_st = D12_ReadInterruptRegister();
+	if( bEPPflags.bits.verbose )
+	{
+		//printf( "int_stat 0x%04x\n", i_st );
+	}
+
+	if(i_st != 0) {
+		if(i_st & D12_INT_BUSRESET) {
+			bus_reset();
+			bEPPflags.bits.bus_reset = 1;
+		}
+		else {
+			if(i_st & D12_INT_EOT)
+				dma_eot();
+
+			/* PDIUSBD12 support 2 control ep, 2 generic ep, 2 main ep(support dma) */
+			if(i_st & D12_INT_SUSPENDCHANGE)
+				bEPPflags.bits.suspend = 1;
+
+			/* for control */
+			if(i_st & D12_INT_ENDP0IN)	// control ep 1
+			{
+				ep0_txdone();
+			}
+			if(i_st & D12_INT_ENDP0OUT)	
+			{
+				ep0_rxdone();
+			}
+			
+			/* N/A ??? */
+			if(i_st & D12_INT_ENDP1IN)	// generic ep 1 
+			{
+				ep1_txdone();
+			}
+			if(i_st & D12_INT_ENDP1OUT)
+			{
+				ep1_rxdone();
+			}
+
+			/* for main file transfer */
+			if(i_st & D12_INT_ENDP2IN)	// main ep 1
+			{
+				main_txdone();
+			}
+			if(i_st & D12_INT_ENDP2OUT)
+			{
+				main_rxdone();
+			}
+		}
+	}
+
+	bEPPflags.bits.in_isr = 0;
+}
+
+void bus_reset(void)
+{
+}
+
+void ep0_rxdone(void)
+{
+	unsigned char ep_last, i;
+
+	ep_last = D12_ReadLastTransactionStatus(0); // Clear interrupt flag
+#if 0
+	if( bEPPflags.bits.verbose )
+		printf( "rxdone last transaction 0x%02x\n", ep_last );
+#endif
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+
+	if (ep_last & D12_SETUPPACKET)
+	{
+
+		ControlData.wLength = 0;
+		ControlData.wCount = 0;
+
+		if( D12_ReadEndpoint(0, (unsigned char *)(&(ControlData.DeviceRequest)),
+			sizeof(ControlData.DeviceRequest)) != sizeof(DEVICE_REQUEST) ) {
+
+			D12_SetEndpointStatus(0, 1);
+			D12_SetEndpointStatus(1, 1);
+			bEPPflags.bits.control_state = USB_IDLE;
+			
+			return;
+		}
+
+		ControlData.DeviceRequest.wValue =
+			SWAP(ControlData.DeviceRequest.wValue);
+		ControlData.DeviceRequest.wIndex =
+			SWAP(ControlData.DeviceRequest.wIndex);
+		ControlData.DeviceRequest.wLength =
+			SWAP(ControlData.DeviceRequest.wLength);
+
+		if( bEPPflags.bits.verbose )
+		{
+			printf( "Device request bmRequestType 0x%02x\n",
+					ControlData.DeviceRequest.bmRequestType );
+			printf( "Device request bRequest      0x%02x\n",
+					ControlData.DeviceRequest.bRequest );
+			printf( "Device request value  0x%04x\n",
+					ControlData.DeviceRequest.wValue );
+			printf( "Device request index  0x%04x\n",
+					ControlData.DeviceRequest.wIndex );
+			printf( "Device request length 0x%04x\n",
+					ControlData.DeviceRequest.wLength );
+		}
+
+		// Acknowledge setup here to unlock in/out endp
+		D12_AcknowledgeEndpoint(0);
+		D12_AcknowledgeEndpoint(1);
+
+		ControlData.wLength = ControlData.DeviceRequest.wLength;
+		ControlData.wCount = 0;
+
+		if (ControlData.DeviceRequest.bmRequestType & (unsigned char)USB_ENDPOINT_DIRECTION_MASK) {
+			if(
+					((ControlData.DeviceRequest.bmRequestType&USB_REQUEST_TYPE_MASK)==USB_VENDOR_REQUEST)&&
+					((ControlData.DeviceRequest.bRequest&USB_REQUEST_MASK)==12)&&
+					(ControlData.DeviceRequest.wIndex==GET_FLASH_STATUS)
+			  )
+			{
+				char buf[2];
+				extern unsigned int flash_progress_now;
+				extern unsigned int flash_progress_total;
+
+
+				if(bEPPflags.bits.verbose)
+				{
+					printf( "get flash status. " );
+				}
+				/*
+				 * send flash status...
+				 */
+				buf[1] = 0;
+				switch( upg_buffer_status )
+				{
+					case UPGBUF_UNUSED:
+						if( upg_buffer_errorno == 0 )
+						{
+							if( bEPPflags.bits.verbose )
+								printf( "do nothing...\n" );
+							buf[0] = 0;
+							break;
+						}
+						else
+						{
+							if( bEPPflags.bits.verbose )
+							{
+								printf( "error...(%d)\n", upg_buffer_errorno );
+							}
+							buf[0] = 3;
+							buf[1] = upg_buffer_errorno;
+							upg_buffer_errorno = 0;	/* clear error status... */
+							break;
+						}
+					case UPGBUF_ERASE:
+						if( bEPPflags.bits.verbose )
+						{
+							printf( "erasing...(%d/%d)\n",
+									flash_progress_now, flash_progress_total );
+						}
+						buf[0] = 1;
+						if( flash_progress_total )
+						{
+							if( flash_progress_total >= flash_progress_now )
+							{
+								buf[1] = flash_progress_now * 100 / flash_progress_total;
+							}
+						}
+						break;
+					case UPGBUF_WRITE:
+						if( bEPPflags.bits.verbose )
+						{
+							printf( "writing...(%d/%d)\n",
+									flash_progress_now, flash_progress_total );
+						}
+						buf[0] = 2;
+						if( flash_progress_total )
+						{
+							if( flash_progress_total >= flash_progress_now )
+							{
+								buf[1] = flash_progress_now * 100 / flash_progress_total;
+							}
+						}
+						break;
+					default:
+						if( bEPPflags.bits.verbose )
+						{
+							printf( "%d: unknown...\n", upg_buffer_status );
+						}
+						buf[0] = 4;
+						break;
+				}
+				D12_WriteEndpoint( 1, buf, 2 );
+			}
+			else
+			{
+				bEPPflags.bits.setup_packet = 1;
+				bEPPflags.bits.control_state = USB_IDLE;		/* get command */
+			}
+		}
+		else {
+			if (ControlData.DeviceRequest.wLength == 0) {
+				bEPPflags.bits.setup_packet = 1;
+				bEPPflags.bits.control_state = USB_IDLE;		/* set command */
+			}
+			else {
+				if(ControlData.DeviceRequest.wLength > MAX_CONTROLDATA_SIZE) {
+					bEPPflags.bits.control_state = USB_IDLE;
+					D12_SetEndpointStatus(0, 1);
+					D12_SetEndpointStatus(1, 1);
+				}
+				else {
+					//printf( "set command with OUT token\n" );
+					bEPPflags.bits.control_state = USB_RECEIVE;	/* set command with OUT token */
+				}
+			} // set command with data
+		} // else set command
+	} // if setup packet
+
+	else if (bEPPflags.bits.control_state == USB_RECEIVE) {
+		if( bEPPflags.bits.verbose )
+		{
+			printf( "receive control packet.\n" );
+		}
+		i =	D12_ReadEndpoint(0, ControlData.dataBuffer + ControlData.wCount,
+			EP0_PACKET_SIZE);
+
+		ControlData.wCount += i;
+		if( i != EP0_PACKET_SIZE || ControlData.wCount >= ControlData.wLength) {
+			bEPPflags.bits.setup_packet = 1;
+			bEPPflags.bits.control_state = USB_IDLE;
+		}
+	}
+
+	else {
+		if( bEPPflags.bits.verbose )
+		{
+			printf( "receive is IDLE\n" );
+		}
+		bEPPflags.bits.control_state = USB_IDLE;
+	}
+}
+
+void ep0_txdone(void)
+{
+	short i = ControlData.wLength - ControlData.wCount;
+	unsigned char ep_last;
+
+	ep_last = D12_ReadLastTransactionStatus(1); // Clear interrupt flag
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+
+	if (bEPPflags.bits.control_state != USB_TRANSMIT) 
+		return;
+
+	if( i >= EP0_PACKET_SIZE) {
+		//printf( "channed\n" );
+		D12_WriteEndpoint(1, ControlData.pData + ControlData.wCount, EP0_PACKET_SIZE);
+		ControlData.wCount += EP0_PACKET_SIZE;
+
+		bEPPflags.bits.control_state = USB_TRANSMIT;
+	}
+	else if( i != 0) {
+		//printf( "last\n" );
+		D12_WriteEndpoint(1, ControlData.pData + ControlData.wCount, i);
+		ControlData.wCount += i;
+
+		bEPPflags.bits.control_state = USB_IDLE;
+	}
+	else if (i == 0){
+		//printf( "send zero\n" );
+		D12_WriteEndpoint(1, 0, 0); // Send zero packet at the end ???
+
+		bEPPflags.bits.control_state = USB_IDLE;
+	}
+}
+
+void dma_eot(void)
+{
+#if 0		// we will not use dma... by parkhw00
+	if(bEPPflags.bits.dma_state == DMA_PENDING)
+		bEPPflags.bits.setup_dma = 1;
+	else
+		bEPPflags.bits.dma_state = DMA_IDLE;
+#endif
+}
+
+void ep1_txdone(void)
+{
+	unsigned char ep_last;
+
+	ep_last = D12_ReadLastTransactionStatus(3); /* Clear interrupt flag */
+	printf( "ep1 txdone.\n" );
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+}
+
+void ep1_rxdone(void)
+{
+	unsigned char len;
+	unsigned char ep_last;
+
+	ep_last = D12_ReadLastTransactionStatus(2); /* Clear interrupt flag */
+	printf( "ep1 rxdone." );
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+
+	if( 0 )
+	{
+		len = D12_ReadEndpoint(2, GenEpBuf, sizeof(GenEpBuf));
+		printf( " %2d\n", len );
+
+		{
+			int a;
+			for( a=0; a<len; a++ )
+				printf( " %02x", GenEpBuf[a] );
+			printf( "\n" );
+			for( a=0; a<len; a++ )
+				printf( "%c", ((' '<=GenEpBuf[a])&&(GenEpBuf[a]<='~'))?GenEpBuf[a]:'.' );
+			printf( "\n" );
+		}
+
+		if(len != 0)
+			bEPPflags.bits.ep1_rxdone = 1;
+	}
+	else
+	{
+		printf( " unknown data.\n" );
+	}
+}
+
+void main_txdone(void)
+{
+#if 0
+#ifndef __C51__
+	unsigned short len;
+	unsigned char *fp;
+	unsigned short seg, off;
+#endif
+#endif
+	unsigned char ep_last;
+
+	ep_last = D12_ReadLastTransactionStatus(5); /* Clear interrupt flag */
+	printf( "main_tx_done....\n" );
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+
+#if 0
+#ifndef __C51__
+	seg = (ioBuffer + ioCount)>>4;
+	off = (ioBuffer + ioCount)&0xf;
+	fp = MK_FP(seg, off);
+
+	len = ioSize - ioCount;
+	if(len == 0) {
+		if(bEPPflags.bits.dma_state == DMA_PENDING)
+			bEPPflags.bits.setup_dma = 1;
+		else
+			bEPPflags.bits.dma_state = DMA_IDLE;
+	}
+	else {
+		if(len > 64)
+			len = 64;
+		len = D12_WriteEndpoint(5, fp, len);
+		ioCount += len;
+	}
+#endif
+#endif
+}
+
+void main_rxdone(void)
+{
+	int len;
+	unsigned char ep_last;
+
+	ep_last = D12_ReadLastTransactionStatus(4); /* Clear interrupt flag */
+	//printf( "main_rxdone." );
+	if( ep_last & 0x1e )
+		printf( "%s error 0x%02x\n", (ep_last & 0x1e) >> 1 );
+
+	if( upg_buffer_status == UPGBUF_DOWNLOAD )
+	{
+		len = D12_ReadMainEndpoint( &upg_buffer[upg_buffer_len] );
+		//printf( " %3x", len );
+		if( len == 0 )
+			printf( "empty main rx.(%02x)\n", ep_last );
+
+		upg_buffer_len += len;
+		usb_current_block_size -= len;
+
+		if( usb_current_block_size > 0 )
+		{
+			//printf( "\n" );
+		}
+		else if( usb_current_block_size == 0 )
+		{
+			//printf( " block completed.\n" );
+		}
+		else
+		{
+			printf( " we got unexpected data.(br:%d)\n", usb_current_block_size );
+		}
+
+		if( upg_buffer_len > file_header.file_size )
+		{
+			printf( " we got more data.(in:%d)\n", upg_buffer_len );
+		}
+	}
+	else
+	{
+		printf( " unknown data....(st:%d)\n", upg_buffer_status );
+	}
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/mainloop.c u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/mainloop.c
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/mainloop.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/mainloop.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,566 @@
+#include <common.h>
+
+#ifdef CONFIG_PDIUSB12
+
+#include <command.h>
+
+#include <asm/processor.h>
+#include <asm/global_data.h>
+#ifdef CONFIG_PPC405_GPIO
+#include "common/gpio.h"
+#endif
+
+#ifdef CONFIG_DGS_FRONT
+#include "common/front.h"
+#endif
+
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include "epphal.h"
+#include "d12ci.h"
+#include "mainloop.h"
+#include "common/usb100.h"
+#include "common/chap_9.h"
+#include "common/vendor.h"
+#include "common/upgrade.h"
+
+//*************************************************************************
+// USB protocol function pointer arrays
+//*************************************************************************
+void (*StandardDeviceRequest[])(void) =
+{
+	get_status,		// 0
+	clear_feature,		// 1
+	reserved,		// 2
+	set_feature,		// 3
+	reserved,		// 4
+	set_address,		// 5
+	get_descriptor,		// 6
+	reserved,		// 7
+	get_configuration,	// 8
+	set_configuration,	// 9
+	get_interface,		// 10
+	set_interface,		// 11
+	reserved,		// 12
+	reserved,		// 13
+	reserved,		// 14
+	reserved		// 15
+};
+
+void (*VendorDeviceRequest[])(void) =
+{
+	reserved,		// 0
+	get_vendor_descript,	// 1
+	reserved,		// 2
+	reserved,		// 3
+	reserved,		// 4
+	reserved,		// 5
+	reserved,		// 6
+	reserved,		// 7
+	reserved,		// 8
+	reserved,		// 9
+	reserved,		// 10
+	reserved,		// 11
+	vendor_req,		// 12
+	reserved,		// 13
+	reserved,		// 14
+	reserved		// 15
+};
+
+//*************************************************************************
+//  Public static data
+//*************************************************************************
+
+extern EPPFLAGS bEPPflags;
+extern unsigned long ClockTicks;
+extern unsigned char GenEpBuf[];
+
+CONTROL_XFER ControlData;
+
+char * _NAME_USB_REQUEST_DIRECTION[] =
+{
+"Host_to_device",
+"Device_to_host"
+};
+
+char * _NAME_USB_REQUEST_RECIPIENT[] =
+{
+"Device",
+"Interface",
+"Endpoint(0)",
+"Other"
+};
+
+char * _NAME_USB_REQUEST_TYPE[] =
+{
+"Standard",
+"Class",
+"Vendor",
+"Reserved"
+};
+
+char * _NAME_USB_STANDARD_REQUEST[] =
+{
+"GET_STATUS",
+"CLEAR_FEATURE",
+"RESERVED",
+"SET_FEATURE",
+"RESERVED",
+"SET_ADDRESS",
+"GET_DESCRIPTOR",
+"SET_DESCRIPTOR",
+"GET_CONFIGURATION",
+"SET_CONFIGURATION",
+"GET_INTERFACE",
+"SET_INTERFACE",
+"SYNC_FRAME"
+};
+
+int gusbc_debug = 0;
+
+void help_devreq(unsigned char typ, unsigned char req)
+{
+	typ >>= 5;
+
+	if(typ == USB_STANDARD_REQUEST) {
+		if(bEPPflags.bits.verbose)
+		{
+			printf("Request Type = %s, Request = %s.\n", _NAME_USB_REQUEST_TYPE[typ],
+					_NAME_USB_STANDARD_REQUEST[req]);
+		}
+	}
+	else {
+		if(bEPPflags.bits.verbose)
+		{
+			printf("Request Type = %s, bRequest = 0x%x.\n", _NAME_USB_REQUEST_TYPE[typ],
+				req);
+		}
+	}
+}
+
+void on_exit(void)
+{
+	DISABLE;
+#if defined(PDIUSB_USE_INTERRUPT)
+	irq_free_handler( PDIUSB_IRQ );
+#endif
+
+	disconnect_USB();
+
+	ENABLE;
+}
+
+int usb_client_relocate_code( void )
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int a;
+	unsigned long addr;
+
+	for( a=0; a<16; a++ )
+	{
+		addr = (unsigned long)StandardDeviceRequest[a] + gd->reloc_off;
+//		printf( "StandardDeviceRequest 0x%08x -> 0x%08x\n", (int)StandardDeviceRequest[a], (int)addr );
+		StandardDeviceRequest[a] = (void (*)(void))addr;
+
+		addr = (unsigned long)VendorDeviceRequest[a] + gd->reloc_off;
+//		printf( "VendorDeviceRequest 0x%08x -> 0x%08x\n", (int)VendorDeviceRequest[a], (int)addr );
+		VendorDeviceRequest[a] = (void (*)(void))addr;
+	}
+
+	for( a=0; a<sizeof(_NAME_USB_REQUEST_DIRECTION)/sizeof(char*); a++ )
+	{
+		addr = (unsigned long)_NAME_USB_REQUEST_DIRECTION[a] + gd->reloc_off;
+//		printf( "_NAME_USB_REQUEST_DIRECTION 0x%08x -> 0x%08x\n", (int)_NAME_USB_REQUEST_DIRECTION[a], (int)addr );
+		_NAME_USB_REQUEST_DIRECTION[a] = (char*)addr;
+	}
+
+	for( a=0; a<sizeof(_NAME_USB_REQUEST_RECIPIENT)/sizeof(char*); a++ )
+	{
+		addr = (unsigned long)_NAME_USB_REQUEST_RECIPIENT[a] + gd->reloc_off;
+//		printf( "_NAME_USB_REQUEST_RECIPIENT 0x%08x -> 0x%08x\n", (int)_NAME_USB_REQUEST_RECIPIENT[a], (int)addr );
+		_NAME_USB_REQUEST_RECIPIENT[a] = (char*)addr;
+	}
+
+	for( a=0; a<sizeof(_NAME_USB_REQUEST_TYPE)/sizeof(char*); a++ )
+	{
+		addr = (unsigned long)_NAME_USB_REQUEST_TYPE[a] + gd->reloc_off;
+//		printf( "_NAME_USB_REQUEST_TYPE 0x%08x -> 0x%08x\n", (int)_NAME_USB_REQUEST_TYPE[a], (int)addr );
+		_NAME_USB_REQUEST_TYPE[a] = (char*)addr;
+	}
+
+	for( a=0; a<sizeof(_NAME_USB_STANDARD_REQUEST)/sizeof(char*); a++ )
+	{
+		addr = (unsigned long)_NAME_USB_STANDARD_REQUEST[a] + gd->reloc_off;
+//		printf( "_NAME_USB_STANDARD_REQUEST 0x%08x -> 0x%08x\n", (int)_NAME_USB_STANDARD_REQUEST[a], (int)addr );
+		_NAME_USB_STANDARD_REQUEST[a] = (char*)addr;
+	}
+
+	return 0;
+}
+
+/*
+ * handle user key input and do host requests.
+ */
+int main_loop_function( void )
+{
+	char c;
+	static int suspend = 0;
+#ifdef CONFIG_DGS_FRONT
+	int key;
+#endif
+
+	if( gusbc_debug )
+	{
+		if( tstc() )
+		{
+			c = getc();
+			switch( c )
+			{
+				/*
+				 * abcdefghijklmnopqrstuvwxyz
+				 * 123456789abcdef0123456789a
+				 */
+				case 0x03:		/* ^C - break */
+					return 1;
+					break;
+				case 0x12:		/* ^R - reconnect */
+					printf( "^R reconnect usb.\n" );
+					reconnect_USB();
+					//bEPPflags.bits.verbose = 0;	/* disable verbose print */
+					break;
+				case 'v':
+					if(bEPPflags.bits.verbose == 0) {
+						printf("Verbose = ON.\n");
+						bEPPflags.bits.verbose = 1;
+						upg_verbose_message = 1;
+					}
+					else {
+						printf("Verbose = OFF.\n");
+						bEPPflags.bits.verbose = 0;
+						upg_verbose_message = 0;
+					}
+					break;
+				default:
+					break;
+			}
+		}
+	}
+
+	/*
+	 * check pwr button.
+	 */
+#ifdef CONFIG_DGS_FRONT
+	key = front_getkey();
+	if( key==key_power || key==key_front_power )
+	{	// got power off button.
+		//while( front_getc() != 0xff );
+		return 1;
+	}
+#endif
+
+	/*
+	 * do bottom half.
+	 */
+	if (bEPPflags.bits.bus_reset) {
+		DISABLE;
+		bEPPflags.bits.bus_reset = 0;
+		ENABLE;
+		if( bEPPflags.bits.verbose )
+			printf("Bus reset!\n");
+	} // if bus reset
+
+	if (bEPPflags.bits.suspend) {
+		DISABLE;
+		bEPPflags.bits.suspend= 0;
+		suspend ++;
+		ENABLE;
+		suspend_change();
+		if( bEPPflags.bits.verbose )
+			printf("Suspend change!\n");
+	} // if suspend change
+
+	if (bEPPflags.bits.setup_packet){
+//		printf( "setup_packet\n" );
+		DISABLE;
+		bEPPflags.bits.setup_packet = 0;
+		ENABLE;
+		control_handler();
+	} // if setup_packet
+
+	if(bEPPflags.bits.setup_dma) {
+		if( bEPPflags.bits.verbose )
+			printf( "setup_dma\n" );
+		DISABLE;
+		bEPPflags.bits.setup_dma = 0;
+		ENABLE;
+		//			setup_dma();
+	} // if setup_dma
+
+#if defined(CONFIG_PPC405_GPIO) && defined(PDIUSB_SUSPEND_GPIO)
+	{
+		static unsigned long long starttime = 0;
+		unsigned long gpiodat;
+
+		/*
+		 * check if it is first...
+		 */
+		if( starttime == 0 )
+		{
+			starttime = get_ticks();
+		}
+		else
+		{
+			if( !gusbc_debug )
+			{
+				/*
+				 * check some seconds passed.
+				 */
+				if( get_ticks()  > (starttime+PDIUSB_CONNECT_TIMEOUT*get_tbclk()) )
+				{
+					gpio_in( 0, 0x80000000>>PDIUSB_SUSPEND_GPIO, &gpiodat );
+					if( gpiodat )
+					{	/* disconnected... */
+						printf( "disconnected...\n" );
+
+						starttime = 0;
+					}
+					else
+					{
+					}
+				}
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int usb_client_main( int argc, char *argv[] )
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	BOOL in_loop = TRUE;
+
+#ifdef CONFIG_DGS_FRONT
+	front_puts( "USB UPGRADE" );
+
+	/*
+	 * wait power key release...
+	 */
+	{
+		unsigned long long starttime;
+		int key;
+
+		starttime = get_ticks();
+
+		while( get_ticks() < (starttime+3*get_tbclk()) )
+		{
+			if( front_tstc() )
+			{
+				key = front_getkey();
+				if( key == key_release || key == key_front_release )
+					break;
+				starttime = get_ticks();
+			}
+		}
+	}
+#endif
+
+	/*
+	 * set some default value
+	 */
+	bEPPflags.value = 0;	/* disable verbose print. */
+	/* initiate usb_data_buffer and status register */
+	upg_buffer = (unsigned char*)gd->dgs_upg_buffer;
+	//printf( "we have 0x%08x bytes of memory at 0x%08x for download buffer.\n",
+	//		PDIUSB_DOWN_BUFFER, (int)usb_data_buffer );
+	upg_buffer_status = UPGBUF_UNUSED;
+	upg_buffer_errorno = 0;
+
+	/*
+	 * do chip initialize...
+	 */
+	unsigned short chip_id;
+	chip_id = D12_ReadChipID();
+	if( chip_id != 0x1012 )
+	{
+		printf( "Chip ID is 0x%04x\n", chip_id );
+		printf( "It seems that pdiusb is not working...\n" );
+		return -1;
+	}
+
+	/* register interrupt handler. */
+#if defined(PDIUSB_USE_INTERRUPT)
+	mtdcr( uictr, mfdcr(uictr)&~(0x80000000>>PDIUSB_IRQ) );	// level sensitive
+	mtdcr( uicpr, mfdcr(uicpr)|(0x80000000>>PDIUSB_IRQ) );		// negative interrupt
+	irq_install_handler( PDIUSB_IRQ, usb_isr, NULL );
+#endif
+
+	/* reconnect usb. */
+	printf("Connecting USB to PC.\n");
+	reconnect_USB();
+
+	if( argc>1 )
+	{
+		if( !strcmp( argv[1], "debug" ) )
+		{
+			bEPPflags.bits.verbose = 1;
+			upg_verbose_message = 1;
+			gusbc_debug = 1;
+		}
+	}
+
+
+	/* Main program loop */
+	while( in_loop )
+	{
+
+#if !defined(PDIUSB_USE_INTERRUPT)
+		if( STPIO_GET_PIN(PIO_PORT(3), 1)==0 )
+		{
+			usb_isr(NULL);
+		}
+#endif
+		switch( main_loop_function() )
+		{
+			case 1:
+				in_loop = 0;
+				break;
+			default:
+				break;
+		}
+
+		if( upg_buffer_status == UPGBUF_WRITE )
+		{
+			switch( burn_flash() )
+			{
+				case 1:
+					in_loop = 0;
+					break;
+				case 2:	/* flash write error. */
+					break;
+				default:
+					break;
+			}
+		}
+	} // Main Loop
+
+	on_exit();
+
+	return 0;
+}
+
+static int do_usbcmd( cmd_tbl_t *cmdtp, int flag, int argc, char **argv )
+{
+	return usb_client_main( argc, argv );
+}
+
+U_BOOT_CMD(
+		usbupg, 2, 0, do_usbcmd,
+		"usbupg  - excute usb update program.\n",
+		"usbupg <debug>\n     - appand \"debug\" to debug the device.\n" );
+
+void suspend_change(void)
+{
+}
+
+void stall_ep0(void)
+{
+	D12_SetEndpointStatus(0, 1);
+	D12_SetEndpointStatus(1, 1);
+}
+
+void disconnect_USB(void)
+{
+	if( bEPPflags.bits.verbose )
+		printf( "disconnect usb.\n" );
+	// Initialize D12 configuration
+	D12_SetMode(D12_NOLAZYCLOCK|D12_CLOCKRUNNING, D12_SETTOONE | D12_CLOCK_12M);
+}
+
+void connect_USB(void)
+{
+	if( bEPPflags.bits.verbose )
+		printf( "connect usb.\n" );
+	// reset event flags
+	DISABLE;
+	bEPPflags.value = 0;
+	ENABLE;
+
+	// V2.1 enable normal+sof interrupt
+	D12_SetDMA(D12_ENDP4INTENABLE | D12_ENDP5INTENABLE);	// removed by parkhw00
+
+	// Initialize D12 configuration
+	D12_SetMode(D12_NOLAZYCLOCK|D12_CLOCKRUNNING|D12_SOFTCONNECT, D12_SETTOONE | D12_CLOCK_12M);
+}
+
+
+void reconnect_USB(void)
+{
+	disconnect_USB();
+
+	udelay( 1*1000*1000 );
+
+	connect_USB();
+}
+
+void init_unconfig(void)
+{
+	D12_SetEndpointEnable(0);	/* Disable all endpoints but EPP0. */
+}
+
+void init_config(void)
+{
+	D12_SetEndpointEnable(1);	/* Enable  generic/iso endpoints. */
+}
+
+void single_transmit(unsigned char * buf, unsigned char len)
+{
+	if( len <= EP0_PACKET_SIZE) {
+		D12_WriteEndpoint(1, buf, len);
+	}
+}
+
+void code_transmit(unsigned char * pRomData, unsigned short len)
+{
+	ControlData.wCount = 0;
+	if(ControlData.wLength > len)
+		ControlData.wLength = len;
+
+	ControlData.pData = pRomData;
+	if( ControlData.wLength >= EP0_PACKET_SIZE) {
+		D12_WriteEndpoint(1, ControlData.pData, EP0_PACKET_SIZE);
+		ControlData.wCount += EP0_PACKET_SIZE;
+
+		DISABLE;
+		bEPPflags.bits.control_state = USB_TRANSMIT;
+		ENABLE;
+	}
+	else {
+		D12_WriteEndpoint(1, pRomData, ControlData.wLength);
+		ControlData.wCount += ControlData.wLength;
+		DISABLE;
+		bEPPflags.bits.control_state = USB_IDLE;
+		ENABLE;
+	}
+}
+
+void control_handler(void)
+{
+	unsigned char type, req;
+
+	type = ControlData.DeviceRequest.bmRequestType & USB_REQUEST_TYPE_MASK;
+	req = ControlData.DeviceRequest.bRequest & USB_REQUEST_MASK;
+
+	help_devreq(type, req); // print out device request
+
+	if (type == USB_STANDARD_REQUEST)
+		(*StandardDeviceRequest[req])();
+	else if (type == USB_VENDOR_REQUEST)
+		(*VendorDeviceRequest[req])();
+	else
+		stall_ep0();
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/pdiusbd12/mainloop.h u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/mainloop.h
--- u-boot-1.3.1/board/dgstation/common/pdiusbd12/mainloop.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/pdiusbd12/mainloop.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,191 @@
+#ifndef __MAINLOOP_H__
+#define __MAINLOOP_H__
+
+
+//*************************************************************************
+// basic #defines
+//*************************************************************************
+#define MAX_ENDPOINTS      (unsigned char)0x3
+
+#define EP0_TX_FIFO_SIZE   16
+#define EP0_RX_FIFO_SIZE   16
+#define EP0_PACKET_SIZE    16
+
+#define EP1_TX_FIFO_SIZE   16
+#define EP1_RX_FIFO_SIZE   16
+#define EP1_PACKET_SIZE    16
+
+#define EP2_TX_FIFO_SIZE   64
+#define EP2_RX_FIFO_SIZE   64
+#define EP2_PACKET_SIZE    64
+
+
+#define USB_IDLE           0
+#define USB_TRANSMIT       1
+#define USB_RECEIVE        2
+
+#define USB_CLASS_CODE_TEST_CLASS_DEVICE                    0xdc
+#define USB_SUBCLASS_CODE_TEST_CLASS_D12                    0xA0
+#define USB_PROTOCOL_CODE_TEST_CLASS_D12                    0xB0
+
+//*************************************************************************
+// masks
+//*************************************************************************
+
+#define USB_RECIPIENT            (unsigned char)0x1F
+#define USB_RECIPIENT_DEVICE     (unsigned char)0x00
+#define USB_RECIPIENT_INTERFACE  (unsigned char)0x01
+#define USB_RECIPIENT_ENDPOINT   (unsigned char)0x02
+
+#define USB_REQUEST_TYPE_MASK    (unsigned char)0x60
+#define USB_STANDARD_REQUEST     (unsigned char)0x00
+#define USB_CLASS_REQUEST        (unsigned char)0x20
+#define USB_VENDOR_REQUEST       (unsigned char)0x40
+
+#define USB_REQUEST_MASK         (unsigned char)0x0F
+
+#define DEVICE_ADDRESS_MASK      0x7F
+
+//*************************************************************************
+// macros
+//*************************************************************************
+// FIXME:: !! Is it right???? I don`t know about endian... by parkhw00.
+#if 0
+
+#define SWAP(x)		((((x) & 0xFF) << 8) | (((x) >> 8) & 0xFF))
+#define LSWAP(x)			\
+	(				\
+	 ((((x)>>0)&0xff)<<24) |	\
+	 ((((x)>>8)&0xff)<<16) |	\
+	 ((((x)>>16)&0xff)<<8) |	\
+	 ((((x)>>24)&0xff)<<0) 		\
+	)
+
+#define MSB(x)    (((x) >> 8) & 0xFF)
+#define LSB(x)    ((x) & 0xFF)
+
+#else
+
+#define SWAP(x)		(x)
+#define LSWAP(x)		(x)		
+
+#define MSB(x)    (((x) >> 8) & 0xFF)
+#define LSB(x)    ((x) & 0xFF)
+
+#endif
+#define FALSE   0
+#define TRUE    (!FALSE)
+
+//*************************************************************************
+// basic typedefs
+//*************************************************************************
+typedef unsigned char   UCHAR;
+typedef unsigned short  USHORT;
+typedef unsigned long   ULONG;
+typedef unsigned char   BOOL;
+
+//*************************************************************************
+// structure and union definitions
+//*************************************************************************
+typedef union _epp_flags
+{
+	struct _flags
+	{
+		unsigned char timer               	: 1;
+		unsigned char bus_reset           	: 1;
+		unsigned char suspend             	: 1;
+		unsigned char setup_packet  	  	: 1;
+		unsigned char remote_wakeup	   	: 1;
+		unsigned char in_isr		      	: 1;
+		unsigned char control_state		: 2;
+
+		unsigned char configuration		: 1;
+		unsigned char verbose			: 1;
+		unsigned char ep1_rxdone		: 1;
+		unsigned char setup_dma			: 1;
+		unsigned char dma_state      		: 2;
+		unsigned char dma_disable		: 1; // V2.1
+	} bits;
+	unsigned short value;
+} EPPFLAGS;
+
+typedef struct _device_request
+{
+	unsigned char bmRequestType;
+	unsigned char bRequest;
+	unsigned short wValue;
+	unsigned short wIndex;
+	unsigned short wLength;
+} DEVICE_REQUEST;
+
+#pragma pack(1)
+struct _IO_REQUEST {
+	unsigned short	uAddressL;
+	unsigned char	bAddressH;
+	unsigned short	uSize;
+	unsigned char	bCommand;
+};
+#pragma pack()
+
+//#define MAX_CONTROLDATA_SIZE	8
+#define MAX_CONTROLDATA_SIZE	512
+
+typedef struct _control_xfer
+{
+	DEVICE_REQUEST DeviceRequest;
+	unsigned short wLength;
+	unsigned short wCount;
+	unsigned char * pData;
+	unsigned char dataBuffer[MAX_CONTROLDATA_SIZE];
+} CONTROL_XFER;
+
+//*************************************************************************
+// USB utility functions
+//*************************************************************************
+extern int main_loop_function( void );
+extern void usb_isr( void* );
+
+extern void fn_usb_isr( void );
+
+extern void suspend_change(void);
+extern void stall_ep0(void);
+extern void disconnect_USB(void);
+extern void connect_USB(void);
+extern void reconnect_USB(void);
+extern void init_unconfig(void);
+extern void init_config(void);
+extern void single_transmit(unsigned char * pData, unsigned char len);
+extern void code_transmit(unsigned char * pRomData, unsigned short len);
+
+extern void control_handler(void);
+extern void check_key_LED(void);
+extern void setup_dma(void);
+#ifndef __C51__
+extern void setup_io(void); // V2.1, x86 only
+#endif
+
+#define IN_TOKEN_DMA 	1
+#define OUT_TOKEN_DMA 	0
+
+#ifndef __C51__
+	#define DMA_BUFFER_SIZE		64000
+#else
+	#define DMA_BUFFER_SIZE		16384
+#endif
+
+#define DMA_IDLE	0
+#define DMA_RUNNING	1
+#define DMA_PENDING	2
+
+#define SETUP_DMA_REQUEST 		0x0471
+#define GET_FIRMWARE_VERSION    0x0472
+#define GET_SET_TWAIN_REQUEST   0x0473
+
+typedef struct _TWAIN_FILEINFO {
+	unsigned char	bPage;    // bPage bit 7 - 5 map to uSize bit 18 - 16
+	unsigned char	uSizeH;    // uSize bit 15 - 8
+	unsigned char	uSizeL;    // uSize bit 7 - 0
+} TWAIN_FILEINFO, *PTWAIN_FILEINFO;
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/common/serial_set2set.c u-boot-1.3.1_st2.3-32/board/dgstation/common/serial_set2set.c
--- u-boot-1.3.1/board/dgstation/common/serial_set2set.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/serial_set2set.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,317 @@
+#include <common.h>
+
+#ifdef CONFIG_SERIAL_SET2SET
+#ifndef CONFIG_DGS_FRONT
+#error "CONFIG_DGS_FRONT is needed with CONFIG_SERIAL_UPGRADE."
+#endif
+
+#include <command.h>
+#include "common/front.h"
+#include "common/upgrade.h"
+#include "common/flash_img_info.h"
+
+#define _CMD_PC_BR		0x22
+#define _CMD_PC_READY		0x05
+#define _RCV_READY		0x05
+#define _CMD_WHICH_FUNCTION	0xd0
+#define _CMD_START_UPLOAD	0xd1
+#define _RCV_REQ_HEADER		0x70
+
+#define TIMEOUT			500
+
+#pragma pack(1)
+struct DataHeader
+{
+	char valid;
+	char model_name[30];
+	char p_or_d;
+	char da;
+	char f_or_e;
+	unsigned int size;
+	char dummy;
+};
+#pragma pack()
+
+extern flash_img_info_t dgs_flash_imgs[];
+
+/* in serial_upgrade.c */
+extern int dg_getc( int to_ms );
+extern void gen_crc_table(void);
+extern unsigned long getCRC32(unsigned char *buff, int size);
+
+static int send_header( unsigned int size )
+{
+	unsigned char buf[64];
+	struct DataHeader header;
+	int key;
+	int a;
+
+	header.size = size;
+	strcpy( header.model_name, CFG_SERIALDOWN_HEADER );
+
+	memset( buf, 0, 64 );
+	memcpy( buf, &header, sizeof(header) );
+
+	key = dg_getc( TIMEOUT );
+	if( key != 0x70 )
+		return -1;
+
+	for( a=0; a<64; a++ )
+		__serial_putc( buf[a] );
+
+	return 0;
+}
+
+static int send_body( int block, int size, unsigned char *base )
+{
+	int a;
+	unsigned long crc;
+
+	block ++;
+
+	if( dg_getc( TIMEOUT ) != 0x69 )
+		return -1;
+	if( dg_getc( TIMEOUT ) != block%10 )
+		return -1;
+
+	crc = getCRC32( base, 1024 );
+
+	__serial_putc( 0x69 );
+	if( (size+1023)/1024 == block )
+		__serial_putc( 0xee );
+	else
+		__serial_putc( block % 10 );
+
+	for( a=0; a<1024; a++ )
+		__serial_putc( base[a] );
+
+	__serial_putc( crc >> 24 & 0xff );
+	__serial_putc( crc >> 16 & 0xff );
+	__serial_putc( crc >>  8 & 0xff );
+	__serial_putc( crc >>  0 & 0xff );
+
+	return 0;
+}
+
+static int prepare_bodyheader( unsigned long start, unsigned long size, const char *name )
+{
+	struct _image_header header;
+
+	header.magic = IMG_MAGIC;
+	header.structure_size = sizeof(header);
+	header.vendor_id = MY_VENDOR_ID;
+	header.product_id = MY_PRODUCT_ID;
+	header.hw_model = MY_HW_MODEL;
+	header.hw_version = MY_HW_VERSION;
+	strncpy( header.name, name, H_NAME_SIZE-1 );
+	header.name[H_NAME_SIZE-1] = 0;
+	header.start_addr = start;
+	header.erase_size = size;
+	header.data_offset = HEADER_SIZE;
+	header.data_size = size;
+	header.data_crc = crc32( 0xffffffff, (unsigned char*)start, size );;
+
+	memset( upg_buffer, 0, HEADER_SIZE );
+	memcpy( upg_buffer, &header, sizeof(header) );
+	*(unsigned long*)upg_buffer = crc32( 0xffffffff, (unsigned char*)upg_buffer+4, HEADER_SIZE-4 );
+
+	return 0;
+}
+
+int serial_set2set( int argc, char **argv )
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	int a;
+	int key;
+	int ret;
+	int imgnum;
+	int imgmax;
+	char buf[16];
+	unsigned long start, size;
+
+#ifdef CONFIG_DGS_FRONT_7SEG
+	front_puts( "S2S" );
+#else
+	front_puts( "set 2 set" );
+#endif
+
+	gen_crc_table();
+
+	upg_buffer = (unsigned char*)gd->dgs_upg_buffer;
+
+	{
+		int keys[2];
+
+		keys[0] = key_release;
+		keys[1] = key_front_release;
+		keys[3] = key_null;
+
+		front_waitkey( keys, 5 );
+	}
+
+	while( 1 )
+	{
+		/* select flash partition */
+		printf( "\npower to reboot.\n" );
+		for( a=0; dgs_flash_imgs[a].name; a++ )
+		{
+			printf( "%2d. %08x - %06x \"%s\"\n", a+1,
+					dgs_flash_imgs[a].start,
+					dgs_flash_imgs[a].size,
+					dgs_flash_imgs[a].name );
+		}
+		imgmax = a-1;
+
+		imgnum = 0;
+		printf( "image :   " );
+		while( 1 )
+		{
+			if( imgnum < 0 )
+				imgnum = 0;
+			if( imgnum > imgmax )
+				imgnum = imgmax;
+
+			sprintf( buf, "%d", imgnum+1 );
+			front_puts( buf );
+			printf( "\b\b%2d", imgnum+1 );
+			key = front_singlekey( 0 );
+			if( key == key_ok || key == key_front_ok )
+				break;
+			if(
+					key == key_down ||
+					key == key_front_down ||
+					key == key_left ||
+					key == key_front_left
+			  )
+			{
+				imgnum --;
+				continue;
+			}
+			if(
+					key == key_up ||
+					key == key_front_up ||
+					key == key_right ||
+					key == key_front_right
+			  )
+			{
+				imgnum ++;
+				continue;
+			}
+			if( key_0 <= key && key <= key_9 )
+			{
+				imgnum = key-key_0-1;
+				continue;
+			}
+			if( key == key_power || key == key_front_power )
+				return 0;
+		}
+
+		start = dgs_flash_imgs[imgnum].start;
+		size = dgs_flash_imgs[imgnum].size;
+		prepare_bodyheader( start, size, dgs_flash_imgs[imgnum].name );
+		printf( "\n\"%s\" ready.\n", dgs_flash_imgs[imgnum].name );
+		front_puts( "redy" );
+
+		/* let`s start */
+		gd->baudrate = 9600;
+		serial_setbrg();
+
+		while( dg_getc(0) != _CMD_PC_BR );
+		printf( "start downloading...\n" );
+		front_puts( "send" );
+		__serial_putc( _CMD_PC_BR );
+
+#if 1
+		__serial_putc( 6 );
+		gd->baudrate = 230400;
+#else
+		__serial_putc( 5 );
+		gd->baudrate = 115200;
+#endif
+		udelay( 100000 );
+		serial_setbrg();
+		udelay( 100000 );
+
+		for( a=0; a<4; a++ )
+		{
+			if( dg_getc( TIMEOUT ) == _CMD_PC_READY )
+				break;;
+		}
+		if( a == 4 )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+		__serial_putc( _CMD_PC_READY );
+
+		if( dg_getc( TIMEOUT ) != _CMD_WHICH_FUNCTION )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+		__serial_putc( 7 );
+		if( dg_getc( TIMEOUT ) != 7 )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+
+		size += HEADER_SIZE;
+
+		/* send header */
+		ret = send_header( size );
+		if( ret < 0 )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+
+		/* send body header */
+		for( a=0; a<4; a++ )
+		{
+			send_body( a, size, (unsigned char *)(upg_buffer+1024*a) );
+			if( ret < 0 )
+				break;
+		}
+		if( a != 4 )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+
+		/* send body */
+		for( a=4; a<((size+1023)/1024); a++ )
+		{
+			send_body( a, size, (unsigned char *)(start+1024*(a-4)) );
+			if( ret < 0 )
+				break;
+		}
+		if( a != (size+1023)/1024 )
+		{
+			printf( "protocal error.%d\n", __LINE__ );
+			front_puts( "failed" );
+			continue;
+		}
+
+		printf( "successed.\n" );
+	}
+}
+
+int do_serial_set2set( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	return serial_set2set( argc, argv );
+}
+
+U_BOOT_CMD(
+		serial_set2set, 14, 0, do_serial_set2set,
+		"serial_set2set- send flash image to another.\n",
+		"start set2set through serial port.\n" );
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/common/serial_upgrade.c u-boot-1.3.1_st2.3-32/board/dgstation/common/serial_upgrade.c
--- u-boot-1.3.1/board/dgstation/common/serial_upgrade.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/serial_upgrade.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,553 @@
+#include <common.h>
+
+#ifdef CONFIG_SERIAL_UPGRADE
+#ifndef CONFIG_DGS_FRONT
+#error "CONFIG_DGS_FRONT is needed with CONFIG_SERIAL_UPGRADE."
+#endif
+
+#include <command.h>
+#include <malloc.h>
+#include "common/front.h"
+
+#include "common/upgrade.h"
+
+/* 현재 TV 스크린으로 로그를 볼 수 없다. */
+#define dprintf(a,b...) do{}while(0)//printf(a,##b)
+//#define dprintf(a,b...) printf(a,##b)
+
+//--------------------------------------//
+//          Command Define              //
+//--------------------------------------//
+#define   _CMD_PC_BR             0x22
+#define   _CMD_PC_READY          0x05
+#define   _RCV_READY             0x05
+#define   _CMD_WHICH_FUNCTION    0xd0
+#define   _CMD_START_UPLOAD      0xd1
+#define   _RCV_REQ_HEADER        0x70
+
+#define TIMEOUT 500
+#define RETRY 2
+
+#define CRC32 0x04c11db7
+
+#pragma pack(1)
+struct DataHeader
+{
+	char valid;
+	char model_name[30];
+	char p_or_d;
+	char da;
+	char f_or_e;
+	unsigned int size;
+	char dummy;
+};
+
+struct _serial_image_header
+{
+	unsigned long header_crc32;
+	unsigned long image_size;
+};
+#pragma pack()
+
+/*
+ * variables for dgstation serial download...
+ */
+#if 0
+unsigned char Flash_is_Writed_Sequence[64] = {
+	10, 63, 18, 53,  2, 44, 19, 34,
+	 0, 12, 20, 26, 45, 37, 46,  8,
+	38, 14, 27,  7, 57, 33, 11, 17,
+	35, 16, 29,  4,  5,  9, 21, 56,
+	58, 55, 25, 48, 49, 50, 43, 13,
+	 3, 36, 39,  6, 23, 51, 61, 59,
+	15, 41, 62, 24, 28, 22, 30, 42,
+	 1, 40, 47, 52, 31, 60, 32, 54,
+};
+
+unsigned char Scramble_Number_Flash_is_Writed[64] = {
+	0xc9, 0x9c, 0x2a, 0x41, 0x43, 0x6d, 0xc0, 0xe2,
+	0xf6, 0x8c, 0x11, 0xf9, 0x73, 0xca, 0x35, 0x38,
+	0xe0, 0x1c, 0x72, 0x4c, 0xb9, 0xd7, 0x61, 0x61,
+	0xee, 0x2f, 0x14, 0x41, 0x44, 0x9a, 0xe1, 0xff,
+	0x2b, 0xcf, 0xff, 0x00, 0xf0, 0xbe, 0xe4, 0xf9,
+	0x6a, 0x68, 0x6d, 0xbd, 0x2b, 0xde, 0x67, 0xda,
+	0xcd, 0xe0, 0x1f, 0x57, 0xaf, 0xd3, 0x40, 0x9b,
+	0xea, 0x9e, 0xda, 0x1e, 0x7d, 0x3c, 0xd3, 0xa0,
+};
+#endif
+unsigned int *dg_crc_table;
+
+/*
+ * functions for dgstation serial download...
+ */
+void gen_crc_table(void)
+{
+	int i, j;
+	unsigned long acc, data;
+
+	dg_crc_table = malloc( 256*sizeof(unsigned int) );
+
+	for( i=0 ; i<256 ; i++ )
+	{
+		data = ( (unsigned long) i << 24 );
+		acc = 0;
+		for( j=0 ; j<8 ; j++ )
+		{
+			if( (data ^ acc) & 0x80000000L )
+				acc = ( acc << 1 ) ^ CRC32;
+			else
+				acc = ( acc << 1 );
+			data <<= 1;
+		}
+		dg_crc_table[i] = acc;
+	}
+	return;
+}
+
+void crc_update(unsigned int data, unsigned long *acc)
+{
+	int i;
+
+	i = ((int)( *acc >> 24) ^ data ) & 0xff;
+	*acc = ( *acc << 8 ) ^ dg_crc_table[i];
+}
+
+unsigned long getCRC32(unsigned char *buff, int size)
+{
+	unsigned long acc=0x0L;
+	int i;
+
+	for( i=0 ; i<size ; i++ )
+	{
+		crc_update(*(buff+i), &acc);
+	}
+	return acc;
+}
+
+void clean_crc_table( void )
+{
+	free( dg_crc_table );
+}
+
+int dg_getc( int to_ms )
+{
+	unsigned long long stime = get_ticks();
+
+	do
+	{
+		if( serial_tstc() )
+			return serial_getc();
+	}while( get_ticks() < stime+(get_tbclk()/1000*to_ms) );
+
+	return -1;
+}
+
+int receive_header( void )
+{
+	int a, b;
+	int key;
+	unsigned char buffer[64];
+//	struct _serial_image_header header;
+	struct DataHeader header;
+
+	/*
+	 * request header...
+	 * and get header...
+	 */
+
+	serial_putc( 0x70 );
+	for( a=0; a<64; a++ )
+	{
+		for( b=0; b<10; b++ )
+		{
+			key = dg_getc( TIMEOUT );
+			if( key != -1 )
+				break;
+		}
+		if( b == 10 )
+		{
+			udelay(3000000);
+	
+			/* ok 키를 기다렸다가 시리얼로 보냄 */
+			do
+			{
+				key = front_getkey();
+			}while(key != key_front_ok);
+			dprintf( "header timeout.(got %d)\n", a );
+			return -1;
+		}
+		
+		buffer[a] = key;
+	}
+	memcpy( &header, buffer, sizeof(header) );
+	header.size = ntohl( header.size );
+
+	/*
+	 * compare model name.
+	 */
+	if( strcmp( header.model_name, CFG_SERIALDOWN_HEADER ) )
+	{
+		dprintf( "image is not mine.(got\"%s\",expected\"%s\"\n",
+				header.model_name, CFG_SERIALDOWN_HEADER );
+		return -1;
+	}
+
+	return header.size;
+}
+
+int receive_body( int block_number, int body_size )
+{
+	int a, b;
+	int key;
+	int last_block = 0;
+	unsigned long received_crc, my_crc;
+	unsigned char block_buffer[2+1024+4];
+
+	block_number ++;
+
+	/*
+	 * send request block code.
+	 */
+	serial_putc( 0x69 );
+	serial_putc( block_number%10 );
+
+	/*
+	 * get real body.
+	 */
+	for( a=0; a<2+1024+4; a++ )
+	{
+		for( b=0; b<10; b++ )
+		{
+			key = dg_getc( TIMEOUT );
+			if( key != -1 )
+				break;
+		}
+		if( b == 10 )
+		{
+			dprintf( "body time out.(%d,%d)\n", block_number, a );
+			return -1;
+		}
+
+		block_buffer[a] = key;
+	}
+
+	/*
+	 * check block is not broken.
+	 */
+	if( block_buffer[0] != 0x69 )
+	{
+		dprintf( "block header is broken.(0x%02x)\n", block_buffer[0] );
+		return -1;
+	}
+	if( (body_size+1023)/1024 == block_number )
+	{
+		if( block_buffer[1] != 0xee )
+		{
+			dprintf( "block sequence is broken.\n" );
+			return -1;
+		}
+		last_block = 1;
+	}
+	else
+	{
+		if( block_buffer[1] != block_number%10 )
+		{
+			dprintf( "block sequence is broken.(%d)\n", block_buffer[1] );
+			return -1;
+		}
+	}
+	received_crc = block_buffer[2+1024+0]<<24;
+	received_crc |= block_buffer[2+1024+1]<<16;
+	received_crc |= block_buffer[2+1024+2]<<8;
+	received_crc |= block_buffer[2+1024+3]<<0;
+	my_crc = getCRC32( &block_buffer[2], 1024 );
+	if( received_crc != my_crc )
+	{
+		dprintf( "body crc error.\n" );
+		return -1;
+	}
+
+	/*
+	 * move data to body buffer.
+	 */
+	memcpy( &upg_buffer[(block_number-1)*1024], &block_buffer[2], 1024 );
+
+	return 0;
+}
+
+int do_serial_download( void )
+{
+	int data_size;
+	int ret = 0;
+	int a;
+
+	dprintf( "start download... wait...\n" );
+	/*
+	 * get header.
+	 */
+	if( (data_size=receive_header())<0 )
+	{
+		dprintf( "header error.\n" );
+		ret = -1;
+		goto terminate;
+	}
+
+	/*
+	 * get body...
+	 */
+	for( a=0; a<(data_size+1023)/1024; a++ )
+	{
+		if( receive_body( a, data_size ) )
+		{
+			dprintf( "body error.\n" );
+			ret = -1;
+			goto terminate;
+		}
+
+		front_persent( a, (data_size+1023)/1024 );
+	}
+
+	/*
+	 * burn image to flash.
+	 */
+	ret = burn_flash();
+
+terminate:
+	serial_putc( 0x70 );
+	serial_putc( 0x70 );
+	serial_putc( 0x70 );
+
+	return ret;
+}
+
+int serial_main( int argc, char *argv[] )
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+//	int retry;
+	int key;
+	int baudrate;
+	int a;
+	int ret = 0;
+
+	front_puts( "serial upgrade" );
+
+	gen_crc_table();
+
+	upg_buffer = (unsigned char*)gd->dgs_upg_buffer;
+
+#if 0
+	{
+		int keys[3];
+
+		keys[0] = key_release;
+		keys[1] = key_front_release;
+		keys[2] = key_null;
+
+		front_waitkey( keys, 5 );
+	}
+#else
+	{
+		unsigned long long starttime;
+
+		starttime = get_ticks();
+
+		while( get_ticks() < (starttime+5*get_tbclk()) )
+		{
+			if( front_tstc() )
+			{
+				key = front_getkey();
+				if( key == key_release || key == key_front_release )
+					break;
+			}
+		}
+	}
+#endif
+	
+	dprintf( "serial download...\n" );
+//	for( retry=0; retry<RETRY; retry++ )
+	while( 1 )
+	{
+		/*
+		 * check key is pressed.
+		 */
+		dprintf( "\n" );
+		dprintf( "press Ok button to start download.\n" );
+		dprintf( "Or press power to reboot.\n" );
+#if 1
+		{
+			int keys[5];
+			int key;
+
+			keys[0] = key_ok;
+			keys[1] = key_front_ok;
+			keys[2] = key_power;
+			keys[3] = key_front_power;
+			keys[4] = key_null;
+
+			key = front_waitkey( keys, 0 );
+			if( key == key_power || key == key_front_power )
+				goto terminate;
+		}
+#else
+		while( 1 )
+		{
+			key = front_getkey();
+			if( key == key_ok || key == key_front_ok )
+			{
+				while( 1 )
+				{
+					key = front_getkey();
+					if( key == key_release || key == key_front_release )
+						break;
+				}
+				break;
+			}
+
+			/*
+			 * check pwr button.
+			 */
+			if( key == key_power || key == key_front_power )
+			{
+				while( 1 )
+				{
+					key = front_getkey();
+					if( key == key_release || key == key_front_release )
+						break;
+				}
+				goto terminate;
+			}
+		}
+#endif
+
+		gd->baudrate = 9600;
+		serial_setbrg();
+
+		while( serial_tstc() )
+			serial_getc();
+		
+		serial_putc( _CMD_PC_BR );
+
+		key = dg_getc( TIMEOUT*4 );	// large file in PC can couse timeout.
+		if( key != _CMD_PC_BR )	// ack로 _CMD_PC_BR을 받음
+		{
+			dprintf( "PC is not responding.. will retry.\n" );
+			goto do_retry;
+		}
+
+		key = dg_getc( TIMEOUT );
+		switch( key )
+		{
+			case 1:
+				baudrate = 9600;
+				break;
+			case 2:
+				baudrate = 19200;
+				break;
+			case 3:
+				baudrate = 38400;
+				break;
+			case 4:
+				baudrate = 57600;
+				break;
+			case 5:
+				baudrate = 115200;
+				break;
+			case 6:
+				baudrate = 230400;
+				break;
+			default:
+				{
+					goto do_retry;
+				}
+		}
+
+		/*
+		 * change real baud rate.
+		 */
+		if( baudrate != 9600 )
+		{
+			gd->baudrate = baudrate;
+			serial_setbrg();
+		}
+
+		/*
+		 * wait to PC change baud rate.
+		 */
+		for( a=0; a<10; a++ )
+		{
+			serial_putc( _CMD_PC_READY );
+			key = dg_getc( TIMEOUT );
+			if( key == _CMD_PC_READY )
+				break;
+		}
+		if( a == 10 )
+		{
+			dprintf( "PC doesn`t respond PC rdy.\n" );
+			goto do_retry;
+		}
+
+		/*
+		 * receive function number...
+		 */
+		for( a=0; a<10; a++ )
+		{
+			serial_putc( _CMD_WHICH_FUNCTION );
+			key = dg_getc( TIMEOUT );
+			if( key != -1 )
+				break;
+		}
+		if( a == 10 )
+		{
+			dprintf( "PC doesn`t send function number.\n" );
+			goto do_retry;
+		}
+		serial_putc( key );
+
+		/*
+		 * Do PC wanted work.
+		 */
+		switch( key )
+		{
+			case 7:
+				ret = do_serial_download();
+				break;
+			case 8:
+				break;
+			default:
+				goto do_retry;
+		}
+
+		if( ret )
+			goto do_retry;
+
+		continue;
+do_retry:
+		;
+		front_puts( "error" );
+	}
+
+terminate:
+//	if( retry == RETRY )
+//		ret = -1;
+
+	gd->baudrate = CONFIG_BAUDRATE;
+	serial_setbrg();
+
+	clean_crc_table();
+
+	return ret;
+}
+
+int do_serial_upgrade( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	return serial_main(argc,argv);
+}
+
+U_BOOT_CMD(
+		serial_upgrade, 14, 0, do_serial_upgrade,
+		"serial_upgrade- upgrade system with serial port.\n",
+		"run serial download.\n"
+		" if you want to debug, append debug after dg_serial.\n" );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/common/tvmode.c
--- u-boot-1.3.1/board/dgstation/common/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,148 @@
+
+#include <common.h>
+#include <command.h>
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define NO_NTSC		/* remove NTSC mode */
+
+#define N_TVMODE	6	
+
+#ifdef CONFIG_DGS_FRONT_7SEG	/* TODO : we have to change message if NTSC enanbled */
+char *tvmode_name[N_TVMODE] = {
+	"PAL",	"SD-NTSC", 
+	"720",	"720P-60", 
+	"1080",	"1080I-60"};
+#else
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50",	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#endif
+
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts(tvmode_name[mode]);
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+#ifdef NO_NTSC
+		mode &= 0xfe;
+#endif
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+#ifdef NO_NTSC
+					mode++;
+#endif
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+#ifdef NO_NTSC
+					mode--;
+#endif
+					if(mode<0) 
+					{
+						mode = N_TVMODE-1;
+#ifdef NO_NTSC
+						mode--;
+#endif
+					}
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/common/upgrade.c u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade.c
--- u-boot-1.3.1/board/dgstation/common/upgrade.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,341 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_UPGRADE
+
+#include "common/upgrade.h"
+
+#ifdef CONFIG_DGS_FRONT
+#include "common/front.h"
+#else
+#error Need CONFIG_DGS_FRONT config.
+#endif
+
+unsigned char *upg_buffer;
+int upg_buffer_len;
+enum _upg_buffer_status upg_buffer_status;
+char *upg_buffer_message;
+int upg_buffer_errorno;
+int upg_verbose_message;
+
+/*
+ * start writing the image to flash.
+ * return:
+ * 	0 : nomal terminate. all is completed.
+ * 	2 : writing failed. this will not happen...
+ * 	3 : image error. unknown image or crc error.
+ */
+int burn_flash( void )
+{
+	struct _image_header header;
+	int ret = 0;
+	unsigned long crc;
+	unsigned long header_crc;
+	unsigned long data_start;
+	unsigned long data_size;
+	unsigned long erase_size;
+	int err;
+
+	printf( "checking received image...\n" );
+	
+	/*
+	 * check header and body is correct.
+	 */
+	crc = crc32( 0xffffffff, upg_buffer+4, HEADER_SIZE-4 );
+	header_crc = ntohl( *(unsigned long*)upg_buffer );
+	if( header_crc != crc )
+	{
+		printf( "header crc is not correct.(got 0x%08x,expected 0x%08x)\n",
+				(int)*(unsigned long*)upg_buffer, (int)crc );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 1" );
+#endif
+		upg_buffer_errorno = 1;
+		goto terminate_witherr;
+	}
+
+	memcpy( &header, upg_buffer, sizeof(struct _image_header) );
+
+	header.magic		= ntohl( header.magic );
+	header.structure_size	= ntohl( header.structure_size );
+	header.vendor_id	= ntohl( header.vendor_id );
+	header.product_id	= ntohl( header.product_id );
+	header.hw_model		= ntohl( header.hw_model );
+	header.hw_version	= ntohl( header.hw_version );
+	header.start_addr	= ntohl( header.start_addr );
+	header.erase_size	= ntohl( header.erase_size );
+	header.data_offset	= ntohl( header.data_offset );
+	header.data_size	= ntohl( header.data_size );
+	header.data_crc		= ntohl( header.data_crc );
+
+	if( upg_verbose_message )
+	{
+		printf( "magic          : 0x%08x\n", (int)header.magic );
+		printf( "structure_size : 0x%08x\n", (int)header.structure_size );
+		printf( "vendor_id      : 0x%08x\n", (int)header.vendor_id );
+		printf( "product_id     : 0x%08x\n", (int)header.product_id );
+		printf( "hw_model       : 0x%08x\n", (int)header.hw_model );
+		printf( "hw_version     : 0x%08x\n", (int)header.hw_version );
+		printf( "start_addr     : 0x%08x\n", (int)header.start_addr );
+		printf( "erase_size     : 0x%08x\n", (int)header.erase_size );
+		printf( "data_offset    : 0x%08x\n", (int)header.data_offset );
+		printf( "data_size      : 0x%08x\n", (int)header.data_size );
+		printf( "data_crc       : 0x%08x\n", (int)header.data_crc );
+		printf( "name           : \"%s\"\n", header.name );
+	}
+
+	crc = crc32( 0xffffffff, &upg_buffer[header.data_offset], header.data_size );
+	if( header.data_crc != crc )
+	{
+		printf( "data crc is not correct.(got 0x%08x,expected 0x%08x)\n",
+				(int)header.data_crc, (int)crc );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 2" );
+#endif
+		upg_buffer_errorno = 2;
+		goto terminate_witherr;
+	}
+
+	/*
+	 * determin image is mine.
+	 */
+	if( header.vendor_id != MY_VENDOR_ID )
+	{
+		printf( "vendor id is not mine.(got 0x%08x,expected 0x%08x)\n",
+				(int)header.vendor_id, MY_VENDOR_ID );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 3" );
+#endif
+		upg_buffer_errorno = 3;
+		goto terminate_witherr;
+	}
+	if( header.product_id != MY_PRODUCT_ID )
+	{
+		printf( "product id is not mine.(got 0x%08x,expected 0x%08x)\n",
+				(int)header.product_id, MY_PRODUCT_ID );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 4" );
+#endif
+		upg_buffer_errorno = 4;
+		goto terminate_witherr;
+	}
+	if( header.hw_model != MY_HW_MODEL )
+	{
+		printf( "hardware model is not mine.(got 0x%08x,expected 0x%08x)\n",
+				(int)header.hw_model, MY_HW_MODEL );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 5" );
+#endif
+		upg_buffer_errorno = 5;
+		goto terminate_witherr;
+	}
+
+	if( header.hw_version != MY_HW_VERSION )
+	{
+		printf( "hardware version is not mine.(got 0x%08x,expected 0x%08x)\n",
+				(int)header.hw_version, MY_HW_VERSION );
+		ret = 3;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 6" );
+#endif
+		upg_buffer_errorno = 5;
+		goto terminate_witherr;
+	}
+
+	header.name[H_NAME_SIZE-1] = 0;
+	printf( "got %s image.\n", header.name );
+	data_start = header.start_addr;
+	data_size  = header.data_size;
+	erase_size = header.erase_size;
+	if( data_start+erase_size-1 >= (unsigned long)CFG_MONITOR_BASE )
+	{
+		printf( "updating boot loader.\n" );
+		printf( "DO NOT TURN OFF THE POWER while updating!!!\n" );
+	}
+	
+	/*
+	 * erase flash first...
+	 */
+	printf( "erase 0x%08x - 0x%08x\n", (int)data_start, (int)data_start+erase_size-1 );
+	upg_buffer_status = UPGBUF_ERASE;
+
+#ifdef CONFIG_DGS_FRONT_PROGRESSBAR
+#ifdef CONFIG_DGS_FRONT_7SEG
+	char buf[5]={0,};
+	strcpy(buf, "ES00");
+	front_puts( buf );
+#else
+	char buf[14]={0,};
+	strcpy(buf, "ERASING 00");
+	front_puts( buf );
+#endif
+#else
+	front_puts( "ERASING" );
+#endif
+
+#ifdef CONFIG_DGS_FRONT_PROGRESSBAR	// 플래시가 uniform 인가 확인해야 한다.
+	unsigned int erased, start, end;
+	// cuberevo는 uniform flash를 쓴다.
+	unsigned int sector_size = 128*1024; 	// 128KByte
+	unsigned int sector_count = 2;		// 한번에 지우고 쓰는 섹터수
+	unsigned int percent;
+	erased = 0;
+	while( erased < erase_size )
+	{
+		start = data_start + erased;
+		end = start + sector_size*sector_count;
+
+		if(end > (data_start+erase_size) )
+			end = data_start+erase_size;
+		
+		if( flash_sect_erase(start, end-1) )
+		{
+			printf( "erase error.\n" );
+			ret = 2;
+#ifdef CONFIG_DGS_FRONT
+			front_puts( "Er 8" );
+#endif
+			upg_buffer_errorno = 8;
+			goto terminate_witherr;
+		}
+		erased += sector_size*sector_count;
+
+		percent = (int)(erased*100/erase_size);
+#ifdef CONFIG_DGS_FRONT_7SEG
+		buf[2] = percent/10 + '0';
+		buf[3] = percent%10 + '0'; 
+#else
+		buf[8] = percent/10 + '0';
+		buf[9] = percent%10 + '0'; 
+#endif
+		front_puts( buf );
+	}
+#else // CONFIG_DGS_FRONT_PROGRESSBAR 
+	if( flash_sect_erase(data_start,data_start+erase_size-1) )
+	{
+		printf( "erase error.\n" );
+		ret = 2;
+#ifdef CONFIG_DGS_FRONT
+		front_puts( "Er 8" );
+#endif
+		upg_buffer_errorno = 8;
+		goto terminate_witherr;
+	}
+#endif
+
+
+	/*
+	 * and... write the body to flash...
+	 */
+	if( data_size != 0 )
+	{
+		printf( "write to flash...\n" );
+		
+		upg_buffer_status = UPGBUF_WRITE;
+#ifdef CONFIG_DGS_FRONT
+#ifdef CONFIG_DGS_FRONT_PROGRESSBAR
+#ifdef CONFIG_DGS_FRONT_7SEG
+		strcpy(buf, "FL00");
+		front_puts( buf );
+#else
+		strcpy(buf, "FLASHING 00");
+		front_puts( buf );
+#endif
+#else
+		front_puts( "FLASHING" );
+#endif
+#endif
+
+#ifdef CONFIG_DGS_FRONT_PROGRESSBAR
+		unsigned int written;
+		int to_write;
+
+		written = 0;
+		while( written < data_size )
+		{
+			start = data_start + written;
+			to_write = sector_size*sector_count;
+
+			if((written+to_write) > data_size)
+				to_write = data_size - written;
+
+			err = flash_write(&upg_buffer[header.data_offset + written],
+					start,
+					to_write);
+			if( err )
+			{
+				flash_perror( err );
+				ret = 2;
+#ifdef CONFIG_DGS_FRONT
+				front_puts( "Er 9" );
+#endif
+				upg_buffer_errorno = 9;
+				goto terminate_witherr;
+			}
+			written += to_write;
+			percent = (int)(written*100/data_size);
+#ifdef CONFIG_DGS_FRONT_7SEG
+			buf[2] = percent/10 + '0';
+			buf[3] = percent%10 + '0'; 
+#else
+			buf[9] = percent/10 + '0';
+			buf[10] = percent%10 + '0'; 
+#endif
+			front_puts( buf );
+		}
+#else
+		err = flash_write(
+				&upg_buffer[header.data_offset],
+				data_start,
+				data_size
+				);
+		if( err )
+		{
+			flash_perror( err );
+			ret = 2;
+#ifdef CONFIG_DGS_FRONT
+			front_puts( "Er 9" );
+#endif
+			upg_buffer_errorno = 9;
+			goto terminate_witherr;
+		}
+#endif
+	}
+
+	printf( "completed...\n" );
+
+#ifdef CONFIG_DGS_FRONT
+	front_puts( "done" );
+#endif
+
+	goto terminate;
+
+terminate_witherr:
+	if( ret == 2 )
+	{
+		printf( "WARNING!!! The STB may not boot in next power up.\n" );
+		printf( "The error is unrecoverable.\n" );
+		printf( "Capture this screen and contact to vendor.\n" );
+	}
+	else if( ret == 3 )
+	{
+		printf( "Maybe you transferred wrong file.\n" );
+	}
+	printf( "My hardware model  : %08x\n", MY_HW_MODEL );
+	printf( "My hardware version: %08x\n", MY_HW_VERSION );
+
+terminate:
+	upg_buffer_status = UPGBUF_UNUSED;
+
+	printf( "Select another file.\n" );
+	printf( "Or press power to reboot.\n" );
+	printf( "\n" );
+
+	return ret;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/upgrade.h u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade.h
--- u-boot-1.3.1/board/dgstation/common/upgrade.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#ifndef _DGS_UPGRADE_H
+#define _DGS_UPGRADE_H
+
+#define IMG_MAGIC       (('F'<<24)|('i'<<16)|('m'<<8)|('g'<<0))
+#define DATA_OFFSET     0x1000
+#define BUF_SIZE        DATA_OFFSET             // must be same with data_offset???
+#define HEADER_SIZE	DATA_OFFSET
+#define H_NAME_SIZE	32
+struct _image_header
+{
+	unsigned long header_crc;	/* crc from 4 ~ HEADER_SIZE */
+	unsigned long magic;		/* magic number. IMG_MAGIC */
+	unsigned long structure_size;	/* size of this structure */
+
+	unsigned long vendor_id;	/* vender id */
+	unsigned long product_id;	/* product id */
+
+	unsigned long hw_model;		/* MY_HW_MODEL */
+	unsigned long hw_version;
+
+	unsigned long start_addr;	/* start address of write to flash. */
+	unsigned long erase_size;	/* erase size from start_addr */
+
+	unsigned long data_offset;	/* offset of acture data */
+	unsigned long data_size;	/* size of acture data */
+	unsigned long data_crc;		/* crc from data_offset ~ (data_offset+data_size) */
+
+	char name[H_NAME_SIZE];		/* name of this image */
+};
+
+extern int burn_flash( void );
+
+/*
+ * buffer status for upg_buffer.
+ *  will be stored in upg_buffer_status.
+ */
+enum _upg_buffer_status
+{
+	UPGBUF_UNUSED = 0,
+	UPGBUF_DOWNLOAD,
+	UPGBUF_ERASE,
+	UPGBUF_WRITE,
+};
+
+extern unsigned char *upg_buffer;
+extern int upg_buffer_len;
+extern enum _upg_buffer_status upg_buffer_status;
+extern char *upg_buffer_message;
+extern int upg_verbose_message;
+/*
+ * upg_buffer_errorno
+ *  0 : no error
+ *  1 : wrong header crc
+ *  2 : wrong data crc
+ *  3 : incorrect vendor id
+ *  4 : incorrect product id
+ *  5 : wrong hardware model or version
+ *  6 :
+ *  7 :
+ *  8 : flash erase failed
+ *  9 : flash write failed
+ */
+extern int upg_buffer_errorno;
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/upgrade_host.c u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade_host.c
--- u-boot-1.3.1/board/dgstation/common/upgrade_host.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/upgrade_host.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,148 @@
+/*
+   Update s/w from usb host device  @ DGStation
+
+	* Known Bugs *
+		- do not process error case if no memorystick or no file ....
+		- sometimes can't load usb_update.img if too much file is exist in memory stick.
+*/
+
+#include <common.h>
+#include <command.h>
+#include "front.h"
+
+#if defined(CONFIG_DGS_UPGRADE) && defined(CONFIG_SH_STB7100_USB)
+DECLARE_GLOBAL_DATA_PTR;
+static char *interface = "usb";
+static char *file = "usb_update.img";
+extern unsigned char *upg_buffer; 
+#if defined(CONFIG_USB_STORAGE)
+extern int usb_stor_curr_dev; /* current device */
+#endif
+
+/* mount fat and load binary to memory */
+long load_update_image()
+{
+	int i;
+	long size;
+	unsigned long offset;
+	unsigned long count;
+	char buf [12];
+	block_dev_desc_t *dev_desc=NULL;
+	int dev=0;
+	int part=1;
+	char *ep;
+
+	/* start usb */
+	sh_disable_data_caches();
+	usb_stop();
+	i = usb_init();
+#if defined(CONFIG_USB_STORAGE)
+	if(i>=0)
+		usb_stor_curr_dev = usb_stor_scan(1);
+#endif
+	sh_enable_data_caches();
+
+	/* read file from specified usb part */
+	dev = 0;
+	part = 1;
+	dev_desc = get_dev(interface, dev);
+	if(fat_register_device(dev_desc, part)!=0)
+	{
+		printf ("Unable to use %s %d:%d !!\n",interface, dev,part);
+		goto go_usb_stop;
+	}
+	
+	offset = gd->dgs_upg_buffer;
+	count = 0; /* read file totally */
+	size = file_fat_read(file, (unsigned char*)offset, count);
+	if(size==-1) {
+		printf("Unable to read \"%s\" from %s %d:%d !!\n",
+				file, interface, dev, part);
+		goto go_usb_stop;
+	}
+	sprintf(buf, "%lX", size);
+	setenv("filesize", buf);
+	
+	/* stop usb */
+	usb_stop();
+
+	return size;
+
+go_usb_stop:;
+	/* stop usb */
+	usb_stop();
+	return -1;
+}
+
+static int do_update( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	long size;
+	int key;
+	int keys[5];
+	unsigned long long starttime;
+
+	front_puts("USB UPGRADE");
+
+	keys[0] = key_release;
+	keys[1] = key_front_release;
+	keys[2] = key_null;
+	front_waitkey( keys, 0 );
+
+	/* set start address used by burn_flash() */
+	upg_buffer = gd->dgs_upg_buffer;  
+
+	front_puts("LOAD SW");
+retry_download:;
+	if((size=load_update_image()) <= 0)
+	{
+		printf("Update s/w load fail\n");
+#if defined(CONFIG_DGS_FRONT_7SEG)
+		front_puts("Er10");
+#else
+		front_puts("Er 10");
+#endif
+		goto fail;
+	}
+	
+	printf("%s readed(%d bytes)\n", file, size);
+	
+	if(burn_flash() == 0)
+	{
+		printf("Completed !\n");
+	}
+	else
+	{
+		//return 1;
+		printf("Update error !\n");
+	}
+
+fail:;
+	/* check power key */
+	keys[0] = key_power;
+	keys[1] = key_front_power;
+	keys[2] = key_ok;
+	keys[3] = key_front_ok;
+	keys[4] = key_null;
+
+	key = front_waitkey( keys, 0 );
+	if(key==key_ok || key==key_front_ok)
+	{
+		printf("Retry.\n");
+		front_puts("USB UPGRADE");
+		goto retry_download;
+	}
+
+	/* reboot */
+	return 0;
+}
+
+U_BOOT_CMD(
+	usbupghost,	1,	0,	do_update,
+	"usbupghost - update s/w from usb host memorystick\n",
+	""
+	""
+	""
+);
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/common/usb100.h u-boot-1.3.1_st2.3-32/board/dgstation/common/usb100.h
--- u-boot-1.3.1/board/dgstation/common/usb100.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/usb100.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,224 @@
+#ifndef   __USB100_H__
+#define   __USB100_H__
+
+
+#define MAXIMUM_USB_STRING_LENGTH 255
+
+// values for the bits returned by the USB GET_STATUS command
+#define USB_GETSTATUS_SELF_POWERED                0x01
+#define USB_GETSTATUS_REMOTE_WAKEUP_ENABLED       0x02
+
+
+#define USB_DEVICE_DESCRIPTOR_TYPE                0x01
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE         0x02
+#define USB_STRING_DESCRIPTOR_TYPE                0x03
+#define USB_INTERFACE_DESCRIPTOR_TYPE             0x04
+#define USB_ENDPOINT_DESCRIPTOR_TYPE              0x05
+#define USB_POWER_DESCRIPTOR_TYPE                 0x06
+
+#define USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(d, i) ((USHORT)((USHORT)d<<8 | i))
+
+//
+// Values for bmAttributes field of an
+// endpoint descriptor
+//
+
+#define USB_ENDPOINT_TYPE_MASK                    0x03
+
+#define USB_ENDPOINT_TYPE_CONTROL                 0x00
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
+#define USB_ENDPOINT_TYPE_BULK                    0x02
+#define USB_ENDPOINT_TYPE_INTERRUPT               0x03
+
+
+//
+// definitions for bits in the bmAttributes field of a 
+// configuration descriptor.
+//
+#define USB_CONFIG_POWERED_MASK                   0xc0
+
+#define USB_CONFIG_BUS_POWERED                    0x80
+#define USB_CONFIG_SELF_POWERED                   0x40
+#define USB_CONFIG_REMOTE_WAKEUP                  0x20
+
+//
+// Endpoint direction bit, stored in address
+//
+
+#define USB_ENDPOINT_DIRECTION_MASK               0x80
+
+// test direction bit in the bEndpointAddress field of
+// an endpoint descriptor.
+#define USB_ENDPOINT_DIRECTION_OUT(addr)          (!((addr) & USB_ENDPOINT_DIRECTION_MASK))
+#define USB_ENDPOINT_DIRECTION_IN(addr)           ((addr) & USB_ENDPOINT_DIRECTION_MASK)
+
+//
+// USB defined request codes
+// see chapter 9 of the USB 1.0 specifcation for
+// more information.
+//
+
+// These are the correct values based on the USB 1.0
+// specification
+
+#define USB_REQUEST_GET_STATUS                    0x00
+#define USB_REQUEST_CLEAR_FEATURE                 0x01
+
+#define USB_REQUEST_SET_FEATURE                   0x03
+
+#define USB_REQUEST_SET_ADDRESS                   0x05
+#define USB_REQUEST_GET_DESCRIPTOR                0x06
+#define USB_REQUEST_SET_DESCRIPTOR                0x07
+#define USB_REQUEST_GET_CONFIGURATION             0x08
+#define USB_REQUEST_SET_CONFIGURATION             0x09
+#define USB_REQUEST_GET_INTERFACE                 0x0A
+#define USB_REQUEST_SET_INTERFACE                 0x0B
+#define USB_REQUEST_SYNC_FRAME                    0x0C
+
+
+//
+// defined USB device classes
+//
+
+
+#define USB_DEVICE_CLASS_RESERVED           0x00
+#define USB_DEVICE_CLASS_AUDIO              0x01
+#define USB_DEVICE_CLASS_COMMUNICATIONS     0x02
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE    0x03
+#define USB_DEVICE_CLASS_MONITOR            0x04
+#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE 0x05
+#define USB_DEVICE_CLASS_POWER              0x06
+#define USB_DEVICE_CLASS_PRINTER            0x07
+#define USB_DEVICE_CLASS_STORAGE            0x08
+#define USB_DEVICE_CLASS_HUB                0x09
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC    0xFF
+
+//
+// USB defined Feature selectors
+//
+
+#define USB_FEATURE_ENDPOINT_STALL          0x0000
+#define USB_FEATURE_REMOTE_WAKEUP           0x0001
+#define USB_FEATURE_POWER_D0                0x0002
+#define USB_FEATURE_POWER_D1                0x0003
+#define USB_FEATURE_POWER_D2                0x0004
+#define USB_FEATURE_POWER_D3                0x0005
+
+typedef struct _USB_DEVICE_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    USHORT bcdUSB;
+    UCHAR bDeviceClass;
+    UCHAR bDeviceSubClass;
+    UCHAR bDeviceProtocol;
+    UCHAR bMaxPacketSize0;
+    USHORT idVendor;
+    USHORT idProduct;
+    USHORT bcdDevice;
+    UCHAR iManufacturer;
+    UCHAR iProduct;
+    UCHAR iSerialNumber;
+    UCHAR bNumConfigurations;
+} __attribute__((packed)) USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;
+
+typedef struct _USB_ENDPOINT_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    UCHAR bEndpointAddress;
+    UCHAR bmAttributes;
+    USHORT wMaxPacketSize;
+    UCHAR bInterval;
+} __attribute__((packed)) USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;
+
+//
+// values for bmAttributes Field in
+// USB_CONFIGURATION_DESCRIPTOR
+//
+
+#define BUS_POWERED                           0x80
+#define SELF_POWERED                          0x40
+#define REMOTE_WAKEUP                         0x20
+
+typedef struct _USB_CONFIGURATION_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    USHORT wTotalLength;
+    UCHAR bNumInterfaces;
+    UCHAR bConfigurationValue;
+    UCHAR iConfiguration;
+    UCHAR bmAttributes;
+    UCHAR MaxPower;
+} __attribute__((packed)) USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;
+
+typedef struct _USB_INTERFACE_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    UCHAR bInterfaceNumber;
+    UCHAR bAlternateSetting;
+    UCHAR bNumEndpoints;
+    UCHAR bInterfaceClass;
+    UCHAR bInterfaceSubClass;
+    UCHAR bInterfaceProtocol;
+    UCHAR iInterface;
+} __attribute__((packed)) USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;
+
+typedef struct _USB_STRING_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    UCHAR bString[1];
+} __attribute__((packed)) USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;
+
+//
+// USB power descriptor added to core specification
+//
+
+#define USB_SUPPORT_D0_COMMAND      0x01
+#define USB_SUPPORT_D1_COMMAND      0x02
+#define USB_SUPPORT_D2_COMMAND      0x04
+#define USB_SUPPORT_D3_COMMAND      0x08
+
+#define USB_SUPPORT_D1_WAKEUP       0x10
+#define USB_SUPPORT_D2_WAKEUP       0x20
+
+
+typedef struct _USB_POWER_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+    UCHAR bCapabilitiesFlags;
+    USHORT EventNotification;
+    USHORT D1LatencyTime;
+    USHORT D2LatencyTime;
+    USHORT D3LatencyTime;
+    UCHAR PowerUnit;
+    USHORT D0PowerConsumption;
+    USHORT D1PowerConsumption;
+    USHORT D2PowerConsumption;
+} __attribute__((packed)) USB_POWER_DESCRIPTOR, *PUSB_POWER_DESCRIPTOR;
+
+
+typedef struct _USB_COMMON_DESCRIPTOR {
+    UCHAR bLength;
+    UCHAR bDescriptorType;
+} __attribute__((packed)) USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;
+
+
+//
+// Standard USB HUB definitions 
+//
+// See Chapter 11
+//
+
+typedef struct _USB_HUB_DESCRIPTOR {
+    UCHAR        bDescriptorLength;      // Length of this descriptor
+    UCHAR        bDescriptorType;        // Hub configuration type
+    UCHAR        bNumberOfPorts;         // number of ports on this hub
+    USHORT       wHubCharacteristics;    // Hub Charateristics
+    UCHAR        bPowerOnToPowerGood;    // port power on till power good in 2ms
+    UCHAR        bHubControlCurrent;     // max current in mA
+    //
+    // room for 255 ports power control and removable bitmask
+    UCHAR        bRemoveAndPowerMask[64];
+} __attribute__((packed)) USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;
+
+
+#endif   /* __USB100_H__ */
diff -urN u-boot-1.3.1/board/dgstation/common/vendor.c u-boot-1.3.1_st2.3-32/board/dgstation/common/vendor.c
--- u-boot-1.3.1/board/dgstation/common/vendor.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/vendor.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,293 @@
+#include <common.h>
+
+#if defined (CONFIG_PDIUSB12) || defined (CONFIG_NET2270)
+
+#ifdef CONFIG_DGS_FRONT
+#include "common/front.h"
+#endif
+
+#include "common/upgrade.h"
+#include "vendor.h"
+#include "usb100.h"
+#ifdef CONFIG_PDIUSB12
+#include "pdiusbd12/d12ci.h"
+#include "pdiusbd12/mainloop.h"
+#endif
+
+#ifdef CONFIG_NET2270
+#include "net2270/net2270.h"
+#include "net2270/mainloop.h"
+#endif
+
+#define VENDOR_DESC_LEN (sizeof(struct _vendor_header)+sizeof(struct _vendor_desc))
+
+extern CONTROL_XFER ControlData;
+extern EPPFLAGS bEPPflags;
+
+int usb_current_block_size = 0;
+int usb_data_buffer_index;
+
+/*
+ * file_header and iorequest will be stored by PC.
+ * PC will send me about file size and filename, block size...
+ */
+struct _FileDownHeader file_header;
+struct _IO_REQUEST iorequest;
+
+/*
+ * currently not using...
+ */
+struct _vendor_header vh = 
+{
+	SWAP(1),
+	SWAP(VENDOR_DESC_LEN)
+};
+
+struct _vendor_desc vd =
+{
+	LSWAP(1),
+	LSWAP(2),
+	LSWAP(3)
+};
+
+void get_vendor_descript( void )
+{
+	unsigned char *buf;
+
+	buf = upg_buffer;
+
+	memcpy( &buf[0], &vh, sizeof(struct _vendor_header) );
+	memcpy( &buf[sizeof(struct _vendor_header)], &vd, sizeof(struct _vendor_desc) );
+
+	code_transmit( buf, VENDOR_DESC_LEN );
+}
+
+void vendor_req( void )
+{
+	u16 wIndex;
+	u16 wValue;
+	u16 wLength;
+	u8 buf[2];
+#ifdef CONFIG_NET2270
+//	DISABLE;
+#endif
+	
+	wIndex = ControlData.DeviceRequest.wIndex;
+	wValue = ControlData.DeviceRequest.wValue;
+	wLength = ControlData.DeviceRequest.wLength;
+
+//	printf( "vendor_req." );
+
+	if( ControlData.DeviceRequest.bmRequestType & USB_ENDPOINT_DIRECTION_MASK )
+	{
+		switch( wIndex )
+		{
+			case GET_FIRMWARE_VERSION:
+				printf( "Connected.\n" );
+				printf( "Select file in FlashTool and download.\n" );
+#ifdef CONFIG_NET2270				
+				send_fifo(EndPoint0, "\x01", 1 );
+
+				/* why??? */
+				if( usb_current_block_size > 0 ) {
+					//udelay(10);
+					read_main_data(EndPointB);
+				}
+#endif
+
+#ifdef CONFIG_PDIUSB12
+				single_transmit( "x01", 1);
+#endif
+
+				break;
+			case GET_FLASH_STATUS:
+				/*
+				 * FIXME!!!
+				 * NOT COMPLETED. MAKE ME WORK!!!
+				 */
+				if(bEPPflags.bits.verbose)
+				{
+					printf( " get flash status.\n" );
+				}
+				
+				buf[1] = 0;
+				switch( upg_buffer_status )
+				{
+					case UPGBUF_UNUSED:
+						buf[0] = 0x00;
+						break;
+					default:
+						buf[0] = 0x02;
+						break;
+				}
+#ifdef CONFIG_NET2270
+				send_fifo(EndPoint0, buf, 2 );
+#endif
+#ifdef CONFIG_PDIUSB12
+				D12_WriteEndpoint(1, buf, 2);
+#endif
+				break;
+			default:
+				printf( " unknown index. (0x%04x)\n", wIndex );
+#ifdef CONFIG_PDIUSB12
+				single_transmit(0, 0);
+#endif
+				break;
+		}
+	}
+	else
+	{
+		switch( wIndex )
+		{
+			case SET_FILE_DOWN_HEADER:
+				if(bEPPflags.bits.verbose)
+				{
+					printf( " set file down header.\n" );
+				}
+				if( set_file_down_header( (struct _FileDownHeader*)ControlData.dataBuffer, wLength ) )
+				{
+					printf( "download is not accepted\n" );
+				}
+#ifdef CONFIG_PDIUSB12
+				single_transmit(0, 0);
+#endif
+				break;
+			case SET_FILE_DOWN:
+				if(bEPPflags.bits.verbose)
+				{
+					printf( " set file down.\n" );
+				}
+				set_file_down( (struct _IO_REQUEST*)ControlData.dataBuffer, wLength );
+#ifdef CONFIG_PDIUSB12
+				single_transmit(0, 0);
+#endif
+				break;
+			case USB_CMD_END:
+				if(bEPPflags.bits.verbose)
+				{
+					printf( " cmd end\n" );
+				}
+				download_completed();
+#ifdef CONFIG_PDIUSB12
+				single_transmit(0, 0);
+#endif
+				break;
+			default:
+				printf( " unknown index.(0x%04x)\n", wIndex );
+#ifdef CONFIG_PDIUSB12
+				single_transmit(0, 0);
+#endif
+				break;
+		}
+	}
+
+#ifdef CONFIG_NET2270
+//	ENABLE;
+#endif
+}
+
+int set_file_down_header( struct _FileDownHeader *header, int len )
+{
+	if( len != sizeof(struct _FileDownHeader) )
+	{
+		printf( "header size is differ. needed %d, but got %d\n", sizeof(struct _FileDownHeader), len );
+		return -1;
+	}
+
+	memcpy( &file_header, header, len );
+	file_header.file_size = ntohl(file_header.file_size);
+	if(bEPPflags.bits.verbose)
+	{
+		printf( "file_name    %s\n", file_header.file_name );
+		printf( "file_size    %d\n", (int)file_header.file_size );	// It`s swaped...
+		printf( "down_type    %d\n", (int)file_header.down_type );
+		printf( "down_media   %d\n", (int)file_header.down_media );
+		printf( "down_command %d\n", (int)file_header.down_command );
+	}
+
+	if( file_header.file_size > CFG_DGS_UPGRADE_BUFSIZE )
+	{
+		printf( "file is too big...\n" );
+		return -1;
+	}
+
+	if( upg_buffer_status != UPGBUF_UNUSED )
+	{
+		printf( "buffer is using by other.(status:%d)\n", upg_buffer_status );
+		printf( "go any way...\n" );
+//		return -1;
+	}
+
+	upg_buffer_status = UPGBUF_DOWNLOAD;
+	upg_buffer_len = 0;
+
+	return 0;
+}
+
+void set_file_down( struct _IO_REQUEST *request, int len )
+{
+	if( len != sizeof(struct _IO_REQUEST) )
+	{
+		printf( "iorequest size is differ. needed %d, but got %d\n", sizeof(struct _IO_REQUEST), len );
+		return;
+	}
+
+	memcpy( &iorequest, request, len );
+	iorequest.uSize = SWAP( iorequest.uSize );
+	if(bEPPflags.bits.verbose)
+	{
+		printf( "uAddressL 0x%04x\n", iorequest.uAddressL );
+		printf( "bAddressH 0x%02x\n", iorequest.bAddressH );
+		printf( "uSize     0x%04x\n", iorequest.uSize );
+		printf( "bCommand  0x%02x\n", iorequest.bCommand );
+	}
+
+	/*
+	 * set block size.
+	 * will be used in main_rxdone.
+	 */
+	if( usb_current_block_size )
+ 		printf( "do we lost some data at last transfer\?\?\?(bs:%d)\n",
+				usb_current_block_size );
+	usb_current_block_size = iorequest.uSize;
+#ifdef CONFIG_NET2270
+//	if(bEPPflags.bits.full_speed) { 
+//		udelay(1);
+//	}
+	
+	read_main_data(EndPointB);
+#endif
+}
+
+int download_completed( void )
+{
+	if( upg_buffer_status == UPGBUF_DOWNLOAD )
+	{
+		if( usb_current_block_size )
+			printf( "do we lost some data at last transfer\?\?\?(bs:%d)\n",
+					usb_current_block_size );
+		upg_buffer_status = UPGBUF_WRITE;
+		usb_current_block_size = 0;
+
+		if( upg_buffer_len != file_header.file_size )
+		{
+			printf( "vendor.c: %d lost data?(%d!=%d)\n", __LINE__,
+					upg_buffer_len, (int)file_header.file_size );
+			goto error;
+		}
+	}
+	else
+	{
+		printf( "download completed with unknown stat.\n" );
+	}
+
+	return 0;
+
+error:
+	upg_buffer_status = UPGBUF_UNUSED;
+
+	return -1;
+
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/common/vendor.h u-boot-1.3.1_st2.3-32/board/dgstation/common/vendor.h
--- u-boot-1.3.1/board/dgstation/common/vendor.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/common/vendor.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,73 @@
+#ifndef _VENDOR_H
+#define _VENDOR_H
+
+#ifdef CONFIG_NET2270
+#include "net2270/mainloop.h"
+#endif
+
+#ifdef CONFIG_PDIUSB12
+#include "pdiusbd12/mainloop.h"
+#endif
+
+#define USB_BS_NOT_USE		0		/* buffer is not using...
+						   any one can use usb_data_buffer */
+#define USB_BS_DOWN		1		/* buffer is using for download */
+#define USB_BS_WRITE		2		/* buffer is using for writeing flash */
+
+/*
+ * status of bootloader for usb client.
+ * will be used for announce status to user(PC application).
+ */
+#define USB_ST_DO_NOTHING	0
+#define USB_ST_DOWNLOAD		1
+#define USB_ST_ERASE		2
+#define USB_ST_WRITE		3
+#define USB_ST_ERROR		4
+
+/*
+ * index of vendor request.
+ * used in vendor_req function
+ */
+#define GET_FIRMWARE_VERSION	0x0472
+#define GET_FLASH_STATUS	0x0473
+#define SET_FILE_DOWN_HEADER	3
+#define SET_FILE_DOWN		4
+#define USB_CMD_END		7
+
+struct _vendor_header
+{
+	unsigned short request;                   
+	unsigned short len;
+};                                                         
+
+struct _vendor_desc                                                       
+{                                     
+	unsigned long product;
+
+	unsigned long sw_model;
+	unsigned long sw_version;
+};
+
+#pragma pack(1)
+struct _FileDownHeader{
+	unsigned char file_name[256];
+	unsigned long file_size;
+//	unsigned long file_time;
+//	unsigned long file_date;
+	unsigned char down_type;
+	unsigned char down_media;
+	unsigned char down_command;
+};
+#pragma pack()
+
+extern void get_vendor_descript( void );
+extern void vendor_req( void );
+extern int set_file_down_header( struct _FileDownHeader*, int );
+extern void set_file_down( struct _IO_REQUEST*, int );
+extern int download_completed( void );
+extern int burn_flash( void );
+
+extern int usb_current_block_size;
+extern struct _FileDownHeader file_header;
+extern struct _IO_REQUEST iorequest;
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusb",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusb",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# cuberevo board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/cuberevo.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/cuberevo.c
--- u-boot-1.3.1/board/dgstation/cuberevo/cuberevo.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/cuberevo.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,210 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	/* TS path disable */
+	//*((unsigned short *)0xa3800000) = 0xffff;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+
+	front_puts("BOOTING");
+	
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf("Board: cuberevo (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/relook511.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,696 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 12;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_12dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_12dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_12dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_12dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_12dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_12dotmatrix);
+		num2seg = num2seg_12dotmatrix;
+		Char2seg = Char2seg_12dotmatrix;
+		special2seg = special2seg_12dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_12dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/init-cuberevo.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/init-cuberevo.S
--- u-boot-1.3.1/board/dgstation/cuberevo/init-cuberevo.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/init-cuberevo.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,328 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+/*
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0xc0de)
+
+	// FPGA clk output 
+	//POKE_LONG(STB7100_CLOCKGENB_OUT_CTRL, 0xb)
+	
+	// CLKGENB SOURCE 
+	//POKE_LONG(STB7100_CLOCKGENB_REFCLK_SEL, 0)
+	
+	// CLK_PIX_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x0)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_SDIV1, 0x1)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_MD1, 0x17)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_PE1, 0x521a)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x1)
+	
+	// CLK_DISP_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_DISP_CFG, 0xc79)
+
+	// CLK_GDP2 
+	//POKE_LONG(STB7100_CLOCKGENB_CLK_SRC, 0x7)
+	
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0x0)
+*/	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+	
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# relook511s board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/cuberevo-2000hd.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/cuberevo-2000hd.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/cuberevo-2000hd.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/cuberevo-2000hd.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-2000hd/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+	
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("Board: cuberevo-2000hd (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/cuberevo-mini.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,705 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-2000hd/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 14;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_14dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_14dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_14dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_14dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+		/* cuberevo-mini have 14 dotmatrix vfd type only.
+		 force set micom_version. */
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#elif defined(CONFIG_CUBEREVO_2000HD)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x08;
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_2000HD)
+		&& micom_version[1]==0x08)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2) || defined(CONFIG_CUBEREVO_2000HD)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_14dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_14dotmatrix);
+		num2seg = num2seg_14dotmatrix;
+		Char2seg = Char2seg_14dotmatrix;
+		special2seg = special2seg_14dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_14dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_2000HD)
+		&& micom_version[1]==0x08)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2) || defined(CONFIG_CUBEREVO_2000HD)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/init-cuberevo-2000hd.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/init-cuberevo-2000hd.S
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/init-cuberevo-2000hd.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/init-cuberevo-2000hd.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,291 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-2000hd.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo-mini/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-2000hd/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-2000hd/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-2000hd/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# relook511s board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/cuberevo-250hd.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/cuberevo-250hd.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/cuberevo-250hd.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/cuberevo-250hd.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,205 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-250hd/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 1<<13; /* OC is inverted */ 
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+	
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("Board: cuberevo-250hd (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/cuberevo-250hd.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,812 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-250hd/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 14;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_14dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_14dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+/*
+          a
+	+----+
+       f+  g +b
+	+----+
+       e+    +c
+	+----+
+	  d
+
+	0 : on
+	1 : off
+*/
+static const unsigned short num2seg_7seg[] =
+{
+	0xc0,		// 0
+	0xf9,		// 1
+	0xa4,		// 2
+	0xb0,		// 3
+	0x99,		// 4
+	0x92,		// 5
+	0x82,		// 6
+	0xd8,		// 7
+	0x80,		// 8
+	0x98,		// 9
+};
+#define	A	(~((unsigned char)0x01))
+#define B	(~((unsigned char)0x02))
+#define C	(~((unsigned char)0x04))
+#define D	(~((unsigned char)0x08))
+#define E	(~((unsigned char)0x10))
+#define F	(~((unsigned char)0x20))
+#define G	(~((unsigned char)0x40))
+#define DP	(~((unsigned char)0x80))
+static const unsigned short Char2seg_7seg[] =
+{
+	A & B & C & E & F & G,		// A
+	C & D & E & F & G,		// B
+	A & D & E & F,			// C
+	B & C & D & E & G,		// D
+	A & D & E & F & G,		// E
+	A & E & F & G,			// F
+	A & C & D & E & F,		// G
+	C & E & F & G,			// H
+	C,				// I
+	B & C & D & E,			// J
+	A & C & E & F & G,		// K
+	D & E & F,			// L
+	A & B & C & E & F,		// M
+	C & E & G,			// N
+	C & D & E & G,			// O
+	A & B & E & F & G,		// P
+	A & B & D & E & F & G,		// Q
+	E & G,				// R
+	C & D & F & G,			// S
+	D & E & F & G,			// T
+	C & D & E,			// U
+	B & C & D & E & F,		// V
+	B & C & D & E & F & G,		// W
+	B & C & E & F & G,		// X
+	B & C & D & F & G,		// Y
+	A & B & D & E,			// Z
+};
+special_char_t special2seg_14dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+special_char_t  special2seg_7seg[] = 
+{
+	{'-',	0xbf},
+	{'_',	0xf7},
+	{'.',	0x7f},
+	{' ',	0xff},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_14dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_7seg[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+		/* cuberevo-mini have 14 dotmatrix vfd type only.
+		 force set micom_version. */
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+		micom_version[0] = 0x06;
+		micom_version[1] = 0x01;
+#else
+#error unknown platform !!
+#endif
+	}
+
+#if defined(CONFIG_CUBEREVO)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+	if(micom_version[0]==0x06 
+		&& micom_version[1]==0x01)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* default */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+		front_seg_num = 4;
+#else
+#error unknown platform !!
+#endif
+
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		fntkeys = front_keymap_14dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_14dotmatrix);
+		num2seg = num2seg_14dotmatrix;
+		Char2seg = Char2seg_14dotmatrix;
+		special2seg = special2seg_14dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_14dotmatrix);
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+		fntkeys = front_keymap_7seg; 
+		fntkeynum = ARRAY_SIZE(front_keymap_7seg);
+		num2seg = num2seg_7seg;
+		Char2seg = Char2seg_7seg;
+		special2seg = special2seg_7seg;
+		special2seg_size = ARRAY_SIZE(special2seg_7seg);
+#endif
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* old one */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+#if defined(CONFIG_CUBEREVO)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+	if(micom_version[0]==0x06 
+		&& micom_version[1]==0x01)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD)
+		return "4 digit 7-segment front";
+#else
+#error unknown platform !!
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/init-cuberevo-250hd.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/init-cuberevo-250hd.S
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/init-cuberevo-250hd.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/init-cuberevo-250hd.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,291 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-250hd.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,140 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo-250hd/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define NO_NTSC
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"PAL",	"SD-NTSC", 
+	"720",	"720P-60", 
+	"1080",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+#ifdef NO_NTSC
+		mode &= 0xfe;
+#endif
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+#ifdef NO_NTSC
+					mode++;
+#endif
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+#ifdef NO_NTSC
+					mode--;
+#endif
+					if(mode<0) 
+					{
+						mode = N_TVMODE-1;
+#ifdef NO_NTSC
+						mode--;
+#endif
+					}
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-250hd/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-250hd/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-250hd/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusb",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusb",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# cuberevo board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/cuberevo-9500hd.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/cuberevo-9500hd.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/cuberevo-9500hd.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/cuberevo-9500hd.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,214 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-9500hd/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	/* TS path disable */
+	//*((unsigned short *)0xa3800000) = 0xffff;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, !CFG_USB_EN); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+
+	front_puts("BOOTING");
+	
+	udelay(100000);
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, CFG_USB_EN); // USB HOST, en=0
+	
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf("Board: cuberevo-9500hd (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/relook511.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,699 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-9500hd/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 12;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_12dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_12dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_12dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_12dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_9500HD)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_9500HD)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x03;
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_9500HD)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_12dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_12dotmatrix);
+		num2seg = num2seg_12dotmatrix;
+		Char2seg = Char2seg_12dotmatrix;
+		special2seg = special2seg_12dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_12dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_9500HD)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_9500HD)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/init-cuberevo-9500hd.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/init-cuberevo-9500hd.S
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/init-cuberevo-9500hd.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/init-cuberevo-9500hd.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,328 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+/*
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0xc0de)
+
+	// FPGA clk output 
+	//POKE_LONG(STB7100_CLOCKGENB_OUT_CTRL, 0xb)
+	
+	// CLKGENB SOURCE 
+	//POKE_LONG(STB7100_CLOCKGENB_REFCLK_SEL, 0)
+	
+	// CLK_PIX_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x0)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_SDIV1, 0x1)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_MD1, 0x17)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_PE1, 0x521a)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x1)
+	
+	// CLK_DISP_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_DISP_CFG, 0xc79)
+
+	// CLK_GDP2 
+	//POKE_LONG(STB7100_CLOCKGENB_CLK_SRC, 0x7)
+	
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0x0)
+*/	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+	
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-9500hd.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-9500hd/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-9500hd/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-9500hd/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# relook511s board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/cuberevo-mini.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/cuberevo-mini.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/cuberevo-mini.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/cuberevo-mini.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-mini/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+	
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("Board: cuberevo-mini (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/cuberevo-mini.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,698 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-mini/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 14;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_14dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_14dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_14dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_14dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+		/* cuberevo-mini have 14 dotmatrix vfd type only.
+		 force set micom_version. */
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_14dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_14dotmatrix);
+		num2seg = num2seg_14dotmatrix;
+		Char2seg = Char2seg_14dotmatrix;
+		special2seg = special2seg_14dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_14dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/init-cuberevo-mini.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/init-cuberevo-mini.S
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/init-cuberevo-mini.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/init-cuberevo-mini.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,291 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-mini.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo-mini/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# relook511s board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/cuberevo-mini2.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/cuberevo-mini2.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/cuberevo-mini2.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/cuberevo-mini2.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-mini2/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+	
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("Board: cuberevo-mini II (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/cuberevo-mini.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,698 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-mini2/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 14;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_14dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_14dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_14dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_14dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+		/* cuberevo-mini have 14 dotmatrix vfd type only.
+		 force set micom_version. */
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_14dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_14dotmatrix);
+		num2seg = num2seg_14dotmatrix;
+		Char2seg = Char2seg_14dotmatrix;
+		special2seg = special2seg_14dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_14dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/init-cuberevo-mini2.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/init-cuberevo-mini2.S
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/init-cuberevo-mini2.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/init-cuberevo-mini2.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,291 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-mini2.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo-mini/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini2/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini2/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini2/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/cmd_bootmenu_cmds.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/cmd_bootmenu_cmds.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/cmd_bootmenu_cmds.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,84 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_up, key_front_power, key_null },
+		0,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_p_right, key_front_power, key_null },
+		0,
+		"menu_upgserial",
+	},
+	{
+		{ key_front_p_down, key_front_power, key_null },
+		0,
+		"menu_hddfmt",
+	},
+	{
+		{ key_front_down, key_null },
+		20*3,
+		"menu_set2set",
+	},
+	{
+		{ key_front_left, key_null },
+		20*3,
+		"menu_debugmode",
+	},
+	{
+		{ key_front_p_left, key_front_power, key_null},
+		0,
+		"menu_upgnet",
+	},
+	{
+		{ key_front_p_menu, key_front_power, key_null },
+		0,
+		"menu_tvmode",
+	},
+	{
+		{ key_front_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+	{
+		{ key_menu, key_null},
+		20*3,
+		"menu_tvmode",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/config.mk u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/config.mk
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/config.mk	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# relook511s board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/cuberevo-mini-fta.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/cuberevo-mini-fta.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/cuberevo-mini-fta.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/cuberevo-mini-fta.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "cuberevo-mini-fta/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_IN);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);                
+#endif
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+	
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("Board: cuberevo-mini-fta (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+/*int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	//NOTREACHED
+	return (0);
+}*/
+
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/denc.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/denc.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/denc.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/flash_imgs.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/flash_imgs.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/flash_imgs.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/cuberevo-mini-fta.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/front_dev.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/front_dev.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/front_dev.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,812 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "cuberevo-mini-fta/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 14;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_14dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_14dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+/*
+          a
+	+----+
+       f+  g +b
+	+----+
+       e+    +c
+	+----+
+	  d
+
+	0 : on
+	1 : off
+*/
+static const unsigned short num2seg_7seg[] =
+{
+	0xc0,		// 0
+	0xf9,		// 1
+	0xa4,		// 2
+	0xb0,		// 3
+	0x99,		// 4
+	0x92,		// 5
+	0x82,		// 6
+	0xd8,		// 7
+	0x80,		// 8
+	0x98,		// 9
+};
+#define	A	(~((unsigned char)0x01))
+#define B	(~((unsigned char)0x02))
+#define C	(~((unsigned char)0x04))
+#define D	(~((unsigned char)0x08))
+#define E	(~((unsigned char)0x10))
+#define F	(~((unsigned char)0x20))
+#define G	(~((unsigned char)0x40))
+#define DP	(~((unsigned char)0x80))
+static const unsigned short Char2seg_7seg[] =
+{
+	A & B & C & E & F & G,		// A
+	C & D & E & F & G,		// B
+	A & D & E & F,			// C
+	B & C & D & E & G,		// D
+	A & D & E & F & G,		// E
+	A & E & F & G,			// F
+	A & C & D & E & F,		// G
+	C & E & F & G,			// H
+	C,				// I
+	B & C & D & E,			// J
+	A & C & E & F & G,		// K
+	D & E & F,			// L
+	A & B & C & E & F,		// M
+	C & E & G,			// N
+	C & D & E & G,			// O
+	A & B & E & F & G,		// P
+	A & B & D & E & F & G,		// Q
+	E & G,				// R
+	C & D & F & G,			// S
+	D & E & F & G,			// T
+	C & D & E,			// U
+	B & C & D & E & F,		// V
+	B & C & D & E & F & G,		// W
+	B & C & E & F & G,		// X
+	B & C & D & F & G,		// Y
+	A & B & D & E,			// Z
+};
+special_char_t special2seg_14dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+special_char_t  special2seg_7seg[] = 
+{
+	{'-',	0xbf},
+	{'_',	0xf7},
+	{'.',	0x7f},
+	{' ',	0xff},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_14dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_7seg[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+		/* cuberevo-mini have 14 dotmatrix vfd type only.
+		 force set micom_version. */
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+		micom_version[0] = 0x06;
+		micom_version[1] = 0x01;
+#else
+#error unknown platform !!
+#endif
+	}
+
+#if defined(CONFIG_CUBEREVO)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+	if(micom_version[0]==0x06 
+		&& micom_version[1]==0x01)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* default */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+		front_seg_num = 4;
+#else
+#error unknown platform !!
+#endif
+
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		fntkeys = front_keymap_14dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_14dotmatrix);
+		num2seg = num2seg_14dotmatrix;
+		Char2seg = Char2seg_14dotmatrix;
+		special2seg = special2seg_14dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_14dotmatrix);
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+		fntkeys = front_keymap_7seg; 
+		fntkeynum = ARRAY_SIZE(front_keymap_7seg);
+		num2seg = num2seg_7seg;
+		Char2seg = Char2seg_7seg;
+		special2seg = special2seg_7seg;
+		special2seg_size = ARRAY_SIZE(special2seg_7seg);
+#endif
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* old one */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+#if defined(CONFIG_CUBEREVO)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+	if(micom_version[0]==0x08 
+		&& micom_version[1]==0x06)
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+	if(micom_version[0]==0x06 
+		&& micom_version[1]==0x01)
+#else
+#error unknown front type !!
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI_FTA)
+		return "4 digit 7-segment front";
+#else
+#error unknown platform !!
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/front_dev.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/front_dev.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/front_dev.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/init-cuberevo-mini-fta.S u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/init-cuberevo-mini-fta.S
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/init-cuberevo-mini-fta.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/init-cuberevo-mini-fta.S	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,291 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/Makefile u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/Makefile
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/Makefile	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,65 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-cuberevo-mini-fta.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/serial_set2set.o
+COBJS	+= ../common/serial_upgrade.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+COBJS	+= ../common/vendor.o
+COBJS	+= ../common/pdiusbd12/chap_9.o
+COBJS	+= ../common/pdiusbd12/d12ci.o
+COBJS	+= ../common/pdiusbd12/epphal.o
+COBJS	+= ../common/pdiusbd12/isr.o
+COBJS	+= ../common/pdiusbd12/mainloop.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/sconsole.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/sconsole.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/sconsole.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/sconsole.h u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/sconsole.h
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/sconsole.h	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/tvmode.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/tvmode.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/tvmode.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,140 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo-mini-fta/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define NO_NTSC
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"PAL",	"SD-NTSC", 
+	"720",	"720P-60", 
+	"1080",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+#ifdef NO_NTSC
+		mode &= 0xfe;
+#endif
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+#ifdef NO_NTSC
+					mode++;
+#endif
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+#ifdef NO_NTSC
+					mode--;
+#endif
+					if(mode<0) 
+					{
+						mode = N_TVMODE-1;
+#ifdef NO_NTSC
+						mode--;
+#endif
+					}
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/u-boot.lds u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/u-boot.lds
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/u-boot.lds	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/video.c u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/video.c
--- u-boot-1.3.1/board/dgstation/cuberevo-mini-fta/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/board/dgstation/cuberevo-mini-fta/video.c	2009-01-22 09:21:06.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1/common/cmd_bootm.c u-boot-1.3.1_st2.3-32/common/cmd_bootm.c
--- u-boot-1.3.1/common/cmd_bootm.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/common/cmd_bootm.c	2009-01-22 09:21:01.000000000 +0100
@@ -261,7 +261,14 @@
 #elif defined(__PPC__)
 	if (hdr->ih_arch != IH_CPU_PPC)
 #elif defined(__SH4__)
-	if (hdr->ih_arch != IH_CPU_SH)
+	if ((hdr->ih_arch != IH_CPU_SH) 
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2) || defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD) || defined(CONFIG_CUBEREVO_2000HD) || defined(CONFIG_CUBEREVO_9500HD)
+	/* compat with u-boot-1.1.2 in dgstation platform.
+	   SH4 use 0x10 for arch definition in u-boot-1.1.2 image.h
+	 */
+			&& (hdr->ih_arch != IH_CPU_BLACKFIN)
+#endif
+			)
 #elif defined(__ST200__)
 	if (hdr->ih_arch != IH_CPU_ST200)
 #else
@@ -411,7 +418,8 @@
 		unc_len = Usize;	/* we now know that it will fit okay */
 }
 #endif	/* CONFIG_SH4 */
-		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
+		//if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
+		if (gunzip ((void *)ntohl(hdr->ih_ep), unc_len,
 			    (uchar *)data, &len) != 0) {
 			puts ("GUNZIP ERROR - must RESET board to recover\n");
 			show_boot_progress (-6);
diff -urN u-boot-1.3.1/common/cmd_eeprom.c u-boot-1.3.1_st2.3-32/common/cmd_eeprom.c
--- u-boot-1.3.1/common/cmd_eeprom.c	2007-12-06 10:21:19.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/common/cmd_eeprom.c	2009-01-22 09:21:01.000000000 +0100
@@ -22,36 +22,19 @@
  *
  */
 
-/*
- * Support for read and write access to EEPROM like memory devices. This
- * includes regular EEPROM as well as  FRAM (ferroelectic nonvolaile RAM).
- * FRAM devices read and write data at bus speed. In particular, there is no
- * write delay. Also, there is no limit imposed on the numer of bytes that can
- * be transferred with a single read or write.
- *
- * Use the following configuration options to ensure no unneeded performance
- * degradation (typical for EEPROM) is incured for FRAM memory:
- *
- * #define CFG_I2C_FRAM
- * #undef CFG_EEPROM_PAGE_WRITE_DELAY_MS
- *
- */
-
 #include <common.h>
 #include <config.h>
 #include <command.h>
 #include <i2c.h>
 
-#if defined(CFG_ENV_IS_IN_EEPROM) || defined(CONFIG_CMD_EEPROM)
+//#if (CONFIG_COMMANDS & CFG_CMD_EEPROM) || defined(CFG_ENV_IS_IN_EEPROM)
+#if defined(CONFIG_CMD_EEPROM) || defined(CFG_ENV_IS_IN_EEPROM)
 
 extern void eeprom_init  (void);
 extern int  eeprom_read  (unsigned dev_addr, unsigned offset,
 			  uchar *buffer, unsigned cnt);
 extern int  eeprom_write (unsigned dev_addr, unsigned offset,
 			  uchar *buffer, unsigned cnt);
-#if defined(CFG_EEPROM_WREN)
-extern int eeprom_write_enable (unsigned dev_addr, int state);
-#endif
 #endif
 
 
@@ -62,7 +45,7 @@
 
 /* ------------------------------------------------------------------------- */
 
-#if defined(CONFIG_CMD_EEPROM)
+#ifdef CONFIG_CMD_EEPROM
 int do_eeprom ( cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	const char *const fmt =
@@ -110,7 +93,7 @@
 	printf ("Usage:\n%s\n", cmdtp->usage);
 	return 1;
 }
-#endif
+#endif	/* CFG_CMD_EEPROM */
 
 /*-----------------------------------------------------------------------
  *
@@ -121,7 +104,7 @@
  *   0x00000nxx for EEPROM address selectors and page number at n.
  */
 
-#if defined(CFG_ENV_IS_IN_EEPROM) || defined(CONFIG_CMD_EEPROM)
+#ifdef CONFIG_CMD_EEPROM
 
 #ifndef CONFIG_SPI
 #if !defined(CFG_I2C_EEPROM_ADDR_LEN) || CFG_I2C_EEPROM_ADDR_LEN < 1 || CFG_I2C_EEPROM_ADDR_LEN > 2
@@ -140,11 +123,7 @@
 	 * because the next page may be in a different device.
 	 */
 	while (offset < end) {
-		unsigned alen, len;
-#if !defined(CFG_I2C_FRAM)
-		unsigned maxlen;
-#endif
-
+		unsigned alen, len, maxlen;
 #if CFG_I2C_EEPROM_ADDR_LEN == 1 && !defined(CONFIG_SPI_X)
 		uchar addr[2];
 
@@ -166,31 +145,37 @@
 
 		addr[0] |= dev_addr;		/* insert device address */
 
-		len = end - offset;
-
-		/*
-		 * For a FRAM device there is no limit on the number of the
-		 * bytes that can be ccessed with the single read or write
-		 * operation.
-		 */
-#if !defined(CFG_I2C_FRAM)
 		maxlen = 0x100 - blk_off;
 		if (maxlen > I2C_RXTX_LEN)
 			maxlen = I2C_RXTX_LEN;
+		len    = end - offset;
 		if (len > maxlen)
 			len = maxlen;
-#endif
-
 #ifdef CONFIG_SPI
 		spi_read (addr, alen, buffer, len);
 #else
+#if defined(CONFIG_CUBEREVO) || defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2) || defined(CONFIG_CUBEREVO_MINI_FTA) || defined(CONFIG_CUBEREVO_250HD) || defined(CONFIG_CUBEREVO_2000HD) || defined(CONFIG_CUBEREVO_9500HD) || defined(CONFIG_SLOBBIE_IP)
+		/* PIO로 soft i2c를 구현할때, page read 가 제대로 동작하지 않는다.
+		   그래서 한 바이트씩 나눠서 읽는다.
+		   SSC H/W를 이용해서 하도록 구현해야 한다.
+		   */
+		int i;
+		for(i=0; i<len; i++)
+		{
+			if(i2c_read(addr[0], offset+i, alen-1, &buffer[i], 1)!=0)
+			{
+				rcode = 1;
+				break;
+			}
+		}
+#else
 		if (i2c_read (addr[0], offset, alen-1, buffer, len) != 0)
 			rcode = 1;
 #endif
+#endif
 		buffer += len;
 		offset += len;
 	}
-
 	return rcode;
 }
 
@@ -217,20 +202,13 @@
 	int	i;
 #endif
 
-#if defined(CFG_EEPROM_WREN)
-	eeprom_write_enable (dev_addr,1);
-#endif
 	/* Write data until done or would cross a write page boundary.
 	 * We must write the address again when changing pages
 	 * because the address counter only increments within a page.
 	 */
 
 	while (offset < end) {
-		unsigned alen, len;
-#if !defined(CFG_I2C_FRAM)
-		unsigned maxlen;
-#endif
-
+		unsigned alen, len, maxlen;
 #if CFG_I2C_EEPROM_ADDR_LEN == 1 && !defined(CONFIG_SPI_X)
 		uchar addr[2];
 
@@ -252,15 +230,6 @@
 
 		addr[0] |= dev_addr;		/* insert device address */
 
-		len = end - offset;
-
-		/*
-		 * For a FRAM device there is no limit on the number of the
-		 * bytes that can be ccessed with the single read or write
-		 * operation.
-		 */
-#if !defined(CFG_I2C_FRAM)
-
 #if defined(CFG_EEPROM_PAGE_WRITE_BITS)
 
 #define	EEPROM_PAGE_SIZE	(1 << CFG_EEPROM_PAGE_WRITE_BITS)
@@ -273,10 +242,9 @@
 		if (maxlen > I2C_RXTX_LEN)
 			maxlen = I2C_RXTX_LEN;
 
+		len = end - offset;
 		if (len > maxlen)
 			len = maxlen;
-#endif
-
 #ifdef CONFIG_SPI
 		spi_write (addr, alen, buffer, len);
 #else
@@ -373,9 +341,6 @@
 		udelay(CFG_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
 #endif
 	}
-#if defined(CFG_EEPROM_WREN)
-	eeprom_write_enable (dev_addr,0);
-#endif
 	return rcode;
 }
 
@@ -422,11 +387,10 @@
 }
 /*-----------------------------------------------------------------------
  */
-#endif
-
+#endif	/* CFG_CMD_EEPROM */
 /***************************************************/
 
-#if defined(CONFIG_CMD_EEPROM)
+#ifdef CONFIG_CMD_EEPROM
 
 #ifdef CFG_I2C_MULTI_EEPROMS
 U_BOOT_CMD(
@@ -446,4 +410,4 @@
 );
 #endif /* CFG_I2C_MULTI_EEPROMS */
 
-#endif
+#endif	/* CFG_CMD_EEPROM */
diff -urN u-boot-1.3.1/common/cmd_usb.c u-boot-1.3.1_st2.3-32/common/cmd_usb.c
--- u-boot-1.3.1/common/cmd_usb.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/common/cmd_usb.c	2009-01-22 09:21:01.000000000 +0100
@@ -36,7 +36,7 @@
 #endif
 
 #ifdef CONFIG_USB_STORAGE
-static int usb_stor_curr_dev=-1; /* current device */
+int usb_stor_curr_dev=-1; /* current device */
 #endif
 
 /* some display routines (info command) */
diff -urN u-boot-1.3.1/common/soft_i2c.c u-boot-1.3.1_st2.3-32/common/soft_i2c.c
--- u-boot-1.3.1/common/soft_i2c.c	2007-12-06 10:21:19.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/common/soft_i2c.c	2009-01-22 09:21:01.000000000 +0100
@@ -63,6 +57,7 @@
 
 #ifdef DEBUG_I2C
 #define PRINTD(fmt,args...)	do {	\
+	DECLARE_GLOBAL_DATA_PTR;	\
 	if (gd->have_console)		\
 		printf (fmt ,##args);	\
 	} while (0)
@@ -173,10 +168,13 @@
 	volatile immap_t *immr = (immap_t *)CFG_IMMR;
 #endif
 
+	I2C_ACTIVE;
 	I2C_SCL(0);
 	I2C_DELAY;
-	I2C_ACTIVE;
+
 	I2C_SDA(ack);
+
+	I2C_ACTIVE;
 	I2C_DELAY;
 	I2C_SCL(1);
 	I2C_DELAY;
diff -urN u-boot-1.3.1/cpu/sh/stb7100/stb7100.c u-boot-1.3.1_st2.3-32/cpu/sh/stb7100/stb7100.c
--- u-boot-1.3.1/cpu/sh/stb7100/stb7100.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/cpu/sh/stb7100/stb7100.c	2009-01-22 09:20:45.000000000 +0100
@@ -362,7 +362,7 @@
 	 */
 	/* Setup PIO for USB power */
 	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
-	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+	STPIO_SET_PIN(PIO_PORT(5), 7, CFG_USB_EN);
 
 	/* Make sure PLL is on */
 #define SYS_CFG2_PLL_POWER_DOWN_BIT	1
diff -urN u-boot-1.3.1/drivers/net/stm-stmac.c u-boot-1.3.1_st2.3-32/drivers/net/stm-stmac.c
--- u-boot-1.3.1/drivers/net/stm-stmac.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/drivers/net/stm-stmac.c	2009-01-22 09:20:49.000000000 +0100
@@ -136,6 +136,50 @@
 #define MII_TSTAT_RMII  0x0800
 #define MII_TSTAT_MII   0x0400
 
+#elif defined(CONFIG_STMAC_RTL8201)	/* ST STE10xP */
+
+#define RTL8201_PHY_HI_IDA       0x8200
+#define RTL8201_PHY_HI_IDB       0x8201
+
+/******************************************************************************
+ * IEEE Standard 802.3-2002 vendor specific registers (0x10-0x1e) STe10xP
+ *****************************************************************************/
+#define MII_XCIIS                0x11	/* Config info & int status register */
+#define MII_XIE                  0x12	/* Interrupt enable register */
+#define MII_100CTR               0x13	/* 100BaseX control register */
+#define MII_XMC                  0x14	/* Mode control register */
+
+/******************************************************************************
+ * 100BaseX Auxiliary Status register defines
+ *****************************************************************************/
+#define XCIIS_FIFO_OVR           0x0800	/* FIFO Overrun */
+#define XCIIS_SPEED              0x0200	/* Speed */
+#define XCIIS_DUPLEX             0x0100	/* Duplex */
+#define XCIIS_PAUSE              0x0080	/* Pause */
+#define XCIIS_ANEG_INT           0x0040	/* Auto Negotiation Interrupt */
+#define XCIIS_RFAULT             0x0020	/* Remote Fault Interrupt */
+#define XCIIS_LDOWN              0x0010	/* Link Down Interrupt */
+#define XCIIS_LCWR               0x0008	/* Link Code Word Received Interrupt */
+#define XCIIS_PFAULT             0x0004	/* Parallel Detection Fault */
+#define XCIIS_ANEG_PAGE          0x0002	/* Auto Negotiation Page Rec Intr */
+#define XCIIS_REF_INTR           0x0001	/* Ref Interrupt */
+
+/******************************************************************************
+ * XCVR Mode Control register defines
+ *****************************************************************************/
+#define XMC_LDETECT              0x0800	/* Link Detect */
+#define XMC_PHY_ADDR_MSK         0x00f8	/* PHY Address Mask */
+#define XMC_PHY_ADDR_SHIFT       3	/* PHY Address Mask */
+#define XMC_PRE_SUP              0x0002	/* Preamble Suppression */
+#define PHY_ADDR_MSK		XMC_PHY_ADDR_MSK	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		XMC_PHY_ADDR_SHIFT	/* PHY Address Mask */
+
+/* MII mode */
+#define MII_TSTAT_SMII  0x1000
+#define MII_TSTAT_RMII  0x0800
+#define MII_TSTAT_MII   0x0400
+
+#elif defined(CONFIG_STMAC_LAN8700)	/* SMSC LAN8700 */
 #elif defined(CONFIG_STMAC_LAN8700)	/* SMSC LAN8700 */
 
 /* SMSC LAN8700 phy identifier values */
@@ -259,6 +301,12 @@
 			printf (STMAC "STe100P found\n");
 			return phyaddr;
 		}
+#elif defined(CONFIG_STMAC_RTL8201)
+		if(id1==0 && (id2==RTL8201_PHY_HI_IDA || id2==RTL8201_PHY_HI_IDB))
+		{
+			printf ("STMAC: RTL8020/1 found\n");
+			return phyaddr;
+		}
 #elif defined(CONFIG_STMAC_LAN8700)
 		if ((id & LAN8700_PHY_ID_MASK) == LAN8700_PHY_ID) {
 			printf (STMAC "SMSC LAN8700 found\n");
@@ -292,6 +340,8 @@
 	/* test for H/W address disagreement with the assigned address */
 #if defined(CONFIG_STMAC_STE10XP)
 	value = stmac_mii_read (eth_phy_addr, MII_XMC);
+#elif defined(CONFIG_STMAC_RTL8201)
+	value = 1; /* must be 1 */
 #elif defined(CONFIG_STMAC_LAN8700) || defined(CONFIG_STMAC_LAN8710)
	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
 #elif defined(CONFIG_STMAC_DP83865)
diff -urN u-boot-1.3.1/drivers/serial/stm-asc.c u-boot-1.3.1_st2.3-32/drivers/serial/stm-asc.c
--- u-boot-1.3.1/drivers/serial/stm-asc.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/drivers/serial/stm-asc.c	2009-01-22 09:20:51.000000000 +0100
@@ -32,6 +32,7 @@
 
 #define BAUDMODE	0x00001000
 #define CTSENABLE	0x00000800
+#define FIFOENABLE	(1<<10)
 #define RXENABLE	0x00000100
 #define RUN		0x00000080
 #define LOOPBACK	0x00000000
@@ -138,7 +138,6 @@
 extern int serial_init (void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
-	const int cflag = CREAD | HUPCL | CLOCAL | CSTOPB | CS8 | PARODD;
 	unsigned long val;
 	int baud = gd->baudrate;
 	int t, mode=1;
@@ -194,32 +193,10 @@
 	/* build up the value to be written to CONTROL */
 	val = RXENABLE | RUN;
 
-	/* set character length */
-	if ((cflag & CSIZE) == CS7)
-		val |= MODE_7BIT_PAR;
-	else {
-		if (cflag & PARENB)
-			val |= MODE_8BIT_PAR;
-		else
-			val |= MODE_8BIT;
-	}
-
-	/* set stop bit */
-	/* it seems no '0 stop bits' option is available: by default
-	 * we get 0.5 stop bits */
-	if (cflag & CSTOPB)
-		val |= STOP_1BIT;
-
-	/* odd parity */
-	if (cflag & PARODD)
-		val |= PARITYODD;
-
-#ifdef CONFIG_HWFLOW
-	/*  set flow control */
-	if (hwflow)
-		val |= CTSENABLE;
-#endif	/* CONFIG_HWFLOW */
-
+	/* config */
+	val |= MODE_8BIT;	// 8bit
+	val |= STOP_1BIT;	// stop 1bit
+	val |= FIFOENABLE;	// fifo enable
 	/* set baud generator mode */
 	if (mode)
 		val |= BAUDMODE;
@@ -254,6 +235,13 @@
 	p2_outl (UART_TXBUFFER_REG, ch);
 }
 
+/* not checked !! */
+void __serial_putc(char ch)
+{
+	serial_putc(ch);
+}
+
+
 /* write an entire (NUL-terminated) string */
 extern void serial_puts (const char *s)
 {
diff -urN u-boot-1.3.1/include/asm-sh/global_data.h u-boot-1.3.1_st2.3-32/include/asm-sh/global_data.h
--- u-boot-1.3.1/include/asm-sh/global_data.h	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/asm-sh/global_data.h	2009-01-22 09:20:52.000000000 +0100
@@ -46,6 +46,9 @@
 	unsigned long env_addr;	/* Address  of Environment struct */
 	unsigned long env_valid;	/* Checksum of Environment valid? */
 	void **jt;		/* jump table */
+#ifdef CONFIG_DGS_UPGRADE
+	unsigned long	dgs_upg_buffer;
+#endif
 } gd_t;
 
 /*
diff -urN u-boot-1.3.1/include/asm-sh/io.h u-boot-1.3.1_st2.3-32/include/asm-sh/io.h
--- u-boot-1.3.1/include/asm-sh/io.h	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/asm-sh/io.h	2009-01-22 09:20:52.000000000 +0100
@@ -11,7 +11,7 @@
  * For read{b,w,l} and write{b,w,l} there are also __raw versions, which
  * do not have a memory barrier after them.
  *
- * In addition, we have
+ * In addition, we have 
  *   ctrl_in{b,w,l}/ctrl_out{b,w,l} for SuperH specific I/O.
  *   which are processor specific.
  */
@@ -76,6 +76,21 @@
        defined(CONFIG_SH_MB796)		|| \
        defined(CONFIG_SH_HDK5289)
 #  include "asm/io_stb1eval.h"
+# elif defined(CONFIG_SH_GX1_EVAL) || \
+       defined(CONFIG_SH_STB1_EVAL) || \
+       defined(CONFIG_SH_MEDIAREF) || \
+       defined(CONFIG_SH_ST40_DB547) || \
+       defined(CONFIG_SH_ST40_STARTER) || \
+       defined(CONFIG_SH_ST220_EVAL) || \
+       defined(CONFIG_SH_STM8000_DEMO) || \
+       defined(CONFIG_SH_TMM_LR2) || \
+       defined(CONFIG_SH_STI5528_EVAL) || \
+       defined(CONFIG_SH_STI5528_ESPRESSO) || \
+       defined(CONFIG_SH_STB7100_MBOARD) || \
+       defined(CONFIG_SH_STB7100_REF) || \
+       defined(CONFIG_SH_STB7109E_REF) || \
+	defined(CONFIG_SH_MB411)
+#  include "asm/io_stb1eval.h"
 #else
 #  error "What system is this?"
 #endif
@@ -97,6 +107,20 @@
 	*(volatile unsigned long *) addr = b;
 }
 
+#if 0
+extern unsigned char _inb (unsigned long port);
+extern unsigned short _inw (unsigned long port);
+extern unsigned int _inl (unsigned long port);
+extern void _outb (unsigned char b, unsigned long port);
+extern void _outw (unsigned short w, unsigned long port);
+extern void _outl (unsigned int l, unsigned long port);
+extern unsigned char _inb_p (unsigned long port);
+extern unsigned short _inw_p (unsigned long port);
+extern unsigned int _inl_p (unsigned long port);
+extern void _outb_p (unsigned char b, unsigned long port);
+extern void _outw_p (unsigned short w, unsigned long port);
+extern void _outl_p (unsigned int l, unsigned long port);
+#endif
 extern void _insb (unsigned long port, void *dst, unsigned long count);
 extern void _insw (unsigned long port, void *dst, unsigned long count);
 extern void _insl (unsigned long port, void *dst, unsigned long count);
@@ -104,6 +128,15 @@
 extern void _outsw (unsigned long port, const void *src, unsigned long count);
 extern void _outsl (unsigned long port, const void *src, unsigned long count);
 
+#if 0
+extern unsigned char _readb (unsigned long addr);
+extern unsigned short _readw (unsigned long addr);
+extern unsigned int _readl (unsigned long addr);
+extern void _writeb (unsigned char b, unsigned long addr);
+extern void _writew (unsigned short b, unsigned long addr);
+extern void _writel (unsigned int b, unsigned long addr);
+#endif
+
 #ifdef __KERNEL__
 extern unsigned char ___raw_readb (unsigned long addr);
 extern unsigned short ___raw_readw (unsigned long addr);
@@ -325,6 +358,26 @@
 
 #define IO_SPACE_LIMIT 0xffffffff
 
+#include "asm/addrspace.h"
+
+/*
+ * Change virtual addresses to physical addresses and vv.
+ * These are trivial on the 1:1 Linux/SuperH mapping
+ */
+static __inline__ unsigned long virt_to_phys (volatile void *address)
+{
+	return PHYSADDR (address);
+}
+
+static __inline__ void *phys_to_virt (unsigned long address)
+{
+	return (void *) P1SEGADDR (address);
+}
+
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+#define page_to_bus page_to_phys
+
 /*
  * readX/writeX() are used to access memory mapped devices. On some
  * architectures the memory mapped IO stuff needs to be accessed
@@ -337,7 +390,7 @@
  * these cases with wired TLB entries anyway ...)
  *
  * We cheat a bit and always return uncachable areas until we've fixed
- * the drivers to handle caching properly.
+ * the drivers to handle caching properly.  
  */
 static __inline__ void *ioremap (unsigned long offset, unsigned long size)
 {
@@ -393,13 +446,5 @@
 #define dma_cache_wback(_start,_size) \
     __flush_wback_region(_start,_size)
 
-static inline void sync(void)
-{
-	/* do nothing */
-	/* Note: may need to include a "synco" instruction here, if we
-	 * have silicon with agressive write-combiners on the SH4-300
-	 * series cores in the future */
-}
-
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_IO_H */
diff -urN u-boot-1.3.1/include/asm-sh/pio.h u-boot-1.3.1_st2.3-32/include/asm-sh/pio.h
--- u-boot-1.3.1/include/asm-sh/pio.h	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/asm-sh/pio.h	2009-01-22 09:20:52.000000000 +0100
@@ -51,6 +51,7 @@
 
 #if defined(CONFIG_SH_STB7100)
 #define PIO_PORT_SIZE		0x1000					/* QQQ - DELETE */
+#define PIO_BASE  		0xb8020000
 #define PIO_PORT(n)		( ((n)*PIO_PORT_SIZE) + PIO_BASE)	/* QQQ - DELETE */
 #else	/* CONFIG_SH_STB7100 */
 #define PIO_PORT(n)		( ST40_PIO ## n ## _REGS_BASE )
diff -urN u-boot-1.3.1/include/asm-sh/stb7100reg.h u-boot-1.3.1_st2.3-32/include/asm-sh/stb7100reg.h
--- u-boot-1.3.1/include/asm-sh/stb7100reg.h	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/asm-sh/stb7100reg.h	2009-01-22 09:20:52.000000000 +0100
@@ -70,6 +70,12 @@
 #define ST40_EMI_REGS_BASE 0xba100000
 #endif
 
+
+/* STb7100 HDMI registers */
+#define STB7100_HDMI_REGS_BASE	0xb900b5800
+#define STB7100_HDMI_CFG	SH4_DWORD_REG(STB7100_HDMI_REGS_BASE+ 0x000)
+#define STB7100_HDMI_SYNC_CFG	SH4_DWORD_REG(STB7100_HDMI_REGS_BASE+ 0x020)
+
 /*----------------------------------------------------------------------------*/
 
 #include "asm/st40reg.h"
diff -urN u-boot-1.3.1/include/configs/cuberevo-2000hd.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-2000hd.h
--- u-boot-1.3.1/include/configs/cuberevo-2000hd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-2000hd.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,442 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_2000HD	1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-2000hd
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-2000hd debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00056000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-2000hd"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	2	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 1
+
+#define CONFIG_CONS_INDEX 0
+#define CONFIG_SH_ASC_BASE 0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			0
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-2000hd> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo-250hd.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-250hd.h
--- u-boot-1.3.1/include/configs/cuberevo-250hd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-250hd.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,443 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    			1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_250HD	1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-250hd
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-250hd debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+#define CONFIG_DGS_FRONT_7SEG
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00055000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-250hd"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	2	// GPIO PORT 2에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 1
+
+#define CONFIG_CONS_INDEX 0
+#define CONFIG_SH_ASC_BASE 0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			0
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-250hd> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo-9500hd.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-9500hd.h
--- u-boot-1.3.1/include/configs/cuberevo-9500hd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-9500hd.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,442 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_9500HD		1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-9500hd
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-9500hd debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00057000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-9500hd"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	4	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 	1
+#define CFG_STM_ASC_SERIAL 	1
+
+#define CONFIG_CONS_INDEX 	0
+#define CONFIG_SH_ASC_BASE 	0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			0
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-9500hd> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo.h
--- u-boot-1.3.1/include/configs/cuberevo.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,442 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO		1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo 
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00051100
+#define MY_HW_VERSION		0x00010001
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	4	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 	1
+#define CFG_STM_ASC_SERIAL 	1
+
+#define CONFIG_CONS_INDEX 	0
+#define CONFIG_SH_ASC_BASE 	0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			1
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo-mini2.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini2.h
--- u-boot-1.3.1/include/configs/cuberevo-mini2.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini2.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,442 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_MINI2	1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-mini2 
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-mini2 debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00053000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-mini2"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	4	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 1
+
+#define CONFIG_CONS_INDEX 0
+#define CONFIG_SH_ASC_BASE 0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			1
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-mini II> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo-mini-fta.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini-fta.h
--- u-boot-1.3.1/include/configs/cuberevo-mini-fta.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini-fta.h	2009-01-22 09:20:58.000000000 +0100
@@ -0,0 +1,443 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    			1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_MINI_FTA	1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-mini-fta
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-mini-fta debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+#define CONFIG_DGS_FRONT_7SEG
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00054000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-mini-fta"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	2	// GPIO PORT 2에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 1
+
+#define CONFIG_CONS_INDEX 0
+#define CONFIG_SH_ASC_BASE 0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			0
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-mini-fta> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/configs/cuberevo-mini.h u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini.h
--- u-boot-1.3.1/include/configs/cuberevo-mini.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/configs/cuberevo-mini.h	2009-01-22 09:20:56.000000000 +0100
@@ -0,0 +1,442 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_CUBEREVO_MINI	1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cuberevo-mini 
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=1500 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgserial=setenv stdout vga;setenv stderr vga;serial_upgrade;reset\0" \
+	"menu_set2set=setenv stdout vga;setenv stderr vga;serial_set2set;reset\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=cuberevo-mini debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x00052000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 1
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+#define CONFIG_SERIAL_UPGRADE
+#define CONFIG_SERIAL_SET2SET
+#define CFG_SERIALDOWN_HEADER	"cuberevo-mini"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	4	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 1
+
+#define CONFIG_CONS_INDEX 0
+#define CONFIG_SH_ASC_BASE 0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			1
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"cuberevo-mini> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1/include/flash.h u-boot-1.3.1_st2.3-32/include/flash.h
--- u-boot-1.3.1/include/flash.h	2007-12-06 10:21:19.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/include/flash.h	2009-01-22 09:21:00.000000000 +0100
@@ -130,6 +130,7 @@
  */
 
 #define AMD_MANUFACT	0x00010001	/* AMD	   manuf. ID in D23..D16, D7..D0 */
+#define SPA_MANUFACT	0x00010001	/* Spansion */
 #define FUJ_MANUFACT	0x00040004	/* FUJITSU manuf. ID in D23..D16, D7..D0 */
 #define ATM_MANUFACT	0x001F001F	/* ATMEL */
 #define STM_MANUFACT	0x00200020	/* STM (Thomson) manuf. ID in D23.. -"- */
@@ -194,6 +195,9 @@
 #define MX_ID_LV320T	0x22A722A7	/* 29LV320T by Macronix, AMD compatible */
 #define AMD_ID_LV320B	0x22F922F9	/* 29LV320B ID (32 M, bottom boot sect) */
 #define MX_ID_LV320B	0x22A822A8	/* 29LV320B by Macronix, AMD compatible */
+#define MX_ID_LV640MT	0x227E227E	/* 29LV640MT                            */
+#define	MX_ID_LV640BT	0x22c922c9	/* 29LV640BT/DT				*/
+#define	MX_ID_LV640DT	0x22c922c9	/* 29LV640BT/DT				*/
 
 #define AMD_ID_DL322T	0x22552255	/* 29DL322T ID (32 M, top boot sector)	*/
 #define AMD_ID_DL322B	0x22562256	/* 29DL322B ID (32 M, bottom boot sect) */
@@ -254,13 +258,15 @@
 #define STM_ID_F040B	0xE2		/* M29F040B ID ( 4M = 512K x 8	)	*/
 					/* 8 64K x 8 uniform sectors		*/
 
+#define SPA_ID_S29GL064M	  	0x227E227E  /* Spansion S29GL064M ( 8MBytes )	*/
+#define SPA_ID_S29GL128N		0x227E227E	/* spansion S29GL128N ( 16Mbytes ) */
+#define SPA_ID_S29GL256N		0x227E227E	/* spansion S29GL128N ( 16Mbytes ) */
+
 #define STM_ID_x800AB	0x005B005B	/* M29W800AB ID (8M = 512K x 16 )	*/
 #define STM_ID_29W320DT 0x22CA22CA	/* M29W320DT ID (32 M, top boot sector) */
-#define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect)	*/
-#define STM_ID_29W320ET 0x22562256	/* M29W320ET ID (32 M, top boot sector) */
-#define STM_ID_29W320EB 0x22572257	/* M29W320EB ID (32 M, bottom boot sect)*/
+#define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect) */
 #define STM_ID_29W040B	0x00E300E3	/* M29W040B ID (4M = 512K x 8)	*/
-#define FLASH_PSD4256GV 0x00E9		/* PSD4256 Flash and CPLD combination	*/
+#define STM_ID_29W640DT 0x22DE22DE	/* M29W640DT ID (64M = 4M x 16 )	*/
 
 #define INTEL_ID_28F016S    0x66a066a0	/* 28F016S[VS] ID (16M = 512k x 16)	*/
 #define INTEL_ID_28F800B3T  0x88928892	/*  8M = 512K x 16 top boot sector	*/
@@ -368,6 +374,9 @@
 #define FLASH_STMW320DT 0x0052		/* STM M29W320DT   (32 M, top boot sector)	*/
 #define FLASH_STMW320DB 0x0053		/* STM M29W320DB   (32 M, bottom boot sect)*/
 #define FLASH_STM320DB	0x00CB		/* STM M29W320DB (4M = 64K x 64, bottom)*/
+
+#define FLASH_STMW640DT	0x22DE		/* STM M29W640DT ( 64M = 4M x 16) */
+
 #define FLASH_STM800DT	0x00D7		/* STM M29W800DT (1M = 64K x 16, top)	*/
 #define FLASH_STM800DB	0x005B		/* STM M29W800DB (1M = 64K x 16, bottom)*/
 
@@ -383,6 +392,10 @@
 #define FLASH_INTEL640T 0x007A		/* INTEL 28F320B3T ( 64M =  4 M x 16 )	*/
 #define FLASH_INTEL640B 0x007B		/* INTEL 28F320B3B ( 64M =  4 M x 16 )	*/
 
+#define FLASH_28F320J3A 0x007C		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
+#define FLASH_28F640J3A 0x007D		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
+#define FLASH_28F128J3A 0x007E		/* INTEL 28F128J3A (128M = 128K x 128)	*/
+
 #define FLASH_28F008S5	0x0080		/* Intel 28F008S5  (  1M =  64K x 16 )	*/
 #define FLASH_28F016SV	0x0081		/* Intel 28F016SV  ( 16M = 512k x 32 )	*/
 #define FLASH_28F800_B	0x0083		/* Intel E28F800B  (  1M = ? )		*/
@@ -417,24 +430,24 @@
 #define FLASH_AMLV320B	0x00A7		/* AMD 29LV320MB   ( 32M = 2M x 16 )	*/
 #define FLASH_AMLV320T	0x00A8		/* AMD 29LV320MT   ( 32M = 2M x 16 )	*/
 #define FLASH_AMLV256U	0x00AA		/* AMD 29LV256M	   ( 256M = 16M x 16 )	*/
-#define FLASH_MXLV320B	0x00AB		/* MX  29LV320MB   ( 32M = 2M x 16 )	*/
+#define FLASH_MXLV320B  0x00AB		/* MX  29LV320MB   ( 32M = 2M x 16 )	*/
 #define FLASH_MXLV320T	0x00AC		/* MX  29LV320MT   ( 32M = 2M x 16 )	*/
+#define FLASH_MXLV640MB	0x00AD		/* MX  29LV640MB                        */
+#define FLASH_MXLV640MT	0x00AE		/* MX  29LV640MT                        */
+#define FLASH_MXLV640BT 0x00AF		/* MX  29LV640BT						*/
+
+/* Intel 28F256L18T 256M = 128K x 255 + 32k x 4	*/
 #define FLASH_28F256L18T 0x00B0		/* Intel 28F256L18T 256M = 128K x 255 + 32k x 4 */
 #define FLASH_AMDL163T	0x00B2		/* AMD AM29DL163T (2M x 16 )			*/
 #define FLASH_AMDL163B	0x00B3
-#define FLASH_28F64K3	0x00B4		/* Intel 28F64K3   (  64M)		*/
-#define FLASH_28F128K3	0x00B6		/* Intel 28F128K3  ( 128M = 8M x 16 )	*/
-#define FLASH_28F256K3	0x00B8		/* Intel 28F256K3  ( 256M = 16M x 16 )	*/
-
-#define FLASH_28F320J3A 0x00C0		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
-#define FLASH_28F640J3A 0x00C2		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
-#define FLASH_28F128J3A 0x00C4		/* INTEL 28F128J3A (128M = 128K x 128)	*/
-#define FLASH_28F256J3A 0x00C6		/* INTEL 28F256J3A (256M = 128K x 256)	*/
-
-#define FLASH_FUJLV650	0x00D0		/* Fujitsu MBM 29LV650UE/651UE		*/
-#define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
-#define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
-#define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
+
+#define FLASH_FUJLV650	0x00B4		/* Fujitsu MBM 29LV650UE/651UE		*/
+
+#define FLASH_MXLV640DT	0x00B5
+#define FLASH_SPA064MR3	0x00B6		/* Spansion S29GL064MR3			*/
+#define FLASH_SPA064MR4	0x00B7		/* Spansion S29GL064MR4		*/
+#define FLASH_SPA128N	0x00B8		/* Spansion S29GL128N */
+#define FLASH_SPA256N	0x00B9		/* Spansion S29GL128N */
 
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
@@ -447,7 +460,7 @@
 #define FLASH_MAN_MX	0x00030000	/* MXIC					*/
 #define FLASH_MAN_STM	0x00040000
 #define FLASH_MAN_TOSH	0x00050000	/* Toshiba				*/
-#define FLASH_MAN_EXCEL 0x00060000	/* Excel Semiconductor			*/
+#define FLASH_MAN_SPA	0x00060000	/* Spansion */
 #define FLASH_MAN_SST	0x00100000
 #define FLASH_MAN_INTEL 0x00300000
 #define FLASH_MAN_MT	0x00400000
diff -urN u-boot-1.3.1/lib_sh/board.c u-boot-1.3.1_st2.3-32/lib_sh/board.c
--- u-boot-1.3.1/lib_sh/board.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/lib_sh/board.c	2009-01-22 09:21:01.000000000 +0100
@@ -105,7 +105,7 @@
 static int display_banner (void)
 {
 
-	printf ("\n\n%s\n\n", version_string);
+	printf ("\n\n\n%s\n", version_string);
 	return (0);
 }
 
@@ -154,8 +154,8 @@
 	init_baudrate,		/* initialze baudrate settings */
 	serial_init,		/* serial communications setup */
 	console_init_f,		/* Initial console             */
-	checkboard,
 	display_banner,		/* say that we are here */
+	checkboard,
 	init_func_ram,
 	NULL,
 };
@@ -282,6 +282,13 @@
 #endif
 	eth_initialize(gd->bd);
 #endif
+	
+#ifdef CONFIG_DGS_UPGRADE
+	gd->dgs_upg_buffer = CFG_DGS_UPGRADE_BUFSTART;
+	printf("Reserve 0x%x bytes from 0x%x for DGS upgrade buffer.\n",
+			CFG_DGS_UPGRADE_BUFSIZE,
+			gd->dgs_upg_buffer);
+#endif
 
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
diff -urN u-boot-1.3.1/lib_sh/sh_linux.c u-boot-1.3.1_st2.3-32/lib_sh/sh_linux.c
--- u-boot-1.3.1/lib_sh/sh_linux.c	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/lib_sh/sh_linux.c	2009-01-22 09:21:01.000000000 +0100
@@ -50,6 +50,11 @@
 #define LOADER_TYPE		((unsigned long *) (param+0x00c))
 #define INITRD_START		((unsigned long *) (param+0x010))
 #define INITRD_SIZE		((unsigned long *) (param+0x014))
+#if defined(CONFIG_SLOBBIE_IP)	// old compat
+#define BDINFO			((char*)(param+0x01C))
+#else
+#define BDINFO			((char*)(param+0x018))
+#endif
 #define SE_MODE			((const unsigned long *) (param+0x018))
 /* ... */
 #define COMMAND_LINE		((char *) (param+0x100))
@@ -270,6 +275,9 @@
 	if (*extra)
 		strcpy (COMMAND_LINE + strlen (commandline), extra);
 
+	/* copy board info */
+	memcpy((char*)BDINFO, (char*)gd->bd, sizeof(bd_t));
+
 	/* linux_params_init (gd->bd->bi_boot_params, commandline); */
 
 	printf ("\nStarting kernel %s - 0x%08x - %d ...\n\n", COMMAND_LINE,
diff -urN u-boot-1.3.1/Makefile u-boot-1.3.1_st2.3-32/Makefile
--- u-boot-1.3.1/Makefile	2010-01-12 10:59:52.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/Makefile	2009-01-22 09:20:40.000000000 +0100
@@ -281,8 +281,12 @@
 $(obj)u-boot.srec:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O srec $< $@
 
-$(obj)u-boot.bin:	$(obj)u-boot
+$(obj)u-boot.bin:	$(obj)u-boot prepare_mkverbin
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+		./mkverbin
+
+prepare_mkverbin: mkverbin.c
+		gcc -o mkverbin $<
 
 $(obj)u-boot.img:	$(obj)u-boot.bin
 		./tools/mkimage -A $(ARCH) -T firmware -C none \
@@ -2671,6 +2675,63 @@
 ## SuperH SH4
 #########################################################################
 
+cuberevo_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+#@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h
+	@./mkconfig -a cuberevo sh sh cuberevo "dgstation" stb7100
+
+cuberevo-9500hd_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-9500hd sh sh cuberevo-9500hd "dgstation" stb7100
+
+cuberevo-mini_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-mini sh sh cuberevo-mini "dgstation" stb7100
+
+cuberevo-mini2_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-mini2 sh sh cuberevo-mini2 "dgstation" stb7100
+
+cuberevo-mini-fta_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-mini-fta sh sh cuberevo-mini-fta "dgstation" stb7100
+
+cuberevo-250hd_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-250hd sh sh cuberevo-250hd "dgstation" stb7100
+
+cuberevo-2000hd_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100  1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 27" >>include/config.h
+	@./mkconfig -a cuberevo-2000hd sh sh cuberevo-2000hd "dgstation" stb7100
+
+cuberevo-100hd_config : unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100	1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411		1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE 	27" >>include/config.h
+	@./mkconfig -a slobbie-ip sh sh slobbie-ip "dgstation" stb7100
+
 mb411_config :		unconfig
 	@ >include/config.h
 	@echo "#define CONFIG_SH_STB7100 1" >>include/config.h
diff -urN u-boot-1.3.1/mkverbin.c u-boot-1.3.1_st2.3-32/mkverbin.c
--- u-boot-1.3.1/mkverbin.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1_st2.3-32/mkverbin.c	2009-01-22 09:20:52.000000000 +0100
@@ -0,0 +1,69 @@
+// uboot끝에 버전을 써넣는다.
+#include <stdio.h>
+
+// VeRJan 30 2008 - 14:45:02 => 총 3+22 byte
+const char version_string[] = "VeR" __DATE__ " - " __TIME__ "";
+
+#define BOOTSIZE	0x40000
+#define VERSIZE		25
+
+int main(void)
+{
+	FILE *in, *out;
+	unsigned char *buf = NULL;
+	int size;
+
+	buf = malloc(BOOTSIZE);
+	if(buf == NULL)
+	{
+		printf("[ERR] can't alloc mem\n");
+		return -1;
+	}
+
+	in = fopen("./u-boot.bin", "rb");
+	out = fopen("./u-boot.bin.ver", "wb");
+
+	if(in == NULL)
+	{
+		printf("[ERR] can't open u-boot.bin\n");
+		goto err0;
+	}
+
+	if(out == NULL)
+	{
+		printf("[ERR] can't open u-boot.bin.ver\n");
+		goto err1;
+	}
+
+	fseek(in, 0, SEEK_END);
+	size = ftell(in);
+	fseek(in, 0, SEEK_SET);
+	fread(buf, BOOTSIZE, 1, in);
+	if(size > BOOTSIZE-VERSIZE)
+	{
+		printf("[ERR] boot is too large !!!\n");
+		goto err2;
+	}
+
+	fwrite(buf, size, 1, out);
+	fseek(out, BOOTSIZE-VERSIZE, SEEK_SET);
+	fwrite(version_string, VERSIZE, 1, out);
+
+	fclose(in);
+	fclose(out);
+
+	if(buf) free(buf);
+
+	return 0;
+
+
+err2:;
+	fclose(out);
+err1:;
+       	fclose(in);
+err0:;
+	if(buf) free(buf);
+
+	return -1;
+}
+
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/cmd_bootmenu_cmds.c u-boot-1.3.1/board/dgstation/slobbie-ip/cmd_bootmenu_cmds.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/cmd_bootmenu_cmds.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/cmd_bootmenu_cmds.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,44 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_BOOTMENU
+
+#include "common/cmd_bootmenu.h"
+
+dgs_bootmenu_t dgs_bootmenu_cmds[] =
+{
+	{
+		{ key_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_front_power, key_null },
+		20*3,
+		"menu_upgusbhost",
+	},
+	{
+		{ key_down, key_null},
+		20*3,
+		"menu_upgnet",
+	},
+
+	/* user selectable menu command */
+	{	{ key_1, key_null }, 20*3, "menu_1", },
+	{	{ key_2, key_null }, 20*3, "menu_2", },
+	{	{ key_3, key_null }, 20*3, "menu_3", },
+	{	{ key_4, key_null }, 20*3, "menu_4", },
+	{	{ key_5, key_null }, 20*3, "menu_5", },
+	{	{ key_6, key_null }, 20*3, "menu_6", },
+	{	{ key_7, key_null }, 20*3, "menu_7", },
+	{	{ key_8, key_null }, 20*3, "menu_8", },
+	{	{ key_9, key_null }, 20*3, "menu_9", },
+	{	{ key_0, key_null }, 20*3, "menu_0", },
+
+	{	/* always NULL terminated */
+		{ key_null },
+		0,
+		NULL,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/config.mk u-boot-1.3.1/board/dgstation/slobbie-ip/config.mk
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/config.mk	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# cuberevo board 
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+#TEXT_BASE = 0x85F00000
+TEXT_BASE = 0x85000000
+PLATFORM_LDFLAGS += 
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(VENDOR)
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/denc.h u-boot-1.3.1/board/dgstation/slobbie-ip/denc.h
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/denc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/denc.h	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef _DENC_H
+#define _DENC_H
+
+/* DENC device type */
+enum
+{
+	STDENC_DEVICE_TYPE_DENC,
+	STDENC_DEVICE_TYPE_7015,
+	STDENC_DEVICE_TYPE_7020,
+	STDENC_DEVICE_TYPE_GX1,
+	STDENC_DEVICE_TYPE_4629,
+	STDENC_DEVICE_TYPE_V13
+};
+
+/* DENC mode */
+enum
+{
+	STDENC_MODE_NONE,
+	STDENC_MODE_NTSCM,
+	STDENC_MODE_NTSCM_J,
+	STDENC_MODE_NTSCM_443,
+	STDENC_MODE_PALBDGHI,
+	STDENC_MODE_PALM,
+	STDENC_MODE_PALN,
+	STDENC_MODE_PALN_C,
+	STDENC_MODE_SECAM,
+	STDENC_MODE_SECAM_AUX
+};
+
+/* DENC register address */
+#define DENC_BASE	0xb920c000
+
+#define DENC_CFG0               (DENC_BASE+0x00)            /* Configuration 0 */
+#define DENC_CFG1               (DENC_BASE+0x04)            /* Configuration 1 */
+#define DENC_CFG2               (DENC_BASE+0x08)            /* Configuration 2 */
+#define DENC_CFG3               (DENC_BASE+0x0C)            /* Configuration 3 */
+#define DENC_CFG4               (DENC_BASE+0x10)            /* Configuration 4 */
+#define DENC_CFG5               (DENC_BASE+0x14)            /* Configuration 5 */
+#define DENC_CFG6               (DENC_BASE+0x18)            /* Configuration 6 */
+#define DENC_CFG7               (DENC_BASE+0x1C)            /* Configuration 7 */
+#define DENC_CFG8               (DENC_BASE+0x20)            /* Configuration 8 */
+#define DENC_CFG9               (DENC_BASE+0x144)           /* Configuration 9 */
+#define DENC_CFG10               (DENC_BASE+0x170)           /* Configuration 9 */
+#define DENC_CFG11               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG12               (DENC_BASE+0x174)           /* Configuration 9 */
+#define DENC_CFG13               (DENC_BASE+0x17c)           /* Configuration 9 */
+#define DENC_STATUS             (DENC_BASE+0x24)            /* Status */
+
+#define DENC_HWID		(DENC_BASE + 0x060)
+
+#define DENC_IDFS2  		(DENC_BASE + 0x028)  /* Increment digital frequency synthesiser [23:16] */
+#define DENC_IDFS1  		(DENC_BASE + 0x02c)  /* Increment digital frequency synthesiser [15:8]  */
+#define DENC_IDFS0		(DENC_BASE + 0x030)  /* Increment digital frequency synthesiser [7:0]   */
+
+/* DENC register bit value */
+/* DENC_CFG0 - Configuration register 0  (8-bit)---------------------------- */
+#define DENC_CFG0_MASK_STD   0x3F /* Mask for standard selected              */
+#define DENC_CFG0_PAL_BDGHI  0x00 /* PAL B, D, G, H or I standard selected   */
+#define DENC_CFG0_PAL_N      0x40 /* PAL N standard selected                 */
+#define DENC_CFG0_NTSC_M     0x80 /* NTSC M  standard selected               */
+#define DENC_CFG0_PAL_M      0xC0 /* PAL M standard selected                 */
+#define DENC_CFG0_MASK_SYNC  0xC7 /* Mask for synchro configuration          */
+#define DENC_CFG0_ODDE_SLV   0x00 /* ODDEVEN based slave mode (frame lock)   */
+#define DENC_CFG0_FRM_SLV    0x08 /* Frame only based slave mode(frame lock) */
+#define DENC_CFG0_ODHS_SLV   0x10 /* ODDEVEN + HSYNC based slave mode(line l)*/
+#define DENC_CFG0_FRHS_SLV   0x18 /* Frame + HSYNC based slave mode(line l)  */
+#define DENC_CFG0_VSYNC_SLV  0x20 /* VSYNC only based slave mode(frame l   ) */
+#define DENC_CFG0_VSHS_SLV   0x28 /* VSYNC + HSYNC based slave mode(line l  )*/
+#define DENC_CFG0_MASTER     0x30 /* Master mode selected                    */
+#define DENC_CFG0_COL_BAR    0x38 /* Test color bar pattern enabled          */
+#define DENC_CFG0_HSYNC_POL  0x04 /* HSYNC positive pulse                    */
+#define DENC_CFG0_ODD_POL    0x02 /* Synchronisation polarity selection      */
+#define DENC_CFG0_FREE_RUN   0x01 /* Freerun On                              */
+
+/* DENC_CFG1 - Configuration register 1  (8-bit)---------------------------- */
+#define DENC_CFG1_VBI_SEL      0x80 /* Full VBI selected                     */
+#define DENC_CFG1_MASK_FLT     0x9F /* Mask for U/V Chroma filter bandwith   */
+                                    /* selection                             */
+#define DENC_CFG1_MASK_SYNC_OK 0xEF /* mask for sync in case of frame loss   */
+#define DENC_CFG1_FLT_11       0x00 /* FLT Low definition NTSC filter        */
+#define DENC_CFG1_FLT_13       0x20 /* FLT Low definition PAL filter         */
+#define DENC_CFG1_FLT_16       0x40 /* FLT High definition NTSC filter       */
+#define DENC_CFG1_FLT_19       0x60 /* FLT High definition PAL filter        */
+#define DENC_CFG1_SYNC_OK      0x10 /* Synchronisation avaibility            */
+#define DENC_CFG1_COL_KILL     0x08 /* Color suppressed on CVBS              */
+#define DENC_CFG1_SETUP        0x04 /* Pedestal setup (7.5 IRE)              */
+#define DENC_CFG1_MASK_CC      0xFC /* Mask for Closed caption encoding mode */
+#define DENC_CFG1_CC_DIS       0x00 /* Closed caption data encoding disabled */
+#define DENC_CFG1_CC_ENA_F1    0x01 /* Closed caption enabled in field 1     */
+#define DENC_CFG1_CC_ENA_F2    0x02 /* Closed caption enabled in field 2     */
+#define DENC_CFG1_CC_ENA_BOTH  0x03 /* Closed caption enabled in both fields */
+#define DENC_CFG1_DAC_INV      0x80 /* Enable DAC input data inversion       */
+/* DENC_CFG2 - Configuration register 2  (8-bit)---------------------------- */
+#define DENC_CFG2_NO_INTER     0x80 /* Non-interlaced mode selected          */
+#define DENC_CFG2_ENA_RST      0x40 /* Cyclic phase reset enabled            */
+#define DENC_CFG2_ENA_BURST    0x20 /* Chrominance burst enabled             */
+/* register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_444      0x10 /* Select 444 input for RGB tri-dacs     */
+/* end register macrocell V3/V5/V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG2_SEL_RST      0x08 /* Reset DDFS with value on DNC_IFx reg. */
+#define DENC_CFG2_RST_OSC      0x04 /* Software phase reset of DDFS          */
+#define DENC_CFG2_MASK_RST     0xFC /* Mask for reset DDFS mode              */
+#define DENC_CFG2_RST_8F       0x03 /* Reset DDFS every 8 fields             */
+#define DENC_CFG2_RST_4F       0x02 /* Reset DDFS every 4 fields             */
+#define DENC_CFG2_RST_2F       0x01 /* Reset DDFS every 2 fields             */
+#define DENC_CFG2_RST_EVE      0x00 /* Reset DDFS every line                 */
+
+
+/* DENC_CFG3 - Configuration register 3  (8-bit) --------------------------- */
+#define DENC_CFG3_ENA_TRFLT    0x80 /* Enable Trap filter                    */
+#define DENC_CFG3_PAL_TRFLT    0x40 /* select Trap filter 4,43 MHz           */
+#define DENC_CFG3_ENA_CGMS     0x20 /* Enable CGMS encoding                  */
+#define DENC_CFG3_VAL_422_CK_MUX 0x04 /* Enable external clock for debug and validation */
+/* register macrocell V3/V5/V6/V7/V8/V9 */
+#define DENC_CFG3_MASK_DELAY   0xF1 /* Mask for delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P2     0x04 /* +2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_P1     0x02 /* +1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_0      0x00 /* +0 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M1     0x0E /* -1 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_DELAY_M2     0x0C /* -2 pixel delay on luma 4:2:2 inputs   */
+#define DENC_CFG3_ENA_WSS      0x01 /* wide screen signalling enable         */
+/* end register macrocell V3/V5/V6/V7/V8/V9 */
+/* register macrocell V3/V5 */
+#define DENC_CFG3_NOSD         0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V3/V5 */
+/* register macrocell V7/V8/V9/V10/V11/V12 */
+#define DENC_CFG3_CK_IN_PHASE  0x10 /*choice of active edge  of 'denc_ref_ck'*/
+/* end register macrocell V7/V8/V9/V10/V11/V12 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG3_DELAY_ENABLE 0x08 /* enable of chroma to luma delay        */
+/* end register macrocell V10/V11/V12 */
+
+/* DENC_CFG4 - Configuration register 4  (8-bit) --------------------------- */
+#define DENC_CFG4_MASK_SYIN    0x3F /* Mask for adjustment of incoming       */
+                                    /* synchro signals                       */
+#define DENC_CFG4_SYIN_0       0x00 /* nominal delay                         */
+#define DENC_CFG4_SYIN_P1      0x40 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYIN_P2      0x80 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYIN_P3      0xC0 /* delay = +3 ckref                      */
+#define DENC_CFG4_MASK_SYOUT   0xCF /* Mask for adjustment of outgoing       */
+                                   /* synchro signals                       */
+#define DENC_CFG4_SYOUT_0      0x00 /* nominal delay                         */
+#define DENC_CFG4_SYOUT_P1     0x10 /* delay = +1 ckref                      */
+#define DENC_CFG4_SYOUT_P2     0x20 /* delay = +2 ckref                      */
+#define DENC_CFG4_SYOUT_P3     0x30 /* delay = +3 ckref                      */
+#define DENC_CFG4_ALINE        0x08 /* Video active line duration control    */
+/* register macrocell V3/V5/V6 */
+#define DENC_CFG4_MASK_TXD     0xF8 /* Mask for teletext data latency        */
+#define DENC_CFG4_TXT_LAT_2    0x00 /* teletext data latency 2=2+0           */
+#define DENC_CFG4_TXT_LAT_3    0x01 /* teletext data latency 3=2+1           */
+#define DENC_CFG4_TXT_LAT_4    0x02 /* teletext data latency 4=2+2           */
+#define DENC_CFG4_TXT_LAT_5    0x03 /* teletext data latency 5=2+3           */
+#define DENC_CFG4_TXT_LAT_6    0x04 /* teletext data latency 6=2+4           */
+#define DENC_CFG4_TXT_LAT_7    0x05 /* teletext data latency 7=2+5           */
+#define DENC_CFG4_TXT_LAT_8    0x06 /* teletext data latency 8=2+6           */
+#define DENC_CFG4_TXT_LAT_9    0x07 /* teletext data latency 9=2+7           */
+/* end register macrocell V3/V5/V6 */
+/* register macrocell V7/V8/V9/10/V11*/
+#define DENC_CFG4_MASK_DELAY   0xF8 /* Mask for delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P2     0x02 /* +2 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_P1     0x01 /* +1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_0      0x00 /* +0 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M1     0x07 /* -1 pixel delay on luma 4:4:4 inputs   */
+#define DENC_CFG4_DELAY_M2     0x06 /* -2 pixel delay on luma 4:4:4 inputs   */
+
+/* DENC_CFG5 - Configuration register 5  (8-bit) --------------------------- */
+/* register macrocell V3 */
+#define DENC_CFG5_MASK_CONF    0x7F /* mask for configuration of outputs     */
+#define DENC_CFG5_RGB          0x80 /* outputs selection : R-G-B-CVBS1       */
+#define DENC_CFG5_NYC          0x00 /* outputs selection : Y-C-CVBS-CVBS1    */
+#define DENC_CFG5_DIS_CVBS1    0x40 /*  */
+#define DENC_CFG5_DIS_YS_V3    0x08 /*  */
+#define DENC_CFG5_DIS_C_V3     0x04 /*  */
+#define DENC_CFG5_DIS_CVBS     0x02 /*  */
+/* end 'register macrocell V3' */
+/* register macrocell V5 */
+/*#define DENC_CFG5_DIS_CVBS1    0x40 already defined */
+#define DENC_CFG5_DIS_YS_V5    0x20 /*  */
+#define DENC_CFG5_DIS_C_V5     0x10 /*  */
+#define DENC_CFG5_DIS_R        0x08 /*  */
+#define DENC_CFG5_DIS_G        0x04 /*  */
+#define DENC_CFG5_DIS_B        0x02 /*  */
+/* end 'register macrocell V5' */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG5_SEL_INC      0x80 /* Choice of Dig Freq Synthe increment   */
+/* end 'register macrocell V7/V8/V9/10/V11' */
+/* register macrocell V6/V7/V8/V9/10/V11 */
+#define DENC_CFG5_DIS_DAC1     0x40 /* DAC 1 input forced to 0               */
+#define DENC_CFG5_DIS_DAC2     0x20 /* DAC 2 input forced to 0               */
+#define DENC_CFG5_DIS_DAC3     0x10 /* DAC 3 input forced to 0               */
+#define DENC_CFG5_DIS_DAC4     0x08 /* DAC 4 input forced to 0               */
+#define DENC_CFG5_DIS_DAC5     0x04 /* DAC 5 input forced to 0               */
+#define DENC_CFG5_DIS_DAC6     0x02 /* DAC 6 input forced to 0               */
+/* end 'register macrocell V6/V7/V8/V9/10/V11' */
+#define DENC_CFG5_DAC_INV      0x01 /* Enable DAC input data inversion       */
+#define DENC_CFG5_DAC_NONINV   0x00 /* Enable DAC input data non inversion   */
+
+/* DENC_CFG6 - Configuration register 6 ------------------------------------ */
+#define DENC_CFG6_RST_SOFT     0x80 /* Denc soft reset                       */
+#define DENC_CFG6_MASK_LSKP    0x8F /* mask for line skip configuration      */
+#define DENC_CFG6_NORM_MODE    0x00 /* normal mode, no insert/skip capable   */
+#define DENC_CFG6_MAN_MODE     0x10 /* same as normal, unless skip specified */
+#define DENC_CFG6_AUTO_INS     0x40 /* automatic line insert mode            */
+#define DENC_CFG6_AUTO_SKP     0x60 /* automatic line skip mode              */
+#define DENC_CFG6_FORBIDDEN    0x70 /* Reserved, don't write this value      */
+#define DENC_CFG6_MAX_DYN      0x01 /* Maximum dynamic range 1-254 ( 16-240) */
+/* register macrocell V3 */
+#define DENC_CFG6_CHGI2C_0     0x02 /* Chip add select; write=0x40,read=0x41 */
+#define DENC_CFG6_CHGI2C_1     0x00 /* Chip add select; write=0x42,read=0x43 */
+/* end register macrocell V3 */
+/* register macrocell V7/V8/V9/10/V11 */
+#define DENC_CFG6_TTX_ENA      0x02 /* Teletexte enable bit                  */
+#define DENC_CFG6_MASK_CFC     0x0C /* Color frequency control mask          */
+#define DENC_CFG6_CFC_OFF      0x00 /* Update of increment for DDFS disabled */
+#define DENC_CFG6_CFC_IMM      0x04 /* Update immediately after loading / CFC*/
+#define DENC_CFG6_CFC_HSYNC    0x08 /* Update on next active edge of HSYNC   */
+#define DENC_CFG6_CFC_COLBUR   0x0C /* Update just before next color burst   */
+/* end register macrocell V7/V8/V9/10/V11 */
+
+
+/* DENC_CFG7 - Configuration register 7 ( SECAM mainly ) ------------------- */
+#define DENC_CFG7_SECAM        0x80 /* Select SECAM chroma encoding on top   */
+                                    /* of config selected in DENC_CFG0       */
+#define DENC_CFG7_PHI12_SEC    0x40 /* sub carrier phase sequence start      */
+#define DENC_CFG7_INV_PHI_SEC  0x20 /* invert phases on second field         */
+/* register macrocell V6/V7/V8/V9/V10/V11 */
+#define DENC_CFG7_SETUP_YUV    0x08 /* Control of pedestal enabled for YUV   */
+#define DENC_CFG7_UV_LEV       0x04 /* UV output level control               */
+/* end register macrocell V6/V7/V8/V9/V10/V11 */
+/* register macrocell V12 */
+#define DENC_CFG7_SETUP_AUX    0x08 /* Control of pedestal enabled for AUX   */
+/* end register macrocell V12 */
+
+#define DENC_CFG7_ENA_VPS      0x02 /* enable video programming system       */
+#define DENC_CFG7_SQ_PIX       0x01 /* enable square pixel mode (PAL/NTSC)   */
+
+/* DENC_CFG7 - Configuration register 8 (only for activating MUX422*/
+#define DENC_CFG8_VAL_422_MUX  0x10 /* Enable video output in STi4629 */
+
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_FLT_YS       0x01 /* Enable software luma coeffs           */
+#define DENC_CFG9_PLG_DIV_Y_0  0x02 /* Sum of coefficients                   */
+#define DENC_CFG9_PLG_DIV_Y_1  0x04 /* Sum of coefficients                   */
+#define DENC_CFG9_MASK_PLG_DIV 0xF9 /* Mask for sum of coefficients          */
+/* end register macrocell V10/V11/V12 */
+/* register macrocell V10/V11 */
+#define DENC_CFG9_444_CVBS     0x08 /* Set 4:4:4 for CVBS                    */
+/* end register macrocell V10/V11 */
+/* register macrocell V10/V11/V12 */
+#define DENC_CFG9_MASK_DELAY   0x0F /* Mask for delay on chroma path         */
+#define DENC_CFG9_DELAY_P2_5   0xC0 /* +2.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P2     0xD0 /* +2 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_P1_5   0xE0 /* +1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_P1     0xF0 /* +1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_0_5    0x00 /* +0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_0      0x10 /* +0 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M0_5   0x20 /* -0.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M1     0x30 /* -1 pixel delay on chroma path         */
+#define DENC_CFG9_DELAY_M1_5   0x40 /* -1.5 pixel delay on chroma path       */
+#define DENC_CFG9_DELAY_M2     0x50 /* -2 pixel delay on chroma path         */
+/* end register macrocell V10/V11/V12 */
+
+/* register macrocell V12 */
+/* DENC_CFG10 - Configuration register 10  (8-bit)-------------------------- */
+#define DENC_CFG10_AUX_MSK_FLT 0x9F /* Mask for U/V Chroma filter bandwith   */
+                                     /* selection on AUX                     */
+#define DENC_CFG10_AUX_FLT_11  0x00 /* AUX FLT Low definition NTSC filter    */
+#define DENC_CFG10_AUX_FLT_13  0x20 /* AUX FLT Low definition PAL filter     */
+#define DENC_CFG10_AUX_FLT_16  0x40 /* AUX FLT High definition NTSC filter   */
+#define DENC_CFG10_AUX_FLT_19  0x60 /* AUX FLT High definition PAL filter    */
+#define DENC_CFG10_AUX_CO_KIL  0x10 /* Color suppressed on CVBS AUX          */
+#define DENC_CFG10_RGB_SAT_EN  0x08 /* RGB outputs saturated to real colors. */
+#define DENC_CFG10_SECAM_IN    0x04 /* Secam input video select.             */
+
+/* DENC_CFG11 - Configuration register 11  (8-bit)-------------------------- */
+#define DENC_CFG11_AUX_MASK_DEL 0x0F /* Mask for delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P2_5 0xC0 /* +2.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P2   0xD0 /* +2 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_P1_5 0xE0 /* +1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_P1   0xF0 /* +1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_0_5  0x00 /* +0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_0    0x10 /* +0 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M0_5 0x20 /* -0.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M1   0x30 /* -1 pixel delay on aux chroma path    */
+#define DENC_CFG11_AUX_DEL_M1_5 0x40 /* -1.5 pixel delay on aux chroma path  */
+#define DENC_CFG11_AUX_DEL_M2   0x50 /* -2 pixel delay on aux chroma path    */
+#define DENC_CFG11_MAIN_IF_DEL  0x04 /* delay on luma vs chroma in CVBS_main */
+
+/* DENC_CFG12 - Configuration register 12  (8-bit)-------------------------- */
+#define DENC_CFG12_AUX_ENTRAP   0x80 /* Enable trap filter in CVBS_aux       */
+#define DENC_CFG12_AUX_DEL_EN   0x08 /* Enable luma to chroma delay on aux   */
+#define DENC_CFG12_MAIN_ENNOTCH 0x04 /* Notch filtering on main luma input   */
+#define DENC_CFG12_AUX_MAX_DYN  0x02 /* max dynamic magnitude allowed on aux */
+/* end 'register macrocell V12' */
+
+#define DENC_CFG13_CVBS_MAIN    0x7     /* enable CVBS SD output on dac6 */
+#define DENC_CFG13_YCCVBS_MAIN  0x7     /* enable CVBS SD output on dac3 */
+/* STi7015/20 specific DENC registers, out of DENC cell registers */
+/* As addressing is 32bits, register offsets are given divided by 4 */
+#define DENC_CFG_7015          0x70 /* 0x1C0>>2 DENC configuration           */
+#define DENC_TTX_7015          0x71 /* 0x1C4>>2 Start address of Txt file    */
+
+#define DENC_CFG_7015_ON       0x01  /* DENC On. To be set to use DENC       */
+#define DENC_CFG_7015_CKR      0x02  /* Insertion of CLKRUN for Teletext     */
+#define DENC_TTX_7015_MASK     0x3FFFF00 /* Mask of address in the 32bits    */
+
+
+
+typedef unsigned char U8;
+typedef unsigned int U32;	
+
+/* DENC registers are 'Delay on luma path with reference to chroma path on 4:2:2 inputs'
+ * At API level, choosen value is 'Chroma Delay', so delays must be inverted, that's why
+ * table starts with positive delay toward negative delays */
+static U8 ChromaDelayV3To9[] = {	DENC_CFG3_DELAY_P2,
+					DENC_CFG3_DELAY_P1,
+					DENC_CFG3_DELAY_0,
+					DENC_CFG3_DELAY_M1,
+					DENC_CFG3_DELAY_M2
+};
+/* Delay on chroma path with reference to luma path on S-VHS and CVBS */
+static U8 ChromaDelayV10More[] = {	DENC_CFG9_DELAY_M2,
+					DENC_CFG9_DELAY_M1_5,
+					DENC_CFG9_DELAY_M1,
+					DENC_CFG9_DELAY_M0_5,
+					DENC_CFG9_DELAY_0,
+					DENC_CFG9_DELAY_0_5,
+					DENC_CFG9_DELAY_P1,
+					DENC_CFG9_DELAY_P1_5,
+					DENC_CFG9_DELAY_P2,
+					DENC_CFG9_DELAY_P2_5
+};
+
+/* Delay on AUX chroma path with reference to AUX luma path on S-VHS and CVBS */
+static U8 ChromaDelayAux[] = {	DENC_CFG11_AUX_DEL_M2,
+				DENC_CFG11_AUX_DEL_M1_5,
+				DENC_CFG11_AUX_DEL_M1,
+				DENC_CFG11_AUX_DEL_M0_5,
+				DENC_CFG11_AUX_DEL_0,
+				DENC_CFG11_AUX_DEL_0_5,
+				DENC_CFG11_AUX_DEL_P1,
+				DENC_CFG11_AUX_DEL_P1_5,
+				DENC_CFG11_AUX_DEL_P2,
+				DENC_CFG11_AUX_DEL_P2_5
+};
+
+static U32 Idfs[] = {   0x2A098B, /* NTSCM_443         */
+			0x2E3DB2, /* NTSCM_443_SQ      */
+			0x21E7CE, /* NTSCM_60Hz        */
+			0x254BC9, /* NTSCM_60Hz_SQ     */
+			0x29FECB, /* NTSCM_443_60Hz    */
+			0x2E31DF  /* NTSCM_443_60Hz_SQ */
+};
+
+enum
+{
+	NTSCM_443,          /* ref clk 27000kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_SQ,       /* ref clk 24545.45kHz, color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_60Hz,         /* ref clk 27027kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_60Hz_SQ,      /* ref clk 24057kHz,    color subcarrier frequency 3579545.2  Hz*/
+	NTSCM_443_60Hz,     /* ref clk 27027kHz,    color subcarrier frequency 4433618.75 Hz*/
+	NTSCM_443_60Hz_SQ,   /* ref clk 24057kHz,    color subcarrier frequency 4433618.75 Hz*/
+	PALN_SQ
+};
+
+
+
+
+
+#define STDENC_MIN_CHROMA_DELAY (-4)
+#define STDENC_MAX_CHROMA_DELAY_V10_MORE 5
+#define STDENC_MAX_CHROMA_DELAY_V10_LESS 4
+#define STDENC_STEP_CHROMA_DELAY_V10_MORE 1
+#define STDENC_STEP_CHROMA_DELAY_V10_LESS 2
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/flash_imgs.c u-boot-1.3.1/board/dgstation/slobbie-ip/flash_imgs.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/flash_imgs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/flash_imgs.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,111 @@
+#include <common.h>
+
+#if defined(CONFIG_SERIAL_SET2SET) || defined(CFG_JFFS_CUSTOM_PART)
+
+#include "common/flash_img_info.h"
+
+/*
+ * MUST use same values from kernel mtd block sizes...
+ *
+ * see file dgs/common/linux/drivers/mtd/maps/relook511.c
+ * you can just copy below definations from the file.
+ */
+
+#define	FLASH_32MB
+//#define FLASH_16MB
+
+
+#if defined(FLASH_32MB)
+
+// 32MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x02000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x200000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0xA00000
+
+#elif defined(FLASH_16MB) 
+
+// 16MB flash
+#define WINDOW_ADDR	0xA0000000
+#define WINDOW_SIZE	0x01000000
+
+#define BOOT_SIZE	0x040000	// boot loader
+#define WELCOME_SIZE	0x020000	// welcome+boot config
+#define KERNEL_SIZE	0x1A0000	// kernel size
+#define ROOT_SIZE	(WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE)
+#define DB_SIZE		0x600000
+
+#else
+
+// 8MB flash
+#define WINDOW_ADDR     0xA0000000 	 
+#define WINDOW_SIZE     0x00800000 	 
+
+#define BOOT_SIZE       0x030000        // boot loader 	 
+#define WELCOME_SIZE    0x010000        // welcome+boot config 	 
+#define KERNEL_SIZE     0x180000        // kernel size 	 
+#define ROOT_SIZE       (WINDOW_SIZE-WELCOME_SIZE-KERNEL_SIZE-DB_SIZE-BOOT_SIZE) 	 
+#define DB_SIZE         0x230000
+
+
+#endif
+
+
+flash_img_info_t dgs_flash_imgs[] =
+{
+	{
+		"boot",
+		WINDOW_ADDR,
+		BOOT_SIZE,
+	},
+
+	{
+		"config_welcome",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE,
+	},
+	{
+		"kernel",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE,
+	},
+	{
+		"root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE,
+		ROOT_SIZE,
+	},
+	{
+		"db",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE,
+		DB_SIZE,
+	},
+	/*************************/
+	{
+		"all",
+		WINDOW_ADDR,
+		WINDOW_SIZE,
+	},
+	{
+		"all_noboot",
+		WINDOW_ADDR+BOOT_SIZE,
+		WELCOME_SIZE+KERNEL_SIZE+ROOT_SIZE+DB_SIZE,
+	},
+	{
+		"kernel_root",
+		WINDOW_ADDR+BOOT_SIZE+WELCOME_SIZE,
+		KERNEL_SIZE+ROOT_SIZE,
+	},
+
+	/*************************/
+	{
+		NULL,
+		0x00000000,
+		0x00000000,
+	},
+};
+
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/front_dev.c u-boot-1.3.1/board/dgstation/slobbie-ip/front_dev.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/front_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/front_dev.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,761 @@
+#include <common.h>
+
+#ifdef CONFIG_DGS_FRONT
+
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/io_stb1eval.h>
+
+#include "common/front.h"
+#include "slobbie-ip/front_dev.h"
+
+#define MICOM_REQ_WR_VFDBUF	(unsigned char)0xd0
+#define MICOM_REQ_WR_VFDUPDATE 	(unsigned char)0xd1
+
+#define UART0_BASE      0xb8030000ul
+#define UART1_BASE      0xb8031000ul
+#define UART2_BASE	0xb8032000ul
+#define UART3_BASE	0xb8033000ul
+
+#define FRONT_BASE	UART2_BASE
+
+//#define DEBUG
+#ifdef DEBUG
+#define fdebug(fmt,arg...) printf(fmt,##arg)
+#else
+#define fdebug(fmt,arg...) do{}while(0)
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define FRONT_PACKCNT		2
+#define FRONT_RMCKEY		0xe0
+#define FRONT_FRTKEY_H		0xe1
+#define FRONT_FRTKEY_L		0xe2
+
+/*-----------------------------------------
+ * SH4 
+ *-----------------------------------------*/
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (FRONT_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (FRONT_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (FRONT_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (FRONT_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (FRONT_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (FRONT_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (FRONT_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (FRONT_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (FRONT_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (FRONT_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (FRONT_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ---------------- 
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------ 
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+typedef struct
+{
+	unsigned short code;
+	enum front_key key;
+} key_table_t;
+
+typedef struct _special_char
+{
+	unsigned char ch;
+	unsigned short value;
+} special_char_t;
+
+unsigned char micom_version[3] = {0,};
+int front_seg_num = 12;
+unsigned short *num2seg;
+unsigned short *Char2seg;
+static special_char_t	*special2seg;
+static int special2seg_size = 4;
+
+key_table_t *fntkeys;
+int fntkeynum = 14;
+
+static const unsigned short num2seg_12dotmatrix[] =
+{
+	0x20,		// 0
+	0x21,		// 1
+	0x22,		// 2
+	0x23,		// 3
+	0x24,		// 4
+	0x25,		// 5
+	0x26,		// 6
+	0x27,		// 7
+	0x28,		// 8
+	0x29,		// 9
+};
+
+static const unsigned short Char2seg_12dotmatrix[] =
+{
+	0x31,		// A
+	0x32,		// B
+	0x33,		// C
+	0x34,		// D
+	0x35,		// E
+	0x36,		// F
+	0x37,		// G
+	0x38,		// H
+	0x39,		// I
+	0x3a,		// J
+	0x3b,		// K
+	0x3c,		// L
+	0x3d,		// M
+	0x3e,		// N
+	0x3f,		// O
+	0x40,		// P
+	0x41,		// Q
+	0x42,		// R
+	0x43,		// S
+	0x44,		// T
+	0x45,		// U
+	0x46,		// V
+	0x47,		// W
+	0x48,		// X
+	0x49,		// Y
+	0x4a,		// Z
+};
+static const unsigned short num2seg_13grid[] =
+{
+	0x3123,		// 0
+	0x0408,		// 1
+	0x30c3,		// 2
+	0x21c3,		// 3
+	0x01e2,		// 4
+	0x21e1,		// 5
+	0x31e1,		// 6
+	0x0123,		// 7
+	0x31e3,		// 8
+	0x21e3,		// 9
+};
+
+static const unsigned short Char2seg_13grid[] =
+{
+	0x11e3,		// A
+	0x25cb,		// B
+	0x3021,		// C
+	0x250b,		// D
+	0x30e1,		// E
+	0x10e1,		// F
+	0x31a1,		// G
+	0x11e2,		// H
+	0x2409,		// I
+	0x0809,		// J
+	0x1264,		// K
+	0x3020,		// L
+	0x1136,		// M
+	0x1332,		// N
+	0x3123,		// O
+	0x10e3,		// P
+	0x3323,		// Q
+	0x12e3,		// R
+	0x21e1,		// S
+	0x0409,		// T
+	0x3122,		// U
+	0x1824,		// V
+	0x1b22,		// W
+	0x0a14,		// X
+	0x04e2,		// Y
+	0x2805,		// Z
+};
+
+special_char_t special2seg_12dotmatrix[] =
+{
+	{'-', 	0x1d},
+	{'\'', 	0x90},
+	{'.', 	0x1e},
+	{' ',	0x10},
+};
+
+special_char_t special2seg_13grid[] = 
+{
+	{'-',	0x00c0},
+	{'\'',	0x0004},
+	{'.', 	0x4000},
+	{' ',	0x0000},
+};
+
+const static key_table_t rmckeys[] =
+{
+	{ 0x0a, key_power },
+	{ 0x1d, key_left },
+	{ 0x1c, key_right },
+	{ 0x1a, key_up },
+	{ 0x1b, key_down },
+	{ 0x1f, key_ok },
+	{ 0x26, key_menu},
+	{ 0x10, key_0 },
+	{ 0x11, key_1 },
+	{ 0x12, key_2 },
+	{ 0x13, key_3 },
+	{ 0x14, key_4 },
+	{ 0x15, key_5 },
+	{ 0x16, key_6 },
+	{ 0x17, key_7 },
+	{ 0x18, key_8 },
+	{ 0x19, key_9 },
+	{ 0xff, key_release },
+};
+#define rmckeynum	(sizeof(rmckeys)/sizeof(rmckeys[0]))
+
+key_table_t front_keymap_13grid[] =
+{
+	{ 0x1000, 	key_front_power },	/* front power */
+	{ 0x0002, 	key_front_left },	/* front left */
+	{ 0x0004, 	key_front_right },	/* front right */
+	{ 0x4000,	key_front_up },		/* front up */
+	{ 0x0040,	key_front_down },	/* front down */
+	{ 0x0020, 	key_front_ok },		/* front ok */
+	{ 0x0001, 	key_front_menu },	/* front menu */
+	{ 0x1000|0x0002,key_front_p_left },
+	{ 0x1000|0x0004,key_front_p_right },
+	{ 0x1000|0x4000,key_front_p_up },
+	{ 0x1000|0x0040,key_front_p_down },
+	{ 0x1000|0x0020,key_front_p_ok },
+	{ 0x1000|0x0001,key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+key_table_t front_keymap_12dotmatrix[] =
+{
+	{ (1<<0), 	key_front_power },	/* front power */
+	{ (1<<5), 	key_front_left },	/* front left */
+	{ (1<<6), 	key_front_right },	/* front right */
+	{ (1<<7),	key_front_up },		/* front up */
+	{ (1<<8),	key_front_down },	/* front down */
+	{ (1<<4), 	key_front_ok },		/* front ok */
+	{ (1<<1), 	key_front_menu },	/* front menu */
+	{ (1<<0)|(1<<5),key_front_p_left },
+	{ (1<<0)|(1<<6),key_front_p_right },
+	{ (1<<0)|(1<<7),key_front_p_up },
+	{ (1<<0)|(1<<8),key_front_p_down },
+	{ (1<<0)|(1<<4),key_front_p_ok },
+	{ (1<<0)|(1<<1),key_front_p_menu },
+	{ 0x0000, 	key_front_release },	/* front release */
+};
+
+
+int front_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	
+	int t;
+	int p2_val;
+	unsigned int status;
+
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+	
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	p2_val |= MODE_8BIT;	// 8bit
+	p2_val |= STOP_1BIT;	// stop 1bit
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, BPS_9600);
+	//p2_val |= BAUDMODE;
+	p2_val |= (1<<10);
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	
+	micom_version[0] = micom_version[1] = micom_version[2] = 0;
+
+	return (0);
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void front_putc (char c)
+{
+	int i;
+	while (!putDebugCharReady ()); /* TODO : 계속 레디가 안되면? */
+	p2_outl (UART_TXBUFFER_REG, c&0xff);
+}
+
+int front_send_packet(const char *packet)
+{
+	int a;
+
+	for( a = 0; a < 5; a++)
+	{
+		front_putc( packet[a] );
+	}
+	return 0;
+}
+
+int front_persent( int now, int total )
+{
+	char buf[16];
+
+	sprintf( buf, "received %2d", now*100/total );
+	front_puts( buf );
+
+	return 0;
+}
+
+void front_putchar( int pos, char ch )
+{
+	unsigned char packet[6];
+	unsigned short data;
+	int i;
+
+	switch( ch )
+	{
+		case 'A' ... 'Z':
+			ch -= 'A'-'a';
+		case 'a' ... 'z':
+			data = Char2seg[ch-'a'];
+			break;
+		case '0' ... '9':
+			data = num2seg[ch-'0'];
+			break;
+		case '-':
+		case '\'':
+		case '.':
+		case ' ':
+			for(i=0; i<special2seg_size; i++)
+				if(special2seg[i].ch == ch) break;
+			if(i < special2seg_size) 
+			{
+				data = special2seg[i].value;
+				break;
+			}
+			else
+				return ;
+		default :
+			return ;
+	}
+
+	packet[0] = MICOM_REQ_WR_VFDBUF;
+	packet[1] = pos;
+	packet[2] = data&0xff;
+	packet[3] = (data>>8)&0xff;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	
+	front_send_packet( packet );
+}
+
+void front_puts (const char *s)
+{
+	int a;
+	int pos;
+	unsigned char packet[6];
+	
+	pos = front_seg_num - strlen(s);
+	if( pos < 0 )
+		pos = 0;
+	pos /= 2;
+
+	for( a=0; a<pos; a++ )
+		front_putchar( a, ' ' );
+	for( ; *s && pos<front_seg_num; pos++, s++ )
+		front_putchar( pos, *s );
+	for( ; pos<front_seg_num; pos++ )
+		front_putchar( pos, ' ' );
+
+	packet[0] = MICOM_REQ_WR_VFDUPDATE;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+void front_start_down_mark(void)
+{
+	unsigned char packet[6];
+
+	// clean wait/warn
+	packet[0] = 0xc6;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+	
+	packet[0] = 0xc7;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	packet[0] = 0xdc;
+	packet[1] = 0x2;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+void front_stop_down_mark(void)
+{
+	unsigned char packet[6];
+
+	packet[0] = 0xdc;
+	packet[1] = 1;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+void front_reset()
+{
+	unsigned char packet[6];
+
+	packet[0] = 0xc8;
+	packet[1] = 1;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+}
+
+int front_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+int front_getc ()
+{
+	char ch;
+
+	while (!front_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+int front_check_version()
+{
+#define MICOM_REQ_RD_VER	0xa5
+#define MICOM_ACK_PROG_DATE	0xe9
+#define MICOM_ACK_PROG_MONT	0xea
+#define MICOM_ACK_PROG_YEAR	0xeb
+
+	if(micom_version[0] == 0)
+	{
+#if defined(CONFIG_CUBEREVO)
+		front_get_version();
+#elif defined(CONFIG_CUBEREVO_MINI)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x04;
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		micom_version[0] = 0x08;
+		micom_version[1] = 0x06;
+#elif defined(CONFIG_SLOBBIE_IP)
+		micom_version[0] = 0x05;
+		micom_version[1] = 0x01;
+#else
+#error unknown front type !!
+#endif
+	}
+
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+		)
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		front_seg_num = 12;
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		front_seg_num = 14;
+#endif
+		fntkeys = front_keymap_12dotmatrix; 
+		fntkeynum = ARRAY_SIZE(front_keymap_12dotmatrix);
+		num2seg = num2seg_12dotmatrix;
+		Char2seg = Char2seg_12dotmatrix;
+		special2seg = special2seg_12dotmatrix;
+		special2seg_size = ARRAY_SIZE(special2seg_12dotmatrix);
+			
+		//printf("Board: init %d dotmatrix vfd\n", front_seg_num);
+	}
+	else
+	{
+		/* 13 grid */
+		front_seg_num = 13;
+		fntkeys = front_keymap_13grid;
+		fntkeynum = ARRAY_SIZE(front_keymap_13grid);
+		num2seg = num2seg_13grid;
+		Char2seg = Char2seg_13grid;
+		special2seg = special2seg_13grid;
+		special2seg_size = ARRAY_SIZE(special2seg_13grid);
+		
+		//printf("Board: init %d grid vfd\n", front_seg_num);
+	}
+
+	return 0;
+}
+
+char *front_get_type( void )
+{
+	if(micom_version[0]==0x08 
+#if defined(CONFIG_CUBEREVO)
+		&& micom_version[1]==0x03)
+#elif defined(CONFIG_CUBEREVO_MINI)
+		&& micom_version[1]==0x04)
+#elif defined(CONFIG_CUBEREVO_MINI2)
+		&& micom_version[1]==0x06)
+#else
+		)
+#endif
+	{
+		/* 12 dotmatrix */
+#if defined(CONFIG_CUBEREVO)
+		return "12 dotmatrix vfd front";
+#elif defined(CONFIG_CUBEREVO_MINI) || defined(CONFIG_CUBEREVO_MINI2)
+		return "14 dotmatrix vfd front";
+#endif
+	}
+	else if(micom_version[0]==0x07)
+	{
+		return "13 grid vfd front";
+	}
+	else if(micom_version[0]==0x05)
+	{
+		return "null front";
+	}
+	else 
+	{
+		return "unknown front";
+	}
+}
+
+int front_get_version( void )
+{
+	int i=0, a;
+	unsigned char pack_buf[2];
+	int pack_cnt = 0;
+	unsigned char packet[6];
+	
+	packet[0] = MICOM_REQ_RD_VER;
+	packet[1] = 0x00;
+	packet[2] = 0x00;
+	packet[3] = 0x00;
+	packet[4] = 0x00;
+	packet[5] = 0x00;
+	front_send_packet(packet);	
+
+	while(i<3)
+	{
+		if(front_tstc())
+		{
+			pack_buf[pack_cnt] = front_getc();
+			pack_cnt++;
+
+			if(pack_cnt>= FRONT_PACKCNT)
+			{
+				pack_cnt = 0;
+				switch (pack_buf[0])
+				{
+					case MICOM_ACK_PROG_YEAR:
+						micom_version[0] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_MONT:
+						micom_version[1] = pack_buf[1];
+						i++;
+						break;
+					case MICOM_ACK_PROG_DATE:
+						micom_version[2] = pack_buf[1];
+						i++;
+						break;
+					default:
+						//fdebug( "unknown.\n" );
+						for( a=0; a<FRONT_PACKCNT-1; a++ )
+							pack_buf[a] = pack_buf[a+1];
+						pack_cnt = FRONT_PACKCNT-1;
+						break;
+				}
+			}
+		}
+	}
+
+}
+
+int front_getkey( void )
+{
+	static int pack_cnt = 0;
+	static unsigned char pack_buf[FRONT_PACKCNT];
+	static int front_key = 0;
+	int a;
+	int key = key_null;
+
+	if( front_tstc() )
+	{
+		pack_buf[pack_cnt] = front_getc();
+		//fdebug( "serial get %02x\n", pack_buf[pack_cnt] );
+		pack_cnt ++;
+
+		if( pack_cnt >= FRONT_PACKCNT )
+		{
+			//fdebug( "got packet %02x %02x\n", pack_buf[0], pack_buf[1] );
+			pack_cnt = 0;
+
+			switch( pack_buf[0] )
+			{
+				case FRONT_FRTKEY_H:
+					front_key = pack_buf[1]<<8;
+					break;
+				case FRONT_FRTKEY_L:
+					if( front_key >= 0 )
+					{
+						front_key |= pack_buf[1];
+						//fdebug( "%04x\n", front_key );
+
+						for( a=0; a<fntkeynum; a++ )
+							if( front_key == fntkeys[a].code )
+							{
+								key = fntkeys[a].key;
+								break;
+							}
+
+						front_key = -1;
+					}
+					break;
+				case FRONT_RMCKEY:
+					for( a=0; a<rmckeynum; a++ )
+						if( pack_buf[1] == rmckeys[a].code )
+						{
+							key = rmckeys[a].key;
+							break;
+						}
+					break;
+				default:
+					//fdebug( "unknown.\n" );
+					for( a=0; a<FRONT_PACKCNT-1; a++ )
+						pack_buf[a] = pack_buf[a+1];
+					pack_cnt = FRONT_PACKCNT-1;
+					break;
+			}
+		}
+	}
+
+	return key;
+}
+
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/front_dev.h u-boot-1.3.1/board/dgstation/slobbie-ip/front_dev.h
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/front_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/front_dev.h	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _FRONT_DEV_H
+#define _FRONT_DEV_H
+
+extern int front_init (void);
+extern void front_putc (const char c);
+extern int front_send_packet(const char *packet);
+extern int front_getc (void);
+extern int front_convert( char letter );
+extern int front_send_u2( unsigned char *packet );
+
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/init-slobbie-ip.S u-boot-1.3.1/board/dgstation/slobbie-ip/init-slobbie-ip.S
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/init-slobbie-ip.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/init-slobbie-ip.S	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,328 @@
+	
+#define _SH4REG_ASM_
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+#include "asm/old-pokeloop.h"
+		
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define LMI_SXSR(a)		(a<<26)
+#define LMI_SRCDW(a)		(a<<24)
+#define LMI_SWTR(a)		(a<<23)
+#define LMI_TWTR_DIS(a)		(a<<22)
+#define LMI_SPDL1(a)		(a<<21)
+#define LMI_SPDL0(a)		(a<<12)
+#define LMI_SRFC(a)		(a<<17)
+#define LMI_SCL(a)		(a<<13)
+#define LMI_SRRD(a)		(a<<11)
+#define LMI_SRAS(a)		(a<<8)
+#define	LMI_SRC(a)		(a<<4)
+#define LMI_SRCDR(a)		(a<<2)
+#define LMI_SRP(a)		(a<<0)
+
+#define EMI_DATA0_WE_USE_OE(a)		(a<<26)
+#define EMI_DATA0_WAIT_POL(a)		(a<<25)
+#define EMI_DATA0_LATCH_POINT(a)	(a<<20)
+#define EMI_DATA0_DATA_DRIVE(a)		(a<<15)
+#define EMI_DATA0_BUS_RELEASE(a)	(a<<11)
+#define EMI_DATA0_CS_ACTIVE(a)		(a<<9)
+#define EMI_DATA0_OE_ACTIVE(a)		(a<<7)
+#define EMI_DATA0_BE_ACTIVE(a)		(a<<5)
+#define EMI_DATA0_PORT_SIZE(a)		(a<<3)
+#define EMI_DATA0_DEVICE_TYPE(a)	(a<<0)
+
+#define EMI_DATA1_CYCLE(a)		(a<<31)
+#define EMI_DATA1_ACCESS_READ(a)	(a<<24)
+#define EMI_DATA1_CSE1_READ(a)		(a<<20)
+#define EMI_DATA1_CSE2_READ(a)		(a<<16)
+#define EMI_DATA1_OEE1_READ(a)		(a<<12)
+#define EMI_DATA1_OEE2_READ(a)		(a<<8)
+#define EMI_DATA1_BEE1_READ(a)		(a<<4)
+#define EMI_DATA1_BEE2_READ(a)		(a<<0)
+
+#define EMI_DATA2_CYCLE(a)		(a<<31)
+#define EMI_DATA2_ACCESS_WRITE(a)	(a<<24)
+#define EMI_DATA2_CSE1_WRITE(a)		(a<<20)
+#define EMI_DATA2_CSE2_WRITE(a)		(a<<16)
+#define EMI_DATA2_OEE1_WRITE(a)		(a<<12)
+#define EMI_DATA2_OEE2_WRITE(a)		(a<<8)
+#define EMI_DATA2_BEE1_WRITE(a)		(a<<4)
+#define EMI_DATA2_BEE2_WRITE(a)		(a<<0)
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL0
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x6 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+	/*--------------------------------------------------------------------------
+	 * CLOCKGENA setup PLL1
+	 *--------------------------------------------------------------------------*/
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16)) 	/* 266 */
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xa6 << 8) | (0x0 << 16))	/* 333 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x85 << 8) | (0x1 << 16))	/* 400 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x9 | (0x84 << 8) | (0x1 << 16))	/* 396 */
+	//UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x10 | (0xed << 8) | (0x1 << 16))	/* 399.93 */
+
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	
+
+	/*------------------------------------------------------------------------
+	 * CLOCKGENB
+	 *-----------------------------------------------------------------------*/
+/*
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0xc0de)
+
+	// FPGA clk output 
+	//POKE_LONG(STB7100_CLOCKGENB_OUT_CTRL, 0xb)
+	
+	// CLKGENB SOURCE 
+	//POKE_LONG(STB7100_CLOCKGENB_REFCLK_SEL, 0)
+	
+	// CLK_PIX_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x0)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_SDIV1, 0x1)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_MD1, 0x17)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_PE1, 0x521a)
+	//POKE_LONG(STB7100_CLOCKGENB_FS0_EN1, 0x1)
+	
+	// CLK_DISP_HD 
+	//POKE_LONG(STB7100_CLOCKGENB_DISP_CFG, 0xc79)
+
+	// CLK_GDP2 
+	//POKE_LONG(STB7100_CLOCKGENB_CLK_SRC, 0x7)
+	
+	//POKE_LONG(STB7100_CLOCKGENB_LOCK, 0x0)
+*/	
+	/*-----------------------------------------------------------------------
+	 * SYSCONF setup
+	 *-----------------------------------------------------------------------*/
+	//POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x082FFEFF)
+	
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+	
+	/* Ethernet : 100Mbps, MII */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG07, 0x13<<16)
+
+	/*--------------------*/	
+	/* INTERCONNECT Setup */
+	/* ------------------ */
+	POKE_LONG(0xB9216200 , 0x1)
+	POKE_LONG(0xB9216204 , 0x5)
+	POKE_LONG(0xB9216208 , 0x3)
+	POKE_LONG(0xB921620C , 0x2)
+	POKE_LONG(0xB9216210 , 0x4)
+	
+	POKE_LONG(0xB9243000 , 0x4)
+	POKE_LONG(0xB9243004 , 0x3)
+	POKE_LONG(0xB9243008 , 0x2)
+	POKE_LONG(0xB924300C , 0x1)
+
+	POKE_LONG(0xB9243010 , 0x5)
+
+
+	/*------------------------------------------------------------------------
+	 * LMI SYS setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a025f)    // LSB(31:0)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x00000005)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455) /* 0x35b06455 */
+	
+   	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0C001A00)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003) /* 2. Start clock */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001) /* nop */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* precharge all bank */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402) /* 4. EMSR for DLL */
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133) /* 5. MSR for DLL */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002) /* 6. precharge all bank*/
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004) /* 7. Auto refresh */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033) /* 8. MSR, A8=0 */
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * LMI VID setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x00000005)
+	
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	
+	/*------------------------------------------------------------------------
+	 * EMI setup
+	 *------------------------------------------------------------------------*/
+	POKE_LONG(ST40_EMI_LOCK, 0x0)
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000003)
+	
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000010)
+	
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	
+	/* USB */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(15)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(15)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x3)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* CI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 
+			EMI_DATA0_WE_USE_OE(0x0) 	|
+			EMI_DATA0_WAIT_POL(0x0)		|
+			
+			EMI_DATA0_LATCH_POINT(30)	|
+			EMI_DATA0_DATA_DRIVE(12)		|
+			EMI_DATA0_BUS_RELEASE(50)	|
+
+			EMI_DATA0_CS_ACTIVE(0x3)	|
+			EMI_DATA0_OE_ACTIVE(0x1)	|
+			EMI_DATA0_BE_ACTIVE(0x2)	|
+			EMI_DATA0_PORT_SIZE(0x2)	|
+			EMI_DATA0_DEVICE_TYPE(0x1)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 
+			EMI_DATA1_CYCLE(0x1)		|
+			EMI_DATA1_ACCESS_READ(100)	|
+			EMI_DATA1_CSE1_READ(0)		|
+			EMI_DATA1_CSE2_READ(0)		|
+			EMI_DATA1_OEE1_READ(10)		|
+			EMI_DATA1_OEE2_READ(10)		|
+			EMI_DATA1_BEE1_READ(10)		|
+			EMI_DATA1_BEE2_READ(10)
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 
+			EMI_DATA2_CYCLE(1)		|
+			EMI_DATA2_ACCESS_WRITE(100)	|
+			EMI_DATA2_CSE1_WRITE(0)		|
+			EMI_DATA2_CSE2_WRITE(0)		|
+			EMI_DATA2_OEE1_WRITE(10)		|
+			EMI_DATA2_OEE2_WRITE(10)		|
+			EMI_DATA2_BEE1_WRITE(10)		|
+			EMI_DATA2_BEE2_WRITE(10)	
+			)
+
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+
+	/* PCMCIA CS */ 
+	/*POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* FPGA */ 
+	/*POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x010ffed1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)*/
+	
+	/* Program other EMI registers */
+	POKE_LONG(ST40_EMI_GENCFG, 0x00000000)
+	
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/Makefile u-boot-1.3.1/board/dgstation/slobbie-ip/Makefile
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/Makefile	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,57 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-slobbie-ip.o
+
+COBJS	:= 
+COBJS	+= $(BOARD).o 
+#COBJS	+= sconsole.o
+COBJS 	+= cmd_bootmenu_cmds.o
+COBJS	+= flash_imgs.o
+COBJS	+= front_dev.o
+COBJS	+= video.o
+COBJS	+= ../common/tvmode.o
+COBJS	+= ../common/flash.o
+COBJS	+= ../common/eeprom_db.o
+COBJS	+= ../common/front.o
+COBJS	+= ../common/cmd_bootmenu.o
+COBJS	+= ../common/upgrade.o
+COBJS	+= ../common/upgrade_host.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/sconsole.c u-boot-1.3.1/board/dgstation/slobbie-ip/sconsole.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/sconsole.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/sconsole.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CFG_SH_SCIF_SERIAL) && !defined(CFG_SH_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/sconsole.h u-boot-1.3.1/board/dgstation/slobbie-ip/sconsole.h
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/sconsole.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/sconsole.h	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/slobbie-ip.c u-boot-1.3.1/board/dgstation/slobbie-ip/slobbie-ip.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/slobbie-ip.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/slobbie-ip.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,213 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#include "slobbie-ip/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+#if 1
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	//EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	//EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+#endif
+
+#define PIO_BASE  0xb8020000  
+#define PIO2_BASE  0xb8024000  
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	// PIOx, TX, RX, CTS, RTS
+
+	/* Setup PIO for external device */
+	// PIO 0
+	SET_PIO_PIN(PIO_PORT(0), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(0), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(0), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(0), 7, STPIO_ALT_BIDIR);
+
+	// PIO 1
+	SET_PIO_PIN(PIO_PORT(1), 0, STPIO_ALT_OUT); 	
+	SET_PIO_PIN(PIO_PORT(1), 1, STPIO_ALT_BIDIR);	
+	SET_PIO_PIN(PIO_PORT(1), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(1), 7, STPIO_ALT_BIDIR);
+
+	// PIO 2
+	SET_PIO_PIN(PIO_PORT(2), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 1, STPIO_BIDIR);
+	SET_PIO_PIN(PIO_PORT(2), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(2), 3, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+
+	// PIO 3
+	SET_PIO_PIN(PIO_PORT(3), 0, STPIO_ALT_OUT); 	// SCL
+	SET_PIO_PIN(PIO_PORT(3), 1, STPIO_OUT);		// USB INT
+	SET_PIO_PIN(PIO_PORT(3), 2, STPIO_ALT_BIDIR);	// SDA
+	SET_PIO_PIN(PIO_PORT(3), 3, STPIO_OUT);		// USB_SUSPEND
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(3), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_OUT);		// USB INT spare. TP13이 날아간 보드를 위함.
+
+	// PIO 4
+	SET_PIO_PIN(PIO_PORT(4), 0, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 1, STPIO_BIDIR);
+	//SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+	SET_PIO_PIN(PIO_PORT(4), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(4), 3, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 5, STPIO_BIDIR);
+	
+	SET_PIO_PIN(PIO_PORT(4), 6, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+
+	// PIO 5
+	//SET_PIO_ASC(PIO_PORT(5), 0, 1, 4, 3); /* Serial : don't use CTS/RTS */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3); /* Serial */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);  
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_BIDIR);	// tuner2 license chip
+	//SET_PIO_PIN(PIO_PORT(5), 2, STPIO_ALT_OUT);
+
+
+	//STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+
+}
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide()
+{
+	EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+//static int dgs_tvmode(int timeout);
+int board_init(void)
+{
+	unsigned int i,j;
+	unsigned int *mem;
+	unsigned long sysconf;
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* HDMI enable */
+	//*STB7100_HDMI_CFG = 0x0;
+	//*STB7100_HDMI_CFG = 0x1;
+	//*STB7100_HDMI_SYNC_CFG = (1<<15) | (1<<14) | (1<<13);
+	//*STB7100_HDMI_SYNC_CFG = 0x0; /* OC is inverted */ 
+
+	/* TS path disable */
+	//*((unsigned short *)0xa3800000) = 0xffff;
+
+	configPIO();
+
+	STPIO_SET_PIN(PIO_PORT(4), 6, 1);
+
+	// ethernet reset on
+	STPIO_SET_PIN(PIO_PORT(3), 1, 0);
+
+	udelay(200000);
+
+
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1); // USB HOST, en=0
+
+#ifdef CONFIG_PDIUSB12
+	STPIO_SET_PIN(PIO_PORT(3), PDIUSB_SUSPEND_GPIO, 0); // USB CLIENT, suspend = 0
+#endif
+	
+	front_init();
+
+	/* 현재 하드가 없으므로 초기화 제거 */
+#if defined(CONFIG_CMD_IDE) 
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+	front_check_version();
+
+	front_puts("BOOTING");
+
+	// ethernet reset off
+	STPIO_SET_PIN(PIO_PORT(3), 1, 1);
+	
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf("Board: slobbie-ip (0x%08X)\n",
+			*((unsigned int*)0xB9001000)
+	       );
+	printf("Board: %s\n", front_get_type());
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	front_reset();
+	//stb7100_reset();
+	//NOTREACHED
+	return (0);
+}
+
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/tvmode.c u-boot-1.3.1/board/dgstation/slobbie-ip/tvmode.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/tvmode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/tvmode.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,123 @@
+
+#include <common.h>
+#include <command.h>
+#include "cuberevo/front_dev.h"
+#include "common/front.h"
+#include "common/eeprom_db.h"
+
+#define N_TVMODE	6	
+char *tvmode_name[N_TVMODE] = {
+	"SD-PAL",	"SD-NTSC", 
+	"720P-50", 	"720P-60", 
+	"1080I-50",	"1080I-60"};
+#define MAX_KEY	60
+int presskey[MAX_KEY];
+
+static int dgs_tvmode(int timeout)
+{
+	db_key db_key;
+	char buf[256];
+	int buflen;
+	int res;
+	int mode;
+	int i;
+
+	res = get_keyvalue("tvmode", &db_key);
+	if(res)
+	{
+		return 0;
+	}
+		
+	buflen = sizeof(buf);
+	res = search_item(DB_MAGIC_SIZE, db_key, buf, &buflen, NULL, NULL);
+
+	if(res==1 || res==2) 
+	{
+		mode = 0;
+		sprintf(buf, "0");
+		front_puts("SD-PAL");
+		add_item(db_key_tvmode, buf);
+	}
+	else
+	{
+		mode = buf[0]-'0';
+	}
+
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+
+	long long start_tick = get_ticks();
+	int front_key;
+	int update=1;
+
+	memset(presskey, 0, sizeof(presskey));
+	
+	while( start_tick + get_tbclk()/1000*timeout > get_ticks() )
+	{
+		if(update)
+		{
+			sprintf(buf, "%s",tvmode_name[mode]);
+			front_puts(buf);
+			update = 0;
+		}
+
+		if(front_tstc())
+		{
+			front_key = front_getkey();
+			if( front_key != key_null )
+			{
+				for(i=MAX_KEY-1; i>0; i--)
+					presskey[i] = presskey[i-1];
+				presskey[0]= front_key;
+
+				if((presskey[0]==key_release && presskey[1]==key_up) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_up))
+				{
+					mode++;	
+					if(mode>N_TVMODE-1) mode=0;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_down) || 
+					(presskey[0]==key_front_release && presskey[1]==key_front_down))
+				{
+					mode--;
+					if(mode<0) mode = N_TVMODE-1;
+					update = 1;
+				}
+				else if((presskey[0]==key_release && presskey[1]==key_ok) ||
+					(presskey[0]==key_front_release && presskey[1]==key_front_ok))
+				{
+					goto set_tvmode;
+				}
+				
+			
+				start_tick = get_ticks();
+			}
+		}
+	}
+
+set_tvmode:;
+
+	// mode를 체크해서 eeprom에 세팅
+	if(mode<0 || mode>N_TVMODE-1)
+		mode = 0;
+	sprintf(buf, "%d",mode);
+	add_item(db_key_tvmode, buf);
+
+	front_puts("BOOTING");
+
+	return 0;
+}
+
+static int do_tvmode( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
+{
+	int timeout = 5000;
+	return dgs_tvmode(timeout);
+}
+
+U_BOOT_CMD(
+		set_tvmode, 1, 0, do_tvmode,
+		"set_tvmode - set tv display mode.\n",
+		"timeout(ms)\n"
+		" set tv display mode.\n"
+		);
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/u-boot.lds u-boot-1.3.1/board/dgstation/slobbie-ip/u-boot.lds
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/u-boot.lds	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff -urN u-boot-1.3.1.orig/board/dgstation/slobbie-ip/video.c u-boot-1.3.1/board/dgstation/slobbie-ip/video.c
--- u-boot-1.3.1.orig/board/dgstation/slobbie-ip/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/board/dgstation/slobbie-ip/video.c	2010-12-09 09:42:48.000000000 +0100
@@ -0,0 +1,629 @@
+#include <common.h>
+
+#ifdef CONFIG_CFB_CONSOLE
+
+#include <asm/io_stb1eval.h>
+
+#include <video_fb.h>
+#include "denc.h"
+
+#define TRUE	1
+#define FALSE	(!TRUE)
+
+//#define DENC_MAIN_COMPENSATION_ENABLED
+//#define DENC_MAIN_COMPONSATE_2PIXEL
+//#define DENC_MAIN_COMPONSATE_1_5PIXEL
+//#define DENC_MAIN_COMPONSATE_1PIXEL
+//#define  DENC_MAIN_COMPONSATE_0_5PIXEL
+
+#define UPDATE_REG(reg, mask, cond) ((cond)? ((reg) |= (mask)) : ((reg) &= ~(mask)))
+#define IDFS2(val)    ((U8)(((val) & 0xFF0000)>>16))
+#define IDFS1(val)    ((U8)(((val) & 0xFF00)>>8))
+#define IDFS0(val)    ((U8)((val)  & 0xFF))								   
+
+#define MEM_BASE		0x92000000
+#define GRA_OFFSET		0x00480000
+#define GRA_BASE		(MEM_BASE+GRA_OFFSET)
+#define OSD_DATA_START_OFFSET	0x1000
+#define CLUT			((unsigned short*)(GRA_BASE+sizeof(osdhdr_t)+sizeof(osdhdr_ext1_t)+sizeof(osdhdr_ext2_t)))
+#define IMAGE_BASE		((unsigned char*)(GRA_BASE+OSD_DATA_START_OFFSET))
+
+#define VIDEO_WIDTH		720
+#define VIDEO_HEIGHT_PAL	576
+#define VIDEO_HEIGHT_NTSC	480
+#define WELCOME_BPP		4
+
+#define SCR_WIDTH		600
+#define SCR_HEIGHT_PAL		440
+#define SCR_HEIGHT_NTSC		360
+#define SCR_H_OFFSET		((VIDEO_WIDTH-SCR_WIDTH)/2)
+
+
+#pragma pack(1)
+typedef struct osdhdr
+{
+	unsigned color_table_update:1;
+	unsigned region_hsize:8;
+	unsigned shade_level:4;
+	unsigned high_color:1;
+	unsigned start_row:9;
+	unsigned start_column:9;
+	unsigned link_addr:16;
+	unsigned color_resolution:1;
+	unsigned region_vsize:9;
+	unsigned pixel_resolution:1;
+	unsigned blend_level:4;
+	unsigned force_transparency:1;
+} osdhdr_t;
+
+typedef struct osdhdr_ext1
+{
+	unsigned int link_addr:19;
+	unsigned int link_addr_lsb:4;
+	unsigned int hsb_ext:2;
+	unsigned int h_ext:1;
+	unsigned int dcus:1;
+	unsigned int shade_ext:2;
+	unsigned int dcub:1;
+	unsigned int blend_ext:2;
+} osdhdr_ext1_t;
+
+typedef struct osdhdr_ext2
+{
+	unsigned int horizontal_fir_scaling_control:4;
+	unsigned int tiling_control:2;
+	unsigned int anti_flicker_correction:2;
+	unsigned int reserved1:1;
+	unsigned int color_specific_blending:1;
+	unsigned int header_extecsion3:1;
+	unsigned int reserved2:1;
+	unsigned int chroma_bitmap_link_address_enable:1;
+	unsigned int chroma_bitmap_link_address:19;
+} osdhdr_ext2_t;
+#pragma pack()
+
+struct _welcome_header
+{
+	unsigned long crc;
+	unsigned long data_len;
+	unsigned long compress_type;
+	unsigned long bg_color;
+};
+
+GraphicDevice gGD;
+
+
+
+static int scr_height = SCR_HEIGHT_PAL;
+static int scr_v_offset = (VIDEO_HEIGHT_PAL-SCR_HEIGHT_PAL)/2;
+
+static int video_mode =	STDENC_MODE_PALBDGHI;
+static int device_type = STDENC_DEVICE_TYPE_DENC;
+static int video_height = VIDEO_HEIGHT_PAL;
+static unsigned char denc_ver = 12; /* 7109는 denc version이 12 */
+static unsigned char black_level_pedestal = FALSE;
+static unsigned char black_level_pedestal_aux = FALSE;
+static unsigned char ycbcr_444_input = 0;
+static unsigned char interlaced = 1;
+static unsigned char luma_trap_filter = FALSE;
+static unsigned char luma_trap_filter_aux = FALSE;
+static char chroma_delay = 0;
+static char chroma_delay_aux = 0;
+static unsigned char aux_enc_on = 1;	/* aux encoder on(1)/off */
+static unsigned char square_pixel = 0;
+static unsigned char secam_square_pixel = FALSE;
+static unsigned char field_rate_60hz = 0;
+static unsigned char is_external;
+static unsigned char prog_idfs = FALSE;
+
+static int	cfg[14];
+static int	dfs[3];
+#if 0
+static int denc_config_pal(int mode)
+{
+	cfg[2] &= ~DENC_CFG2_SEL_RST;
+	cfg[2] |= (DENC_CFG2_ENA_RST | DENC_CFG2_ENA_BURST | DENC_CFG2_RST_2F);
+	UPDATE_REG(cfg[2], DENC_CFG2_NO_INTER, interlaced);
+	UPDATE_REG(cfg[3], DENC_CFG3_ENA_TRFLT, luma_trap_filter);
+
+	if(denc_ver<10)
+	{
+		/* TODO : not implemented yet */
+	}
+	else
+	{
+		cfg[3] |= DENC_CFG3_DELAY_ENABLE;
+		cfg[9] &= DENC_CFG9_MASK_DELAY;
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[9] |= DENC_CFG9_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayV10More[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(aux_enc_on)
+	{
+		cfg[12] |= DENC_CFG12_AUX_DEL_EN;
+		UPDATE_REG(cfg[12], DENC_CFG12_AUX_ENTRAP, luma_trap_filter);
+		cfg[11] &= DENC_CFG11_AUX_MASK_DEL;
+
+#if	defined(DENC_MAIN_COMPONSATE_2PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M2;
+#elif	defined(DENC_MAIN_COMPONSATE_1_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1_5;
+#elif	defined(DENC_MAIN_COMPONSATE_1PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M1;
+#elif	defined(DENC_MAIN_COMPONSATE_0_5PIXEL)
+		cfg[11] |= DENC_CFG11_AUX_DELAY_M0_5;
+#else
+		cfg[9] |= ChromaDelayAux[(chroma_delay-STDENC_MIN_CHROMA_DELAY)/STDENC_STEP_CHROMA_DELAY_V10_MORE];
+#endif
+	}
+
+	if(denc_ver >= 6)
+	{
+		cfg[7] &= ~DENC_CFG7_SECAM;
+		UPDATE_REG(cfg[7], DENC_CFG7_SQ_PIX, square_pixel);
+	}
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+			cfg[0] |= DENC_CFG0_PAL_BDGHI;
+			cfg[1] |= DENC_CFG1_FLT_19;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+			if( denc_ver >= 12 )
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_19;
+				cfg[0] |= DENC_CFG0_HSYNC_POL;
+				if( square_pixel )
+				{
+					dfs[0] = IDFS2(Idfs[NTSCM_443_SQ]);
+					dfs[1] = IDFS1(Idfs[NTSCM_443_SQ]);
+					dfs[2] = IDFS0(Idfs[NTSCM_443_SQ]);
+				}
+			}
+			break;
+		case STDENC_MODE_PALN:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] |= DENC_CFG3_PAL_TRFLT;
+
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALN_C:
+			cfg[0] |= DENC_CFG0_PAL_N;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[PALN_SQ]) ;
+					dfs[1] = IDFS1(Idfs[PALN_SQ]) ;
+					dfs[0] = IDFS0(Idfs[PALN_SQ]) ;
+				}
+			}
+			break;
+		case STDENC_MODE_PALM :
+			cfg[0] |= DENC_CFG0_PAL_M;
+			cfg[1] |= DENC_CFG1_FLT_16;
+			cfg[3] &= ~DENC_CFG3_PAL_TRFLT;
+			if(denc_ver>=12)
+			{
+				cfg[10] |= DENC_CFG10_AUX_FLT_16;
+				if(square_pixel)
+				{
+					dfs[2] = IDFS2(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[1] = IDFS1(Idfs[NTSCM_443_60Hz_SQ]) ;
+					dfs[0] = IDFS0(Idfs[NTSCM_443_60Hz_SQ]) ;
+				}
+			}
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+
+	return 0;
+}
+
+static int denc_init( int mode )
+{ 
+	int reg_shift;
+	/* DENC_Init() */
+
+		/* STDENC_Init() -> Init() */
+
+	aux_enc_on = FALSE;
+	is_external = FALSE;
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_4629 :
+		case STDENC_DEVICE_TYPE_V13  : 
+			reg_shift = 0;
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+		case STDENC_DEVICE_TYPE_7020 :
+			reg_shift = 2;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			reg_shift = 3;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* init by default */
+	device_type 		= STDENC_DEVICE_TYPE_DENC;
+	secam_square_pixel 	= FALSE;
+	luma_trap_filter 	= FALSE;
+	luma_trap_filter_aux	= FALSE;
+	black_level_pedestal	= FALSE;
+	black_level_pedestal_aux	= FALSE;
+
+	/* set DencVersion */
+	denc_ver = 12;
+	
+	switch(device_type)
+	{
+		case STDENC_DEVICE_TYPE_4629 :
+			ycbcr_444_input = TRUE;
+			chroma_delay_aux = -1;
+			is_external = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_DENC :
+		case STDENC_DEVICE_TYPE_V13 :
+			if(denc_ver < 10) chroma_delay = 0;
+			else chroma_delay = -1;
+			if(denc_ver < 12) ycbcr_444_input = FALSE;
+			else
+			{
+				ycbcr_444_input = TRUE;
+				chroma_delay_aux = -1;
+				aux_enc_on = TRUE;
+			}
+			break;
+		case STDENC_DEVICE_TYPE_7015 :
+			chroma_delay = -3;
+			ycbcr_444_input = FALSE;
+			break;
+		case STDENC_DEVICE_TYPE_7020 :
+			chroma_delay = -3;
+			ycbcr_444_input = TRUE;
+			break;
+		case STDENC_DEVICE_TYPE_GX1 :
+			chroma_delay = -1;
+			ycbcr_444_input = TRUE;
+			break;
+		default :
+			debug("[DENC] %s:%d - ???\n",__FUNCTION__,__LINE__);
+	}
+	
+	/* STDENC_Open() : not to do */
+	
+
+	/* DENC_SetMode() */
+	if(video_mode == STDENC_MODE_NTSCM)
+	{
+		interlaced = TRUE;
+		square_pixel = FALSE;
+		field_rate_60hz = FALSE;
+	}
+	else
+	{
+		interlaced = TRUE;
+#if defined(PAL_SECAM_SQUARE)
+		square_pixel = TRUE;
+#else
+		square_pixel = FALSE;
+#endif
+	}
+
+	/* STDENC_SetEncodingMode() */
+	switch (video_mode)
+	{
+		case STDENC_MODE_NTSCM :
+		case STDENC_MODE_NTSCM_J :
+		case STDENC_MODE_NTSCM_443 :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode == STDENC_MODE_NTSCM_J)	black_level_pedestal = FALSE;
+				else black_level_pedestal = TRUE;
+				if(denc_ver < 10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALM :
+		case STDENC_MODE_PALN :
+		case STDENC_MODE_PALN_C :
+			if(square_pixel && denc_ver<6) debug("[DENC] %s:%d - bad parameter\n",
+					__FUNCTION__,__LINE__);
+			else
+			{
+				if(video_mode==STDENC_MODE_PALBDGHI ||
+					video_mode==STDENC_MODE_PALN_C)
+					black_level_pedestal = FALSE;
+				else
+					black_level_pedestal = TRUE;
+				if(denc_ver<10) chroma_delay = 0;
+				else
+				{
+					if(device_type==STDENC_DEVICE_TYPE_7015 ||
+						device_type==STDENC_DEVICE_TYPE_7020)
+						chroma_delay = -3;
+					else
+					{
+						chroma_delay = -1;
+						if(aux_enc_on)
+						{
+							chroma_delay_aux = -1;
+							black_level_pedestal_aux = black_level_pedestal;
+						}
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM :
+			if(denc_ver<6 || (secam_square_pixel && denc_ver<10))
+				debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal = FALSE;
+				luma_trap_filter = TRUE;
+				if(device_type == STDENC_DEVICE_TYPE_7015 ||
+					device_type == STDENC_DEVICE_TYPE_7020)
+					chroma_delay = -3;
+				else
+				{
+					chroma_delay = 0;
+					if(aux_enc_on)
+					{
+						chroma_delay_aux = 0;
+						luma_trap_filter_aux = TRUE;
+					}
+				}
+			}
+			break;
+		case STDENC_MODE_SECAM_AUX :
+			if(denc_ver<12 || !aux_enc_on) debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+			else
+			{
+				black_level_pedestal_aux = FALSE;
+				chroma_delay_aux = 0;
+				luma_trap_filter_aux = TRUE;
+			}
+			break;
+		case STDENC_MODE_NONE :
+		default:
+			debug("[DENC] %s:%d - bad parameter\n", __FUNCTION__,__LINE__);
+	}
+
+	/* stdenc_HALSetEncodingMode() start */
+	
+	/* from src/stdenc/src/hal/denc_hal.c 파일에서 루틴을 가져옴 */
+	cfg[0] = p2_inl(DENC_CFG0);
+	cfg[1] = p2_inl(DENC_CFG1);
+	cfg[2] = p2_inl(DENC_CFG2);
+	cfg[3] = p2_inl(DENC_CFG3);
+	cfg[5] = p2_inl(DENC_CFG5);
+	cfg[6] = p2_inl(DENC_CFG6);
+
+	if(denc_ver >= 6)	cfg[7] = p2_inl(DENC_CFG7);
+	if(denc_ver >= 12)	
+	{
+		cfg[10] = p2_inl(DENC_CFG10);
+		cfg[11] = p2_inl(DENC_CFG11);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		cfg[9] = p2_inl(DENC_09);
+#endif
+	}
+
+	dfs[0] = p2_inl(DENC_IDFS0);
+	dfs[1] = p2_inl(DENC_IDFS1);
+	dfs[2] = p2_inl(DENC_IDFS2);
+		
+	cfg[0] &= DENC_CFG0_MASK_STD;
+	cfg[1] &= DENC_CFG1_MASK_FLT;	
+	UPDATE_REG(cfg[1], DENC_CFG1_SETUP, black_level_pedestal);
+
+	if(denc_ver>=6 && denc_ver<=11)
+	{
+		UPDATE_REG(cfg[2], DENC_CFG2_SEL_444, ycbcr_444_input);
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_YUV, black_level_pedestal);
+	}
+	if(denc_ver>=7)
+	{
+		cfg[5] &= ~DENC_CFG5_SEL_INC;
+	}
+	if(denc_ver>=12)
+	{
+		cfg[10] &= DENC_CFG10_AUX_MSK_FLT;
+		UPDATE_REG(cfg[7], DENC_CFG7_SETUP_AUX, black_level_pedestal);
+	}
+	prog_idfs = FALSE;
+
+	switch( video_mode )
+	{
+		case STDENC_MODE_PALBDGHI :
+		case STDENC_MODE_PALN:
+		case STDENC_MODE_PALN_C:
+		case STDENC_MODE_PALM:
+			denc_config_pal(mode);
+			break;
+		case STDENC_MODE_NTSCM:
+		case STDENC_MODE_NTSCM_J:
+		case STDENC_MODE_NTSCM_443:
+			
+			break;
+		case STDENC_MODE_SECAM:
+		case STDENC_MODE_SECAM_AUX:
+
+			break;
+		case STDENC_MODE_NONE:
+			
+			break;
+
+		default :
+			printf("DENC : not implemented denc mode\n");
+	}
+
+
+	/* Setting common values for all encoding modes */
+	cfg[6] |= DENC_CFG6_RST_SOFT;
+	if(denc_ver>=12) p2_outl(DENC_CFG6, cfg[6]);
+
+	/* write configuration registers */
+	p2_outl(DENC_CFG0, cfg[0]);
+	p2_outl(DENC_CFG1, cfg[1]);
+	if(denc_ver>=6)	p2_outl(DENC_CFG7, cfg[7]);
+	if(denc_ver>=12)	
+	{
+		p2_outl(DENC_CFG10, cfg[10]);
+		p2_outl(DENC_CFG11, cfg[11]);
+		p2_outl(DENC_CFG12, cfg[12]);
+#ifdef DENC_MAIN_COMPENSATION_ENABLED
+		p2_outl(DENC_CFG3, cfg[3]);
+		p2_outl(DENC_CFG9, cfg[9]);
+#endif
+	}
+	if(prog_idfs)
+	{
+		p2_outl(DENC_IDFS2, dfs[2]);
+		p2_outl(DENC_IDFS1, dfs[1]);
+		p2_outl(DENC_IDFS0, dfs[0]);
+	}
+	p2_outl(DENC_CFG2, cfg[2]);
+	p2_outl(DENC_CFG5, cfg[5]);
+	if(device_type == STDENC_DEVICE_TYPE_V13)
+		p2_outl(DENC_CFG6, cfg[6]);
+	if(denc_ver<12)
+		p2_outl(DENC_CFG6, cfg[6]);
+	
+
+	//regcfg0 = (cfg[0] & DENC_CFG0_MASK_SYNC) | (regcfg0&(U8)~DENC_CFG0_MASK_SYNC);
+	
+	/* stdenc_HALSetEncodingMode() end */
+	
+#if 0	
+	cfg = p2_inl(DENC_CFG00);
+	if( mode == DENC_PAL )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0xc0;
+	}
+	else if( mode == DENC_NTSC )
+	{
+		cfg &= ~0xc0;
+		cfg |= 0x80;
+	}
+	else
+	{
+		printf("%s : unsupported video format.\n",__FUNCTION__);
+		return -1;		
+	}
+
+	/* 테스트를 위해서 autotest mode */
+	//printf("DENC H/W ID : 0x%08X", p2_inl(DENC_HWID));
+	//printf("DENC H/W ID : 0x%08X", p2_inl(0xb920c1ac));
+	//cfg |= 0x38;
+	//p2_outl(DENC_CFG00, cfg);
+#endif
+	return 0;
+}
+
+static int vos_init(void)
+{
+
+
+}
+
+static int vmix_init(void)
+{
+#if 0
+GAM_GDPn_CTRL : 칼라포맷 설정
+GAM_GDPn_VPO : GDP viewport start
+GAM_GDPn_VPS : GDP viewport stop
+GAM_GDPn_PML : GDP pixmap memory location
+GAM_GDPn_PMP : GDP pixmap memory pitch
+	------------ link list update : no need to write
+#endif
+
+	// setup compositor
+	GAM_GDPn_PKZ = 0x0000 0000
+	GAM_MIX1_CTRL = 0x8;	// GDP1 enable 
+	GAM_MIX1_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+	GAM_MIX1_CRB = ;	// cross-bar contrlol 
+
+	GAM_MIX2_CTRL = 0x10;	// GDP2 enable
+	GAM_MIX2_AVO = ;	// active video offset
+	GAM_MIX1_AVS = ;	// active video stop
+
+	
+}
+#endif
+void *video_hw_init( void )
+{
+
+//	denc_init(video_mode);
+//	vtg_init();
+	/* 일단 denc쪽만 초기화 */
+	return NULL;
+	
+	
+	memset( &gGD, 0, sizeof(gGD) );
+	gGD.winSizeX = SCR_WIDTH;
+	gGD.winSizeY = scr_height;
+	gGD.gdfBytesPP = 1;
+	gGD.gdfIndex = GDF__8BIT_INDEX;
+	gGD.frameAdrs = (unsigned int)IMAGE_BASE;
+
+	return &gGD;
+}
+
+
+void video_set_lut( unsigned int index,
+		unsigned char r, unsigned char g, unsigned char b )
+{
+	int y, cb, cr;
+#if 0
+	rgb_to_ycbcr( r, g, b, &y, &cb, &cr );
+	CLUT[index] = ((y & 0x3F) << 10) | ((cb & 0xF) << 6) | ((cr & 0xF) << 2);
+#endif
+}
+
+#endif
+
diff -urN u-boot-1.3.1.orig/include/configs/slobbie-ip.h u-boot-1.3.1/include/configs/slobbie-ip.h
--- u-boot-1.3.1.orig/include/configs/slobbie-ip.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1/include/configs/slobbie-ip.h	2010-12-09 09:43:05.000000000 +0100
@@ -0,0 +1,440 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#ifndef INPUT_CLOCK_RATE
+#define INPUT_CLOCK_RATE 	27
+#endif
+
+#define CONFIG_SH4    		1            	/* This is an SH4 CPU    	*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX    		/* its an SH4-202		*/
+#define	CONFIG_SLOBBIE_IP		1
+#define P_CLOCK_RATE     	66370000     	/* clock rate for CSP    	*/
+//#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+//#define DEBUG 1
+//#define FLASH_DEBUG
+
+/* big endian */
+//#define ST40_BIG_ENDIAN			
+//#define __BIG_ENDIAN__
+//#define __BIG_ENDIAN
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region	*/
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define FLASH_BASE0_PRELIM	CFG_FLASH_BASE
+#define CFG_FLASH_ERASE_TOUT	20000000
+#define CFG_FLASH_WRITE_TOUT	5000000
+
+//#define CFG_FLASH_SUP_AMD
+#define CFG_FLASH_SUP_SPA	/* spansion is same with AMD */
+#define CFG_FLASH_SUP_STM
+#define CFG_FLASH_SUP_MX
+
+#define CFG_FLASH_SUP_STM_29W640DT
+
+//#define CFG_FLASH_SUP_SPA_S29GL064MR3	/* top type. */
+#define CFG_FLASH_SUP_SPA_S29GL064MR4	/* bottom type. */
+#define CFG_FLASH_SUP_SPA_S29GL128N	/* uniform 16MB */
+#define CFG_FLASH_SUP_SPA_S29GL256N	/* uniform 32MB */
+
+#define CFG_FLASH_SUP_MX_29LV640MT	/* top type. this is same with SPA_S29GL064MR3 */
+#define CFG_FLASH_SUP_MX_29LV640DT
+
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000 
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB KB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START   	0x92000000 //CFG_SDRAM_BASE
+#define CFG_MEMTEST_END     	0x94000000 //(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD slobbie-ip
+#define CONFIG_DGS_ETHADDR		"00:13:18:00:00:00"
+#define CONFIG_DGS_ETHADDR_HEADER_LEN	9	// "00:13:18:" 의 길이
+
+//#define CONFIG_BOOTARGS "console=ttyAS1,115200 mem=36m panic=3 root=/dev/mtdblock3 bigphysarea=1300"
+#define CONFIG_BOOTARGS "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 bigphysarea=2000 quiet"
+#define CONFIG_BOOTARGS_NETUPG "console=ttyAS1,115200 panic=3 root=/dev/mtdblock3 quiet"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"menu_timeout=echo booting...;front_puts \"booting\";boot\0" \
+	"menu_serialbreak=echo entering boot loader console.;front_puts \"console\"\0" \
+	"menu_upgusb=setenv stdout vga;setenv stderr vga;if usbupg; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_upgusbhost=setenv stdout vga;setenv stderr vga;if usbupghost; then reset; else echo Oops...; echo You can debug through serial port.; fi\0" \
+	"menu_hddfmt=setenv bootargs $bootargs format_hdd=1;front_puts \"format hdd\";boot\0" \
+	"menu_debugmode=setenv bootargs $bootargs debug debug_app=1;front_puts \"debug shell\";boot\0" \
+	"menu_upgnet=setenv bootargs " XSTR(CONFIG_BOOTARGS_NETUPG) " factory_update=1;front_puts \"net upg\";boot\0" \
+	"menu_tvmode=set_tvmode;boot\0" \
+	"serial#=slobbie-ip debugging\0" \
+	"bootcmd=bootm a0060000\0" \
+	"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+	"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+	"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+	"monitor_sec=1:0\0" \
+	"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+	"unprot=" \
+	"protect off $monitor_sec\0" \
+	"update=" \
+	"erase $monitor_sec;" \
+	"cp.b $load_addr $monitor_base $monitor_len;" \
+	"protect on $monitor_sec\0" 
+#if 1
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\";  fi; bootmenu"
+#else
+#define CONFIG_PREBOOT 	"if edb toenv ethaddr; then echo \"Setup mac address.\"; else echo \"Use default mac address.\"; setenv ethaddr " XSTR(CONFIG_DGS_ETHADDR) "; fi;" \
+			"bootmenu"
+#endif
+
+#if 0
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#else
+#define CONFIG_COMMANDS	(CONFIG_CMD_DFL | \
+		CFG_CMD_ASKENV  | \
+		CFG_CMD_EEPROM | \
+		CFG_CMD_I2C | \
+		CFG_CMD_NFS | CFG_CMD_PING | CFG_CMD_DHCP |\
+		CFG_CMD_IDE | CFG_CMD_EXT2 )
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NET
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+//#include <cmd_confdefs.h>
+#include <config_cmd_default.h>
+
+/*--------------------------------------------------------------
+ * DGStation specific setting
+ */
+#define CONFIG_DGS_FRONT
+#define CONFIG_DGS_FRONT_PROGRESSBAR	// usb uprade시 프론트에 진행정도를 퍼센트로 보여준다.
+					// flash 전체가 uniform sector인가 확인해야 한다.
+					// board/dgstation/common/upgrade.c에서 sectore_size 확인 필요. 
+#define CONFIG_DGS_BOOTMENU
+
+
+/*-----------------------------------------------------------------------
+ * for eeprom
+ */
+#define CONFIG_DGS_EEPROM_DB
+#define CFG_I2C_EEPROM_ADDR		0x50
+#define CFG_I2C_EEPROM_ADDR_LEN		1
+#define CFG_EEPROM_SIZE			512 //(16*1024)
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS	11	/* 10ms. but give more */
+#define CFG_EEPROM_PAGE_WRITE_BITS	4	/* 64 bytes in one page */
+
+
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#define CONFIG_VIDEO_CLEARSCR
+//#define CFG_VIDEO_CHANGE_SIZE
+//#define CFG_CONSOLE_INFO_QUIET 1
+//#define CFG_VIDEO_START_FUNCTION
+//#define CFG_CONSOLE_IS_IN_ENV	1
+
+/*-----------------------------------------------------------------------
+ * system upgrade API
+ */
+#define CONFIG_DGS_UPGRADE
+#define CFG_DGS_UPGRADE_BUFSTART 0xA5FF0000
+#define CFG_DGS_UPGRADE_BUFSIZE	 0x02010000	/* reserve 32+a MB for usb download buffer. */
+#define MY_VENDOR_ID		0x00444753	// " DGS"
+#define MY_PRODUCT_ID		0x6c6f6f6b	// "look"
+#define MY_HW_MODEL		0x0005C000
+#define MY_HW_VERSION		0x00010000
+
+/*-----------------------------------------------------------------------
+ * USB Client device driver for upgrade.
+ */
+#if 0
+#define CONFIG_PDIUSB12
+#define PDIUSB_IOBASE		0xA2000000
+//#define PDIUSB_USE_INTERRUPT	 // 인터럽트 모드로 쓰려면 이 컨피그를 추가한다.
+#if defined(PDIUSB_USE_INTERRUPT)
+#define PDIUSB_IRQ		60		// Cut C page.229	
+#endif
+#define PDIUSB_SUSPEND_GPIO	3		// 특정 GPIO port 의 몇번째 비트인가	
+#define PDIUSB_AD_ADDRESS	1		
+#define PDIUSB_CONNECT_TIMEOUT	10
+#define PDIUSB_BUSTYPE		unsigned char
+#endif
+
+/*-----------------------------------------------------------------------
+ * serial upgrade function.
+ */
+//#define CONFIG_SERIAL_UPGRADE
+//#define CONFIG_SERIAL_SET2SET
+//#define CFG_SERIALDOWN_HEADER	"slobbie-ip"
+
+#define CONFIG_SOFT_I2C
+//#define CONFIG_FAST_I2C
+
+#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
+#define CFG_I2C_SPEED	100000
+#define CFG_I2C_SLAVE	0xfe
+#endif
+
+#if defined(CONFIG_SOFT_I2C)
+#define I2C_PIN_SDA	1
+#define	I2C_PIN_SCL	0
+#define I2C_PORT	4	// GPIO PORT 4에 연결
+
+#define I2C_DELAY	udelay(2)
+
+#define I2C_ACTIVE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_OUT); } while(0)	
+#define I2C_TRISTATE	do{ SET_PIO_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, STPIO_BIDIR); } while(0)
+
+#define I2C_SDA(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA, v); } while(0)
+#define I2C_SCL(v)	do{ STPIO_SET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SCL, v); } while(0)
+
+#define I2C_READ	(STPIO_GET_PIN(PIO_PORT(I2C_PORT), I2C_PIN_SDA)!=0)
+
+#endif
+
+/*--------------------------------------------------------------
+ * Serial console info 
+ */
+
+#define CONFIG_STM_ASC_SERIAL 	1
+#define CFG_STM_ASC_SERIAL 	1
+
+#define CONFIG_CONS_INDEX 	0
+#define CONFIG_SH_ASC_BASE 	0xb8033000ul /* UART3 */
+#define CFG_STM_ASC_BASE	CONFIG_SH_ASC_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 0
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+	/* cuberevo use RTL8201 phy, and it's not work yet. */
+#define CONFIG_DRIVER_NETSTMAC
+#define CFG_STM_STMAC_BASE		0xb8110000ul
+//#define CONFIG_STMAC_STE10XP
+#define CONFIG_STMAC_RTL8201
+#define CONFIG_CMD_MII
+
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#	define CFG_USB_EN			1
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following */
+
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+/* 일단 하드가 없는데, 컴파일시 에러가 나기 때문에
+   아래 디파인을 추가한다. */
+
+
+#ifdef CONFIG_SH_STB7100_IDE
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xA2800000
+#define CFG_ATA_IDE0_OFFSET  0x00200000
+#define CFG_ATA_REG_OFFSET   0
+#define CFG_ATA_DATA_OFFSET  0
+#define CFG_ATA_STRIDE       0x00020000
+#define CFG_ATA_ALT_OFFSET   -0x0100000
+
+#define CONFIG_DOS_PARTITION
+
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+
+#define	CFG_PIO_MODE	4		
+
+#define CFG_IDE_MAXBUS       1
+#define CFG_IDE_MAXDEVICE    1
+
+#define CFG_ATA_BASE_ADDR    0xB9209800
+#define CFG_ATA_IDE0_OFFSET  0x0
+#define CFG_ATA_REG_OFFSET   0x0
+#define CFG_ATA_DATA_OFFSET  0x0
+#define CFG_ATA_STRIDE       0x4
+#define CFG_ATA_ALT_OFFSET   0x8
+
+#endif
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER         1 
+#define CFG_AUTO_COMPLETE       1
+#define	CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"# > "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2     "> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ           (16 << 20)      /* initial linux memory size 	*/
+//#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_COMMAND_HISTORY
+#define CONFIG_COMMAND_EDIT 
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+//#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+//#define CFG_FLASH_PROTECTION    1	/* use hardware flash protection      */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+#define CFG_MAX_FLASH_SECT	256    	/* max number of sectors on one chip */
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define	CFG_ENV_IS_IN_FLASH	1 
+#define CFG_ENV_OFFSET          CFG_MONITOR_LEN
+#define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE            0x20000
+#define CFG_ENV_SECT_SIZE       0x20000
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.3.1.orig/lib_sh/board.c u-boot-1.3.1/lib_sh/board.c
--- u-boot-1.3.1.orig/lib_sh/board.c	2010-12-09 14:48:09.000000000 +0100
+++ u-boot-1.3.1/lib_sh/board.c	2010-12-09 14:47:47.000000000 +0100
@@ -410,6 +410,11 @@
 		 * otherwise, we enter an infinite-loop of resetting! */
 	*ST40_CPG_WTCSR = 0xA5C2;
 #elif defined(CONFIG_CPU_SUBTYPE_SH4_3XX)	/* SH4-300 series */
+#if defined(CONFIG_SLOBBIE_IP)
+	extern void front_reset();
+
+	front_reset();
+#else
 	/*
 	 * However, on SH4-300 series parts, issuing a TRAP instruction
 	 * with SR.BL=1 should always be sufficient.
@@ -420,6 +425,7 @@
 	asm ("ldc %0, sr": :"r" (sr));
 	asm volatile ("trapa #0");
 #endif
+#endif
 
 	/* wait for H/W reset to kick in ... */
 	for (;;);
diff -urN u-boot-1.3.1.orig/tools/env/Makefile u-boot-1.3.1/tools/env/Makefile
--- u-boot-1.3.1.orig/tools/env/Makefile	2010-12-09 16:10:45.000000000 +0100
+++ u-boot-1.3.1/tools/env/Makefile	2010-12-09 15:59:13.000000000 +0100
@@ -28,6 +28,8 @@
 
 CPPFLAGS := -Wall -DUSE_HOSTCC
 
+CPPFLAGS += -idirafter $(SRCTREE)/include
+
 all:	$(obj)fw_printenv
 
 $(obj)fw_printenv:	$(SRCS) $(HEADERS)
diff -urN u-boot-1.3.1.orig/tools/env/fw_env.c u-boot-1.3.1/tools/env/fw_env.c
--- u-boot-1.3.1.orig/tools/env/fw_env.c	2010-12-09 16:11:25.000000000 +0100
+++ u-boot-1.3.1/tools/env/fw_env.c	2010-12-09 16:09:00.000000000 +0100
@@ -23,6 +23,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -34,6 +35,8 @@
 #include <linux/mtd/mtd.h>
 #include "fw_env.h"
 
+typedef struct erase_info_user erase_info_t;
+
 typedef unsigned char uchar;
 
 #define	CMD_GETENV	"fw_printenv"
